#include "stdafx.h"
#include "FM1xLineDefect.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#define new DEBUG_NEW
#endif

// #if LINESCAN_CAMERA_MODE == 0
// #define IElement(x, y)  *((BYTE *)IAddress + x + 4096 * y)  // 4K  LineScan
// #elif LINESCAN_CAMERA_MODE ==1
// #define IElement(x, y)  *((BYTE *)IAddress + x + 16384 * y) // 16K LineScan
// #elif LINESCAN_CAMERA_MODE ==2
// #define IElement(x, y)  *((BYTE *)IAddress + x + 23360 * y) // 23K LineScan
// #endif

// CNC_6HEAD New Version(LineScan16k X 2)
////////////////////////////////////////////////////////////
CFM1xLineDefect::CFM1xLineDefect()
{
    SingleLine  = new CSingleLine();
    RectEdge    = new CRectEdge();
    Edge        = new CEdge();
    Find1       = new CFind();
    Find2       = new CFind();
	Circle      = new CCircle();
	Find        = new CFind();
	CircleFit   = new CCircleFit();
	Polygon     = new CPolygon();

    FLeftWall    = true ; 
    FTopWall     = true ; 
    FRightWall   = true ; 
    FBottomWall  = true ; 
    FLeftTop     = true ; 
    FRightTop    = true ; 
    FRightBottom = true ; 
    FLeftBottom  = true ; 
	IsMarkBtm    = false;
	IsAllGrind   = false;

	MarkPos.x    = 0.0f;
	MarkPos.y    = 0.0f;

	MarkEndPos.x = 0.0f;
	MarkEndPos.y = 0.0f;

	MarkStrPos.x = 0.0f;
	MarkStrPos.y = 0.0f;

	MarkAng     = 0.0f;

    FBevelIn = false;

	FProcessMode = pmAutoOutLine;

    IRoi = new EROIBW8();

	// Dark Defect 
	DefectPointCount = 0; // 전체 불량 개수 초기화
	ACount           = 0; // 모자모양 불량 개수 초기화
	BCount           = 0; // 젓가락모양 불량 개수 초기화
	CCount           = 0; // 컵모양 불량 개수 초기화
	DCount           = 0;
	C1Count          = 0;
	C2Count          = 0;
	C3Count          = 0;
	C4Count          = 0;
	ABurrCount       = 0;
	BBurrCount       = 0;
	CBurrCount       = 0;
	DBurrCount       = 0;

	// Bridht Defect 
	ACrackCount      = 0;
	BCrackCount      = 0;
	CCrackCount      = 0;
	DCrackCount      = 0;

	// Dark Defect 
	A1CirDeftectCnt  = 0;
	A2CirDeftectCnt  = 0;
    C1CirDeftectCnt  = 0;
	C2CirDeftectCnt  = 0;
	C3CirDeftectCnt  = 0;
	C4CirDeftectCnt  = 0;
	C5CirDeftectCnt  = 0;
	C6CirDeftectCnt  = 0;
	Btm3CirDefectCnt = 0;

	// Bright Defect 
	A1CirCrackCnt    =0;
	A2CirCrackCnt    =0;
	C1CirCrackCnt    =0;
	C2CirCrackCnt    =0;
	C3CirCrackCnt    =0;
	C4CirCrackCnt    =0;
	C5CirCrackCnt    =0;
	C6CirCrackCnt    =0;
	Btm3CirCrackCnt  =0;

	// Cell 정보 
	CELL_A =0;
	CELL_B =0;
	CELL_C =0;
	CELL_D =0;
	CELL_E =0;
	CELL_F =0;
	CELL_G =0;
	CELL_H =0;

	LTDx=0.0f, RTDx=0.0f, RBDx=0.0f, LBDx=0.0f;
	LTDy=0.0f, RTDy=0.0f, RBDy=0.0f, LBDy=0.0f;

	// Corner Data OutPoint Init
	C1Point = NULL;
	C2Point = NULL;
	C3Point = NULL;
	C4Point = NULL;

	// Corner Data InPoint Init
	C1InPoint = NULL;
	C2InPoint = NULL;
	C3InPoint = NULL;
	C4InPoint = NULL;

	// Corner Grind Meaasure StandPoint
	C1MeaPoint = NULL;
	C2MeaPoint = NULL;
	C3MeaPoint = NULL;
	C4MeaPoint = NULL;

	// Circle Data InPoint Init
	A1CirInPoint   = NULL;
	A2CirInPoint   = NULL;
// 	A1PolyInPoint  = NULL;

	C1CirInPoint   = NULL;
	C2CirInPoint   = NULL;
	C3CirInPoint   = NULL;
	C4CirInPoint   = NULL;
	C5CirInPoint   = NULL;
	C6CirInPoint   = NULL;

	// Circle Data OutPoint Init
	A1CirOutPoint   = NULL;
	A2CirOutPoint   = NULL;

	C1CirOutPoint   = NULL;
	C2CirOutPoint   = NULL;
	C3CirOutPoint   = NULL;
	C4CirOutPoint   = NULL;
	C5CirOutPoint   = NULL;
	C6CirOutPoint   = NULL;

	// Narrow Trench In/Out Data 
	Btm3InPoint     = NULL;
	Btm3OutPoint    = NULL;

	// 박리 Circle 검사 InPoint Init 
	A1CirInCrackPoint = NULL;
	A2CirInCrackPoint = NULL;

	C1CirInCrackPoint = NULL;
	C2CirInCrackPoint = NULL;
	C3CirInCrackPoint = NULL;
	C4CirInCrackPoint = NULL;
	C5CirInCrackPoint = NULL;
	C6CirInCrackPoint = NULL;

	// Circle Data StandPoint Init 
	C1CirStandPoint = NULL;
	C2CirStandPoint = NULL;
	C3CirStandPoint = NULL;
	C4CirStandPoint = NULL;
	C5CirStandPoint = NULL;
	C6CirStandPoint = NULL;

	// MultiThresHold 
	ECThresHold       =0;
	EnCapTopThresHold =0;
	EnCapMidThresHold =0;
	EnCapBtmThresHold =0;

	//Cell Inspection 
	LeftEdgeThresHold    =0;
	TopEdgeThresHold     =0;
	RightEdgeThresHold   =0;
	BtmEdgeThresHold     =0;
	CirGrindMeaThresHold =0;
	CorGrindMeaThresHold =0;
	CirGrindInThresHold  =0;
	CorGrindInThresHold  =0;

	//프로그램 실행시 한번 초기화  
	// NOTCH CELL INSPECTION LineData Init
	PreLeftOutLine [0].FP0.x = 0.0f;
	PreLeftOutLine [0].FP0.y = 0.0f;
	PreLeftOutLine [0].FP1.x = 0.0f;
	PreLeftOutLine [0].FP1.y = 0.0f;
	PreLeftInLine  [0].FP0.x = 0.0f;
	PreLeftInLine  [0].FP0.y = 0.0f;
	PreLeftInLine  [0].FP1.x = 0.0f;
	PreLeftInLine  [0].FP1.y = 0.0f;
	PreRightOutLine[0].FP0.x = 0.0f;
	PreRightOutLine[0].FP0.y = 0.0f;
	PreRightOutLine[0].FP1.x = 0.0f;
	PreRightOutLine[0].FP1.y = 0.0f;
	PreRightInLine [0].FP0.x = 0.0f;
	PreRightInLine [0].FP0.y = 0.0f;
	PreRightInLine [0].FP1.x = 0.0f;
	PreRightInLine [0].FP1.y = 0.0f;

	// TrackLine Data Init 
	PreLeftTrackLine [0].FP0.x = 0.0f;
	PreLeftTrackLine [0].FP0.y = 0.0f;
	PreLeftTrackLine [0].FP1.x = 0.0f;
	PreLeftTrackLine [0].FP1.y = 0.0f;

	PreRightTrackLine[0].FP0.x = 0.0f;
	PreRightTrackLine[0].FP0.y = 0.0f;
	PreRightTrackLine[0].FP1.x = 0.0f;
	PreRightTrackLine[0].FP1.y = 0.0f;

	// NOTCH CELL Btm Dis 
// 	BtmLeftDis      = 0.0f;
// 	BtmCenterDis    = 0.0f;
// 	BtmRightDis     = 0.0f;
// 	BtmCenterHeight = 0.0f;
// 	RoundHalfDis    = 0.0f;

	//Notch Circle Dx,Dy 
	ASideCircleWidth    =0.0f;
	ASideCircleHeight   =0.0f;

	CSideCircleWidth    =0.0f;
	CSideCircleHeight   =0.0f;
	CenterCircleWidth   =0.0f;
	CenterCircleHeight  =0.0f;

	Center1CircleWidth  =0.0f;
	Center2CircleWidth  =0.0f;


	// Notch Cell Track Width, Height
	TrackCircleWidth   =0.0f;
	TrackCircleHeight  =0.0f;

	// 외곽라인에서 개별 GrindMark까지 Width,Height 거리
	OutToGrindMarkDis1=0.0f;
	OutToGrindMarkDis2=0.0f;

	// 박리 검출 목적으로 EdgeLine에서 Trap까지 거리 
	dEdgeToTrapLineDis=0.0f;

	// Notch Cell Mark Init 
	dCirOffsetX        =0.0f;
	dCirOffsetY        =0.0f;

	LogUnit.Create(_T("FAVION"));

	FCompanyMode =0; //Customer    Classify Parameter 
	FInspectMode =0; //InspectMode Classify Parameter

	//LHJ 추가 20180808
	RqMode = false;
	WkMode = false;

	// Corner 연마검사 여부 확인 
	IsCornerTop = false;
	IsCornerBtm = false;

	// Rect 검사 여부 확인 
	IsRectTop = false;
	IsRectBtm = false;

	// Cell Circle Grind 검사 유무 결정
	IsCircleTop = false;
	IsCircleBtm = false;

	// Narrow Trench In/Out Data 
	IsNarrowTrench = false;

	// Find Dir 
	FindDir  ="";
	MatchDir =""; 

	// Grind Mark Find Score 
	GrindMarkMinScore    =0.0f;
	GrindPadMarkMinScore =0.0f;

	// A_Side AlignMark에서 GrindMark까지 거리 편차값 Init
	AMarkToGrindMarkDvX =0.0f;
	AMarkToGrindMarkDvY =0.0f;

	AMarkToGrindMarkDvX2=0.0f;
	AMarkToGrindMarkDvY2=0.0f;

	for(int k=0; k<9; k++){
		GrindRectSpec[k].DvX =0.0f;
		GrindRectSpec[k].DvX =0.0f;
	}

	OnClearData();
}
CFM1xLineDefect::~CFM1xLineDefect()
{
	delete SingleLine    ;
	delete RectEdge      ;
	delete Edge          ;
    delete Find1         ;
	delete Find2         ;
	delete Circle        ;
	delete Find          ;
	delete CircleFit     ;
}

float CFM1xLineDefect::GetLengthFrLineToPoint(TFPoint P1, TFPoint P2, TFPoint P3)
{
    //--------------------------------------------------------------------------
    // 직선과 한점의 수직한 교차점에 의한 치수 측정
    // 공식 : ax + by + c = 0, (m, n) -> Distance = (ma + nb +c) / sqrt(a*a + b*b)
    //--------------------------------------------------------------------------
    double xDiff = P2.x-P1.x;
    double yDiff = P2.y-P1.y;

    if      (xDiff == 0) return (float)(fabs(P3.x-P1.x));
    else if (yDiff == 0) return (float)(fabs(P3.y-P1.y));

    float m    = (float)(yDiff/xDiff);
    float dist = (float)(fabs((-m*P3.x + P3.y + m*P1.x - P1.y)/sqrt(m*m + 1)));

    return dist;
}
int CFM1xLineDefect::OnExecute(TShape Shape)
{
    FShape = Shape;
    return OnExecute();
}
int CFM1xLineDefect::OnExecute()
{
	if (GImage==NULL         ) { AfxMessageBox(L"Check CFM1xLineDefect OnExecute GImage Memory Allocate"); return false; }
	if (GImage->GetWidth()<1 ) { AfxMessageBox(L"Check CFM1xLineDefect OnExecute GImage Width Size"     ); return false; }
	if (GImage->GetHeight()<1) { AfxMessageBox(L"Check CFM1xLineDefect OnExecute GImage Height Size"    ); return false; }

	IAddress    = GImage->GetImagePtr();
	BufferWidth = GImage->GetWidth   (); //Buffer 크기설정....특적 좌표에서 Pixel 추출시 필요함 
    int Index = 0;
	// 개별 LineEdge 검출전 고객사Cell형태 기준으로 영역별 검사유무 결정해야함   
	// NOTCH CELL 검사 시퀀스 
	if (FShape==shRectH   && FCompanyMode==COM_NOTCH  ) Index = 0;
	if (FShape==shRectS   && FCompanyMode==COM_NOTCH  ) Index = 1;
	if (FShape==shRectC   && FCompanyMode==COM_NOTCH  ) Index = 2;
	// 기존시퀀스랑 Cell형태가 상이할 경우 Company 추가해야함 
    bool l  = false;
    bool t  = false;
    bool r  = false;
    bool b  = false;
    bool lt = false;
    bool rt = false;
    bool rb = false;
    bool lb = false;

    switch (Index) {

        case 0 :
			// RectH 모자모양 
			//------------------------------------------------------------------
			l  = FLeftWall    = true ;
			t  = FTopWall     = true ;
			r  = FRightWall   = true ;
			b  = FBottomWall  = false;
			lt = FLeftTop     = true ;
			rt = FRightTop    = true ;
			rb = FRightBottom = false;
			lb = FLeftBottom  = false;
			break;

        case 1 :
			// RectS : 젓가락 모양
			//------------------------------------------------------------------
			l  = FLeftWall    = true ;
			t  = FTopWall     = false;
			r  = FRightWall   = true ;
			b  = FBottomWall  = false;
			lt = FLeftTop     = false;
			rt = FRightTop    = false;
			rb = FRightBottom = false;
			lb = FLeftBottom  = false;
			break;

        case 2 :
            // RectC : 컵모양
            //------------------------------------------------------------------
			l  = FLeftWall    = true ;
			t  = FTopWall     = false;
			r  = FRightWall   = true ;
			b  = FBottomWall  = true ;
			lt = FLeftTop     = false;
			rt = FRightTop    = false;
			rb = FRightBottom = false;
			lb = FLeftBottom  = false;
			break;
    }
    if(!OnExecute(l, t, r, b, lt, rt, rb, lb)) return false;
    return true;
}
CRect CFM1xLineDefect::OnMerge( CRect ar, CRect br)
{
	CRect r;
	r.left   = (ar.left   < br.left  ) ? ar.left   : br.left  ;
	r.top    = (ar.top    < br.top   ) ? ar.top    : br.top   ;
	r.right  = (ar.right  > br.right ) ? ar.right  : br.right ;
	r.bottom = (ar.bottom > br.bottom) ? ar.bottom : br.bottom;

	return r;
}
/////////////////////////////////////////////////////////////////////////////////////
int CFM1xLineDefect::GetSize(TCorner *lpCorner,TBlob *lpDefect, int Count, int Dv)
{
	bool IsRoof  = false;
	bool IsStart = false;
	CRect Rect;
	Rect.left   = 0;
	Rect.right  = 0;
	Rect.top    = 0;
	Rect.bottom = 0;
	int DefectCount=0;
	int DefectPoint=0;
	const double MinDv =2;
	int PixelValue  =0;
	int PixelCount  =0;
	int PixelPoint  =0;
	int PixelScore  =0;
	float Score     =0.0f;

	// Defect Data 존재유무 판단함 
	for(int i=0; i<Count; i++){
		if(lpCorner[i].Dv>Dv){
			IsStart = true;
			break;
		}
	}

	if(IsStart){	
		for (register int k=0; k<Count; k++) {
			if ( lpCorner[k].Dv >1               ) { IsRoof = true; }
			if ( IsRoof && lpCorner[k].Dv <=MinDv) { 
				if(DefectPoint>3){
					lpDefect[DefectCount].Height = (Rect.bottom - Rect.top);
					lpDefect[DefectCount].Width  = (Rect.right - Rect.left);

					// 내부 Pixel Data 축출 
					PixelCount =0; PixelPoint=0; 
					for(int n=Rect.top+1 ; n<Rect.bottom-1; n++){
						for(int m=Rect.left+1; m<Rect.right-1 ; m++){
//							if(m<=0 || n<=0 || m>FrameImgW || n>FrameImgH) continue;
							PixelValue = IElement(m,n);
							if(PixelValue < ECThresHold) PixelCount++;
							PixelPoint++;
						}
					}
					Score  = (((float)PixelCount/(float)PixelPoint)*100);
					if(Score>10){
						lpDefect[DefectCount].P.x    =  (float)Rect.left;
						lpDefect[DefectCount].P.y    =  (float)(Rect.top +ImageHeight);
						lpDefect[DefectCount].Round  =  PixelCount;
						DefectCount++;
					}
				}
				DefectPoint=0;
				IsRoof = false; 
			}
			
			if (IsRoof) {
				Rect.left   = Rect.left  <lpCorner[k].P.x && Rect.left!=0 ? Rect.left   :(long) lpCorner[k].P.x;
				Rect.top    = Rect.top   <lpCorner[k].P.y && Rect.top !=0 ? Rect.top    :(long) lpCorner[k].P.y;
				Rect.right  = Rect.right >lpCorner[k].P.x                 ? Rect.right  :(long) lpCorner[k].P.x;
				Rect.bottom = Rect.bottom>lpCorner[k].P.y                 ? Rect.bottom :(long) lpCorner[k].P.y;
				DefectPoint++;
			}
			else {
				Rect.left   = 0;
				Rect.top    = 0;
				Rect.right  = 0;
				Rect.bottom = 0;
			}
		
		}
	}
	return DefectCount;
}
int CFM1xLineDefect::GetCircleCrackSize(TCircle *lpCircle,TBlob *lpDefect, int Count, int Dis, double CirDiameter, TFPoint Center, bool IsInCircle)
{
	bool IsRoof   = false;
	bool IsStart  = false;
	bool IsFlagCh = true ; 
	CRect Rect;
	Rect.left   = 0;
	Rect.right  = 0;
	Rect.top    = 0;
	Rect.bottom = 0;
	int DefectCount=0;
	int DefectPoint=0;
	// 	const double MinDv =0.5;
	int MinDis = Dis;
	int PixelValue  =0;
	int PixelCount  =0;
	int PixelPoint  =0;
	int PixelScore  =0;
	float Score     =0.0f;

	int DefectWidth  =0;
	int DefectHeight =0;
	double MaxDis    =0.0f;

	TFPoint StaPos(0.0f, 0.0f);
	TFPoint EndPos(0.0f, 0.0f);
	TFPoint MaxPos(0.0f, 0.0f);
	int     MaxCount=0;
	float   PointDis =0.0f;

	// 꽃 박리와 반원형 박리 구별 목적 필요한 변수  
	TFPoint LTPoint(0.0f, 0.0f);
	TFPoint RTPoint(0.0f, 0.0f);
	TFPoint LBPoint(0.0f, 0.0f);
	TFPoint RBPoint(0.0f, 0.0f);
	double CenDisLTPos =0.0f;
	double CenDisRTPos =0.0f;
	double CenDisLBPos =0.0f;
	double CenDisRBPos =0.0f;

	// Defect Data 존재유무 판단g 
	if(Count>5) IsStart = true;

	if(IsStart){	
		for (register int k=0; k<Count; k++) {
			if ( lpCircle[k].P.x!=0.0f && lpCircle[k].P.y!=0.0f && IsFlagCh) {   // 1이상 큰 정수부터 가능함 즉....2부터.....
				IsRoof = true;
				IsFlagCh = false ;
				StaPos.x = lpCircle[k].P.x;
				StaPos.y = lpCircle[k].P.y;
				PointDis =0.0f;
			} 
			if(k>1       ) PointDis = Math.GetLength(lpCircle[k-1].P,lpCircle[k].P);
			if(k==Count-1) PointDis = MinDis+1;

			if (IsRoof && PointDis >MinDis) { 
					// 내부 Pixel Data 축출 
				PixelCount =0, PixelPoint=0, PixelScore=5, Score =0.0f;
				for(int n=Rect.top ; n<Rect.bottom; n++){
					for(int m=Rect.left; m<Rect.right; m++){
//						if(m<=0 || n<=0 || m>FrameImgW || n>FrameImgH) continue;
						PixelValue = IElement(m,n);
						if(PixelValue > BrokenThresHold) PixelCount++;
						PixelPoint++;
					}
				}
				EndPos.x = lpCircle[k].P.x;
				EndPos.y = lpCircle[k].P.y;

				Score  = (((float)PixelCount/(float)PixelPoint)*100);
				// Circle Defect 내부의 PixelCount 수량을 체크한다 => 오버킬 감소 목적 
				if(Score>PixelScore){
// 						MaxPos.x = lpCircle[MaxCount].P.x;
// 						MaxPos.y = lpCircle[MaxCount].P.y;
					// 꽃 박리와 반원형 박리 구별목적
					LTPoint.x = (float)Rect.left ;  LTPoint.y = (float)Rect.top   ;
					RTPoint.x = (float)Rect.right;  RTPoint.y = (float)Rect.top   ;
					LBPoint.x = (float)Rect.left ;  LBPoint.y = (float)Rect.bottom;
					RBPoint.x = (float)Rect.right;  RBPoint.y = (float)Rect.bottom;

					CenDisLTPos =0.0f;
					CenDisRTPos =0.0f;
					CenDisLBPos =0.0f;
					CenDisRBPos =0.0f;

					// 꽃박리(Peeling) vs 반원형박리(Broken)구별 시퀀스 
					if(CirDiameter!=0.0f){
						if(IsInCircle){ // Cir1, Cir2, Cir5, Cir6
							CenDisLTPos = Math.GetLength(Center,LTPoint);
							CenDisRTPos = Math.GetLength(Center,RTPoint);
							CenDisLBPos = Math.GetLength(Center,LBPoint);						
							CenDisRBPos = Math.GetLength(Center,RBPoint);		
							if(CenDisLTPos>=CirDiameter || CenDisRTPos>=CirDiameter || CenDisLBPos>=CirDiameter || CenDisRBPos>=CirDiameter) lpDefect[DefectCount].LineAttach =1;
						}
						else          {// Cir3, Cir4 
							CenDisLTPos = Math.GetLength(Center,LTPoint);
							CenDisRTPos = Math.GetLength(Center,RTPoint);
							CenDisLBPos = Math.GetLength(Center,LBPoint);						
							CenDisRBPos = Math.GetLength(Center,RBPoint);		
							if(CenDisLTPos<=CirDiameter || CenDisRTPos<=CirDiameter || CenDisLBPos<=CirDiameter || CenDisRBPos<=CirDiameter) lpDefect[DefectCount].LineAttach =1;
						}
					}

					lpDefect[DefectCount].Rect.left    = Rect.left  ;
					lpDefect[DefectCount].Rect.top     = Rect.top   ;
					lpDefect[DefectCount].Rect.right   = Rect.right ; 
					lpDefect[DefectCount].Rect.bottom  = Rect.bottom;

					lpDefect[DefectCount].Height       = (Rect.bottom - Rect.top );
					lpDefect[DefectCount].Width        = (Rect.right  - Rect.left);

// 					lpDefect[DefectCount].Ver_Dis      = lpCircle[MaxCount].Dv        ;
// 					lpDefect[DefectCount].Hor_Dis      = Math.GetLength(StaPos,EndPos);

					lpDefect[DefectCount].Ver_Dis      = lpDefect[DefectCount].Height;
					lpDefect[DefectCount].Hor_Dis      = lpDefect[DefectCount].Width ;

					lpDefect[DefectCount].P.x       =  (float) Rect.left;
					lpDefect[DefectCount].P.y       =  (float)(Rect.top +ImageHeight);

					lpDefect[DefectCount].Rect.top     = lpDefect[DefectCount].P.y;
					lpDefect[DefectCount].Rect.bottom  = lpDefect[DefectCount].Rect.top+lpDefect[DefectCount].Height;
					lpDefect[DefectCount].Round        =  PixelCount;
					DefectCount++;
				}
				DefectPoint=0   ;
				IsRoof   = false; 
				IsFlagCh = true ;
				MaxDis   =0.0f  ;
				MaxCount =0     ; 
			}

			if (IsRoof) { // Bright Point 기준 Rect생성 
// 				if(lpCircle[k].Dv>MaxDis){
// 					MaxDis   = lpCircle[k].Dv;
// 					MaxCount = k             ;
// 				}
				Rect.left   = Rect.left  <lpCircle[k].P.x && Rect.left!=0 ? Rect.left   :(long) lpCircle[k].P.x;
				Rect.top    = Rect.top   <lpCircle[k].P.y && Rect.top !=0 ? Rect.top    :(long) lpCircle[k].P.y;
				Rect.right  = Rect.right >lpCircle[k].P.x                 ? Rect.right  :(long) lpCircle[k].P.x;
				Rect.bottom = Rect.bottom>lpCircle[k].P.y                 ? Rect.bottom :(long) lpCircle[k].P.y;
				DefectPoint++;
			}
			else {
				Rect.left   = 0;
				Rect.top    = 0;
				Rect.right  = 0;
				Rect.bottom = 0;
			}

		}
	}
	return DefectCount;
}
int CFM1xLineDefect::GetCircleSize(TCircle *lpCircle,TBlob *lpDefect, int Count, int Dv) //Mark_Mode Dark Defect 
{
	bool IsRoof   = false;
	bool IsStart  = false;
	bool IsFlagCh = true ; 
	CRect Rect;
	Rect.left   = 0;
	Rect.right  = 0;
	Rect.top    = 0;
	Rect.bottom = 0;
	int DefectCount=0;
	int DefectPoint=0;
// 	const double MinDv =0.5;
	const double MinDv =Dv/2;
	int PixelValue  =0;
	int PixelCount  =0;
	int PixelPoint  =0;
	int PixelScore  =0;
	float Score     =0.0f;

	int DefectWidth  =0;
	int DefectHeight =0;
	double MaxDis    =0.0f;
     
	TFPoint StaPos(0.0f, 0.0f);
	TFPoint EndPos(0.0f, 0.0f);
	TFPoint MaxPos(0.0f, 0.0f);
	int     MaxCount=0;

	// Defect Data 존재유무 판단함 
	for(int i=0; i<Count; i++){
		if(lpCircle[i].Dv>Dv){
			IsStart = true;
			break;
		}
	}

	if(IsStart){	
		for (register int k=0; k<Count; k++) {
			if ( lpCircle[k].Dv >1 && IsFlagCh) {   // 1이상 큰 정수부터 가능함 즉....2부터.....
				IsRoof = true;
				IsFlagCh = false ;
				StaPos.x = lpCircle[k].P.x;
				StaPos.y = lpCircle[k].P.y;
		    } 

			if ( IsRoof && lpCircle[k].Dv <=1 && DefectPoint>3) { 
				if(DefectPoint>3){
					// 내부 Pixel Data 축출 
					PixelCount =0, PixelPoint=0, PixelScore=45, Score =0.0f;
					for(int n=Rect.top+1 ; n<Rect.bottom-1; n++){
						for(int m=Rect.left+1; m<Rect.right-1 ; m++){
//							if(m<=0 || n<=0 || m>FrameImgW || n>FrameImgH) continue;
							PixelValue = IElement(m,n);
							if(PixelValue < EnCapBtmThresHold) PixelCount++;
							PixelPoint++;
						}
					}
					EndPos.x = lpCircle[k].P.x;
					EndPos.y = lpCircle[k].P.y;

					Score  = (((float)PixelCount/(float)PixelPoint)*100);
					// Circle Defect 내부의 PixelCount 수량을 체크한다 => 오버킬 감소 목적 
					if(Score>PixelScore){
						MaxPos.x = lpCircle[MaxCount].P.x;
						MaxPos.y = lpCircle[MaxCount].P.y;

						lpDefect[DefectCount].Rect.left    = Rect.left  ;
						lpDefect[DefectCount].Rect.top     = Rect.top   ;
						lpDefect[DefectCount].Rect.right   = Rect.right ; 
						lpDefect[DefectCount].Rect.bottom  = Rect.bottom;

						lpDefect[DefectCount].Height      = (Rect.bottom - Rect.top );
						lpDefect[DefectCount].Width       = (Rect.right  - Rect.left);

						lpDefect[DefectCount].Ver_Dis      = lpCircle[MaxCount].Dv        ;
						lpDefect[DefectCount].Hor_Dis      = Math.GetLength(StaPos,EndPos);

						lpDefect[DefectCount].P.x       =  (float)Rect.left;
						lpDefect[DefectCount].P.y       =  (float)(Rect.top +ImageHeight);

						lpDefect[DefectCount].Rect.top     = lpDefect[DefectCount].P.y;
						lpDefect[DefectCount].Rect.bottom  = lpDefect[DefectCount].Rect.top+lpDefect[DefectCount].Height;

						lpDefect[DefectCount].Round  =  PixelCount;
						DefectCount++;
					}
				}
				DefectPoint=0   ;
				IsRoof   = false; 
				IsFlagCh = true ;
				MaxDis   =0.0f  ;
				MaxCount =0     ; 
			}

			if (IsRoof) {
				if(lpCircle[k].Dv>MaxDis){
					MaxDis   = lpCircle[k].Dv;
					MaxCount = k             ;
				}
				Rect.left   = Rect.left  <lpCircle[k].P.x && Rect.left!=0 ? Rect.left   :(long) lpCircle[k].P.x;
				Rect.top    = Rect.top   <lpCircle[k].P.y && Rect.top !=0 ? Rect.top    :(long) lpCircle[k].P.y;
				Rect.right  = Rect.right >lpCircle[k].P.x                 ? Rect.right  :(long) lpCircle[k].P.x;
				Rect.bottom = Rect.bottom>lpCircle[k].P.y                 ? Rect.bottom :(long) lpCircle[k].P.y;
				DefectPoint++;

// 				if(DefectPoint>10 && IsFlagCh){
// 					PixelCount =0, PixelPoint=0, PixelScore=15, Score =0.0f;
// 					for(int n=Rect.top ; n<Rect.bottom; n++){
// 						for(int m=Rect.left; m<Rect.right ; m++){
// 							PixelValue = IElement(m,n);
// 							if(PixelValue < EnCapBtmThresHold) PixelCount++;
// 							PixelPoint++;
// 						}
// 					}
// 					Score  = (((float)PixelCount/(float)PixelPoint)*100);
// 					if(Score<PixelScore){
// 						Rect.left   = 0;
// 						Rect.top    = 0;
// 						Rect.right  = 0;
// 						Rect.bottom = 0;
// 						DefectPoint = 0;
// 						IsFlagCh    = true;
// 					}
// 					else IsFlagCh = false;
// 				}
			}
			else {
				Rect.left   = 0;
				Rect.top    = 0;
				Rect.right  = 0;
				Rect.bottom = 0;
			}

		}
	}
	return DefectCount;
}
int CFM1xLineDefect::GetPolygonSize(TFPoint *PolygonData, TBlob *lpDefect,int TotalCount,int Range, int DefectDv)// Polygon Mode Dark Defect 
{
	bool IsRoof   = false;
	bool IsBadRect= false;
	CRect Rect;
	Rect.left   = 0;
	Rect.right  = 0;
	Rect.top    = 0;
	Rect.bottom = 0;

	int DefectCount=0;
	int DefectPoint=0;

	// Defect 검출시 내부 Quantity Score Calc 
	int PixelValue   =0;
	int PixelCount   =0;
	int PixelPoint   =0;
	int PixelScore   =0;
	float Score      =0.0f;

	int BadRectCount  =0;

	// Defect Merge Value
	const int MgCount=3 ;
	const int xMerge =10;
	const int yMerge =10;

	// 3개의 기준 Point 좌표 
	TFPoint f1(0.0f,0.0f), f2(0.0f, 0.0f), f3(0.0f,0.0f);

	// Polygon Vlaue 
	TFPoint *RangePoint     =NULL;
	float Dv1 =0.0f, Dv2=0.0F, Dv3=0.0f;

	//BadRect Init 
	for(int k=0; k<MAX_POLYGON_DEFECT_COUNT; k++){
		// Polygon Defect Data 
		BadRect[k].Rect.left          =0   ;
		BadRect[k].Rect.top           =0   ;
		BadRect[k].Rect.right         =0   ;
		BadRect[k].Rect.bottom        =0   ;
		BadRect[k].SPoint.x           =0.0f;
		BadRect[k].SPoint.y           =0.0f;
		BadRect[k].EPoint.x           =0.0f;
		BadRect[k].EPoint.y           =0.0f;
		BadRect[k].BadPixelCount      =0   ;

		for(int i=0; i<MAX_POLYGON_DEFECT_POINT; i++){
			BadRect[k].Pixel[i].x =0.0f;
			BadRect[k].Pixel[i].y =0.0f;
		}
	}
	
	// Range범위만큼 Polygon Data Point 분활하여 Defect 유무 Calc
 	for(int k=0; k<TotalCount; k+=Range){
        TFPoint *Q1 = &PolygonData[k];
		int v = (TotalCount-k)/Range;  // Range범위만큼 분활시 나머지 값
		int r = TotalCount%Range    ;  // 전체 픽셀을 Range범위보다 분활시 Range범위보다 작은범위가 남을경우 
		int n = (v>=1)? Range: r    ;  // 전체 픽셀을 Range범위보다 분활시 Range범위보다 작은범위가 남을경우 

		if(v<0) break;

		// Range 범위만큼 분활하여 동적 생성한다 
		if(RangePoint!=NULL) delete [] RangePoint;
		RangePoint = new TFPoint[n];

		// Range범위에서 실제 Polygon Pos 좌표 및 BadPixel Pos좌표 Init 
		for(int z=0; z<n; z++){
			RangePoint[z].x    = Q1[z].x;
			RangePoint[z].y    = Q1[z].y;
		}

		// Find Defct Pixel 
		f1 = RangePoint[0         ]; //Range범위에서 첫번째 Point 좌표
		f2 = RangePoint[(int)(n/2)]; //Range범위에서 가운데 Point 좌표
		f3 = RangePoint[n-1       ]; //Range범위에서 마지막 Point 좌표

		// Rect Data Init 
		Rect.left   =0;
		Rect.top    =0;
		Rect.right  =0;
		Rect.bottom =0;

		IsBadRect  = false;
		PixelCount =0     ;
		for(int i=0; i<n; i++){ // Range영역에서 3개 Point기준 BadRect,BadPixel 정보를 취합한다 
			Dv1 = GetLengthFrLineToPoint(f1, f3, RangePoint[i]);
			Dv2 = GetLengthFrLineToPoint(f1, f2, RangePoint[i]);
			Dv3 = GetLengthFrLineToPoint(f2, f3, RangePoint[i]);

			if(Dv1>DefectDv || Dv2>DefectDv || Dv3>DefectDv){ // Defect Point 존재할경우 
				if(!IsBadRect){ // Defect Point StaPos Data 취합 목적
					IsBadRect = true;
					BadRect[BadRectCount].SPoint.x  = RangePoint[i].x;
					BadRect[BadRectCount].SPoint.y  = RangePoint[i].y;
				}

				if(IsBadRect){
					Rect.left   = Rect.left  <RangePoint[i].x && Rect.left!=0 ? Rect.left   :(long) RangePoint[i].x;
					Rect.top    = Rect.top   <RangePoint[i].y && Rect.top !=0 ? Rect.top    :(long) RangePoint[i].y;
					Rect.right  = Rect.right >RangePoint[i].x                 ? Rect.right  :(long) RangePoint[i].x;
					Rect.bottom = Rect.bottom>RangePoint[i].y                 ? Rect.bottom :(long) RangePoint[i].y;

					BadRect[BadRectCount].Pixel[BadRect[BadRectCount].BadPixelCount] = RangePoint[i]  ;
					BadRect[BadRectCount].EPoint.x                                   = RangePoint[i].x; // End Pos 정보 업데이트 
					BadRect[BadRectCount].EPoint.y                                   = RangePoint[i].y; // End Pos 정보 업데이트 
					BadRect[BadRectCount].BadPixelCount++                                             ;
				}
			}
		}

		if(IsBadRect){
			BadRect[BadRectCount].Rect = Rect;

			float Distance=0.0f;

			if(BadRectCount>0){ // 두번째 BadRect부터 이전 BadRect외 비교하여 거리값 측정 
				Distance = Math.GetLength(BadRect[BadRectCount].SPoint, BadRect[BadRectCount-1].EPoint);
			}

			// 현재 BadRect기준 일정거리 이하이면 이전BadRect데이터와 Merge한다 
			if(((Rect.right - Rect.left)>2) && ((Rect.bottom- Rect.top)>2) && Distance && (Distance<20)){
				BadRect[BadRectCount-1].Rect.left   = BadRect[BadRectCount-1].Rect.left  <Rect.left   ? BadRect[BadRectCount-1].Rect.left   : Rect.left  ;
				BadRect[BadRectCount-1].Rect.top    = BadRect[BadRectCount-1].Rect.top   <Rect.top    ? BadRect[BadRectCount-1].Rect.top    : Rect.top   ;
				BadRect[BadRectCount-1].Rect.right  = BadRect[BadRectCount-1].Rect.right >Rect.right  ? BadRect[BadRectCount-1].Rect.right  : Rect.right ;
				BadRect[BadRectCount-1].Rect.bottom = BadRect[BadRectCount-1].Rect.bottom>Rect.bottom ? BadRect[BadRectCount-1].Rect.bottom : Rect.bottom;

	            BadRect[BadRectCount-1].EPoint = BadRect[BadRectCount].EPoint;

				for(int b=0; b<BadRect[BadRectCount].BadPixelCount; b++){ // 현재 BadPixelData값을 이전 BadRect에 넘겨준다 
					BadRect[BadRectCount-1].Pixel[BadRect[BadRectCount-1].BadPixelCount] = BadRect[BadRectCount].Pixel[b];
                    BadRect[BadRectCount-1].BadPixelCount++;

					// 현재 Data Init 
					BadRect[BadRectCount].Pixel[b].x =0;
					BadRect[BadRectCount].Pixel[b].y =0;
				}
				BadRect[BadRectCount].BadPixelCount =0;
				BadRect[BadRectCount].EPoint.x      =0;
				BadRect[BadRectCount].EPoint.y      =0;
				BadRect[BadRectCount].SPoint.x      =0;
				BadRect[BadRectCount].SPoint.y      =0;
			}
			else  BadRectCount++;
		}
	}

	// Range 범위만큼 분활하여 동적 생성한다 
	// Range 범위기준 마지막 데이터 삭제 
	if(RangePoint!=NULL) delete [] RangePoint;

	// BadRect Data 기준 1차 필터링 및 실제 lpDefect에 데이터 넘겨줌
    if(BadRectCount>0){
		TFPoint Target(0.0f,0.0f);

		for(int k=0; k<BadRectCount; k++){
			IsRoof = false;
			for(int i=0; i<BadRect[k].BadPixelCount; i++){
				f1     = BadRect[k].SPoint  ; // BadRect 시작점 좌표
				f2     = BadRect[k].EPoint  ; // BadRect 종료점 좌표 
				Target = BadRect[k].Pixel[i]; // BddRect 리얼   좌표 
				Dv1    = GetLengthFrLineToPoint(f1, f2, Target);

				if(Dv1>3){
					if(!IsRoof){ // Defect Point StaPos Data 취합 목적
						IsRoof = true;
					}

					if(IsRoof){
						Rect.left   = Rect.left  <Target.x && Rect.left!=0 ? Rect.left   :(long) Target.x;
						Rect.top    = Rect.top   <Target.y && Rect.top !=0 ? Rect.top    :(long) Target.y;
						Rect.right  = Rect.right >Target.x                 ? Rect.right  :(long) Target.x;
						Rect.bottom = Rect.bottom>Target.y                 ? Rect.bottom :(long) Target.y;
						DefectPoint++;
					}
				}
				else                                            { // Defect Point 없을경우 
					if(IsRoof){
						if(DefectPoint>10){
							// 내부 Pixel Data 축출 
							PixelCount =0, PixelPoint=0, PixelScore=5, Score =0.0f;
							for(int n=Rect.top ; n<Rect.bottom; n++){
								for(int m=Rect.left; m<Rect.right; m++){
//									if(m<=0 || n<=0 || m>FrameImgW || n>FrameImgH) continue;
									PixelValue = IElement(m,n);
									if(PixelValue < EnCapBtmThresHold) PixelCount++;
									PixelPoint++;
								}
							}
							Score  = (((float)PixelCount/(float)PixelPoint)*100);
							// Circle Defect 내부의 PixelCount 수량을 체크한다 => 오버킬 감소 목적 
							if(Score>PixelScore){
								lpDefect[DefectCount].Rect.left    = Rect.left  ;
								lpDefect[DefectCount].Rect.top     = Rect.top   ;
								lpDefect[DefectCount].Rect.right   = Rect.right ; 
								lpDefect[DefectCount].Rect.bottom  = Rect.bottom;

								lpDefect[DefectCount].Height       = (Rect.bottom - Rect.top );
								lpDefect[DefectCount].Width        = (Rect.right  - Rect.left);

								lpDefect[DefectCount].Ver_Dis      = lpDefect[DefectCount].Height;
								lpDefect[DefectCount].Hor_Dis      = lpDefect[DefectCount].Width ;

								lpDefect[DefectCount].P.x          =  (float)(Rect.left            );
								lpDefect[DefectCount].P.y          =  (float)(Rect.top +ImageHeight); // 전체 Frame기준 Real좌표 기준으로 변환 

								lpDefect[DefectCount].Rect.top     = lpDefect[DefectCount].P.y;
								lpDefect[DefectCount].Rect.bottom  = lpDefect[DefectCount].Rect.top+lpDefect[DefectCount].Height;
								lpDefect[DefectCount].Round        =  PixelCount;
								DefectCount++;

								// Data Init 
								DefectPoint = 0;
								Rect.left   = 0;
								Rect.top    = 0;
								Rect.right  = 0;
								Rect.bottom = 0;
								IsRoof      = false; 
							}
							else {
								DefectPoint = 0;
								Rect.left   = 0;
								Rect.top    = 0;
								Rect.right  = 0;
								Rect.bottom = 0;
								IsRoof      = false; 
							}
						}
						else { // Defect Count 작을경우 초기화 
							DefectPoint = 0;
							Rect.left   = 0;
							Rect.top    = 0;
							Rect.right  = 0;
							Rect.bottom = 0;
							IsRoof      = false; 
						}
					}
					else      { // 최소 Defect Distance 작을경우 
						Rect.left   = 0;
						Rect.top    = 0;
						Rect.right  = 0;
						Rect.bottom = 0;
					}
				}
			}
		}
	}

	// Defect Data기준 Merge 진행함 
	if(DefectCount>1){ // Defect정보가 최소 2개이상 존재할경우 Merge 시퀀스 진행함
		bool IsxMg=false, IsyMg=false, IsInMg=false;
		CRect r1, r2;
		int sort =0;
		int tmpDDefectCount = DefectCount;

		for(int k=0; k<tmpDDefectCount; k++){
			if(lpDefect[k].Rect.left==0 && lpDefect[k].Rect.top==0 && lpDefect[k].Rect.right==0 && lpDefect[k].Rect.bottom==0) continue;

			for(int l=k+1; l<k+MgCount; l++ ){
				IsxMg = false; IsyMg = false;
				if(l>(tmpDDefectCount-1)) break;
				if(lpDefect[l].Rect.left==0 && lpDefect[l].Rect.top==0 && lpDefect[k].Rect.right==0 && lpDefect[k].Rect.bottom==0) continue;

				r1 = lpDefect[k].Rect;
				r2 = lpDefect[l].Rect; 

				register int HorDist   = abs((r1.left < r2.left) ?  r2.left - r1.right  : r1.left - r2.right );
				register int VerDist   = abs((r1.top  < r2.top ) ?  r2.top  - r1.bottom : r1.top  - r2.bottom);
				IsInMg    = ((r1.left<=r2.left) && (r1.top<r2.top) && (r1.bottom>r2.bottom) && (r1.right >r2.right))? true: false;

				if(HorDist>xMerge && VerDist>yMerge && !IsInMg ) continue;

				IsxMg = (HorDist<xMerge) ? true: false;
				IsyMg = (VerDist<yMerge) ? true: false;

				if((IsxMg && IsyMg) || IsInMg){
					lpDefect[k].Round    += lpDefect[l].Round;
					lpDefect[k].Rect      = OnMerge(lpDefect[k].Rect, lpDefect[l].Rect);
					lpDefect[k].Width     = lpDefect[k].Rect.right  - lpDefect[k].Rect.left;
					lpDefect[k].Height    = lpDefect[k].Rect.bottom - lpDefect[k].Rect.top ;
					lpDefect[k].Hor_Dis   = lpDefect[k].Width ; 
					lpDefect[k].Ver_Dis   = lpDefect[k].Height;
					lpDefect[k].P.x       = (float)(lpDefect[k].Rect.left);
					lpDefect[k].P.y       = (float)(lpDefect[k].Rect.top ); 
					lpDefect[l].Rect.left = lpDefect[l].Rect.top = lpDefect[l].Rect.right = lpDefect[l].Rect.bottom =0;
					DefectCount--;
					k=-1;
					break;
				}
			}
		}
		for(int j=0; j<tmpDDefectCount; j++){
			if(lpDefect[j].Rect.left==0 && lpDefect[j].Rect.top==0 && lpDefect[j].Rect.right==0 && lpDefect[j].Rect.bottom==0) continue;
			lpDefect[sort] = lpDefect[j];
			sort++;
		}
	}
	return DefectCount;
}
int CFM1xLineDefect::GetAvgCellSize(int TopCount, int MidCount, int BtmCount, int AvgMode)
{
	if(MarkStrPos.x==0 || MarkStrPos.y==0 || MarkEndPos.x==0 || MarkEndPos.y==0) return false;

	int nTotalCellSize =0;
	int nCellSize      =0;
	int nAvgCellSize   =0;


	int nCellSizeCount =0;

	if     (AvgMode==0){  // TopCellSizeAvg
		for(int k1=0; k1<TopCount; k1++){
			if(FCellPoint[k1].x==0 || FCellPoint[k1].y==0) continue;
			nCellSize = (int)(Math.GetLengthFrLineToPoint(MarkStrPos, MarkEndPos, FCellPoint[k1]));     
			nTotalCellSize +=nCellSize;
			nCellSizeCount++;
		}
		if(nTotalCellSize>0 && nCellSizeCount>0) nAvgCellSize = nTotalCellSize/nCellSizeCount;
	}
	else if(AvgMode==1){  // MidCellSizeAvg
		for(int k2=TopCount; k2<TopCount+MidCount; k2++){
			if(FCellPoint[k2].x==0 || FCellPoint[k2].y==0) continue;
			nCellSize = (int)(Math.GetLengthFrLineToPoint(MarkStrPos, MarkEndPos, FCellPoint[k2]));     
			nTotalCellSize +=nCellSize;
			nCellSizeCount++;
		}
		if(nTotalCellSize>0 && nCellSizeCount>0) nAvgCellSize = nTotalCellSize/nCellSizeCount;

	}
	else if(AvgMode==2){  // BtmCellSizeAvg
		for(int k3=TopCount+MidCount; k3<TopCount+MidCount+BtmCount; k3++){
			if(FCellPoint[k3].x==0 || FCellPoint[k3].y==0) continue;
			nCellSize = (int)(Math.GetLengthFrLineToPoint(MarkStrPos, MarkEndPos, FCellPoint[k3]));     
			nTotalCellSize +=nCellSize;
			nCellSizeCount++;
		}
		if(nTotalCellSize>0 && nCellSizeCount>0) nAvgCellSize = nTotalCellSize/nCellSizeCount;

	}
	else if(AvgMode==3){  // AllCellSizeAvg
		for(int k4=0; k4<TopCount+MidCount+BtmCount; k4++){
			if(FCellPoint[k4].x==0 || FCellPoint[k4].y==0) continue;
			nCellSize = (int)(Math.GetLengthFrLineToPoint(MarkPos, MarkEndPos, FCellPoint[k4]));     
			nTotalCellSize +=nCellSize;
			nCellSizeCount++;
		}
		if(nTotalCellSize>0 && nCellSizeCount>0) nAvgCellSize = nTotalCellSize/nCellSizeCount;
	}
	return  nAvgCellSize;
}
int CFM1xLineDefect::GetCellSize(int Count)
{
	if(MarkStrPos.x==0 || MarkStrPos.y==0 || MarkEndPos.x==0 || MarkEndPos.y==0) return false;
	if( FCellPoint[Count].x==0 || FCellPoint[Count].y==0)                        return false;
    if(Count>=MAX_DEFECT_POINT)                                                  return false;

	int nCellSize      =0;
	
	nCellSize = (int)(Math.GetLengthFrLineToPoint(MarkStrPos, MarkEndPos, FCellPoint[Count]));     
	return  nCellSize;
}
void CFM1xLineDefect::OnClearData()
{
	for(int k=0; k<MAX_DEFECT_POINT; k++){
		// Cell Inspection Init
		// Dark Defect 
		ADefectPoint[k].Height    =0;
		ADefectPoint[k].Width     =0;
		ADefectPoint[k].Round     =0;
		ADefectPoint[k].P.x       =0;
		ADefectPoint[k].P.y       =0;
		ADefectPoint[k].Ver_Dis   =0;
		ADefectPoint[k].Hor_Dis   =0;
		ADefectPoint[k].LineAttach=0;
		
		BDefectPoint[k].Height    =0;
		BDefectPoint[k].Width     =0;
		BDefectPoint[k].Round     =0;
		BDefectPoint[k].P.x       =0;
		BDefectPoint[k].P.y       =0;
		BDefectPoint[k].Ver_Dis   =0;
		BDefectPoint[k].Hor_Dis   =0;
		BDefectPoint[k].LineAttach=0;
		
		CDefectPoint[k].Height    =0;
		CDefectPoint[k].Width     =0;
		CDefectPoint[k].Round     =0;
		CDefectPoint[k].P.x       =0;
		CDefectPoint[k].P.y       =0;
		CDefectPoint[k].Ver_Dis   =0;
		CDefectPoint[k].Hor_Dis   =0;
		CDefectPoint[k].LineAttach=0;

		
		DDefectPoint[k].Height    =0;
		DDefectPoint[k].Width     =0;
		DDefectPoint[k].Round     =0;
		DDefectPoint[k].P.x       =0;
		DDefectPoint[k].P.y       =0;
		DDefectPoint[k].Ver_Dis   =0;
		DDefectPoint[k].Hor_Dis   =0;
		DDefectPoint[k].LineAttach=0;


		// Bright Defect 
		ACrackPoint[k].Height    =0;
		ACrackPoint[k].Width     =0;
		ACrackPoint[k].Round     =0;
		ACrackPoint[k].P.x       =0;
		ACrackPoint[k].P.y       =0;
		ACrackPoint[k].Ver_Dis   =0;
		ACrackPoint[k].Hor_Dis   =0;
		ACrackPoint[k].LineAttach=0;

		BCrackPoint[k].Height    =0;
		BCrackPoint[k].Width     =0;
		BCrackPoint[k].Round     =0;
		BCrackPoint[k].P.x       =0;
		BCrackPoint[k].P.y       =0;
		BCrackPoint[k].Ver_Dis   =0;
		BCrackPoint[k].Hor_Dis   =0;
		BCrackPoint[k].LineAttach=0;

		CCrackPoint[k].Height    =0;
		CCrackPoint[k].Width     =0;
		CCrackPoint[k].Round     =0;
		CCrackPoint[k].P.x       =0;
		CCrackPoint[k].P.y       =0;
		CCrackPoint[k].Ver_Dis   =0;
		CCrackPoint[k].Hor_Dis   =0;
		CCrackPoint[k].LineAttach=0;

		DCrackPoint[k].Height    =0;
		DCrackPoint[k].Width     =0;
		DCrackPoint[k].Round     =0;
		DCrackPoint[k].P.x       =0;
		DCrackPoint[k].P.y       =0;
		DCrackPoint[k].Ver_Dis   =0;
		DCrackPoint[k].Hor_Dis   =0;
		DCrackPoint[k].LineAttach=0;
		
		C1DefectPoint[k].Height    =0;
		C1DefectPoint[k].Width     =0;
		C1DefectPoint[k].Round     =0;
		C1DefectPoint[k].P.x       =0;
		C1DefectPoint[k].P.y       =0;
		C1DefectPoint[k].Ver_Dis   =0;
		C1DefectPoint[k].Hor_Dis   =0;
		C1DefectPoint[k].LineAttach=0;
		
		C2DefectPoint[k].Height    =0;
		C2DefectPoint[k].Width     =0;
		C2DefectPoint[k].Round     =0;
		C2DefectPoint[k].P.x       =0;
		C2DefectPoint[k].P.y       =0;
		C2DefectPoint[k].Ver_Dis   =0;
		C2DefectPoint[k].Hor_Dis   =0;
		C2DefectPoint[k].LineAttach=0;
		
		C3DefectPoint[k].Height    =0;
		C3DefectPoint[k].Width     =0;
		C3DefectPoint[k].Round     =0;
		C3DefectPoint[k].P.x       =0;
		C3DefectPoint[k].P.y       =0;
		C3DefectPoint[k].Ver_Dis   =0;
		C3DefectPoint[k].Hor_Dis   =0;
		C3DefectPoint[k].LineAttach=0;

		
		C4DefectPoint[k].Height    =0;
		C4DefectPoint[k].Width     =0;
		C4DefectPoint[k].Round     =0;
		C4DefectPoint[k].P.x       =0;
		C4DefectPoint[k].P.y       =0;
		C4DefectPoint[k].Ver_Dis   =0;
		C4DefectPoint[k].Hor_Dis   =0;
		C4DefectPoint[k].LineAttach=0;


		ABurrPoint[k].Height    =0;
		ABurrPoint[k].Width     =0;
		ABurrPoint[k].Round     =0;
		ABurrPoint[k].P.x       =0;
		ABurrPoint[k].P.y       =0;
		ABurrPoint[k].Ver_Dis   =0;
		ABurrPoint[k].Hor_Dis   =0;
		ABurrPoint[k].LineAttach=0;

		BBurrPoint[k].Height    =0;
		BBurrPoint[k].Width     =0;
		BBurrPoint[k].Round     =0;
		BBurrPoint[k].P.x       =0;
		BBurrPoint[k].P.y       =0;
		BBurrPoint[k].Ver_Dis   =0;
		BBurrPoint[k].Hor_Dis   =0;
		BBurrPoint[k].LineAttach=0;

		CBurrPoint[k].Height    =0;
		CBurrPoint[k].Width     =0;
		CBurrPoint[k].Round     =0;
		CBurrPoint[k].P.x       =0;
		CBurrPoint[k].P.y       =0;
		CBurrPoint[k].Ver_Dis   =0;
		CBurrPoint[k].Hor_Dis   =0;
		CBurrPoint[k].LineAttach=0;

		
		DBurrPoint[k].Height    =0;
		DBurrPoint[k].Width     =0;
		DBurrPoint[k].Round     =0;
		DBurrPoint[k].P.x       =0;
		DBurrPoint[k].P.y       =0;
		DBurrPoint[k].Ver_Dis   =0;
		DBurrPoint[k].Hor_Dis   =0;
		DBurrPoint[k].LineAttach=0;

		// Circle Defect Data Init
		// Dark Defect 
		A1CirDefectPoint[k].Height      =0;
		A1CirDefectPoint[k].Width       =0;
		A1CirDefectPoint[k].Round       =0;
		A1CirDefectPoint[k].P.x         =0;
		A1CirDefectPoint[k].P.y         =0;
		A1CirDefectPoint[k].Rect.left   =0;
		A1CirDefectPoint[k].Rect.top    =0;
		A1CirDefectPoint[k].Rect.right  =0;
		A1CirDefectPoint[k].Rect.bottom =0;
		A1CirDefectPoint[k].Ver_Dis     =0;
		A1CirDefectPoint[k].Hor_Dis     =0;
		A1CirDefectPoint[k].LineAttach  =0;

		A2CirDefectPoint[k].Height      =0;
		A2CirDefectPoint[k].Width       =0;
		A2CirDefectPoint[k].Round       =0;
		A2CirDefectPoint[k].P.x         =0;
		A2CirDefectPoint[k].P.y         =0;
		A2CirDefectPoint[k].Rect.left   =0;
		A2CirDefectPoint[k].Rect.top    =0;
		A2CirDefectPoint[k].Rect.right  =0;
		A2CirDefectPoint[k].Rect.bottom =0;
		A2CirDefectPoint[k].Ver_Dis     =0;
		A2CirDefectPoint[k].Hor_Dis     =0;
		A2CirDefectPoint[k].LineAttach  =0;

		C1CirDefectPoint[k].Height      =0;
		C1CirDefectPoint[k].Width       =0;
		C1CirDefectPoint[k].Round       =0;
		C1CirDefectPoint[k].P.x         =0;
		C1CirDefectPoint[k].P.y         =0;
		C1CirDefectPoint[k].Rect.left   =0;
		C1CirDefectPoint[k].Rect.top    =0;
		C1CirDefectPoint[k].Rect.right  =0;
		C1CirDefectPoint[k].Rect.bottom =0;
		C1CirDefectPoint[k].Ver_Dis     =0;
		C1CirDefectPoint[k].Hor_Dis     =0;
		C1CirDefectPoint[k].LineAttach  =0;

		C2CirDefectPoint[k].Height      =0;
		C2CirDefectPoint[k].Width       =0;
		C2CirDefectPoint[k].Round       =0;
		C2CirDefectPoint[k].P.x         =0;
		C2CirDefectPoint[k].P.y         =0;
		C2CirDefectPoint[k].Rect.left   =0;
		C2CirDefectPoint[k].Rect.top    =0;
		C2CirDefectPoint[k].Rect.right  =0;
		C2CirDefectPoint[k].Rect.bottom =0;
		C2CirDefectPoint[k].Ver_Dis     =0;
		C2CirDefectPoint[k].Hor_Dis     =0;
		C2CirDefectPoint[k].LineAttach  =0;

		C3CirDefectPoint[k].Height      =0;
		C3CirDefectPoint[k].Width       =0;
		C3CirDefectPoint[k].Round       =0;
		C3CirDefectPoint[k].P.x         =0;
		C3CirDefectPoint[k].P.y         =0;
		C3CirDefectPoint[k].Rect.left   =0;
		C3CirDefectPoint[k].Rect.top    =0;
		C3CirDefectPoint[k].Rect.right  =0;
		C3CirDefectPoint[k].Rect.bottom =0;
		C3CirDefectPoint[k].Ver_Dis     =0;
		C3CirDefectPoint[k].Hor_Dis     =0;
		C3CirDefectPoint[k].LineAttach  =0;

		C4CirDefectPoint[k].Height      =0;
		C4CirDefectPoint[k].Width       =0;
		C4CirDefectPoint[k].Round       =0;
		C4CirDefectPoint[k].P.x         =0;
		C4CirDefectPoint[k].P.y         =0;
		C4CirDefectPoint[k].Rect.left   =0;
		C4CirDefectPoint[k].Rect.top    =0;
		C4CirDefectPoint[k].Rect.right  =0;
		C4CirDefectPoint[k].Rect.bottom =0;
		C4CirDefectPoint[k].Ver_Dis     =0;
		C4CirDefectPoint[k].Hor_Dis     =0;
		C4CirDefectPoint[k].LineAttach  =0;

		C5CirDefectPoint[k].Height      =0;
		C5CirDefectPoint[k].Width       =0;
		C5CirDefectPoint[k].Round       =0;
		C5CirDefectPoint[k].P.x         =0;
		C5CirDefectPoint[k].P.y         =0;
		C5CirDefectPoint[k].Rect.left   =0;
		C5CirDefectPoint[k].Rect.top    =0;
		C5CirDefectPoint[k].Rect.right  =0;
		C5CirDefectPoint[k].Rect.bottom =0;
		C5CirDefectPoint[k].Ver_Dis     =0;
		C5CirDefectPoint[k].Hor_Dis     =0;
		C5CirDefectPoint[k].LineAttach  =0;

		C6CirDefectPoint[k].Height      =0;
		C6CirDefectPoint[k].Width       =0;
		C6CirDefectPoint[k].Round       =0;
		C6CirDefectPoint[k].P.x         =0;
		C6CirDefectPoint[k].P.y         =0;
		C6CirDefectPoint[k].Rect.left   =0;
		C6CirDefectPoint[k].Rect.top    =0;
		C6CirDefectPoint[k].Rect.right  =0;
		C6CirDefectPoint[k].Rect.bottom =0;
		C6CirDefectPoint[k].Ver_Dis     =0;
		C6CirDefectPoint[k].Hor_Dis     =0;
		C6CirDefectPoint[k].LineAttach  =0;

		Btm3CirDefectPoint[k].Height      =0;
		Btm3CirDefectPoint[k].Width       =0;
		Btm3CirDefectPoint[k].Round       =0;
		Btm3CirDefectPoint[k].P.x         =0;
		Btm3CirDefectPoint[k].P.y         =0;
		Btm3CirDefectPoint[k].Rect.left   =0;
		Btm3CirDefectPoint[k].Rect.top    =0;
		Btm3CirDefectPoint[k].Rect.right  =0;
		Btm3CirDefectPoint[k].Rect.bottom =0;
		Btm3CirDefectPoint[k].Ver_Dis     =0;
		Btm3CirDefectPoint[k].Hor_Dis     =0;
		Btm3CirDefectPoint[k].LineAttach  =0;

		// Bright Defect 
		A1CirCrackPoint[k].Height     =0;
		A1CirCrackPoint[k].Width      =0;
		A1CirCrackPoint[k].Round      =0;
		A1CirCrackPoint[k].P.x        =0;
		A1CirCrackPoint[k].P.y        =0;
		A1CirCrackPoint[k].Rect.left  =0;
		A1CirCrackPoint[k].Rect.top   =0;
		A1CirCrackPoint[k].Rect.right =0;
		A1CirCrackPoint[k].Rect.bottom=0;
		A1CirCrackPoint[k].Ver_Dis    =0;
		A1CirCrackPoint[k].Hor_Dis    =0;
		A1CirCrackPoint[k].LineAttach =0;

		A2CirCrackPoint[k].Height     =0;
		A2CirCrackPoint[k].Width      =0;
		A2CirCrackPoint[k].Round      =0;
		A2CirCrackPoint[k].P.x        =0;
		A2CirCrackPoint[k].P.y        =0;
		A2CirCrackPoint[k].Rect.left  =0;
		A2CirCrackPoint[k].Rect.top   =0;
		A2CirCrackPoint[k].Rect.right =0;
		A2CirCrackPoint[k].Rect.bottom=0;
		A2CirCrackPoint[k].Ver_Dis    =0;
		A2CirCrackPoint[k].Hor_Dis    =0;
		A2CirCrackPoint[k].LineAttach =0;

		C1CirCrackPoint[k].Height     =0;
		C1CirCrackPoint[k].Width      =0;
		C1CirCrackPoint[k].Round      =0;
		C1CirCrackPoint[k].P.x        =0;
		C1CirCrackPoint[k].P.y        =0;
		C1CirCrackPoint[k].Rect.left  =0;
		C1CirCrackPoint[k].Rect.top   =0;
		C1CirCrackPoint[k].Rect.right =0;
		C1CirCrackPoint[k].Rect.bottom=0;
		C1CirCrackPoint[k].Ver_Dis    =0;
		C1CirCrackPoint[k].Hor_Dis    =0;
		C1CirCrackPoint[k].LineAttach =0;

		C2CirCrackPoint[k].Height     =0;
		C2CirCrackPoint[k].Width      =0;
		C2CirCrackPoint[k].Round      =0;
		C2CirCrackPoint[k].P.x        =0;
		C2CirCrackPoint[k].P.y        =0;
		C2CirCrackPoint[k].Rect.left  =0;
		C2CirCrackPoint[k].Rect.top   =0;
		C2CirCrackPoint[k].Rect.right =0;
		C2CirCrackPoint[k].Rect.bottom=0;
		C2CirCrackPoint[k].Ver_Dis    =0;
		C2CirCrackPoint[k].Hor_Dis    =0;
		C2CirCrackPoint[k].LineAttach =0;

		C3CirCrackPoint[k].Height     =0;
		C3CirCrackPoint[k].Width      =0;
		C3CirCrackPoint[k].Round      =0;
		C3CirCrackPoint[k].P.x        =0;
		C3CirCrackPoint[k].P.y        =0;
		C3CirCrackPoint[k].Rect.left  =0;
		C3CirCrackPoint[k].Rect.top   =0;
		C3CirCrackPoint[k].Rect.right =0;
		C3CirCrackPoint[k].Rect.bottom=0;
		C3CirCrackPoint[k].Ver_Dis    =0;
		C3CirCrackPoint[k].Hor_Dis    =0;
		C3CirCrackPoint[k].LineAttach =0;

		C4CirCrackPoint[k].Height     =0;
		C4CirCrackPoint[k].Width      =0;
		C4CirCrackPoint[k].Round      =0;
		C4CirCrackPoint[k].P.x        =0;
		C4CirCrackPoint[k].P.y        =0;
		C4CirCrackPoint[k].Rect.left  =0;
		C4CirCrackPoint[k].Rect.top   =0;
		C4CirCrackPoint[k].Rect.right =0;
		C4CirCrackPoint[k].Rect.bottom=0;
		C4CirCrackPoint[k].Ver_Dis    =0;
		C4CirCrackPoint[k].Hor_Dis    =0;
		C4CirCrackPoint[k].LineAttach =0;

		C5CirCrackPoint[k].Height     =0;
		C5CirCrackPoint[k].Width      =0;
		C5CirCrackPoint[k].Round      =0;
		C5CirCrackPoint[k].P.x        =0;
		C5CirCrackPoint[k].P.y        =0;
		C5CirCrackPoint[k].Rect.left  =0;
		C5CirCrackPoint[k].Rect.top   =0;
		C5CirCrackPoint[k].Rect.right =0;
		C5CirCrackPoint[k].Rect.bottom=0;
		C5CirCrackPoint[k].Ver_Dis    =0;
		C5CirCrackPoint[k].Hor_Dis    =0;
		C5CirCrackPoint[k].LineAttach =0;

		C6CirCrackPoint[k].Height     =0;
		C6CirCrackPoint[k].Width      =0;
		C6CirCrackPoint[k].Round      =0;
		C6CirCrackPoint[k].P.x        =0;
		C6CirCrackPoint[k].P.y        =0;
		C6CirCrackPoint[k].Rect.left  =0;
		C6CirCrackPoint[k].Rect.top   =0;
		C6CirCrackPoint[k].Rect.right =0;
		C6CirCrackPoint[k].Rect.bottom=0;
		C6CirCrackPoint[k].Ver_Dis    =0;
		C6CirCrackPoint[k].Hor_Dis    =0;
		C6CirCrackPoint[k].LineAttach =0;

		Btm3CirCrackPoint[k].Height     =0;
		Btm3CirCrackPoint[k].Width      =0;
		Btm3CirCrackPoint[k].Round      =0;
		Btm3CirCrackPoint[k].P.x        =0;
		Btm3CirCrackPoint[k].P.y        =0;
		Btm3CirCrackPoint[k].Rect.left  =0;
		Btm3CirCrackPoint[k].Rect.top   =0;
		Btm3CirCrackPoint[k].Rect.right =0;
		Btm3CirCrackPoint[k].Rect.bottom=0;
		Btm3CirCrackPoint[k].Ver_Dis    =0;
		Btm3CirCrackPoint[k].Hor_Dis    =0;
		Btm3CirCrackPoint[k].LineAttach =0;
		
		FCellPoint[k].x         =0.0f;
		FCellPoint[k].y         =0.0f;
	}
	// TOP/BTM Broken Inspection StartLine
	
	// Line Position
	LinePosition = 0.0f;

	// Line Data 
	LeftLineData  =0.0f;
	RightLineData =0.0f;

	// NOTCH CELL INSPECTION LineData Init
	LeftOutLine [0].FP0.x = 0.0f;
	LeftOutLine [0].FP0.y = 0.0f;
	LeftOutLine [0].FP1.x = 0.0f;
	LeftOutLine [0].FP1.y = 0.0f;
	LeftInLine  [0].FP0.x = 0.0f;
	LeftInLine  [0].FP0.y = 0.0f;
	LeftInLine  [0].FP1.x = 0.0f;
	LeftInLine  [0].FP1.y = 0.0f;

	TopOutLine [0].FP0.x  = 0.0f;
	TopOutLine [0].FP0.y  = 0.0f;
	TopOutLine [0].FP1.x  = 0.0f;
	TopOutLine [0].FP1.y  = 0.0f;
	TopInLine  [0].FP0.x  = 0.0f;
	TopInLine  [0].FP0.y  = 0.0f;
	TopInLine  [0].FP1.x  = 0.0f;
	TopInLine  [0].FP1.y  = 0.0f;

	RightOutLine[0].FP0.x = 0.0f;
	RightOutLine[0].FP0.y = 0.0f;
	RightOutLine[0].FP1.x = 0.0f;
	RightOutLine[0].FP1.y = 0.0f;
	RightInLine [0].FP0.x = 0.0f;
	RightInLine [0].FP0.y = 0.0f;
	RightInLine [0].FP1.x = 0.0f;
	RightInLine [0].FP1.y = 0.0f;
	// Notch Cell Pattern Line 
	LeftTrackLine [0].FP0.x = 0.0f;
	LeftTrackLine [0].FP0.y = 0.0f;
	LeftTrackLine [0].FP1.x = 0.0f;
	LeftTrackLine [0].FP1.y = 0.0f;

	RightTrackLine[0].FP0.x = 0.0f;
	RightTrackLine[0].FP0.y = 0.0f;
	RightTrackLine[0].FP1.x = 0.0f;
	RightTrackLine[0].FP1.y = 0.0f;

	BtmTrackLine  [0].FP0.x = 0.0f;
	BtmTrackLine  [0].FP0.y = 0.0f;
	BtmTrackLine  [0].FP1.x = 0.0f;
	BtmTrackLine  [0].FP1.y = 0.0f;

	for(int k=0; k<MAX_BTM_COUNT; k++){
		BtmOutLine  [k].FP0.x = 0.0f;
		BtmOutLine  [k].FP0.y = 0.0f;
		BtmOutLine  [k].FP1.x = 0.0f;
		BtmOutLine  [k].FP1.y = 0.0f;
		BtmInLine   [k].FP0.x = 0.0f;
		BtmInLine   [k].FP0.y = 0.0f;
		BtmInLine   [k].FP1.x = 0.0f;
		BtmInLine   [k].FP1.y = 0.0f;
		BtmStandLine[k].FP0.x = 0.0f;
		BtmStandLine[k].FP0.y = 0.0f;
		BtmStandLine[k].FP1.x = 0.0f;
		BtmStandLine[k].FP1.y = 0.0f;
	}

	//Line Data Init
	for(int i=0; i<MAX_LINE_POINT; i++){
		Line[i].FP0.x =0.0f;
		Line[i].FP0.y =0.0f;
		Line[i].FP1.x =0.0f;
		Line[i].FP1.y =0.0f;
	}

	// Grind Rect && Grind Point Init
	for(int k=0; k<MAX_FIND_MARK_COUNT; k++){
		GrindMarkRect      [k].left   =0;
		GrindMarkRect      [k].top    =0;
		GrindMarkRect      [k].right  =0;
		GrindMarkRect      [k].bottom =0;
	    GrindMarkPoint     [k].x      =0.0f;
		GrindMarkPoint     [k].y      =0.0f;
		GrindMarkRectCenter[k].x      =0.0f;
		GrindMarkRectCenter[k].y      =0.0f;
		GrindMarkGradient  [k]        =0.0f;
		GrindMarkScore     [k]        =0.0f;
	}

	// Pad Roi Rect 
	for(int k=0; k<2; k++){
		PadPolyRect[k].left   =0;
		PadPolyRect[k].top    =0;
		PadPolyRect[k].right  =0;
		PadPolyRect[k].bottom =0;
	}

	// Notch Roi Rect 
	for(int k=0; k<6; k++){
		NotchPolyRect[k].left   =0;
		NotchPolyRect[k].top    =0;
		NotchPolyRect[k].right  =0;
		NotchPolyRect[k].bottom =0;
	}

	// CornerData Init
    C1EdgeCount =0;
	C2EdgeCount =0;
	C3EdgeCount =0;
	C4EdgeCount =0;

	// Corner InEdge Count
	C1InEdgeCount =0;
	C2InEdgeCount =0;
	C3InEdgeCount =0;
	C4InEdgeCount =0;

	// Corner Grind Measure Stand Edge Count 
	C1MeaEdgeCount =0;
	C2MeaEdgeCount =0;
	C3MeaEdgeCount =0;
	C4MeaEdgeCount =0;

	// Inspection End
	TopLimitLine = 0 ;
	BtmLimitLine = 0 ;

	// Circle Data Init
	//----------------------------------------------------------------
	// Circle Data 
	for(int k=0; k<MAX_CIRCLE_EDGEPOINT; k++){
		A1CircleData[k].Dis = 0.0f;
		A1CircleData[k].Dv  = 0.0f;
		A1CircleData[k].P.x = 0.0f;
		A1CircleData[k].P.y = 0.0f;

		A2CircleData[k].Dis = 0.0f;
		A2CircleData[k].Dv  = 0.0f;
		A2CircleData[k].P.x = 0.0f;
		A2CircleData[k].P.y = 0.0f;

		C1CircleData[k].Dis = 0.0f;
		C1CircleData[k].Dv  = 0.0f;
		C1CircleData[k].P.x = 0.0f;
		C1CircleData[k].P.y = 0.0f;

		C2CircleData[k].Dis = 0.0f;
		C2CircleData[k].Dv  = 0.0f;
		C2CircleData[k].P.x = 0.0f;
		C2CircleData[k].P.y = 0.0f;

		C3CircleData[k].Dis = 0.0f;
		C3CircleData[k].Dv  = 0.0f;
		C3CircleData[k].P.x = 0.0f;
		C3CircleData[k].P.y = 0.0f;

		C4CircleData[k].Dis = 0.0f;
		C4CircleData[k].Dv  = 0.0f;
		C4CircleData[k].P.x = 0.0f;
		C4CircleData[k].P.y = 0.0f;

		C5CircleData[k].Dis = 0.0f;
		C5CircleData[k].Dv  = 0.0f;
		C5CircleData[k].P.x = 0.0f;
		C5CircleData[k].P.y = 0.0f;

		C6CircleData[k].Dis = 0.0f;
		C6CircleData[k].Dv  = 0.0f;
		C6CircleData[k].P.x = 0.0f;
		C6CircleData[k].P.y = 0.0f;

		Btm3CircleData[k].Dis = 0.0f;
		Btm3CircleData[k].Dv  = 0.0f;
		Btm3CircleData[k].P.x = 0.0f;
		Btm3CircleData[k].P.y = 0.0f;
	}
	// Circle InEdge Point Count
	A1CirInEdgeCount = 0;
	A2CirInEdgeCount = 0;

	C1CirInEdgeCount = 0;
	C2CirInEdgeCount = 0;
	C3CirInEdgeCount = 0;
	C4CirInEdgeCount = 0;
	C5CirInEdgeCount = 0;
	C6CirInEdgeCount = 0;

	// Circle InEdge Point Count
	A1CirOutEdgeCount = 0;
	A2CirOutEdgeCount = 0;

	C1CirOutEdgeCount = 0;
	C2CirOutEdgeCount = 0;
	C3CirOutEdgeCount = 0;
	C4CirOutEdgeCount = 0;
	C5CirOutEdgeCount = 0;
	C6CirOutEdgeCount = 0;

	// 박리불량 검출 Point Count
	A1CirInCrackCount = 0;
	A2CirInCrackCount = 0;
					    
	C1CirInCrackCount = 0;
	C2CirInCrackCount = 0;
	C3CirInCrackCount = 0;
	C4CirInCrackCount = 0;
	C5CirInCrackCount = 0;
	C6CirInCrackCount = 0;

	Btm3CirInCrackCount =0;

	// Bridht Defect 
	ACrackCount      = 0;
	BCrackCount      = 0;
	CCrackCount      = 0;
	DCrackCount      = 0;

	// Circle StandEdge Point Count
	C1CirStandEdgeCount = 0;
	C2CirStandEdgeCount = 0;
	C3CirStandEdgeCount = 0;
	C4CirStandEdgeCount = 0;
	C5CirStandEdgeCount = 0;
	C6CirStandEdgeCount = 0;

	Btm3InEdgeCount     = 0;
	Btm3OutEdgeCount    = 0;

	// Circle Calculate Data Init 
	A1CirDx      = 0.0f;
	A1CirDy      = 0.0f;
	A1CirRound   = 0.0f;
	A2CirDx      = 0.0f;
	A2CirDy      = 0.0f;
	A2CirRound   = 0.0f;

	for(int k=0; k<4; k++){
		A1CirGrindWd [k]= 0.0f;
		A1CirGrindMea[k]= 0.0f;
		A2CirGrindWd [k]= 0.0f;
		A2CirGrindMea[k]= 0.0f;
	}

	C0CirGrindWd = 0.0f; 
	C0CirGrindMea= 0.0f; 
	C1CirDx      = 0.0f;
	C1CirDy      = 0.0f;
	C1CirRound   = 0.0f;
	C1CirGrindWd = 0.0f;
	C1CirGrindMea= 0.0f;
	C2CirDx      = 0.0f;
	C2CirDy      = 0.0f;
	C2CirRound   = 0.0f;
	C2CirGrindWd = 0.0f;
	C2CirGrindMea= 0.0f;
	C3CirDx      = 0.0f;
	C3CirDy      = 0.0f;
	C3CirGrindWd = 0.0f;
	C3CirGrindMea= 0.0f;
	C3CirRound   = 0.0f;
	C4CirDx      = 0.0f;
	C4CirDy      = 0.0f;
	C4CirRound   = 0.0f;
	C4CirGrindWd = 0.0f;
	C4CirGrindMea= 0.0f;
	C5CirDx      = 0.0f;
	C5CirDy      = 0.0f;
	C5CirRound   = 0.0f;
	C5CirGrindWd = 0.0f;
	C5CirGrindMea= 0.0f;
	C6CirDx      = 0.0f;
	C6CirDy      = 0.0f;
	C6CirRound   = 0.0f;
	C6CirGrindWd = 0.0f;
	C6CirGrindMea= 0.0f;
	C7CirGrindWd = 0.0f; 
	C7CirGrindMea= 0.0f; 


	// Trench 가상 GrindMark Point
	TrenchLeftGrindWd   = 0.0f;
	TrenchLeftGrindMea  = 0.0f;
	TrenchRightGrindWd  = 0.0f;
	TrenchRightGrindMea = 0.0f;

	// Circle Center Data Init 
	A1CirCenter.x = 0.0f;
	A1CirCenter.y = 0.0f;
	A2CirCenter.x = 0.0f;
	A2CirCenter.y = 0.0f;

	C1CirCenter.x = 0.0f;
	C1CirCenter.y = 0.0f;
	C2CirCenter.x = 0.0f;
	C2CirCenter.y = 0.0f;
	C3CirCenter.x = 0.0f;
	C3CirCenter.y = 0.0f;
	C4CirCenter.x = 0.0f;
	C4CirCenter.y = 0.0f;
	C5CirCenter.x = 0.0f;
	C5CirCenter.y = 0.0f;
	C6CirCenter.x = 0.0f;
	C6CirCenter.y = 0.0f;

	// Real Circle Center Data Init 
	RealA1CirCenter.x = 0.0f;
	RealA1CirCenter.y = 0.0f;
	RealA2CirCenter.x = 0.0f;
	RealA2CirCenter.y = 0.0f;

	RealC1CirCenter.x = 0.0f;
	RealC1CirCenter.y = 0.0f;
	RealC2CirCenter.x = 0.0f;
	RealC2CirCenter.y = 0.0f;
	RealC3CirCenter.x = 0.0f;
	RealC3CirCenter.y = 0.0f;
	RealC4CirCenter.x = 0.0f;
	RealC4CirCenter.y = 0.0f;
	RealC5CirCenter.x = 0.0f;
	RealC5CirCenter.y = 0.0f;
	RealC6CirCenter.x = 0.0f;
	RealC6CirCenter.y = 0.0f;

	ACircleFit1Center.x = 0.0f;
	ACircleFit1Center.y = 0.0f;
	ACircleFit2Center.x = 0.0f;
	ACircleFit2Center.y = 0.0f;

	CircleFit1Center.x = 0.0f;
	CircleFit1Center.y = 0.0f;
	CircleFit2Center.x = 0.0f;
	CircleFit2Center.y = 0.0f;
	CircleFit3Center.x = 0.0f;
	CircleFit3Center.y = 0.0f;
	CircleFit4Center.x = 0.0f;
	CircleFit4Center.y = 0.0f;
	CircleFit5Center.x = 0.0f;
	CircleFit5Center.y = 0.0f;
	CircleFit6Center.x = 0.0f;
	CircleFit6Center.y = 0.0f;

    CircleFitBtm3Center.x =0.0f;
	CircleFitBtm3Center.y =0.0f;

	CrackACirDiameter1 = 0.0f;
	CrackACirDiameter2 = 0.0f;
	CrackCirDiameter1  = 0.0f;
	CrackCirDiameter2  = 0.0f;
	CrackCirDiameter3  = 0.0f;
	CrackCirDiameter4  = 0.0f;
	CrackCirDiameter5  = 0.0f;
	CrackCirDiameter6  = 0.0f;

	ACirDiameter1 = 0.0f;
	ACirDiameter2 = 0.0f;

	CirDiameter1 = 0.0f;
	CirDiameter2 = 0.0f;
	CirDiameter3 = 0.0f;
	CirDiameter4 = 0.0f;
	CirDiameter5 = 0.0f;
	CirDiameter6 = 0.0f;

	ACirFitDiameter1 = 0.0f;
	ACirFitDiameter2 = 0.0f;

	CirFitDiameter1 = 0.0f;
	CirFitDiameter2 = 0.0f;
	CirFitDiameter3 = 0.0f;
	CirFitDiameter4 = 0.0f;
	CirFitDiameter5 = 0.0f;
	CirFitDiameter6 = 0.0f;

	// Narrow Trench 
	CirFitDiameterBtm3 =0.0f;

	// TrackLine Circle Center Data Init 
	TrackC1CirCenter.x = 0.0f;
	TrackC1CirCenter.y = 0.0f;
	TrackC2CirCenter.x = 0.0f;
	TrackC2CirCenter.y = 0.0f;
	TrackC3CirCenter.x = 0.0f;
	TrackC3CirCenter.y = 0.0f;
	TrackC4CirCenter.x = 0.0f;
	TrackC4CirCenter.y = 0.0f;
	TrackC5CirCenter.x = 0.0f;
	TrackC5CirCenter.y = 0.0f;
	TrackC6CirCenter.x = 0.0f;
	TrackC6CirCenter.y = 0.0f;

	// NOTCH CELL Btm EdgePoint Data Init 
	for(int k=0; k<MAX_BTM_LINE_POINT; k++){
		BtmEdgePoint[k].x =0.0f;
		BtmEdgePoint[k].y =0.0f;
	}

	// NOTCH CELL Top EdgePoint Data Init 
	for(int k=0; k<MAX_TOP_LINE_POINT; k++){
		TopEdgePoint[k].x =0.0f;
		TopEdgePoint[k].y =0.0f;
	}

	// NOTCH Corner Data Init 
	C1CorGrindWd  = 0.0f;
	C1CorGrindMea = 0.0f;
	C2CorGrindWd  = 0.0f;
	C2CorGrindMea = 0.0f;
	C3CorGrindWd  = 0.0f;
	C3CorGrindMea = 0.0f;
	C4CorGrindWd  = 0.0f;
	C4CorGrindMea = 0.0f;

	// NOTCH Btm Grind_Width, Grind_Measure Data Init 
	BtmGrindWidth1   = 0.0f;
	BtmGrindWidth2   = 0.0f;
	BtmGrindWidth3   = 0.0f;
	BtmGrindWidth4   = 0.0f;
	BtmGrindWidth5   = 0.0f;
	BtmGrindWidth6   = 0.0f;
	BtmGrindWidth7   = 0.0f;
	BtmGrindWidth8   = 0.0f;
	BtmGrindWidth9   = 0.0f;
	BtmGrindMeasure1 = 0.0f;
	BtmGrindMeasure2 = 0.0f;
	BtmGrindMeasure3 = 0.0f;
	BtmGrindMeasure4 = 0.0f;
	BtmGrindMeasure5 = 0.0f;
	BtmGrindMeasure6 = 0.0f;
	BtmGrindMeasure7 = 0.0f;
	BtmGrindMeasure8 = 0.0f;
	BtmGrindMeasure9 = 0.0f;

	// Notch Cell TrackLine Data Overlap Init 
	AvgLeftTrackLineDis     =0;
	AvgRightTrackLineDis    =0;
	AvgLeftBtmTrackLineDis  =0;
	AvgRightBtmTrackLineDis =0;
	LeftTrackLineCount      =0;
	RightTrackLineCount     =0;
	TotalLeftTrackDis       =0;
	TotalRightTrackDis      =0;

	// NOTCH 
	// Btm Line Search 시간 단축 목적 
	FEndLine =0;

	// Notch Cell Mark Degree 
	MarkDegree =0.0f;

	// 연마 각도 (Circle)
	SideCirDeg   =0;
	CenterCirDeg =0;

// 	Find->OnLoad(true,FindDir);

	// Notch Cell Size Data Init 
	LeftCellSizeHeight  =0.0f;
	CenCellSizeHeight   =0.0f;
	CenCellSizeWidth    =0.0f;
	NotchCellSizeWidth  =0.0f;
	NotchCellSizeHeight =0.0f;

	// MarkToTopSide Height
	LeftMarkToTopHeight  =0.0f;
	CenMarkToTopHeight   =0.0f;
	RightMarkToTopHeight =0.0f;

	// Center Cell Size  측정시 필요한 데이터 
	TotalCellSizeWidth  =0.0f;
	CenterCellSize      =0.0f;
	TotalCellSizeCount  =0   ;

	// Cell Size 측정 기준
	LeftStaPos.x   =0.0f;
	LeftStaPos.y   =0.0f;
	LeftEndPos.x   =0.0f;
	LeftEndPos.y   =0.0f;
	CenterStaPos.x =0.0f;
	CenterStaPos.y =0.0f;
	CenterEndPos.x =0.0f;
	CenterEndPos.y =0.0f;

	// Align 심하게 틀어질경우 발생하는 Defect오버킬 
	int LeftDegMargin =0;
	int RightDegMargin=0;

	AlignMark1.x=0.0f;
	AlignMark1.y=0.0f;
	AlignMark2.x=0.0f;
	AlignMark2.y=0.0f;

	// A_Side Grind 측정 Point Data Init 
	for(int k=0; k<MAX_ASIDE_GRIND_POINT; k++){
		ASideGrindWd [k] =0.0f;
		ASideGrindMea[k] =0.0f;
	}
	//----------------------------------------------------------------
}
int CFM1xLineDefect::OnAutoBevelIn()// Line기준 실제 검사 함수 
{
	EImageEncoder CodeImageEncoder     ;
	ECodedImage2  CodeImage            ;
	EObjectSelection CodeImageSelection;
    EROIBW8   DefectROI                ;

	int ROI_X =0;
	int ROI_Y =0;
	int ROI_W =0;
	int ROI_H =0;

	// Circle Dis, Dv TEST 
	double MaxDis =0.0f     ;
	double MinDis =10000.0f ;
	double MaxDv  =0.0f     ;
	double MinDv  =10000.0f ;
	double StdMaxDis =0.0f     ;
	double StdMinDis =10000.0f ;
	int    MinCirCount =0;


    int Index = 0;
	// NOTCH Defect 검사 시퀀스 
	if( FShape==shRectH && FCompanyMode==COM_NOTCH ){ // NOTCH Edge Inspection(All Inspection     )  ImageCopy -> ImageConversion -> ROI Attatch 
		if(ImgDegree==0.0f) EasyImage::Threshold(GImage    ,&DefectImg, EnCapTopThresHold);
		else                EasyImage::Threshold(&RotateImg,&DefectImg, EnCapTopThresHold); //DefectImg.Save("D:\\ROTATE_IMG\\DefectImg_Binary_HAP.bmp");
		Index =0;   
	}                                                                                                     
	if( FShape==shRectS && FCompanyMode==COM_NOTCH ){
        EasyImage::Threshold(GImage    ,&DefectImg, EnCapMidThresHold);
		Index =1;                                                                              // NOTCH Edge Inspection(Only Top Inspection)  Short Cell Cam0
	}
	if( FShape==shRectC && FCompanyMode==COM_NOTCH ){ // NOTCH Edge Inspection(All Inspection     )  ImageCopy -> ImageConversion -> ROI Attatch 
		if(ImgDegree==0.0f) EasyImage::Threshold(GImage    ,&DefectImg, EnCapBtmThresHold);
		else                EasyImage::Threshold(&RotateImg,&DefectImg, EnCapBtmThresHold); //DefectImg.Save("D:\\ROTATE_IMG\\DefectImg_Binary_HAP.bmp");
		Index =12;   
	}    

	// Pixel 내부Data 추출 Buffer넘겨줌 
	//IAddress = DefectImg.GetImagePtr();
	int PixelValue;
	int PixelCount;

	// 광원 Btm OverKill방지 목적 
	int BTMLine =0;
	int TotalPixel =0;

	// Frit OverKill Remove Value
	int    MaxPixel   =0;
	int    MaxData    =0;
	int    CurData    =0;
	int    BrokenPixel =0;
	int    CrackPixel  =0;
	const int LongBrokenMargin   =7500;
	const int LongCrackMargin    =10  ;
// 	const int ShortBrokenMargin  =7500;
	const int ShortCrackMargin   =25  ;

	// Burr & Remain
	int BurrWidth =100;

	// Left Line Dv 
	double LeftDv =0.0f;

    bool l  = false; bool lt = false;
    bool t  = false; bool rt = false;
    bool r  = false; bool rb = false;
    bool b  = false; bool lb = false;

	// LeftLimit Remove Blob
	bool IsRemoveBlob = true;

    int ImgW   = GImage->GetWidth();
    int ImgH   = GImage->GetHeight();
	ImageWidth = GImage->GetWidth();;

	int Count1=0, Count2=0, Count3=0, Count4=0, Count5=0;

	//Euresys Blob Parameter Setting 
	//////////////////////////////////////////////////
    //CNC_6HEAD 이미지 변환 후 기본설정 진행 
	if((FShape==shRectH || FShape==shRectS || FShape==shRectC)){
		DefectROI.Attach(&DefectImg);
		CodeImageSelection.SetFeretAngle(0.00f);
		CodeImageEncoder.GetGrayscaleSingleThresholdSegmenter().SetWhiteLayerEncoded(false);
		CodeImageEncoder.GetGrayscaleSingleThresholdSegmenter().SetBlackLayerEncoded(true );

		IAddress = DefectImg.GetImagePtr();
	}
    //////////////////////////////////////////////////

    TFPoint LT(0          ,           0);
    TFPoint RT((float)ImgW,           0);
    TFPoint RB((float)ImgW, (float)ImgH);
    TFPoint LB(0          , (float)ImgH);
    TFPoint SP, EP, LSP, LEP, RSP, REP  ;

	// Notch Cell Size 측정 
	TFPoint NotchCenterPos(0.0f, 0.0f);

	// ROI 영역 설정
	int LeftHeight ;
	int RightHeight;
	int TopWidth   ;
	int BtmWidth   ;
	int BlobCount  ;
	const int Margin =15;

	// ImageRotate 불량 발생함 OverKill 감소 목적
	const int TopMargin =10;
	const int BtmMargin =30;

	// 컵영역 직사각형 형태일경우 단차로 인해서 불량이 패턴과 붙어서
	// 검사시 검출 불가함...이로인해서 Offset추가함 
	const int BtmInspOffset = 6;

	// Corner Data 
	int CornerCount  =0;
    int MarktoBmLine =0;

	//Circle Count,Avg Round 
	int CircleCount=0;
	float AvgCirDis   =0.0f;
	float TotalCirDis =0.0f;

	// Merge Margin
	const int xMerge  =30;
	const int yMerge  =30;
    const int MgCount =3;

	//Remain Offset 
	const int RemainMargin = 30;

	// BM Line Check
	float RightBMGab=0;
	float LeftBMGab =0;

	// Side Offset Margin
	int SideMargin =1;

	// Margin Filter
	const int BroMarginWidth  = 200;
	const int BroMarginHeight = 200;

	// GrindMark 각도 적용하여 회전목적(검사화면 디스플레이)
	TFPoint LtPos, RbPos;

	// 검사 ROI 설정 
	// Notch Cell 모자 검사 
	if(FShape==shRectH ) {
		SP = Math.OnIntersect(LeftOutLine [0].FP0, LeftOutLine [0].FP1, LB, RB);
		EP = Math.OnIntersect(RightOutLine[0].FP0, RightOutLine[0].FP1, LB, RB);

		FLeftWidth  =200;
		FRightWidth =200;
		FTopHeight  =200;

		if(IsCornerTop)     { //Corner Cutting일경우 Defect검사 영역 설정 
			TopWidth    =(int)(FRTTInPoint.x - FLTTInPoint.x); // TOP검사 진행시 양쪽 끝에 오버킬 감소 목적 
			LeftHeight  =(int)(SP.y - FLTLInPoint.y);
			RightHeight =(int)(EP.y - FRTRInPoint.y);
		}
		else if(IsRectTop)  {//Corner Cutting 없을경우 Defect검사 영역 설정 
			TopWidth    =(int)(FRTPoint.x - FLTPoint.x); // TOP검사 진행시 양쪽 끝에 오버킬 감소 목적 
			LeftHeight  =(int)(SP.y - FLTPoint.y);
			RightHeight =(int)(EP.y - FRTPoint.y);
		}
		else if(IsCircleTop){//Circle Cutting일경우 Defect 검사 영역 설정 
			if(TopEdgePoint[0].x==0 || TopEdgePoint[0].y==0) {
				TopEdgePoint[0].x = (int)FLTPoint.x                     ; 
				TopEdgePoint[0].y = (int)FLTPoint.y+ASideCircleHeight+10;
			}
			if(TopEdgePoint[1].x==0 || TopEdgePoint[1].y==0) {
				TopEdgePoint[1].x = (int)FLTPoint.x+ASideCircleWidth+10; 
				TopEdgePoint[1].y = (int)FLTPoint.y                    ;
			}
			if(TopEdgePoint[2].x==0 || TopEdgePoint[2].y==0) {
				TopEdgePoint[2].x = (int)FRTPoint.x -ASideCircleWidth-10; 
				TopEdgePoint[2].y = (int)FRTPoint.y                     ;
			}
			if(TopEdgePoint[3].x==0 || TopEdgePoint[3].y==0) {
				TopEdgePoint[3].x = (int)FRTPoint.x                     ; 
				TopEdgePoint[3].y = (int)FRTPoint.y+ASideCircleHeight+10;
			}
			TopWidth    =(int)(TopEdgePoint[2].x - TopEdgePoint[1].x); // TOP검사 진행시 양쪽 끝에 오버킬 감소 목적   
// 			LeftHeight  =(int)(SP.y - TopEdgePoint[0].y);                                                             
// 			RightHeight =(int)(EP.y - TopEdgePoint[3].y);
			if(IsMarkBtm){
				LeftHeight  =(int)(SP.y - TopEdgePoint[0].y);                                                             
				RightHeight =(int)(EP.y - TopEdgePoint[3].y);
			}
			else         {
				TopEdgePoint[0].y = (int)FLTPoint.y+ASideCircleHeight+10;
				TopEdgePoint[3].y = (int)FRTPoint.y+ASideCircleHeight+10;
				LeftHeight        = (int)(SP.y - TopEdgePoint[0].y);                                                             
				RightHeight       = (int)(EP.y - TopEdgePoint[3].y);
			}
		}

		// Defect Data Init 
		DefectPointCount = 0; // 전체 불량 개수 초기화
		BCount           = 0; // B_SIDE  불량 포인트 개수
		ACount           = 0; // A_SIDE  불량 포인트 개수
		CCount           = 0; // C_SIDE  불량 포인트 개수
		DCount           = 0; // D_SIDE  불량 포인트 개수
// 		C1CirDeftectCnt  = 0;
		C2CirDeftectCnt  = 0;
		C3CirDeftectCnt  = 0;
		C4CirDeftectCnt  = 0;
		C5CirDeftectCnt  = 0;
		C6CirDeftectCnt  = 0;
		ABurrCount       = 0;
		BBurrCount       = 0;
		CBurrCount       = 0;
		DBurrCount       = 0;

		// BSide, DSide Defect 검사시 Margin값 설정 
		if(AlignMark1.y!=0.0f && AlignMark2.y!=0.0f){
			if(AlignMark1.y>AlignMark2.y){
				LeftDegMargin  = (int)((AlignMark1.y - AlignMark2.y)+5);
				RightDegMargin = 5;
			}
			else if(AlignMark1.y<AlignMark2.y) {
				LeftDegMargin  = 5;
				RightDegMargin = (int)((AlignMark2.y - AlignMark1.y)+5);
			}
			else if(AlignMark1.y==AlignMark2.y) {
				LeftDegMargin  = 5;
				RightDegMargin = 5;
			}
		}
	}
	// Notch Cell 스틱 검사 
	if(FShape==shRectS) {
		LSP = Math.OnIntersect(LeftOutLine[0].FP0, LeftOutLine[0].FP1, LT, RT);
		LEP = Math.OnIntersect(LeftOutLine[0].FP0, LeftOutLine[0].FP1, LB, RB);

		RSP = Math.OnIntersect(RightOutLine[0].FP0, RightOutLine[0].FP1, LT, RT);
		REP = Math.OnIntersect(RightOutLine[0].FP0, RightOutLine[0].FP1, LB, RB);

		// 오버킬 방지목적으로 무조건 안쪽 라인 기준 검사 
		if((fabs(LSP.x - LEP.x)>Margin) || (fabs(RSP.x - REP.x)>Margin) ){
			LSP.x = (LSP.x>LEP.x) ? LSP.x : LEP.x;
			RSP.x = (RSP.x>REP.x) ? REP.x : RSP.x;
		}
		// Blob
		FLeftWidth   = 200;
		FRightWidth  = 200;
		LeftHeight   = (int)(LEP.y - LSP.y);
		RightHeight  = (int)(REP.y - RSP.y);
	}
	// Notch Cell 컵 검사 
	if(FShape==shRectC) {
		SP = Math.OnIntersect(LeftOutLine [0].FP0, LeftOutLine [0].FP1, LT, RT);
		EP = Math.OnIntersect(RightOutLine[0].FP0, RightOutLine[0].FP1, LT, RT);

		// BtmWidth 설정값은 Circle계산 이 후에 개별 적용함
		FLeftWidth  = 200;
		FRightWidth = 200;
		FBtmHeight  = 50;

		if(IsCornerBtm)     {//Corner Cutting일경우 Defect검사 영역 설정 
			LeftHeight  = (int)((FLBLInPoint.y - SP.y));
			RightHeight = (int)((FRBRInPoint.y - EP.y));
			BtmWidth    = (int)((FRBBInPoint.x - FLBBInPoint.x));
		}				    
		else if(IsRectBtm)  {//Corner Cutting 없을경우 Defect검사 영역 설정 
			LeftHeight  = (int)((FLBPoint.y - SP.y      ));
			RightHeight = (int)((FRBPoint.y - EP.y      ));
			BtmWidth    = (int)((FRBPoint.x - FLBPoint.x));
		}
		else if(IsCircleBtm){//Circle Cutting일경우 Defect 검사 영역 설정 
			LeftHeight  = (int)((FLBPoint.y - SP.y) - CSideCircleHeight - dCirOffsetY);
			RightHeight = (int)((FRBPoint.y - EP.y) - CSideCircleHeight - dCirOffsetY);
		}

		// BSide, DSide Defect 검사시 Margin값 설정 
		if(AlignMark1.y!=0.0f && AlignMark2.y!=0.0f){
			if(AlignMark1.y>AlignMark2.y){
				LeftDegMargin  = 5                                     ;
				RightDegMargin = (int)((AlignMark1.y - AlignMark2.y)+5);
			}
			else if(AlignMark1.y<AlignMark2.y) {
				LeftDegMargin  = (int)((AlignMark2.y - AlignMark1.y)+5);
				RightDegMargin = 5                                     ;
			}
			else if(AlignMark1.y==AlignMark2.y) {
				LeftDegMargin  = 5;
				RightDegMargin = 5;
			}
		}
	}
	float Dis    =0.0f;
	float StdDis =0.0f;

	// Side Offset TEST 
	double  Width   =0.0f;
	long    Left    =0;
	float   CenterX =0.0F;


    switch (Index) {
		
        // shRectH NOTCH 
        //----------------------------------------------------------------------
	case 0 :
		// Corner Defect 검사 
		if(IsCornerTop){
			if(C1InEdgeCount!=0){
				CornerCount=0;
				for(int k=0; k<C1InEdgeCount; k++){
					if(C1InPoint[k].y>FLTLPoint.y-1) continue;
					Dis = Math.GetLengthFrLineToPoint(FLTLInPoint, FLTTInPoint, C1InPoint[k]);
					C1Corner[CornerCount].Dv   = Dis         ;
					C1Corner[CornerCount].P.x  = C1InPoint[k].x;
					C1Corner[CornerCount].P.y  = C1InPoint[k].y;
					CornerCount++;
					if(Dis>MaxDv) MaxDv = Dis;
					if(Dis<MinDv) MinDv = Dis;
				}
				if(LTCornerWidth>(LTCornerHeight*2)) C1Count = GetSize(C1Corner, C1DefectPoint, CornerCount, 10);
				else                                 C1Count = GetSize(C1Corner, C1DefectPoint, CornerCount, 5 );
			}

			MaxDv =0.0f;
			MinDv =10000.0f;

			// Corner 2 
			if(C2InEdgeCount!=0){
				CornerCount=0;
				for(int k=0; k<C2InEdgeCount; k++){
					if(C2InPoint[k].y>FRTRPoint.y-1) continue;
					Dis = Math.GetLengthFrLineToPoint(FRTTInPoint, FRTRInPoint, C2InPoint[k]);
					C2Corner[CornerCount].Dv   = Dis         ;
					C2Corner[CornerCount].P.x  = C2InPoint[k].x;
					C2Corner[CornerCount].P.y  = C2InPoint[k].y;
					CornerCount++;
					if(Dis>MaxDv) MaxDv = Dis;
					if(Dis<MinDv) MinDv = Dis;
				}
				if(RTCornerWidth >(RTCornerHeight*1.5)) C2Count = GetSize(C2Corner, C2DefectPoint, CornerCount, 10);
				else                                    C2Count = GetSize(C2Corner, C2DefectPoint, CornerCount, 5 );

			}
			//Side A
			////////////////////////////////////////////////////////////////////////////////////////////////
			// 			LogUnit.SetLog("CAP_Side_A_Start_CamId: %d, ImageHeight: %d ",CamId,ImageHeight);     
			// 		DefectROI.SetPlacement((int)(FLTTPoint.x+SideMargin), (int)((FLTTPoint.y+FRTTPoint.y)/2), TopWidth-(2*SideMargin), FTopHeight);
			DefectROI.SetPlacement((int)(FLTTInPoint.x+SideMargin), (int)((FLTTInPoint.y+FRTTInPoint.y)/2), TopWidth-(2*SideMargin), FTopHeight);
			if((FLTTInPoint.x+SideMargin) <=0          || ((FLTTInPoint.y+FRTTInPoint.y)/2)<=0           || TopWidth-(2*SideMargin)<=0          || FTopHeight<=0          )return false;
			if((FLTTInPoint.x+SideMargin) >=ImageWidth || ((FLTTInPoint.y+FRTTInPoint.y)/2)>TopLimitLine || TopWidth-(2*SideMargin)>=ImageWidth || FTopHeight>TopLimitLine) return false;
			if((FLTTInPoint.x+SideMargin)+(TopWidth-(2*SideMargin)) >=ImageWidth || ((FRTTInPoint.y+FRTTPoint.y)/2)+ FTopHeight>TopLimitLine) return false;
			// Blob 검사 
			CodeImageSelection.Clear();
			CodeImageEncoder.Encode(DefectROI,CodeImage);
			CodeImageSelection.Clear();
			CodeImageSelection.AddObjects(CodeImage);
			// Blob 필터링 
			CodeImageSelection.RemoveUsingFloatFeature  (EFeature_BoundingBoxWidth ,FMinWidth , FMaxWidth  , EDoubleThresholdMode_Outside);
			CodeImageSelection.RemoveUsingFloatFeature  (EFeature_BoundingBoxHeight,FMinHeight, FMaxHeight , EDoubleThresholdMode_Outside);
			CodeImageSelection.RemoveUsingIntegerFeature(EFeature_TopLimit         ,0         , 3          , EDoubleThresholdMode_Outside);

			BlobCount = CodeImageSelection.GetElementCount();
			CodeImageSelection.Sort(EFeature_LeftLimit ,ESortDirection_Ascending);

			if(BlobCount!=0){
				for(int k=0; k<BlobCount; k++){
					if(ACount>=MAX_DEFECT_POINT) break;
					ADefectPoint[ACount].Width  = CodeImageSelection.GetElement(k).GetBoundingBoxWidth() ;
					ADefectPoint[ACount].Height = CodeImageSelection.GetElement(k).GetBoundingBoxHeight();

					ADefectPoint[ACount].Rect.left   =(long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterX() - ADefectPoint[ACount].Width/2 ) +FLTTInPoint.x+SideMargin      );
					ADefectPoint[ACount].Rect.top    =(long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - ADefectPoint[ACount].Height/2) +((FLTTInPoint.y+FRTTInPoint.y)/2));
					ADefectPoint[ACount].Rect.right  =(long)(ADefectPoint[ACount].Rect.left+ ADefectPoint[ACount].Width );
					ADefectPoint[ACount].Rect.bottom =(long)(ADefectPoint[ACount].Rect.top + ADefectPoint[ACount].Height);
					PixelCount = 0;
					PixelValue = 0;

					// 내부 Pixel Data 축출 
					for(int n=ADefectPoint[ACount].Rect.top+1 ; n<ADefectPoint[ACount].Rect.bottom-1; n++){
						for(int m=ADefectPoint[ACount].Rect.left+1; m<ADefectPoint[ACount].Rect.right-1 ; m++){
							PixelValue = IElement(m,n);
							if(PixelValue < EnCapTopThresHold) PixelCount++;
						}
					}

					ADefectPoint[ACount].Round  = PixelCount;
					ADefectPoint[ACount].P.x    =(float)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterX() - ADefectPoint[ACount].Width/2 )+FLTTInPoint.x+SideMargin       );
					ADefectPoint[ACount].P.y    =(float)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - ADefectPoint[ACount].Height/2)+((FLTTInPoint.y+FRTTInPoint.y)/2));

					// Image Rotate 기준 좌표를 다시 Rotate한다 _ Display 목적 
					if(ImgDegree!=0.0f){
						ADefectPoint[ACount].P = Math.OnRotate(CenterPoint, ADefectPoint[ACount].P, (ImgDegree));
					}
					// Image Rotate 기준 좌표를 회전 이후에 ImageHeight값을 더하여 실제 좌표를 산출한다 
					ADefectPoint[ACount].P.y    =(float)(ADefectPoint[ACount].P.y+ImageHeight);

					//Merget위해서 필요함 
					ADefectPoint[ACount].Rect.top    =(long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - ADefectPoint[ACount].Height/2) +((FLTTInPoint.y+FRTTInPoint.y)/2)+ImageHeight);
					ADefectPoint[ACount].Rect.bottom =(long)(ADefectPoint[ACount].Rect.top + ADefectPoint[ACount].Height);
					ACount++;
				}
			}

			//Side B
			////////////////////////////////////////////////////////////////////////////////////////////////
			// 			LogUnit.SetLog("CAP_Side_B_Start_CamId: %d, ImageHeight: %d ",CamId,ImageHeight);     
			// 			DefectROI.SetPlacement((int)(FRTRInPoint.x-FRightWidth-SideMargin), (int)(FRTRInPoint.y+Margin), FRightWidth, (RightHeight-(2*Margin)-TopMargin));
			// 			DefectROI.SetPlacement((int)(FRTRInPoint.x-FRightWidth-SideMargin), (int)(FRTRInPoint.y+Margin), FRightWidth, (RightHeight-(2*Margin)-TopMargin));
			DefectROI.SetPlacement((int)(FRTRInPoint.x-FRightWidth-SideMargin), (int)(FRTRInPoint.y+Margin), FRightWidth, (RightHeight-(2*Margin)-RightDegMargin));
			if((FRTRInPoint.x-FRightWidth-SideMargin) <=0          ||(FRTRInPoint.y+Margin)<=0           || FRightWidth<=0          || (RightHeight-(2*Margin)-RightDegMargin)<=0)           return false;
			if((FRTRInPoint.x-FRightWidth-SideMargin) >=ImageWidth ||(FRTRInPoint.y+Margin)>TopLimitLine || FRightWidth>=ImageWidth || (RightHeight-(2*Margin)-RightDegMargin)>TopLimitLine) return false;
			if((FRTRInPoint.x-FRightWidth-SideMargin)+FRightWidth >=ImageWidth ||((FRTRInPoint.y+Margin)+(RightHeight-(2*Margin)-RightDegMargin))>TopLimitLine) return false;
			//  Blob 검사 진행 
			CodeImageSelection.Clear();
			CodeImageEncoder.Encode(DefectROI,CodeImage);
			CodeImageSelection.Clear();
			CodeImageSelection.AddObjects(CodeImage);
			// Blob 필터링 
			CodeImageSelection.RemoveUsingFloatFeature(EFeature_BoundingBoxWidth ,FMinWidth     , FMaxWidth    , EDoubleThresholdMode_Outside);
			CodeImageSelection.RemoveUsingFloatFeature(EFeature_BoundingBoxHeight,FMinHeight    , FMaxHeight   , EDoubleThresholdMode_Outside);
			// 				CodeImageSelection.RemoveUsingIntegerFeature(EFeature_RightLimit     ,FRightWidth-2 , FRightWidth+1, EDoubleThresholdMode_Outside);
			CodeImageSelection.RemoveUsingIntegerFeature(EFeature_RightLimit     ,FRightWidth-1 , FRightWidth+1, EDoubleThresholdMode_Outside);

			BlobCount = CodeImageSelection.GetElementCount();
			CodeImageSelection.Sort(EFeature_TopLimit,ESortDirection_Ascending);

			if(BlobCount!=0){
				for(int k=0; k<BlobCount; k++){
					if(BCount>=MAX_DEFECT_POINT) break;
					BDefectPoint[BCount].Width  = CodeImageSelection.GetElement(k).GetBoundingBoxWidth() ;
					BDefectPoint[BCount].Height = CodeImageSelection.GetElement(k).GetBoundingBoxHeight();

					BDefectPoint[BCount].Rect.left   = (long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterX() - BDefectPoint[BCount].Width/2 ) +(FRTRInPoint.x-FRightWidth-SideMargin));
					BDefectPoint[BCount].Rect.top    = (long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - BDefectPoint[BCount].Height/2) +(FRTRInPoint.y+Margin)                );
					BDefectPoint[BCount].Rect.right  = (long)(BDefectPoint[BCount].Rect.left+ BDefectPoint[BCount].Width );
					BDefectPoint[BCount].Rect.bottom = (long)(BDefectPoint[BCount].Rect.top + BDefectPoint[BCount].Height);
					PixelCount = 0;
					PixelValue = 0;

					// 내부 Pixel Data 축출 
					for(int n=BDefectPoint[BCount].Rect.top+1 ; n<BDefectPoint[BCount].Rect.bottom-1; n++){
						for(int m=BDefectPoint[BCount].Rect.left+1; m<BDefectPoint[BCount].Rect.right-1 ; m++){
							PixelValue = IElement(m,n);
							if(PixelValue < EnCapTopThresHold) PixelCount++;
						}
					}
					BDefectPoint[BCount].Round  = PixelCount;
					BDefectPoint[BCount].P.x    = (float)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterX() - BDefectPoint[BCount].Width/2 ) +(FRTRInPoint.x-FRightWidth-SideMargin));
					BDefectPoint[BCount].P.y    = (float)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - BDefectPoint[BCount].Height/2) +(FRTRInPoint.y+Margin)+ImageHeight    );
					BDefectPoint[BCount].Width  = BDefectPoint[BCount].Width+SideMargin; 

					// Merge 위해서 데이터 필요함 
					BDefectPoint[BCount].Rect.top    =(long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - BDefectPoint[BCount].Height/2) + FRTRInPoint.y+Margin+ImageHeight);
					BDefectPoint[BCount].Rect.bottom =(long)(BDefectPoint[BCount].Rect.top + BDefectPoint[BCount].Height);
					BCount++;
				}
			}
			BlobCount =0;

			// 외곽라인에서 Mark까지의 거리 산출 
			if     (Line[waRightWall].FP0.x >Line[waRightWall].FP1.x) RDistance = ((Line[waRightWall].FP1.x+(Line[waRightWall].FP0.x - Line[waRightWall].FP1.x)/2) - FP1.x);
			else if(Line[waRightWall].FP0.x==Line[waRightWall].FP1.x) RDistance = (Line[waRightWall].FP0.x - FP1.x);
			else                                                      RDistance = ((Line[waRightWall].FP0.x+(Line[waRightWall].FP1.x - Line[waRightWall].FP0.x)/2) - FP1.x);

			MarktoBmLine = (IsMarkBtm) ? 5: 50;  
			if(IsMarkBtm) RDistance = RDistance-MarktoBmLine;
			else          RDistance = RDistance+MarktoBmLine;

			// Side D	
			////////////////////////////////////////////////////////////////////////////////////////////////
			// 			LogUnit.SetLog("CAP_Side_D_Start_CamId: %d, ImageHeight: %d ",CamId,ImageHeight);     
			// 			DefectROI.SetPlacement((int)(FLTLInPoint.x+SideMargin), (int)(FLTLInPoint.y+Margin), FLeftWidth, (LeftHeight-(2*Margin)-TopMargin));
			// 			if((FLTLInPoint.x+SideMargin) <=0          ||(FLTLInPoint.y+Margin)<=0           || FLeftWidth<=0          || (LeftHeight-(2*Margin)-TopMargin)<=0          ) return false;
			// 			if((FLTLInPoint.x+SideMargin) >=ImageWidth ||(FLTLInPoint.y+Margin)>TopLimitLine || FLeftWidth>=ImageWidth || (LeftHeight-(2*Margin)-TopMargin)>TopLimitLine) return false;
			// 			if((FLTLInPoint.x+SideMargin)+FLeftWidth >=ImageWidth ||(FLTLInPoint.y+Margin)+(LeftHeight-(2*Margin)-TopMargin)>TopLimitLine) return false;

			DefectROI.SetPlacement((int)(FLTLInPoint.x+SideMargin), (int)(FLTLInPoint.y+Margin), FLeftWidth, (LeftHeight-(2*Margin)-LeftDegMargin));
			if((FLTLInPoint.x+SideMargin) <=0          ||(FLTLInPoint.y+Margin)<=0           || FLeftWidth<=0          || (LeftHeight-(2*Margin)-LeftDegMargin)<=0          ) return false;
			if((FLTLInPoint.x+SideMargin) >=ImageWidth ||(FLTLInPoint.y+Margin)>TopLimitLine || FLeftWidth>=ImageWidth || (LeftHeight-(2*Margin)-LeftDegMargin)>TopLimitLine) return false;
			if((FLTLInPoint.x+SideMargin)+FLeftWidth >=ImageWidth ||(FLTLInPoint.y+Margin)+(LeftHeight-(2*Margin)-LeftDegMargin)>TopLimitLine) return false;

			// Blob 검사 진행 
			CodeImageSelection.Clear();
			CodeImageEncoder.Encode(DefectROI,CodeImage);
			CodeImageSelection.Clear();
			CodeImageSelection.AddObjects(CodeImage);

			// Blob 필터링 
			CodeImageSelection.RemoveUsingFloatFeature  (EFeature_BoundingBoxWidth ,FMinWidth , FMaxWidth  , EDoubleThresholdMode_Outside);
			CodeImageSelection.RemoveUsingFloatFeature  (EFeature_BoundingBoxHeight,FMinHeight, FMaxHeight , EDoubleThresholdMode_Outside);
			// 				CodeImageSelection.RemoveUsingIntegerFeature(EFeature_LeftLimit        ,0         , 3          , EDoubleThresholdMode_Outside);
			CodeImageSelection.RemoveUsingIntegerFeature(EFeature_LeftLimit        ,0         , 1          , EDoubleThresholdMode_Outside);

			BlobCount = CodeImageSelection.GetElementCount();
			CodeImageSelection.Sort(EFeature_TopLimit,ESortDirection_Ascending);

			if(BlobCount!=0){
				for(int k=0; k<BlobCount; k++){
					if(DCount>=MAX_DEFECT_POINT) break;
					DDefectPoint[DCount].Width     =  CodeImageSelection.GetElement(k).GetBoundingBoxWidth() ;
					DDefectPoint[DCount].Height    =  CodeImageSelection.GetElement(k).GetBoundingBoxHeight();

					DDefectPoint[DCount].Rect.left   = (long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterX() - DDefectPoint[DCount].Width/2 ) +(FLTLInPoint.x+SideMargin));
					DDefectPoint[DCount].Rect.top    = (long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - DDefectPoint[DCount].Height/2) +(FLTLInPoint.y+Margin)    );
					DDefectPoint[DCount].Rect.right  = (long)(DDefectPoint[DCount].Rect.left+ DDefectPoint[DCount].Width );
					DDefectPoint[DCount].Rect.bottom = (long)(DDefectPoint[DCount].Rect.top + DDefectPoint[DCount].Height);

					PixelCount = 0;
					PixelValue = 0;
					// 내부 Pixel Data 축출 
					for(int n=DDefectPoint[DCount].Rect.top+1 ; n<DDefectPoint[DCount].Rect.bottom-1; n++){
						for(int m=DDefectPoint[DCount].Rect.left+1; m<DDefectPoint[DCount].Rect.right-1 ; m++){
							PixelValue = IElement(m,n);
							if(PixelValue < EnCapTopThresHold) PixelCount++;
						}
					}
					// Display 데이터 필요함 
					DDefectPoint[DCount].Round = PixelCount;
					DDefectPoint[DCount].P.x       = (float)(DDefectPoint[DCount].Rect.left);
					DDefectPoint[DCount].P.y       = (float)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - DDefectPoint[DCount].Height/2)+(FLTLInPoint.y+Margin)+ImageHeight );
					DDefectPoint[DCount].Width     = DDefectPoint[DCount].Width+SideMargin; 

					// Merge 위해서 데이터 필요함 
					DDefectPoint[DCount].Rect.top    =(long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - DDefectPoint[DCount].Height/2) +(FLTLInPoint.y+Margin)+ImageHeight);
					DDefectPoint[DCount].Rect.bottom =(long)(DDefectPoint[DCount].Rect.top + DDefectPoint[DCount].Height);
					DCount++;
				}
			}
			BlobCount =0;

			// 외곽라인에서 Mark까지의 거리 산출 
			if     (Line[waLeftWall].FP0.x >Line[waLeftWall].FP1.x) LDistance = (FP0.x - (Line[waLeftWall].FP1.x+(Line[waLeftWall].FP0.x - Line[waLeftWall].FP1.x)/2));
			else if(Line[waLeftWall].FP0.x==Line[waLeftWall].FP1.x) LDistance = (FP0.x -  Line[waLeftWall].FP0.x)                                                     ;
			else                                                    LDistance = (FP0.x - (Line[waLeftWall].FP0.x+(Line[waLeftWall].FP1.x - Line[waLeftWall].FP0.x)/2)); 
		}
		else if(IsRectTop) {  // Corner Cutting이 없을경우 
			//Side A
			////////////////////////////////////////////////////////////////////////////////////////////////
			DefectROI.SetPlacement((int)(FLTPoint.x+SideMargin), (int)((FLTPoint.y+FRTPoint.y)/2), TopWidth-(2*SideMargin), FTopHeight);
			if((FLTPoint.x+SideMargin) <=0          || ((FLTPoint.y+FRTPoint.y)/2)<=0           || TopWidth-(2*SideMargin)<=0          || FTopHeight<=0          )return false;
			if((FLTPoint.x+SideMargin) >=ImageWidth || ((FLTPoint.y+FRTPoint.y)/2)>TopLimitLine || TopWidth-(2*SideMargin)>=ImageWidth || FTopHeight>TopLimitLine) return false;
			if((FLTPoint.x+SideMargin)+(TopWidth-(2*SideMargin)) >=ImageWidth || ((FLTPoint.y+FRTPoint.y)/2)+ FTopHeight>TopLimitLine) return false;
			// Blob 검사 
			CodeImageSelection.Clear();
			CodeImageEncoder.Encode(DefectROI,CodeImage);
			CodeImageSelection.Clear();
			CodeImageSelection.AddObjects(CodeImage);
			// Blob 필터링 
			CodeImageSelection.RemoveUsingFloatFeature  (EFeature_BoundingBoxWidth ,FMinWidth , FMaxWidth  , EDoubleThresholdMode_Outside);
			CodeImageSelection.RemoveUsingFloatFeature  (EFeature_BoundingBoxHeight,FMinHeight, FMaxHeight , EDoubleThresholdMode_Outside);
			CodeImageSelection.RemoveUsingIntegerFeature(EFeature_TopLimit         ,0         , 3          , EDoubleThresholdMode_Outside);

			BlobCount = CodeImageSelection.GetElementCount();
			CodeImageSelection.Sort(EFeature_LeftLimit ,ESortDirection_Ascending);

			if(BlobCount!=0){
				for(int k=0; k<BlobCount; k++){
					if(ACount>=MAX_DEFECT_POINT) break;
					ADefectPoint[ACount].Width  = CodeImageSelection.GetElement(k).GetBoundingBoxWidth() ;
					ADefectPoint[ACount].Height = CodeImageSelection.GetElement(k).GetBoundingBoxHeight();

					ADefectPoint[ACount].Rect.left   =(long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterX() - ADefectPoint[ACount].Width/2 ) +FLTPoint.x+SideMargin      );
					ADefectPoint[ACount].Rect.top    =(long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - ADefectPoint[ACount].Height/2) +((FLTPoint.y+FRTPoint.y)/2));
					ADefectPoint[ACount].Rect.right  =(long)(ADefectPoint[ACount].Rect.left+ ADefectPoint[ACount].Width );
					ADefectPoint[ACount].Rect.bottom =(long)(ADefectPoint[ACount].Rect.top + ADefectPoint[ACount].Height);
					PixelCount = 0;
					PixelValue = 0;

					// 내부 Pixel Data 축출 
					for(int n=ADefectPoint[ACount].Rect.top+1 ; n<ADefectPoint[ACount].Rect.bottom-1; n++){
						for(int m=ADefectPoint[ACount].Rect.left+1; m<ADefectPoint[ACount].Rect.right-1 ; m++){
							PixelValue = IElement(m,n);
							if(PixelValue < EnCapTopThresHold) PixelCount++;
						}
					}

					ADefectPoint[ACount].Round  = PixelCount;
					ADefectPoint[ACount].P.x    =(float)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterX() - ADefectPoint[ACount].Width/2 )+FLTPoint.x+SideMargin      );
					ADefectPoint[ACount].P.y    =(float)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - ADefectPoint[ACount].Height/2)+((FLTPoint.y+FRTPoint.y)/2));

					// Image Rotate 기준 좌표를 다시 Rotate한다 _ Display 목적 
					if(ImgDegree!=0.0f){
						ADefectPoint[ACount].P = Math.OnRotate(CenterPoint, ADefectPoint[ACount].P, (ImgDegree));
					}
					// Image Rotate 기준 좌표를 회전 이후에 ImageHeight값을 더하여 실제 좌표를 산출한다 
					ADefectPoint[ACount].P.y    =(float)(ADefectPoint[ACount].P.y+ImageHeight);

					//Merget위해서 필요함 
					ADefectPoint[ACount].Rect.top    =(long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - ADefectPoint[ACount].Height/2) +((FLTPoint.y+FRTPoint.y)/2)+ImageHeight);
					ADefectPoint[ACount].Rect.bottom =(long)(ADefectPoint[ACount].Rect.top + ADefectPoint[ACount].Height);
					ACount++;
				}
			}
			BlobCount =0;

			//Side B
			////////////////////////////////////////////////////////////////////////////////////////////////
			// 			LogUnit.SetLog("CAP_Side_B_Start_CamId: %d, ImageHeight: %d ",CamId,ImageHeight);     
			// 			DefectROI.SetPlacement((int)(FRTPoint.x-FRightWidth-SideMargin), (int)(FRTPoint.y+Margin), FRightWidth, (RightHeight-(2*Margin)-TopMargin));
			// 			if((FRTPoint.x-FRightWidth-SideMargin) <=0          ||(FRTPoint.y+Margin)<=0           || FRightWidth<=0          || (RightHeight-(2*Margin)-TopMargin)<=0)           return false;
			// 			if((FRTPoint.x-FRightWidth-SideMargin) >=ImageWidth ||(FRTPoint.y+Margin)>TopLimitLine || FRightWidth>=ImageWidth || (RightHeight-(2*Margin)-TopMargin)>TopLimitLine) return false;
			// 			if((FRTPoint.x-FRightWidth-SideMargin)+FRightWidth >=ImageWidth ||((FRTPoint.y+Margin)+(RightHeight-(2*Margin)-TopMargin))>TopLimitLine) return false;

			DefectROI.SetPlacement((int)(FRTPoint.x-FRightWidth-SideMargin), (int)(FRTPoint.y+Margin), FRightWidth, (RightHeight-(2*Margin)-RightDegMargin));
			if((FRTPoint.x-FRightWidth-SideMargin) <=0          ||(FRTPoint.y+Margin)<=0           || FRightWidth<=0          || (RightHeight-(2*Margin)-RightDegMargin)<=0)           return false;
			if((FRTPoint.x-FRightWidth-SideMargin) >=ImageWidth ||(FRTPoint.y+Margin)>TopLimitLine || FRightWidth>=ImageWidth || (RightHeight-(2*Margin)-RightDegMargin)>TopLimitLine) return false;
			if((FRTPoint.x-FRightWidth-SideMargin)+FRightWidth >=ImageWidth ||((FRTPoint.y+Margin)+(RightHeight-(2*Margin)-RightDegMargin))>TopLimitLine) return false;

			//  Blob 검사 진행 
			CodeImageSelection.Clear();
			CodeImageEncoder.Encode(DefectROI,CodeImage);
			CodeImageSelection.Clear();
			CodeImageSelection.AddObjects(CodeImage);
			// Blob 필터링 
			CodeImageSelection.RemoveUsingFloatFeature(EFeature_BoundingBoxWidth ,FMinWidth     , FMaxWidth    , EDoubleThresholdMode_Outside);
			CodeImageSelection.RemoveUsingFloatFeature(EFeature_BoundingBoxHeight,FMinHeight    , FMaxHeight   , EDoubleThresholdMode_Outside);
			// 				CodeImageSelection.RemoveUsingIntegerFeature(EFeature_RightLimit     ,FRightWidth-2 , FRightWidth+1, EDoubleThresholdMode_Outside);
			CodeImageSelection.RemoveUsingIntegerFeature(EFeature_RightLimit     ,FRightWidth-1 , FRightWidth+1, EDoubleThresholdMode_Outside);

			BlobCount = CodeImageSelection.GetElementCount();
			CodeImageSelection.Sort(EFeature_TopLimit,ESortDirection_Ascending);

			if(BlobCount!=0){
				for(int k=0; k<BlobCount; k++){
					if(BCount>=MAX_DEFECT_POINT) break;
					BDefectPoint[BCount].Width  = CodeImageSelection.GetElement(k).GetBoundingBoxWidth() ;
					BDefectPoint[BCount].Height = CodeImageSelection.GetElement(k).GetBoundingBoxHeight();

					BDefectPoint[BCount].Rect.left   = (long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterX() - BDefectPoint[BCount].Width/2 ) +(FRTPoint.x-FRightWidth-SideMargin));
					BDefectPoint[BCount].Rect.top    = (long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - BDefectPoint[BCount].Height/2) +(FRTPoint.y+Margin)                );
					BDefectPoint[BCount].Rect.right  = (long)(BDefectPoint[BCount].Rect.left+ BDefectPoint[BCount].Width );
					BDefectPoint[BCount].Rect.bottom = (long)(BDefectPoint[BCount].Rect.top + BDefectPoint[BCount].Height);
					PixelCount = 0;
					PixelValue = 0;

					// 내부 Pixel Data 축출 
					for(int n=BDefectPoint[BCount].Rect.top+1 ; n<BDefectPoint[BCount].Rect.bottom-1; n++){
						for(int m=BDefectPoint[BCount].Rect.left+1; m<BDefectPoint[BCount].Rect.right-1 ; m++){
							PixelValue = IElement(m,n);
							if(PixelValue < EnCapTopThresHold) PixelCount++;
						}
					}
					BDefectPoint[BCount].Round  = PixelCount;
					BDefectPoint[BCount].P.x    = (float)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterX() - BDefectPoint[BCount].Width/2 ) +(FRTPoint.x-FRightWidth-SideMargin));
					BDefectPoint[BCount].P.y    = (float)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - BDefectPoint[BCount].Height/2) +(FRTPoint.y+Margin)+ImageHeight    );
					BDefectPoint[BCount].Width  = BDefectPoint[BCount].Width+SideMargin; 

					// Merge 위해서 데이터 필요함 
					BDefectPoint[BCount].Rect.top    =(long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - BDefectPoint[BCount].Height/2) + FRTPoint.y+Margin+ImageHeight);
					BDefectPoint[BCount].Rect.bottom =(long)(BDefectPoint[BCount].Rect.top + BDefectPoint[BCount].Height);
					BCount++;
				}
			}
			BlobCount =0;

			// 외곽라인에서 Mark까지의 거리 산출 
			if     (Line[waRightWall].FP0.x >Line[waRightWall].FP1.x) RDistance = ((Line[waRightWall].FP1.x+(Line[waRightWall].FP0.x - Line[waRightWall].FP1.x)/2) - FP1.x);
			else if(Line[waRightWall].FP0.x==Line[waRightWall].FP1.x) RDistance = (Line[waRightWall].FP0.x - FP1.x);
			else                                                      RDistance = ((Line[waRightWall].FP0.x+(Line[waRightWall].FP1.x - Line[waRightWall].FP0.x)/2) - FP1.x);

			// 			MarktoBmLine = (IsMarkBtm) ? 5: 50;  
			// 			if(IsMarkBtm) RDistance = RDistance-MarktoBmLine;
			// 			else          RDistance = RDistance+MarktoBmLine;

			// Side D	
			////////////////////////////////////////////////////////////////////////////////////////////////
			// 			LogUnit.SetLog("CAP_Side_D_Start_CamId: %d, ImageHeight: %d ",CamId,ImageHeight);     
			// 			DefectROI.SetPlacement((int)(FLTPoint.x+SideMargin), (int)(FLTPoint.y+Margin), FLeftWidth, (LeftHeight-(2*Margin)-TopMargin));
			// 			if((FLTPoint.x+SideMargin) <=0          ||(FLTPoint.y+Margin)<=0           || FLeftWidth<=0          || (LeftHeight-(2*Margin)-TopMargin)<=0          ) return false;
			// 			if((FLTPoint.x+SideMargin) >=ImageWidth ||(FLTPoint.y+Margin)>TopLimitLine || FLeftWidth>=ImageWidth || (LeftHeight-(2*Margin)-TopMargin)>TopLimitLine) return false;
			// 			if((FLTPoint.x+SideMargin)+FLeftWidth >=ImageWidth ||(FLTPoint.y+Margin)+(LeftHeight-(2*Margin)-TopMargin)>TopLimitLine) return false;

			DefectROI.SetPlacement((int)(FLTPoint.x+SideMargin), (int)(FLTPoint.y+Margin), FLeftWidth, (LeftHeight-(2*Margin)-LeftDegMargin));
			if((FLTPoint.x+SideMargin) <=0          ||(FLTPoint.y+Margin)<=0           || FLeftWidth<=0          || (LeftHeight-(2*Margin)-LeftDegMargin)<=0          ) return false;
			if((FLTPoint.x+SideMargin) >=ImageWidth ||(FLTPoint.y+Margin)>TopLimitLine || FLeftWidth>=ImageWidth || (LeftHeight-(2*Margin)-LeftDegMargin)>TopLimitLine) return false;
			if((FLTPoint.x+SideMargin)+FLeftWidth >=ImageWidth ||(FLTPoint.y+Margin)+(LeftHeight-(2*Margin)-LeftDegMargin)>TopLimitLine) return false;

			// Blob 검사 진행 
			CodeImageSelection.Clear();
			CodeImageEncoder.Encode(DefectROI,CodeImage);
			CodeImageSelection.Clear();
			CodeImageSelection.AddObjects(CodeImage);

			// Blob 필터링 
			CodeImageSelection.RemoveUsingFloatFeature  (EFeature_BoundingBoxWidth ,FMinWidth , FMaxWidth  , EDoubleThresholdMode_Outside);
			CodeImageSelection.RemoveUsingFloatFeature  (EFeature_BoundingBoxHeight,FMinHeight, FMaxHeight , EDoubleThresholdMode_Outside);
			// 				CodeImageSelection.RemoveUsingIntegerFeature(EFeature_LeftLimit        ,0         , 3          , EDoubleThresholdMode_Outside);
			CodeImageSelection.RemoveUsingIntegerFeature(EFeature_LeftLimit        ,0         , 1          , EDoubleThresholdMode_Outside);

			BlobCount = CodeImageSelection.GetElementCount();
			CodeImageSelection.Sort(EFeature_TopLimit,ESortDirection_Ascending);

			if(BlobCount!=0){
				for(int k=0; k<BlobCount; k++){
					if(DCount>=MAX_DEFECT_POINT) break;
					DDefectPoint[DCount].Width     =  CodeImageSelection.GetElement(k).GetBoundingBoxWidth() ;
					DDefectPoint[DCount].Height    =  CodeImageSelection.GetElement(k).GetBoundingBoxHeight();

					DDefectPoint[DCount].Rect.left   = (long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterX() - DDefectPoint[DCount].Width/2 ) +(FLTPoint.x+SideMargin));
					DDefectPoint[DCount].Rect.top    = (long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - DDefectPoint[DCount].Height/2) +(FLTPoint.y+Margin)    );
					DDefectPoint[DCount].Rect.right  = (long)(DDefectPoint[DCount].Rect.left+ DDefectPoint[DCount].Width );
					DDefectPoint[DCount].Rect.bottom = (long)(DDefectPoint[DCount].Rect.top + DDefectPoint[DCount].Height);

					PixelCount = 0;
					PixelValue = 0;
					// 내부 Pixel Data 축출 
					for(int n=DDefectPoint[DCount].Rect.top+1 ; n<DDefectPoint[DCount].Rect.bottom-1; n++){
						for(int m=DDefectPoint[DCount].Rect.left+1; m<DDefectPoint[DCount].Rect.right-1 ; m++){
							PixelValue = IElement(m,n);
							if(PixelValue < EnCapTopThresHold) PixelCount++;
						}
					}
					// Display 데이터 필요함 
					DDefectPoint[DCount].Round = PixelCount;
					DDefectPoint[DCount].P.x       = (float)(DDefectPoint[DCount].Rect.left);
					DDefectPoint[DCount].P.y       = (float)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - DDefectPoint[DCount].Height/2)+(FLTPoint.y+Margin)+ImageHeight );
					DDefectPoint[DCount].Width     = DDefectPoint[DCount].Width+SideMargin; 

					// Merge 위해서 데이터 필요함 
					DDefectPoint[DCount].Rect.top    =(long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - DDefectPoint[DCount].Height/2) +(FLTPoint.y+Margin)+ImageHeight);
					DDefectPoint[DCount].Rect.bottom =(long)(DDefectPoint[DCount].Rect.top + DDefectPoint[DCount].Height);
					DCount++;
				}
			}
			BlobCount =0;

			// 외곽라인에서 Mark까지의 거리 산출 
			if     (Line[waLeftWall].FP0.x >Line[waLeftWall].FP1.x) LDistance = (FP0.x - (Line[waLeftWall].FP1.x+(Line[waLeftWall].FP0.x - Line[waLeftWall].FP1.x)/2));
			else if(Line[waLeftWall].FP0.x==Line[waLeftWall].FP1.x) LDistance = (FP0.x -  Line[waLeftWall].FP0.x)                                                     ;
			else                                                    LDistance = (FP0.x - (Line[waLeftWall].FP0.x+(Line[waLeftWall].FP1.x - Line[waLeftWall].FP0.x)/2)); 
		}
		else if(IsCircleTop){ // Circle Cutting일경우 Defect검사 진행 
			if(FInspectMode==Insp_Polygon){ // A_Side 영역 Arc Polygon Mode 검사 시퀀스 
				// 				LogUnit.SetLog("Polygon_Defect_START");     
				if(A1CirInEdgeCount!=0){    // Polygon Mode 검사에서는 Dx,Dy,R,박리불량 미검사 
					IAddress = DefectImg.GetImagePtr(); // Pixel 정보 추출 목적 

					A1CirDeftectCnt  = GetPolygonSize(A1CirInPoint, A1CirDefectPoint, A1CirInEdgeCount, 50, 5); // Dark Defect 
					// 박리 불량 검사 
					if(!IsMarkBtm && A1CirInCrackCount>0 && BrokenThresHold!=0){
						IAddress = RotateBrokenImg.GetImagePtr(); // Pixel 정보 추출 목적 
						A1CirCrackCnt  = GetCircleCrackSize(A1CircleData, A1CirCrackPoint, A1CirInCrackCount, 30,ACirFitDiameter1,ACircleFit1Center); //Bright Defect 
					}
				}

				if(A2CirInEdgeCount!=0){
					IAddress = DefectImg.GetImagePtr(); // Pixel 정보 추출 목적 
					A2CirDeftectCnt  = GetPolygonSize(A2CirInPoint, A2CirDefectPoint, A2CirInEdgeCount, 50, 5); // Dark Defect 

					// 박리 불량 검사 
					if(!IsMarkBtm && A2CirInCrackCount>0 && BrokenThresHold!=0){
						IAddress = RotateBrokenImg.GetImagePtr(); // Pixel 정보 추출 목적 
						A2CirCrackCnt  = GetCircleCrackSize(A2CircleData, A2CirCrackPoint, A2CirInCrackCount, 30,ACirFitDiameter2,ACircleFit2Center); // Bright Defect 
					}
				}
				// 				LogUnit.SetLog("Polygon_Defect_END");     
			}
			else                          { // A_Side 영역 Arc Mark Mode 검사 시퀀스 (A_Side영역은 Only MarkMode만 존재함)
				// 				LogUnit.SetLog("Mark_Defect_START");     
				if(A1CirInEdgeCount!=0){
					IAddress = DefectImg.GetImagePtr(); // Pixel 정보 추출 목적 
					MaxDis =0.0f     ;
					MinDis =10000.0f ;
					MaxDv  =0.0f     ;
					MinDv  =10000.0f ;

					CircleCount=0;TotalCirDis=0.0f; AvgCirDis=0.0f;
					for(int k=0; k<A1CirInEdgeCount; k++){
						if(A1CirInPoint[k].x==0 || A1CirInPoint[k].y==0 || k>=MAX_CIRCLE_EDGEPOINT) continue;

						// 					Dis    = Math.GetLengthFrPointToPoint(A1CirCenter,A1CirInPoint[k]);
						Dis    = Math.GetLengthFrPointToPoint(ACircleFit1Center,A1CirInPoint[k]);

						if(Dis>MaxDis) MaxDis = Dis;
						if(Dis<MinDis) MinDis = Dis;

						if(k==0){ // BTM Defect 검사를 위한 좌표값 및 Dx,Dy 산출 
							A1CirDx = Math.GetLengthFrPointToPoint(ACircleFit1Center,A1CirInPoint[k]);
						} 
						if(k==(A1CirInEdgeCount-1)){
							A1CirDy = Math.GetLengthFrPointToPoint(ACircleFit1Center,A1CirInPoint[k]);
						}

						A1CircleData[CircleCount].Dis  = Dis              ;
						A1CircleData[CircleCount].P.x  = A1CirInPoint[k].x;
						A1CircleData[CircleCount].P.y  = A1CirInPoint[k].y;
						CircleCount++   ;
						TotalCirDis+=Dis;
					}
					if(CircleCount!=0 || TotalCirDis!=0){ // Circle AvgRound Cal
						AvgCirDis = (TotalCirDis/CircleCount);
						A1CirRound = AvgCirDis;
					}

					for(int i=0; i<CircleCount; i++){
						// 					A1CircleData[i].Dv = fabs(AvgCirDis - A1CircleData[i].Dis);
						A1CircleData[i].Dv = (ACirFitDiameter1 - A1CircleData[i].Dis) >0 ?(ACirFitDiameter1 - A1CircleData[i].Dis):0;
						if(A1CircleData[i].Dv>MaxDv) MaxDv = A1CircleData[i].Dv;
						if(A1CircleData[i].Dv<MinDv) MinDv = A1CircleData[i].Dv;

					}
					A1CirDeftectCnt  = GetCircleSize(A1CircleData, A1CirDefectPoint, CircleCount, 5); // Dark Defect 

					// 박리불량 검사 시퀀스 
					if(!IsMarkBtm && A1CirInCrackCount>0 && BrokenThresHold!=0){
						for(int i=0; i<A1CirInCrackCount; i++){
							A1CircleData[i].Dv  =0.0f;
							A1CircleData[i].Dis =0.0f;
							A1CircleData[i].P.x  = A1CirInCrackPoint[i].x;
							A1CircleData[i].P.y  = A1CirInCrackPoint[i].y;
						}
						IAddress = RotateBrokenImg.GetImagePtr(); // Pixel 정보 추출 목적 
						A1CirCrackCnt  = GetCircleCrackSize(A1CircleData, A1CirCrackPoint, A1CirInCrackCount, 30,CrackACirDiameter1,ACircleFit1Center);
					}
				}

				if(A2CirInEdgeCount!=0){
					IAddress = DefectImg.GetImagePtr(); // Pixel 정보 추출 목적 
					MaxDis =0.0f     ;
					MinDis =10000.0f ;
					MaxDv  =0.0f     ;
					MinDv  =10000.0f ;

					CircleCount=0;TotalCirDis=0.0f; AvgCirDis=0.0f;
					for(int k=0; k<A2CirInEdgeCount; k++){
						if(A2CirInPoint[k].x==0 || A2CirInPoint[k].y==0 || k>=MAX_CIRCLE_EDGEPOINT) continue;

						// 					Dis    = Math.GetLengthFrPointToPoint(A2CirCenter,A2CirInPoint[k]);
						Dis    = Math.GetLengthFrPointToPoint(ACircleFit2Center,A2CirInPoint[k]);

						if(Dis>MaxDis) MaxDis = Dis;
						if(Dis<MinDis) MinDis = Dis;

						if(k==0){ // BTM Defect 검사를 위한 좌표값 및 Dx,Dy 산출 
							A2CirDy = Math.GetLengthFrPointToPoint(ACircleFit2Center,A2CirInPoint[k]);
						} 
						if(k==(A2CirInEdgeCount-1)){
							A2CirDx = Math.GetLengthFrPointToPoint(ACircleFit2Center,A2CirInPoint[k]);
						}

						A2CircleData[CircleCount].Dis  = Dis              ;
						A2CircleData[CircleCount].P.x  = A2CirInPoint[k].x;
						A2CircleData[CircleCount].P.y  = A2CirInPoint[k].y;
						CircleCount++   ;
						TotalCirDis+=Dis;
					}
					if(CircleCount!=0 || TotalCirDis!=0){ // Circle AvgRound Cal
						AvgCirDis = (TotalCirDis/CircleCount);
						A2CirRound = AvgCirDis;
					}

					for(int i=0; i<CircleCount; i++){
						// 					A2CircleData[i].Dv = fabs(AvgCirDis - A2CircleData[i].Dis);
						A2CircleData[i].Dv = (ACirFitDiameter2 - A2CircleData[i].Dis) >0 ?(ACirFitDiameter2 - A2CircleData[i].Dis):0;
						if(A2CircleData[i].Dv>MaxDv) MaxDv = A2CircleData[i].Dv;
						if(A2CircleData[i].Dv<MinDv) MinDv = A2CircleData[i].Dv;
					}
					A2CirDeftectCnt  = GetCircleSize(A2CircleData, A2CirDefectPoint, CircleCount, 5);

					// 박리불량 검사 시퀀스 
					if(!IsMarkBtm && A2CirInCrackCount>0 && BrokenThresHold!=0){
						for(int i=0; i<A2CirInCrackCount; i++){
							A2CircleData[i].Dv  =0.0f;
							A2CircleData[i].Dis =0.0f;
							A2CircleData[i].P.x  = A2CirInCrackPoint[i].x;
							A2CircleData[i].P.y  = A2CirInCrackPoint[i].y;
						}
						IAddress = RotateBrokenImg.GetImagePtr(); // Pixel 정보 추출 목적 
						A2CirCrackCnt  = GetCircleCrackSize(A2CircleData, A2CirCrackPoint, A2CirInCrackCount, 20,CrackACirDiameter2,ACircleFit2Center);
					}
				}
				// 				LogUnit.SetLog("Mark_Defect_END");     
			}

			// SIDE A 검사 
			////////////////////////////////////////////////////////////////////////////////////////////////
			DefectROI.SetPlacement((int)(TopEdgePoint[1].x+SideMargin), (int)((TopEdgePoint[1].y+TopEdgePoint[2].y)/2), TopWidth-(2*SideMargin), FTopHeight);
			if((TopEdgePoint[1].x+SideMargin) <=0          || ((TopEdgePoint[1].y+TopEdgePoint[2].y)/2)<=0           || TopWidth-(2*SideMargin)<=0          || FTopHeight<=0          ) return false;
			if((TopEdgePoint[1].x+SideMargin) >=ImageWidth || ((TopEdgePoint[1].y+TopEdgePoint[2].y)/2)>TopLimitLine || TopWidth-(2*SideMargin)>=ImageWidth || FTopHeight>TopLimitLine) return false;
			if((TopEdgePoint[1].x+SideMargin)+(TopWidth-(2*SideMargin)) >=ImageWidth || ((TopEdgePoint[1].y+TopEdgePoint[2].y)/2)+ FTopHeight>TopLimitLine                            ) return false;
			// Blob 검사 
			CodeImageSelection.Clear();
			CodeImageEncoder.Encode(DefectROI,CodeImage);
			CodeImageSelection.Clear();
			CodeImageSelection.AddObjects(CodeImage);
			// Blob 필터링 
			CodeImageSelection.RemoveUsingFloatFeature  (EFeature_BoundingBoxWidth ,FMinWidth , FMaxWidth  , EDoubleThresholdMode_Outside);
			CodeImageSelection.RemoveUsingFloatFeature  (EFeature_BoundingBoxHeight,FMinHeight, FMaxHeight , EDoubleThresholdMode_Outside);
			CodeImageSelection.RemoveUsingIntegerFeature(EFeature_TopLimit         ,0         , 3          , EDoubleThresholdMode_Outside);

			BlobCount = CodeImageSelection.GetElementCount();
			CodeImageSelection.Sort(EFeature_LeftLimit ,ESortDirection_Ascending);

			if(BlobCount!=0){
				for(int k=0; k<BlobCount; k++){
					if(ACount>=MAX_DEFECT_POINT) break;
					ADefectPoint[ACount].Width  = CodeImageSelection.GetElement(k).GetBoundingBoxWidth() ;
					ADefectPoint[ACount].Height = CodeImageSelection.GetElement(k).GetBoundingBoxHeight();

					ADefectPoint[ACount].Rect.left   =(long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterX() - ADefectPoint[ACount].Width/2 ) +(TopEdgePoint[1].x+SideMargin));
					ADefectPoint[ACount].Rect.top    =(long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - ADefectPoint[ACount].Height/2) +((TopEdgePoint[1].y+TopEdgePoint[2].y)/2));
					ADefectPoint[ACount].Rect.right  =(long)(ADefectPoint[ACount].Rect.left+ ADefectPoint[ACount].Width );
					ADefectPoint[ACount].Rect.bottom =(long)(ADefectPoint[ACount].Rect.top + ADefectPoint[ACount].Height);
					PixelCount = 0;
					PixelValue = 0;

					// 내부 Pixel Data 축출 
					for(int n=ADefectPoint[ACount].Rect.top+1 ; n<ADefectPoint[ACount].Rect.bottom-1; n++){
						for(int m=ADefectPoint[ACount].Rect.left+1; m<ADefectPoint[ACount].Rect.right-1 ; m++){
							PixelValue = IElement(m,n);
							if(PixelValue < EnCapTopThresHold) PixelCount++;
						}
					}

					ADefectPoint[ACount].Round  = PixelCount;
					ADefectPoint[ACount].P.x    =(float)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterX() - ADefectPoint[ACount].Width/2 )+(TopEdgePoint[1].x+SideMargin));
					ADefectPoint[ACount].P.y    =(float)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - ADefectPoint[ACount].Height/2)+((TopEdgePoint[1].y+TopEdgePoint[2].y)/2));


					// Image Rotate 기준 좌표를 다시 Rotate한다 _ Display 목적 
					if(ImgDegree!=0.0f){
						ADefectPoint[ACount].P = Math.OnRotate(CenterPoint, ADefectPoint[ACount].P, (ImgDegree));
					}
					// Image Rotate 기준 좌표를 회전 이후에 ImageHeight값을 더하여 실제 좌표를 산출한다 
					ADefectPoint[ACount].P.y    =(float)(ADefectPoint[ACount].P.y+ImageHeight);

					//Merget위해서 필요함 
					ADefectPoint[ACount].Rect.top    =(long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - ADefectPoint[ACount].Height/2) +((TopEdgePoint[1].y+TopEdgePoint[2].y)/2)+ImageHeight);
					ADefectPoint[ACount].Rect.bottom =(long)(ADefectPoint[ACount].Rect.top + ADefectPoint[ACount].Height);
					ACount++;
				}
			}
			BlobCount =0;

			// SIDE B 검사 
			//Side B
			////////////////////////////////////////////////////////////////////////////////////////////////
			// 			LogUnit.SetLog("CAP_Side_B_Start_CamId: %d, ImageHeight: %d ",CamId,ImageHeight);     
			// 			DefectROI.SetPlacement((int)(TopEdgePoint[3].x-FRightWidth-SideMargin), (int)(TopEdgePoint[3].y+Margin), FRightWidth, (RightHeight-(2*Margin)-TopMargin));
			// 			if((TopEdgePoint[3].x-FRightWidth-SideMargin) <=0          ||(TopEdgePoint[3].y+Margin)<=0           || FRightWidth<=0          || (RightHeight-(2*Margin)-TopMargin)<=0)           return false;
			// 			if((TopEdgePoint[3].x-FRightWidth-SideMargin) >=ImageWidth ||(TopEdgePoint[3].y+Margin)>TopLimitLine || FRightWidth>=ImageWidth || (RightHeight-(2*Margin)-TopMargin)>TopLimitLine) return false;
			// 			if((TopEdgePoint[3].x-FRightWidth-SideMargin)+FRightWidth >=ImageWidth ||((TopEdgePoint[3].y+Margin)+(RightHeight-(2*Margin)-TopMargin))>TopLimitLine) return false;

			DefectROI.SetPlacement((int)(TopEdgePoint[3].x-FRightWidth-SideMargin), (int)(TopEdgePoint[3].y+Margin), FRightWidth, (RightHeight-(2*Margin)-RightDegMargin));
			if((TopEdgePoint[3].x-FRightWidth-SideMargin) <=0          ||(TopEdgePoint[3].y+Margin)<=0           || FRightWidth<=0          || (RightHeight-(2*Margin)-RightDegMargin)<=0)           return false;
			if((TopEdgePoint[3].x-FRightWidth-SideMargin) >=ImageWidth ||(TopEdgePoint[3].y+Margin)>TopLimitLine || FRightWidth>=ImageWidth || (RightHeight-(2*Margin)-RightDegMargin)>TopLimitLine) return false;
			if((TopEdgePoint[3].x-FRightWidth-SideMargin)+FRightWidth >=ImageWidth ||((TopEdgePoint[3].y+Margin)+(RightHeight-(2*Margin)-RightDegMargin))>TopLimitLine) return false;

			//  Blob 검사 진행 
			CodeImageSelection.Clear();
			CodeImageEncoder.Encode(DefectROI,CodeImage);
			CodeImageSelection.Clear();
			CodeImageSelection.AddObjects(CodeImage);
			// Blob 필터링 
			CodeImageSelection.RemoveUsingFloatFeature(EFeature_BoundingBoxWidth ,FMinWidth     , FMaxWidth    , EDoubleThresholdMode_Outside);
			CodeImageSelection.RemoveUsingFloatFeature(EFeature_BoundingBoxHeight,FMinHeight    , FMaxHeight   , EDoubleThresholdMode_Outside);
			// 				CodeImageSelection.RemoveUsingIntegerFeature(EFeature_RightLimit     ,FRightWidth-2 , FRightWidth+1, EDoubleThresholdMode_Outside);
			CodeImageSelection.RemoveUsingIntegerFeature(EFeature_RightLimit     ,FRightWidth-1 , FRightWidth+1, EDoubleThresholdMode_Outside);

			BlobCount = CodeImageSelection.GetElementCount();
			CodeImageSelection.Sort(EFeature_TopLimit,ESortDirection_Ascending);

			if(BlobCount!=0){
				for(int k=0; k<BlobCount; k++){
					if(BCount>=MAX_DEFECT_POINT) break;
					BDefectPoint[BCount].Width  = CodeImageSelection.GetElement(k).GetBoundingBoxWidth() ;
					BDefectPoint[BCount].Height = CodeImageSelection.GetElement(k).GetBoundingBoxHeight();

					BDefectPoint[BCount].Rect.left   = (long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterX() - BDefectPoint[BCount].Width/2 ) +(TopEdgePoint[3].x-FRightWidth-SideMargin));
					BDefectPoint[BCount].Rect.top    = (long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - BDefectPoint[BCount].Height/2) +(TopEdgePoint[3].y+Margin)                );
					BDefectPoint[BCount].Rect.right  = (long)(BDefectPoint[BCount].Rect.left+ BDefectPoint[BCount].Width );
					BDefectPoint[BCount].Rect.bottom = (long)(BDefectPoint[BCount].Rect.top + BDefectPoint[BCount].Height);
					PixelCount = 0;
					PixelValue = 0;

					// 내부 Pixel Data 축출 
					for(int n=BDefectPoint[BCount].Rect.top+1 ; n<BDefectPoint[BCount].Rect.bottom-1; n++){
						for(int m=BDefectPoint[BCount].Rect.left+1; m<BDefectPoint[BCount].Rect.right-1 ; m++){
							PixelValue = IElement(m,n);
							if(PixelValue < EnCapTopThresHold) PixelCount++;
						}
					}
					BDefectPoint[BCount].Round  = PixelCount;
					BDefectPoint[BCount].P.x    = (float)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterX() - BDefectPoint[BCount].Width/2 ) +(TopEdgePoint[3].x-FRightWidth-SideMargin));
					BDefectPoint[BCount].P.y    = (float)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - BDefectPoint[BCount].Height/2) +(TopEdgePoint[3].y+Margin)+ImageHeight    );
					BDefectPoint[BCount].Width  = BDefectPoint[BCount].Width+SideMargin; 

					// Merge 위해서 데이터 필요함 
					BDefectPoint[BCount].Rect.top    =(long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - BDefectPoint[BCount].Height/2) + (TopEdgePoint[3].y+Margin)+ImageHeight);
					BDefectPoint[BCount].Rect.bottom =(long)(BDefectPoint[BCount].Rect.top + BDefectPoint[BCount].Height);
					BCount++;
				}
			}
			BlobCount =0;

			// 외곽라인에서 Mark까지의 거리 산출 
			if     (Line[waRightWall].FP0.x >Line[waRightWall].FP1.x) RDistance = ((Line[waRightWall].FP1.x+(Line[waRightWall].FP0.x - Line[waRightWall].FP1.x)/2) - FP1.x);
			else if(Line[waRightWall].FP0.x==Line[waRightWall].FP1.x) RDistance = (Line[waRightWall].FP0.x - FP1.x);
			else                                                      RDistance = ((Line[waRightWall].FP0.x+(Line[waRightWall].FP1.x - Line[waRightWall].FP0.x)/2) - FP1.x);

			// SIDE D 검사 
			////////////////////////////////////////////////////////////////////////////////////////////////
			// 			LogUnit.SetLog("CAP_Side_D_Start_CamId: %d, ImageHeight: %d ",CamId,ImageHeight);     
			// 			DefectROI.SetPlacement((int)(TopEdgePoint[0].x+SideMargin), (int)(TopEdgePoint[0].y+Margin), FLeftWidth, (LeftHeight-(2*Margin)-TopMargin));
			// 			if((TopEdgePoint[0].x+SideMargin) <=0          ||(TopEdgePoint[0].y+Margin)<=0           || FLeftWidth<=0          || (LeftHeight-(2*Margin)-TopMargin)<=0          ) return false;
			// 			if((TopEdgePoint[0].x+SideMargin) >=ImageWidth ||(TopEdgePoint[0].y+Margin)>TopLimitLine || FLeftWidth>=ImageWidth || (LeftHeight-(2*Margin)-TopMargin)>TopLimitLine) return false;
			// 			if((TopEdgePoint[0].x+SideMargin)+FLeftWidth >=ImageWidth ||(TopEdgePoint[0].y+Margin)+(LeftHeight-(2*Margin)-TopMargin)>TopLimitLine) return false;

			DefectROI.SetPlacement((int)(TopEdgePoint[0].x+SideMargin), (int)(TopEdgePoint[0].y+Margin), FLeftWidth, (LeftHeight-(2*Margin)-LeftDegMargin));
			if((TopEdgePoint[0].x+SideMargin) <=0          ||(TopEdgePoint[0].y+Margin)<=0           || FLeftWidth<=0          || (LeftHeight-(2*Margin)-LeftDegMargin)<=0          ) return false;
			if((TopEdgePoint[0].x+SideMargin) >=ImageWidth ||(TopEdgePoint[0].y+Margin)>TopLimitLine || FLeftWidth>=ImageWidth || (LeftHeight-(2*Margin)-LeftDegMargin)>TopLimitLine) return false;
			if((TopEdgePoint[0].x+SideMargin)+FLeftWidth >=ImageWidth ||(TopEdgePoint[0].y+Margin)+(LeftHeight-(2*Margin)-LeftDegMargin)>TopLimitLine) return false;

			// Blob 검사 진행 
			CodeImageSelection.Clear();
			CodeImageEncoder.Encode(DefectROI,CodeImage);
			CodeImageSelection.Clear();
			CodeImageSelection.AddObjects(CodeImage);

			// Blob 필터링 
			CodeImageSelection.RemoveUsingFloatFeature  (EFeature_BoundingBoxWidth ,FMinWidth , FMaxWidth  , EDoubleThresholdMode_Outside);
			CodeImageSelection.RemoveUsingFloatFeature  (EFeature_BoundingBoxHeight,FMinHeight, FMaxHeight , EDoubleThresholdMode_Outside);
			// 				CodeImageSelection.RemoveUsingIntegerFeature(EFeature_LeftLimit        ,0         , 3          , EDoubleThresholdMode_Outside);
			CodeImageSelection.RemoveUsingIntegerFeature(EFeature_LeftLimit        ,0         , 1          , EDoubleThresholdMode_Outside);

			BlobCount = CodeImageSelection.GetElementCount();
			CodeImageSelection.Sort(EFeature_TopLimit,ESortDirection_Ascending);

			if(BlobCount!=0){
				for(int k=0; k<BlobCount; k++){
					if(DCount>=MAX_DEFECT_POINT) break;
					DDefectPoint[DCount].Width     =  CodeImageSelection.GetElement(k).GetBoundingBoxWidth() ;
					DDefectPoint[DCount].Height    =  CodeImageSelection.GetElement(k).GetBoundingBoxHeight();

					DDefectPoint[DCount].Rect.left   = (long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterX() - DDefectPoint[DCount].Width/2 ) +(TopEdgePoint[0].x+SideMargin));
					DDefectPoint[DCount].Rect.top    = (long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - DDefectPoint[DCount].Height/2) +(TopEdgePoint[0].y+Margin)    );
					DDefectPoint[DCount].Rect.right  = (long)(DDefectPoint[DCount].Rect.left+ DDefectPoint[DCount].Width );
					DDefectPoint[DCount].Rect.bottom = (long)(DDefectPoint[DCount].Rect.top + DDefectPoint[DCount].Height);

					PixelCount = 0;
					PixelValue = 0;
					// 내부 Pixel Data 축출 
					for(int n=DDefectPoint[DCount].Rect.top+1 ; n<DDefectPoint[DCount].Rect.bottom-1; n++){
						for(int m=DDefectPoint[DCount].Rect.left+1; m<DDefectPoint[DCount].Rect.right-1 ; m++){
							PixelValue = IElement(m,n);
							if(PixelValue < EnCapTopThresHold) PixelCount++;
						}
					}
					// Display 데이터 필요함 
					DDefectPoint[DCount].Round = PixelCount;
					DDefectPoint[DCount].P.x       = (float)(DDefectPoint[DCount].Rect.left);
					DDefectPoint[DCount].P.y       = (float)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - DDefectPoint[DCount].Height/2)+(TopEdgePoint[0].y+Margin)+ImageHeight );
					DDefectPoint[DCount].Width     = DDefectPoint[DCount].Width+SideMargin; 

					// Merge 위해서 데이터 필요함 
					DDefectPoint[DCount].Rect.top    =(long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - DDefectPoint[DCount].Height/2) +(TopEdgePoint[0].y+Margin)+ImageHeight);
					DDefectPoint[DCount].Rect.bottom =(long)(DDefectPoint[DCount].Rect.top + DDefectPoint[DCount].Height);
					DCount++;
				}
			}
			BlobCount =0;

			// 외곽라인에서 Mark까지의 거리 산출 
			if     (Line[waLeftWall].FP0.x >Line[waLeftWall].FP1.x) LDistance = (FP0.x - (Line[waLeftWall].FP1.x+(Line[waLeftWall].FP0.x - Line[waLeftWall].FP1.x)/2));
			else if(Line[waLeftWall].FP0.x==Line[waLeftWall].FP1.x) LDistance = (FP0.x -  Line[waLeftWall].FP0.x)                                                     ;
			else                                                    LDistance = (FP0.x - (Line[waLeftWall].FP0.x+(Line[waLeftWall].FP1.x - Line[waLeftWall].FP0.x)/2)); 
		}


		// Cell Size 측정 데이터 넘겨줌(Image 회전 없을경우)
		LeftStaPos.x   =  FLTPoint.x            ;
		LeftStaPos.y   =  FLTPoint.y+ImageHeight;
		CenterStaPos.x =  FLTPoint.x + (FRTPoint.x - FLTPoint.x)/2            ; 
		CenterStaPos.y = (FLTPoint.y + FRTPoint.y)              /2+ImageHeight; 

		// FLTPoint,FRTPoint 기준 Image Rotate 적용하여 Display 목적으로 원본이미지 기준 좌표값 복원시킨
		if(ImgDegree!=0.0f){
			// 검사영역 분리과 상관없이 무조건 각도 적용하여 다시 계산해야 하는 좌표값들 
			// TopLine 
			Line[1].FP0 = Math.OnRotate(CenterPoint, Line[1].FP0  , (ImgDegree));
			Line[1].FP1 = Math.OnRotate(CenterPoint, Line[1].FP1  , (ImgDegree));

			// LeftOutLIne 
			LeftOutLine[0].FP0 = Math.OnRotate(CenterPoint, LeftOutLine[0].FP0  , (ImgDegree));
			LeftOutLine[0].FP1 = Math.OnRotate(CenterPoint, LeftOutLine[0].FP1  , (ImgDegree));

			// RightOutLIne 
			RightOutLine[0].FP0 = Math.OnRotate(CenterPoint, RightOutLine[0].FP0  , (ImgDegree));
			RightOutLine[0].FP1 = Math.OnRotate(CenterPoint, RightOutLine[0].FP1  , (ImgDegree));

			FRTPoint    = Math.OnRotate(CenterPoint, FRTPoint     , (ImgDegree));
			FLTPoint    = Math.OnRotate(CenterPoint, FLTPoint     , (ImgDegree));

			// Cell Size 측정 데이터 넘겨줌(Image  회전)
			LeftStaPos.x   =  FLTPoint.x            ;
			LeftStaPos.y   =  FLTPoint.y+ImageHeight;
			CenterStaPos.x =  FLTPoint.x + (FRTPoint.x - FLTPoint.x)/2            ; 
			CenterStaPos.y = (FLTPoint.y + FRTPoint.y)              /2+ImageHeight; 

			if(FCutMode==1){ // CAI_CUT 
				TopOutLine[0].FP0 = Math.OnRotate(CenterPoint, TopOutLine[0].FP0  , (ImgDegree));
				TopOutLine[0].FP1 = Math.OnRotate(CenterPoint, TopOutLine[0].FP1  , (ImgDegree));
				TopInLine [0].FP0 = Math.OnRotate(CenterPoint, TopInLine [0].FP0  , (ImgDegree));
				TopInLine [0].FP1 = Math.OnRotate(CenterPoint, TopInLine [0].FP1  , (ImgDegree));
			}

			if(IsCornerTop){
				FLTTPoint   = Math.OnRotate(CenterPoint, FLTTPoint    , (ImgDegree));
				FLTLPoint   = Math.OnRotate(CenterPoint, FLTLPoint    , (ImgDegree));
				FLTTInPoint = Math.OnRotate(CenterPoint, FLTTInPoint  , (ImgDegree));
				FLTLInPoint = Math.OnRotate(CenterPoint, FLTLInPoint  , (ImgDegree));
				FLTTMeaPoint= Math.OnRotate(CenterPoint, FLTTMeaPoint , (ImgDegree));
				FLTLMeaPoint= Math.OnRotate(CenterPoint, FLTLMeaPoint , (ImgDegree));

				FRTTPoint   = Math.OnRotate(CenterPoint, FRTTPoint    , (ImgDegree));
				FRTRPoint   = Math.OnRotate(CenterPoint, FRTRPoint    , (ImgDegree));
				FRTTInPoint = Math.OnRotate(CenterPoint, FRTTInPoint  , (ImgDegree));
				FRTRInPoint = Math.OnRotate(CenterPoint, FRTRInPoint  , (ImgDegree));
				FRTTMeaPoint= Math.OnRotate(CenterPoint, FRTTMeaPoint , (ImgDegree));
				FRTRMeaPoint= Math.OnRotate(CenterPoint, FRTRMeaPoint , (ImgDegree));

				// Corner Defect 좌표도 각도 적용하여 변경해야함 
				if(C1Count!=0){
					for(int k=0; k<C1Count; k++){
						// Fram기준 Y좌표값으로 원복한다 
						C1DefectPoint[k].P.y = C1DefectPoint[k].P.y - ImageHeight;
						if(C1DefectPoint[k].P.y>0) {
							C1DefectPoint[k].P   = Math.OnRotate(CenterPoint,C1DefectPoint[k].P,(ImgDegree)); 
							C1DefectPoint[k].P.y = C1DefectPoint[k].P.y + ImageHeight;
						}
						else {
							C1DefectPoint[k].P.y = C1DefectPoint[k].P.y + ImageHeight;
						}
					}
				}

				if(C2Count!=0){
					for(int k=0; k<C2Count; k++){
						// Fram기준 Y좌표값으로 원복한다 
						C2DefectPoint[k].P.y = C2DefectPoint[k].P.y - ImageHeight;
						if(C2DefectPoint[k].P.y>0) {
							C2DefectPoint[k].P   = Math.OnRotate(CenterPoint,C2DefectPoint[k].P,(ImgDegree)); 
							C2DefectPoint[k].P.y = C2DefectPoint[k].P.y + ImageHeight;
						}
						else {
							C2DefectPoint[k].P.y = C2DefectPoint[k].P.y + ImageHeight;
						}
					}
				}

				// GrindMarkPoint Rotate 
				if(IsMarkBtm){
					for(int k=19; k<27; k++){
						LtPos.x =0.0f, LtPos.y=0.0f,RbPos.x=0.0f,RbPos.y=0.0f;
						if(GrindMarkRect[k].left==0 || GrindMarkRect[k].top==0 || GrindMarkRect[k].right==0 || GrindMarkRect[k].bottom==0 ) continue;

						LtPos.x = (float)GrindMarkRect[k].left  ;
						LtPos.y = (float)GrindMarkRect[k].top   ;
						RbPos.x = (float)GrindMarkRect[k].right ;
						RbPos.y = (float)GrindMarkRect[k].bottom;
						LtPos = Math.OnRotate(CenterPoint, LtPos,ImgDegree);
						RbPos = Math.OnRotate(CenterPoint, RbPos,ImgDegree);

						GrindMarkRect[k].left   = (long)LtPos.x;
						GrindMarkRect[k].top    = (long)LtPos.y;
						GrindMarkRect[k].right  = (long)RbPos.x;
						GrindMarkRect[k].bottom = (long)RbPos.y;
						if(GrindMarkPoint[k].x!=0.0f && GrindMarkPoint[k].y!=0.0f) {
							GrindMarkPoint[k] = Math.OnRotate(CenterPoint, GrindMarkPoint[k],ImgDegree);
						}
					}
				}
			}
			else if(IsCircleTop) { // Display 목적으로 월래 각도 기준으로 좌표값을 다시 회전 시켜야 한다   
				// A영역 Circle_Defect 좌표 이미지 기준 회전함
				if(A1CirDeftectCnt!=0){
					for(int k=0; k<A1CirDeftectCnt; k++){
						A1CirDefectPoint[k].P.y = A1CirDefectPoint[k].P.y - ImageHeight;
						if(A1CirDefectPoint[k].P.y>0) {
							A1CirDefectPoint[k].P   = Math.OnRotate(CenterPoint,A1CirDefectPoint[k].P,(ImgDegree)); 
							A1CirDefectPoint[k].P.y = A1CirDefectPoint[k].P.y + ImageHeight;
						}
						else {
							A1CirDefectPoint[k].P.y = A1CirDefectPoint[k].P.y + ImageHeight;
						}
					}
				}

				if(A2CirDeftectCnt!=0){
					// A영역 Circle_Defect 좌표 이미지 기준 회전함
					for(int k=0; k<A2CirDeftectCnt; k++){
						A2CirDefectPoint[k].P.y = A2CirDefectPoint[k].P.y - ImageHeight;
						if(A2CirDefectPoint[k].P.y>0) {
							A2CirDefectPoint[k].P   = Math.OnRotate(CenterPoint,A2CirDefectPoint[k].P,(ImgDegree)); 
							A2CirDefectPoint[k].P.y = A2CirDefectPoint[k].P.y + ImageHeight;
						}
						else {
							A2CirDefectPoint[k].P.y = A2CirDefectPoint[k].P.y + ImageHeight;
						}
					}
				}

				// Circle Defect Data 
				// Bright Defect Data 
				////////////////////////////////////////////////////////////////////////////////////////////////
				if(A1CirCrackCnt!=0){
					for(int k=0; k<A1CirCrackCnt; k++){
						A1CirCrackPoint[k].P.y = A1CirCrackPoint[k].P.y - ImageHeight;
						if(A1CirCrackPoint[k].P.y>0) {
							A1CirCrackPoint[k].P   = Math.OnRotate(CenterPoint,A1CirCrackPoint[k].P,(ImgDegree)); 
							A1CirCrackPoint[k].P.y = A1CirCrackPoint[k].P.y + ImageHeight;
						}
						else {
							A1CirCrackPoint[k].P.y = A1CirCrackPoint[k].P.y + ImageHeight;
						}
					}
				}

				if(A2CirCrackCnt!=0){
					for(int k=0; k<A2CirCrackCnt; k++){
						A2CirCrackPoint[k].P.y = A2CirCrackPoint[k].P.y - ImageHeight;
						if(A2CirCrackPoint[k].P.y>0) {
							A2CirCrackPoint[k].P   = Math.OnRotate(CenterPoint,A2CirCrackPoint[k].P,(ImgDegree)); 
							A2CirCrackPoint[k].P.y = A2CirCrackPoint[k].P.y + ImageHeight;
						}
						else {
							A2CirCrackPoint[k].P.y = A2CirCrackPoint[k].P.y + ImageHeight;
						}
					}
				}
				//////////////////////////////////////////////////////////////////////////////////////

				if(A1CirInEdgeCount!=0){
					for(int k=0; k<A1CirInEdgeCount; k++){
						if(A1CirInPoint[k].x==0.0f || A1CirInPoint[k].y==0.0f) continue;
						A1CirInPoint[k] = Math.OnRotate(CenterPoint, A1CirInPoint[k], ImgDegree);
					}
				}
				if(A1CirOutEdgeCount!=0){
					for(int k=0; k<A1CirOutEdgeCount; k++){
						if(A1CirOutPoint[k].x==0.0f || A1CirOutPoint[k].y==0.0f) continue;
						A1CirOutPoint[k] = Math.OnRotate(CenterPoint, A1CirOutPoint[k], ImgDegree);
					}
				}
				// 				if(A1PolyInEdgeCount!=0){
				// 					for(int k=0; k<A1PolyInEdgeCount; k++){
				// 						if(A1PolyInPoint[k].x==0.0f || A1PolyInPoint[k].y==0.0f) continue;
				// 						A1PolyInPoint[k] = Math.OnRotate(CenterPoint, A1PolyInPoint[k], ImgDegree);
				// 					}
				// 				}


				if(A1CirCenter      .x!=0.0f && A1CirCenter      .y!=0.0f) A1CirCenter        = Math.OnRotate(CenterPoint, A1CirCenter       , (ImgDegree)); // 외곽 교차점 기준  
				if(RealA1CirCenter  .x!=0.0f && RealA1CirCenter  .y!=0.0f) RealA1CirCenter    = Math.OnRotate(CenterPoint, RealA1CirCenter   , (ImgDegree)); // Euresys 
				if(ACircleFit1Center.x!=0.0f && ACircleFit1Center.y!=0.0f) ACircleFit1Center  = Math.OnRotate(CenterPoint, ACircleFit1Center , (ImgDegree)); // FAVION

				if(A2CirInEdgeCount!=0){
					for(int k=0; k<A2CirInEdgeCount; k++){
						if(A2CirInPoint[k].x==0.0f || A2CirInPoint[k].y==0.0f) continue;
						A2CirInPoint[k] = Math.OnRotate(CenterPoint, A2CirInPoint[k], ImgDegree);
					}
				}
				if(A2CirOutEdgeCount!=0){
					for(int k=0; k<A2CirOutEdgeCount; k++){
						if(A2CirOutPoint[k].x==0.0f || A2CirOutPoint[k].y==0.0f) continue;
						A2CirOutPoint[k] = Math.OnRotate(CenterPoint, A2CirOutPoint[k], ImgDegree);
					}
				}

				if(A2CirCenter      .x!=0.0f && A2CirCenter      .y!=0.0f) A2CirCenter        = Math.OnRotate(CenterPoint, A2CirCenter       , (ImgDegree)); // 외곽 교차점 기준  
				if(RealA2CirCenter  .x!=0.0f && RealA2CirCenter  .y!=0.0f) RealA2CirCenter    = Math.OnRotate(CenterPoint, RealA2CirCenter   , (ImgDegree)); // Euresys 
				if(ACircleFit2Center.x!=0.0f && ACircleFit2Center.y!=0.0f) ACircleFit2Center  = Math.OnRotate(CenterPoint, ACircleFit2Center , (ImgDegree)); // FAVION

				// GrindMarkPoint Rotate 
				if(IsMarkBtm){
					for(int k=19; k<27; k++){
						LtPos.x =0.0f, LtPos.y=0.0f,RbPos.x=0.0f,RbPos.y=0.0f;
						if(GrindMarkRect[k].left==0 || GrindMarkRect[k].top==0 || GrindMarkRect[k].right==0 || GrindMarkRect[k].bottom==0 ) continue;

						LtPos.x = (float)GrindMarkRect[k].left  ;
						LtPos.y = (float)GrindMarkRect[k].top   ;
						RbPos.x = (float)GrindMarkRect[k].right ;
						RbPos.y = (float)GrindMarkRect[k].bottom;
						LtPos = Math.OnRotate(CenterPoint, LtPos,ImgDegree);
						RbPos = Math.OnRotate(CenterPoint, RbPos,ImgDegree);

						GrindMarkRect[k].left   = (long)LtPos.x;
						GrindMarkRect[k].top    = (long)LtPos.y;
						GrindMarkRect[k].right  = (long)RbPos.x;
						GrindMarkRect[k].bottom = (long)RbPos.y;
						if(GrindMarkPoint[k].x!=0.0f && GrindMarkPoint[k].y!=0.0f) {
							GrindMarkPoint[k] = Math.OnRotate(CenterPoint, GrindMarkPoint[k],ImgDegree);
						}
					}
					// Pad ROI Rect Rotate 
					for(int k=0; k<2; k++){
						LtPos.x =0.0f, LtPos.y=0.0f,RbPos.x=0.0f,RbPos.y=0.0f;
						if(PadPolyRect[k].left==0 || PadPolyRect[k].top==0 || PadPolyRect[k].right==0 || PadPolyRect[k].bottom==0 ) continue;

						LtPos.x = (float)PadPolyRect[k].left  ;
						LtPos.y = (float)PadPolyRect[k].top   ;
						RbPos.x = (float)PadPolyRect[k].right ;
						RbPos.y = (float)PadPolyRect[k].bottom;
						LtPos = Math.OnRotate(CenterPoint, LtPos,ImgDegree);
						RbPos = Math.OnRotate(CenterPoint, RbPos,ImgDegree);

						PadPolyRect[k].left   = (long)LtPos.x;
						PadPolyRect[k].top    = (long)LtPos.y;
						PadPolyRect[k].right  = (long)RbPos.x;
						PadPolyRect[k].bottom = (long)RbPos.y;
					}
				}
			}
		}
		////////////////////////////////////////////////////////////////////////////////////////////////
		Index = 0;
		return true;
		
		// NOTCH RectC : 젓가락 모양
		//------------------------------------------------------------------
	case 1 :
		// Side B
		/////////////////////////////////////////////////////////////////////////////////////////////////
		//LogUnit.SetLog("STATIC_Side_B_START_CamId: %d, ImageHeight: %d ",CamId,ImageHeight);     
		DefectROI.SetPlacement((int)(RSP.x-FRightWidth-SideMargin), (int)RSP.y, FRightWidth, RightHeight);
		if((RSP.x-FRightWidth-SideMargin) <=0          ||(RSP.y)<0           || FRightWidth<=0          || RightHeight<0         )return false;
		if((RSP.x-FRightWidth-SideMargin) >=ImageWidth ||(RSP.y)>ImageHeight || FRightWidth>=ImageWidth || RightHeight>ImageHeight)return false;
		if((RSP.x-FRightWidth-SideMargin)+FRightWidth >=ImageWidth ||(RSP.y)+RightHeight>ImageHeight                             )return false;
		//Line Position
		LinePosition = RSP.x-FRightWidth-SideMargin;
		// Blob 검사 진행함 
		CodeImageSelection.Clear();
		CodeImageEncoder.Encode(DefectROI,CodeImage);
		CodeImageSelection.Clear();
		CodeImageSelection.AddObjects(CodeImage);
		// Blob 필터링 
		CodeImageSelection.RemoveUsingFloatFeature  (EFeature_BoundingBoxWidth ,FMinWidth    , FMaxWidth     , EDoubleThresholdMode_Outside);
		CodeImageSelection.RemoveUsingFloatFeature  (EFeature_BoundingBoxHeight,FMinHeight   , FMaxHeight    , EDoubleThresholdMode_Outside);
		CodeImageSelection.RemoveUsingIntegerFeature(EFeature_RightLimit       ,FRightWidth-1, FRightWidth+1 , EDoubleThresholdMode_Outside);

		BlobCount = CodeImageSelection.GetElementCount();
		CodeImageSelection.Sort(EFeature_TopLimit,ESortDirection_Ascending);

		if(BlobCount!=0){
			for(int k=0; k<BlobCount; k++){
				if(BCount>=MAX_DEFECT_POINT) break; 
				BDefectPoint[BCount].Width  = CodeImageSelection.GetElement(k).GetBoundingBoxWidth();
				BDefectPoint[BCount].Height = CodeImageSelection.GetElement(k).GetBoundingBoxHeight();

				BDefectPoint[BCount].Rect.left   =(long)(((CodeImageSelection.GetElement(k).GetBoundingBoxCenterX() - BDefectPoint[BCount].Width/2) +LinePosition));
				BDefectPoint[BCount].Rect.top    =(long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - BDefectPoint[BCount].Height/2)               );
				BDefectPoint[BCount].Rect.right  =(long)(BDefectPoint[BCount].Rect.left+ BDefectPoint[BCount].Width );
				BDefectPoint[BCount].Rect.bottom =(long)(BDefectPoint[BCount].Rect.top + BDefectPoint[BCount].Height);

				PixelCount = 0;
				PixelValue = 0;

				// 내부 Pixel Data 축출 
				for(int n=BDefectPoint[BCount].Rect.top+1 ; n<BDefectPoint[BCount].Rect.bottom-1; n++){
					for(int m=BDefectPoint[BCount].Rect.left+1; m<BDefectPoint[BCount].Rect.right-1 ; m++){
						PixelValue = IElement(m,n);
						if(PixelValue < EnCapMidThresHold) PixelCount++;
					}
				}

				BDefectPoint[BCount].Round  = PixelCount;
				BDefectPoint[BCount].P.x    =(float)(BDefectPoint[BCount].Rect.left);
				BDefectPoint[BCount].P.y    =(float)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - BDefectPoint[BCount].Height/2) +ImageHeight );
				BDefectPoint[BCount].Width  = (InspectMode)? BDefectPoint[BCount].Width :BDefectPoint[BCount].Width+SideMargin; 

				// Merge 위해서 데이터 필요함 
				BDefectPoint[BCount].Rect.top    =(long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - BDefectPoint[BCount].Height/2) +ImageHeight);
				BDefectPoint[BCount].Rect.bottom =(long)(BDefectPoint[BCount].Rect.top + BDefectPoint[BCount].Height);
				BCount++;
			}
		}
		BlobCount =0;
		//  		LogUnit.SetLog("STATIC_Side_B_END_CamId: %d, ImageHeight: %d ",CamId,ImageHeight);     
		// 외곽라인에서 Mark까지의 거리 산출 
		// CellSize 
		if     (Line[waRightWall].FP0.x >Line[waRightWall].FP1.x) RDistance = (Line[waRightWall].FP1.x+(Line[waRightWall].FP0.x - Line[waRightWall].FP1.x)/2) - FP1.x;
		else if(Line[waRightWall].FP0.x==Line[waRightWall].FP1.x) RDistance =  Line[waRightWall].FP0.x - FP1.x;
		else                                                      RDistance = (Line[waRightWall].FP0.x+(Line[waRightWall].FP1.x - Line[waRightWall].FP0.x)/2) - FP1.x;

		// SIDE-D
		DefectROI.SetPlacement((int)(LSP.x+SideMargin),(int)LSP.y, FLeftWidth, LeftHeight);
		if((LSP.x+SideMargin) <=0          || (LSP.y)<0           || FLeftWidth<=0          || LeftHeight<0          ) return false;
		if((LSP.x+SideMargin) >=ImageWidth || (LSP.y)>ImageHeight || FLeftWidth>=ImageWidth || LeftHeight>ImageHeight) return false;
		if((LSP.x+SideMargin)+FLeftWidth >=ImageWidth || (LSP.y)+LeftHeight>ImageHeight                              ) return false;
		// Line Position
		LinePosition = LSP.x+SideMargin;
		// Blob 검사 진행 
		CodeImageSelection.Clear();
		CodeImageEncoder.Encode(DefectROI,CodeImage);
		CodeImageSelection.Clear();
		CodeImageSelection.AddObjects(CodeImage);
		// Blob 필터링 
		CodeImageSelection.RemoveUsingFloatFeature(EFeature_BoundingBoxWidth ,FMinWidth , FMaxWidth  , EDoubleThresholdMode_Outside);
		CodeImageSelection.RemoveUsingFloatFeature(EFeature_BoundingBoxHeight,FMinHeight, FMaxHeight , EDoubleThresholdMode_Outside);
		CodeImageSelection.RemoveUsingIntegerFeature(EFeature_LeftLimit        ,0       , 1          , EDoubleThresholdMode_Outside);

		BlobCount = CodeImageSelection.GetElementCount();
		CodeImageSelection.Sort(EFeature_TopLimit,ESortDirection_Ascending);

		if(BlobCount!=0){
			for(int k=0; k<BlobCount; k++){
				if(DCount>=MAX_DEFECT_POINT) break; 
				DDefectPoint[DCount].Width  = CodeImageSelection.GetElement(k).GetBoundingBoxWidth() ;
				DDefectPoint[DCount].Height = CodeImageSelection.GetElement(k).GetBoundingBoxHeight();

				DDefectPoint[DCount].Rect.left   =(long)(((CodeImageSelection.GetElement(k).GetBoundingBoxCenterX() - DDefectPoint[DCount].Width/2 ) +LinePosition));
				DDefectPoint[DCount].Rect.top    =(long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - DDefectPoint[DCount].Height/2)                );
				DDefectPoint[DCount].Rect.right  =(long)(DDefectPoint[DCount].Rect.left+ DDefectPoint[DCount].Width) ; 
				DDefectPoint[DCount].Rect.bottom =(long)(DDefectPoint[DCount].Rect.top + DDefectPoint[DCount].Height);

				PixelCount =0;
				PixelValue =0;

				// 내부 Pixel Data 축출 
				for(int n=DDefectPoint[DCount].Rect.top+1 ; n<DDefectPoint[DCount].Rect.bottom-1; n++){
					for(int m=DDefectPoint[DCount].Rect.left+1; m<DDefectPoint[DCount].Rect.right-1 ; m++){
						PixelValue = IElement(m,n);
						if(PixelValue < EnCapMidThresHold) PixelCount++;
					}
				}

				DDefectPoint[DCount].Round = PixelCount;
				DDefectPoint[DCount].P.x    =(float)(DDefectPoint[DCount].Rect.left); 
				DDefectPoint[DCount].P.y    =(float)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - DDefectPoint[DCount].Height/2)+ImageHeight  );
				DDefectPoint[DCount].Width  = (InspectMode)? DDefectPoint[DCount].Width :DDefectPoint[DCount].Width+SideMargin; 

				// Merge 위해서 데이터 필요함 
				DDefectPoint[DCount].Rect.top    =(long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - DDefectPoint[DCount].Height/2)+ImageHeight);
				DDefectPoint[DCount].Rect.bottom =(long)(DDefectPoint[DCount].Rect.top + DDefectPoint[DCount].Height);
				DCount++;
			}
		}
		BlobCount =0;
		//  		LogUnit.SetLog("STATIC_Side_D_END_CamId: %d, ImageHeight: %d ",CamId,ImageHeight);     
		// Notch Cell Size Calc
		if(LSP.x!=0.0f  && RSP.x!=0.0f ){
			CenterCellSize = Math.GetLengthFrPointToPoint(LSP,RSP);
			TotalCellSizeWidth+=CenterCellSize;
			TotalCellSizeCount++;
		}
		// 외곽라인에서 Mark까지의 거리 산출 
		// CellSize 
		if     (Line[waLeftWall].FP0.x >Line[waLeftWall].FP1.x) LDistance = FP0.x - (Line[waLeftWall].FP1.x+(Line[waLeftWall].FP0.x - Line[waLeftWall].FP1.x)/2);
		else if(Line[waLeftWall].FP0.x==Line[waLeftWall].FP1.x) LDistance = FP0.x -  Line[waLeftWall].FP0.x;
		else                                                    LDistance = FP0.x - (Line[waLeftWall].FP0.x+(Line[waLeftWall].FP1.x - Line[waLeftWall].FP0.x)/2); 
		////////////////////////////////////////////////////////////////////////////////////////////////

		// Broken 및 박리 불량 검사 시퀀스(EnCap만 진행함)
		if(!IsMarkBtm && BrokenThresHold!=0){
			RotateBrokenImg.SetSize(GImage->GetWidth(), GImage->GetHeight())       ;
			EasyImage::Oper(EArithmeticLogicOperation_Copy,GImage,&RotateBrokenImg);
			EasyImage::Threshold(GImage    ,&RotateBrokenImg, BrokenThresHold)     ;

			DefectROI.Attach(&RotateBrokenImg);
			CodeImageSelection.SetFeretAngle(0.00f);
			CodeImageEncoder.GetGrayscaleSingleThresholdSegmenter().SetWhiteLayerEncoded(true );
			CodeImageEncoder.GetGrayscaleSingleThresholdSegmenter().SetBlackLayerEncoded(false);
			IAddress = RotateBrokenImg.GetImagePtr();

			FRightWidth = 60; // 테스트 목적
			FLeftWidth  = 60; // 테스트 목적

			// Side_B Bright Defect 검출 및 분류(Broken,반원형 박리___꽃박리)
			/////////////////////////////////////////////////////////////////////////////////////////////////
			DefectROI.SetPlacement((int)(RSP.x-FRightWidth-SideMargin), (int)RSP.y, FRightWidth, RightHeight);
			if((RSP.x-FRightWidth-SideMargin) <=0          ||(RSP.y)<0           || FRightWidth<=0          || RightHeight<0          )return false;
			if((RSP.x-FRightWidth-SideMargin) >=ImageWidth ||(RSP.y)>ImageHeight || FRightWidth>=ImageWidth || RightHeight>ImageHeight)return false;
			if((RSP.x-FRightWidth-SideMargin)+FRightWidth >=ImageWidth ||(RSP.y)+RightHeight>ImageHeight                              )return false;
			//Line Position
			LinePosition = RSP.x-FRightWidth-SideMargin;
			// Blob 검사 진행함 
			CodeImageSelection.Clear();
			CodeImageEncoder.Encode(DefectROI,CodeImage);
			CodeImageSelection.Clear();
			CodeImageSelection.AddObjects(CodeImage);
			// Blob 필터링 
			CodeImageSelection.RemoveUsingFloatFeature  (EFeature_BoundingBoxWidth ,FMinWidth    , FMaxWidth     , EDoubleThresholdMode_Outside);
			CodeImageSelection.RemoveUsingFloatFeature  (EFeature_BoundingBoxHeight,FMinHeight   , FMaxHeight    , EDoubleThresholdMode_Outside);
			// 			CodeImageSelection.RemoveUsingIntegerFeature(EFeature_RightLimit       ,FRightWidth-1, FRightWidth+1 , EDoubleThresholdMode_Outside);

			BlobCount = CodeImageSelection.GetElementCount();
			CodeImageSelection.Sort(EFeature_TopLimit,ESortDirection_Ascending);

			if(BlobCount!=0){
				for(int k=0; k<BlobCount; k++){
					if(BCount>=MAX_DEFECT_POINT) break; 
					BCrackPoint[BCrackCount].Width  = CodeImageSelection.GetElement(k).GetBoundingBoxWidth();
					BCrackPoint[BCrackCount].Height = CodeImageSelection.GetElement(k).GetBoundingBoxHeight();

					BCrackPoint[BCrackCount].Rect.left   =(long)(((CodeImageSelection.GetElement(k).GetBoundingBoxCenterX() - BCrackPoint[BCrackCount].Width/2) +LinePosition));
					BCrackPoint[BCrackCount].Rect.top    =(long)(( CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - BCrackPoint[BCrackCount].Height/2)              );
					BCrackPoint[BCrackCount].Rect.right  =(long)(BCrackPoint[BCrackCount].Rect.left+ BCrackPoint[BCrackCount].Width );
					BCrackPoint[BCrackCount].Rect.bottom =(long)(BCrackPoint[BCrackCount].Rect.top + BCrackPoint[BCrackCount].Height);
					BCrackPoint[BCrackCount].LineAttach  =((CodeImageSelection.GetElement(k).GetRightLimit() > (FRightWidth-5))>0)? 1:0; //LineAttach:1 반원형 박리, 0: 꽃박리 

					PixelCount = 0;
					PixelValue = 0;

					// 내부 Pixel Data 축출 
					for(int n=BCrackPoint[BCrackCount].Rect.top+1 ; n<BCrackPoint[BCrackCount].Rect.bottom-1; n++){
						for(int m=BCrackPoint[BCrackCount].Rect.left+1; m<BCrackPoint[BCrackCount].Rect.right-1 ; m++){
							PixelValue = IElement(m,n);
							if(PixelValue > BrokenThresHold) PixelCount++;
						}
					}

					BCrackPoint[BCrackCount].Round  = PixelCount;
					BCrackPoint[BCrackCount].P.x    =(float)(BCrackPoint[BCrackCount].Rect.left);
					BCrackPoint[BCrackCount].P.y    =(float)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - BCrackPoint[BCrackCount].Height/2) +ImageHeight );
					BCrackPoint[BCrackCount].Width  = (InspectMode)? BCrackPoint[BCrackCount].Width :BCrackPoint[BCrackCount].Width+SideMargin; 

					// Merge 위해서 데이터 필요함 
					BCrackPoint[BCrackCount].Rect.top    =(long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - BCrackPoint[BCrackCount].Height/2) +ImageHeight);
					BCrackPoint[BCrackCount].Rect.bottom =(long)(BCrackPoint[BCrackCount].Rect.top + BCrackPoint[BCrackCount].Height);
					BCrackCount++;
				}
			}
			BlobCount =0;

			// Side_D Bright Defect 검출 및 분류(Broken,반원형 박리___꽃박리)
			/////////////////////////////////////////////////////////////////////////////////////////////////
			DefectROI.SetPlacement((int)(LSP.x+SideMargin),(int)LSP.y, FLeftWidth, LeftHeight);
			if((LSP.x+SideMargin) <=0          || (LSP.y)<0           || FLeftWidth<=0          || LeftHeight<0          ) return false;
			if((LSP.x+SideMargin) >=ImageWidth || (LSP.y)>ImageHeight || FLeftWidth>=ImageWidth || LeftHeight>ImageHeight) return false;
			if((LSP.x+SideMargin)+FLeftWidth >=ImageWidth || (LSP.y)+LeftHeight>ImageHeight                              ) return false;
			// Line Position
			LinePosition = LSP.x+SideMargin;
			// Blob 검사 진행 
			CodeImageSelection.Clear();
			CodeImageEncoder.Encode(DefectROI,CodeImage);
			CodeImageSelection.Clear();
			CodeImageSelection.AddObjects(CodeImage);
			// Blob 필터링 
			CodeImageSelection.RemoveUsingFloatFeature(EFeature_BoundingBoxWidth ,FMinWidth , FMaxWidth  , EDoubleThresholdMode_Outside);
			CodeImageSelection.RemoveUsingFloatFeature(EFeature_BoundingBoxHeight,FMinHeight, FMaxHeight , EDoubleThresholdMode_Outside);
			// 			CodeImageSelection.RemoveUsingIntegerFeature(EFeature_LeftLimit        ,0       , 1          , EDoubleThresholdMode_Outside);

			BlobCount = CodeImageSelection.GetElementCount();
			CodeImageSelection.Sort(EFeature_TopLimit,ESortDirection_Ascending);

			if(BlobCount!=0){
				for(int k=0; k<BlobCount; k++){
					if(BCount>=MAX_DEFECT_POINT) break; 
					DCrackPoint[DCrackCount].Width  = CodeImageSelection.GetElement(k).GetBoundingBoxWidth();
					DCrackPoint[DCrackCount].Height = CodeImageSelection.GetElement(k).GetBoundingBoxHeight();

					DCrackPoint[DCrackCount].Rect.left   =(long)(((CodeImageSelection.GetElement(k).GetBoundingBoxCenterX() - DCrackPoint[DCrackCount].Width/2) +LinePosition));
					DCrackPoint[DCrackCount].Rect.top    =(long)(( CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - DCrackPoint[DCrackCount].Height/2)              );
					DCrackPoint[DCrackCount].Rect.right  =(long)(DCrackPoint[DCrackCount].Rect.left+ DCrackPoint[DCrackCount].Width );
					DCrackPoint[DCrackCount].Rect.bottom =(long)(DCrackPoint[DCrackCount].Rect.top + DCrackPoint[DCrackCount].Height);
					DCrackPoint[DCrackCount].LineAttach  =(CodeImageSelection.GetElement(k).GetLeftLimit() < 5)? 1:0; //LineAttach:1 반원형 박리, 0: 꽃박리 

					PixelCount = 0;
					PixelValue = 0;

					// 내부 Pixel Data 축출 
					for(int n=DCrackPoint[DCrackCount].Rect.top+1 ; n<DCrackPoint[DCrackCount].Rect.bottom-1; n++){
						for(int m=DCrackPoint[DCrackCount].Rect.left+1; m<DCrackPoint[DCrackCount].Rect.right-1 ; m++){
							PixelValue = IElement(m,n);
							if(PixelValue > BrokenThresHold) PixelCount++;
						}
					}

					DCrackPoint[DCrackCount].Round  = PixelCount;
					DCrackPoint[DCrackCount].P.x    =(float)(DCrackPoint[DCrackCount].Rect.left);
					DCrackPoint[DCrackCount].P.y    =(float)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - DCrackPoint[DCrackCount].Height/2) +ImageHeight );
					DCrackPoint[DCrackCount].Width  = (InspectMode)? DCrackPoint[DCrackCount].Width :DCrackPoint[DCrackCount].Width+SideMargin; 

					// Merge 위해서 데이터 필요함 
					DCrackPoint[DCrackCount].Rect.top    =(long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - DCrackPoint[DCrackCount].Height/2) +ImageHeight);
					DCrackPoint[DCrackCount].Rect.bottom =(long)(DCrackPoint[DCrackCount].Rect.top + DCrackPoint[DCrackCount].Height);
					DCrackCount++;
				}
			}
			BlobCount =0;
		}
		Index = 0;
		return true;
			
		// NOTCH RectC : 컵모양
		//------------------------------------------------------------------
	case 2 :

		if(IsCornerBtm)     { //Corner Cutting 일경우 Defect 검사 시퀀스 
			if(C3InEdgeCount!=0){
				CornerCount=0;
				for(int k=0; k<C3InEdgeCount; k++){
					if(C3InPoint[k].y<FLBLPoint.y-1) continue;
					Dis = Math.GetLengthFrLineToPoint(FLBLInPoint, FLBBInPoint, C3InPoint[k]);
					C3Corner[CornerCount].Dv   = Dis         ;
					C3Corner[CornerCount].P.x  = C3InPoint[k].x;
					C3Corner[CornerCount].P.y  = C3InPoint[k].y;
					CornerCount++;
				}
				C3Count = GetSize(C3Corner, C3DefectPoint, CornerCount, 5);
			}

			if(C4InEdgeCount!=0){
				CornerCount=0;
				for(int k=0; k<C4InEdgeCount; k++){
					if(C4InPoint[k].y<FRBRPoint.y-1) continue;
					Dis = Math.GetLengthFrLineToPoint(FRBRInPoint, FRBBInPoint, C4InPoint[k]);
					C4Corner[CornerCount].Dv   = Dis         ;
					C4Corner[CornerCount].P.x  = C4InPoint[k].x;
					C4Corner[CornerCount].P.y  = C4InPoint[k].y;
					CornerCount++;
				}
				C4Count = GetSize(C4Corner, C4DefectPoint, CornerCount, 5);
			}
			// Side D 
			///////////////////////////////////////////////////////////////////////////////////////////////////////////////
			//LogUnit.SetLog("CUP_Side_D_Start_CamId: %d, ImageHeight: %d ",CamId,ImageHeight);     
			DefectROI.SetPlacement((int)(SP.x+SideMargin),(int)(SP.y+BtmMargin), FLeftWidth, LeftHeight-(2*BtmMargin));
			if((SP.x+SideMargin) <=0          || SP.y+BtmMargin< 0            || FLeftWidth<=0          || LeftHeight-(2*BtmMargin)< 0           ) return false;
			if((SP.x+SideMargin) >=ImageWidth || SP.y+BtmMargin> BtmLimitLine || FLeftWidth>=ImageWidth || LeftHeight-(2*BtmMargin)> BtmLimitLine) return false;
			if((SP.x+SideMargin)+FLeftWidth >=ImageWidth || (SP.y+BtmMargin)+(LeftHeight-(2*BtmMargin))> BtmLimitLine                            ) return false;

			// Line Position 
			LinePosition = SP.x+SideMargin;
			// Blob 검사 진행 
			CodeImageSelection.Clear();
			CodeImageEncoder.Encode(DefectROI,CodeImage);
			CodeImageSelection.Clear();
			CodeImageSelection.AddObjects(CodeImage);
			// Blob 필터링 
			CodeImageSelection.RemoveUsingFloatFeature(EFeature_BoundingBoxWidth ,FMinWidth , FMaxWidth  , EDoubleThresholdMode_Outside);
			CodeImageSelection.RemoveUsingFloatFeature(EFeature_BoundingBoxHeight,FMinHeight, FMaxHeight , EDoubleThresholdMode_Outside);
			// 				CodeImageSelection.RemoveUsingIntegerFeature(EFeature_LeftLimit        ,0       , 3          , EDoubleThresholdMode_Outside);
			CodeImageSelection.RemoveUsingIntegerFeature(EFeature_LeftLimit        ,0       , 1          , EDoubleThresholdMode_Outside);

			BlobCount = CodeImageSelection.GetElementCount();
			CodeImageSelection.Sort(EFeature_TopLimit,ESortDirection_Ascending);

			if(BlobCount!=0){
				for(int k=0; k<BlobCount; k++){
					if(DCount>=MAX_DEFECT_POINT) break;
					DDefectPoint[DCount].Width  =  CodeImageSelection.GetElement(k).GetBoundingBoxWidth() ;
					DDefectPoint[DCount].Height =  CodeImageSelection.GetElement(k).GetBoundingBoxHeight();

					DDefectPoint[DCount].Rect.left   =(long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterX() - DDefectPoint[DCount].Width/2 ) +LinePosition );
					DDefectPoint[DCount].Rect.top    =(long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - DDefectPoint[DCount].Height/2)+(SP.y+BtmMargin));
					DDefectPoint[DCount].Rect.right  =(long)(DDefectPoint[DCount].Rect.left+ DDefectPoint[DCount].Width );
					DDefectPoint[DCount].Rect.bottom =(long)(DDefectPoint[DCount].Rect.top + DDefectPoint[DCount].Height);
					PixelCount =0;
					PixelValue =0;

					// 내부 Pixel Data 축출 
					for(int n=DDefectPoint[DCount].Rect.top+1 ; n<DDefectPoint[DCount].Rect.bottom-1; n++){
						for(int m=DDefectPoint[DCount].Rect.left+1; m<DDefectPoint[DCount].Rect.right-1 ; m++){
							PixelValue = IElement(m,n);
							if(PixelValue < EnCapBtmThresHold) PixelCount++;
						}
					}

					DDefectPoint[DCount].Round = PixelCount;
					DDefectPoint[DCount].P.x    =(float)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterX() - DDefectPoint[DCount].Width/2 ) +LinePosition);
					DDefectPoint[DCount].P.y    =(float)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - DDefectPoint[DCount].Height/2)+(SP.y+BtmMargin)+ImageHeight);
					DDefectPoint[DCount].Width  = (InspectMode)?DDefectPoint[DCount].Width: DDefectPoint[DCount].Width+SideMargin;

					// Merge 위해서 데이터 필요함 
					DDefectPoint[DCount].Rect.top    =(long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - DDefectPoint[DCount].Height/2) +(SP.y+BtmMargin)+ImageHeight);
					DDefectPoint[DCount].Rect.bottom =(long)(DDefectPoint[DCount].Rect.top + DDefectPoint[DCount].Height);
					DCount++;
				}
			}
			BlobCount=0;
			// 외곽라인에서 Mark까지의 거리 산출 
			if     (Line[waLeftWall].FP0.x >Line[waLeftWall].FP1.x) LDistance = FP0.x - (Line[waLeftWall].FP1.x+(Line[waLeftWall].FP0.x - Line[waLeftWall].FP1.x)/2);
			else if(Line[waLeftWall].FP0.x==Line[waLeftWall].FP1.x) LDistance = FP0.x -  Line[waLeftWall].FP0.x;
			else                                                    LDistance = FP0.x - (Line[waLeftWall].FP0.x+(Line[waLeftWall].FP1.x - Line[waLeftWall].FP0.x)/2); 
			////////////////////////////////////////////////////////////////////////////////////////////////


			// Side B
			////////////////////////////////////////////////////////////////////////////////////////////////
			DefectROI.SetPlacement((int)(EP.x-FRightWidth-SideMargin),(int)(EP.y+BtmMargin), FRightWidth,  RightHeight-(2*BtmMargin));
			if((EP.x-FRightWidth-SideMargin) <=0          || (EP.y+BtmMargin)< 0            || FRightWidth<=0           || RightHeight-(2*BtmMargin)< 0           ) return false;
			if((EP.x-FRightWidth-SideMargin) >=ImageWidth || (EP.y+BtmMargin)> BtmLimitLine || FRightWidth>=ImageWidth  || RightHeight-(2*BtmMargin)> BtmLimitLine) return false;
			if((EP.x-FRightWidth-SideMargin)+FRightWidth >=ImageWidth || (EP.y+BtmMargin)+(RightHeight-(2*BtmMargin))> BtmLimitLine                               ) return false;

			// Line Position 
			LinePosition = EP.x - FRightWidth- SideMargin;
			// Blob 검사 진행 
			CodeImageSelection.Clear();
			CodeImageEncoder.Encode(DefectROI,CodeImage);
			CodeImageSelection.Clear();
			CodeImageSelection.AddObjects(CodeImage);
			// Blob 필터링 
			CodeImageSelection.RemoveUsingFloatFeature  (EFeature_BoundingBoxWidth ,FMinWidth               , FMaxWidth                , EDoubleThresholdMode_Outside);
			CodeImageSelection.RemoveUsingFloatFeature  (EFeature_BoundingBoxHeight,FMinHeight              , FMaxHeight               , EDoubleThresholdMode_Outside);
			CodeImageSelection.RemoveUsingIntegerFeature(EFeature_RightLimit     ,FRightWidth -1            , FRightWidth+1            , EDoubleThresholdMode_Outside);

			BlobCount = CodeImageSelection.GetElementCount();
			CodeImageSelection.Sort(EFeature_TopLimit,ESortDirection_Ascending);

			if(BlobCount!=0){
				for(int k=0; k<BlobCount; k++){
					if(BCount>=MAX_DEFECT_POINT) break;
					BDefectPoint[BCount].Width  = CodeImageSelection.GetElement(k).GetBoundingBoxWidth() ; 
					BDefectPoint[BCount].Height = CodeImageSelection.GetElement(k).GetBoundingBoxHeight();

					BDefectPoint[BCount].Rect.left   =(long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterX() - BDefectPoint[BCount].Width/2 ) +(LinePosition)  );
					BDefectPoint[BCount].Rect.top    =(long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - BDefectPoint[BCount].Height/2) +(EP.y+BtmMargin));
					BDefectPoint[BCount].Rect.right  =(long)(BDefectPoint[BCount].Rect.left+ BDefectPoint[BCount].Width );
					BDefectPoint[BCount].Rect.bottom =(long)(BDefectPoint[BCount].Rect.top + BDefectPoint[BCount].Height);
					PixelCount = 0;
					PixelValue = 0;

					// 내부 Pixel Data 축출 
					for(int n=BDefectPoint[BCount].Rect.top+1 ; n<BDefectPoint[BCount].Rect.bottom-1; n++){
						for(int m=BDefectPoint[BCount].Rect.left+1; m<BDefectPoint[BCount].Rect.right-1 ; m++){
							PixelValue = IElement(m,n);
							if(PixelValue < EnCapBtmThresHold) PixelCount++;
						}
					}
					BDefectPoint[BCount].Round  = PixelCount;
					BDefectPoint[BCount].P.x    =(float)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterX() - BDefectPoint[BCount].Width/2 )+(LinePosition));
					BDefectPoint[BCount].P.y    =(float)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - BDefectPoint[BCount].Height/2)+(EP.y+BtmMargin)+ImageHeight   );
					BDefectPoint[BCount].Width  =(InspectMode)? BDefectPoint[BCount].Width: BDefectPoint[BCount].Width+SideMargin;

					// Merge 위해서 데이터 필요함 
					BDefectPoint[BCount].Rect.top    =(long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - BDefectPoint[BCount].Height/2) +(EP.y+BtmMargin)+ImageHeight);
					BDefectPoint[BCount].Rect.bottom =(long)(BDefectPoint[BCount].Rect.top + BDefectPoint[BCount].Height);
					BCount++;
				}
			}
			BlobCount =0;
			// 외곽라인에서 Mark까지의 거리 산출 
			if     (Line[waRightWall].FP0.x >Line[waRightWall].FP1.x) RDistance = (Line[waRightWall].FP1.x+(Line[waRightWall].FP0.x - Line[waRightWall].FP1.x)/2) - FP1.x;
			else if(Line[waRightWall].FP0.x==Line[waRightWall].FP1.x) RDistance =  Line[waRightWall].FP0.x - FP1.x;
			else                                                      RDistance = (Line[waRightWall].FP0.x+(Line[waRightWall].FP1.x - Line[waRightWall].FP0.x)/2) - FP1.x;
			////////////////////////////////////////////////////////////////////////////////////////////////
			// SIDE C 
			// Btm검사시 오버킬을 줄위기 위해서 
			if(fabs(FLBBPoint.y - FRBBPoint.y)>3) BTMLine = (FLBBPoint.y > FRBBPoint.y) ?(int)FRBBPoint.y : (int)FLBBPoint.y ;
			else                                  BTMLine = (FLBBPoint.y > FRBBPoint.y) ?(int)FLBBPoint.y : (int)FRBBPoint.y ;

			DefectROI.SetPlacement((int)FLBBPoint.x+SideMargin, (int)(BTMLine-FBtmHeight), BtmWidth -(2*SideMargin), FBtmHeight);
			if((FLBBPoint.x+SideMargin) <=0          ||(BTMLine-FBtmHeight)< 0            || BtmWidth -(2*SideMargin)<=0          || FBtmHeight< 0           ) return false;
			if((FLBBPoint.x+SideMargin) >=ImageWidth ||(BTMLine-FBtmHeight)> BtmLimitLine || BtmWidth -(2*SideMargin)>=ImageWidth || FBtmHeight> BtmLimitLine) return false;
			if((FLBBPoint.x+SideMargin)+(BtmWidth -(2*SideMargin)) >=ImageWidth ||(BTMLine-FBtmHeight)+FBtmHeight> BtmLimitLine                              ) return false;

			//if(BtmLimitLine!=0){
			//	if(((BtmBMLine[0].FP0.y+BtmBMLine[0].FP1.y)/2+BtmOffset)>BtmLimitLine) return false;
			//}

			CodeImageSelection.Clear();
			CodeImageEncoder.Encode(DefectROI,CodeImage);
			CodeImageSelection.Clear();
			CodeImageSelection.AddObjects(CodeImage);
			// Blob 필터링 
			CodeImageSelection.RemoveUsingFloatFeature  (EFeature_BoundingBoxWidth ,FMinWidth      , FMaxWidth   , EDoubleThresholdMode_Outside);
			CodeImageSelection.RemoveUsingFloatFeature  (EFeature_BoundingBoxHeight,FMinHeight     , FMaxHeight  , EDoubleThresholdMode_Outside);
			CodeImageSelection.RemoveUsingIntegerFeature(EFeature_BottomLimit      ,FBtmHeight-1   , FBtmHeight+1, EDoubleThresholdMode_Outside);


			BlobCount = CodeImageSelection.GetElementCount();
			CodeImageSelection.Sort(EFeature_LeftLimit ,ESortDirection_Ascending);

			if(BlobCount!=0){
				for(int k=0; k<BlobCount; k++){
					if(CCount>=MAX_DEFECT_POINT) break; 
					CDefectPoint[CCount].Width  =  CodeImageSelection.GetElement(k).GetBoundingBoxWidth() ;
					CDefectPoint[CCount].Height =  CodeImageSelection.GetElement(k).GetBoundingBoxHeight();

					CDefectPoint[CCount].Rect.left   =(long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterX() - CDefectPoint[CCount].Width/2 ) +FLBBPoint.x+SideMargin);
					// 						CDefectPoint[CCount].Rect.top    =(long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - CDefectPoint[CCount].Height/2) +((FLBBPoint.y+FRBBPoint.y)/2-FBtmHeight-1));
					CDefectPoint[CCount].Rect.top    =(long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - CDefectPoint[CCount].Height/2) +(BTMLine-FBtmHeight));
					CDefectPoint[CCount].Rect.right  =(long)(CDefectPoint[CCount].Rect.left+ CDefectPoint[CCount].Width );
					CDefectPoint[CCount].Rect.bottom =(long)(CDefectPoint[CCount].Rect.top + CDefectPoint[CCount].Height);
					PixelCount = 0;
					PixelValue = 0;

					// 내부 Pixel Data 축출 
					for(int n=CDefectPoint[CCount].Rect.top+1 ; n<CDefectPoint[CCount].Rect.bottom-1; n++){
						for(int m=CDefectPoint[CCount].Rect.left+1; m<CDefectPoint[CCount].Rect.right-1 ; m++){
							PixelValue = IElement(m,n);
							if(PixelValue < EnCapBtmThresHold) PixelCount++;
						}
					}
					CDefectPoint[CCount].Round  =  PixelCount;
					CDefectPoint[CCount].P.x    = (float)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterX() - CDefectPoint[CCount].Width/2 )+FLBBPoint.x+SideMargin);
					CDefectPoint[CCount].P.y    = (float)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - CDefectPoint[CCount].Height/2)+(BTMLine-FBtmHeight)  );

					if(ImgDegree!=0.0f){
						CDefectPoint[CCount].P = Math.OnRotate(CenterPoint,CDefectPoint[CCount].P, ImgDegree);
					}
					CDefectPoint[CCount].P.y    = (float)(CDefectPoint[CCount].P.y +ImageHeight);

					// Merge 위해서 데이터 필요함 
					// 						CDefectPoint[CCount].Rect.top    =(long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - CDefectPoint[CCount].Height/2) +((FLBBPoint.y+FRBBPoint.y)/2-FBtmHeight-1)+ImageHeight);
					CDefectPoint[CCount].Rect.top    =(long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - CDefectPoint[CCount].Height/2) +(BTMLine-FBtmHeight)+ImageHeight);
					CDefectPoint[CCount].Rect.bottom =(long)(CDefectPoint[CCount].Rect.top + CDefectPoint[CCount].Height);
					CCount++;
				}
			}
			BlobCount =0;
		}
		else if(IsRectBtm)  { //직사각형 경우 Defect 검사 시퀀스 
			// SIDE D 
			////////////////////////////////////////////////////////////////////////////////////////////////
			DefectROI.SetPlacement((int)(SP.x+SideMargin),(int)(SP.y+BtmMargin), FLeftWidth, LeftHeight-(2*BtmMargin));
			if((SP.x+SideMargin) <=0          || (SP.y+BtmMargin)<0            || FLeftWidth<=0          || LeftHeight-(2*BtmMargin)<  0           ) return false;
			if((SP.x+SideMargin) >=ImageWidth || (SP.y+BtmMargin)>BtmLimitLine || FLeftWidth>=ImageWidth || LeftHeight-(2*BtmMargin)>  BtmLimitLine) return false;
			if((SP.x+SideMargin)+FLeftWidth >=ImageWidth || (SP.y+BtmMargin)+(LeftHeight-(2*BtmMargin))> BtmLimitLine                              ) return false;
			// Line Position
			LinePosition = SP.x+SideMargin;

			CodeImageSelection.Clear();
			CodeImageEncoder.Encode(DefectROI,CodeImage);
			CodeImageSelection.Clear();
			CodeImageSelection.AddObjects(CodeImage);
			// Blob 필터링 
			CodeImageSelection.RemoveUsingFloatFeature(EFeature_BoundingBoxWidth ,FMinWidth , FMaxWidth  , EDoubleThresholdMode_Outside);
			CodeImageSelection.RemoveUsingFloatFeature(EFeature_BoundingBoxHeight,FMinHeight, FMaxHeight , EDoubleThresholdMode_Outside);
			// 			CodeImageSelection.RemoveUsingIntegerFeature(EFeature_LeftLimit        ,0       , 3          , EDoubleThresholdMode_Outside);
			CodeImageSelection.RemoveUsingIntegerFeature(EFeature_LeftLimit        ,0       , 2          , EDoubleThresholdMode_Outside);

			BlobCount = CodeImageSelection.GetElementCount();
			CodeImageSelection.Sort(EFeature_TopLimit,ESortDirection_Ascending);

			if(BlobCount!=0){
				for(int k=0; k<BlobCount; k++){
					if(DCount>=MAX_DEFECT_POINT) break; 
					DDefectPoint[DCount].Width  =  CodeImageSelection.GetElement(k).GetBoundingBoxWidth() ;
					DDefectPoint[DCount].Height =  CodeImageSelection.GetElement(k).GetBoundingBoxHeight();

					DDefectPoint[DCount].Rect.left   =(long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterX() - DDefectPoint[DCount].Width/2 ) +LinePosition);
					DDefectPoint[DCount].Rect.top    =(long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - DDefectPoint[DCount].Height/2) +(SP.y+BtmMargin));
					DDefectPoint[DCount].Rect.right  =(long)(DDefectPoint[DCount].Rect.left+ DDefectPoint[DCount].Width );
					DDefectPoint[DCount].Rect.bottom =(long)(DDefectPoint[DCount].Rect.top + DDefectPoint[DCount].Height);
					PixelCount =0;
					PixelValue =0;

					// 내부 Pixel Data 축출 
					for(int n=DDefectPoint[DCount].Rect.top+1 ; n<DDefectPoint[DCount].Rect.bottom-1; n++){
						for(int m=DDefectPoint[DCount].Rect.left+1; m<DDefectPoint[DCount].Rect.right-1 ; m++){
							PixelValue = IElement(m,n);
							if(PixelValue < EnCapBtmThresHold) PixelCount++;
						}
					}

					DDefectPoint[DCount].Round = PixelCount;
					DDefectPoint[DCount].P.x    =(float)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterX() - DDefectPoint[DCount].Width/2 ) +LinePosition   );
					DDefectPoint[DCount].P.y    =(float)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - DDefectPoint[DCount].Height/2)+(SP.y+BtmMargin)+ImageHeight     );

					// Merge 위해서 데이터 필요함 
					DDefectPoint[DCount].Rect.top    =(long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - DDefectPoint[DCount].Height/2) +(SP.y+BtmMargin)+ImageHeight);
					DDefectPoint[DCount].Rect.bottom =(long)(DDefectPoint[DCount].Rect.top + DDefectPoint[DCount].Height);
					DCount++;
				}
			}
			BlobCount=0;
			// 외곽라인에서 Mark까지의 거리 산출 
			//if     (Line[waLeftWall].FP0.x >Line[waLeftWall].FP1.x) LDistance = FP0.x - (Line[waLeftWall].FP1.x+(Line[waLeftWall].FP0.x - Line[waLeftWall].FP1.x)/2);
			//else if(Line[waLeftWall].FP0.x==Line[waLeftWall].FP1.x) LDistance = FP0.x -  Line[waLeftWall].FP0.x;
			//else                                                    LDistance = FP0.x - (Line[waLeftWall].FP0.x+(Line[waLeftWall].FP1.x - Line[waLeftWall].FP0.x)/2); 

			if     (Line[waLeftWall].FP0.x >Line[waLeftWall].FP1.x) LDistance = FP0.x - (Line[waLeftWall].FP1.x+(Line[waLeftWall].FP0.x - Line[waLeftWall].FP1.x)/2);
			else if(Line[waLeftWall].FP0.x==Line[waLeftWall].FP1.x) LDistance = FP0.x -  Line[waLeftWall].FP0.x;
			else                                                    LDistance = FP0.x - (Line[waLeftWall].FP0.x+(Line[waLeftWall].FP1.x - Line[waLeftWall].FP0.x)/2); 
			////////////////////////////////////////////////////////////////////////////////////////////////

			// SIDE B
			////////////////////////////////////////////////////////////////////////////////////////////////
			DefectROI.SetPlacement((int)(EP.x-FRightWidth-SideMargin),(int)(EP.y+BtmMargin), FRightWidth, RightHeight-(2*BtmMargin));
			if((EP.x-FRightWidth-SideMargin) <=0          || (EP.y+BtmMargin)<0            || FRightWidth<=0          || RightHeight-(2*BtmMargin)< 0           ) return false;
			if((EP.x-FRightWidth-SideMargin) >=ImageWidth || (EP.y+BtmMargin)>BtmLimitLine || FRightWidth>=ImageWidth || RightHeight-(2*BtmMargin)> BtmLimitLine) return false;
			if((EP.x-FRightWidth-SideMargin)+FRightWidth >=ImageWidth || (EP.y+BtmMargin)+(RightHeight-(2*BtmMargin))>BtmLimitLine                              ) return false;

			// Line Position
			LinePosition = EP.x-FRightWidth;

			CodeImageSelection.Clear();
			CodeImageEncoder.Encode(DefectROI,CodeImage);
			CodeImageSelection.Clear();
			CodeImageSelection.AddObjects(CodeImage);
			// Blob 필터링 
			CodeImageSelection.RemoveUsingFloatFeature(EFeature_BoundingBoxWidth ,FMinWidth     , FMaxWidth    , EDoubleThresholdMode_Outside);
			CodeImageSelection.RemoveUsingFloatFeature(EFeature_BoundingBoxHeight,FMinHeight    , FMaxHeight   , EDoubleThresholdMode_Outside);
			// 				CodeImageSelection.RemoveUsingIntegerFeature(EFeature_RightLimit     ,FRightWidth-2             , FRightWidth+1            , EDoubleThresholdMode_Outside);
			CodeImageSelection.RemoveUsingIntegerFeature(EFeature_RightLimit     ,FRightWidth-1             , FRightWidth+1            , EDoubleThresholdMode_Outside);

			BlobCount = CodeImageSelection.GetElementCount();
			CodeImageSelection.Sort(EFeature_TopLimit,ESortDirection_Ascending);

			if(BlobCount!=0){
				for(int k=0; k<BlobCount; k++){
					if(BCount>=MAX_DEFECT_POINT) break; 
					BDefectPoint[BCount].Width  = CodeImageSelection.GetElement(k).GetBoundingBoxWidth() ;
					BDefectPoint[BCount].Height = CodeImageSelection.GetElement(k).GetBoundingBoxHeight();

					BDefectPoint[BCount].Rect.left   =(long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterX() - BDefectPoint[BCount].Width/2 ) +(LinePosition));
					BDefectPoint[BCount].Rect.top    =(long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - BDefectPoint[BCount].Height/2) +(EP.y+BtmMargin));
					BDefectPoint[BCount].Rect.right  =(long)(BDefectPoint[BCount].Rect.left+ BDefectPoint[BCount].Width );
					BDefectPoint[BCount].Rect.bottom =(long)(BDefectPoint[BCount].Rect.top + BDefectPoint[BCount].Height);
					PixelCount = 0;
					PixelValue = 0;

					// 내부 Pixel Data 축출 
					for(int n=BDefectPoint[BCount].Rect.top+1 ; n<BDefectPoint[BCount].Rect.bottom-1; n++){
						for(int m=BDefectPoint[BCount].Rect.left+1; m<BDefectPoint[BCount].Rect.right-1 ; m++){
							PixelValue = IElement(m,n);
							if(PixelValue < EnCapBtmThresHold) PixelCount++;
						}
					}
					BDefectPoint[BCount].Round  = PixelCount;
					BDefectPoint[BCount].P.x    =(float)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterX() - BDefectPoint[BCount].Width/2 )+(LinePosition));
					BDefectPoint[BCount].P.y    =(float)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - BDefectPoint[BCount].Height/2)+(EP.y+BtmMargin)+ImageHeight   );

					// Merge 위해서 데이터 필요함 
					BDefectPoint[BCount].Rect.top    =(long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - BDefectPoint[BCount].Height/2) +(EP.y+BtmMargin)+ImageHeight);
					BDefectPoint[BCount].Rect.bottom =(long)(BDefectPoint[BCount].Rect.top + BDefectPoint[BCount].Height);
					BCount++;
				}
			}

			BlobCount =0;
			// 외곽라인에서 Mark까지의 거리 산출 
			//if     (Line[waRightWall].FP0.x >Line[waRightWall].FP1.x) RDistance = (Line[waRightWall].FP1.x+(Line[waRightWall].FP0.x - Line[waRightWall].FP1.x)/2) - FP1.x;
			//else if(Line[waRightWall].FP0.x==Line[waRightWall].FP1.x) RDistance =  Line[waRightWall].FP0.x - FP1.x;
			//else                                                      RDistance = (Line[waRightWall].FP0.x+(Line[waRightWall].FP1.x - Line[waRightWall].FP0.x)/2) - FP1.x;

			if     (Line[waRightWall].FP0.x >Line[waRightWall].FP1.x) RDistance = (Line[waRightWall].FP1.x+(Line[waRightWall].FP0.x - Line[waRightWall].FP1.x)/2) - FP1.x;
			else if(Line[waRightWall].FP0.x==Line[waRightWall].FP1.x) RDistance =  Line[waRightWall].FP0.x - FP1.x;
			else                                                      RDistance = (Line[waRightWall].FP0.x+(Line[waRightWall].FP1.x - Line[waRightWall].FP0.x)/2) - FP1.x;
			////////////////////////////////////////////////////////////////////////////////////////////////

			//SIDE C
			////////////////////////////////////////////////////////////////////////////////////////////////
			// Btm검사시 오버킬을 줄위기 위해서 
			if(fabs(FLBPoint.y - FRBPoint.y)>3) BTMLine = (FLBPoint.y > FRBPoint.y) ?(int)FRBPoint.y : (int)FLBPoint.y ;
			else                                BTMLine = (FLBPoint.y > FRBPoint.y) ?(int)FLBPoint.y : (int)FRBPoint.y ;

			if(IsMarkBtm){
				DefectROI.SetPlacement((int)FLBPoint.x+SideMargin, (int)(BTMLine-FBtmHeight), BtmWidth-(2*SideMargin), FBtmHeight);
				if((FLBPoint.x+SideMargin) <=0          ||(BTMLine-FBtmHeight)<0            || BtmWidth-(2*SideMargin)<=0          || FBtmHeight<0           ) return false;
				if((FLBPoint.x+SideMargin) >=ImageWidth ||(BTMLine-FBtmHeight)>BtmLimitLine || BtmWidth-(2*SideMargin)>=ImageWidth || FBtmHeight>BtmLimitLine) return false;
				if((FLBPoint.x+SideMargin)+(BtmWidth-(2*SideMargin))>=ImageWidth ||(BTMLine-FBtmHeight)+FBtmHeight>BtmLimitLine                              ) return false;
			}
			else         {
				DefectROI.SetPlacement((int)FLBPoint.x+SideMargin, (int)(BTMLine-FBtmHeight), BtmWidth-(2*SideMargin), FBtmHeight-BtmInspOffset);
				if((FLBPoint.x+SideMargin) <=0          ||(BTMLine-FBtmHeight)<0            || BtmWidth-(2*SideMargin)<=0          || FBtmHeight-BtmInspOffset<0           ) return false;
				if((FLBPoint.x+SideMargin) >=ImageWidth ||(BTMLine-FBtmHeight)>BtmLimitLine || BtmWidth-(2*SideMargin)>=ImageWidth || FBtmHeight-BtmInspOffset>BtmLimitLine) return false;
				if((FLBPoint.x+SideMargin)+(BtmWidth-(2*SideMargin))>=ImageWidth ||(BTMLine-FBtmHeight)+FBtmHeight-BtmInspOffset>BtmLimitLine                              ) return false;
			}

			CodeImageSelection.Clear();
			CodeImageEncoder.Encode(DefectROI,CodeImage);
			CodeImageSelection.Clear();
			CodeImageSelection.AddObjects(CodeImage);
			// Blob 필터링 
			CodeImageSelection.RemoveUsingFloatFeature  (EFeature_BoundingBoxWidth ,FMinWidth      , FMaxWidth   , EDoubleThresholdMode_Outside);
			CodeImageSelection.RemoveUsingFloatFeature  (EFeature_BoundingBoxHeight,FMinHeight     , FMaxHeight  , EDoubleThresholdMode_Outside);
			if(IsMarkBtm) CodeImageSelection.RemoveUsingIntegerFeature(EFeature_BottomLimit      ,FBtmHeight-1                 , FBtmHeight+1              , EDoubleThresholdMode_Outside);
			else          CodeImageSelection.RemoveUsingIntegerFeature(EFeature_BottomLimit      ,FBtmHeight-BtmInspOffset-1   , FBtmHeight-BtmInspOffset+1, EDoubleThresholdMode_Outside);


			BlobCount = CodeImageSelection.GetElementCount();
			CodeImageSelection.Sort(EFeature_LeftLimit ,ESortDirection_Ascending);

			if(BlobCount!=0){
				for(int k=0; k<BlobCount; k++){
					if(CCount>=MAX_DEFECT_POINT) break; 
					CDefectPoint[CCount].Width  =  CodeImageSelection.GetElement(k).GetBoundingBoxWidth() ;
					CDefectPoint[CCount].Height =  CodeImageSelection.GetElement(k).GetBoundingBoxHeight();

					CDefectPoint[CCount].Rect.left   =(long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterX() - CDefectPoint[CCount].Width/2 ) +FLBPoint.x+SideMargin);
					// 						CDefectPoint[CCount].Rect.top    =(long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - CDefectPoint[CCount].Height/2) +((FLBBPoint.y+FRBBPoint.y)/2-FBtmHeight-1));
					CDefectPoint[CCount].Rect.top    =(long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - CDefectPoint[CCount].Height/2) +(BTMLine-FBtmHeight));
					CDefectPoint[CCount].Rect.right  =(long)(CDefectPoint[CCount].Rect.left+ CDefectPoint[CCount].Width );
					CDefectPoint[CCount].Rect.bottom =(long)(CDefectPoint[CCount].Rect.top + CDefectPoint[CCount].Height);
					PixelCount = 0;
					PixelValue = 0;

					// 내부 Pixel Data 축출 
					for(int n=CDefectPoint[CCount].Rect.top+1 ; n<CDefectPoint[CCount].Rect.bottom-1; n++){
						for(int m=CDefectPoint[CCount].Rect.left+1; m<CDefectPoint[CCount].Rect.right-1 ; m++){
							PixelValue = IElement(m,n);
							if(PixelValue < EnCapBtmThresHold) PixelCount++;
						}
					}
					CDefectPoint[CCount].Round  =  PixelCount;
					CDefectPoint[CCount].P.x    = (float)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterX() - CDefectPoint[CCount].Width/2 )+FLBPoint.x+SideMargin);
					CDefectPoint[CCount].P.y    = (float)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - CDefectPoint[CCount].Height/2)+(BTMLine-FBtmHeight) );

					if(ImgDegree!=0.0f){
						CDefectPoint[CCount].P = Math.OnRotate(CenterPoint,CDefectPoint[CCount].P, ImgDegree);
					}
					CDefectPoint[CCount].P.y    = (float)(CDefectPoint[CCount].P.y+ImageHeight);

					// Merge 위해서 데이터 필요함 
					// 						CDefectPoint[CCount].Rect.top    =(long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - CDefectPoint[CCount].Height/2) +((FLBBPoint.y+FRBBPoint.y)/2-FBtmHeight-1)+ImageHeight);
					CDefectPoint[CCount].Rect.top    =(long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - CDefectPoint[CCount].Height/2) +(BTMLine-FBtmHeight)+ImageHeight);
					CDefectPoint[CCount].Rect.bottom =(long)(CDefectPoint[CCount].Rect.top + CDefectPoint[CCount].Height);
					CCount++;
				}
			}
			BlobCount =0;
			////////////////////////////////////////////////////////////////////////////////////////////////
		}
		else if(IsCircleBtm){ //Circle Cutting일경우 Defect 검사 시퀀스 
			if(FInspectMode==Insp_Polygon){ // 비선형 검사에서는 Dx,Dy,R 미검사 
				if(C1CirInEdgeCount!=0){
					IAddress = DefectImg.GetImagePtr(); // Pixel 정보 추출 목적 
					C1CirDeftectCnt  = GetPolygonSize(C1CirInPoint, C1CirDefectPoint, C1CirInEdgeCount, 50, 5); // Dark Defect 

					if(!IsMarkBtm && C1CirInCrackCount>0 && BrokenThresHold!=0){
						IAddress = RotateBrokenImg.GetImagePtr(); // Pixel 정보 추출 목적 
						C1CirCrackCnt  = GetCircleCrackSize(C1CircleData, C1CirCrackPoint, C1CirInCrackCount, 30,CirFitDiameter1,CircleFit1Center); // Bright Defect 
					}
				}

				if(C2CirInEdgeCount!=0){
					IAddress = DefectImg.GetImagePtr(); // Pixel 정보 추출 목적 
					C2CirDeftectCnt  = GetPolygonSize(C2CirInPoint, C2CirDefectPoint, C2CirInEdgeCount, 50, 5); // Dark Defect 

					if(!IsMarkBtm && C2CirInCrackCount>0 && BrokenThresHold!=0){
						IAddress = RotateBrokenImg.GetImagePtr(); // Pixel 정보 추출 목적 
						C2CirCrackCnt  = GetCircleCrackSize(C2CircleData, C2CirCrackPoint, C2CirInCrackCount, 30,CirFitDiameter2,CircleFit2Center); // Bright Defect 
					}
				}

				if(C3CirInEdgeCount!=0){
					IAddress = DefectImg.GetImagePtr(); // Pixel 정보 추출 목적 
					C3CirDeftectCnt  = GetPolygonSize(C3CirInPoint, C3CirDefectPoint, C3CirInEdgeCount, 50, 5); // Dark Defect 

					if(!IsMarkBtm && C3CirInCrackCount>0 && BrokenThresHold!=0){
						IAddress = RotateBrokenImg.GetImagePtr(); // Pixel 정보 추출 목적 
						C3CirCrackCnt  = GetCircleCrackSize(C3CircleData, C3CirCrackPoint, C3CirInCrackCount, 30,CirFitDiameter3,CircleFit3Center); // Bright Defect 
					}
				}

				if(C4CirInEdgeCount!=0){
					IAddress = DefectImg.GetImagePtr(); // Pixel 정보 추출 목적 
					C4CirDeftectCnt  = GetPolygonSize(C4CirInPoint, C4CirDefectPoint, C4CirInEdgeCount, 50, 5); // Dark Defect 

					if(!IsMarkBtm && C4CirInCrackCount>0 && BrokenThresHold!=0){
						IAddress = RotateBrokenImg.GetImagePtr(); // Pixel 정보 추출 목적 
						C4CirCrackCnt  = GetCircleCrackSize(C4CircleData, C4CirCrackPoint, C4CirInCrackCount, 30,CirFitDiameter4,CircleFit4Center); // Bright Defect 
					}
				}

				if(C5CirInEdgeCount!=0){
					IAddress = DefectImg.GetImagePtr(); // Pixel 정보 추출 목적 
					C5CirDeftectCnt  = GetPolygonSize(C5CirInPoint, C5CirDefectPoint, C5CirInEdgeCount, 50, 5); // Dark Defect 

					if(!IsMarkBtm && C5CirInCrackCount>0 && BrokenThresHold!=0){
						IAddress = RotateBrokenImg.GetImagePtr(); // Pixel 정보 추출 목적 
						C5CirCrackCnt  = GetCircleCrackSize(C5CircleData, C5CirCrackPoint, C5CirInCrackCount, 30,CirFitDiameter5,CircleFit5Center); // Bright Defect 
					}
				}

				if(C6CirInEdgeCount!=0){
					IAddress = DefectImg.GetImagePtr(); // Pixel 정보 추출 목적 
					C6CirDeftectCnt  = GetPolygonSize(C6CirInPoint, C6CirDefectPoint, C6CirInEdgeCount, 50, 5); // Dark Defect 

					if(!IsMarkBtm && C6CirInCrackCount>0 && BrokenThresHold!=0){
						IAddress = RotateBrokenImg.GetImagePtr(); // Pixel 정보 추출 목적 
						C6CirCrackCnt  = GetCircleCrackSize(C6CircleData, C6CirCrackPoint, C6CirInCrackCount, 30,CirFitDiameter6,CircleFit6Center); // Bright Defect 
					}
				}
				if(Btm3InEdgeCount!=0){
					IAddress = DefectImg.GetImagePtr(); // Pixel 정보 추출 목적 
					Btm3CirDefectCnt  = GetPolygonSize(Btm3InPoint, Btm3CirDefectPoint, Btm3InEdgeCount, 50, 5); // Dark Defect 

					if(!IsMarkBtm && Btm3CirInCrackCount>0 && BrokenThresHold!=0){
						IAddress = RotateBrokenImg.GetImagePtr(); // Pixel 정보 추출 목적 
						Btm3CirCrackCnt  = GetCircleCrackSize(Btm3CircleData, Btm3CirCrackPoint, Btm3CirInCrackCount, 30,CirFitDiameterBtm3,CircleFitBtm3Center); // Bright Defect 
					}
				}
			}
			else { // MarkMode, TrackMode 
				if(C1CirInEdgeCount!=0){
					IAddress = DefectImg.GetImagePtr(); // Pixel 정보 추출 목적 
					MaxDis =0.0f        ;
					MinDis =10000.0f    ;
					MaxDv  =0.0f        ;
					MinDv  =10000.0f    ;
					StdMaxDis =0.0f     ;
					StdMinDis =10000.0f ;
					MinCirCount =0      ;
					// 삼항 연산자 최소값 구하기  
					if      (FInspectMode==Insp_Track) MinCirCount = (C1CirInEdgeCount<C1CirOutEdgeCount)?(C1CirInEdgeCount<C1CirStandEdgeCount)?C1CirInEdgeCount:C1CirStandEdgeCount:(C1CirOutEdgeCount<C1CirStandEdgeCount)?C1CirOutEdgeCount:C1CirStandEdgeCount;
					else if (FInspectMode==Insp_Mark ) MinCirCount = C1CirInEdgeCount;

					CircleCount=0;TotalCirDis=0.0f; AvgCirDis=0.0f;
					for(int k=0; k<MinCirCount; k++){
						if(FInspectMode==Insp_Track){ // TrackMode 
							if(C1CirInPoint[k].x==0    || C1CirInPoint[k].y==0    || k>=MAX_CIRCLE_EDGEPOINT) continue;
							if(C1CirStandPoint[k].x==0 || C1CirStandPoint[k].y==0 || k>=MAX_CIRCLE_EDGEPOINT) continue;

							if(IsMarkBtm){ // RealC1CirCneter값은 TrackLine EdgePoint기준 Circle_Fitting 결과물 
								Dis    = Math.GetLengthFrPointToPoint(RealC1CirCenter,C1CirInPoint[k]   );
								StdDis = Math.GetLengthFrPointToPoint(RealC1CirCenter,C1CirStandPoint[k]);
							}
							else {        // TrackLine 교차점 기준 센터 
								Dis    = Math.GetLengthFrPointToPoint(TrackC1CirCenter,C1CirInPoint[k]   );
							}

							if(Dis>MaxDis) MaxDis = Dis;
							if(Dis<MinDis) MinDis = Dis;

							if(StdDis>StdMaxDis) StdMaxDis = StdDis;
							if(StdDis<StdMinDis) StdMinDis = StdDis;

							if(k==0){ // BTM Defect 검사를 위한 좌표값 및 Dx,Dy 산출 
								if(IsMarkBtm){ 					
									C1CirDy = Math.GetLengthFrPointToPoint(TrackC1CirCenter,C1CirInPoint[k]);
								}
								else {
									C1CirDy = Math.GetLengthFrPointToPoint(TrackC1CirCenter,C1CirInPoint[k]);
								}
							} 
							if(k==(C1CirInEdgeCount-1)){
								if(IsMarkBtm){ 					
									C1CirDx = Math.GetLengthFrPointToPoint(TrackC1CirCenter,C1CirInPoint[k]);
								}
								else {
									C1CirDx = Math.GetLengthFrPointToPoint(TrackC1CirCenter,C1CirInPoint[k]);
								}
							}
						}
						else if(FInspectMode==Insp_Mark){ // MarkMode 
							if(C1CirInPoint[k].x==0    || C1CirInPoint[k].y==0    || k>=MAX_CIRCLE_EDGEPOINT) continue;

							if(IsMarkBtm){ // RealC1CirCneter값은 연마안쪽 EdgePoint기준 Circle_Fitting 결과물 
								// 							Dis    = Math.GetLengthFrPointToPoint(RealC1CirCenter,C1CirInPoint[k] ); // Euresys Circle Fitting
								Dis = Math.GetLengthFrPointToPoint(CircleFit1Center,C1CirInPoint[k]   ); // FAVION  Circle Fitting 
							}
							else {
								Dis    = Math.GetLengthFrPointToPoint(CircleFit1Center,C1CirInPoint[k]   );
							}

							if(Dis>MaxDis) MaxDis = Dis;
							if(Dis<MinDis) MinDis = Dis;

							if(k==0){ // BTM Defect 검사를 위한 좌표값 및 Dx,Dy 산출 
								// 						    C1CirDy = Math.GetLengthFrPointToPoint(RealC1CirCenter,C1CirInPoint[k]);
								C1CirDy = Math.GetLengthFrPointToPoint(CircleFit1Center,C1CirInPoint[k]);
							} 
							if(k==(C1CirInEdgeCount-1)){
								// 						    C1CirDx = Math.GetLengthFrPointToPoint(RealC1CirCenter,C1CirInPoint[k]);
								C1CirDx = Math.GetLengthFrPointToPoint(CircleFit1Center,C1CirInPoint[k]);
							}
						}
						//Data 취합 
						C1CircleData[CircleCount].Dis  = Dis              ; 
						C1CircleData[CircleCount].P.x  = C1CirInPoint[k].x;
						C1CircleData[CircleCount].P.y  = C1CirInPoint[k].y;
						CircleCount++   ;
						TotalCirDis+=Dis;
					}

					if(CircleCount!=0 || TotalCirDis!=0){ // Circle AvgRound Cal
						AvgCirDis = (TotalCirDis/CircleCount);
						C1CirRound = AvgCirDis;
					}

					for(int i=0; i<CircleCount; i++){
						// 					C1CircleData[i].Dv = fabs(AvgCirDis - C1CircleData[i].Dis); // Avg EdgePoint 기준 편차값 
						C1CircleData[i].Dv = (CirFitDiameter1 - C1CircleData[i].Dis) >0 ?(CirFitDiameter1 - C1CircleData[i].Dis):0;
						if(C1CircleData[i].Dv>MaxDv) MaxDv = C1CircleData[i].Dv;
						if(C1CircleData[i].Dv<MinDv) MinDv = C1CircleData[i].Dv;
					}
					C1CirDeftectCnt  = GetCircleSize(C1CircleData, C1CirDefectPoint, CircleCount, 5); // Dark Defect 

					// 박리불량 검사 시퀀스 
					if(!IsMarkBtm && C1CirInCrackCount>0 && BrokenThresHold!=0){
						for(int i=0; i<C1CirInCrackCount; i++){
							C1CircleData[i].Dv  =0.0f;
							C1CircleData[i].Dis =0.0f;
							C1CircleData[i].P.x  = C1CirInCrackPoint[i].x;
							C1CircleData[i].P.y  = C1CirInCrackPoint[i].y;
						}
						IAddress = RotateBrokenImg.GetImagePtr(); // Pixel 정보 추출 목적 
						C1CirCrackCnt  = GetCircleCrackSize(C1CircleData, C1CirCrackPoint, C1CirInCrackCount, 30, CrackCirDiameter1,CircleFit1Center); // Bright Defect 
					}
				}

				// C2Circle Calculate 
				if(C2CirInEdgeCount!=0){
					IAddress = DefectImg.GetImagePtr(); // Pixel 정보 추출 목적 
					MaxDis =0.0f     ;
					MinDis =10000.0f ;
					MaxDv  =0.0f     ;
					MinDv  =10000.0f ;
					StdMaxDis =0.0f     ;
					StdMinDis =10000.0f ;
					MinCirCount =0      ;
					// 삼항 연산자 최소값 구하기  

					if      (FInspectMode==Insp_Track) MinCirCount = (C2CirInEdgeCount<C2CirOutEdgeCount)?(C2CirInEdgeCount<C2CirStandEdgeCount)?C2CirInEdgeCount:C2CirStandEdgeCount:(C2CirOutEdgeCount<C2CirStandEdgeCount)?C2CirOutEdgeCount:C2CirStandEdgeCount;
					else if (FInspectMode==Insp_Mark ) MinCirCount =  C2CirInEdgeCount;

					CircleCount=0;TotalCirDis=0.0f; AvgCirDis=0.0f;
					for(int k=0; k<MinCirCount; k++){
						if(FInspectMode==Insp_Track){ // TrackMode 
							if(C2CirInPoint[k].x==0    || C2CirInPoint[k].y==0    || k>=MAX_CIRCLE_EDGEPOINT) continue;
							if(C2CirStandPoint[k].x==0 || C2CirStandPoint[k].y==0 || k>=MAX_CIRCLE_EDGEPOINT) continue;

							if(IsMarkBtm){ // RealC2CirCneter값은 TrackLine EdgePoint기준 Circle_Fitting 결과물 
								Dis    = Math.GetLengthFrPointToPoint(RealC2CirCenter,C2CirInPoint[k]   );
								StdDis = Math.GetLengthFrPointToPoint(RealC2CirCenter,C2CirStandPoint[k]);
							}
							else {         // TrackLine 교차점 기준 센터 
								Dis    = Math.GetLengthFrPointToPoint(TrackC2CirCenter,C2CirInPoint[k]   );
							}

							if(Dis>MaxDis) MaxDis = Dis;
							if(Dis<MinDis) MinDis = Dis;
							if(StdDis>StdMaxDis) StdMaxDis = StdDis;
							if(StdDis<StdMinDis) StdMinDis = StdDis;

							if(k==0){ // BTM Defect 검사를 위한 좌표값 및 Dx,Dy 산출 
								if(IsMarkBtm){ 					
									C2CirDx = Math.GetLengthFrPointToPoint(TrackC2CirCenter,C2CirInPoint[k]);
								}
								else {
									C2CirDx = Math.GetLengthFrPointToPoint(TrackC2CirCenter,C2CirInPoint[k]);
								}
							} 
							if(k==(C2CirInEdgeCount-1)) {
								if(IsMarkBtm){ 					
									C2CirDy = Math.GetLengthFrPointToPoint(TrackC2CirCenter,C2CirInPoint[k]);
								}
								else {
									C2CirDy = Math.GetLengthFrPointToPoint(TrackC2CirCenter,C2CirInPoint[k]);
								}
							}
						}
						else if(FInspectMode==Insp_Mark){ // MarkMode 
							if(C2CirInPoint[k].x==0    || C2CirInPoint[k].y==0    || k>=MAX_CIRCLE_EDGEPOINT) continue;

							if(IsMarkBtm){ // RealC2CirCneter값은 연마안쪽 EdgePoint기준 Circle_Fitting 결과물 
								// 							Dis    = Math.GetLengthFrPointToPoint(RealC2CirCenter,C2CirInPoint[k]   );
								Dis = Math.GetLengthFrPointToPoint(CircleFit2Center,C2CirInPoint[k]     );
								// 							Dis    = Math.GetLengthFrPointToPoint(C2CirCenter,C2CirInPoint[k]   );
							}
							else {         // RealC2CirCneter값은 연마안쪽 EdgePoint기준 Circle_Fitting 결과물 
								Dis    = Math.GetLengthFrPointToPoint(CircleFit2Center,C2CirInPoint[k]   );
							}

							if(Dis>MaxDis) MaxDis = Dis;
							if(Dis<MinDis) MinDis = Dis;

							if(k==0){ // BTM Defect 검사를 위한 좌표값 및 Dx,Dy 산출 
								// 						    C2CirDx = Math.GetLengthFrPointToPoint(RealC2CirCenter,C2CirInPoint[k]);
								C2CirDx = Math.GetLengthFrPointToPoint(CircleFit2Center,C2CirInPoint[k]);
							} 
							if(k==(C2CirInEdgeCount-1)) {
								// 							C2CirDy = Math.GetLengthFrPointToPoint(RealC2CirCenter,C2CirInPoint[k]);
								C2CirDy = Math.GetLengthFrPointToPoint(CircleFit2Center,C2CirInPoint[k]);
							}
						}

						C2CircleData[CircleCount].Dis  = Dis              ; // FAVION  Circle Fitting 
						C2CircleData[CircleCount].P.x  = C2CirInPoint[k].x;
						C2CircleData[CircleCount].P.y  = C2CirInPoint[k].y;
						CircleCount++   ;
						TotalCirDis+=Dis;
					}
					if(CircleCount!=0 || TotalCirDis!=0){ // Circle AvgRound Cal
						AvgCirDis = (TotalCirDis/CircleCount);
						C2CirRound = AvgCirDis;
					}

					for(int i=0; i<CircleCount; i++){
						// 					C2CircleData[i].Dv = fabs(AvgCirDis - C2CircleData[i].Dis);      // Euresys Circle Fitting 
						C2CircleData[i].Dv = (CirFitDiameter2 - C2CircleData[i].Dis) >0 ?(CirFitDiameter2 - C2CircleData[i].Dis):0;
						if(C2CircleData[i].Dv>MaxDv) MaxDv = C2CircleData[i].Dv;
						if(C2CircleData[i].Dv<MinDv) MinDv = C2CircleData[i].Dv;
					}
					C2CirDeftectCnt  = GetCircleSize(C2CircleData, C2CirDefectPoint, CircleCount, 5);

					if(!IsMarkBtm && C2CirInCrackCount>0 && BrokenThresHold!=0){
						for(int i=0; i<C2CirInCrackCount; i++){
							C2CircleData[i].Dv  =0.0f;
							C2CircleData[i].Dis =0.0f;
							C2CircleData[i].P.x  = C2CirInCrackPoint[i].x;
							C2CircleData[i].P.y  = C2CirInCrackPoint[i].y;
						}
						IAddress = RotateBrokenImg.GetImagePtr(); // Pixel 정보 추출 목적 
						C2CirCrackCnt  = GetCircleCrackSize(C2CircleData, C2CirCrackPoint, C2CirInCrackCount, 30, CrackCirDiameter2,CircleFit2Center);
					}
				}

				// C3Circle Calculate 
				if(C3CirInEdgeCount!=0){
					IAddress = DefectImg.GetImagePtr(); // Pixel 정보 추출 목적 
					MaxDis =0.0f     ;
					MinDis =10000.0f ;
					MaxDv  =0.0f     ;
					MinDv  =10000.0f ;
					StdMaxDis =0.0f     ;
					StdMinDis =10000.0f ;
					MinCirCount =0      ;
					// 삼항 연산자 최소값 구하기  
					if      (FInspectMode==Insp_Track) MinCirCount = (C3CirInEdgeCount<C3CirOutEdgeCount)?(C3CirInEdgeCount<C3CirStandEdgeCount)?C3CirInEdgeCount:C3CirStandEdgeCount:(C3CirOutEdgeCount<C3CirStandEdgeCount)?C3CirOutEdgeCount:C3CirStandEdgeCount;
					else if (FInspectMode==Insp_Mark ) MinCirCount =  C3CirInEdgeCount; 

					CircleCount=0;TotalCirDis=0.0f; AvgCirDis=0.0f;
					for(int k=0; k<MinCirCount; k++){
						if(FInspectMode==Insp_Track){ // TrackMode
							if(C3CirInPoint[k].x==0    || C3CirInPoint[k].y==0    || k>=MAX_CIRCLE_EDGEPOINT) continue;
							if(C3CirStandPoint[k].x==0 || C3CirStandPoint[k].y==0 || k>=MAX_CIRCLE_EDGEPOINT) continue;

							if(IsMarkBtm){ // RealC3CirCneter값은 TrackLine EdgePoint기준 Circle_Fitting 결과물 
								Dis    = Math.GetLengthFrPointToPoint(RealC3CirCenter,C3CirInPoint[k]   );
								StdDis = Math.GetLengthFrPointToPoint(RealC3CirCenter,C3CirStandPoint[k]);
							}
							else {         // TrackLine 교차점 기준 센터 
								Dis    = Math.GetLengthFrPointToPoint(TrackC3CirCenter,C3CirInPoint[k]   );
							}

							if(Dis>MaxDis) MaxDis = Dis;
							if(Dis<MinDis) MinDis = Dis;

							if(StdDis>StdMaxDis) StdMaxDis = StdDis;
							if(StdDis<StdMinDis) StdMinDis = StdDis;

							if(k==0){ // BTM Defect 검사를 위한 좌표값 및 Dx,Dy 산출 
								if(IsMarkBtm){ 					
									C3CirDx = Math.GetLengthFrPointToPoint(TrackC3CirCenter,C3CirInPoint[k]);
								}
								else {
									C3CirDx = Math.GetLengthFrPointToPoint(TrackC3CirCenter,C3CirInPoint[k]);
								}
							} 
							if(k==(C3CirInEdgeCount-1)) {
								if(IsMarkBtm){ 					
									C3CirDy = Math.GetLengthFrPointToPoint(TrackC3CirCenter,C3CirInPoint[k]);
								}
								else {
									C3CirDy = Math.GetLengthFrPointToPoint(TrackC3CirCenter,C3CirInPoint[k]);
								}
							}
						}
						else if(FInspectMode==Insp_Mark){ // MarkMode 
							if(C3CirInPoint[k].x==0    || C3CirInPoint[k].y==0    || k>=MAX_CIRCLE_EDGEPOINT) continue;

							if(IsMarkBtm){ // RealC3CirCneter값은 연마안쪽 EdgePoint기준 Circle_Fitting 결과물 
								// 							Dis    = Math.GetLengthFrPointToPoint(RealC3CirCenter,C3CirInPoint[k]   );
								Dis = Math.GetLengthFrPointToPoint(CircleFit3Center,C3CirInPoint[k]  );
								// 							Dis    = Math.GetLengthFrPointToPoint(C3CirCenter,C3CirInPoint[k]   );
							}
							else {         // RealC1CirCneter값은 연마안쪽 EdgePoint기준 Circle_Fitting 결과물 
								Dis    = Math.GetLengthFrPointToPoint(CircleFit3Center,C3CirInPoint[k]   );
							}

							if(Dis>MaxDis) MaxDis = Dis;
							if(Dis<MinDis) MinDis = Dis;

							if(k==0){ // BTM Defect 검사를 위한 좌표값 및 Dx,Dy 산출 
								C3CirDx = Math.GetLengthFrPointToPoint(CircleFit3Center,C3CirInPoint[k]);
								// 							C3CirDx = Math.GetLengthFrPointToPoint(RealC3CirCenter,C3CirInPoint[k]);
							} 
							if(k==(C3CirInEdgeCount-1)) {
								// 							C3CirDy = Math.GetLengthFrPointToPoint(RealC3CirCenter,C3CirInPoint[k]);
								C3CirDy = Math.GetLengthFrPointToPoint(CircleFit3Center,C3CirInPoint[k]);
							}
						}

						C3CircleData[CircleCount].Dis  = Dis              ;  // FAVION Circle Fitting 
						C3CircleData[CircleCount].P.x  = C3CirInPoint[k].x;
						C3CircleData[CircleCount].P.y  = C3CirInPoint[k].y;
						CircleCount++   ;
						TotalCirDis+=Dis;
					}
					if(CircleCount!=0 || TotalCirDis!=0){ // Circle AvgRound Cal
						AvgCirDis = (TotalCirDis/CircleCount);
						C3CirRound = AvgCirDis;
					}

					for(int i=0; i<CircleCount; i++){
						// 					C3CircleData[i].Dv = fabs(AvgCirDis - C3CircleData[i].Dis);          // Euresys Circle Fitting 
						C3CircleData[i].Dv = (CirFitDiameter3 - C3CircleData[i].Dis) <0 ?fabs(CirFitDiameter3 - C3CircleData[i].Dis):0;
						if(C3CircleData[i].Dv>MaxDv) MaxDv = C3CircleData[i].Dv;
						if(C3CircleData[i].Dv<MinDv) MinDv = C3CircleData[i].Dv;
					}
					C3CirDeftectCnt  = GetCircleSize(C3CircleData, C3CirDefectPoint, CircleCount, 5);

					if(!IsMarkBtm && C3CirInCrackCount>0 && BrokenThresHold!=0){
						for(int i=0; i<C3CirInCrackCount; i++){
							C3CircleData[i].Dv  =0.0f;
							C3CircleData[i].Dis =0.0f;
							C3CircleData[i].P.x  = C3CirInCrackPoint[i].x;
							C3CircleData[i].P.y  = C3CirInCrackPoint[i].y;
						}
						IAddress = RotateBrokenImg.GetImagePtr(); // Pixel 정보 추출 목적 

						C3CirCrackCnt  = GetCircleCrackSize(C3CircleData, C3CirCrackPoint, C3CirInCrackCount, 30, CrackCirDiameter3,CircleFit3Center,false);
					}
				}

				// C4Circle Calculate 
				if(C4CirInEdgeCount!=0){
					IAddress = DefectImg.GetImagePtr(); // Pixel 정보 추출 목적 
					MaxDis =0.0f     ;
					MinDis =10000.0f ;
					MaxDv  =0.0f     ;
					MinDv  =10000.0f ;
					StdMaxDis =0.0f     ;
					StdMinDis =10000.0f ;
					MinCirCount =0      ;
					// 삼항 연산자 최소값 구하기  
					if      (FInspectMode==Insp_Track) MinCirCount = (C4CirInEdgeCount<C4CirOutEdgeCount)?(C4CirInEdgeCount<C4CirStandEdgeCount)?C4CirInEdgeCount:C4CirStandEdgeCount:(C4CirOutEdgeCount<C4CirStandEdgeCount)?C4CirOutEdgeCount:C4CirStandEdgeCount;
					else if (FInspectMode==Insp_Mark ) MinCirCount =  C4CirInEdgeCount;     

					CircleCount=0;TotalCirDis=0.0f; AvgCirDis=0.0f;
					for(int k=0; k<MinCirCount; k++){
						if(FInspectMode==Insp_Track){ // TrackMode 
							if(C4CirInPoint[k].x==0    || C4CirInPoint[k].y==0    || k>=MAX_CIRCLE_EDGEPOINT) continue;
							if(C4CirStandPoint[k].x==0 || C4CirStandPoint[k].y==0 || k>=MAX_CIRCLE_EDGEPOINT) continue;

							if(IsMarkBtm){  // RealC4CirCneter값은 TrackLine EdgePoint기준 Circle_Fitting 결과물 
								Dis    = Math.GetLengthFrPointToPoint(RealC4CirCenter,C4CirInPoint[k]   );
								StdDis = Math.GetLengthFrPointToPoint(RealC4CirCenter,C4CirStandPoint[k]);
							}
							else {          // TrackLine 교차점 기준 센터 
								Dis    = Math.GetLengthFrPointToPoint(TrackC4CirCenter,C4CirInPoint[k]   );
							}

							if(Dis>MaxDis) MaxDis = Dis;
							if(Dis<MinDis) MinDis = Dis;

							if(StdDis>StdMaxDis) StdMaxDis = StdDis;
							if(StdDis<StdMinDis) StdMinDis = StdDis;


							if(k==0){ // BTM Defect 검사를 위한 좌표값 및 Dx,Dy 산출 
								if(IsMarkBtm){ 					
									C4CirDy = Math.GetLengthFrPointToPoint(TrackC4CirCenter,C4CirInPoint[k]);
								}
								else {
									C4CirDy = Math.GetLengthFrPointToPoint(TrackC4CirCenter,C4CirInPoint[k]);
								}
							} 
							if(k==(C4CirInEdgeCount-1)) {
								if(IsMarkBtm){ 					
									C4CirDx = Math.GetLengthFrPointToPoint(TrackC4CirCenter,C4CirInPoint[k]);
								}
								else {
									C4CirDx = Math.GetLengthFrPointToPoint(TrackC4CirCenter,C4CirInPoint[k]);
								}
							}
						}
						else if(FInspectMode==Insp_Mark){ // MarkMode 
							if(C4CirInPoint[k].x==0    || C4CirInPoint[k].y==0    || k>=MAX_CIRCLE_EDGEPOINT) continue;

							if(IsMarkBtm){  // RealC4CirCneter값은 연마안쪽 EdgePoint기준 Circle_Fitting 결과물 
								// 							Dis    = Math.GetLengthFrPointToPoint(RealC4CirCenter,C4CirInPoint[k]   );
								Dis = Math.GetLengthFrPointToPoint(CircleFit4Center,C4CirInPoint[k]  );
								// 							Dis    = Math.GetLengthFrPointToPoint(C4CirCenter,C4CirInPoint[k]   );
							}
							else {          // RealC4CirCneter값은 연마안쪽 EdgePoint기준 Circle_Fitting 결과물 
								Dis    = Math.GetLengthFrPointToPoint(CircleFit4Center,C4CirInPoint[k]   );
							}

							if(Dis>MaxDis) MaxDis = Dis;
							if(Dis<MinDis) MinDis = Dis;

							if(k==0){ // BTM Defect 검사를 위한 좌표값 및 Dx,Dy 산출 
								// 							C4CirDy = Math.GetLengthFrPointToPoint(RealC4CirCenter,C4CirInPoint[k]);
								C4CirDy = Math.GetLengthFrPointToPoint(CircleFit4Center,C4CirInPoint[k]);
							} 
							if(k==(C4CirInEdgeCount-1)) {
								// 							C4CirDx = Math.GetLengthFrPointToPoint(RealC4CirCenter,C4CirInPoint[k]);
								C4CirDx = Math.GetLengthFrPointToPoint(CircleFit4Center,C4CirInPoint[k]);
							}
						}

						C4CircleData[CircleCount].Dis  = Dis              ;  // FAVION Circle Fitting
						C4CircleData[CircleCount].P.x  = C4CirInPoint[k].x;
						C4CircleData[CircleCount].P.y  = C4CirInPoint[k].y;
						CircleCount++   ;
						TotalCirDis+=Dis;
					}
					if(CircleCount!=0 || TotalCirDis!=0){ // Circle AvgRound Cal
						AvgCirDis = (TotalCirDis/CircleCount);
						C4CirRound = AvgCirDis;
					}

					for(int i=0; i<CircleCount; i++){
						// 					C4CircleData[i].Dv = fabs(AvgCirDis - C4CircleData[i].Dis);       // Euresys Circle Fitting 
						C4CircleData[i].Dv = (CirFitDiameter4 - C4CircleData[i].Dis) <0 ?fabs(CirFitDiameter4 - C4CircleData[i].Dis):0;
						if(C4CircleData[i].Dv>MaxDv) MaxDv = C4CircleData[i].Dv;
						if(C4CircleData[i].Dv<MinDv) MinDv = C4CircleData[i].Dv;
					}
					C4CirDeftectCnt  = GetCircleSize(C4CircleData, C4CirDefectPoint, CircleCount, 5);

					if(!IsMarkBtm && C4CirInCrackCount>0 && BrokenThresHold!=0){
						for(int i=0; i<C4CirInCrackCount; i++){
							C4CircleData[i].Dv  =0.0f;
							C4CircleData[i].Dis =0.0f;
							C4CircleData[i].P.x  = C4CirInCrackPoint[i].x;
							C4CircleData[i].P.y  = C4CirInCrackPoint[i].y;
						}
						IAddress = RotateBrokenImg.GetImagePtr(); // Pixel 정보 추출 목적 
						C4CirCrackCnt  = GetCircleCrackSize(C4CircleData, C4CirCrackPoint, C4CirInCrackCount, 30, CrackCirDiameter4,CircleFit4Center,false);
					}
				}

				// C5Circle Calculate 
				if(C5CirInEdgeCount!=0){
					IAddress = DefectImg.GetImagePtr(); // Pixel 정보 추출 목적 

					MaxDis =0.0f     ;
					MinDis =10000.0f ;
					MaxDv  =0.0f     ;
					MinDv  =10000.0f ;
					StdMaxDis =0.0f     ;
					StdMinDis =10000.0f ;
					MinCirCount =0      ;
					// 삼항 연산자 최소값 구하기  
					if      (FInspectMode==Insp_Track) MinCirCount = (C5CirInEdgeCount<C5CirOutEdgeCount)?(C5CirInEdgeCount<C5CirStandEdgeCount)?C5CirInEdgeCount:C5CirStandEdgeCount:(C5CirOutEdgeCount<C5CirStandEdgeCount)?C5CirOutEdgeCount:C5CirStandEdgeCount;
					else if (FInspectMode==Insp_Mark ) MinCirCount =  C5CirInEdgeCount;

					CircleCount=0;TotalCirDis=0.0f; AvgCirDis=0.0f;
					for(int k=0; k<MinCirCount; k++){
						if(FInspectMode==Insp_Track){ // TrackMode 
							if(C5CirInPoint[k].x==0    || C5CirInPoint[k].y==0    || k>=MAX_CIRCLE_EDGEPOINT) continue;
							if(C5CirStandPoint[k].x==0 || C5CirStandPoint[k].y==0 || k>=MAX_CIRCLE_EDGEPOINT) continue;

							if(IsMarkBtm){  // RealC5CirCneter값은 TrackLine EdgePoint기준 Circle_Fitting 결과물 
								Dis    = Math.GetLengthFrPointToPoint(RealC5CirCenter,C5CirInPoint[k]   );
								StdDis = Math.GetLengthFrPointToPoint(RealC5CirCenter,C5CirStandPoint[k]);
							}
							else {          // TrackLine 교차점 기준 센터 
								Dis    = Math.GetLengthFrPointToPoint(TrackC5CirCenter,C5CirInPoint[k]   );
							}

							if(Dis>MaxDis) MaxDis = Dis;
							if(Dis<MinDis) MinDis = Dis;

							if(StdDis>StdMaxDis) StdMaxDis = StdDis;
							if(StdDis<StdMinDis) StdMinDis = StdDis;

							if(k==0){ // BTM Defect 검사를 위한 좌표값 및 Dx,Dy 산출 
								if(IsMarkBtm){ 					
									C5CirDy = Math.GetLengthFrPointToPoint(TrackC5CirCenter,C5CirInPoint[k]);
								}
								else {
									C5CirDy = Math.GetLengthFrPointToPoint(TrackC5CirCenter,C5CirInPoint[k]);
								}
							} 
							if(k==(C5CirInEdgeCount-1)) {
								if(IsMarkBtm){ 					
									C5CirDx = Math.GetLengthFrPointToPoint(TrackC5CirCenter,C5CirInPoint[k]);
								}
								else {
									C5CirDx = Math.GetLengthFrPointToPoint(TrackC5CirCenter,C5CirInPoint[k]);
								}
							}
						}
						else if(FInspectMode==Insp_Mark){ // MarkMode 
							if(C5CirInPoint[k].x==0    || C5CirInPoint[k].y==0    || k>=MAX_CIRCLE_EDGEPOINT) continue;

							if(IsMarkBtm){  // RealC5CirCneter값은 연마안쪽 EdgePoint기준 Circle_Fitting 결과물 
								// 							Dis    = Math.GetLengthFrPointToPoint(RealC5CirCenter,C5CirInPoint[k]   );
								Dis = Math.GetLengthFrPointToPoint(CircleFit5Center,C5CirInPoint[k]  );
								// 							Dis    = Math.GetLengthFrPointToPoint(C5CirCenter,C5CirInPoint[k]   );
							}
							else {          // RealC5CirCneter값은 연마안쪽 EdgePoint기준 Circle_Fitting 결과물 
								Dis    = Math.GetLengthFrPointToPoint(CircleFit5Center,C5CirInPoint[k]   );
							}

							if(Dis>MaxDis) MaxDis = Dis;
							if(Dis<MinDis) MinDis = Dis;

							if(k==0){ // BTM Defect 검사를 위한 좌표값 및 Dx,Dy 산출 
								// 							C5CirDy = Math.GetLengthFrPointToPoint(RealC5CirCenter,C5CirInPoint[k]);
								C5CirDy = Math.GetLengthFrPointToPoint(CircleFit5Center,C5CirInPoint[k]);
							} 
							if(k==(C5CirInEdgeCount-1)) {
								// 							C5CirDx = Math.GetLengthFrPointToPoint(RealC5CirCenter,C5CirInPoint[k]);
								C5CirDx = Math.GetLengthFrPointToPoint(CircleFit5Center,C5CirInPoint[k]);
							}
						}

						C5CircleData[CircleCount].Dis  = Dis            ;  // FAVION  Circle Fitting 
						C5CircleData[CircleCount].P.x  = C5CirInPoint[k].x;
						C5CircleData[CircleCount].P.y  = C5CirInPoint[k].y;
						CircleCount++   ;
						TotalCirDis+=Dis;
					}
					if(CircleCount!=0 || TotalCirDis!=0){ // Circle AvgRound Cal
						AvgCirDis = (TotalCirDis/CircleCount);
						C5CirRound = AvgCirDis;
					}

					for(int i=0; i<CircleCount; i++){
						// 					C5CircleData[i].Dv = fabs(AvgCirDis - C5CircleData[i].Dis);       // Euresys Circle Fitting  
						C5CircleData[i].Dv = (CirFitDiameter5 - C5CircleData[i].Dis) >0 ?(CirFitDiameter5 - C5CircleData[i].Dis):0;
						if(C5CircleData[i].Dv>MaxDv) MaxDv = C5CircleData[i].Dv;
						if(C5CircleData[i].Dv<MinDv) MinDv = C5CircleData[i].Dv;
					}
					C5CirDeftectCnt  = GetCircleSize(C5CircleData, C5CirDefectPoint, CircleCount, 5);

					if(!IsMarkBtm && C5CirInCrackCount>0 && BrokenThresHold!=0){
						for(int i=0; i<C5CirInCrackCount; i++){
							C5CircleData[i].Dv  =0.0f;
							C5CircleData[i].Dis =0.0f;
							C5CircleData[i].P.x  = C5CirInCrackPoint[i].x;
							C5CircleData[i].P.y  = C5CirInCrackPoint[i].y;
						}
						IAddress = RotateBrokenImg.GetImagePtr(); // Pixel 정보 추출 목적 
						C5CirCrackCnt  = GetCircleCrackSize(C5CircleData, C5CirCrackPoint, C5CirInCrackCount, 30, CrackCirDiameter5,CircleFit5Center);
					}
				}

				// C6Circle Calculate 
				if(C6CirInEdgeCount!=0){
					IAddress = DefectImg.GetImagePtr(); // Pixel 정보 추출 목적 

					MaxDis =0.0f     ;
					MinDis =10000.0f ;
					MaxDv  =0.0f     ;
					MinDv  =10000.0f ;
					StdMaxDis =0.0f     ;
					StdMinDis =10000.0f ;
					MinCirCount =0      ;
					// 삼항 연산자 최소값 구하기  
					if      (FInspectMode==Insp_Track) MinCirCount = (C6CirInEdgeCount<C6CirOutEdgeCount)?(C6CirInEdgeCount<C6CirStandEdgeCount)?C6CirInEdgeCount:C6CirStandEdgeCount:(C6CirOutEdgeCount<C6CirStandEdgeCount)?C6CirOutEdgeCount:C6CirStandEdgeCount;
					else if (FInspectMode==Insp_Mark ) MinCirCount =  C6CirInEdgeCount;  

					CircleCount=0;TotalCirDis=0.0f; AvgCirDis=0.0f;
					for(int k=0; k<MinCirCount; k++){
						if(FInspectMode==Insp_Track){ // TrackMode 
							if(C6CirInPoint[k].x==0    || C6CirInPoint[k].y==0    || k>=MAX_CIRCLE_EDGEPOINT) continue;
							if(C6CirStandPoint[k].x==0 || C6CirStandPoint[k].y==0 || k>=MAX_CIRCLE_EDGEPOINT) continue;

							if(IsMarkBtm){  // RealC6CirCneter값은 TrackLine EdgePoint기준 Circle_Fitting 결과물 
								Dis    = Math.GetLengthFrPointToPoint(RealC6CirCenter,C6CirInPoint[k]   );
								StdDis = Math.GetLengthFrPointToPoint(RealC6CirCenter,C6CirStandPoint[k]);
							}
							else {          // TrackLine 교차점 기준 센터 
								Dis    = Math.GetLengthFrPointToPoint(TrackC6CirCenter,C6CirInPoint[k]   );
							}

							if(Dis>MaxDis) MaxDis = Dis;
							if(Dis<MinDis) MinDis = Dis;

							if(StdDis>StdMaxDis) StdMaxDis = StdDis;
							if(StdDis<StdMinDis) StdMinDis = StdDis;


							if(k==0){ // BTM Defect 검사를 위한 좌표값 및 Dx,Dy 산출 
								if(IsMarkBtm){ 					
									C6CirDx = Math.GetLengthFrPointToPoint(TrackC6CirCenter,C6CirInPoint[k]);
								}
								else {
									C6CirDx = Math.GetLengthFrPointToPoint(TrackC6CirCenter,C6CirInPoint[k]);
								}
							} 
							if(k==(C6CirInEdgeCount-1)) {
								if(IsMarkBtm){ 					
									C6CirDy = Math.GetLengthFrPointToPoint(TrackC6CirCenter,C6CirInPoint[k]);
								}
								else {
									C6CirDy = Math.GetLengthFrPointToPoint(TrackC6CirCenter,C6CirInPoint[k]);
								}
							}
						}
						else if(FInspectMode==Insp_Mark){ // MarkMode 
							if(C6CirInPoint[k].x==0    || C6CirInPoint[k].y==0    || k>=MAX_CIRCLE_EDGEPOINT) continue;

							if(IsMarkBtm){  // RealC6CirCneter값은 연마안쪽 EdgePoint기준 Circle_Fitting 결과물 
								// 							Dis    = Math.GetLengthFrPointToPoint(RealC6CirCenter,C6CirInPoint[k]   );
								Dis = Math.GetLengthFrPointToPoint(CircleFit6Center,C6CirInPoint[k]  );
								// 							Dis    = Math.GetLengthFrPointToPoint(C6CirCenter,C6CirInPoint[k]   );
							}
							else {          // RealC6CirCneter값은 연마안쪽 EdgePoint기준 Circle_Fitting 결과물 
								Dis    = Math.GetLengthFrPointToPoint(CircleFit6Center,C6CirInPoint[k]   );
							}

							if(Dis>MaxDis) MaxDis = Dis;
							if(Dis<MinDis) MinDis = Dis;

							if(k==0){ // BTM Defect 검사를 위한 좌표값 및 Dx,Dy 산출 
								C6CirDx = Math.GetLengthFrPointToPoint(CircleFit6Center,C6CirInPoint[k]);
								// 							C6CirDx = Math.GetLengthFrPointToPoint(RealC6CirCenter,C6CirInPoint[k]);
							} 
							if(k==(C6CirInEdgeCount-1)) {
								C6CirDy = Math.GetLengthFrPointToPoint(CircleFit6Center,C6CirInPoint[k]);
								// 							C6CirDy = Math.GetLengthFrPointToPoint(RealC6CirCenter,C6CirInPoint[k]);
							}
						}

						C6CircleData[CircleCount].Dis  = Dis            ; // FAVION Circle Fitting 
						C6CircleData[CircleCount].P.x  = C6CirInPoint[k].x;
						C6CircleData[CircleCount].P.y  = C6CirInPoint[k].y;
						CircleCount++   ;
						TotalCirDis+=Dis;
					}
					if(CircleCount!=0 || TotalCirDis!=0){ // Circle AvgRound Cal
						AvgCirDis = (TotalCirDis/CircleCount);
						C6CirRound = AvgCirDis;
					}

					for(int i=0; i<CircleCount; i++){
						// 					C6CircleData[i].Dv = fabs(AvgCirDis - C6CircleData[i].Dis);       // Euresys Circle Fitting 
						C6CircleData[i].Dv = (CirFitDiameter6 - C6CircleData[i].Dis) >0 ?(CirFitDiameter6 - C6CircleData[i].Dis):0;
						if(C6CircleData[i].Dv>MaxDv) MaxDv = C6CircleData[i].Dv;
						if(C6CircleData[i].Dv<MinDv) MinDv = C6CircleData[i].Dv;
					}
					C6CirDeftectCnt  = GetCircleSize(C6CircleData, C6CirDefectPoint, CircleCount, 5);

					if(!IsMarkBtm && C6CirInCrackCount>0 && BrokenThresHold!=0){
						for(int i=0; i<C6CirInCrackCount; i++){
							C6CircleData[i].Dv  =0.0f;
							C6CircleData[i].Dis =0.0f;
							C6CircleData[i].P.x  = C6CirInCrackPoint[i].x;
							C6CircleData[i].P.y  = C6CirInCrackPoint[i].y;
						}
						IAddress = RotateBrokenImg.GetImagePtr(); // Pixel 정보 추출 목적 
						C6CirCrackCnt  = GetCircleCrackSize(C6CircleData, C6CirCrackPoint, C6CirInCrackCount, 30, CrackCirDiameter6,CircleFit6Center);
					}
				}
			}


			// Side D 
			///////////////////////////////////////////////////////////////////////////////////////////////////////////////
			//LogUnit.SetLog("CUP_Side_D_Start_CamId: %d, ImageHeight: %d ",CamId,ImageHeight);     
			// 			DefectROI.SetPlacement((int)(SP.x+SideMargin),(int)(SP.y+BtmMargin), FLeftWidth, LeftHeight-(2*BtmMargin));
			// 			if((SP.x+SideMargin) <=0          || SP.y+BtmMargin<0            || FLeftWidth<=0          || LeftHeight-(2*BtmMargin)< 0          ) return false;
			// 			if((SP.x+SideMargin) >=ImageWidth || SP.y+BtmMargin>BtmLimitLine || FLeftWidth>=ImageWidth || LeftHeight-(2*BtmMargin)>BtmLimitLine) return false;
			// 			if((SP.x+SideMargin)+FLeftWidth >=ImageWidth || (SP.y+BtmMargin)+(LeftHeight-(2*BtmMargin))>BtmLimitLine                           ) return false;

			IAddress = DefectImg.GetImagePtr(); // Pixel 정보 추출 목적 
			DefectROI.SetPlacement((int)(SP.x+SideMargin),(int)(SP.y+LeftDegMargin), FLeftWidth, LeftHeight-(2*LeftDegMargin));
			if((SP.x+SideMargin) <=0          || SP.y+LeftDegMargin<0            || FLeftWidth<=0          || LeftHeight-(2*LeftDegMargin)< 0          ) return false;
			if((SP.x+SideMargin) >=ImageWidth || SP.y+LeftDegMargin>BtmLimitLine || FLeftWidth>=ImageWidth || LeftHeight-(2*LeftDegMargin)>BtmLimitLine) return false;
			if((SP.x+SideMargin)+FLeftWidth >=ImageWidth || (SP.y+LeftDegMargin)+(LeftHeight-(2*LeftDegMargin))>BtmLimitLine                           ) return false;

			// Line Position 
			LinePosition = SP.x+SideMargin;
			// Blob 검사 진행 
			CodeImageSelection.Clear();
			CodeImageEncoder.Encode(DefectROI,CodeImage);
			CodeImageSelection.Clear();
			CodeImageSelection.AddObjects(CodeImage);
			// Blob 필터링 
			CodeImageSelection.RemoveUsingFloatFeature(EFeature_BoundingBoxWidth ,FMinWidth , FMaxWidth  , EDoubleThresholdMode_Outside);
			CodeImageSelection.RemoveUsingFloatFeature(EFeature_BoundingBoxHeight,FMinHeight, FMaxHeight , EDoubleThresholdMode_Outside);
			// 				CodeImageSelection.RemoveUsingIntegerFeature(EFeature_LeftLimit        ,0       , 3          , EDoubleThresholdMode_Outside);
			CodeImageSelection.RemoveUsingIntegerFeature(EFeature_LeftLimit        ,0       , 1          , EDoubleThresholdMode_Outside);

			BlobCount = CodeImageSelection.GetElementCount();
			CodeImageSelection.Sort(EFeature_TopLimit,ESortDirection_Ascending);

			if(BlobCount!=0){
				for(int k=0; k<BlobCount; k++){
					if(DCount>=MAX_DEFECT_POINT) break;
					DDefectPoint[DCount].Width  =  CodeImageSelection.GetElement(k).GetBoundingBoxWidth() ;
					DDefectPoint[DCount].Height =  CodeImageSelection.GetElement(k).GetBoundingBoxHeight();

					DDefectPoint[DCount].Rect.left   =(long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterX() - DDefectPoint[DCount].Width/2 ) +LinePosition );
					DDefectPoint[DCount].Rect.top    =(long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - DDefectPoint[DCount].Height/2)+(SP.y+LeftDegMargin));
					DDefectPoint[DCount].Rect.right  =(long)(DDefectPoint[DCount].Rect.left+ DDefectPoint[DCount].Width );
					DDefectPoint[DCount].Rect.bottom =(long)(DDefectPoint[DCount].Rect.top + DDefectPoint[DCount].Height);
					PixelCount =0;
					PixelValue =0;

					// 내부 Pixel Data 축출 
					for(int n=DDefectPoint[DCount].Rect.top+1 ; n<DDefectPoint[DCount].Rect.bottom-1; n++){
						for(int m=DDefectPoint[DCount].Rect.left+1; m<DDefectPoint[DCount].Rect.right-1 ; m++){
							PixelValue = IElement(m,n);
							if(PixelValue < EnCapBtmThresHold) PixelCount++;
						}
					}

					DDefectPoint[DCount].Round = PixelCount;
					DDefectPoint[DCount].P.x    =(float)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterX() - DDefectPoint[DCount].Width/2 ) +LinePosition);
					DDefectPoint[DCount].P.y    =(float)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - DDefectPoint[DCount].Height/2)+(SP.y+LeftDegMargin)+ImageHeight);
					DDefectPoint[DCount].Width  = (InspectMode)?DDefectPoint[DCount].Width: DDefectPoint[DCount].Width+SideMargin;

					// Merge 위해서 데이터 필요함 
					DDefectPoint[DCount].Rect.top    =(long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - DDefectPoint[DCount].Height/2) +(SP.y+LeftDegMargin)+ImageHeight);
					DDefectPoint[DCount].Rect.bottom =(long)(DDefectPoint[DCount].Rect.top + DDefectPoint[DCount].Height);
					DCount++;
				}
			}
			BlobCount=0;
			// 외곽라인에서 Mark까지의 거리 산출 
			if     (Line[waLeftWall].FP0.x >Line[waLeftWall].FP1.x) LDistance = FP0.x - (Line[waLeftWall].FP1.x+(Line[waLeftWall].FP0.x - Line[waLeftWall].FP1.x)/2);
			else if(Line[waLeftWall].FP0.x==Line[waLeftWall].FP1.x) LDistance = FP0.x -  Line[waLeftWall].FP0.x;
			else                                                    LDistance = FP0.x - (Line[waLeftWall].FP0.x+(Line[waLeftWall].FP1.x - Line[waLeftWall].FP0.x)/2); 
			////////////////////////////////////////////////////////////////////////////////////////////////


			// Side B
			////////////////////////////////////////////////////////////////////////////////////////////////
			DefectROI.SetPlacement((int)(EP.x-FRightWidth-SideMargin),(int)(EP.y+RightDegMargin), FRightWidth,  RightHeight-(2*RightDegMargin));
			if((EP.x-FRightWidth-SideMargin) <=0          || (EP.y+RightDegMargin)<0            || FRightWidth<=0          || RightHeight-(2*RightDegMargin)<0           ) return false;
			if((EP.x-FRightWidth-SideMargin) >=ImageWidth || (EP.y+RightDegMargin)>BtmLimitLine || FRightWidth>=ImageWidth || RightHeight-(2*RightDegMargin)>BtmLimitLine) return false;
			if((EP.x-FRightWidth-SideMargin)+FRightWidth >=ImageWidth || (EP.y+RightDegMargin)+(RightHeight-(2*RightDegMargin))>BtmLimitLine                             ) return false;

			// 			DefectROI.SetPlacement((int)(EP.x-FRightWidth-SideMargin),(int)(EP.y+BtmMargin), FRightWidth,  RightHeight-(2*BtmMargin));
			// 			if((EP.x-FRightWidth-SideMargin) <=0          || (EP.y+BtmMargin)<0            || FRightWidth<=0          || RightHeight-(2*BtmMargin)<0           ) return false;
			// 			if((EP.x-FRightWidth-SideMargin) >=ImageWidth || (EP.y+BtmMargin)>BtmLimitLine || FRightWidth>=ImageWidth || RightHeight-(2*BtmMargin)>BtmLimitLine) return false;
			// 			if((EP.x-FRightWidth-SideMargin)+FRightWidth >=ImageWidth || (EP.y+BtmMargin)+(RightHeight-(2*BtmMargin))>BtmLimitLine                             ) return false;

			// Line Position 
			LinePosition = EP.x - FRightWidth- SideMargin;
			// Blob 검사 진행 
			CodeImageSelection.Clear();
			CodeImageEncoder.Encode(DefectROI,CodeImage);
			CodeImageSelection.Clear();
			CodeImageSelection.AddObjects(CodeImage);
			// Blob 필터링 
			CodeImageSelection.RemoveUsingFloatFeature  (EFeature_BoundingBoxWidth ,FMinWidth               , FMaxWidth                , EDoubleThresholdMode_Outside);
			CodeImageSelection.RemoveUsingFloatFeature  (EFeature_BoundingBoxHeight,FMinHeight              , FMaxHeight               , EDoubleThresholdMode_Outside);
			CodeImageSelection.RemoveUsingIntegerFeature(EFeature_RightLimit       ,FRightWidth -1          , FRightWidth+1            , EDoubleThresholdMode_Outside);

			BlobCount = CodeImageSelection.GetElementCount();
			CodeImageSelection.Sort(EFeature_TopLimit,ESortDirection_Ascending);

			if(BlobCount!=0){
				for(int k=0; k<BlobCount; k++){
					if(BCount>=MAX_DEFECT_POINT) break;
					BDefectPoint[BCount].Width  = CodeImageSelection.GetElement(k).GetBoundingBoxWidth() ; 
					BDefectPoint[BCount].Height = CodeImageSelection.GetElement(k).GetBoundingBoxHeight();

					BDefectPoint[BCount].Rect.left   =(long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterX() - BDefectPoint[BCount].Width/2 ) +(LinePosition)  );
					BDefectPoint[BCount].Rect.top    =(long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - BDefectPoint[BCount].Height/2) +(EP.y+RightDegMargin));
					BDefectPoint[BCount].Rect.right  =(long)(BDefectPoint[BCount].Rect.left+ BDefectPoint[BCount].Width );
					BDefectPoint[BCount].Rect.bottom =(long)(BDefectPoint[BCount].Rect.top + BDefectPoint[BCount].Height);
					PixelCount = 0;
					PixelValue = 0;

					// 내부 Pixel Data 축출 
					for(int n=BDefectPoint[BCount].Rect.top+1 ; n<BDefectPoint[BCount].Rect.bottom-1; n++){
						for(int m=BDefectPoint[BCount].Rect.left+1; m<BDefectPoint[BCount].Rect.right-1 ; m++){
							PixelValue = IElement(m,n);
							if(PixelValue < EnCapBtmThresHold) PixelCount++;
						}
					}
					BDefectPoint[BCount].Round  = PixelCount;
					BDefectPoint[BCount].P.x    =(float)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterX() - BDefectPoint[BCount].Width/2 )+(LinePosition));
					BDefectPoint[BCount].P.y    =(float)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - BDefectPoint[BCount].Height/2)+(EP.y+RightDegMargin)+ImageHeight   );
					BDefectPoint[BCount].Width  =(InspectMode)? BDefectPoint[BCount].Width: BDefectPoint[BCount].Width+SideMargin;

					// Merge 위해서 데이터 필요함 
					BDefectPoint[BCount].Rect.top    =(long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - BDefectPoint[BCount].Height/2) +(EP.y+RightDegMargin)+ImageHeight);
					BDefectPoint[BCount].Rect.bottom =(long)(BDefectPoint[BCount].Rect.top + BDefectPoint[BCount].Height);
					BCount++;
				}
			}
			BlobCount =0;
			// 외곽라인에서 Mark까지의 거리 산출 
			if     (Line[waRightWall].FP0.x >Line[waRightWall].FP1.x) RDistance = (Line[waRightWall].FP1.x+(Line[waRightWall].FP0.x - Line[waRightWall].FP1.x)/2) - FP1.x;
			else if(Line[waRightWall].FP0.x==Line[waRightWall].FP1.x) RDistance =  Line[waRightWall].FP0.x - FP1.x;
			else                                                      RDistance = (Line[waRightWall].FP0.x+(Line[waRightWall].FP1.x - Line[waRightWall].FP0.x)/2) - FP1.x;
			////////////////////////////////////////////////////////////////////////////////////////////////

			// Side C 
			// Circle 검사 후 6개의 좌표기준으로 5개의 영역 검사 진행함 
			///////////////////////////////////////////////////////////////////////////////////////////////
			// Notch부 직선영역 Dark Defect 검사 시퀀스 시작 
			//첫번째 Btm영역의 직선라인 기준 검사 
			if(BtmInLine[0].FP0.x!=0 && BtmInLine[0].FP0.y!=0 && BtmInLine[0].FP1.x!=0 && BtmInLine[0].FP1.y!=0){
				DefectROI.SetPlacement((int)(BtmInLine[0].FP0.x+SideMargin), (int)(BtmInLine[0].FP0.y-FBtmHeight), (BtmInLine[0].FP1.x - BtmInLine[0].FP0.x)-(2*SideMargin), FBtmHeight);
				if((BtmInLine[0].FP0.x+SideMargin) <=0          ||(BtmInLine[0].FP0.y-FBtmHeight)< 0           || (BtmInLine[0].FP1.x - BtmInLine[0].FP0.x)-(2*SideMargin)<=0          || FBtmHeight< 0          ) return false;
				if((BtmInLine[0].FP0.x+SideMargin) >=ImageWidth ||(BtmInLine[0].FP0.y-FBtmHeight)>BtmLimitLine || (BtmInLine[0].FP1.x - BtmInLine[0].FP0.x)-(2*SideMargin)>=ImageWidth || FBtmHeight>BtmLimitLine) return false;
				if((BtmInLine[0].FP0.x+SideMargin)+((BtmInLine[0].FP1.x - BtmInLine[0].FP0.x)-(2*SideMargin)) >=ImageWidth ||(BtmInLine[0].FP0.y-FBtmHeight)+FBtmHeight>BtmLimitLine                             ) return false;
				//Blob 검사 진행함 
				CodeImageSelection.Clear();
				CodeImageEncoder.Encode(DefectROI,CodeImage);
				CodeImageSelection.Clear();
				CodeImageSelection.AddObjects(CodeImage);
				// Blob 필터링 
				CodeImageSelection.RemoveUsingFloatFeature  (EFeature_BoundingBoxWidth ,FMinWidth      , FMaxWidth   , EDoubleThresholdMode_Outside);
				CodeImageSelection.RemoveUsingFloatFeature  (EFeature_BoundingBoxHeight,FMinHeight     , FMaxHeight  , EDoubleThresholdMode_Outside);
				CodeImageSelection.RemoveUsingIntegerFeature(EFeature_BottomLimit      ,FBtmHeight-1   , FBtmHeight+1, EDoubleThresholdMode_Outside);

				BlobCount = CodeImageSelection.GetElementCount();
				CodeImageSelection.Sort(EFeature_LeftLimit ,ESortDirection_Ascending);

				if(BlobCount!=0){
					for(int k=0; k<BlobCount; k++){
						if(CCount>=MAX_DEFECT_POINT) break; 
						CDefectPoint[CCount].Width  =  CodeImageSelection.GetElement(k).GetBoundingBoxWidth() ;
						CDefectPoint[CCount].Height =  CodeImageSelection.GetElement(k).GetBoundingBoxHeight();

						CDefectPoint[CCount].Rect.left   =(long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterX() - CDefectPoint[CCount].Width/2 ) +(BtmInLine[0].FP0.x+SideMargin));
						CDefectPoint[CCount].Rect.top    =(long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - CDefectPoint[CCount].Height/2) +(BtmInLine[0].FP0.y-FBtmHeight));
						CDefectPoint[CCount].Rect.right  =(long)(CDefectPoint[CCount].Rect.left+ CDefectPoint[CCount].Width );
						CDefectPoint[CCount].Rect.bottom =(long)(CDefectPoint[CCount].Rect.top + CDefectPoint[CCount].Height);
						PixelCount = 0;
						PixelValue = 0;

						// 내부 Pixel Data 축출 
						for(int n=CDefectPoint[CCount].Rect.top+1 ; n<CDefectPoint[CCount].Rect.bottom-1; n++){
							for(int m=CDefectPoint[CCount].Rect.left+1; m<CDefectPoint[CCount].Rect.right-1 ; m++){
								PixelValue = IElement(m,n);
								if(PixelValue < EnCapBtmThresHold) PixelCount++;
							}
						}
						CDefectPoint[CCount].Round  =  PixelCount;
						CDefectPoint[CCount].P.x    = (float)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterX() - CDefectPoint[CCount].Width/2 ) +(BtmInLine[0].FP0.x+SideMargin));
						CDefectPoint[CCount].P.y    = (float)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - CDefectPoint[CCount].Height/2) +(BtmInLine[0].FP0.y-FBtmHeight));

						// Image Rotate 기준 좌표를 다시 Rotate한다 _ Display 목적 
						if(ImgDegree!=0.0f){
							CDefectPoint[CCount].P = Math.OnRotate(CenterPoint, CDefectPoint[CCount].P, (ImgDegree));
						}
						// Image Rotate 기준 좌표를 회전 이후에 ImageHeight값을 더하여 실제 좌표를 산출한다 
						CDefectPoint[CCount].P.y    =(float)(CDefectPoint[CCount].P.y+ImageHeight);

						// Merge 위해서 데이터 필요함 
						CDefectPoint[CCount].Rect.top    =(long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - CDefectPoint[CCount].Height/2) +(BtmInLine[0].FP0.y-FBtmHeight)+ImageHeight);
						CDefectPoint[CCount].Rect.bottom =(long)(CDefectPoint[CCount].Rect.top + CDefectPoint[CCount].Height);
						CCount++;
					}
				}
			}
			BlobCount =0;

			///////////////////////////////////////////////////////////////////////////////////////////////
			//두번째 Btm영역의 직선라인 기준 검사 
			if(BtmInLine[1].FP0.x!=0 && BtmInLine[1].FP0.y!=0 && BtmInLine[1].FP1.x!=0 && BtmInLine[1].FP1.y!=0){
				DefectROI.SetPlacement((int)(BtmInLine[1].FP0.x-FRightWidth-SideMargin),(int)(BtmInLine[1].FP0.y), FRightWidth,  (BtmInLine[1].FP1.y - BtmInLine[1].FP0.y));
				if((BtmInLine[1].FP0.x-FRightWidth-SideMargin) <=0          || (BtmInLine[1].FP0.y)<0            || FRightWidth<=0          || (BtmInLine[1].FP1.y - BtmInLine[1].FP0.y)<=0          ) return false;
				if((BtmInLine[1].FP0.x-FRightWidth-SideMargin) >=ImageWidth || (BtmInLine[1].FP0.y)>BtmLimitLine || FRightWidth>=ImageWidth || (BtmInLine[1].FP1.y - BtmInLine[1].FP0.y)>BtmLimitLine) return false;
				if((BtmInLine[1].FP0.x-FRightWidth-SideMargin)+ FRightWidth >=ImageWidth ||(BtmInLine[1].FP0.y)+(BtmInLine[1].FP1.y - BtmInLine[1].FP0.y)>BtmLimitLine                               ) return false;

				// Line Position 
				LinePosition = BtmInLine[1].FP0.x-FRightWidth-SideMargin;
				// Blob 검사 진행 
				CodeImageSelection.Clear();
				CodeImageEncoder.Encode(DefectROI,CodeImage);
				CodeImageSelection.Clear();
				CodeImageSelection.AddObjects(CodeImage);
				// Blob 필터링 
				CodeImageSelection.RemoveUsingFloatFeature  (EFeature_BoundingBoxWidth ,FMinWidth               , FMaxWidth                , EDoubleThresholdMode_Outside);
				CodeImageSelection.RemoveUsingFloatFeature  (EFeature_BoundingBoxHeight,FMinHeight              , FMaxHeight               , EDoubleThresholdMode_Outside);
				CodeImageSelection.RemoveUsingIntegerFeature(EFeature_RightLimit     ,FRightWidth -1            , FRightWidth+1            , EDoubleThresholdMode_Outside);

				BlobCount = CodeImageSelection.GetElementCount();
				CodeImageSelection.Sort(EFeature_TopLimit,ESortDirection_Ascending);

				if(BlobCount!=0){
					for(int k=0; k<BlobCount; k++){
						if(BCount>=MAX_DEFECT_POINT) break;
						BDefectPoint[BCount].Width  = CodeImageSelection.GetElement(k).GetBoundingBoxWidth() ; 
						BDefectPoint[BCount].Height = CodeImageSelection.GetElement(k).GetBoundingBoxHeight();

						BDefectPoint[BCount].Rect.left   =(long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterX() - BDefectPoint[BCount].Width/2 ) +(LinePosition)      );
						BDefectPoint[BCount].Rect.top    =(long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - BDefectPoint[BCount].Height/2) +(BtmInLine[1].FP0.y));
						BDefectPoint[BCount].Rect.right  =(long)(BDefectPoint[BCount].Rect.left+ BDefectPoint[BCount].Width );
						BDefectPoint[BCount].Rect.bottom =(long)(BDefectPoint[BCount].Rect.top + BDefectPoint[BCount].Height);
						PixelCount = 0;
						PixelValue = 0;

						// 내부 Pixel Data 축출 
						for(int n=BDefectPoint[BCount].Rect.top+1 ; n<BDefectPoint[BCount].Rect.bottom-1; n++){
							for(int m=BDefectPoint[BCount].Rect.left+1; m<BDefectPoint[BCount].Rect.right-1 ; m++){
								PixelValue = IElement(m,n);
								if(PixelValue < EnCapBtmThresHold) PixelCount++;
							}
						}
						BDefectPoint[BCount].Round  = PixelCount;
						BDefectPoint[BCount].P.x    =(float)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterX() - BDefectPoint[BCount].Width/2 )+(LinePosition));
						BDefectPoint[BCount].P.y    =(float)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - BDefectPoint[BCount].Height/2)+(BtmInLine[1].FP0.y)+ImageHeight);
						BDefectPoint[BCount].Width  =(InspectMode)? BDefectPoint[BCount].Width: BDefectPoint[BCount].Width+SideMargin;

						// Merge 위해서 데이터 필요함 
						BDefectPoint[BCount].Rect.top    =(long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - BDefectPoint[BCount].Height/2) +(BtmInLine[1].FP0.y)+ImageHeight);
						BDefectPoint[BCount].Rect.bottom =(long)(BDefectPoint[BCount].Rect.top + BDefectPoint[BCount].Height);
						BCount++;
					}
				}
			}
			BlobCount =0;

			///////////////////////////////////////////////////////////////////////////////////////////////
			//세번째 Btm영역의 직선라인 기준 검사 
			//Dark Defect 
			if(BtmInLine[2].FP0.x!=0 && BtmInLine[2].FP0.y!=0 && BtmInLine[2].FP1.x!=0 && BtmInLine[2].FP1.y!=0){
				// 				DefectROI.SetPlacement((int)(BtmInLine[2].FP0.x+SideMargin), (int)(BtmInLine[2].FP0.y-50),(BtmInLine[2].FP1.x - BtmInLine[2].FP0.x)-(2*SideMargin), 50);
				DefectROI.SetPlacement((int)(BtmInLine[2].FP0.x+SideMargin), (int)(BtmInLine[2].FP0.y-FBtmHeight),(BtmInLine[2].FP1.x - BtmInLine[2].FP0.x)-(2*SideMargin), FBtmHeight);
				if((BtmInLine[2].FP0.x+SideMargin) <=0          ||(BtmInLine[2].FP0.y-FBtmHeight)< 0           || (BtmInLine[2].FP1.x - BtmInLine[2].FP0.x)-(2*SideMargin)<=0          || FBtmHeight<0           ) return false;
				if((BtmInLine[2].FP0.x+SideMargin) >=ImageWidth ||(BtmInLine[2].FP0.y-FBtmHeight)>BtmLimitLine || (BtmInLine[2].FP1.x - BtmInLine[2].FP0.x)-(2*SideMargin)>=ImageWidth || FBtmHeight>BtmLimitLine) return false;
				// 				if((BtmInLine[2].FP0.x+SideMargin) <=0          ||(BtmInLine[2].FP0.y-50)< 0           || (BtmInLine[2].FP1.x - BtmInLine[2].FP0.x)-(2*SideMargin)<=0          || FBtmHeight<0           ) return false;
				// 				if((BtmInLine[2].FP0.x+SideMargin) >=ImageWidth ||(BtmInLine[2].FP0.y-50)>BtmLimitLine || (BtmInLine[2].FP1.x - BtmInLine[2].FP0.x)-(2*SideMargin)>=ImageWidth || FBtmHeight>BtmLimitLine) return false;
				if((BtmInLine[2].FP0.x+SideMargin) +(BtmInLine[2].FP1.x - BtmInLine[2].FP0.x)-(2*SideMargin)>=ImageWidth ||(BtmInLine[2].FP0.y-FBtmHeight)+FBtmHeight>BtmLimitLine                               ) return false;
				//Blob 검사 진행함 
				CodeImageSelection.Clear();
				CodeImageEncoder.Encode(DefectROI,CodeImage);
				CodeImageSelection.Clear();
				CodeImageSelection.AddObjects(CodeImage);
				// Blob 필터링 
				CodeImageSelection.RemoveUsingFloatFeature  (EFeature_BoundingBoxWidth ,FMinWidth      , FMaxWidth   , EDoubleThresholdMode_Outside);
				CodeImageSelection.RemoveUsingFloatFeature  (EFeature_BoundingBoxHeight,FMinHeight     , FMaxHeight  , EDoubleThresholdMode_Outside);
				CodeImageSelection.RemoveUsingIntegerFeature(EFeature_BottomLimit      ,FBtmHeight-1   , FBtmHeight+1, EDoubleThresholdMode_Outside);

				BlobCount = CodeImageSelection.GetElementCount();
				CodeImageSelection.Sort(EFeature_LeftLimit ,ESortDirection_Ascending);

				if(BlobCount!=0){
					for(int k=0; k<BlobCount; k++){
						if(CCount>=MAX_DEFECT_POINT) break; 
						CDefectPoint[CCount].Width  =  CodeImageSelection.GetElement(k).GetBoundingBoxWidth() ;
						CDefectPoint[CCount].Height =  CodeImageSelection.GetElement(k).GetBoundingBoxHeight();

						CDefectPoint[CCount].Rect.left   =(long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterX() - CDefectPoint[CCount].Width/2 ) +(BtmInLine[2].FP0.x+SideMargin));
						CDefectPoint[CCount].Rect.top    =(long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - CDefectPoint[CCount].Height/2) +(BtmInLine[2].FP0.y-FBtmHeight));
						CDefectPoint[CCount].Rect.right  =(long)(CDefectPoint[CCount].Rect.left+ CDefectPoint[CCount].Width );
						CDefectPoint[CCount].Rect.bottom =(long)(CDefectPoint[CCount].Rect.top + CDefectPoint[CCount].Height);
						PixelCount = 0;
						PixelValue = 0;

						// 내부 Pixel Data 축출 
						for(int n=CDefectPoint[CCount].Rect.top+1 ; n<CDefectPoint[CCount].Rect.bottom-1; n++){
							for(int m=CDefectPoint[CCount].Rect.left+1; m<CDefectPoint[CCount].Rect.right-1 ; m++){
								PixelValue = IElement(m,n);
								if(PixelValue < EnCapBtmThresHold) PixelCount++;
							}
						}
						CDefectPoint[CCount].Round  =  PixelCount;
						CDefectPoint[CCount].P.x    = (float)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterX() - CDefectPoint[CCount].Width/2 ) +(BtmInLine[2].FP0.x+SideMargin));
						CDefectPoint[CCount].P.y    = (float)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - CDefectPoint[CCount].Height/2) +(BtmInLine[2].FP0.y-FBtmHeight));

						// Image Rotate 기준 좌표를 다시 Rotate한다 _ Display 목적 
						if(ImgDegree!=0.0f){
							CDefectPoint[CCount].P = Math.OnRotate(CenterPoint, CDefectPoint[CCount].P, (ImgDegree));
						}
						// Image Rotate 기준 좌표를 회전 이후에 ImageHeight값을 더하여 실제 좌표를 산출한다 
						CDefectPoint[CCount].P.y    =(float)(CDefectPoint[CCount].P.y+ImageHeight);

						// Merge 위해서 데이터 필요함 
						CDefectPoint[CCount].Rect.top    =(long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - CDefectPoint[CCount].Height/2) +(BtmInLine[2].FP0.y-FBtmHeight)+ImageHeight);
						CDefectPoint[CCount].Rect.bottom =(long)(CDefectPoint[CCount].Rect.top + CDefectPoint[CCount].Height);
						CCount++;
					}
				}
			}
			BlobCount =0;

			///////////////////////////////////////////////////////////////////////////////////////////////
			//네번째 Btm영역의 직선라인 기준 검사 
			if(BtmInLine[3].FP0.x!=0 && BtmInLine[3].FP0.y!=0 && BtmInLine[3].FP1.x!=0 && BtmInLine[3].FP1.y!=0){
				DefectROI.SetPlacement((int)(BtmInLine[3].FP0.x+SideMargin),(int)(BtmInLine[3].FP0.y), FLeftWidth, (BtmInLine[3].FP1.y - BtmInLine[3].FP0.y));
				if((BtmInLine[3].FP0.x+SideMargin) <=0          || BtmInLine[3].FP0.y<0            || FLeftWidth<=0          || (BtmInLine[3].FP1.y - BtmInLine[3].FP0.y)< 0          ) return false;
				if((BtmInLine[3].FP0.x+SideMargin) >=ImageWidth || BtmInLine[3].FP0.y>BtmLimitLine || FLeftWidth>=ImageWidth || (BtmInLine[3].FP1.y - BtmInLine[3].FP0.y)>BtmLimitLine) return false;
				if((BtmInLine[3].FP0.x+SideMargin)+FLeftWidth >=ImageWidth || BtmInLine[3].FP0.y+(BtmInLine[3].FP1.y - BtmInLine[3].FP0.y)>BtmLimitLine                               ) return false;
				// Line Position 
				LinePosition = BtmInLine[3].FP0.x+SideMargin;
				// Blob 검사 진행 
				CodeImageSelection.Clear();
				CodeImageEncoder.Encode(DefectROI,CodeImage);
				CodeImageSelection.Clear();
				CodeImageSelection.AddObjects(CodeImage);
				// Blob 필터링 
				CodeImageSelection.RemoveUsingFloatFeature(EFeature_BoundingBoxWidth ,FMinWidth , FMaxWidth  , EDoubleThresholdMode_Outside);
				CodeImageSelection.RemoveUsingFloatFeature(EFeature_BoundingBoxHeight,FMinHeight, FMaxHeight , EDoubleThresholdMode_Outside);
				// 				CodeImageSelection.RemoveUsingIntegerFeature(EFeature_LeftLimit        ,0       , 3          , EDoubleThresholdMode_Outside);
				CodeImageSelection.RemoveUsingIntegerFeature(EFeature_LeftLimit        ,0       , 1          , EDoubleThresholdMode_Outside);

				BlobCount = CodeImageSelection.GetElementCount();
				CodeImageSelection.Sort(EFeature_TopLimit,ESortDirection_Ascending);

				if(BlobCount!=0){
					for(int k=0; k<BlobCount; k++){
						if(DCount>=MAX_DEFECT_POINT) break;
						DDefectPoint[DCount].Width  =  CodeImageSelection.GetElement(k).GetBoundingBoxWidth() ;
						DDefectPoint[DCount].Height =  CodeImageSelection.GetElement(k).GetBoundingBoxHeight();

						DDefectPoint[DCount].Rect.left   =(long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterX() - DDefectPoint[DCount].Width/2 ) +LinePosition );
						DDefectPoint[DCount].Rect.top    =(long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - DDefectPoint[DCount].Height/2)+(BtmInLine[3].FP0.y));
						DDefectPoint[DCount].Rect.right  =(long)(DDefectPoint[DCount].Rect.left+ DDefectPoint[DCount].Width );
						DDefectPoint[DCount].Rect.bottom =(long)(DDefectPoint[DCount].Rect.top + DDefectPoint[DCount].Height);
						PixelCount =0;
						PixelValue =0;

						// 내부 Pixel Data 축출 
						for(int n=DDefectPoint[DCount].Rect.top+1 ; n<DDefectPoint[DCount].Rect.bottom-1; n++){
							for(int m=DDefectPoint[DCount].Rect.left+1; m<DDefectPoint[DCount].Rect.right-1 ; m++){
								PixelValue = IElement(m,n);
								if(PixelValue < EnCapBtmThresHold) PixelCount++;
							}
						}

						DDefectPoint[DCount].Round = PixelCount;
						DDefectPoint[DCount].P.x    =(float)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterX() - DDefectPoint[DCount].Width/2 ) +LinePosition);
						DDefectPoint[DCount].P.y    =(float)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - DDefectPoint[DCount].Height/2)+(BtmInLine[3].FP0.y)+ImageHeight);
						DDefectPoint[DCount].Width  = (InspectMode)?DDefectPoint[DCount].Width: DDefectPoint[DCount].Width+SideMargin;

						// Merge 위해서 데이터 필요함 
						DDefectPoint[DCount].Rect.top    =(long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - DDefectPoint[DCount].Height/2) +(BtmInLine[3].FP0.y)+ImageHeight);
						DDefectPoint[DCount].Rect.bottom =(long)(DDefectPoint[DCount].Rect.top + DDefectPoint[DCount].Height);
						DCount++;
					}
				}
			}
			BlobCount =0;

			///////////////////////////////////////////////////////////////////////////////////////////////
			//다섯번째 Btm영역의 직선라인 기준 검사 
			if(BtmInLine[4].FP0.x!=0 && BtmInLine[4].FP0.y!=0 && BtmInLine[4].FP1.x!=0 && BtmInLine[4].FP1.y!=0){
				DefectROI.SetPlacement((int)(BtmInLine[4].FP0.x+SideMargin), (int)(BtmInLine[4].FP0.y-FBtmHeight),(BtmInLine[4].FP1.x - BtmInLine[4].FP0.x)-(2*SideMargin), FBtmHeight);
				if((BtmInLine[4].FP0.x+SideMargin) <=0          ||(BtmInLine[4].FP0.y-FBtmHeight)<0            || (BtmInLine[4].FP1.x - BtmInLine[4].FP0.x)-(2*SideMargin)<=0          || FBtmHeight< 0          ) return false;
				if((BtmInLine[4].FP0.x+SideMargin) >=ImageWidth ||(BtmInLine[4].FP0.y-FBtmHeight)>BtmLimitLine || (BtmInLine[4].FP1.x - BtmInLine[4].FP0.x)-(2*SideMargin)>=ImageWidth || FBtmHeight>BtmLimitLine) return false;
				if((BtmInLine[4].FP0.x+SideMargin) + (BtmInLine[4].FP1.x - BtmInLine[4].FP0.x)-(2*SideMargin) >=ImageWidth ||(BtmInLine[4].FP0.y-FBtmHeight)+FBtmHeight>BtmLimitLine                             ) return false;
				//Blob 검사 진행함 
				CodeImageSelection.Clear();
				CodeImageEncoder.Encode(DefectROI,CodeImage);
				CodeImageSelection.Clear();
				CodeImageSelection.AddObjects(CodeImage);
				// Blob 필터링 
				CodeImageSelection.RemoveUsingFloatFeature  (EFeature_BoundingBoxWidth ,FMinWidth      , FMaxWidth   , EDoubleThresholdMode_Outside);
				CodeImageSelection.RemoveUsingFloatFeature  (EFeature_BoundingBoxHeight,FMinHeight     , FMaxHeight  , EDoubleThresholdMode_Outside);
				CodeImageSelection.RemoveUsingIntegerFeature(EFeature_BottomLimit      ,FBtmHeight-1   , FBtmHeight+1, EDoubleThresholdMode_Outside);

				BlobCount = CodeImageSelection.GetElementCount();
				CodeImageSelection.Sort(EFeature_LeftLimit ,ESortDirection_Ascending);

				if(BlobCount!=0){
					for(int k=0; k<BlobCount; k++){
						if(CCount>=MAX_DEFECT_POINT) break; 
						CDefectPoint[CCount].Width  =  CodeImageSelection.GetElement(k).GetBoundingBoxWidth() ;
						CDefectPoint[CCount].Height =  CodeImageSelection.GetElement(k).GetBoundingBoxHeight();

						CDefectPoint[CCount].Rect.left   =(long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterX() - CDefectPoint[CCount].Width/2 ) +(BtmInLine[4].FP0.x+SideMargin));
						CDefectPoint[CCount].Rect.top    =(long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - CDefectPoint[CCount].Height/2) +(BtmInLine[4].FP0.y-FBtmHeight));
						CDefectPoint[CCount].Rect.right  =(long)(CDefectPoint[CCount].Rect.left+ CDefectPoint[CCount].Width );
						CDefectPoint[CCount].Rect.bottom =(long)(CDefectPoint[CCount].Rect.top + CDefectPoint[CCount].Height);
						PixelCount = 0;
						PixelValue = 0;

						// 내부 Pixel Data 축출 
						for(int n=CDefectPoint[CCount].Rect.top+1 ; n<CDefectPoint[CCount].Rect.bottom-1; n++){
							for(int m=CDefectPoint[CCount].Rect.left+1; m<CDefectPoint[CCount].Rect.right-1 ; m++){
								PixelValue = IElement(m,n);
								if(PixelValue < EnCapBtmThresHold) PixelCount++;
							}
						}
						CDefectPoint[CCount].Round  =  PixelCount;
						CDefectPoint[CCount].P.x    = (float)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterX() - CDefectPoint[CCount].Width/2 ) +(BtmInLine[4].FP0.x+SideMargin));
						CDefectPoint[CCount].P.y    = (float)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - CDefectPoint[CCount].Height/2) +(BtmInLine[4].FP0.y-FBtmHeight));

						// Image Rotate 기준 좌표를 다시 Rotate한다 _ Display 목적 
						if(ImgDegree!=0.0f){
							CDefectPoint[CCount].P = Math.OnRotate(CenterPoint, CDefectPoint[CCount].P, (ImgDegree));
						}
						// Image Rotate 기준 좌표를 회전 이후에 ImageHeight값을 더하여 실제 좌표를 산출한다 
						CDefectPoint[CCount].P.y    =(float)(CDefectPoint[CCount].P.y+ImageHeight);

						// Merge 위해서 데이터 필요함 
						CDefectPoint[CCount].Rect.top    =(long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - CDefectPoint[CCount].Height/2) +(BtmInLine[4].FP0.y-FBtmHeight)+ImageHeight);
						CDefectPoint[CCount].Rect.bottom =(long)(CDefectPoint[CCount].Rect.top + CDefectPoint[CCount].Height);
						CCount++;
					}
				}
			}
			BlobCount =0;
			/////////////////////////////////////////////////////////////////////////////////////////////
			// Notch부 직선영역 Dark Defect 검사 시퀀스 종료 

			/////////////////////////////////////////////////////////////////////////////////////////////
			// RF_MODEL 직선영역 Dark Defect 검사 시퀀스 시작 
			// 			if(C2CirInEdgeCount==0 && C3CirInEdgeCount==0 && C4CirInEdgeCount==0 && C5CirInEdgeCount==0){
			// 
			// 			}
			/////////////////////////////////////////////////////////////////////////////////////////////
			// RF_MODEL 직선영역 Dark Defect 검사 시퀀스 종료 


			// 연마 후 세정 작업시 물이 들어갈경우 발생하는 불량 검출 목적 
			// 원형 박리불량, 꽃 박리불량 검출 시퀀스.....EnCap영역에서만 검사를 진행함 
			// Notch부 직선영역 Bright Defect 검사 시퀀스 시작 
			if(BrokenThresHold!=0 && !IsMarkBtm){
				// 이미지 변환 
				// 				EasyImage::Threshold(&RotateImg,&DefectImg, BrokenThresHold); 
				DefectROI.Attach(&RotateBrokenImg);
				CodeImageSelection.SetFeretAngle(0.00f);
				CodeImageEncoder.GetGrayscaleSingleThresholdSegmenter().SetWhiteLayerEncoded(true );
				CodeImageEncoder.GetGrayscaleSingleThresholdSegmenter().SetBlackLayerEncoded(false);
				IAddress = RotateBrokenImg.GetImagePtr();

				// TEST 목적 
				FBtmHeight =70;
				// Notch부 직선영역 Dark Defect 검사 시퀀스 시작 
				//첫번째 Btm영역의 직선라인 기준 검사 
				// 				if(BtmInLine[0].FP0.x!=0 && BtmInLine[0].FP0.y!=0 && BtmInLine[0].FP1.x!=0 && BtmInLine[0].FP1.y!=0){
				// 					DefectROI.SetPlacement((int)(BtmInLine[0].FP0.x+SideMargin), (int)(BtmInLine[0].FP0.y-FBtmHeight), (BtmInLine[0].FP1.x - BtmInLine[0].FP0.x)-(2*SideMargin), FBtmHeight);
				// 					if((BtmInLine[0].FP0.x+SideMargin) <=0          ||(BtmInLine[0].FP0.y-FBtmHeight)< 0           || (BtmInLine[0].FP1.x - BtmInLine[0].FP0.x)-(2*SideMargin)<=0          || FBtmHeight< 0          ) return false;
				// 					if((BtmInLine[0].FP0.x+SideMargin) >=ImageWidth ||(BtmInLine[0].FP0.y-FBtmHeight)>BtmLimitLine || (BtmInLine[0].FP1.x - BtmInLine[0].FP0.x)-(2*SideMargin)>=ImageWidth || FBtmHeight>BtmLimitLine) return false;
				// 					if((BtmInLine[0].FP0.x+SideMargin)+((BtmInLine[0].FP1.x - BtmInLine[0].FP0.x)-(2*SideMargin)) >=ImageWidth ||(BtmInLine[0].FP0.y-FBtmHeight)+FBtmHeight>BtmLimitLine                             ) return false;

				// 새로운 Cell박리 검사 목적...점점 소스가 더러워진다..첨부터  알았으면...이따구로 코딩할수 없을텐데...
				// 4_Round
				if(C2CirInEdgeCount==0 && C3CirInEdgeCount==0 && C4CirInEdgeCount==0 && C5CirInEdgeCount==0){
					if(BtmInLine[0].FP0.x!=0 && BtmInLine[0].FP0.y!=0 && BtmInLine[0].FP1.x!=0 && BtmInLine[0].FP1.y!=0){
						DefectROI.SetPlacement((int)(BtmInLine[0].FP0.x)-50, (int)(BtmInLine[0].FP0.y-FBtmHeight), (BtmInLine[0].FP1.x - BtmInLine[0].FP0.x)+100, FBtmHeight);
						if((BtmInLine[0].FP0.x-50) <=0          ||(BtmInLine[0].FP0.y-FBtmHeight)< 0           || ((BtmInLine[0].FP1.x - BtmInLine[0].FP0.x)+100)<=0          || FBtmHeight< 0          ) return false;
						if((BtmInLine[0].FP0.x-50) >=ImageWidth ||(BtmInLine[0].FP0.y-FBtmHeight)>BtmLimitLine || ((BtmInLine[0].FP1.x - BtmInLine[0].FP0.x)+100)>=ImageWidth || FBtmHeight>BtmLimitLine) return false;
						if((BtmInLine[0].FP0.x-50)+((BtmInLine[0].FP1.x - BtmInLine[0].FP0.x)+100) >=ImageWidth ||( BtmInLine[0].FP0.y-FBtmHeight)+FBtmHeight>BtmLimitLine                             ) return false;

						//Blob 검사 진행함 
						CodeImageSelection.Clear();
						CodeImageEncoder.Encode(DefectROI,CodeImage);
						CodeImageSelection.Clear();
						CodeImageSelection.AddObjects(CodeImage);
						// Blob 필터링 
						CodeImageSelection.RemoveUsingFloatFeature  (EFeature_BoundingBoxWidth ,3     , FMaxWidth   , EDoubleThresholdMode_Outside);
						CodeImageSelection.RemoveUsingFloatFeature  (EFeature_BoundingBoxHeight,3     , FMaxHeight  , EDoubleThresholdMode_Outside);
						// 					CodeImageSelection.RemoveUsingIntegerFeature(EFeature_BottomLimit      ,FBtmHeight-1   , FBtmHeight+1, EDoubleThresholdMode_Outside);

						BlobCount = CodeImageSelection.GetElementCount();
						CodeImageSelection.Sort(EFeature_LeftLimit ,ESortDirection_Ascending);

						if(BlobCount!=0){
							for(int k=0; k<BlobCount; k++){
								if(CCrackCount>=MAX_DEFECT_POINT) break; 
								CCrackPoint[CCrackCount].Width  =  CodeImageSelection.GetElement(k).GetBoundingBoxWidth() ;
								CCrackPoint[CCrackCount].Height =  CodeImageSelection.GetElement(k).GetBoundingBoxHeight();

								CCrackPoint[CCrackCount].Rect.left   =(long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterX() - CCrackPoint[CCrackCount].Width/2 ) +(BtmInLine[0].FP0.x)-50);
								CCrackPoint[CCrackCount].Rect.top    =(long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - CCrackPoint[CCrackCount].Height/2) +(BtmInLine[0].FP0.y-FBtmHeight));
								CCrackPoint[CCrackCount].Rect.right  =(long)(CCrackPoint[CCrackCount].Rect.left+ CCrackPoint[CCrackCount].Width );
								CCrackPoint[CCrackCount].Rect.bottom =(long)(CCrackPoint[CCrackCount].Rect.top + CCrackPoint[CCrackCount].Height);
								CCrackPoint[CCrackCount].LineAttach  =(CodeImageSelection.GetElement(k).GetBottomLimit()>(FBtmHeight-5)) ? 1: 0;
								PixelCount = 0;
								PixelValue = 0;

								// 내부 Pixel Data 축출 
								for(int n=CCrackPoint[CCrackCount].Rect.top+1 ; n<CCrackPoint[CCrackCount].Rect.bottom-1; n++){
									for(int m=CCrackPoint[CCrackCount].Rect.left+1; m<CCrackPoint[CCrackCount].Rect.right-1 ; m++){
										PixelValue = IElement(m,n);
										if(PixelValue > BrokenThresHold) PixelCount++;
									}
								}
								CCrackPoint[CCrackCount].Round  =  PixelCount;
								CCrackPoint[CCrackCount].P.x    = (float)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterX() - CCrackPoint[CCrackCount].Width/2 ) +(BtmInLine[0].FP0.x)-50);
								CCrackPoint[CCrackCount].P.y    = (float)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - CCrackPoint[CCrackCount].Height/2) +(BtmInLine[0].FP0.y-FBtmHeight));

								// Image Rotate 기준 좌표를 다시 Rotate한다 _ Display 목적 
								if(ImgDegree!=0.0f){
									CCrackPoint[CCrackCount].P = Math.OnRotate(CenterPoint, CCrackPoint[CCrackCount].P, (ImgDegree));
								}
								// Image Rotate 기준 좌표를 회전 이후에 ImageHeight값을 더하여 실제 좌표를 산출한다 
								CCrackPoint[CCrackCount].P.y    =(float)(CCrackPoint[CCrackCount].P.y+ImageHeight);

								// Merge 위해서 데이터 필요함 
								CCrackPoint[CCrackCount].Rect.top    =(long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - CCrackPoint[CCrackCount].Height/2) +(BtmInLine[0].FP0.y-FBtmHeight)+ImageHeight);
								CCrackPoint[CCrackCount].Rect.bottom =(long)(CCrackPoint[CCrackCount].Rect.top + CCrackPoint[CCrackCount].Height);
								CCrackCount++;
							}
						}
					}
				}
				BlobCount=0;


				if(BtmEdgePoint[0].x!=0 && BtmInLine[0].FP0.y!=0 && BtmEdgePoint[1].x!=0 && BtmInLine[0].FP1.y!=0){
					DefectROI.SetPlacement((int)(BtmEdgePoint[0].x)-50, (int)(BtmInLine[0].FP0.y-FBtmHeight), (BtmEdgePoint[1].x - BtmEdgePoint[0].x)+100, FBtmHeight);
					if((BtmEdgePoint[0].x-50) <=0          ||(BtmInLine[0].FP0.y-FBtmHeight)< 0           || ((BtmEdgePoint[1].x - BtmEdgePoint[0].x)+100)<=0          || FBtmHeight< 0          ) return false;
					if((BtmEdgePoint[0].x-50) >=ImageWidth ||(BtmInLine[0].FP0.y-FBtmHeight)>BtmLimitLine || ((BtmEdgePoint[1].x - BtmEdgePoint[0].x)+100)>=ImageWidth || FBtmHeight>BtmLimitLine) return false;
					if((BtmEdgePoint[0].x-50)+((BtmEdgePoint[1].x - BtmEdgePoint[0].x)) >=ImageWidth ||(BtmInLine[0].FP0.y-FBtmHeight)+FBtmHeight>BtmLimitLine                             ) return false;

					//Blob 검사 진행함 
					CodeImageSelection.Clear();
					CodeImageEncoder.Encode(DefectROI,CodeImage);
					CodeImageSelection.Clear();
					CodeImageSelection.AddObjects(CodeImage);
					// Blob 필터링 
					CodeImageSelection.RemoveUsingFloatFeature  (EFeature_BoundingBoxWidth ,3     , FMaxWidth   , EDoubleThresholdMode_Outside);
					CodeImageSelection.RemoveUsingFloatFeature  (EFeature_BoundingBoxHeight,3     , FMaxHeight  , EDoubleThresholdMode_Outside);
					// 					CodeImageSelection.RemoveUsingIntegerFeature(EFeature_BottomLimit      ,FBtmHeight-1   , FBtmHeight+1, EDoubleThresholdMode_Outside);

					BlobCount = CodeImageSelection.GetElementCount();
					CodeImageSelection.Sort(EFeature_LeftLimit ,ESortDirection_Ascending);

					if(BlobCount!=0){
						for(int k=0; k<BlobCount; k++){
							if(CCrackCount>=MAX_DEFECT_POINT) break; 
							CCrackPoint[CCrackCount].Width  =  CodeImageSelection.GetElement(k).GetBoundingBoxWidth() ;
							CCrackPoint[CCrackCount].Height =  CodeImageSelection.GetElement(k).GetBoundingBoxHeight();

							CCrackPoint[CCrackCount].Rect.left   =(long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterX() - CCrackPoint[CCrackCount].Width/2 ) +(BtmEdgePoint[0].x-50));
							CCrackPoint[CCrackCount].Rect.top    =(long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - CCrackPoint[CCrackCount].Height/2) +(BtmInLine[0].FP0.y-FBtmHeight));
							CCrackPoint[CCrackCount].Rect.right  =(long)(CCrackPoint[CCrackCount].Rect.left+ CCrackPoint[CCrackCount].Width );
							CCrackPoint[CCrackCount].Rect.bottom =(long)(CCrackPoint[CCrackCount].Rect.top + CCrackPoint[CCrackCount].Height);
							CCrackPoint[CCrackCount].LineAttach  =(CodeImageSelection.GetElement(k).GetBottomLimit()>(FBtmHeight-5)) ? 1: 0;
							PixelCount = 0;
							PixelValue = 0;

							// 내부 Pixel Data 축출 
							for(int n=CCrackPoint[CCrackCount].Rect.top+1 ; n<CCrackPoint[CCrackCount].Rect.bottom-1; n++){
								for(int m=CCrackPoint[CCrackCount].Rect.left+1; m<CCrackPoint[CCrackCount].Rect.right-1 ; m++){
									PixelValue = IElement(m,n);
									if(PixelValue > BrokenThresHold) PixelCount++;
								}
							}
							CCrackPoint[CCrackCount].Round  =  PixelCount;
							CCrackPoint[CCrackCount].P.x    = (float)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterX() - CCrackPoint[CCrackCount].Width/2 ) +(BtmEdgePoint[0].x-50));
							CCrackPoint[CCrackCount].P.y    = (float)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - CCrackPoint[CCrackCount].Height/2) +(BtmInLine[0].FP0.y-FBtmHeight));

							// Image Rotate 기준 좌표를 다시 Rotate한다 _ Display 목적 
							if(ImgDegree!=0.0f){
								CCrackPoint[CCrackCount].P = Math.OnRotate(CenterPoint, CCrackPoint[CCrackCount].P, (ImgDegree));
							}
							// Image Rotate 기준 좌표를 회전 이후에 ImageHeight값을 더하여 실제 좌표를 산출한다 
							CCrackPoint[CCrackCount].P.y    =(float)(CCrackPoint[CCrackCount].P.y+ImageHeight);

							// Merge 위해서 데이터 필요함 
							CCrackPoint[CCrackCount].Rect.top    =(long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - CCrackPoint[CCrackCount].Height/2) +(BtmInLine[0].FP0.y-FBtmHeight)+ImageHeight);
							CCrackPoint[CCrackCount].Rect.bottom =(long)(CCrackPoint[CCrackCount].Rect.top + CCrackPoint[CCrackCount].Height);
							CCrackCount++;
						}
					}
				}
				BlobCount =0;

				///////////////////////////////////////////////////////////////////////////////////////////////
				//두번째 Btm영역의 직선라인 기준 검사 
				if(BtmInLine[1].FP0.x!=0 && BtmInLine[1].FP0.y!=0 && BtmInLine[1].FP1.x!=0 && BtmInLine[1].FP1.y!=0){
					DefectROI.SetPlacement((int)(BtmInLine[1].FP0.x-FRightWidth-SideMargin),(int)(BtmInLine[1].FP0.y), FRightWidth,  (BtmInLine[1].FP1.y - BtmInLine[1].FP0.y));
					if((BtmInLine[1].FP0.x-FRightWidth-SideMargin) <=0          || (BtmInLine[1].FP0.y)<0            || FRightWidth<=0          || (BtmInLine[1].FP1.y - BtmInLine[1].FP0.y)<=0          ) return false;
					if((BtmInLine[1].FP0.x-FRightWidth-SideMargin) >=ImageWidth || (BtmInLine[1].FP0.y)>BtmLimitLine || FRightWidth>=ImageWidth || (BtmInLine[1].FP1.y - BtmInLine[1].FP0.y)>BtmLimitLine) return false;
					if((BtmInLine[1].FP0.x-FRightWidth-SideMargin)+ FRightWidth >=ImageWidth ||(BtmInLine[1].FP0.y)+(BtmInLine[1].FP1.y - BtmInLine[1].FP0.y)>BtmLimitLine                               ) return false;

					// Line Position 
					LinePosition = BtmInLine[1].FP0.x-FRightWidth-SideMargin;
					// Blob 검사 진행 
					CodeImageSelection.Clear();
					CodeImageEncoder.Encode(DefectROI,CodeImage);
					CodeImageSelection.Clear();
					CodeImageSelection.AddObjects(CodeImage);
					// Blob 필터링 
					CodeImageSelection.RemoveUsingFloatFeature  (EFeature_BoundingBoxWidth ,3 , FMaxWidth  , EDoubleThresholdMode_Outside);
					CodeImageSelection.RemoveUsingFloatFeature  (EFeature_BoundingBoxHeight,3 , FMaxHeight , EDoubleThresholdMode_Outside);
					// 					CodeImageSelection.RemoveUsingIntegerFeature(EFeature_RightLimit     ,FRightWidth -1            , FRightWidth+1            , EDoubleThresholdMode_Outside);

					BlobCount = CodeImageSelection.GetElementCount();
					CodeImageSelection.Sort(EFeature_TopLimit,ESortDirection_Ascending);

					if(BlobCount!=0){
						for(int k=0; k<BlobCount; k++){
							if(BCount>=MAX_DEFECT_POINT) break;
							BCrackPoint[BCrackCount].Width  = CodeImageSelection.GetElement(k).GetBoundingBoxWidth() ; 
							BCrackPoint[BCrackCount].Height = CodeImageSelection.GetElement(k).GetBoundingBoxHeight();

							BCrackPoint[BCrackCount].Rect.left   =(long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterX() - BCrackPoint[BCrackCount].Width/2 ) +(LinePosition)      );
							BCrackPoint[BCrackCount].Rect.top    =(long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - BCrackPoint[BCrackCount].Height/2) +(BtmInLine[1].FP0.y));
							BCrackPoint[BCrackCount].Rect.right  =(long)(BCrackPoint[BCrackCount].Rect.left+ BCrackPoint[BCrackCount].Width );
							BCrackPoint[BCrackCount].Rect.bottom =(long)(BCrackPoint[BCrackCount].Rect.top + BCrackPoint[BCrackCount].Height);
							BCrackPoint[BCrackCount].LineAttach  =(CodeImageSelection.GetElement(k).GetRightLimit()>(FRightWidth-5)) ? 1: 0;
							PixelCount = 0;
							PixelValue = 0;

							// 내부 Pixel Data 축출 
							for(int n=BCrackPoint[BCrackCount].Rect.top+1 ; n<BCrackPoint[BCrackCount].Rect.bottom-1; n++){
								for(int m=BCrackPoint[BCrackCount].Rect.left+1; m<BCrackPoint[BCrackCount].Rect.right-1 ; m++){
									PixelValue = IElement(m,n);
									if(PixelValue > BrokenThresHold) PixelCount++;
								}
							}
							BCrackPoint[BCrackCount].Round  = PixelCount;
							BCrackPoint[BCrackCount].P.x    =(float)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterX() - BCrackPoint[BCrackCount].Width/2 )+(LinePosition));
							BCrackPoint[BCrackCount].P.y    =(float)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - BCrackPoint[BCrackCount].Height/2)+(BtmInLine[1].FP0.y)+ImageHeight);
							BCrackPoint[BCrackCount].Width  =(InspectMode)? BCrackPoint[BCrackCount].Width: BCrackPoint[BCrackCount].Width+SideMargin;

							// Merge 위해서 데이터 필요함 
							BCrackPoint[BCrackCount].Rect.top    =(long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - BCrackPoint[BCrackCount].Height/2) +(BtmInLine[1].FP0.y)+ImageHeight);
							BCrackPoint[BCrackCount].Rect.bottom =(long)(BCrackPoint[BCrackCount].Rect.top + BCrackPoint[BCrackCount].Height);
							BCrackCount++;
						}
					}
				}
				BlobCount =0;

				///////////////////////////////////////////////////////////////////////////////////////////////
				//세번째 Btm영역의 직선라인 기준 검사 
				// 				if(BtmInLine[2].FP0.x!=0 && BtmInLine[2].FP0.y!=0 && BtmInLine[2].FP1.x!=0 && BtmInLine[2].FP1.y!=0){
				// 					DefectROI.SetPlacement((int)(BtmInLine[2].FP0.x+SideMargin), (int)(BtmInLine[2].FP0.y-FBtmHeight),(BtmInLine[2].FP1.x - BtmInLine[2].FP0.x)-(2*SideMargin), FBtmHeight);
				// 					if((BtmInLine[2].FP0.x+SideMargin) <=0          ||(BtmInLine[2].FP0.y-FBtmHeight)< 0           || (BtmInLine[2].FP1.x - BtmInLine[2].FP0.x)-(2*SideMargin)<=0          || FBtmHeight<0           ) return false;
				// 					if((BtmInLine[2].FP0.x+SideMargin) >=ImageWidth ||(BtmInLine[2].FP0.y-FBtmHeight)>BtmLimitLine || (BtmInLine[2].FP1.x - BtmInLine[2].FP0.x)-(2*SideMargin)>=ImageWidth || FBtmHeight>BtmLimitLine) return false;
				// 					if((BtmInLine[2].FP0.x+SideMargin) +(BtmInLine[2].FP1.x - BtmInLine[2].FP0.x)-(2*SideMargin)>=ImageWidth ||(BtmInLine[2].FP0.y-FBtmHeight)+FBtmHeight>BtmLimitLine                               ) return false;
				// Bright Defect 
				if(BtmEdgePoint[4].x!=0 && BtmInLine[2].FP0.y!=0 && BtmEdgePoint[5].x!=0 && BtmInLine[2].FP1.y!=0){
					DefectROI.SetPlacement((int)(BtmEdgePoint[4].x-50), (int)(BtmInLine[2].FP0.y-FBtmHeight),((BtmEdgePoint[5].x - BtmEdgePoint[4].x)+100), FBtmHeight);
					if((BtmEdgePoint[4].x-50) <=0          ||(BtmInLine[2].FP0.y-FBtmHeight)< 0           || ((BtmEdgePoint[5].x - BtmEdgePoint[4].x)+100)<=0		     || FBtmHeight<0           ) return false;
					if((BtmEdgePoint[4].x-50) >=ImageWidth ||(BtmInLine[2].FP0.y-FBtmHeight)>BtmLimitLine || ((BtmEdgePoint[5].x - BtmEdgePoint[4].x)+100)>=ImageWidth || FBtmHeight>BtmLimitLine) return false;
					if((BtmEdgePoint[4].x-50) +((BtmEdgePoint[5].x - BtmEdgePoint[4].x)+20)>=ImageWidth ||(BtmInLine[2].FP0.y-FBtmHeight)+FBtmHeight>BtmLimitLine                               ) return false;

					//Blob 검사 진행함 
					CodeImageSelection.Clear();
					CodeImageEncoder.Encode(DefectROI,CodeImage);
					CodeImageSelection.Clear();
					CodeImageSelection.AddObjects(CodeImage);
					// Blob 필터링 
					CodeImageSelection.RemoveUsingFloatFeature  (EFeature_BoundingBoxWidth ,3, FMaxWidth   , EDoubleThresholdMode_Outside);
					CodeImageSelection.RemoveUsingFloatFeature  (EFeature_BoundingBoxHeight,3, FMaxHeight  , EDoubleThresholdMode_Outside);
					// 					CodeImageSelection.RemoveUsingIntegerFeature(EFeature_BottomLimit      ,FBtmHeight-1   , FBtmHeight+1, EDoubleThresholdMode_Outside);

					BlobCount = CodeImageSelection.GetElementCount();
					CodeImageSelection.Sort(EFeature_LeftLimit ,ESortDirection_Ascending);

					if(BlobCount!=0){
						for(int k=0; k<BlobCount; k++){
							if(CCrackCount>=MAX_DEFECT_POINT) break; 
							CCrackPoint[CCrackCount].Width  =  CodeImageSelection.GetElement(k).GetBoundingBoxWidth() ;
							CCrackPoint[CCrackCount].Height =  CodeImageSelection.GetElement(k).GetBoundingBoxHeight();

							CCrackPoint[CCrackCount].Rect.left   =(long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterX() - CCrackPoint[CCrackCount].Width/2 ) +(BtmEdgePoint[4].x)-50);
							CCrackPoint[CCrackCount].Rect.top    =(long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - CCrackPoint[CCrackCount].Height/2) +(BtmInLine[2].FP0.y-FBtmHeight));
							CCrackPoint[CCrackCount].Rect.right  =(long)(CCrackPoint[CCrackCount].Rect.left+ CCrackPoint[CCrackCount].Width );
							CCrackPoint[CCrackCount].Rect.bottom =(long)(CCrackPoint[CCrackCount].Rect.top + CCrackPoint[CCrackCount].Height);
							CCrackPoint[CCrackCount].LineAttach  =(CodeImageSelection.GetElement(k).GetBottomLimit()>(FBtmHeight-5)) ? 1: 0;
							PixelCount = 0;
							PixelValue = 0;

							// 내부 Pixel Data 축출 
							for(int n=CCrackPoint[CCrackCount].Rect.top+1 ; n<CCrackPoint[CCrackCount].Rect.bottom-1; n++){
								for(int m=CCrackPoint[CCrackCount].Rect.left+1; m<CCrackPoint[CCrackCount].Rect.right-1 ; m++){
									PixelValue = IElement(m,n);
									if(PixelValue > BrokenThresHold) PixelCount++;
								}
							}
							CCrackPoint[CCrackCount].Round  =  PixelCount;
							CCrackPoint[CCrackCount].P.x    = (float)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterX() - CCrackPoint[CCrackCount].Width/2 ) +(BtmEdgePoint[4].x)-50);
							CCrackPoint[CCrackCount].P.y    = (float)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - CCrackPoint[CCrackCount].Height/2) +(BtmInLine[2].FP0.y-FBtmHeight));

							// Image Rotate 기준 좌표를 다시 Rotate한다 _ Display 목적 
							if(ImgDegree!=0.0f){
								CCrackPoint[CCrackCount].P = Math.OnRotate(CenterPoint, CCrackPoint[CCrackCount].P, (ImgDegree));
							}
							// Image Rotate 기준 좌표를 회전 이후에 ImageHeight값을 더하여 실제 좌표를 산출한다 
							CCrackPoint[CCrackCount].P.y    =(float)(CCrackPoint[CCrackCount].P.y+ImageHeight);

							// Merge 위해서 데이터 필요함 
							CCrackPoint[CCrackCount].Rect.top    =(long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - CCrackPoint[CCrackCount].Height/2) +(BtmInLine[2].FP0.y-FBtmHeight)+ImageHeight);
							CCrackPoint[CCrackCount].Rect.bottom =(long)(CCrackPoint[CCrackCount].Rect.top + CCrackPoint[CCrackCount].Height);
							CCrackCount++;
						}
					}
				}
				BlobCount =0;

				///////////////////////////////////////////////////////////////////////////////////////////////
				//네번째 Btm영역의 직선라인 기준 검사 
				if(BtmInLine[3].FP0.x!=0 && BtmInLine[3].FP0.y!=0 && BtmInLine[3].FP1.x!=0 && BtmInLine[3].FP1.y!=0){
					DefectROI.SetPlacement((int)(BtmInLine[3].FP0.x+SideMargin),(int)(BtmInLine[3].FP0.y), FLeftWidth, (BtmInLine[3].FP1.y - BtmInLine[3].FP0.y));
					if((BtmInLine[3].FP0.x+SideMargin) <=0          || BtmInLine[3].FP0.y<0            || FLeftWidth<=0          || (BtmInLine[3].FP1.y - BtmInLine[3].FP0.y)< 0          ) return false;
					if((BtmInLine[3].FP0.x+SideMargin) >=ImageWidth || BtmInLine[3].FP0.y>BtmLimitLine || FLeftWidth>=ImageWidth || (BtmInLine[3].FP1.y - BtmInLine[3].FP0.y)>BtmLimitLine) return false;
					if((BtmInLine[3].FP0.x+SideMargin)+FLeftWidth >=ImageWidth || BtmInLine[3].FP0.y+(BtmInLine[3].FP1.y - BtmInLine[3].FP0.y)>BtmLimitLine                               ) return false;
					// Line Position 
					LinePosition = BtmInLine[3].FP0.x+SideMargin;
					// Blob 검사 진행 
					CodeImageSelection.Clear();
					CodeImageEncoder.Encode(DefectROI,CodeImage);
					CodeImageSelection.Clear();
					CodeImageSelection.AddObjects(CodeImage);
					// Blob 필터링 
					CodeImageSelection.RemoveUsingFloatFeature(EFeature_BoundingBoxWidth ,3, FMaxWidth  , EDoubleThresholdMode_Outside);
					CodeImageSelection.RemoveUsingFloatFeature(EFeature_BoundingBoxHeight,3, FMaxHeight , EDoubleThresholdMode_Outside);
					// 					CodeImageSelection.RemoveUsingIntegerFeature(EFeature_LeftLimit        ,0       , 1          , EDoubleThresholdMode_Outside);

					BlobCount = CodeImageSelection.GetElementCount();
					CodeImageSelection.Sort(EFeature_TopLimit,ESortDirection_Ascending);

					if(BlobCount!=0){
						for(int k=0; k<BlobCount; k++){
							if(DCount>=MAX_DEFECT_POINT) break;
							DCrackPoint[DCrackCount].Width  =  CodeImageSelection.GetElement(k).GetBoundingBoxWidth() ;
							DCrackPoint[DCrackCount].Height =  CodeImageSelection.GetElement(k).GetBoundingBoxHeight();

							DCrackPoint[DCrackCount].Rect.left   =(long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterX() - DCrackPoint[DCrackCount].Width/2 ) +LinePosition );
							DCrackPoint[DCrackCount].Rect.top    =(long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - DCrackPoint[DCrackCount].Height/2)+(BtmInLine[3].FP0.y));
							DCrackPoint[DCrackCount].Rect.right  =(long)(DCrackPoint[DCrackCount].Rect.left+ DCrackPoint[DCrackCount].Width );
							DCrackPoint[DCrackCount].Rect.bottom =(long)(DCrackPoint[DCrackCount].Rect.top + DCrackPoint[DCrackCount].Height);
							DCrackPoint[DCrackCount].LineAttach  =(CodeImageSelection.GetElement(k).GetLeftLimit()<5) ? 1: 0;
							PixelCount =0;
							PixelValue =0;

							// 내부 Pixel Data 축출 
							for(int n=DCrackPoint[DCrackCount].Rect.top+1 ; n<DCrackPoint[DCrackCount].Rect.bottom-1; n++){
								for(int m=DCrackPoint[DCrackCount].Rect.left+1; m<DCrackPoint[DCrackCount].Rect.right-1 ; m++){
									PixelValue = IElement(m,n);
									if(PixelValue > BrokenThresHold) PixelCount++;
								}
							}

							DCrackPoint[DCrackCount].Round = PixelCount;
							DCrackPoint[DCrackCount].P.x    =(float)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterX() - DCrackPoint[DCrackCount].Width/2 ) +LinePosition);
							DCrackPoint[DCrackCount].P.y    =(float)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - DCrackPoint[DCrackCount].Height/2)+(BtmInLine[3].FP0.y)+ImageHeight);
							DCrackPoint[DCrackCount].Width  = (InspectMode)?DCrackPoint[DCrackCount].Width: DCrackPoint[DCrackCount].Width+SideMargin;

							// Merge 위해서 데이터 필요함 
							DCrackPoint[DCrackCount].Rect.top    =(long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - DCrackPoint[DCrackCount].Height/2) +(BtmInLine[3].FP0.y)+ImageHeight);
							DCrackPoint[DCrackCount].Rect.bottom =(long)(DCrackPoint[DCrackCount].Rect.top + DCrackPoint[DCrackCount].Height);
							DCrackCount++;
						}
					}
				}
				BlobCount =0;

				///////////////////////////////////////////////////////////////////////////////////////////////
				//다섯번째 Btm영역의 직선라인 기준 검사 
				// 				if(BtmInLine[4].FP0.x!=0 && BtmInLine[4].FP0.y!=0 && BtmInLine[4].FP1.x!=0 && BtmInLine[4].FP1.y!=0){
				// 					DefectROI.SetPlacement((int)(BtmInLine[4].FP0.x+SideMargin), (int)(BtmInLine[4].FP0.y-FBtmHeight),(BtmInLine[4].FP1.x - BtmInLine[4].FP0.x)-(2*SideMargin), FBtmHeight);
				// 					if((BtmInLine[4].FP0.x+SideMargin) <=0          ||(BtmInLine[4].FP0.y-FBtmHeight)<0            || (BtmInLine[4].FP1.x - BtmInLine[4].FP0.x)-(2*SideMargin)<=0          || FBtmHeight< 0          ) return false;
				// 					if((BtmInLine[4].FP0.x+SideMargin) >=ImageWidth ||(BtmInLine[4].FP0.y-FBtmHeight)>BtmLimitLine || (BtmInLine[4].FP1.x - BtmInLine[4].FP0.x)-(2*SideMargin)>=ImageWidth || FBtmHeight>BtmLimitLine) return false;
				// 					if((BtmInLine[4].FP0.x+SideMargin) + (BtmInLine[4].FP1.x - BtmInLine[4].FP0.x)-(2*SideMargin) >=ImageWidth ||(BtmInLine[4].FP0.y-FBtmHeight)+FBtmHeight>BtmLimitLine                             ) return false;

				if(BtmEdgePoint[8].x!=0 && BtmInLine[4].FP0.y!=0 && BtmEdgePoint[9].x!=0 && BtmInLine[4].FP1.y!=0){
					DefectROI.SetPlacement((int)(BtmEdgePoint[8].x)-50, (int)(BtmInLine[4].FP0.y-FBtmHeight),((BtmEdgePoint[9].x - BtmEdgePoint[8].x)+100), FBtmHeight);
					if((BtmEdgePoint[8].x-50) <=0          ||(BtmInLine[4].FP0.y-FBtmHeight)<0            || ((BtmEdgePoint[9].x - BtmEdgePoint[8].x)+100)<=0          || FBtmHeight< 0          ) return false;
					if((BtmEdgePoint[8].x-50) >=ImageWidth ||(BtmInLine[4].FP0.y-FBtmHeight)>BtmLimitLine || ((BtmEdgePoint[9].x - BtmEdgePoint[8].x)+100)>=ImageWidth || FBtmHeight>BtmLimitLine) return false;
					if((BtmEdgePoint[8].x-50) + ((BtmEdgePoint[9].x - BtmEdgePoint[9].x)-50) >=ImageWidth ||(BtmInLine[4].FP0.y-FBtmHeight)+FBtmHeight>BtmLimitLine                             ) return false;

					//Blob 검사 진행함 
					CodeImageSelection.Clear();
					CodeImageEncoder.Encode(DefectROI,CodeImage);
					CodeImageSelection.Clear();
					CodeImageSelection.AddObjects(CodeImage);
					// Blob 필터링 
					CodeImageSelection.RemoveUsingFloatFeature  (EFeature_BoundingBoxWidth ,3 , FMaxWidth   , EDoubleThresholdMode_Outside);
					CodeImageSelection.RemoveUsingFloatFeature  (EFeature_BoundingBoxHeight,3 , FMaxHeight  , EDoubleThresholdMode_Outside);
					// 					CodeImageSelection.RemoveUsingIntegerFeature(EFeature_BottomLimit      ,FBtmHeight-1   , FBtmHeight+1, EDoubleThresholdMode_Outside);

					BlobCount = CodeImageSelection.GetElementCount();
					CodeImageSelection.Sort(EFeature_LeftLimit ,ESortDirection_Ascending);

					if(BlobCount!=0){
						for(int k=0; k<BlobCount; k++){
							if(CCrackCount>=MAX_DEFECT_POINT) break; 
							CCrackPoint[CCrackCount].Width  =  CodeImageSelection.GetElement(k).GetBoundingBoxWidth() ;
							CCrackPoint[CCrackCount].Height =  CodeImageSelection.GetElement(k).GetBoundingBoxHeight();

							CCrackPoint[CCrackCount].Rect.left   =(long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterX() - CCrackPoint[CCrackCount].Width/2 ) +(BtmEdgePoint[8].x-50));
							CCrackPoint[CCrackCount].Rect.top    =(long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - CCrackPoint[CCrackCount].Height/2) +(BtmInLine[4].FP0.y-FBtmHeight));
							CCrackPoint[CCrackCount].Rect.right  =(long)(CCrackPoint[CCrackCount].Rect.left+ CCrackPoint[CCrackCount].Width );
							CCrackPoint[CCrackCount].Rect.bottom =(long)(CCrackPoint[CCrackCount].Rect.top + CCrackPoint[CCrackCount].Height);
							CCrackPoint[CCrackCount].LineAttach  =(CodeImageSelection.GetElement(k).GetBottomLimit()>(FBtmHeight-5)) ? 1: 0;
							PixelCount = 0;
							PixelValue = 0;

							// 내부 Pixel Data 축출 
							for(int n=CCrackPoint[CCrackCount].Rect.top+1 ; n<CCrackPoint[CCrackCount].Rect.bottom-1; n++){
								for(int m=CCrackPoint[CCrackCount].Rect.left+1; m<CCrackPoint[CCrackCount].Rect.right-1 ; m++){
									PixelValue = IElement(m,n);
									if(PixelValue > BrokenThresHold) PixelCount++;
								}
							}
							CCrackPoint[CCrackCount].Round  =  PixelCount;
							CCrackPoint[CCrackCount].P.x    = (float)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterX() - CCrackPoint[CCrackCount].Width/2 ) +(BtmEdgePoint[8].x-50));
							CCrackPoint[CCrackCount].P.y    = (float)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - CCrackPoint[CCrackCount].Height/2) +(BtmInLine[4].FP0.y-FBtmHeight));

							// Image Rotate 기준 좌표를 다시 Rotate한다 _ Display 목적 
							if(ImgDegree!=0.0f){
								CCrackPoint[CCrackCount].P = Math.OnRotate(CenterPoint, CCrackPoint[CCrackCount].P, (ImgDegree));
							}
							// Image Rotate 기준 좌표를 회전 이후에 ImageHeight값을 더하여 실제 좌표를 산출한다 
							CCrackPoint[CCrackCount].P.y    =(float)(CCrackPoint[CCrackCount].P.y+ImageHeight);

							// Merge 위해서 데이터 필요함 
							CCrackPoint[CCrackCount].Rect.top    =(long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - CCrackPoint[CCrackCount].Height/2) +(BtmInLine[4].FP0.y-FBtmHeight)+ImageHeight);
							CCrackPoint[CCrackCount].Rect.bottom =(long)(CCrackPoint[CCrackCount].Rect.top + CCrackPoint[CCrackCount].Height);
							CCrackCount++;
						}
					}
				}
				BlobCount =0;
				// Notch부 직선영역 Bright Defect 검사 시퀀스 종료  



				/////////////////////////////////////////////////////////////////////////////////////////////
				// RF_MODEL 직선영역 Dark Defect 검사 시퀀스 시작 
				// 				if(C2CirInEdgeCount==0 && C3CirInEdgeCount==0 && C4CirInEdgeCount==0 && C5CirInEdgeCount==0){
				// 
				// 				}
				/////////////////////////////////////////////////////////////////////////////////////////////
				// RF_MODEL 직선영역 Dark Defect 검사 시퀀스 종료 
			}
		}

		////////////////////////////////////////////////////////////////////////////////////////////////
		// 원본 이미지 회전하여 검사 이후 화면에 디스플레이 목적으로 좌표값을 다시 계사한다 
		////////////////////////////////////////////////////////////////////////////////////////////////
		// Cell Size 측정 데이터 넘겨줌(Image 회전 없을경우)
		if(FLBPoint.x!=0.0f && FLBPoint.y!=0.0f && FRBPoint.x!=0.0f && FRBPoint.y!=0.0f){
			LeftEndPos.x     =  FLBPoint.x            ;
			LeftEndPos.y     =  FLBPoint.y+ImageHeight;

			CenterEndPos.x =  BtmOutLine[2].FP0.x + (BtmOutLine[2].FP0.x - BtmOutLine[2].FP1.x)/2; 
			CenterEndPos.y =  (BtmOutLine[2].FP0.y + BtmOutLine[2].FP1.y)/2+ImageHeight; 
		}
		// Notch Cell Height Calc (Image  회전없음)
		if(BtmOutLine[2].FP0.x!=0.0f && BtmOutLine[2].FP0.y!=0.0f && BtmOutLine[2].FP1.x!=0.0f && BtmOutLine[2].FP1.y!=0.0f){
			NotchCenterPos.x =  BtmOutLine[2].FP0.x + (BtmOutLine[2].FP1.x - BtmOutLine[2].FP0.x)/2.0;
			NotchCenterPos.y = (BtmOutLine[2].FP0.y + BtmOutLine[2].FP1.y)/2.0;
			NotchCellSizeHeight = Math.GetLengthFrLineToPoint(FLBPoint, FRBPoint, NotchCenterPos);
		}
		// Notch Cell Width Calc(Image 회전없음)
		////////////////////////////////////////////////////////////////////////////////////////////////
		if(BtmEdgePoint[2].x!=0.0f && BtmEdgePoint[2].y!=0.0f && BtmEdgePoint[7].x!=0.0f && BtmEdgePoint[7].y!=0.0f){
			NotchCellSizeWidth = Math.GetLengthFrPointToPoint((float)BtmEdgePoint[2].x,(float)BtmEdgePoint[2].y, (float)BtmEdgePoint[7].x,(float)BtmEdgePoint[7].y);
		}
		// Center Cell Size Width Calc(Image 회전과 상관없음)
		if(TotalCellSizeWidth!=0.0f && TotalCellSizeCount!=0) CenCellSizeWidth = TotalCellSizeWidth/TotalCellSizeCount;

		if(ImgDegree!=0.0f ){
			FLBPoint    = Math.OnRotate(CenterPoint, FLBPoint     , (ImgDegree));
			FRBPoint    = Math.OnRotate(CenterPoint, FRBPoint     , (ImgDegree));

			// BtmLine 
			Line[3].FP0 = Math.OnRotate(CenterPoint, Line[3].FP0  , (ImgDegree));
			Line[3].FP1 = Math.OnRotate(CenterPoint, Line[3].FP1  , (ImgDegree));

			// LeftOutLine
			LeftOutLine[0].FP0 = Math.OnRotate(CenterPoint, LeftOutLine[0].FP0  , (ImgDegree));
			LeftOutLine[0].FP1 = Math.OnRotate(CenterPoint, LeftOutLine[0].FP1  , (ImgDegree));

			// RightOutLine
			RightOutLine[0].FP0 = Math.OnRotate(CenterPoint, RightOutLine[0].FP0  , (ImgDegree));
			RightOutLine[0].FP1 = Math.OnRotate(CenterPoint, RightOutLine[0].FP1  , (ImgDegree));

			// Cell Size 측정 데이터 넘겨줌(Image 회전 있음)
			if(FLBPoint.x!=0.0f && FLBPoint.y!=0.0f && FRBPoint.x!=0.0f && FRBPoint.y!=0.0f){
				LeftEndPos.x     =  FLBPoint.x            ;
				LeftEndPos.y     =  FLBPoint.y+ImageHeight;
				CenterEndPos.x =  BtmOutLine[2].FP0.x + (BtmOutLine[2].FP0.x - BtmOutLine[2].FP1.x)/2; 
				CenterEndPos.y =  (BtmOutLine[2].FP0.y + BtmOutLine[2].FP1.y)/2+ImageHeight; 
			}

			if(IsCornerBtm){
				FLBBPoint   = Math.OnRotate(CenterPoint, FLBBPoint    , (ImgDegree));
				FLBLPoint   = Math.OnRotate(CenterPoint, FLBLPoint    , (ImgDegree));
				FLBBInPoint = Math.OnRotate(CenterPoint, FLBBInPoint  , (ImgDegree));
				FLBLInPoint = Math.OnRotate(CenterPoint, FLBLInPoint  , (ImgDegree));
				FLBBMeaPoint= Math.OnRotate(CenterPoint, FLBBMeaPoint , (ImgDegree));
				FLBLMeaPoint= Math.OnRotate(CenterPoint, FLBLMeaPoint , (ImgDegree));

				FRBBPoint   = Math.OnRotate(CenterPoint, FRBBPoint    , (ImgDegree));
				FRBRPoint   = Math.OnRotate(CenterPoint, FRBRPoint    , (ImgDegree));
				FRBBInPoint = Math.OnRotate(CenterPoint, FRBBInPoint  , (ImgDegree));
				FRBRInPoint = Math.OnRotate(CenterPoint, FRBRInPoint  , (ImgDegree));
				FRBBMeaPoint= Math.OnRotate(CenterPoint, FRBBMeaPoint , (ImgDegree));
				FRBRMeaPoint= Math.OnRotate(CenterPoint, FRBRMeaPoint , (ImgDegree));

				// Corner Defect 좌표도 각도 적용하여 변경해야함 
				if(C3Count!=0){
					for(int k=0; k<C3Count; k++){
						// Fram기준 Y좌표값으로 원복한다 
						C3DefectPoint[k].P.y = C3DefectPoint[k].P.y - ImageHeight;
						if(C3DefectPoint[k].P.y>0) {
							C3DefectPoint[k].P   = Math.OnRotate(CenterPoint,C3DefectPoint[k].P,(ImgDegree)); 
							C3DefectPoint[k].P.y = C3DefectPoint[k].P.y + ImageHeight;
						}
						else {
							C3DefectPoint[k].P.y = C3DefectPoint[k].P.y + ImageHeight;
						}
					}
				}

				if(C4Count!=0){
					for(int k=0; k<C4Count; k++){
						// Fram기준 Y좌표값으로 원복한다 
						C4DefectPoint[k].P.y = C4DefectPoint[k].P.y - ImageHeight;
						if(C4DefectPoint[k].P.y>0) {
							C4DefectPoint[k].P   = Math.OnRotate(CenterPoint,C4DefectPoint[k].P,(ImgDegree)); 
							C4DefectPoint[k].P.y = C4DefectPoint[k].P.y + ImageHeight;
						}
						else {
							C4DefectPoint[k].P.y = C4DefectPoint[k].P.y + ImageHeight;
						}
					}
				}
				// GrindMarkPoint Rotate 
				if(IsMarkBtm){
					for(int k=0; k<19; k++){
						LtPos.x =0.0f, LtPos.y=0.0f,RbPos.x=0.0f,RbPos.y=0.0f;
						if(GrindMarkRect[k].left==0 || GrindMarkRect[k].top==0 || GrindMarkRect[k].right==0 || GrindMarkRect[k].bottom==0 ) continue;

						LtPos.x = (float)GrindMarkRect[k].left  ;
						LtPos.y = (float)GrindMarkRect[k].top   ;
						RbPos.x = (float)GrindMarkRect[k].right ;
						RbPos.y = (float)GrindMarkRect[k].bottom;
						LtPos = Math.OnRotate(CenterPoint, LtPos,ImgDegree);
						RbPos = Math.OnRotate(CenterPoint, RbPos,ImgDegree);

						GrindMarkRect[k].left   = (long)LtPos.x;
						GrindMarkRect[k].top    = (long)LtPos.y;
						GrindMarkRect[k].right  = (long)RbPos.x;
						GrindMarkRect[k].bottom = (long)RbPos.y;
						if(GrindMarkPoint[k].x!=0.0f && GrindMarkPoint[k].y!=0.0f) {
							GrindMarkPoint[k] = Math.OnRotate(CenterPoint, GrindMarkPoint[k],ImgDegree);
						}
					}
				}
			}
			else if(IsCircleBtm){
				// TrackLine 교차점 원본 이미지 기준 회전

				if(FInspectMode==Insp_Track){
					// LeftTrackLine
					LeftTrackLine[0].FP0 = Math.OnRotate(CenterPoint, LeftTrackLine[0].FP0  , (ImgDegree));
					LeftTrackLine[0].FP1 = Math.OnRotate(CenterPoint, LeftTrackLine[0].FP1  , (ImgDegree));

					// RightTrackLine
					RightTrackLine[0].FP0 = Math.OnRotate(CenterPoint, RightTrackLine[0].FP0  , (ImgDegree));
					RightTrackLine[0].FP1 = Math.OnRotate(CenterPoint, RightTrackLine[0].FP1  , (ImgDegree));

					// BtmTrackLine
					BtmTrackLine[0].FP0 = Math.OnRotate(CenterPoint, BtmTrackLine[0].FP0  , (ImgDegree));
					BtmTrackLine[0].FP1 = Math.OnRotate(CenterPoint, BtmTrackLine[0].FP1  , (ImgDegree));

					FTRLBPoint    = Math.OnRotate(CenterPoint, FTRLBPoint     , (ImgDegree));
					FTRRBPoint    = Math.OnRotate(CenterPoint, FTRRBPoint     , (ImgDegree));
				}


				// Btm Line Rotate 
				for(int k=0; k<MAX_BTM_COUNT; k++){
					if(BtmInLine[k].FP0.x ==0.0f || BtmInLine[k].FP0.y ==0.0f || BtmInLine[k].FP1.x ==0.0f || BtmInLine[k].FP1.y ==0.0f) continue;
					if(BtmOutLine[k].FP0.x==0.0f || BtmOutLine[k].FP0.y==0.0f || BtmOutLine[k].FP1.x==0.0f || BtmOutLine[k].FP1.y==0.0f) continue;
					BtmInLine   [k].FP0 = Math.OnRotate(CenterPoint, BtmInLine   [k].FP0,  (ImgDegree));
					BtmInLine   [k].FP1 = Math.OnRotate(CenterPoint, BtmInLine   [k].FP1,  (ImgDegree));
					BtmOutLine  [k].FP0 = Math.OnRotate(CenterPoint, BtmOutLine  [k].FP0,  (ImgDegree));
					BtmOutLine  [k].FP1 = Math.OnRotate(CenterPoint, BtmOutLine  [k].FP1,  (ImgDegree));

					if(FInspectMode==Insp_Track){
						if(BtmStandLine[k].FP0.x==0.0f || BtmStandLine[k].FP0.y==0.0f || BtmStandLine[k].FP1.x==0.0f || BtmStandLine[k].FP1.y==0.0f) continue;
						BtmStandLine[k].FP0 = Math.OnRotate(CenterPoint, BtmStandLine[k].FP0,  (ImgDegree));
						BtmStandLine[k].FP1 = Math.OnRotate(CenterPoint, BtmStandLine[k].FP1,  (ImgDegree));
					}
				}

				// Notch Cell Dis 측정 
				if(BtmOutLine[2].FP0.x!=0.0f && BtmOutLine[2].FP0.y!=0.0f && BtmOutLine[2].FP1.x!=0.0f && BtmOutLine[2].FP1.y!=0.0f){
					NotchCenterPos.x =  BtmOutLine[2].FP0.x + (BtmOutLine[2].FP1.x - BtmOutLine[2].FP0.x)/2.0;
					NotchCenterPos.y = (BtmOutLine[2].FP0.y + BtmOutLine[2].FP1.y)/2.0;
					NotchCellSizeHeight = Math.GetLengthFrLineToPoint(FLBPoint, FRBPoint, NotchCenterPos);
				}

				// Circle Defect Data 
				// Dark Defect Data 
				////////////////////////////////////////////////////////////////////////////////////////////////
				if(C1CirDeftectCnt!=0){
					for(int k=0; k<C1CirDeftectCnt; k++){
						C1CirDefectPoint[k].P.y = C1CirDefectPoint[k].P.y - ImageHeight;
						if(C1CirDefectPoint[k].P.y>0) {
							C1CirDefectPoint[k].P   = Math.OnRotate(CenterPoint,C1CirDefectPoint[k].P,(ImgDegree)); 
							C1CirDefectPoint[k].P.y = C1CirDefectPoint[k].P.y + ImageHeight;
						}
						else {
							C1CirDefectPoint[k].P.y = C1CirDefectPoint[k].P.y + ImageHeight;
						}
					}
				}

				if(C2CirDeftectCnt!=0){
					for(int k=0; k<C2CirDeftectCnt; k++){
						C2CirDefectPoint[k].P.y = C2CirDefectPoint[k].P.y - ImageHeight;
						if(C2CirDefectPoint[k].P.y>0) {
							C2CirDefectPoint[k].P   = Math.OnRotate(CenterPoint,C2CirDefectPoint[k].P,(ImgDegree)); 
							C2CirDefectPoint[k].P.y = C2CirDefectPoint[k].P.y + ImageHeight;
						}
						else {
							C2CirDefectPoint[k].P.y = C2CirDefectPoint[k].P.y + ImageHeight;
						}
					}
				}

				if(C3CirDeftectCnt!=0){
					for(int k=0; k<C3CirDeftectCnt; k++){
						C3CirDefectPoint[k].P.y = C3CirDefectPoint[k].P.y - ImageHeight;
						if(C3CirDefectPoint[k].P.y>0) {
							C3CirDefectPoint[k].P   = Math.OnRotate(CenterPoint,C3CirDefectPoint[k].P,(ImgDegree)); 
							C3CirDefectPoint[k].P.y = C3CirDefectPoint[k].P.y + ImageHeight;
						}
						else {
							C3CirDefectPoint[k].P.y = C3CirDefectPoint[k].P.y + ImageHeight;
						}
					}
				}

				if(C4CirDeftectCnt!=0){
					for(int k=0; k<C4CirDeftectCnt; k++){
						C4CirDefectPoint[k].P.y = C4CirDefectPoint[k].P.y - ImageHeight;
						if(C4CirDefectPoint[k].P.y>0) {
							C4CirDefectPoint[k].P   = Math.OnRotate(CenterPoint,C4CirDefectPoint[k].P,(ImgDegree)); 
							C4CirDefectPoint[k].P.y = C4CirDefectPoint[k].P.y + ImageHeight;
						}
						else {
							C4CirDefectPoint[k].P.y = C4CirDefectPoint[k].P.y + ImageHeight;
						}
					}
				}


				if(C5CirDeftectCnt!=0){
					for(int k=0; k<C5CirDeftectCnt; k++){
						C5CirDefectPoint[k].P.y = C5CirDefectPoint[k].P.y - ImageHeight;
						if(C5CirDefectPoint[k].P.y>0) {
							C5CirDefectPoint[k].P   = Math.OnRotate(CenterPoint,C5CirDefectPoint[k].P,(ImgDegree)); 
							C5CirDefectPoint[k].P.y = C5CirDefectPoint[k].P.y + ImageHeight;
						}
						else {
							C5CirDefectPoint[k].P.y = C5CirDefectPoint[k].P.y + ImageHeight;
						}
					}
				}


				if(C6CirDeftectCnt!=0){
					for(int k=0; k<C6CirDeftectCnt; k++){
						C6CirDefectPoint[k].P.y = C6CirDefectPoint[k].P.y - ImageHeight;
						if(C6CirDefectPoint[k].P.y>0) {
							C6CirDefectPoint[k].P   = Math.OnRotate(CenterPoint,C6CirDefectPoint[k].P,(ImgDegree)); 
							C6CirDefectPoint[k].P.y = C6CirDefectPoint[k].P.y + ImageHeight;
						}
						else {
							C6CirDefectPoint[k].P.y = C6CirDefectPoint[k].P.y + ImageHeight;
						}
					}
				}

				if(Btm3CirDefectCnt!=0){
					for(int k=0; k<Btm3CirDefectCnt; k++){
						Btm3CirDefectPoint[k].P.y = Btm3CirDefectPoint[k].P.y - ImageHeight;
						if(Btm3CirDefectPoint[k].P.y>0) {
							Btm3CirDefectPoint[k].P   = Math.OnRotate(CenterPoint,Btm3CirDefectPoint[k].P,(ImgDegree)); 
							Btm3CirDefectPoint[k].P.y = Btm3CirDefectPoint[k].P.y + ImageHeight;
						}
						else {
							Btm3CirDefectPoint[k].P.y = Btm3CirDefectPoint[k].P.y + ImageHeight;
						}
					}
				}

				///////////////////////////////////////////////////////////////////////////////////////////////////

				// Circle Defect Data 
				// Bright Defect Data e
				////////////////////////////////////////////////////////////////////////////////////////////////
				if(C1CirCrackCnt!=0){
					for(int k=0; k<C1CirCrackCnt; k++){
						C1CirCrackPoint[k].P.y = C1CirCrackPoint[k].P.y - ImageHeight;
						if(C1CirCrackPoint[k].P.y>0) {
							C1CirCrackPoint[k].P   = Math.OnRotate(CenterPoint,C1CirCrackPoint[k].P,(ImgDegree)); 
							C1CirCrackPoint[k].P.y = C1CirCrackPoint[k].P.y + ImageHeight;
						}
						else {
							C1CirCrackPoint[k].P.y = C1CirCrackPoint[k].P.y + ImageHeight;
						}
					}
				}

				if(C2CirCrackCnt!=0){
					for(int k=0; k<C2CirCrackCnt; k++){
						C2CirCrackPoint[k].P.y = C2CirCrackPoint[k].P.y - ImageHeight;
						if(C2CirCrackPoint[k].P.y>0) {
							C2CirCrackPoint[k].P   = Math.OnRotate(CenterPoint,C2CirCrackPoint[k].P,(ImgDegree)); 
							C2CirCrackPoint[k].P.y = C2CirCrackPoint[k].P.y + ImageHeight;
						}
						else {
							C2CirCrackPoint[k].P.y = C2CirCrackPoint[k].P.y + ImageHeight;
						}
					}
				}

				if(C3CirCrackCnt!=0){
					for(int k=0; k<C3CirCrackCnt; k++){
						C3CirCrackPoint[k].P.y = C3CirCrackPoint[k].P.y - ImageHeight;
						if(C3CirCrackPoint[k].P.y>0) {
							C3CirCrackPoint[k].P   = Math.OnRotate(CenterPoint,C3CirCrackPoint[k].P,(ImgDegree)); 
							C3CirCrackPoint[k].P.y = C3CirCrackPoint[k].P.y + ImageHeight;
						}
						else {
							C3CirCrackPoint[k].P.y = C3CirCrackPoint[k].P.y + ImageHeight;
						}
					}
				}

				if(C4CirCrackCnt!=0){
					for(int k=0; k<C4CirCrackCnt; k++){
						C4CirCrackPoint[k].P.y = C4CirCrackPoint[k].P.y - ImageHeight;
						if(C4CirCrackPoint[k].P.y>0) {
							C4CirCrackPoint[k].P   = Math.OnRotate(CenterPoint,C4CirCrackPoint[k].P,(ImgDegree)); 
							C4CirCrackPoint[k].P.y = C4CirCrackPoint[k].P.y + ImageHeight;
						}
						else {
							C4CirCrackPoint[k].P.y = C4CirCrackPoint[k].P.y + ImageHeight;
						}
					}
				}

				if(C5CirCrackCnt!=0){
					for(int k=0; k<C5CirCrackCnt; k++){
						C5CirCrackPoint[k].P.y = C5CirCrackPoint[k].P.y - ImageHeight;
						if(C5CirCrackPoint[k].P.y>0) {
							C5CirCrackPoint[k].P   = Math.OnRotate(CenterPoint,C5CirCrackPoint[k].P,(ImgDegree)); 
							C5CirCrackPoint[k].P.y = C5CirCrackPoint[k].P.y + ImageHeight;
						}
						else {
							C5CirCrackPoint[k].P.y = C5CirCrackPoint[k].P.y + ImageHeight;
						}
					}
				}

				if(C6CirCrackCnt!=0){
					for(int k=0; k<C6CirCrackCnt; k++){
						C6CirCrackPoint[k].P.y = C6CirCrackPoint[k].P.y - ImageHeight;
						if(C6CirCrackPoint[k].P.y>0) {
							C6CirCrackPoint[k].P   = Math.OnRotate(CenterPoint,C6CirCrackPoint[k].P,(ImgDegree)); 
							C6CirCrackPoint[k].P.y = C6CirCrackPoint[k].P.y + ImageHeight;
						}
						else {
							C6CirCrackPoint[k].P.y = C6CirCrackPoint[k].P.y + ImageHeight;
						}
					}
				}

				if(Btm3CirCrackCnt!=0){
					for(int k=0; k<Btm3CirCrackCnt; k++){
						Btm3CirCrackPoint[k].P.y = Btm3CirCrackPoint[k].P.y - ImageHeight;
						if(Btm3CirCrackPoint[k].P.y>0) {
							Btm3CirCrackPoint[k].P   = Math.OnRotate(CenterPoint,Btm3CirCrackPoint[k].P,(ImgDegree)); 
							Btm3CirCrackPoint[k].P.y = Btm3CirCrackPoint[k].P.y + ImageHeight;
						}
						else {
							Btm3CirCrackPoint[k].P.y = Btm3CirCrackPoint[k].P.y + ImageHeight;
						}
					}
				}

				/////////////////////////////////////////////////////////////////////////////////////////////////////////

				// C1 Circle Edge Point Rotate 
				if(C1CirStandEdgeCount!=0){
					for(int k=0; k<C1CirStandEdgeCount; k++){
						if(C1CirStandPoint[k].x==0.0f || C1CirStandPoint[k].y==0.0f) continue;
						C1CirStandPoint[k] = Math.OnRotate(CenterPoint, C1CirStandPoint[k], ImgDegree);
					}
				}
				if(C1CirInEdgeCount!=0){
					for(int k=0; k<C1CirInEdgeCount; k++){
						if(C1CirInPoint[k].x==0.0f || C1CirInPoint[k].y==0.0f) continue;
						C1CirInPoint[k] = Math.OnRotate(CenterPoint, C1CirInPoint[k], ImgDegree);
					}
				}
				if(C1CirOutEdgeCount!=0){
					for(int k=0; k<C1CirOutEdgeCount; k++){
						if(C1CirOutPoint[k].x==0.0f || C1CirOutPoint[k].y==0.0f) continue;
						C1CirOutPoint[k] = Math.OnRotate(CenterPoint, C1CirOutPoint[k], ImgDegree);
					}
				}
				if(C1CirCenter     .x!=0.0f && C1CirCenter     .y!=0.0f) C1CirCenter        = Math.OnRotate(CenterPoint, C1CirCenter         , (ImgDegree)); // 외곽 교차점 기준  
				if(RealC1CirCenter .x!=0.0f && RealC1CirCenter .y!=0.0f) RealC1CirCenter    = Math.OnRotate(CenterPoint, RealC1CirCenter     , (ImgDegree)); // Euresys 
				if(CircleFit1Center.x!=0.0f && CircleFit1Center.y!=0.0f) CircleFit1Center   = Math.OnRotate(CenterPoint, CircleFit1Center    , (ImgDegree)); // FAVION

				// C2 Circle Edge Point Rotate 
				if(C2CirStandEdgeCount!=0){
					for(int k=0; k<C2CirStandEdgeCount; k++){
						if(C2CirStandPoint[k].x==0.0f || C2CirStandPoint[k].y==0.0f) continue;
						C2CirStandPoint[k] = Math.OnRotate(CenterPoint, C2CirStandPoint[k], ImgDegree);
					}
				}
				if(C2CirInEdgeCount!=0){
					for(int k=0; k<C2CirInEdgeCount; k++){
						if(C2CirInPoint[k].x==0.0f || C2CirInPoint[k].y==0.0f) continue;
						C2CirInPoint[k] = Math.OnRotate(CenterPoint, C2CirInPoint[k], ImgDegree);
					}
				}
				if(C2CirOutEdgeCount!=0){
					for(int k=0; k<C2CirOutEdgeCount; k++){
						if(C2CirOutPoint[k].x==0.0f || C2CirOutPoint[k].y==0.0f) continue;
						C2CirOutPoint[k] = Math.OnRotate(CenterPoint, C2CirOutPoint[k], ImgDegree);
					}
				}
				if(C2CirCenter     .x!=0.0f && C2CirCenter     .y!=0.0f) C2CirCenter        = Math.OnRotate(CenterPoint, C2CirCenter         , (ImgDegree)); // 외곽 교차점 기준  
				if(RealC2CirCenter .x!=0.0f && RealC2CirCenter .y!=0.0f) RealC2CirCenter    = Math.OnRotate(CenterPoint, RealC2CirCenter     , (ImgDegree));
				if(CircleFit2Center.x!=0.0f && CircleFit2Center.y!=0.0f) CircleFit2Center   = Math.OnRotate(CenterPoint, CircleFit2Center    , (ImgDegree));

				// C3 Circle Edge Point Rotate 
				if(C3CirStandEdgeCount!=0){
					for(int k=0; k<C3CirStandEdgeCount; k++){
						if(C3CirStandPoint[k].x==0.0f || C3CirStandPoint[k].y==0.0f) continue;
						C3CirStandPoint[k] = Math.OnRotate(CenterPoint, C3CirStandPoint[k], ImgDegree);
					}
				}
				if(C3CirInEdgeCount!=0){
					for(int k=0; k<C3CirInEdgeCount; k++){
						if(C3CirInPoint[k].x==0.0f || C3CirInPoint[k].y==0.0f) continue;
						C3CirInPoint[k] = Math.OnRotate(CenterPoint, C3CirInPoint[k], ImgDegree);
					}
				}
				if(C3CirOutEdgeCount!=0){
					for(int k=0; k<C3CirOutEdgeCount; k++){
						if(C3CirOutPoint[k].x==0.0f || C3CirOutPoint[k].y==0.0f) continue;
						C3CirOutPoint[k] = Math.OnRotate(CenterPoint, C3CirOutPoint[k], ImgDegree);
					}
				}
				if(C3CirCenter     .x!=0.0f && C3CirCenter     .y!=0.0f) C3CirCenter        = Math.OnRotate(CenterPoint, C3CirCenter         , (ImgDegree)); // 외곽 교차점 기준  
				if(RealC3CirCenter .x!=0.0f && RealC3CirCenter .y!=0.0f) RealC3CirCenter    = Math.OnRotate(CenterPoint, RealC3CirCenter     , (ImgDegree));
				if(CircleFit3Center.x!=0.0f && CircleFit3Center.y!=0.0f) CircleFit3Center   = Math.OnRotate(CenterPoint, CircleFit3Center    , (ImgDegree));

				// C4 Circle Edge Point Rotate 
				if(C4CirStandEdgeCount!=0){
					for(int k=0; k<C4CirStandEdgeCount; k++){
						if(C4CirStandPoint[k].x==0.0f || C4CirStandPoint[k].y==0.0f) continue;
						C4CirStandPoint[k] = Math.OnRotate(CenterPoint, C4CirStandPoint[k], ImgDegree);
					}
				}
				if(C4CirInEdgeCount!=0){
					for(int k=0; k<C4CirInEdgeCount; k++){
						if(C4CirInPoint[k].x==0.0f || C4CirInPoint[k].y==0.0f) continue;
						C4CirInPoint[k] = Math.OnRotate(CenterPoint, C4CirInPoint[k], ImgDegree);
					}
				}
				if(C4CirOutEdgeCount!=0){
					for(int k=0; k<C4CirOutEdgeCount; k++){
						if(C4CirOutPoint[k].x==0.0f || C4CirOutPoint[k].y==0.0f) continue;
						C4CirOutPoint[k] = Math.OnRotate(CenterPoint, C4CirOutPoint[k], ImgDegree);
					}
				}
				if(C4CirCenter     .x!=0.0f && C4CirCenter     .y!=0.0f) C4CirCenter        = Math.OnRotate(CenterPoint, C4CirCenter         , (ImgDegree)); // 외곽 교차점 기준  
				if(RealC4CirCenter .x!=0.0f && RealC4CirCenter .y!=0.0f) RealC4CirCenter    = Math.OnRotate(CenterPoint, RealC4CirCenter     , (ImgDegree));
				if(CircleFit4Center.x!=0.0f && CircleFit4Center.y!=0.0f) CircleFit4Center   = Math.OnRotate(CenterPoint, CircleFit4Center    , (ImgDegree));

				// C5 Circle Edge Point Rotate 
				if(C5CirStandEdgeCount!=0){
					for(int k=0; k<C5CirStandEdgeCount; k++){
						if(C5CirStandPoint[k].x==0.0f || C5CirStandPoint[k].y==0.0f) continue;
						C5CirStandPoint[k] = Math.OnRotate(CenterPoint, C5CirStandPoint[k], ImgDegree);
					}
				}
				if(C5CirInEdgeCount!=0){
					for(int k=0; k<C5CirInEdgeCount; k++){
						if(C5CirInPoint[k].x==0.0f || C5CirInPoint[k].y==0.0f) continue;
						C5CirInPoint[k] = Math.OnRotate(CenterPoint, C5CirInPoint[k], ImgDegree);
					}
				}
				if(C5CirOutEdgeCount!=0){
					for(int k=0; k<C5CirOutEdgeCount; k++){
						if(C5CirOutPoint[k].x==0.0f || C5CirOutPoint[k].y==0.0f) continue;
						C5CirOutPoint[k] = Math.OnRotate(CenterPoint, C5CirOutPoint[k], ImgDegree);
					}
				}
				if(C5CirCenter     .x!=0.0f && C5CirCenter     .y!=0.0f) C5CirCenter        = Math.OnRotate(CenterPoint, C5CirCenter         , (ImgDegree)); // 외곽 교차점 기준  
				if(RealC5CirCenter .x!=0.0f && RealC5CirCenter .y!=0.0f) RealC5CirCenter    = Math.OnRotate(CenterPoint, RealC5CirCenter     , (ImgDegree));
				if(CircleFit5Center.x!=0.0f && CircleFit5Center.y!=0.0f) CircleFit5Center   = Math.OnRotate(CenterPoint, CircleFit5Center    , (ImgDegree));

				// C6 Circle Edge Point Rotate 
				if(C6CirStandEdgeCount!=0){
					for(int k=0; k<C6CirStandEdgeCount; k++){
						if(C6CirStandPoint[k].x==0.0f || C6CirStandPoint[k].y==0.0f) continue;
						C6CirStandPoint[k] = Math.OnRotate(CenterPoint, C6CirStandPoint[k], ImgDegree);
					}
				}
				if(C6CirInEdgeCount!=0){
					for(int k=0; k<C6CirInEdgeCount; k++){
						if(C6CirInPoint[k].x==0.0f || C6CirInPoint[k].y==0.0f) continue;
						C6CirInPoint[k] = Math.OnRotate(CenterPoint, C6CirInPoint[k], ImgDegree);
					}
				}
				if(C6CirOutEdgeCount!=0){
					for(int k=0; k<C6CirOutEdgeCount; k++){
						if(C6CirOutPoint[k].x==0.0f || C6CirOutPoint[k].y==0.0f) continue;
						C6CirOutPoint[k] = Math.OnRotate(CenterPoint, C6CirOutPoint[k], ImgDegree);
					}
				}
				if(C6CirCenter     .x!=0.0f && C6CirCenter     .y!=0.0f) C6CirCenter        = Math.OnRotate(CenterPoint, C6CirCenter         , (ImgDegree)); // 외곽 교차점 기준  
				if(RealC6CirCenter .x!=0.0f && RealC6CirCenter .y!=0.0f) RealC6CirCenter    = Math.OnRotate(CenterPoint, RealC6CirCenter     , (ImgDegree));
				if(CircleFit6Center.x!=0.0f && CircleFit6Center.y!=0.0f) CircleFit6Center   = Math.OnRotate(CenterPoint, CircleFit6Center    , (ImgDegree));

				// Narrow Trench Btm3 Data Rotate  
				if(Btm3InEdgeCount!=0){
					for(int k=0; k<Btm3InEdgeCount; k++){
						if(Btm3InPoint[k].x==0.0f || Btm3InPoint[k].y==0.0f) continue;
						Btm3InPoint[k] = Math.OnRotate(CenterPoint, Btm3InPoint[k], ImgDegree);
					}
				}
				if(Btm3OutEdgeCount!=0){
					for(int k=0; k<Btm3OutEdgeCount; k++){
						if(Btm3OutPoint[k].x==0.0f || Btm3OutPoint[k].y==0.0f) continue;
						Btm3OutPoint[k] = Math.OnRotate(CenterPoint, Btm3OutPoint[k], ImgDegree);
					}
				}
				if(CircleFitBtm3Center.x!=0.0f && CircleFitBtm3Center.y!=0.0f) CircleFitBtm3Center   = Math.OnRotate(CenterPoint, CircleFitBtm3Center    , (ImgDegree)); // FAVION


				// Grind Mark Pos 각도기준 회전해야함 
				if((FInspectMode==Insp_Mark || FInspectMode==Insp_Polygon) && IsMarkBtm){
					for(int k=0; k<19; k++){
						LtPos.x =0.0f, LtPos.y=0.0f,RbPos.x=0.0f,RbPos.y=0.0f;
						if(GrindMarkRect[k].left==0 || GrindMarkRect[k].top==0 || GrindMarkRect[k].right==0 || GrindMarkRect[k].bottom==0 ) continue;

						LtPos.x = (float)GrindMarkRect[k].left  ;
						LtPos.y = (float)GrindMarkRect[k].top   ;
						RbPos.x = (float)GrindMarkRect[k].right ;
						RbPos.y = (float)GrindMarkRect[k].bottom;
						LtPos = Math.OnRotate(CenterPoint, LtPos,ImgDegree);
						RbPos = Math.OnRotate(CenterPoint, RbPos,ImgDegree);

						GrindMarkRect[k].left   = (long)LtPos.x;
						GrindMarkRect[k].top    = (long)LtPos.y;
						GrindMarkRect[k].right  = (long)RbPos.x;
						GrindMarkRect[k].bottom = (long)RbPos.y;
						if(GrindMarkPoint[k].x!=0.0f && GrindMarkPoint[k].y!=0.0f) {
							GrindMarkPoint[k] = Math.OnRotate(CenterPoint, GrindMarkPoint[k],ImgDegree);
						}
					}

					// Notch ROI Rect Rotate 
					for(int k=0; k<6; k++){
						LtPos.x =0.0f, LtPos.y=0.0f,RbPos.x=0.0f,RbPos.y=0.0f;
						if(NotchPolyRect[k].left==0 || NotchPolyRect[k].top==0 || NotchPolyRect[k].right==0 || NotchPolyRect[k].bottom==0 ) continue;

						LtPos.x = (float)NotchPolyRect[k].left  ;
						LtPos.y = (float)NotchPolyRect[k].top   ;
						RbPos.x = (float)NotchPolyRect[k].right ;
						RbPos.y = (float)NotchPolyRect[k].bottom;
						LtPos = Math.OnRotate(CenterPoint, LtPos,ImgDegree);
						RbPos = Math.OnRotate(CenterPoint, RbPos,ImgDegree);

						NotchPolyRect[k].left   = (long)LtPos.x;
						NotchPolyRect[k].top    = (long)LtPos.y;
						NotchPolyRect[k].right  = (long)RbPos.x;
						NotchPolyRect[k].bottom = (long)RbPos.y;
					}
				}
			}
		}
		////////////////////////////////////////////////////////////////////////////////////////////////
		DefectPointCount = A1CirDeftectCnt+A2CirDeftectCnt+ACount+BCount+CCount+DCount+C1CirDeftectCnt+C2CirDeftectCnt+C3CirDeftectCnt+C4CirDeftectCnt+C5CirDeftectCnt+
			C6CirDeftectCnt+ABurrCount+BBurrCount+CBurrCount+DBurrCount+ACrackCount+BCrackCount+CCrackCount+DCrackCount+A1CirCrackCnt+A2CirCrackCnt+
			C1CirCrackCnt+C2CirCrackCnt+C3CirCrackCnt+C4CirCrackCnt+C5CirCrackCnt+C6CirCrackCnt+Btm3CirCrackCnt+Btm3CirDefectCnt; // 전체 불량개수 계산

		// BTM 영역 검사 종료 후 Cell Size 측정 
		// 검사 종료 후 Cell Size 측정함 
		if(LeftStaPos.x!=0.0f && LeftStaPos.y!=0.0f && LeftEndPos.x!=0.0f && LeftEndPos.y!=0.0f){
			LeftCellSizeHeight = Math.GetLengthFrPointToPoint(LeftStaPos, LeftEndPos);
		}
		if(CenterStaPos.x!=0.0f && CenterStaPos.y!=0.0f && CenterEndPos.x!=0.0f && CenterEndPos.y!=0.0f){
			CenCellSizeHeight  = Math.GetLengthFrPointToPoint(CenterStaPos, CenterEndPos);
		}

		// Defect Blob Merge
		///////////////////////////////////////////////////////////////////////////////////////////////
		// Circle_1 불량 Merge 기능 
		if(C1CirDeftectCnt!=0){
			bool IsxMg=false, IsyMg=false, IsInMg=false;
			CRect r1, r2;
			int sort =0;
			int tmpDDefectCount = C1CirDeftectCnt;

			for(int k=0; k<tmpDDefectCount; k++){
				if(C1CirDefectPoint[k].Rect.left==0 && C1CirDefectPoint[k].Rect.top==0 && C1CirDefectPoint[k].Rect.right==0 && C1CirDefectPoint[k].Rect.bottom==0) continue;

				for(int l=k+1; l<k+MgCount; l++ ){
					IsxMg = false; IsyMg = false;
					if(l>(tmpDDefectCount-1)) break;
					if(C1CirDefectPoint[l].Rect.left==0 && C1CirDefectPoint[l].Rect.top==0 && C1CirDefectPoint[k].Rect.right==0 && C1CirDefectPoint[k].Rect.bottom==0) continue;

					r1 = C1CirDefectPoint[k].Rect;
					r2 = C1CirDefectPoint[l].Rect; 

					register int HorDist   = abs((r1.left < r2.left) ?  r2.left - r1.right  : r1.left - r2.right );
					register int VerDist   = abs((r1.top  < r2.top ) ?  r2.top  - r1.bottom : r1.top  - r2.bottom);
					IsInMg    = ((r1.left<=r2.left) && (r1.top<r2.top) && (r1.bottom>r2.bottom) && (r1.right >r2.right))? true: false;

					if(HorDist>xMerge && VerDist>yMerge && !IsInMg ) continue;

					IsxMg = (HorDist<xMerge) ? true: false;
					IsyMg = (VerDist<yMerge) ? true: false;

					if((IsxMg && IsyMg) || IsInMg){
						C1CirDefectPoint[k].Round    += C1CirDefectPoint[l].Round;
						C1CirDefectPoint[k].Rect      = OnMerge(C1CirDefectPoint[k].Rect, C1CirDefectPoint[l].Rect);
						C1CirDefectPoint[k].Width     = C1CirDefectPoint[k].Rect.right  - C1CirDefectPoint[k].Rect.left;
						C1CirDefectPoint[k].Height    = C1CirDefectPoint[k].Rect.bottom - C1CirDefectPoint[k].Rect.top ;
						C1CirDefectPoint[k].Hor_Dis   = C1CirDefectPoint[k].Width ; 
						C1CirDefectPoint[k].Ver_Dis   = C1CirDefectPoint[k].Height;
						C1CirDefectPoint[k].P.x       = (float)(C1CirDefectPoint[k].Rect.left);
						C1CirDefectPoint[k].P.y       = (float)(C1CirDefectPoint[k].Rect.top ); 
						C1CirDefectPoint[l].Rect.left = C1CirDefectPoint[l].Rect.top = C1CirDefectPoint[l].Rect.right = C1CirDefectPoint[l].Rect.bottom =0;
						C1CirDeftectCnt--;
						k=-1;
						break;
					}

				}

			}
			for(int j=0; j<tmpDDefectCount; j++){
				if(C1CirDefectPoint[j].Rect.left==0 && C1CirDefectPoint[j].Rect.top==0 && C1CirDefectPoint[j].Rect.right==0 && C1CirDefectPoint[j].Rect.bottom==0) continue;
				C1CirDefectPoint[sort] = C1CirDefectPoint[j];
				sort++;
			}
		}
		////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

		// Circle_2 불량 Merge 기능 
		if(C2CirDeftectCnt!=0){
			bool IsxMg=false, IsyMg=false, IsInMg=false;
			CRect r1, r2;
			int sort =0;
			int tmpDDefectCount = C2CirDeftectCnt;

			for(int k=0; k<tmpDDefectCount; k++){
				if(C2CirDefectPoint[k].Rect.left==0 && C2CirDefectPoint[k].Rect.top==0 && C2CirDefectPoint[k].Rect.right==0 && C2CirDefectPoint[k].Rect.bottom==0) continue;

				for(int l=k+1; l<k+MgCount; l++ ){
					IsxMg = false; IsyMg = false;
					if(l>(tmpDDefectCount-1)) break;
					if(C2CirDefectPoint[l].Rect.left==0 && C2CirDefectPoint[l].Rect.top==0 && C2CirDefectPoint[k].Rect.right==0 && C2CirDefectPoint[k].Rect.bottom==0) continue;

					r1 = C2CirDefectPoint[k].Rect;
					r2 = C2CirDefectPoint[l].Rect; 

					register int HorDist   = abs((r1.left < r2.left) ?  r2.left - r1.right  : r1.left - r2.right );
					register int VerDist   = abs((r1.top  < r2.top ) ?  r2.top  - r1.bottom : r1.top  - r2.bottom);
					IsInMg    = ((r1.left<=r2.left) && (r1.top<r2.top) && (r1.bottom>r2.bottom) && (r1.right >r2.right))? true: false;

					if(HorDist>xMerge && VerDist>yMerge && !IsInMg ) continue;

					IsxMg = (HorDist<xMerge) ? true: false;
					IsyMg = (VerDist<yMerge) ? true: false;

					if((IsxMg && IsyMg) || IsInMg){
						C2CirDefectPoint[k].Round    += C2CirDefectPoint[l].Round;
						C2CirDefectPoint[k].Rect      = OnMerge(C2CirDefectPoint[k].Rect, C2CirDefectPoint[l].Rect);
						C2CirDefectPoint[k].Width     = C2CirDefectPoint[k].Rect.right  - C2CirDefectPoint[k].Rect.left;
						C2CirDefectPoint[k].Height    = C2CirDefectPoint[k].Rect.bottom - C2CirDefectPoint[k].Rect.top ;
						C2CirDefectPoint[k].Hor_Dis   = C2CirDefectPoint[k].Width ; 
						C2CirDefectPoint[k].Ver_Dis   = C2CirDefectPoint[k].Height;
						C2CirDefectPoint[k].P.x       = (float)(C2CirDefectPoint[k].Rect.left);
						C2CirDefectPoint[k].P.y       = (float)(C2CirDefectPoint[k].Rect.top ); 
						C2CirDefectPoint[l].Rect.left = C2CirDefectPoint[l].Rect.top = C2CirDefectPoint[l].Rect.right = C2CirDefectPoint[l].Rect.bottom =0;
						C2CirDeftectCnt--;
						k=-1;
						break;
					}

				}

			}
			for(int j=0; j<tmpDDefectCount; j++){
				if(C2CirDefectPoint[j].Rect.left==0 && C2CirDefectPoint[j].Rect.top==0 && C2CirDefectPoint[j].Rect.right==0 && C2CirDefectPoint[j].Rect.bottom==0) continue;
				C2CirDefectPoint[sort] = C2CirDefectPoint[j];
				sort++;
			}
		}
		////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

		// Circle_3 불량 Merge 기능 
		if(C3CirDeftectCnt!=0){
			bool IsxMg=false, IsyMg=false, IsInMg=false;
			CRect r1, r2;
			int sort =0;
			int tmpDDefectCount = C3CirDeftectCnt;

			for(int k=0; k<tmpDDefectCount; k++){
				if(C3CirDefectPoint[k].Rect.left==0 && C3CirDefectPoint[k].Rect.top==0 && C3CirDefectPoint[k].Rect.right==0 && C3CirDefectPoint[k].Rect.bottom==0) continue;

				for(int l=k+1; l<k+MgCount; l++ ){
					IsxMg = false; IsyMg = false;
					if(l>(tmpDDefectCount-1)) break;
					if(C3CirDefectPoint[l].Rect.left==0 && C3CirDefectPoint[l].Rect.top==0 && C3CirDefectPoint[k].Rect.right==0 && C3CirDefectPoint[k].Rect.bottom==0) continue;

					r1 = C3CirDefectPoint[k].Rect;
					r2 = C3CirDefectPoint[l].Rect; 

					register int HorDist   = abs((r1.left < r2.left) ?  r2.left - r1.right  : r1.left - r2.right );
					register int VerDist   = abs((r1.top  < r2.top ) ?  r2.top  - r1.bottom : r1.top  - r2.bottom);
					IsInMg    = ((r1.left<=r2.left) && (r1.top<r2.top) && (r1.bottom>r2.bottom) && (r1.right >r2.right))? true: false;

					if(HorDist>xMerge && VerDist>yMerge && !IsInMg ) continue;

					IsxMg = (HorDist<xMerge) ? true: false;
					IsyMg = (VerDist<yMerge) ? true: false;

					if((IsxMg && IsyMg) || IsInMg){
						C3CirDefectPoint[k].Round    += C3CirDefectPoint[l].Round;
						C3CirDefectPoint[k].Rect      = OnMerge(C3CirDefectPoint[k].Rect, C3CirDefectPoint[l].Rect);
						C3CirDefectPoint[k].Width     = C3CirDefectPoint[k].Rect.right  - C3CirDefectPoint[k].Rect.left;
						C3CirDefectPoint[k].Height    = C3CirDefectPoint[k].Rect.bottom - C3CirDefectPoint[k].Rect.top ;
						C3CirDefectPoint[k].Hor_Dis   = C3CirDefectPoint[k].Width ; 
						C3CirDefectPoint[k].Ver_Dis   = C3CirDefectPoint[k].Height;
						C3CirDefectPoint[k].P.x       = (float)(C3CirDefectPoint[k].Rect.left);
						C3CirDefectPoint[k].P.y       = (float)(C3CirDefectPoint[k].Rect.top ); 
						C3CirDefectPoint[l].Rect.left = C3CirDefectPoint[l].Rect.top = C3CirDefectPoint[l].Rect.right = C3CirDefectPoint[l].Rect.bottom =0;
						C3CirDeftectCnt--;
						k=-1;
						break;
					}

				}

			}
			for(int j=0; j<tmpDDefectCount; j++){
				if(C3CirDefectPoint[j].Rect.left==0 && C3CirDefectPoint[j].Rect.top==0 && C3CirDefectPoint[j].Rect.right==0 && C3CirDefectPoint[j].Rect.bottom==0) continue;
				C3CirDefectPoint[sort] = C3CirDefectPoint[j];
				sort++;
			}
		}
		////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

		// Circle_4 불량 Merge 기능 
		if(C4CirDeftectCnt!=0){
			bool IsxMg=false, IsyMg=false, IsInMg=false;
			CRect r1, r2;
			int sort =0;
			int tmpDDefectCount = C4CirDeftectCnt;

			for(int k=0; k<tmpDDefectCount; k++){
				if(C4CirDefectPoint[k].Rect.left==0 && C4CirDefectPoint[k].Rect.top==0 && C4CirDefectPoint[k].Rect.right==0 && C4CirDefectPoint[k].Rect.bottom==0) continue;

				for(int l=k+1; l<k+MgCount; l++ ){
					IsxMg = false; IsyMg = false;
					if(l>(tmpDDefectCount-1)) break;
					if(C4CirDefectPoint[l].Rect.left==0 && C4CirDefectPoint[l].Rect.top==0 && C4CirDefectPoint[k].Rect.right==0 && C4CirDefectPoint[k].Rect.bottom==0) continue;

					r1 = C4CirDefectPoint[k].Rect;
					r2 = C4CirDefectPoint[l].Rect; 

					register int HorDist   = abs((r1.left < r2.left) ?  r2.left - r1.right  : r1.left - r2.right );
					register int VerDist   = abs((r1.top  < r2.top ) ?  r2.top  - r1.bottom : r1.top  - r2.bottom);
					IsInMg    = ((r1.left<=r2.left) && (r1.top<r2.top) && (r1.bottom>r2.bottom) && (r1.right >r2.right))? true: false;

					if(HorDist>xMerge && VerDist>yMerge && !IsInMg ) continue;

					IsxMg = (HorDist<xMerge) ? true: false;
					IsyMg = (VerDist<yMerge) ? true: false;

					if((IsxMg && IsyMg) || IsInMg){
						C4CirDefectPoint[k].Round    += C4CirDefectPoint[l].Round;
						C4CirDefectPoint[k].Rect      = OnMerge(C4CirDefectPoint[k].Rect, C4CirDefectPoint[l].Rect);
						C4CirDefectPoint[k].Width     = C4CirDefectPoint[k].Rect.right  - C4CirDefectPoint[k].Rect.left;
						C4CirDefectPoint[k].Height    = C4CirDefectPoint[k].Rect.bottom - C4CirDefectPoint[k].Rect.top ;
						C4CirDefectPoint[k].Hor_Dis   = C4CirDefectPoint[k].Width ; 
						C4CirDefectPoint[k].Ver_Dis   = C4CirDefectPoint[k].Height;
						C4CirDefectPoint[k].P.x       = (float)(C4CirDefectPoint[k].Rect.left);
						C4CirDefectPoint[k].P.y       = (float)(C4CirDefectPoint[k].Rect.top ); 
						C4CirDefectPoint[l].Rect.left = C4CirDefectPoint[l].Rect.top = C4CirDefectPoint[l].Rect.right = C4CirDefectPoint[l].Rect.bottom =0;
						C4CirDeftectCnt--;
						k=-1;
						break;
					}

				}

			}
			for(int j=0; j<tmpDDefectCount; j++){
				if(C4CirDefectPoint[j].Rect.left==0 && C4CirDefectPoint[j].Rect.top==0 && C4CirDefectPoint[j].Rect.right==0 && C4CirDefectPoint[j].Rect.bottom==0) continue;
				C4CirDefectPoint[sort] = C4CirDefectPoint[j];
				sort++;
			}
		}
		////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

		// Circle_5 불량 Merge 기능 
		if(C5CirDeftectCnt!=0){
			bool IsxMg=false, IsyMg=false, IsInMg=false;
			CRect r1, r2;
			int sort =0;
			int tmpDDefectCount = C5CirDeftectCnt;

			for(int k=0; k<tmpDDefectCount; k++){
				if(C5CirDefectPoint[k].Rect.left==0 && C5CirDefectPoint[k].Rect.top==0 && C5CirDefectPoint[k].Rect.right==0 && C5CirDefectPoint[k].Rect.bottom==0) continue;

				for(int l=k+1; l<k+MgCount; l++ ){
					IsxMg = false; IsyMg = false;
					if(l>(tmpDDefectCount-1)) break;
					if(C5CirDefectPoint[l].Rect.left==0 && C5CirDefectPoint[l].Rect.top==0 && C5CirDefectPoint[k].Rect.right==0 && C5CirDefectPoint[k].Rect.bottom==0) continue;

					r1 = C5CirDefectPoint[k].Rect;
					r2 = C5CirDefectPoint[l].Rect; 

					register int HorDist   = abs((r1.left < r2.left) ?  r2.left - r1.right  : r1.left - r2.right );
					register int VerDist   = abs((r1.top  < r2.top ) ?  r2.top  - r1.bottom : r1.top  - r2.bottom);
					IsInMg    = ((r1.left<=r2.left) && (r1.top<r2.top) && (r1.bottom>r2.bottom) && (r1.right >r2.right))? true: false;

					if(HorDist>xMerge && VerDist>yMerge && !IsInMg ) continue;

					IsxMg = (HorDist<xMerge) ? true: false;
					IsyMg = (VerDist<yMerge) ? true: false;

					if((IsxMg && IsyMg) || IsInMg){
						C5CirDefectPoint[k].Round    += C5CirDefectPoint[l].Round;
						C5CirDefectPoint[k].Rect      = OnMerge(C5CirDefectPoint[k].Rect, C5CirDefectPoint[l].Rect);
						C5CirDefectPoint[k].Width     = C5CirDefectPoint[k].Rect.right  - C5CirDefectPoint[k].Rect.left;
						C5CirDefectPoint[k].Height    = C5CirDefectPoint[k].Rect.bottom - C5CirDefectPoint[k].Rect.top ;
						C5CirDefectPoint[k].Hor_Dis   = C5CirDefectPoint[k].Width ; 
						C5CirDefectPoint[k].Ver_Dis   = C5CirDefectPoint[k].Height;
						C5CirDefectPoint[k].P.x       = (float)(C5CirDefectPoint[k].Rect.left);
						C5CirDefectPoint[k].P.y       = (float)(C5CirDefectPoint[k].Rect.top ); 
						C5CirDefectPoint[l].Rect.left = C5CirDefectPoint[l].Rect.top = C5CirDefectPoint[l].Rect.right = C5CirDefectPoint[l].Rect.bottom =0;
						C5CirDeftectCnt--;
						k=-1;
						break;
					}

				}

			}
			for(int j=0; j<tmpDDefectCount; j++){
				if(C5CirDefectPoint[j].Rect.left==0 && C5CirDefectPoint[j].Rect.top==0 && C5CirDefectPoint[j].Rect.right==0 && C5CirDefectPoint[j].Rect.bottom==0) continue;
				C5CirDefectPoint[sort] = C5CirDefectPoint[j];
				sort++;
			}
		}
		////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

		// Circle_6 불량 Merge 기능 
		if(C6CirDeftectCnt!=0){
			bool IsxMg=false, IsyMg=false, IsInMg=false;
			CRect r1, r2;
			int sort =0;
			int tmpDDefectCount = C6CirDeftectCnt;

			for(int k=0; k<tmpDDefectCount; k++){
				if(C6CirDefectPoint[k].Rect.left==0 && C6CirDefectPoint[k].Rect.top==0 && C6CirDefectPoint[k].Rect.right==0 && C6CirDefectPoint[k].Rect.bottom==0) continue;

				for(int l=k+1; l<k+MgCount; l++ ){
					IsxMg = false; IsyMg = false;
					if(l>(tmpDDefectCount-1)) break;
					if(C6CirDefectPoint[l].Rect.left==0 && C6CirDefectPoint[l].Rect.top==0 && C6CirDefectPoint[k].Rect.right==0 && C6CirDefectPoint[k].Rect.bottom==0) continue;

					r1 = C6CirDefectPoint[k].Rect;
					r2 = C6CirDefectPoint[l].Rect; 

					register int HorDist   = abs((r1.left < r2.left) ?  r2.left - r1.right  : r1.left - r2.right );
					register int VerDist   = abs((r1.top  < r2.top ) ?  r2.top  - r1.bottom : r1.top  - r2.bottom);
					IsInMg    = ((r1.left<=r2.left) && (r1.top<r2.top) && (r1.bottom>r2.bottom) && (r1.right >r2.right))? true: false;

					if(HorDist>xMerge && VerDist>yMerge && !IsInMg ) continue;

					IsxMg = (HorDist<xMerge) ? true: false;
					IsyMg = (VerDist<yMerge) ? true: false;

					if((IsxMg && IsyMg) || IsInMg){
						C6CirDefectPoint[k].Round    += C6CirDefectPoint[l].Round;
						C6CirDefectPoint[k].Rect      = OnMerge(C6CirDefectPoint[k].Rect, C6CirDefectPoint[l].Rect);
						C6CirDefectPoint[k].Width     = C6CirDefectPoint[k].Rect.right  - C6CirDefectPoint[k].Rect.left;
						C6CirDefectPoint[k].Height    = C6CirDefectPoint[k].Rect.bottom - C6CirDefectPoint[k].Rect.top ;
						C6CirDefectPoint[k].Hor_Dis   = C6CirDefectPoint[k].Width ; 
						C6CirDefectPoint[k].Ver_Dis   = C6CirDefectPoint[k].Height;
						C6CirDefectPoint[k].P.x       = (float)(C6CirDefectPoint[k].Rect.left);
						C6CirDefectPoint[k].P.y       = (float)(C6CirDefectPoint[k].Rect.top ); 
						C6CirDefectPoint[l].Rect.left = C6CirDefectPoint[l].Rect.top = C6CirDefectPoint[l].Rect.right = C6CirDefectPoint[l].Rect.bottom =0;
						C6CirDeftectCnt--;
						k=-1;
						break;
					}

				}

			}
			for(int j=0; j<tmpDDefectCount; j++){
				if(C6CirDefectPoint[j].Rect.left==0 && C6CirDefectPoint[j].Rect.top==0 && C6CirDefectPoint[j].Rect.right==0 && C6CirDefectPoint[j].Rect.bottom==0) continue;
				C6CirDefectPoint[sort] = C6CirDefectPoint[j];
				sort++;
			}
		}
		////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


		// Side C Merge (박리불량)
		if(CCrackCount!=0){
			bool IsxMg=false, IsyMg=false, IsInMg=false;
			CRect r1, r2;
			int sort =0;
			int tmpDDefectCount = CCrackCount;

			for(int k=0; k<tmpDDefectCount; k++){
				if(CCrackPoint[k].Rect.left==0 && CCrackPoint[k].Rect.top==0 && CCrackPoint[k].Rect.right==0 && CCrackPoint[k].Rect.bottom==0) continue;

				for(int l=k+1; l<k+MgCount; l++ ){
					IsxMg = false; IsyMg = false;
					if(l>(tmpDDefectCount-1)) break;
					if(CCrackPoint[l].Rect.left==0 && CCrackPoint[l].Rect.top==0 && CCrackPoint[k].Rect.right==0 && CCrackPoint[k].Rect.bottom==0) continue;

					r1 = CCrackPoint[k].Rect;
					r2 = CCrackPoint[l].Rect; 

					register int HorDist   = abs((r1.left < r2.left) ?  r2.left - r1.right  : r1.left - r2.right );
					register int VerDist   = abs((r1.top  < r2.top ) ?  r2.top  - r1.bottom : r1.top  - r2.bottom);
					IsInMg    = ((r1.left<=r2.left) && (r1.top<r2.top) && (r1.bottom>r2.bottom) && (r1.right >r2.right))? true: false;

					if(HorDist>xMerge && VerDist>yMerge && !IsInMg ) continue;

					IsxMg = (HorDist<xMerge) ? true: false;
					IsyMg = (VerDist<yMerge) ? true: false;

					if((IsxMg && IsyMg) || IsInMg){
						CCrackPoint[k].Round    += CCrackPoint[l].Round;
						CCrackPoint[k].Rect      = OnMerge(CCrackPoint[k].Rect, CCrackPoint[l].Rect);
						CCrackPoint[k].Width     = CCrackPoint[k].Rect.right  - CCrackPoint[k].Rect.left;
						CCrackPoint[k].Height    = CCrackPoint[k].Rect.bottom - CCrackPoint[k].Rect.top ;
						CCrackPoint[k].P.x       = (float)(CCrackPoint[k].Rect.left);
						CCrackPoint[k].P.y       = (float)(CCrackPoint[k].Rect.top ); 
						CCrackPoint[l].Rect.left = CCrackPoint[l].Rect.top = CCrackPoint[l].Rect.right = CCrackPoint[l].Rect.bottom =0;
						CCrackCount--;
						k=-1;
						break;
					}

				}

			}
			for(int j=0; j<tmpDDefectCount; j++){
				if(CCrackPoint[j].Rect.left==0 && CCrackPoint[j].Rect.top==0 && CCrackPoint[j].Rect.right==0 && CCrackPoint[j].Rect.bottom==0) continue;
				CCrackPoint[sort] = CCrackPoint[j];
				sort++;
			}
		}

		// Side D Merge (Crack & Chipping)
		if(DCount!=0){
			bool IsxMg=false, IsyMg=false, IsInMg=false;
			CRect r1, r2;
			int sort =0;
			int tmpDDefectCount = DCount;

			for(int k=0; k<tmpDDefectCount; k++){
				if(DDefectPoint[k].Rect.left==0 && DDefectPoint[k].Rect.top==0 && DDefectPoint[k].Rect.right==0 && DDefectPoint[k].Rect.bottom==0) continue;

				for(int l=k+1; l<k+MgCount; l++ ){
					IsxMg = false; IsyMg = false;
					if(l>(tmpDDefectCount-1)) break;
					if(DDefectPoint[l].Rect.left==0 && DDefectPoint[l].Rect.top==0 && DDefectPoint[k].Rect.right==0 && DDefectPoint[k].Rect.bottom==0) continue;

					r1 = DDefectPoint[k].Rect;
					r2 = DDefectPoint[l].Rect; 

					register int HorDist   = abs((r1.left < r2.left) ?  r2.left - r1.right  : r1.left - r2.right );
					register int VerDist   = abs((r1.top  < r2.top ) ?  r2.top  - r1.bottom : r1.top  - r2.bottom);
					IsInMg    = ((r1.left<=r2.left) && (r1.top<r2.top) && (r1.bottom>r2.bottom) && (r1.right >r2.right))? true: false;

					if(HorDist>xMerge && VerDist>yMerge && !IsInMg ) continue;

					IsxMg = (HorDist<xMerge) ? true: false;
					IsyMg = (VerDist<yMerge) ? true: false;

					if((IsxMg && IsyMg) || IsInMg){
						DDefectPoint[k].Round    += DDefectPoint[l].Round;
						DDefectPoint[k].Rect      = OnMerge(DDefectPoint[k].Rect, DDefectPoint[l].Rect);
						DDefectPoint[k].Width     = DDefectPoint[k].Rect.right  - DDefectPoint[k].Rect.left;
						DDefectPoint[k].Height    = DDefectPoint[k].Rect.bottom - DDefectPoint[k].Rect.top ;
						DDefectPoint[k].P.x       = (float)(DDefectPoint[k].Rect.left);
						DDefectPoint[k].P.y       = (float)(DDefectPoint[k].Rect.top ); 
						DDefectPoint[l].Rect.left = DDefectPoint[l].Rect.top = DDefectPoint[l].Rect.right = DDefectPoint[l].Rect.bottom =0;
						DCount--;
						k=-1;
						break;
					}

				}

			}
			for(int j=0; j<tmpDDefectCount; j++){
				if(DDefectPoint[j].Rect.left==0 && DDefectPoint[j].Rect.top==0 && DDefectPoint[j].Rect.right==0 && DDefectPoint[j].Rect.bottom==0) continue;
				DDefectPoint[sort] = DDefectPoint[j];
				sort++;
			}
		}

		// Side D Merge(Burr & Remain)
		if(DBurrCount!=0){
			bool IsxMg=false, IsyMg=false, IsInMg=false;
			CRect r1, r2;
			int sort =0;
			int tmpDDefectCount = DBurrCount;

			for(int k=0; k<tmpDDefectCount; k++){
				if(DBurrPoint[k].Rect.left==0 && DBurrPoint[k].Rect.top==0 && DBurrPoint[k].Rect.right==0 && DBurrPoint[k].Rect.bottom==0) continue;

				for(int l=k+1; l<k+MgCount; l++ ){
					IsxMg = false; IsyMg = false;
					if(l>(tmpDDefectCount-1)) break;
					if(DBurrPoint[l].Rect.left==0 && DBurrPoint[l].Rect.top==0 && DBurrPoint[k].Rect.right==0 && DBurrPoint[k].Rect.bottom==0) continue;

					r1 = DBurrPoint[k].Rect;
					r2 = DBurrPoint[l].Rect; 

					register int HorDist   =abs((r1.left < r2.left) ?  r2.left - r1.right  : r1.left - r2.right );
					register int VerDist   =abs((r1.top  < r2.top ) ?  r2.top  - r1.bottom : r1.top  - r2.bottom);
					IsInMg    = ((r1.left<=r2.left) && (r1.top<r2.top) && (r1.bottom>r2.bottom) && (r1.right >r2.right))? true: false;

					if(HorDist>xMerge && VerDist>yMerge && !IsInMg ) continue;

					IsxMg = (HorDist<xMerge) ? true: false;
					IsyMg = (VerDist<yMerge) ? true: false;

					if((IsxMg && IsyMg) || IsInMg){
						DBurrPoint[k].Round    += DBurrPoint[l].Round;
						DBurrPoint[k].Rect      = OnMerge(DBurrPoint[k].Rect, DBurrPoint[l].Rect);
						DBurrPoint[k].Width     = DBurrPoint[k].Rect.right  - DBurrPoint[k].Rect.left;
						DBurrPoint[k].Height    = DBurrPoint[k].Rect.bottom - DBurrPoint[k].Rect.top ;
						DBurrPoint[k].P.x       = (float)(DBurrPoint[k].Rect.left);
						DBurrPoint[k].P.y       = (float)(DBurrPoint[k].Rect.top ); 
						DBurrPoint[l].Rect.left = DBurrPoint[l].Rect.top = DBurrPoint[l].Rect.right = DBurrPoint[l].Rect.bottom =0;
						DBurrCount--;
						k=-1;
						break;
					}

				}

			}
			for(int j=0; j<tmpDDefectCount; j++){
				if(DBurrPoint[j].Rect.left==0 && DBurrPoint[j].Rect.top==0 && DBurrPoint[j].Rect.right==0 && DBurrPoint[j].Rect.bottom==0) continue;
				DBurrPoint[sort] = DBurrPoint[j];
				sort++;
			}
		}


		// Side B Merge (Crack & Chipping)
		if(BCount!=0){
			bool IsxMg=false, IsyMg=false, IsInMg=false;
			CRect r1, r2;
			int sort =0;
			int tmpBDefectCount = BCount;

			for(int k=0; k<tmpBDefectCount; k++){
				if(BDefectPoint[k].Rect.left==0 && BDefectPoint[k].Rect.top==0 && BDefectPoint[k].Rect.right==0 && BDefectPoint[k].Rect.bottom==0) continue;

				for(int l=k+1; l<k+MgCount; l++ ){
					IsxMg = false; IsyMg = false;
					if(l>(tmpBDefectCount-1)) break;
					if(BDefectPoint[l].Rect.left==0 && BDefectPoint[l].Rect.top==0 && BDefectPoint[k].Rect.right==0 && BDefectPoint[k].Rect.bottom==0) continue;

					r1 = BDefectPoint[k].Rect;
					r2 = BDefectPoint[l].Rect; 

					register int HorDist   = abs((r1.left < r2.left) ?  r2.left - r1.right  : r1.left - r2.right );
					register int VerDist   = abs((r1.top  < r2.top ) ?  r2.top  - r1.bottom : r1.top  - r2.bottom);
					IsInMg    = ((r1.left<r2.left) && (r1.top<r2.top) && (r1.bottom>r2.bottom) && (r1.right >=r2.right))? true: false;

					if(HorDist>xMerge && VerDist>yMerge && !IsInMg ) continue;

					IsxMg = (HorDist<xMerge) ? true: false;
					IsyMg = (VerDist<yMerge) ? true: false;

					if((IsxMg && IsyMg) || IsInMg){
						BDefectPoint[k].Round    += BDefectPoint[l].Round;
						BDefectPoint[k].Rect      = OnMerge(BDefectPoint[k].Rect, BDefectPoint[l].Rect);
						BDefectPoint[k].Width     = BDefectPoint[k].Rect.right  - BDefectPoint[k].Rect.left;
						BDefectPoint[k].Height    = BDefectPoint[k].Rect.bottom - BDefectPoint[k].Rect.top ;
						BDefectPoint[k].P.x       = (float)(BDefectPoint[k].Rect.left);
						BDefectPoint[k].P.y       = (float)(BDefectPoint[k].Rect.top ); 
						BDefectPoint[l].Rect.left = BDefectPoint[l].Rect.top = BDefectPoint[l].Rect.right = BDefectPoint[l].Rect.bottom =0;
						BCount--;
						k=-1;
						break;
					}

				}

			}
			for(int j=0; j<tmpBDefectCount; j++){
				if(BDefectPoint[j].Rect.left==0 && BDefectPoint[j].Rect.top==0 && BDefectPoint[j].Rect.right==0 && BDefectPoint[j].Rect.bottom==0) continue;
				BDefectPoint[sort] = BDefectPoint[j];
				sort++;
			}
		}


		// Side B Merge (Burr & Remain)
		if(BBurrCount!=0){
			bool IsxMg=false, IsyMg=false, IsInMg=false;
			CRect r1, r2;
			int sort =0;
			int tmpBDefectCount = BBurrCount;

			for(int k=0; k<tmpBDefectCount; k++){
				if(BBurrPoint[k].Rect.left==0 && BBurrPoint[k].Rect.top==0 && BBurrPoint[k].Rect.right==0 && BBurrPoint[k].Rect.bottom==0) continue;

				for(int l=k+1; l<k+MgCount; l++ ){
					IsxMg = false; IsyMg = false;
					if(l>(tmpBDefectCount-1)) break;
					if(BBurrPoint[l].Rect.left==0 && BBurrPoint[l].Rect.top==0 && BBurrPoint[k].Rect.right==0 && BBurrPoint[k].Rect.bottom==0) continue;

					r1 = BBurrPoint[k].Rect;
					r2 = BBurrPoint[l].Rect; 

					register int HorDist   = abs((r1.left < r2.left) ?  r2.left - r1.right  : r1.left - r2.right );
					register int VerDist   = abs((r1.top  < r2.top ) ?  r2.top  - r1.bottom : r1.top  - r2.bottom);
					IsInMg    = ((r1.left<r2.left) && (r1.top<r2.top) && (r1.bottom>r2.bottom) && (r1.right >=r2.right))? true: false;

					if(HorDist>xMerge && VerDist>yMerge && !IsInMg ) continue;

					IsxMg = (HorDist<xMerge) ? true: false;
					IsyMg = (VerDist<yMerge) ? true: false;

					if((IsxMg && IsyMg) || IsInMg){
						BBurrPoint[k].Round    += BBurrPoint[l].Round;
						BBurrPoint[k].Rect      = OnMerge(BBurrPoint[k].Rect, BBurrPoint[l].Rect);
						BBurrPoint[k].Width     = BBurrPoint[k].Rect.right  - BBurrPoint[k].Rect.left;
						BBurrPoint[k].Height    = BBurrPoint[k].Rect.bottom - BBurrPoint[k].Rect.top ;
						BBurrPoint[k].P.x       = (float)(BBurrPoint[k].Rect.left);
						BBurrPoint[k].P.y       = (float)(BBurrPoint[k].Rect.top ); 
						BBurrPoint[l].Rect.left = BBurrPoint[l].Rect.top = BBurrPoint[l].Rect.right = BBurrPoint[l].Rect.bottom =0;
						BBurrCount--;
						k=-1;
						break;
					}

				}

			}
			for(int j=0; j<tmpBDefectCount; j++){
				if(BBurrPoint[j].Rect.left==0 && BBurrPoint[j].Rect.top==0 && BBurrPoint[j].Rect.right==0 && BBurrPoint[j].Rect.bottom==0) continue;
				BBurrPoint[sort] = BBurrPoint[j];
				sort++;
			}

		}

		if(!IsCornerTop){
			if(ACount!=0){ // Left 
				bool IsxMg, IsyMg;
				CRect r1, r2;
				int sort =0;
				int tmpBDefectCount = ACount;

				// SIDE A + SIDE D Merge 
				for(int k=0; k<tmpBDefectCount; k++){
					if(ADefectPoint[k].Rect.left==0 && ADefectPoint[k].Rect.top==0 && ADefectPoint[k].Rect.right==0 && ADefectPoint[k].Rect.bottom==0) continue;
					IsxMg = false; IsyMg = false;
					r1 = ADefectPoint[k].Rect;
					r2 = DDefectPoint[0].Rect; 

					register int HorDist   = abs((r1.left < r2.left) ?  r2.left - r1.right  : r1.left - r2.right );
					register int VerDist   = abs((r1.top  < r2.top ) ?  r2.top  - r1.bottom : r1.top  - r2.bottom);

					if(HorDist>xMerge && VerDist>yMerge) continue;

					IsxMg = (HorDist<xMerge) ? true: false;
					IsyMg = (VerDist<yMerge) ? true: false;

					if(IsxMg && IsyMg){
						DDefectPoint[0].Round     = (ADefectPoint[k].Round>DDefectPoint[0].Round) ? ADefectPoint[k].Round :DDefectPoint[0].Round; 
						DDefectPoint[0].Rect      = OnMerge(ADefectPoint[k].Rect, DDefectPoint[0].Rect);
						DDefectPoint[0].Width     = DDefectPoint[0].Rect.right  - DDefectPoint[0].Rect.left;
						DDefectPoint[0].Height    = DDefectPoint[0].Rect.bottom - DDefectPoint[0].Rect.top ;
						ADefectPoint[k].Rect.left = ADefectPoint[k].Rect.top = ADefectPoint[k].Rect.right = ADefectPoint[k].Rect.bottom =0;
						ACount--;
						k=-1;
						//break;
					}
				}

				for(int j=0; j<tmpBDefectCount; j++){
					if(ADefectPoint[j].Rect.left==0 && ADefectPoint[j].Rect.top==0 && ADefectPoint[j].Rect.right==0 && ADefectPoint[j].Rect.bottom==0) continue;
					ADefectPoint[sort] = ADefectPoint[j];
					sort++;
				}
			}

			if(ACount!=0){ // Right 
				bool IsxMg, IsyMg;
				CRect r1, r2;
				int sort =0;
				int tmpBDefectCount = ACount;

				// SIDE A + SIDE B Merge 
				for(int k=0; k<tmpBDefectCount; k++){
					if(ADefectPoint[k].Rect.left==0 && ADefectPoint[k].Rect.top==0 && ADefectPoint[k].Rect.right==0 && ADefectPoint[k].Rect.bottom==0) continue;
					IsxMg = false; IsyMg = false;
					r1 = ADefectPoint[k].Rect;
					r2 = BDefectPoint[0].Rect; 

					register int HorDist   = abs((r1.left < r2.left) ?  r2.left - r1.right  : r1.left - r2.right );
					register int VerDist   = abs((r1.top  < r2.top ) ?  r2.top  - r1.bottom : r1.top  - r2.bottom);

					if(HorDist>xMerge && VerDist>yMerge) continue;

					IsxMg = (HorDist<xMerge) ? true: false;
					IsyMg = (VerDist<yMerge) ? true: false;

					if(IsxMg && IsyMg){
						BDefectPoint[0].Round     = (ADefectPoint[k].Round>BDefectPoint[0].Round) ? ADefectPoint[k].Round :BDefectPoint[0].Round; 
						BDefectPoint[0].Rect      = OnMerge(ADefectPoint[k].Rect, BDefectPoint[0].Rect);
						BDefectPoint[0].Width     = BDefectPoint[0].Rect.right  - BDefectPoint[0].Rect.left;
						BDefectPoint[0].Height    = BDefectPoint[0].Rect.bottom - BDefectPoint[0].Rect.top ;
						ADefectPoint[k].Rect.left = ADefectPoint[k].Rect.top = ADefectPoint[k].Rect.right = ADefectPoint[k].Rect.bottom =0;
						ACount--;
						k=-1;
						//break;
					}
				}

				for(int j=0; j<tmpBDefectCount; j++){
					if(ADefectPoint[j].Rect.left==0 && ADefectPoint[j].Rect.top==0 && ADefectPoint[j].Rect.right==0 && ADefectPoint[j].Rect.bottom==0) continue;
					ADefectPoint[sort] = ADefectPoint[j];
					sort++;
				}
			}
		}
		//////////////////////////////////////////////////////////////////////////////////////////////
		// Blob Merge End
		Index = 0;
		return true;
    }
	return false;
}
int CFM1xLineDefect::OnExecute(bool l, bool t, bool r, bool b, bool lt, bool rt, bool rb, bool lb)
{

    int x = IRoi->GetOrgX();
    int y = IRoi->GetOrgY();
    int w = IRoi->GetWidth();
    int h = IRoi->GetHeight();

    int szX = IRoi->GetWidth();
    int szY = IRoi->GetHeight();
    int szBuffer = szX > szY ? szX : szY;

	int nLRoiOffset =0;
	int nRRoiOffset =0;
	int CornerCount =0;

	int ROI_H = 0;
	int ROI_L = 0;
	int ROI_W = 0;
	int ROI_T = 0;

	const int MAX_SIDE     = 8  ;
	//const int BMWidth      = 500;
	const int BMHeight     = 200;
	const int GRWidth      = 250;
	const int GROffset     = 20 ;
	const int ROIOffset    = 10 ;
	const int CornerMargin = 2  ;
	      int BMWidth      = 0  ;


	if(FCompanyMode==COM_TIANMA) BMWidth =500;
	if(FCompanyMode==COM_KWON  ) BMWidth =300;

	// 시작부분 Broken발생시 
	int LineMargin =30;
	int LineRange  =80;

	// Euresys ROI 
	// Median Filtter 적용 목적 ROI   
	EROIBW8   FilterROI                ;

	// Circle 생성시 필요한 데이터 
	const int   TrackLineMargin = 5    ;
	const int   CirAngleMargin  = 10   ;
	const int   CirCenterMargin = 0    ;
	const float CirCrackMargin  = 30.0f;  
	const float CirOffsetMargin = 7.0f ;

	//Polygon Value Test 
	int   PolygonMarginCnt= 0 ;

	// Circle Notch부 Trench_Width 길이 마진값 
	const int TrenchWidthMargin =2000;

	// ㅏMark Find 검사시 필요한 ROI영역 데이터 
	int GrindRectWidth=0, GrindRectHeight=0;

	// FAVION Circle Fitting 필요한 Data 
	float SampleSize   = 0.0f; //0.5~0.8이하로 입력할것
	float DistDevRatio = 0.15; //0.1~0.25 이하로 입력할것

	//Circle Count,Avg Round 
	int CircleCount      =0   ;
	int EdgeCount        =0   ;
	float Dis            =0   ;
	float AvgCirDis      =0.0f;
	float TotalCirDis    =0.0f;
	double MaxDis        =0.0f;
	double MinDis        =100000.0f; 
	double GrindMeaDis   =0.0f;
	double GrindWidthDis =0.0f;

    //Polygon Algorithm 적용시 OutData,InData 개별 최단거리 계산시 필요한 Count
	int GrindMarkOutCnt=0, GrindMarkInCnt =0; 

	// GOO 20150819
    //if (FDefectPoint != NULL) delete[] FDefectPoint;
    //FDefectPoint = new TFPoint[szBuffer];

    FLeftWall = l;
    FTopWall = t;
    FRightWall = r;
    FBottomWall = b;
    FLeftTop = lt;
    FRightTop = rt;
    FRightBottom = rb;
    FLeftBottom = lb;

	// TOP, BTM Cell_Size, Grind_Size 검사시 필요 변수

    int ImgW = GImage->GetWidth();
    int ImgH = GImage->GetHeight();

    TFPoint LT(0          ,           0);
    TFPoint RT((float)ImgW,           0);
    TFPoint RB((float)ImgW, (float)ImgH);
    TFPoint LB(0          , (float)ImgH);
    TFPoint LSP, LEP                    ;

	ImgDegree        =0.0f;

    // Data Init
    FLTPoint.x = 0.0f; //좌측라인과 상단라인의 교차점 좌표
    FLTPoint.y = 0.0f; //좌측라인과 상단라인의 교차점 좌표
    FRTPoint.x = 0.0f; //우측라인과 상단라인의 교차점 좌표
    FRTPoint.y = 0.0f; //우측라인과 상단라인의 교차점 좌표
    FRBPoint.x = 0.0f; //우측라인과 하단라인의 교차점 좌표
    FRBPoint.y = 0.0f; //우측라인과 하단라인의 교차점 좌표
    FLBPoint.x = 0.0f; //좌측라인과 하단라인의 교차점 좌표
    FLBPoint.y = 0.0f; //좌측라인과 하단라인의 교차점 좌표
	
    FLTLPoint.x = 0.0f; //좌측라인과   첫번째 코너 교차점 좌표 
    FLTLPoint.y = 0.0f; //좌측라인과   첫번째 코너 교차점 좌표 
    FLTTPoint.x = 0.0f; //위쪽라인과   첫번째 코너 교차점 좌표 
    FLTTPoint.y = 0.0f; //위쪽라인과   첫번째 코너 교차점 좌표 
    FRTRPoint.x = 0.0f; //우측라인과   두번째 코너 교차점 좌표 
    FRTRPoint.y = 0.0f; //우측라인과   두번째 코너 교차점 좌표 
    FRTTPoint.x = 0.0f; //위쪽라인과   두번째 코너 교차점 좌표 
    FRTTPoint.y = 0.0f; //위쪽라인과   두번째 코너 교차점 좌표 
    FRBRPoint.x = 0.0f; //우측라인과   세번째 코너 교차점 좌표 
    FRBRPoint.y = 0.0f; //우측라인과   세번째 코너 교차점 좌표 
    FRBBPoint.x = 0.0f; //아래쪽라인과 세번째 코너 교차점 좌표 
    FRBBPoint.y = 0.0f; //아래쪽라인과 세번째 코너 교차점 좌표 
    FLBLPoint.x = 0.0f; //좌측라인과   네번째 코너 교차점 좌표 
    FLBLPoint.y = 0.0f; //좌측라인과   네번째 코너 교차점 좌표 
    FLBBPoint.x = 0.0f; //아래쪽라인과 네번째 코너 교차점 좌표 
    FLBBPoint.y = 0.0f; //아래쪽라인과 네번째 코너 교차점 좌표 

	//NOTCH Inspection
	FLTLInPoint.x = 0.0f; //왼쪽라인과   코너 연마안쪽 라인과 교차점 좌표
	FLTLInPoint.y = 0.0f; //왼쪽라인과   코너 연마안쪽 라인과 교차점 좌표
	FLTTInPoint.x = 0.0f; //위쪽라인과   코너 연마안쪽 라인과 교차점 좌표
	FLTTInPoint.y = 0.0f; //위쪽라인과   코너 연마안쪽 라인과 교차점 좌표
	FRTRInPoint.x = 0.0f; //오른쪽라인과 코너 연마안쪽 라인과 교차점 좌표
	FRTRInPoint.y = 0.0f; //오른쪽라인과 코너 연마안쪽 라인과 교차점 좌표
	FRTTInPoint.x = 0.0f; //위쪽라인과   코너 연마안쪽 라인과 교차점 좌표
	FRTTInPoint.y = 0.0f; //위쪽라인과   코너 연마안쪽 라인과 교차점 좌표
	FLBLInPoint.x = 0.0f; //왼쪽라인과   코너 연마안쪽 라인과 교차점 좌표
	FLBLInPoint.y = 0.0f; //왼쪽라인과   코너 연마안쪽 라인과 교차점 좌표
	FLBBInPoint.x = 0.0f; //아래쪽라인과   코너 연마안쪽 라인과 교차점 좌표
	FLBBInPoint.y = 0.0f; //아래쪽라인과   코너 연마안쪽 라인과 교차점 좌표
	FRBRInPoint.x = 0.0f; //오른쪽라인과   코너 연마안쪽 라인과 교차점 좌표
	FRBRInPoint.y = 0.0f; //오른쪽라인과   코너 연마안쪽 라인과 교차점 좌표
	FRBBInPoint.x = 0.0f; //아래쪽라인과   코너 연마안쪽 라인과 교차점 좌표
	FRBBInPoint.y = 0.0f; //아래쪽라인과   코너 연마안쪽 라인과 교차점 좌표

	FLTLMeaPoint.x = 0.0f; //왼쪽라인과   코너 연마량 측정 기준 라인과 교차점 좌표
	FLTLMeaPoint.y = 0.0f; //왼쪽라인과   코너 연마량 측정 기준 라인과 교차점 좌표
	FLTTMeaPoint.x = 0.0f; //위쪽라인과   코너 연마량 측정 기준 라인과 교차점 좌표
	FLTTMeaPoint.y = 0.0f; //위쪽라인과   코너 연마량 측정 기준 라인과 교차점 좌표
	FRTRMeaPoint.x = 0.0f; //오른쪽라인과 코너 연마량 측정 기준 라인과 교차점 좌표
	FRTRMeaPoint.y = 0.0f; //오른쪽라인과 코너 연마량 측정 기준 라인과 교차점 좌표
	FRTTMeaPoint.x = 0.0f; //위쪽라인과   코너 연마량 측정 기준 라인과 교차점 좌표
	FRTTMeaPoint.y = 0.0f; //위쪽라인과   코너 연마량 측정 기준 라인과 교차점 좌표

	FLBLMeaPoint.x = 0.0f; //왼쪽라인과   코너 연마량 측정 기준 라인과 교차점 좌표
	FLBLMeaPoint.y = 0.0f; //왼쪽라인과   코너 연마량 측정 기준 라인과 교차점 좌표
	FLBBMeaPoint.x = 0.0f; //아래쪽라인과   코너 연마량 측정 기준 라인과 교차점 좌표
	FLBBMeaPoint.y = 0.0f; //아래쪽라인과   코너 연마량 측정 기준 라인과 교차점 좌표
	FRBRMeaPoint.x = 0.0f; //오른쪽라인과 코너 연마량 측정 기준 라인과 교차점 좌표
	FRBRMeaPoint.y = 0.0f; //오른쪽라인과 코너 연마량 측정 기준 라인과 교차점 좌표
	FRBBMeaPoint.x = 0.0f; //아래쪽라인과   코너 연마량 측정 기준 라인과 교차점 좌표
	FRBBMeaPoint.y = 0.0f; //아래쪽라인과   코너 연마량 측정 기준 라인과 교차점 좌표

	// Notch Cell Track 교차점 좌표 
	FTRLBPoint.x = 0.0f; //좌측트랙라인과 하단트랙라인의 교차점 좌표
	FTRLBPoint.y = 0.0f; //좌측트랙라인과 하단트랙라인의 교차점 좌표
	FTRRBPoint.x = 0.0f; //우측트랙라인과 하단트랙라인의 교차점 좌표
	FTRRBPoint.y = 0.0f; //우측트랙라인과 하단트랙라인의 교차점 좌표


	// NOTCH CELL INSPECTION
	Left_Grind_Width  = 0.0f;
	Left_Grind_Mea    = 0.0f;
	Right_Grind_Width = 0.0f;
	Right_Grind_Mea   = 0.0f;
	Btm_Grind_Width   = 0.0f;
// 	Top_Grind_Width   = 0.0f;
// 	Top_Grind_Mea     = 0.0f;

	// Mark에서 TrackLine까지 거리 값 
	float MarkToTrackLineDis1 =0.0f;
	float MarkToTrackLineDis2 =0.0f;

	// 외곽라인에서 TrackLine까지 거리 값 
	float LeftToTrackLineDis1  =0.0f;
	float LeftToTrackLineDis2  =0.0f;
	float RightToTrackLineDis1 =0.0f;
	float RightToTrackLineDis2 =0.0f;

	for(int i=0; i<MAX_SIDE; i++){
		Line[i].FP0.x = 0.0f;
		Line[i].FP0.y = 0.0f;
		Line[i].FP1.x = 0.0f;
		Line[i].FP1.y = 0.0f;
	}

    TFPoint OrgPoint;

	// BtmTrackLine 좌표
	TFPoint LeftBtmTrackPoint (0.0f, 0.0f);
	TFPoint RightBtmTrackPoint(0.0f, 0.0f);
    //int CornerWidth = 100;	//	
    //int CornerHeight =100;

    int Index = 10;

	// ThresHold Image Copy 
	if(GImage->GetImagePtr()){
		BinaryImg.SetSize(GImage->GetWidth(), GImage->GetHeight());
		EasyImage::Oper(EArithmeticLogicOperation_Copy,GImage,&BinaryImg);
	}
	else {
		return false;
	}

    switch (Index) {
        // Find Line
        //----------------------------------------------------------------------
        case 10 :
                 if (FLeftWall) { // NOTCH 
					 EasyImage::Threshold(GImage,&BinaryImg, LeftEdgeThresHold);
					 if(LeftEdgeThresHold==0) {SingleLine->GImage = GImage;     SingleLine->FThreshold =5 ;}
					 else                     {SingleLine->GImage = &BinaryImg; SingleLine->FThreshold =10;}

					 if(FShape==shRectC){
						 SingleLine->IRoi->SetOrgX  (IRoi->GetOrgX()          );
						 SingleLine->IRoi->SetOrgY  (IRoi->GetOrgY()          );
						 SingleLine->IRoi->SetWidth (IRoi->GetWidth()         );
						 SingleLine->IRoi->SetHeight(FEndLine-CSideCircleHeight);
						 SingleLine->SetIncrement(1);
					 }
					 else if(FShape==shRectH) {
						 if(IsCircleTop){
							 SingleLine->IRoi->SetOrgX  (IRoi->GetOrgX()  );
							 SingleLine->IRoi->SetOrgY  (ASideCircleHeight+50);
							 SingleLine->IRoi->SetWidth (IRoi->GetWidth() );
							 SingleLine->IRoi->SetHeight(ImgH-(ASideCircleHeight+50));
							 SingleLine->SetIncrement(1);
						 }
						 else {
							 SingleLine->IRoi->SetOrgX  (IRoi->GetOrgX()  );
							 SingleLine->IRoi->SetOrgY  (IRoi->GetOrgY()  );
							 SingleLine->IRoi->SetWidth (IRoi->GetWidth() );
							 SingleLine->IRoi->SetHeight(IRoi->GetHeight());
							 SingleLine->SetIncrement(50);
						 }
					 }
					 else {
						 SingleLine->IRoi->SetOrgX  (IRoi->GetOrgX()  );
						 SingleLine->IRoi->SetOrgY  (IRoi->GetOrgY()  );
						 SingleLine->IRoi->SetWidth (IRoi->GetWidth() );
						 SingleLine->IRoi->SetHeight(IRoi->GetHeight());
						 ROI_H = IRoi->GetHeight();
						 if(ROI_H<700)  SingleLine->SetIncrement(50 );
						 else 	        SingleLine->SetIncrement(100);
					 }
					 SingleLine->SetOrientation(orWest);

					 // 						 if(IRoi->GetHeight()<350) SingleLine->SetIncrement(5 );
					 // 						 else                      SingleLine->SetIncrement(30);
					 // ORG
					 // 						 if(FShape==shRectC) Sing%leLine->SetIncrement(5  );
					 // 						 else                SingleLine->SetIncrement(100);

					 SingleLine->SetFindLineId(0);

					 if(IsMarkBtm) SingleLine->SetEdgeType(0); // Black to White 
					 else          SingleLine->SetEdgeType(1); // White to Black  
					 // 						 SingleLine->SetEdgeType(0); // Black To White 
					 SingleLine->OnExecute();
					 Line[0].FP0 = SingleLine->GetResultP0();
					 Line[0].FP1 = SingleLine->GetResultP1();

					 // Btm,Top 상관없이 첫번째
					 LeftOutLine[0].FP0.x = Line[0].FP0.x;
					 LeftOutLine[0].FP0.y = Line[0].FP0.y;
					 LeftOutLine[0].FP1.x = Line[0].FP1.x;
					 LeftOutLine[0].FP1.y = Line[0].FP1.y;

					 // LeftOutLine....make OutLine Data 
					 // 현재의 데이터를 넘겨준다 
					 // 검사중 기준라인을 찾지 못할경우 이전데이터 넘겨줘서 기준라인 생성함 
					 if(LeftOutLine[0].FP0.x!=0.0f && LeftOutLine[0].FP0.y!=0.0f && LeftOutLine[0].FP1.x!=0.0f && LeftOutLine[0].FP1.y!=0.0f){
						 PreLeftOutLine[0].FP0.x = LeftOutLine[0].FP0.x;    PreLeftOutLine[0].FP1.x = LeftOutLine[0].FP1.x;       
						 PreLeftOutLine[0].FP0.y = LeftOutLine[0].FP0.y;    PreLeftOutLine[0].FP1.y = LeftOutLine[0].FP1.y;       
					 } // 셀의 상단 시작부터 Broken 발생으로 데이터가 없는경우 
					 else if(LeftOutLine[0].FP0.x==0.0f || LeftOutLine[0].FP0.y==0.0f || LeftOutLine[0].FP1.x==0.0f || LeftOutLine[0].FP1.y==0.0f){
						 if(PreLeftOutLine[0].FP0.x==0.0f && PreLeftOutLine[0].FP0.y==0.0f && PreLeftOutLine[0].FP1.x==0.0f && PreLeftOutLine[0].FP1.y==0.0f){// 시작부분 Broken발생으로 데이터가 없는경우 
							 // Mark좌표를 기준으로 라인좌표값을 다시 설정함 
							 ROI_H = IRoi->GetHeight();
							 ROI_L = IRoi->GetOrgX()  ;
							 LeftOutLine[0].FP0.x = ROI_L;    LeftOutLine[0].FP0.y = 0.0f        ;
							 LeftOutLine[0].FP1.x = ROI_L;    LeftOutLine[0].FP1.y = (float)ROI_H;

							 //Line 데이터를 PreLine에 넘겨준다 
							 PreLeftOutLine[0].FP0.x = LeftOutLine[0].FP0.x;    PreLeftOutLine[0].FP1.x = LeftOutLine[0].FP1.x;       
							 PreLeftOutLine[0].FP0.y = LeftOutLine[0].FP0.y;    PreLeftOutLine[0].FP1.y = LeftOutLine[0].FP1.y;       
						 }
						 else { // 중간부분 Broken발생으로 데이터가 없는경우 
							 // PreLine 데이터를 넘겨줌 
							 LeftOutLine[0].FP0.x = PreLeftOutLine[0].FP0.x;  LeftOutLine[0].FP1.x = PreLeftOutLine[0].FP1.x;  
							 LeftOutLine[0].FP0.y = PreLeftOutLine[0].FP0.y;  LeftOutLine[0].FP1.y = PreLeftOutLine[0].FP1.y;  
						 }
					 }

					 // NOTCH CELL BTM Grind Line Search 
					 // 						 if(FShape!=shRectH){

					 if(IsAllGrind){
						 if(IsMarkBtm){ // LeftInLine, LeftTrackLine Search 
							 // LeftInLine Search Start 
							 EasyImage::Threshold(GImage,&BinaryImg, LeftEdgeThresHold);
							 SingleLine->GImage = &BinaryImg;

							 // 영역설정 
							 if(fabs(LeftOutLine[0].FP0.x - LeftOutLine[0].FP1.x) > 3){
								 LSP.x = (LeftOutLine[0].FP0.x + LeftOutLine[0].FP1.x)/2;
								 LSP.y = 0.0f;
							 }
							 else {
								 LSP = Math.OnIntersect(LeftOutLine[0].FP0, LeftOutLine[0].FP1, LT, RT);
							 }

							 SingleLine->IRoi->SetOrgX  ((int)LSP.x+3 );
							 SingleLine->IRoi->SetOrgY  (0            );
							 SingleLine->IRoi->SetWidth (100          );
							 SingleLine->IRoi->SetHeight(ImgH         );

							 if(((LSP.x+3)<=0) || ImgH<=0) return false;

							 // 								if(IRoi->GetHeight()<300) SingleLine->SetIncrement(5 );
							 // 								else                      SingleLine->SetIncrement(100);

							 if(FShape==shRectC) SingleLine->SetIncrement(5 );
							 else                SingleLine->SetIncrement(30);

							 // 연마량 측정 OutLine
							 SingleLine->SetFindLineId(0);
							 SingleLine->SetOrientation(orWest);
							 SingleLine->SetEdgeType(0); // Black to White 
							 SingleLine->OnExecute();
							 LeftInLine[0].FP0 = SingleLine->GetResultP0();
							 LeftInLine[0].FP1 = SingleLine->GetResultP1();

							 SingleLine->SetEdgeType(2); // Line Search Org 

							 // LeftInLine None....make InLine Data 
							 // 현재의 데이터를 넘겨준다 
							 if(LeftInLine[0].FP0.x!=0.0f && LeftInLine[0].FP0.y!=0.0f && LeftInLine[0].FP1.x!=0.0f && LeftInLine[0].FP1.y!=0.0f){
								 PreLeftInLine[0].FP0.x = LeftInLine[0].FP0.x;    PreLeftInLine[0].FP1.x = LeftInLine[0].FP1.x;       
								 PreLeftInLine[0].FP0.y = LeftInLine[0].FP0.y;    PreLeftInLine[0].FP1.y = LeftInLine[0].FP1.y;       
							 }
							 else if(LeftInLine[0].FP0.x==0.0f || LeftInLine[0].FP0.y==0.0f || LeftInLine[0].FP1.x==0.0f || LeftInLine[0].FP1.y==0.0f){
								 if(PreLeftInLine[0].FP0.x==0.0f && PreLeftInLine[0].FP0.y==0.0f && PreLeftInLine[0].FP1.x==0.0f && PreLeftInLine[0].FP1.y==0.0f){// 시작부분 Broken발생으로 데이터가 없는경우 
									 // Mark좌표를 기준으로 라인좌표값을 다시 설정함 
									 ROI_H = IRoi->GetHeight();
									 ROI_L = IRoi->GetOrgX()  ;
									 LeftInLine[0].FP0.x = ROI_L;   LeftInLine[0].FP0.y = 0.0f        ;
									 LeftInLine[0].FP1.x = ROI_L;   LeftInLine[0].FP1.y = (float)ROI_H;

									 //Line 데이터를 PreLine에 넘겨준다 
									 PreLeftInLine[0].FP0.x = LeftInLine[0].FP0.x;    PreLeftInLine[0].FP1.x = LeftInLine[0].FP1.x;       
									 PreLeftInLine[0].FP0.y = LeftInLine[0].FP0.y;    PreLeftInLine[0].FP1.y = LeftInLine[0].FP1.y;       
								 }
								 else {                                                                                                    // 중간부분 Broken발생으로 데이터가 없는경우 
									 // PreLine 데이터를 넘겨줌 
									 LeftInLine[0].FP0.x = PreLeftInLine[0].FP0.x;  LeftInLine[0].FP1.x = PreLeftInLine[0].FP1.x;  
									 LeftInLine[0].FP0.y = PreLeftInLine[0].FP0.y;  LeftInLine[0].FP1.y = PreLeftInLine[0].FP1.y;  
								 }
							 }
							 // NOTCH CELL Btm 검사에서만 연마폭 측정함 
							 Left_Grind_Width =(float)(Math.GetLengthFrLineToPoint (LeftOutLine[0].FP0,LeftOutLine[0].FP1, LeftInLine[0].FP0 ));

							 // Left TrackLine Search Start 
							 /////////////////////////////////////////////////////////////////////////////////////////////
							 // 									 BinaryImg.SetSize(GImage->GetWidth(), GImage->GetHeight());
							 // 									 EasyImage::Oper(EArithmeticLogicOperation_Copy,GImage,&BinaryImg);
							 EasyImage::Threshold(GImage,&BinaryImg, CirGrindMeaThresHold);
							 SingleLine->GImage = &BinaryImg;

							 // 영역설정 
							 if(fabs(LeftInLine[0].FP0.x - LeftInLine[0].FP1.x) > 3){
								 LSP.x = (LeftInLine[0].FP0.x + LeftInLine[0].FP1.x)/2;
								 LSP.y = 0.0f;
							 }
							 else {
								 LSP = Math.OnIntersect(LeftInLine[0].FP0, LeftInLine[0].FP1, LT, RT);
							 }

							 SingleLine->IRoi->SetOrgX  ((int)LSP.x+3 );
							 SingleLine->IRoi->SetOrgY  (0            );
							 SingleLine->IRoi->SetWidth (100          );
							 SingleLine->IRoi->SetHeight(ImgH         );

							 if(((LSP.x+3)<=0) || ImgH<=0) return false;

							 if(IRoi->GetHeight()<300) SingleLine->SetIncrement(5 );
							 else                      SingleLine->SetIncrement(100);

							 // Left Track Line Search 
							 SingleLine->SetFindLineId(0);
							 SingleLine->SetOrientation(orWest);
							 SingleLine->SetEdgeType(1); // White To Black  
							 SingleLine->OnExecute();
							 LeftTrackLine[0].FP0 = SingleLine->GetResultP0();
							 LeftTrackLine[0].FP1 = SingleLine->GetResultP1();

							 SingleLine->SetEdgeType(2); // Line Search Type Normal 

							 // LeftTrackLine....make OutLine Data 
							 // 현재의 데이터를 넘겨준다 
							 // 검사중 기준라인을 찾지 못할경우 이전데이터 넘겨줘서 기준라인 생성함 
							 if(LeftTrackLine[0].FP0.x!=0.0f && LeftTrackLine[0].FP0.y!=0.0f && LeftTrackLine[0].FP1.x!=0.0f && LeftTrackLine[0].FP1.y!=0.0f){
								 PreLeftTrackLine[0].FP0.x = LeftTrackLine[0].FP0.x;    PreLeftTrackLine[0].FP1.x = LeftTrackLine[0].FP1.x;       
								 PreLeftTrackLine[0].FP0.y = LeftTrackLine[0].FP0.y;    PreLeftTrackLine[0].FP1.y = LeftTrackLine[0].FP1.y;       
							 } // 셀의 상단 시작부터 Broken 발생으로 데이터가 없는경우 
							 else if(LeftTrackLine[0].FP0.x==0.0f || LeftTrackLine[0].FP0.y==0.0f || LeftTrackLine[0].FP1.x==0.0f || LeftTrackLine[0].FP1.y==0.0f){
								 if(PreLeftTrackLine[0].FP0.x==0.0f && PreLeftTrackLine[0].FP0.y==0.0f && PreLeftTrackLine[0].FP1.x==0.0f && PreLeftTrackLine[0].FP1.y==0.0f){// 시작부분 Broken발생으로 데이터가 없는경우 
									 // Mark좌표를 기준으로 라인좌표값을 다시 설정함 
									 ROI_H = IRoi->GetHeight();
									 ROI_L = IRoi->GetOrgX()  ;
									 LeftTrackLine[0].FP0.x = ROI_L;    LeftTrackLine[0].FP0.y = 0.0f        ;
									 LeftTrackLine[0].FP1.x = ROI_L;    LeftTrackLine[0].FP1.y = (float)ROI_H;

									 //LeftTrackLine 데이터를 PreLeftTrackLine에 넘겨준다 
									 PreLeftTrackLine[0].FP0.x = LeftTrackLine[0].FP0.x;    PreLeftTrackLine[0].FP1.x = LeftTrackLine[0].FP1.x;       
									 PreLeftTrackLine[0].FP0.y = LeftTrackLine[0].FP0.y;    PreLeftTrackLine[0].FP1.y = LeftTrackLine[0].FP1.y;       
								 }
								 else { // 중간부분 Broken발생으로 데이터가 없는경우 
									 // PreLeftTrackLine 데이터를 넘겨줌 
									 LeftTrackLine[0].FP0.x = PreLeftTrackLine[0].FP0.x;  LeftTrackLine[0].FP1.x = PreLeftTrackLine[0].FP1.x;  
									 LeftTrackLine[0].FP0.y = PreLeftTrackLine[0].FP0.y;  LeftTrackLine[0].FP1.y = PreLeftTrackLine[0].FP1.y;  
								 }
							 }
							 // NOTCH CELL Btm 검사에서만 연마폭 측정함 
							 Left_Grind_Mea =(float)(Math.GetLengthFrLineToPoint (LeftOutLine[0].FP0,LeftOutLine[0].FP1, LeftTrackLine[0].FP0 ));

							 // 마크라인에서 부터 LeftTrackLine 까지 거리 산출 
							 // LeftTrackLine Data 존재할 경우 거리 측정함 
							 if(LeftTrackLine[0].FP0.x!=0.0f && LeftTrackLine[0].FP0.y!=0.0f && LeftTrackLine[0].FP1.x!=0.0f && LeftTrackLine[0].FP1.y!=0.0f){
								 // 									LeftTrackLine[0].FP0.y = LeftTrackLine[0].FP0.y + ImageHeight; //전체 이미지 기준 y좌표
								 // 									LeftTrackLine[0].FP1.y = LeftTrackLine[0].FP1.y + ImageHeight; //전체 이미지 기준 y좌표
								 // 
								 // 									MarkToTrackLineDis1 = Math.GetLengthFrLineToPoint(LeftMarkSta, LeftMarkEnd, LeftTrackLine[0].FP0);//Mark라인에서 TrackLine거리 
								 // 									MarkToTrackLineDis2 = Math.GetLengthFrLineToPoint(LeftMarkSta, LeftMarkEnd, LeftTrackLine[0].FP1);//Mark라인에서 TrackLine거리 
								 // 
								 // 									TotalLeftTrackDis  +=  (int)((MarkToTrackLineDis1 + MarkToTrackLineDis2)/2.0); //Mark라인에서 TrackLine거리 누적                   
								 // 									LeftTrackLineCount++; //누적 카운트 증가
								 // 
								 // 									// Org Data 
								 // 									LeftTrackLine[0].FP0.y = LeftTrackLine[0].FP0.y - ImageHeight; //Frame 이미지 기준 y좌표 원복
								 // 									LeftTrackLine[0].FP1.y = LeftTrackLine[0].FP1.y - ImageHeight; //Frame 이미지 기준 y좌표 원복 
							 }
						 }
						 else { //EnCap(Top영역) LeftInLine Search , LeftTrackLine Data Overlap 
							 // LeftInLine Search Start 
							 EasyImage::Threshold(GImage,&BinaryImg, LeftEdgeThresHold);
							 SingleLine->GImage = &BinaryImg;

							 // 영역설정 
							 if(fabs(LeftOutLine[0].FP0.x - LeftOutLine[0].FP1.x) > 3){
								 LSP.x = (LeftOutLine[0].FP0.x + LeftOutLine[0].FP1.x)/2;
								 LSP.y = 0.0f;
							 }
							 else {
								 LSP = Math.OnIntersect(LeftOutLine[0].FP0, LeftOutLine[0].FP1, LT, RT);
							 }

							 SingleLine->IRoi->SetOrgX  ((int)LSP.x+3 );
							 SingleLine->IRoi->SetOrgY  (0            );
							 SingleLine->IRoi->SetWidth (100          );
							 SingleLine->IRoi->SetHeight(ImgH         );

							 if(((LSP.x+3)<=0) || ImgH<=0) return false;

							 // 								if(IRoi->GetHeight()<300) SingleLine->SetIncrement(5 );
							 // 								else                      SingleLine->SetIncrement(100);

							 if(FShape==shRectC) SingleLine->SetIncrement(5 );
							 else                SingleLine->SetIncrement(30);

							 // 연마량 측정 OutLine
							 SingleLine->SetFindLineId(0);
							 SingleLine->SetOrientation(orWest);
							 SingleLine->SetEdgeType(0); // Black to White 
							 SingleLine->OnExecute();
							 LeftInLine[0].FP0 = SingleLine->GetResultP0();
							 LeftInLine[0].FP1 = SingleLine->GetResultP1();

							 SingleLine->SetEdgeType(2); // Line Search Org 

							 // LeftInLine None....make InLine Data 
							 // 현재의 데이터를 넘겨준다 
							 if(LeftInLine[0].FP0.x!=0.0f && LeftInLine[0].FP0.y!=0.0f && LeftInLine[0].FP1.x!=0.0f && LeftInLine[0].FP1.y!=0.0f){
								 PreLeftInLine[0].FP0.x = LeftInLine[0].FP0.x;    PreLeftInLine[0].FP1.x = LeftInLine[0].FP1.x;       
								 PreLeftInLine[0].FP0.y = LeftInLine[0].FP0.y;    PreLeftInLine[0].FP1.y = LeftInLine[0].FP1.y;       
							 }
							 else if(LeftInLine[0].FP0.x==0.0f || LeftInLine[0].FP0.y==0.0f || LeftInLine[0].FP1.x==0.0f || LeftInLine[0].FP1.y==0.0f){
								 if(PreLeftInLine[0].FP0.x==0.0f && PreLeftInLine[0].FP0.y==0.0f && PreLeftInLine[0].FP1.x==0.0f && PreLeftInLine[0].FP1.y==0.0f){// 시작부분 Broken발생으로 데이터가 없는경우 
									 // Mark좌표를 기준으로 라인좌표값을 다시 설정함 
									 ROI_H = IRoi->GetHeight();
									 ROI_L = IRoi->GetOrgX()  ;
									 LeftInLine[0].FP0.x = ROI_L;   LeftInLine[0].FP0.y = 0.0f        ;
									 LeftInLine[0].FP1.x = ROI_L;   LeftInLine[0].FP1.y = (float)ROI_H;

									 //Line 데이터를 PreLine에 넘겨준다 
									 PreLeftInLine[0].FP0.x = LeftInLine[0].FP0.x;    PreLeftInLine[0].FP1.x = LeftInLine[0].FP1.x;       
									 PreLeftInLine[0].FP0.y = LeftInLine[0].FP0.y;    PreLeftInLine[0].FP1.y = LeftInLine[0].FP1.y;       
								 }
								 else {                                                                                                    // 중간부분 Broken발생으로 데이터가 없는경우 
									 // PreLine 데이터를 넘겨줌 
									 LeftInLine[0].FP0.x = PreLeftInLine[0].FP0.x;  LeftInLine[0].FP1.x = PreLeftInLine[0].FP1.x;  
									 LeftInLine[0].FP0.y = PreLeftInLine[0].FP0.y;  LeftInLine[0].FP1.y = PreLeftInLine[0].FP1.y;  
								 }
							 }
							 // NOTCH CELL Btm 검사에서만 연마폭 측정함 
							 Left_Grind_Width =(float)(Math.GetLengthFrLineToPoint (LeftOutLine[0].FP0,LeftOutLine[0].FP1, LeftInLine[0].FP0 ));

							 //LeftTrackLine Data Overlap 
							 /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
							 if(AvgLeftTrackLineDis!=0){
								 // 									LeftOutLine[0].FP0.y = LeftOutLine[0].FP0.y + ImageHeight; //전체 이미지 기준 y좌표
								 // 									LeftOutLine[0].FP1.y = LeftOutLine[0].FP1.y + ImageHeight; //전체 이미지 기준 y좌표
								 // 
								 // 									MarkToTrackLineDis1 = Math.GetLengthFrLineToPoint(LeftMarkSta, LeftMarkEnd, LeftOutLine[0].FP0);//Mark라인에서 OutLine까지 거리 
								 // 									MarkToTrackLineDis2 = Math.GetLengthFrLineToPoint(LeftMarkSta, LeftMarkEnd, LeftOutLine[0].FP1);//Mark라인에서 OutLine까지 거리 
								 // 
								 // 									if(MarkToTrackLineDis1>AvgLeftTrackLineDis) LeftTrackLine[0].FP0.x = LeftOutLine[0].FP0.x+(MarkToTrackLineDis1 - AvgLeftTrackLineDis);
								 // 									if(MarkToTrackLineDis2>AvgLeftTrackLineDis) LeftTrackLine[0].FP1.x = LeftOutLine[0].FP1.x+(MarkToTrackLineDis2 - AvgLeftTrackLineDis);
								 // 
								 // 									// LeftOutLine Data 원본 
								 // 									LeftOutLine[0].FP0.y = LeftOutLine[0].FP0.y - ImageHeight; 
								 // 									LeftOutLine[0].FP1.y = LeftOutLine[0].FP1.y - ImageHeight; 
								 // 
								 // 									LeftTrackLine[0].FP0.y = LeftOutLine[0].FP0.y;
								 // 									LeftTrackLine[0].FP1.y = LeftOutLine[0].FP1.y;
								 /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
							 }
						 }
					 }
					 else {
						 if(IsMarkBtm){ //LeftTrackLine Search 
							 if(FInspectMode==Insp_Track){
								 //BinaryImg.SetSize(GImage->GetWidth(), GImage->GetHeight());
								 //EasyImage::Oper(EArithmeticLogicOperation_Copy,GImage,&BinaryImg);
								 EasyImage::Threshold(GImage,&BinaryImg, CirGrindMeaThresHold);

								 // LeftOutLine 기준 LeftTrackLine 검출 
								 SingleLine->GImage = &BinaryImg;

								 // 영역설정 
								 if(fabs(LeftOutLine[0].FP0.x - LeftOutLine[0].FP1.x) > 3){
									 LSP.x = (LeftOutLine[0].FP0.x + LeftOutLine[0].FP1.x)/2;
									 LSP.y = 0.0f;
								 }
								 else {
									 LSP = Math.OnIntersect(LeftOutLine[0].FP0, LeftOutLine[0].FP1, LT, RT);
								 }

								 if(FShape==shRectC){
									 SingleLine->IRoi->SetOrgX  ((int)LSP.x+3 );
									 SingleLine->IRoi->SetOrgY  (0            );
									 SingleLine->IRoi->SetWidth (47           );
									 SingleLine->IRoi->SetHeight(FEndLine-CSideCircleHeight);
									 SingleLine->SetIncrement(1 );
									 if(((LSP.x+3)<=0) || ImgH<=0) return false;
								 }
								 else {
									 SingleLine->IRoi->SetOrgX  ((int)LSP.x+3 );
									 SingleLine->IRoi->SetOrgY  (0            );
									 SingleLine->IRoi->SetWidth (47           );
									 SingleLine->IRoi->SetHeight(ImgH         );
									 SingleLine->SetIncrement(50);
									 if(((LSP.x+3)<=0) || ImgH<=0) return false;
								 }

								 // Left Track Line Search 
								 SingleLine->SetFindLineId(0);
								 SingleLine->SetOrientation(orWest);
								 SingleLine->SetEdgeType(1); // White To Black  
								 SingleLine->OnExecute();
								 LeftTrackLine[0].FP0 = SingleLine->GetResultP0();
								 LeftTrackLine[0].FP1 = SingleLine->GetResultP1();

								 SingleLine->SetEdgeType(2); // Line Search Type Normal 

								 // LeftTrackLine....Make OutLine Data 
								 // 현재의 데이터를 넘겨준다 
								 // 검사중 기준라인을 찾지 못할경우 이전데이터 넘겨줘서 기준라인 생성함 
								 if(LeftTrackLine[0].FP0.x!=0.0f && LeftTrackLine[0].FP0.y!=0.0f && LeftTrackLine[0].FP1.x!=0.0f && LeftTrackLine[0].FP1.y!=0.0f){
									 PreLeftTrackLine[0].FP0.x = LeftTrackLine[0].FP0.x;    PreLeftTrackLine[0].FP1.x = LeftTrackLine[0].FP1.x;       
									 PreLeftTrackLine[0].FP0.y = LeftTrackLine[0].FP0.y;    PreLeftTrackLine[0].FP1.y = LeftTrackLine[0].FP1.y;       
								 } // 셀의 상단 시작부터 Broken 발생으로 데이터가 없는경우 
								 else if(LeftTrackLine[0].FP0.x==0.0f || LeftTrackLine[0].FP0.y==0.0f || LeftTrackLine[0].FP1.x==0.0f || LeftTrackLine[0].FP1.y==0.0f){
									 if(PreLeftTrackLine[0].FP0.x==0.0f && PreLeftTrackLine[0].FP0.y==0.0f && PreLeftTrackLine[0].FP1.x==0.0f && PreLeftTrackLine[0].FP1.y==0.0f){// 시작부분 Broken발생으로 데이터가 없는경우 
										 // Mark좌표를 기준으로 라인좌표값을 다시 설정함 
										 ROI_H = IRoi->GetHeight();
										 ROI_L = IRoi->GetOrgX()  ;
										 LeftTrackLine[0].FP0.x = ROI_L;    LeftTrackLine[0].FP0.y = 0.0f        ;
										 LeftTrackLine[0].FP1.x = ROI_L;    LeftTrackLine[0].FP1.y = (float)ROI_H;

										 //LeftTrackLine 데이터를 PreLeftTrackLine에 넘겨준다 
										 PreLeftTrackLine[0].FP0.x = LeftTrackLine[0].FP0.x;    PreLeftTrackLine[0].FP1.x = LeftTrackLine[0].FP1.x;       
										 PreLeftTrackLine[0].FP0.y = LeftTrackLine[0].FP0.y;    PreLeftTrackLine[0].FP1.y = LeftTrackLine[0].FP1.y;       
									 }
									 else { // 중간부분 Broken발생으로 데이터가 없는경우 
										 // PreLeftTrackLine 데이터를 넘겨줌 
										 LeftTrackLine[0].FP0.x = PreLeftTrackLine[0].FP0.x;  LeftTrackLine[0].FP1.x = PreLeftTrackLine[0].FP1.x;  
										 LeftTrackLine[0].FP0.y = PreLeftTrackLine[0].FP0.y;  LeftTrackLine[0].FP1.y = PreLeftTrackLine[0].FP1.y;  
									 }
								 }

								 // 마크라인에서 부터 LeftTrackLine 까지 거리 산출 
								 // LeftTrackLine Data 존재할 경우 거리 측정함 
								 // Image Rotate 없음
								 // 외곽기준으로 EnCap에 데이터 오버랩 목적으로 데이터 계산함 
								 if(LeftTrackLine[0].FP0.x!=0.0f && LeftTrackLine[0].FP0.y!=0.0f && LeftTrackLine[0].FP1.x!=0.0f && LeftTrackLine[0].FP1.y!=0.0f){
									 if(LeftOutLine[0].FP0.x!=0.0f && LeftOutLine[0].FP0.y!=0.0f && LeftOutLine[0].FP1.x!=0.0f && LeftOutLine[0].FP1.y!=0.0f){
										 LeftToTrackLineDis1 = Math.GetLengthFrLineToPoint(LeftOutLine[0].FP0, LeftOutLine[0].FP1, LeftTrackLine[0].FP0);//외곽라인에서 TrackLine거리 
										 LeftToTrackLineDis2 = Math.GetLengthFrLineToPoint(LeftOutLine[0].FP0, LeftOutLine[0].FP1, LeftTrackLine[0].FP1);//외곽라인에서 TrackLine거리 

										 TotalLeftTrackDis  +=  (int)((LeftToTrackLineDis1 + LeftToTrackLineDis2)/2.0); //Mark라인에서 TrackLine거리 누적                   
										 LeftTrackLineCount++; //누적 카운트 증가
									 }
								 }
							 }
						 }
						 else {//EnCap(Top영역) LeftTrackLine Data Overlap 
							 //LeftTrackLine Data Overlap 
							 /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
							 if(AvgLeftTrackLineDis!=0){
								 if(FInspectMode==Insp_Track){ // TrackMode 외곽라인 기준  
									 if(LeftOutLine[0].FP0.x!=0.0f && LeftOutLine[0].FP0.y!=0.0f && LeftOutLine[0].FP1.x!=0.0f && LeftOutLine[0].FP1.y!=0.0f){
										 // TOP영역 LeftTrackLine x좌표 
										 LeftTrackLine[0].FP0.x = LeftOutLine[0].FP0.x+AvgLeftTrackLineDis;
										 LeftTrackLine[0].FP1.x = LeftOutLine[0].FP1.x+AvgLeftTrackLineDis;

										 // TOP영역 LeftTrackLine y좌표 
										 LeftTrackLine[0].FP0.y = LeftOutLine[0].FP0.y;
										 LeftTrackLine[0].FP1.y = LeftOutLine[0].FP1.y;
									 }
								 }
							 }
						 }
					 }
                 }
                 if (FTopWall) { // NOTCH 
					 EasyImage::Threshold(GImage,&BinaryImg, TopEdgeThresHold);
					 if(TopEdgeThresHold==0)  {SingleLine->GImage = GImage;     SingleLine->FThreshold =5 ;}
					 else                     {SingleLine->GImage = &BinaryImg; SingleLine->FThreshold =10;}

					 SingleLine->IRoi->SetOrgX  (IRoi->GetOrgX());
					 SingleLine->IRoi->SetOrgY  (IRoi->GetOrgY());
					 SingleLine->IRoi->SetWidth (IRoi->GetWidth());
					 SingleLine->IRoi->SetHeight(IRoi->GetHeight());
					 if(IRoi->GetOrgX()<=0 || IRoi->GetWidth()<=0 || IRoi->GetHeight()<=0){
						 return false;
					 }

					 SingleLine->SetOrientation(orNorth);
					 SingleLine->FIncrement =100;
					 SingleLine->SetFindLineId(0);
					 SingleLine->FThreshold =5;

					 if(FCutMode==Normal_Cut) SingleLine->SetEdgeType(0);  // Black To White
					 if(FCutMode==CAI_Cut   ) SingleLine->SetEdgeType(1);  // White To Black 

					 SingleLine->OnExecute();
					 Line[1].FP0 = SingleLine->GetResultP0();
					 Line[1].FP1 = SingleLine->GetResultP1();
				 }
                 if (FRightWall) { //NOTCH 
					 EasyImage::Threshold(GImage,&BinaryImg, RightEdgeThresHold);
					 if(LeftEdgeThresHold==0) {SingleLine->GImage = GImage;     SingleLine->FThreshold =5 ;}
					 else                     {SingleLine->GImage = &BinaryImg; SingleLine->FThreshold =10;}

					 // 영상이상함 Test목적...나중에 소스 지워야함 
					 // 						 if(IsMarkBtm) SingleLine->SetEdgeType(0); // Black to White 
					 // 						 else          SingleLine->SetEdgeType(1); // White to Black  

					 if(FShape==shRectC){
						 SingleLine->IRoi->SetOrgX  (IRoi->GetOrgX()          );
						 SingleLine->IRoi->SetOrgY  (IRoi->GetOrgY()          );
						 SingleLine->IRoi->SetWidth (IRoi->GetWidth()         );
						 SingleLine->IRoi->SetHeight(FEndLine-CSideCircleHeight);
						 SingleLine->SetIncrement(1 );
					 }
					 else if(FShape==shRectH){
						 if(IsCircleTop){
							 SingleLine->IRoi->SetOrgX  (IRoi->GetOrgX()  );
							 SingleLine->IRoi->SetOrgY  (ASideCircleHeight+50);
							 SingleLine->IRoi->SetWidth (IRoi->GetWidth() );
							 SingleLine->IRoi->SetHeight(ImgH-(ASideCircleHeight+50));
							 SingleLine->SetIncrement(1 );
						 }
						 else {
							 SingleLine->IRoi->SetOrgX  (IRoi->GetOrgX()  );
							 SingleLine->IRoi->SetOrgY  (IRoi->GetOrgY()  );
							 SingleLine->IRoi->SetWidth (IRoi->GetWidth() );
							 SingleLine->IRoi->SetHeight(IRoi->GetHeight());
							 SingleLine->SetIncrement(50 );
						 }
					 }
					 else {
						 SingleLine->IRoi->SetOrgX  (IRoi->GetOrgX());
						 SingleLine->IRoi->SetOrgY  (IRoi->GetOrgY());
						 SingleLine->IRoi->SetWidth (IRoi->GetWidth());
						 SingleLine->IRoi->SetHeight(IRoi->GetHeight());
						 ROI_H = IRoi->GetHeight();
						 if(ROI_H<700)  SingleLine->SetIncrement(50 );
						 else 	        SingleLine->SetIncrement(100);
					 }

					 SingleLine->SetOrientation(orEast);
					 // org 
					 // 						 if(IRoi->GetHeight()<350) SingleLine->SetIncrement(5 );
					 // 						 else                      SingleLine->SetIncrement(30);

					 SingleLine->SetFindLineId(0);
					 SingleLine->FThreshold =10;
					 // 						 SingleLine->SetEdgeType(1);  // White To Black 
					 // TEST 
					 if(IsMarkBtm) SingleLine->SetEdgeType(0); // Black to White 
					 else          SingleLine->SetEdgeType(1); // White to Black  

					 SingleLine->OnExecute();
					 Line[2].FP0 = SingleLine->GetResultP0();
					 Line[2].FP1 = SingleLine->GetResultP1();

					 // Btm,Top 상관없이 첫번째
					 RightOutLine[0].FP0.x = Line[2].FP0.x;
					 RightOutLine[0].FP0.y = Line[2].FP0.y;
					 RightOutLine[0].FP1.x = Line[2].FP1.x;
					 RightOutLine[0].FP1.y = Line[2].FP1.y;

					 // LeftOutLine....make OutLine Data 
					 // 현재의 데이터를 넘겨준다 
					 // 검사중 기준라인을 찾지 못할경우 이전데이터 넘겨줘서 기준라인 생성함 
					 if(RightOutLine[0].FP0.x!=0.0f && RightOutLine[0].FP0.y!=0.0f && RightOutLine[0].FP1.x!=0.0f && RightOutLine[0].FP1.y!=0.0f){
						 PreRightOutLine[0].FP0.x = RightOutLine[0].FP0.x;    PreRightOutLine[0].FP1.x = RightOutLine[0].FP1.x;       
						 PreRightOutLine[0].FP0.y = RightOutLine[0].FP0.y;    PreRightOutLine[0].FP1.y = RightOutLine[0].FP1.y;       
					 } // 셀의 상단 시작부터 Broken 발생으로 데이터가 없는경우 
					 else if(RightOutLine[0].FP0.x==0.0f || RightOutLine[0].FP0.y==0.0f || RightOutLine[0].FP1.x==0.0f || RightOutLine[0].FP1.y==0.0f){
						 if(PreRightOutLine[0].FP0.x==0.0f && PreRightOutLine[0].FP0.y==0.0f && PreRightOutLine[0].FP1.x==0.0f && PreRightOutLine[0].FP1.y==0.0f){// 시작부분 Broken발생으로 데이터가 없는경우 
							 // Mark좌표를 기준으로 라인좌표값을 다시 설정함 
							 ROI_H = IRoi->GetHeight();
							 RightOutLine[0].FP0.x = Line[2].FP0.x;    RightOutLine[0].FP0.y = 0.0f        ;
							 RightOutLine[0].FP1.x = Line[2].FP1.x;    RightOutLine[0].FP1.y = (float)ROI_H;

							 //Line 데이터를 PreLine에 넘겨준다 
							 PreRightOutLine[0].FP0.x = RightOutLine[0].FP0.x;    PreRightOutLine[0].FP1.x = RightOutLine[0].FP1.x;       
							 PreRightOutLine[0].FP0.y = RightOutLine[0].FP0.y;    PreRightOutLine[0].FP1.y = RightOutLine[0].FP1.y;       
						 }
						 else { // 중간부분 Broken발생으로 데이터가 없는경우 
							 // PreLine 데이터를 넘겨줌 
							 RightOutLine[0].FP0.x = PreRightOutLine[0].FP0.x;  RightOutLine[0].FP1.x = PreRightOutLine[0].FP1.x;  
							 RightOutLine[0].FP0.y = PreRightOutLine[0].FP0.y;  RightOutLine[0].FP1.y = PreRightOutLine[0].FP1.y;  
						 }
					 }

					 if(IsAllGrind){
						 if(IsMarkBtm){ // RightInLine, RightTrackLine Search 
							 // RightInLine Search Start 
							 /////////////////////////////////////////////////////////////////////////////
							 EasyImage::Threshold(GImage,&BinaryImg, RightEdgeThresHold);
							 SingleLine->GImage = &BinaryImg;

							 // 영역설정 
							 if(fabs(RightOutLine[0].FP0.x - RightOutLine[0].FP1.x) > 3){
								 LSP.x = (RightOutLine[0].FP0.x + RightOutLine[0].FP1.x)/2;
								 LSP.y = 0.0f;
							 }
							 else {
								 LSP = Math.OnIntersect(RightOutLine[0].FP0, RightOutLine[0].FP1, LT, RT);
							 }

							 SingleLine->IRoi->SetOrgX  ((int)LSP.x-100);
							 SingleLine->IRoi->SetOrgY  (0             );
							 SingleLine->IRoi->SetWidth (97            );
							 SingleLine->IRoi->SetHeight(ImgH          );

							 if(((LSP.x+3)<=0) || ImgH<=0) return false;

							 if(IRoi->GetHeight()<300) SingleLine->SetIncrement(5 );
							 else                      SingleLine->SetIncrement(100);

							 // 연마량 측정 OutLine
							 SingleLine->SetFindLineId(0);
							 SingleLine->SetOrientation(orEast);
							 SingleLine->SetEdgeType(0); // Black to White 
							 SingleLine->OnExecute();
							 RightInLine[0].FP0 = SingleLine->GetResultP0();
							 RightInLine[0].FP1 = SingleLine->GetResultP1();

							 SingleLine->SetEdgeType(2); // Line Search Org 

							 // RightInLine None....make InLine Data 
							 // 현재의 데이터를 넘겨준다 
							 if(RightInLine[0].FP0.x!=0.0f && RightInLine[0].FP0.y!=0.0f && RightInLine[0].FP1.x!=0.0f && RightInLine[0].FP1.y!=0.0f){
								 PreRightInLine[0].FP0.x = RightInLine[0].FP0.x;    PreRightInLine[0].FP1.x = RightInLine[0].FP1.x;       
								 PreRightInLine[0].FP0.y = RightInLine[0].FP0.y;    PreRightInLine[0].FP1.y = RightInLine[0].FP1.y;       
							 }
							 else if(RightInLine[0].FP0.x==0.0f || RightInLine[0].FP0.y==0.0f || RightInLine[0].FP1.x==0.0f || RightInLine[0].FP1.y==0.0f){
								 if(PreRightInLine[0].FP0.x==0.0f && PreRightInLine[0].FP0.y==0.0f && PreRightInLine[0].FP1.x==0.0f && PreRightInLine[0].FP1.y==0.0f){// 시작부분 Broken발생으로 데이터가 없는경우 
									 // Mark좌표를 기준으로 라인좌표값을 다시 설정함 
									 ROI_H = IRoi->GetHeight();
									 ROI_L = IRoi->GetOrgX()  ;
									 RightInLine[0].FP0.x = ROI_L;   RightInLine[0].FP0.y = 0.0f        ;
									 RightInLine[0].FP1.x = ROI_L;   RightInLine[0].FP1.y = (float)ROI_H;

									 //Line 데이터를 PreLine에 넘겨준다 
									 PreRightInLine[0].FP0.x = RightInLine[0].FP0.x;    PreRightInLine[0].FP1.x = RightInLine[0].FP1.x;       
									 PreRightInLine[0].FP0.y = RightInLine[0].FP0.y;    PreRightInLine[0].FP1.y = RightInLine[0].FP1.y;       
								 }
								 else {                                                                                                    // 중간부분 Broken발생으로 데이터가 없는경우 
									 // PreLine 데이터를 넘겨줌 
									 RightInLine[0].FP0.x = PreRightInLine[0].FP0.x;  RightInLine[0].FP1.x = PreRightInLine[0].FP1.x;  
									 RightInLine[0].FP0.y = PreRightInLine[0].FP0.y;  RightInLine[0].FP1.y = PreRightInLine[0].FP1.y;  
								 }
							 }
							 // NOTCH CELL Btm 검사에서만 연마폭 측정함 
							 Right_Grind_Width =(float)(Math.GetLengthFrLineToPoint (RightOutLine[0].FP0,RightOutLine[0].FP1, RightInLine[0].FP0 ));
							 // RightInLine Search End
							 /////////////////////////////////////////////////////////////////////////////


							 // Right TrackLine Search 
							 /////////////////////////////////////////////////////////////////////////////////////////////
							 // 									 BinaryImg.SetSize(GImage->GetWidth(), GImage->GetHeight());
							 // 									 EasyImage::Oper(EArithmeticLogicOperation_Copy,GImage,&BinaryImg);
							 EasyImage::Threshold(GImage,&BinaryImg, CirGrindMeaThresHold);
							 SingleLine->GImage = &BinaryImg;

							 // 영역설정 
							 if(fabs(RightInLine[0].FP0.x - RightInLine[0].FP1.x) > 3){
								 LSP.x = (RightInLine[0].FP0.x + RightInLine[0].FP1.x)/2;
								 LSP.y = 0.0f;
							 }
							 else {
								 LSP = Math.OnIntersect(RightInLine[0].FP0, RightInLine[0].FP1, LT, RT);
							 }

							 SingleLine->IRoi->SetOrgX  ((int)LSP.x-100);
							 SingleLine->IRoi->SetOrgY  (0             );
							 SingleLine->IRoi->SetWidth (97            );
							 SingleLine->IRoi->SetHeight(ImgH          );

							 if(((LSP.x+3)<=0) || ImgH<=0) return false;

							 if(IRoi->GetHeight()<300) SingleLine->SetIncrement(5 );
							 else                      SingleLine->SetIncrement(100);

							 // 연마량 측정 OutLine
							 SingleLine->SetFindLineId(0);
							 SingleLine->SetOrientation(orEast);
							 SingleLine->SetEdgeType(1); // White To Black  
							 SingleLine->OnExecute();
							 RightTrackLine[0].FP0 = SingleLine->GetResultP0();
							 RightTrackLine[0].FP1 = SingleLine->GetResultP1();

							 SingleLine->SetEdgeType(2); // Line Search Org 

							 // RightTrackLine....make OutLine Data 
							 // 현재의 데이터를 넘겨준다 
							 // 검사중 기준라인을 찾지 못할경우 이전데이터 넘겨줘서 기준라인 생성함 
							 if(RightTrackLine[0].FP0.x!=0.0f && RightTrackLine[0].FP0.y!=0.0f && RightTrackLine[0].FP1.x!=0.0f && RightTrackLine[0].FP1.y!=0.0f){
								 PreRightTrackLine[0].FP0.x = RightTrackLine[0].FP0.x;    PreRightTrackLine[0].FP1.x = RightTrackLine[0].FP1.x;       
								 PreRightTrackLine[0].FP0.y = RightTrackLine[0].FP0.y;    PreRightTrackLine[0].FP1.y = RightTrackLine[0].FP1.y;       
							 } // 셀의 상단 시작부터 Broken 발생으로 데이터가 없는경우 
							 else if(RightTrackLine[0].FP0.x==0.0f || RightTrackLine[0].FP0.y==0.0f || RightTrackLine[0].FP1.x==0.0f || RightTrackLine[0].FP1.y==0.0f){
								 if(PreRightTrackLine[0].FP0.x==0.0f && PreRightTrackLine[0].FP0.y==0.0f && PreRightTrackLine[0].FP1.x==0.0f && PreRightTrackLine[0].FP1.y==0.0f){// 시작부분 Broken발생으로 데이터가 없는경우 
									 // Mark좌표를 기준으로 라인좌표값을 다시 설정함 
									 ROI_H = IRoi->GetHeight();
									 ROI_L = IRoi->GetOrgX()  ;
									 RightTrackLine[0].FP0.x = ROI_L;    RightTrackLine[0].FP0.y = 0.0f        ;
									 RightTrackLine[0].FP1.x = ROI_L;    RightTrackLine[0].FP1.y = (float)ROI_H;

									 //RightTrackLine 데이터를 PreRightTrackLine에 넘겨준다 
									 PreRightTrackLine[0].FP0.x = RightTrackLine[0].FP0.x;    PreRightTrackLine[0].FP1.x = RightTrackLine[0].FP1.x;       
									 PreRightTrackLine[0].FP0.y = RightTrackLine[0].FP0.y;    PreRightTrackLine[0].FP1.y = RightTrackLine[0].FP1.y;       
								 }
								 else { // 중간부분 Broken발생으로 데이터가 없는경우 
									 // PreRightTrackLine 데이터를 넘겨줌 
									 RightTrackLine[0].FP0.x = PreRightTrackLine[0].FP0.x;  RightTrackLine[0].FP1.x = PreRightTrackLine[0].FP1.x;  
									 RightTrackLine[0].FP0.y = PreRightTrackLine[0].FP0.y;  RightTrackLine[0].FP1.y = PreRightTrackLine[0].FP1.y;  
								 }
							 }
							 // NOTCH CELL Btm 검사에서만 연마폭 측정함 
							 Right_Grind_Mea =(float)(Math.GetLengthFrLineToPoint (RightOutLine[0].FP0,RightOutLine[0].FP1,RightTrackLine[0].FP0));
							 // RightInLine Search End 
							 /////////////////////////////////////////////////////////////////////////////


							 // 마크라인에서 부터 RightTrackLine 까지 거리 산출 
							 // RightTrackLine Data 존재할 경우 거리 측정함 
							 // RightTrackLine Data 생성 
							 //////////////////////////////////////////////////////////////////////////////
							 if(RightTrackLine[0].FP0.x!=0.0f && RightTrackLine[0].FP0.y!=0.0f && RightTrackLine[0].FP1.x!=0.0f && RightTrackLine[0].FP1.y!=0.0f){
								 // 									 RightTrackLine[0].FP0.y = RightTrackLine[0].FP0.y + ImageHeight; //전체 이미지 기준 y좌표
								 // 									 RightTrackLine[0].FP1.y = RightTrackLine[0].FP1.y + ImageHeight; //전체 이미지 기준 y좌표
								 // 
								 // 									 MarkToTrackLineDis1 = Math.GetLengthFrLineToPoint(RightMarkSta, RightMarkEnd, RightTrackLine[0].FP0);//Mark라인에서 TrackLine거리 
								 // 									 MarkToTrackLineDis2 = Math.GetLengthFrLineToPoint(RightMarkSta, RightMarkEnd, RightTrackLine[0].FP1);//Mark라인에서 TrackLine거리 
								 // 
								 // 									 TotalRightTrackDis  +=  (int)((MarkToTrackLineDis1 + MarkToTrackLineDis2)/2.0); //Mark라인에서 TrackLine거리 누적                   
								 // 									 RightTrackLineCount++; //누적 카운트 증가
								 // 
								 // 									 // Org Data 
								 // 									 RightTrackLine[0].FP0.y = RightTrackLine[0].FP0.y - ImageHeight; //Frame 이미지 기준 y좌표 원복
								 // 									 RightTrackLine[0].FP1.y = RightTrackLine[0].FP1.y - ImageHeight; //Frame 이미지 기준 y좌표 원복 
							 }
							 // RightTrackLine Data 생성 종료 
							 ////////////////////////////////////////////////////////////////////////////////
						 }
						 else {//EnCap(Top영역) RightInLine Search , RightTrackLine Data Overlap 
							 // RightInLine Search Start 
							 /////////////////////////////////////////////////////////////////////////////
							 EasyImage::Threshold(GImage,&BinaryImg, RightEdgeThresHold);
							 SingleLine->GImage = &BinaryImg;

							 // 영역설정 
							 if(fabs(RightOutLine[0].FP0.x - RightOutLine[0].FP1.x) > 3){
								 LSP.x = (RightOutLine[0].FP0.x + RightOutLine[0].FP1.x)/2;
								 LSP.y = 0.0f;
							 }
							 else {
								 LSP = Math.OnIntersect(RightOutLine[0].FP0, RightOutLine[0].FP1, LT, RT);
							 }

							 SingleLine->IRoi->SetOrgX  ((int)LSP.x-100);
							 SingleLine->IRoi->SetOrgY  (0             );
							 SingleLine->IRoi->SetWidth (97            );
							 SingleLine->IRoi->SetHeight(ImgH          );

							 if(((LSP.x+3)<=0) || ImgH<=0) return false;

							 if(IRoi->GetHeight()<300) SingleLine->SetIncrement(5 );
							 else                      SingleLine->SetIncrement(100);

							 // 연마량 측정 OutLine
							 SingleLine->SetFindLineId(0);
							 SingleLine->SetOrientation(orEast);
							 SingleLine->SetEdgeType(0); // Black to White 
							 SingleLine->OnExecute();
							 RightInLine[0].FP0 = SingleLine->GetResultP0();
							 RightInLine[0].FP1 = SingleLine->GetResultP1();

							 SingleLine->SetEdgeType(2); // Line Search Org 

							 // RightInLine None....make InLine Data 
							 // 현재의 데이터를 넘겨준다 
							 if(RightInLine[0].FP0.x!=0.0f && RightInLine[0].FP0.y!=0.0f && RightInLine[0].FP1.x!=0.0f && RightInLine[0].FP1.y!=0.0f){
								 PreRightInLine[0].FP0.x = RightInLine[0].FP0.x;    PreRightInLine[0].FP1.x = RightInLine[0].FP1.x;       
								 PreRightInLine[0].FP0.y = RightInLine[0].FP0.y;    PreRightInLine[0].FP1.y = RightInLine[0].FP1.y;       
							 }
							 else if(RightInLine[0].FP0.x==0.0f || RightInLine[0].FP0.y==0.0f || RightInLine[0].FP1.x==0.0f || RightInLine[0].FP1.y==0.0f){
								 if(PreRightInLine[0].FP0.x==0.0f && PreRightInLine[0].FP0.y==0.0f && PreRightInLine[0].FP1.x==0.0f && PreRightInLine[0].FP1.y==0.0f){// 시작부분 Broken발생으로 데이터가 없는경우 
									 // Mark좌표를 기준으로 라인좌표값을 다시 설정함 
									 ROI_H = IRoi->GetHeight();
									 ROI_L = IRoi->GetOrgX()  ;
									 RightInLine[0].FP0.x = ROI_L;   RightInLine[0].FP0.y = 0.0f        ;
									 RightInLine[0].FP1.x = ROI_L;   RightInLine[0].FP1.y = (float)ROI_H;

									 //Line 데이터를 PreLine에 넘겨준다 
									 PreRightInLine[0].FP0.x = RightInLine[0].FP0.x;    PreRightInLine[0].FP1.x = RightInLine[0].FP1.x;       
									 PreRightInLine[0].FP0.y = RightInLine[0].FP0.y;    PreRightInLine[0].FP1.y = RightInLine[0].FP1.y;       
								 }
								 else {                                                                                                    // 중간부분 Broken발생으로 데이터가 없는경우 
									 // PreLine 데이터를 넘겨줌 
									 RightInLine[0].FP0.x = PreRightInLine[0].FP0.x;  RightInLine[0].FP1.x = PreRightInLine[0].FP1.x;  
									 RightInLine[0].FP0.y = PreRightInLine[0].FP0.y;  RightInLine[0].FP1.y = PreRightInLine[0].FP1.y;  
								 }
							 }
							 // NOTCH CELL Btm 검사에서만 연마폭 측정함 
							 Right_Grind_Width =(float)(Math.GetLengthFrLineToPoint (RightOutLine[0].FP0,RightOutLine[0].FP1, RightInLine[0].FP0 ));
							 // RightInLine Search End
							 /////////////////////////////////////////////////////////////////////////////


							 // RightTrackLine Data OverLap Start
							 //////////////////////////////////////////////////////////////////////////////
							 if(AvgRightTrackLineDis!=0){
								 // 									 RightOutLine[0].FP0.y = RightOutLine[0].FP0.y + ImageHeight; //전체 이미지 기준 y좌표
								 // 									 RightOutLine[0].FP1.y = RightOutLine[0].FP1.y + ImageHeight; //전체 이미지 기준 y좌표
								 // 
								 // 									 MarkToTrackLineDis1 = Math.GetLengthFrLineToPoint(RightMarkSta, RightMarkEnd, RightOutLine[0].FP0);//Mark라인에서 OutLine까지 거리 
								 // 									 MarkToTrackLineDis2 = Math.GetLengthFrLineToPoint(RightMarkSta, RightMarkEnd, RightOutLine[0].FP1);//Mark라인에서 OutLine까지 거리 
								 // 
								 // 									 if(MarkToTrackLineDis1>AvgRightTrackLineDis) RightTrackLine[0].FP0.x = RightOutLine[0].FP0.x - (MarkToTrackLineDis1 - AvgRightTrackLineDis);
								 // 									 if(MarkToTrackLineDis2>AvgRightTrackLineDis) RightTrackLine[0].FP1.x = RightOutLine[0].FP1.x - (MarkToTrackLineDis2 - AvgRightTrackLineDis);
								 // 
								 // 									 // RightOutLine Data 원본 
								 // 									 RightOutLine[0].FP0.y = RightOutLine[0].FP0.y - ImageHeight; 
								 // 									 RightOutLine[0].FP1.y = RightOutLine[0].FP1.y - ImageHeight; 
								 // 
								 // 									 RightTrackLine[0].FP0.y = RightOutLine[0].FP0.y;
								 // 									 RightTrackLine[0].FP1.y = RightOutLine[0].FP1.y;
							 }
							 // RightTrackLine Data OverLap End 
							 //////////////////////////////////////////////////////////////////////////////
						 }
					 }
					 else {
						 if(IsMarkBtm){ //RightTrackLine Search 
							 if(FInspectMode==Insp_Track){
								 // Right TrackLine Search 
								 /////////////////////////////////////////////////////////////////////////////////////////////
								 //BinaryImg.SetSize(GImage->GetWidth(), GImage->GetHeight());
								 //EasyImage::Oper(EArithmeticLogicOperation_Copy,GImage,&BinaryImg);
								 EasyImage::Threshold(GImage,&BinaryImg, CirGrindMeaThresHold);
								 SingleLine->GImage = &BinaryImg;

								 // 영역설정 
								 if(fabs(RightOutLine[0].FP0.x - RightOutLine[0].FP1.x) > 3){
									 LSP.x = (RightOutLine[0].FP0.x + RightOutLine[0].FP1.x)/2;
									 LSP.y = 0.0f;
								 }
								 else {
									 LSP = Math.OnIntersect(RightOutLine[0].FP0, RightOutLine[0].FP1, LT, RT);
								 }

								 SingleLine->IRoi->SetOrgX  ((int)LSP.x-50 );
								 SingleLine->IRoi->SetOrgY  (0             );
								 SingleLine->IRoi->SetWidth (47            );
								 SingleLine->IRoi->SetHeight(ImgH          );

								 if(FShape==shRectC){
									 SingleLine->IRoi->SetOrgX  ((int)LSP.x-50);
									 SingleLine->IRoi->SetOrgY  (0            );
									 SingleLine->IRoi->SetWidth (47           );
									 SingleLine->IRoi->SetHeight(FEndLine-CSideCircleHeight);
									 SingleLine->SetIncrement(1 );
									 if(((LSP.x-50)<=0) || ImgH<=0) return false;
								 }
								 else {
									 SingleLine->IRoi->SetOrgX  ((int)LSP.x-50);
									 SingleLine->IRoi->SetOrgY  (0            );
									 SingleLine->IRoi->SetWidth (47           );
									 SingleLine->IRoi->SetHeight(ImgH         );
									 SingleLine->SetIncrement(50);
									 if(((LSP.x-50)<=0) || ImgH<=0) return false;
								 }

								 // 연마량 측정 OutLine
								 SingleLine->SetFindLineId(0);
								 SingleLine->SetOrientation(orEast);
								 SingleLine->SetEdgeType(1); // White To Black  
								 SingleLine->OnExecute();
								 RightTrackLine[0].FP0 = SingleLine->GetResultP0();
								 RightTrackLine[0].FP1 = SingleLine->GetResultP1();

								 SingleLine->SetEdgeType(2); // Line Search Org 

								 // RightTrackLine....make OutLine Data 
								 // 현재의 데이터를 넘겨준다 
								 // 검사중 기준라인을 찾지 못할경우 이전데이터 넘겨줘서 기준라인 생성함 
								 if(RightTrackLine[0].FP0.x!=0.0f && RightTrackLine[0].FP0.y!=0.0f && RightTrackLine[0].FP1.x!=0.0f && RightTrackLine[0].FP1.y!=0.0f){
									 PreRightTrackLine[0].FP0.x = RightTrackLine[0].FP0.x;    PreRightTrackLine[0].FP1.x = RightTrackLine[0].FP1.x;       
									 PreRightTrackLine[0].FP0.y = RightTrackLine[0].FP0.y;    PreRightTrackLine[0].FP1.y = RightTrackLine[0].FP1.y;       
								 } // 셀의 상단 시작부터 Broken 발생으로 데이터가 없는경우 
								 else if(RightTrackLine[0].FP0.x==0.0f || RightTrackLine[0].FP0.y==0.0f || RightTrackLine[0].FP1.x==0.0f || RightTrackLine[0].FP1.y==0.0f){
									 if(PreRightTrackLine[0].FP0.x==0.0f && PreRightTrackLine[0].FP0.y==0.0f && PreRightTrackLine[0].FP1.x==0.0f && PreRightTrackLine[0].FP1.y==0.0f){// 시작부분 Broken발생으로 데이터가 없는경우 
										 // Mark좌표를 기준으로 라인좌표값을 다시 설정함 
										 ROI_H = IRoi->GetHeight();
										 ROI_L = IRoi->GetOrgX()  ;
										 RightTrackLine[0].FP0.x = ROI_L;    RightTrackLine[0].FP0.y = 0.0f        ;
										 RightTrackLine[0].FP1.x = ROI_L;    RightTrackLine[0].FP1.y = (float)ROI_H;

										 //RightTrackLine 데이터를 PreRightTrackLine에 넘겨준다 
										 PreRightTrackLine[0].FP0.x = RightTrackLine[0].FP0.x;    PreRightTrackLine[0].FP1.x = RightTrackLine[0].FP1.x;       
										 PreRightTrackLine[0].FP0.y = RightTrackLine[0].FP0.y;    PreRightTrackLine[0].FP1.y = RightTrackLine[0].FP1.y;       
									 }
									 else { // 중간부분 Broken발생으로 데이터가 없는경우 
										 // PreRightTrackLine 데이터를 넘겨줌 
										 RightTrackLine[0].FP0.x = PreRightTrackLine[0].FP0.x;  RightTrackLine[0].FP1.x = PreRightTrackLine[0].FP1.x;  
										 RightTrackLine[0].FP0.y = PreRightTrackLine[0].FP0.y;  RightTrackLine[0].FP1.y = PreRightTrackLine[0].FP1.y;  
									 }
								 }
								 // NOTCH CELL Btm 검사에서만 연마폭 측정함 
								 Right_Grind_Mea =(float)(Math.GetLengthFrLineToPoint (RightOutLine[0].FP0,RightOutLine[0].FP1,RightTrackLine[0].FP0));
								 // RightInLine Search End 
								 /////////////////////////////////////////////////////////////////////////////


								 // 마크라인에서 부터 RightTrackLine 까지 거리 산출 
								 // RightTrackLine Data 존재할 경우 거리 측정함 
								 // RightTrackLine Data 생성 
								 if(RightTrackLine[0].FP0.x!=0.0f && RightTrackLine[0].FP0.y!=0.0f && RightTrackLine[0].FP1.x!=0.0f && RightTrackLine[0].FP1.y!=0.0f){
									 if(RightOutLine[0].FP0.x!=0.0f && RightOutLine[0].FP0.y!=0.0f && RightOutLine[0].FP1.x!=0.0f && RightOutLine[0].FP1.y!=0.0f){
										 RightToTrackLineDis1 = Math.GetLengthFrLineToPoint(RightOutLine[0].FP0, RightOutLine[0].FP1, RightTrackLine[0].FP0);//외곽라인에서 TrackLine거리 
										 RightToTrackLineDis2 = Math.GetLengthFrLineToPoint(RightOutLine[0].FP0, RightOutLine[0].FP1, RightTrackLine[0].FP1);//외곽라인에서 TrackLine거리 

										 TotalRightTrackDis  +=  (int)((RightToTrackLineDis1 + RightToTrackLineDis2)/2.0); //Mark라인에서 TrackLine거리 누적                   
										 RightTrackLineCount++; //누적 카운트 증가
									 }
								 }
							 }
						 }
						 else {//EnCap(Top영역) RightTrackLine Data Overlap 
							 // RightTrackLine Data OverLap Start
							 //////////////////////////////////////////////////////////////////////////////
							 if(AvgRightTrackLineDis!=0){
								 if(FInspectMode==Insp_Track){ //외곽기준 데이터 오버랩 한다 
									 if(RightOutLine[0].FP0.x!=0.0f && RightOutLine[0].FP0.y!=0.0f && RightOutLine[0].FP1.x!=0.0f && RightOutLine[0].FP1.y!=0.0f){
										 // TOP영역 LeftTrackLine x좌표 
										 RightTrackLine[0].FP0.x = RightOutLine[0].FP0.x - AvgRightTrackLineDis;
										 RightTrackLine[0].FP1.x = RightOutLine[0].FP1.x - AvgRightTrackLineDis;

										 // TOP영역 LeftTrackLine y좌표 
										 RightTrackLine[0].FP0.y = RightOutLine[0].FP0.y;
										 RightTrackLine[0].FP1.y = RightOutLine[0].FP1.y;
									 }
								 }
							 }
						 }
					 }
                 }
                 if (FBottomWall) { //NOTCH 
					 EasyImage::Threshold(GImage,&BinaryImg, BtmEdgeThresHold);
					 if(BtmEdgeThresHold==0)    {SingleLine->GImage = GImage;     SingleLine->FThreshold =5 ;}
					 else                       {SingleLine->GImage = &BinaryImg; SingleLine->FThreshold =10;}

					 SingleLine->IRoi->SetOrgX  (IRoi->GetOrgX());
					 SingleLine->IRoi->SetOrgY  (FEndLine-100   );
					 SingleLine->IRoi->SetWidth (IRoi->GetWidth());
					 SingleLine->IRoi->SetHeight(200             );

					 SingleLine->SetOrientation(orSouth);
					 SingleLine->FIncrement =50;
					 SingleLine->SetFindLineId(0);
					 SingleLine->FThreshold =5;

					 if(IsMarkBtm) SingleLine->SetEdgeType(1);  // White To Black 
					 else          SingleLine->SetEdgeType(1);  // White To Black 

					 // 기본 BtmLine Search 
					 SingleLine->OnExecute();
					 // 						 Line[waBottomWall].FP0 = SingleLine->GetResultP0();
					 // 						 Line[waBottomWall].FP1 = SingleLine->GetResultP1();
					 Line[3].FP0 = SingleLine->GetResultP0();
					 Line[3].FP1 = SingleLine->GetResultP1();

					 // Btm TrackLine Search Only LTCell ==> Btm 검사시 
					 if(IsMarkBtm){
						 if(FInspectMode==Insp_Track){
							 EasyImage::Threshold(GImage,&BinaryImg, CirGrindMeaThresHold);
							 if(BtmEdgeThresHold==0)    {SingleLine->GImage = GImage;     SingleLine->FThreshold =5 ;}
							 else                       {SingleLine->GImage = &BinaryImg; SingleLine->FThreshold =10;}

							 SingleLine->IRoi->SetOrgX  (IRoi->GetOrgX());
							 SingleLine->IRoi->SetOrgY  (FEndLine-100   );
							 SingleLine->IRoi->SetWidth (IRoi->GetWidth());
							 SingleLine->IRoi->SetHeight(200             );
							 if((FEndLine-100<=0)|| (FEndLine-100>=ImgW)) return false;

							 SingleLine->SetOrientation(orSouth);
							 SingleLine->FIncrement =10;
							 SingleLine->SetFindLineId(0);
							 SingleLine->FThreshold =5;

							 SingleLine->SetEdgeType(1);  //White To Black 

							 SingleLine->OnExecute();
							 BtmTrackLine[0].FP0 = SingleLine->GetResultP0();
							 BtmTrackLine[0].FP1 = SingleLine->GetResultP1();

							 // TrackLine CrossPoint Calculate (Org Data)
							 FTRLBPoint = Math.OnIntersect(LeftTrackLine [0].FP0, LeftTrackLine [0].FP1, BtmTrackLine[0].FP0 , BtmTrackLine[0].FP1);
							 FTRRBPoint = Math.OnIntersect(RightTrackLine[0].FP0, RightTrackLine[0].FP1, BtmTrackLine[0].FP0 , BtmTrackLine[0].FP1);

							 if(TotalLeftTrackDis!=0  && LeftTrackLineCount!=0){ //LeftTrackLine 거리편차 평균값 
								 AvgLeftTrackLineDis  = (int)(TotalLeftTrackDis/LeftTrackLineCount);
							 }
							 if(TotalRightTrackDis!=0 && RightTrackLineCount!=0){//RightTrackLine 거리편차 평균값 
								 AvgRightTrackLineDis = (int)(TotalRightTrackDis/RightTrackLineCount);
							 }

							 if(BtmTrackLine[0].FP0.x!=0 && BtmTrackLine[0].FP0.y!=0 && BtmTrackLine[0].FP1.x!=0 && BtmTrackLine[0].FP1.y!=0){
								 if(Line[3].FP0.x!=0 && Line[3].FP0.y!=0 && Line[3].FP1.x!=0 && Line[3].FP1.y!=0){
									 AvgLeftBtmTrackLineDis = Math.GetLengthFrLineToPoint(Line[3].FP0, Line[3].FP1, BtmTrackLine[0].FP0);//외곽라인에서 TrackLine거리 
									 AvgRightBtmTrackLineDis= Math.GetLengthFrLineToPoint(Line[3].FP0, Line[3].FP1, BtmTrackLine[0].FP1);//외곽라인에서 TrackLine거리 
								 }
							 }
						 }
					 }
					 else { // EnCap Cell 검사시 TrackLine 데이터 만들어 준다 
						 if(AvgLeftBtmTrackLineDis!=0 && AvgRightBtmTrackLineDis!=0){
							 if(FInspectMode==Insp_Track){
								 BtmTrackLine[0].FP0.y = Line[3].FP0.y - AvgLeftBtmTrackLineDis ;
								 BtmTrackLine[0].FP1.y = Line[3].FP1.y - AvgRightBtmTrackLineDis;

								 BtmTrackLine[0].FP0.x = Line[3].FP0.x;
								 BtmTrackLine[0].FP1.x = Line[3].FP1.x;
							 }
						 }
						 // EnCap영역에 TrackLine 교차점을 LT영역 데이터를 이용하여 가상으로 생성해준다 
						 // Image Rotate 없음 (원본 이미지 기준 좌표)
						 if(LeftTrackLine[0].FP0.x!=0.0f && LeftTrackLine[0].FP0.y!=0.0f && RightTrackLine[0].FP0.x!=0.0f && RightTrackLine[0].FP0.y!=0.0f&&
							 LeftTrackLine[0].FP1.x!=0.0f && LeftTrackLine[0].FP1.y!=0.0f && RightTrackLine[0].FP1.x!=0.0f && RightTrackLine[0].FP1.y!=0.0f){
						     if(BtmTrackLine[0].FP0.x!=0.0f && BtmTrackLine[0].FP0.y!=0.0f && BtmTrackLine[0].FP1.x!=0.0f && BtmTrackLine[0].FP1.y!=0.0f){
							     FTRLBPoint = Math.OnIntersect(LeftTrackLine [0].FP0, LeftTrackLine [0].FP1, BtmTrackLine[0].FP0 , BtmTrackLine[0].FP1);
								 FTRRBPoint = Math.OnIntersect(RightTrackLine[0].FP0, RightTrackLine[0].FP1, BtmTrackLine[0].FP0 , BtmTrackLine[0].FP1);
					         }
						 }
					 }
                 }
                 if (FLeftTop) { //NOTCH ==>이미지 회전후 반복검사 진행하므로 필요없음 
// 					 if(ECThresHold==0) {SingleLine->GImage = GImage; SingleLine->FThreshold =5 ;}
// 					 else               {
// 						 EasyImage::Threshold(GImage,&BinaryImg, ECThresHold);
// 						 SingleLine->GImage = &BinaryImg; SingleLine->FThreshold =10;
// 					 }
// 
// 					 OrgPoint = Math.OnIntersect(Line[waLeftWall].FP0, Line[waLeftWall].FP1, Line[waTopWall].FP0, Line[waTopWall].FP1);
// 					 FLTPoint = OrgPoint;
// 
// 					 if(IsCornerTop){
// 						 SingleLine->IRoi->SetOrgX  ((int)OrgPoint.x-10                );
// 						 SingleLine->IRoi->SetOrgY  ((int)OrgPoint.y                   );
// 						 SingleLine->IRoi->SetWidth ((int)CornerWidth+20               );
// 						 SingleLine->IRoi->SetHeight((int)CornerHeight                 );
// 
// 						 SingleLine->SetOrientation(orWest);
// 						 SingleLine->FIncrement =1;
// 						 SingleLine->FThreshold =15;
// 						 SingleLine->SetFindLineId(0);
// 						 SingleLine->SetEdgeType(1);  //White To Black 
// 						 SingleLine->OnExecute();
// 						 Line[waLeftTop].FP0 = SingleLine->GetResultP0();
// 						 Line[waLeftTop].FP1 = SingleLine->GetResultP1();
// 
// 						 // ORG 
// 						 FLTLPoint = Math.OnIntersect(SingleLine->GetResultP0(), SingleLine->GetResultP1(), Line[waLeftWall].FP0, Line[waLeftWall].FP1);
// 						 FLTTPoint = Math.OnIntersect(SingleLine->GetResultP0(), SingleLine->GetResultP1(), Line[waTopWall ].FP0, Line[waTopWall ].FP1);
// 
// 						 if((FLTLPoint.x==0 || FLTLPoint.y==0 || FLTTPoint.x==0 || FLTTPoint.y==0) || (SingleLine->FEdgePointCount <30)){
// 							 LTDx = 0.0f;
// 							 LTDy = 0.0f;
// 							 //화면에 디스플레이 위해서 
// 							 FLTLPoint.x = FLTPoint.x;
// 							 FLTLPoint.y = FLTPoint.y;
// 							 FLTTPoint.x = FLTPoint.x;
// 							 FLTTPoint.y = FLTPoint.y;
// 						 }
// 						 else {
// 							 LTDx = Math.GetLengthFrPointToPoint(FLTPoint, FLTTPoint);
// 							 LTDy = Math.GetLengthFrPointToPoint(FLTPoint, FLTLPoint);
// 
// 							 // OutLine C1Corner Data 
// 							 if((SingleLine->FEdgePointCount) - (CornerMargin*2)>0){
// 								 if(C1Point!=NULL) delete[] C1Point;
// 								 C1Point  = new TFPoint [(SingleLine->FEdgePointCount) - (CornerMargin*2)];
// 								 C1EdgeCount = (SingleLine->FEdgePointCount) -(CornerMargin*2);
// 
// 								 CornerCount =0;  
// 								 for(int k=CornerMargin; k<((SingleLine->FEdgePointCount)-CornerMargin); k++){
// 									 if(CornerCount>=MAX_DEFECT_POINT) break;
// 									 C1Point[CornerCount].x = SingleLine->FEdgePoint[k].x;
// 									 C1Point[CornerCount].y = SingleLine->FEdgePoint[k].y;
// 									 CornerCount++;
// 								 }
// 							 }
// 
// 							 // Corner 연마 안쪽라인 찾는다 
// 							 SingleLine->SetFindLineId(0);
// 							 SingleLine->SetEdgeType(0);  //Black To White 
// 							 SingleLine->OnExecute();
// 
// 							 // InLine C1Corner Data 
// 							 if((SingleLine->FEdgePointCount) - (CornerMargin*2)>0){
// 								 if(C1InPoint!=NULL) delete[] C1InPoint;
// 								 C1InPoint  = new TFPoint [(SingleLine->FEdgePointCount) - (CornerMargin*2)];
// 								 C1EdgeCount = (SingleLine->FEdgePointCount) -(CornerMargin*2);
// 
// 								 CornerCount =0;  
// 								 for(int k=CornerMargin; k<((SingleLine->FEdgePointCount)-CornerMargin); k++){
// 									 if(CornerCount>=MAX_DEFECT_POINT) break;
// 									 C1InPoint[CornerCount].x = SingleLine->FEdgePoint[k].x;
// 									 C1InPoint[CornerCount].y = SingleLine->FEdgePoint[k].y;
// 									 CornerCount++;
// 								 }
// 							 }
// 							 //코너 연마안쪽라인 기준 새로운 교차점 생성 
// 							 FLTLInPoint = Math.OnIntersect(SingleLine->GetResultP0(), SingleLine->GetResultP1(), Line[waLeftWall].FP0, Line[waLeftWall].FP1);
// 							 FLTTInPoint = Math.OnIntersect(SingleLine->GetResultP0(), SingleLine->GetResultP1(), Line[waTopWall ].FP0, Line[waTopWall ].FP1);
// 
// 							 //코너 연마폭, 연마량 계산 
// 							 double Dis =0.0f, AvgGrindWidth=0.0f, AvgGrindMea=0.0f, TotalGrindWidth=0.0f;
// 							 for(int k=0; k<C1EdgeCount; k++){
// 								 Dis = Math.GetLengthFrLineToPoint(FLTLPoint, FLTTPoint, C1InPoint[k]);
// 								 TotalGrindWidth+=Dis;
// 							 }
// 							 if(C1EdgeCount!=0){
// 								 AvgGrindWidth = (TotalGrindWidth/C1EdgeCount);
// 								 C1CorGrindWd  = AvgGrindWidth;
// 							 }
// 						 }
// 					 }
// 					 else {
// 						 LTDx = 0.0f;
// 						 LTDy = 0.0f;
// 						 //화면에 디스플레이 위해서 
// 						 FLTLPoint.x = FLTPoint.x;
// 						 FLTLPoint.y = FLTPoint.y;
// 						 FLTTPoint.x = FLTPoint.x;
// 						 FLTTPoint.y = FLTPoint.y;
// 					 }
                 }
                 if (FRightTop) { // NOTCH ==>이미지 회전후 반복검사 진행하므로 필요없음 
// 					 if(ECThresHold==0) {SingleLine->GImage = GImage; SingleLine->FThreshold =5 ;}
// 					 else               {
// 						 EasyImage::Threshold(GImage,&BinaryImg, ECThresHold);
// 						 SingleLine->GImage = &BinaryImg; SingleLine->FThreshold =10;
// 					 }
// 
// 					 OrgPoint = Math.OnIntersect(Line[waRightWall].FP0, Line[waRightWall].FP1, Line[waTopWall].FP0, Line[waTopWall].FP1);
// 					 FRTPoint = OrgPoint;
// 
// 					 if(IsCornerTop){
// 						 SingleLine->IRoi->SetOrgX  ((int)(OrgPoint.x-CornerWidth-20));
// 						 SingleLine->IRoi->SetOrgY  ((int) OrgPoint.y                );
// 						 SingleLine->IRoi->SetWidth (CornerWidth+10                  );
// 						 SingleLine->IRoi->SetHeight(CornerHeight                    );
// 
// 						 SingleLine->SetOrientation(orEast);
// 						 SingleLine->FIncrement =1;
// 						 SingleLine->FThreshold =15;
// 						 SingleLine->SetFindLineId(0);
// 						 SingleLine->SetEdgeType(1);  //White To Black 
// 						 SingleLine->OnExecute();
// 						 Line[waRightTop].FP0 = SingleLine->GetResultP0();
// 						 Line[waRightTop].FP1 = SingleLine->GetResultP1();
// 
// 						 // ORG 
// 						 FRTRPoint = Math.OnIntersect(SingleLine->GetResultP0(), SingleLine->GetResultP1(), Line[waRightWall].FP0, Line[waRightWall].FP1);
// 						 FRTTPoint = Math.OnIntersect(SingleLine->GetResultP0(), SingleLine->GetResultP1(), Line[waTopWall  ].FP0, Line[waTopWall].FP1  );
// 
// 						 if((FRTRPoint.x==0 || FRTRPoint.y==0 || FRTTPoint.x==0 || FRTTPoint.y==0) || (SingleLine->FEdgePointCount <30)){
// 							 RTDx = 0.0f;
// 							 RTDy = 0.0f;
// 							 //화면에 디스플레이 위해서 
// 							 FRTRPoint.x = FRTPoint.x;
// 							 FRTRPoint.y = FRTPoint.y;
// 							 FRTTPoint.x = FRTPoint.x;
// 							 FRTTPoint.y = FRTPoint.y;
// 						 }
// 						 else {
// 							 RTDx = Math.GetLengthFrPointToPoint(FRTPoint, FRTTPoint);
// 							 RTDy = Math.GetLengthFrPointToPoint(FRTPoint, FRTRPoint);
// 
// 							 // OutLine C2Corner Data 
// 							 if((SingleLine->FEdgePointCount) - (CornerMargin*2)>0){
// 								 if(C2Point!=NULL) delete[] C2Point;
// 								 C2Point  = new TFPoint [(SingleLine->FEdgePointCount) - (CornerMargin*2)];
// 								 C2EdgeCount = (SingleLine->FEdgePointCount) -(CornerMargin*2);
// 
// 								 CornerCount =0;  
// 								 for(int k=CornerMargin; k<((SingleLine->FEdgePointCount)-CornerMargin); k++){
// 									 if(CornerCount>=MAX_DEFECT_POINT) break;
// 									 C2Point[CornerCount].x = SingleLine->FEdgePoint[k].x;
// 									 C2Point[CornerCount].y = SingleLine->FEdgePoint[k].y;
// 									 CornerCount++;
// 								 }
// 							 }
// 
// 							 // Corner 연마 안쪽라인 찾는다 
// 							 SingleLine->SetFindLineId(0);
// 							 SingleLine->SetEdgeType(0);  //Black To White 
// 							 SingleLine->OnExecute();
// 
// 							 // InLine C2Corner Data 
// 							 if((SingleLine->FEdgePointCount) - (CornerMargin*2)>0){
// 								 if(C2InPoint!=NULL) delete[] C2InPoint;
// 								 C2InPoint  = new TFPoint [(SingleLine->FEdgePointCount) - (CornerMargin*2)];
// 								 C2EdgeCount = (SingleLine->FEdgePointCount) -(CornerMargin*2);
// 
// 								 CornerCount =0;  
// 								 for(int k=CornerMargin; k<((SingleLine->FEdgePointCount)-CornerMargin); k++){
// 									 if(CornerCount>=MAX_DEFECT_POINT) break;
// 									 C2InPoint[CornerCount].x = SingleLine->FEdgePoint[k].x;
// 									 C2InPoint[CornerCount].y = SingleLine->FEdgePoint[k].y;
// 									 CornerCount++;
// 								 }
// 							 }
// 							 //코너 연마안쪽라인 기준 새로운 교차점 생성 
// 							 FRTRInPoint = Math.OnIntersect(SingleLine->GetResultP0(), SingleLine->GetResultP1(), Line[waRightWall].FP0, Line[waRightWall].FP1);
// 							 FRTTInPoint = Math.OnIntersect(SingleLine->GetResultP0(), SingleLine->GetResultP1(), Line[waTopWall  ].FP0, Line[waTopWall].FP1  );
// 
// 							 //코너 연마폭, 연마량 계산 
// 							 double Dis =0.0f, AvgGrindWidth=0.0f, AvgGrindMea=0.0f, TotalGrindWidth=0.0f;
// 							 for(int k=0; k<C2EdgeCount; k++){
// 								 Dis = Math.GetLengthFrLineToPoint(FRTRPoint, FRTTPoint, C2InPoint[k]);
// 								 TotalGrindWidth+=Dis;
// 							 }
// 							 if(C2EdgeCount!=0){
// 								 AvgGrindWidth = (TotalGrindWidth/C2EdgeCount);
// 								 C2CorGrindWd  = AvgGrindWidth;
// 							 }
// 						 }
// 					 }
// 					 else {
// 						 RTDx = 0.0f;
// 						 RTDy = 0.0f;
// 						 //화면에 디스플레이 위해서 
// 						 FRTRPoint.x = FRTPoint.x;
// 						 FRTRPoint.y = FRTPoint.y;
// 						 FRTTPoint.x = FRTPoint.x;
// 						 FRTTPoint.y = FRTPoint.y;
// 					 }
                 }
                 if (FRightBottom){ //NOTCH 기준 시퀀스 미사용 
                 }
                 if (FLeftBottom ){ //NOTCH 기준 시퀀스 미사용 
                 }

				 // NOTCH 외관검사시 셀 얼라인 불안정하여 셀이 틀어졌을경우 
				 // 검사 ROI영역을 틀어진 각도 기준으로 회전하여도 외곽라인 근처에 존재하는 패턴으로 인해서 오버킬 발생함 
				 // 이로 인해서 부득이하게 원본 이미지를 복사하여 틀어진 각도만큼 회전하여 기본 Edge데이터를 다시 산출 및 Defect검사시 
				 // 회전된 이미지기준으로 검사 진행함 

				 if(FShape==shRectH ){ //NOTCH ROTATE IMAGE
					 // Image Roate 전 원본이미지 기준 데이터 산출 
					 FLTPoint = Math.OnIntersect(Line[waLeftWall].FP0 , Line[waLeftWall].FP1 , Line[waTopWall].FP0, Line[waTopWall].FP1);
					 FRTPoint = Math.OnIntersect(Line[waRightWall].FP0, Line[waRightWall].FP1, Line[waTopWall].FP0, Line[waTopWall].FP1);

					 // 						 if(FLTPoint.x!=0 && FLTPoint.y!=0 && FRTPoint.x!=0 && FRTPoint.y!=0) ImgDegree = -(Math.GetDegree(FLTPoint.x , FLTPoint.y, FRTPoint.x, FRTPoint.y));
					 if(FP0.x!=0 && FP0.y!=0 && FP1.x!=0 && FP1.y!=0) ImgDegree = -(Math.GetDegree(FP0.x , FP0.y, FP1.x, FP1.y));

					 // 원본 RotateImg Size 설정 및 복사 
					 LogUnit.SetLog(L"shRectH_RotateImg_Start");     
					 RotateImg.SetSize(GImage->GetWidth(), GImage->GetHeight());
					 EasyImage::Oper(EArithmeticLogicOperation_Copy,GImage,&RotateImg);

					 // 원본 복사하여 이미지 회전 
					 EasyImage::ScaleRotate(GImage, (float)ImgW/2, (float)ImgH/2, (float)ImgW/2, (float)ImgH/2, 1.0f, 1.0f, ImgDegree, &RotateImg, 4);
					 CenterPoint.x = ImgW/2;
					 CenterPoint.y = ImgH/2;


					 // Binary RotateImg Size 설정 및 복사 
					 RotateBinaryImg.SetSize(RotateImg.GetWidth(), RotateImg.GetHeight());
					 EasyImage::Oper(EArithmeticLogicOperation_Copy,&RotateImg,&RotateBinaryImg);
					 // Grind Measure Corner, Circle 검사 목적 
					 RotateGrindBinaryImg.SetSize(RotateImg.GetWidth(), RotateImg.GetHeight());
					 EasyImage::Oper(EArithmeticLogicOperation_Copy,&RotateImg,&RotateGrindBinaryImg);
					 LogUnit.SetLog(L"shRectH_RotateImg_End");     

					 if(FLeftWall){
						 EasyImage::Threshold(&RotateImg,&RotateBinaryImg, LeftEdgeThresHold);
						 if(LeftEdgeThresHold==0) {SingleLine->GImage = &RotateImg      ; SingleLine->FThreshold =5 ;}
						 else                     {SingleLine->GImage = &RotateBinaryImg; SingleLine->FThreshold =10;}

						 if(IsCircleTop){
							 SingleLine->IRoi->SetOrgX  (IRoi->GetOrgX()  );
							 SingleLine->IRoi->SetOrgY  (ASideCircleHeight+50);
							 SingleLine->IRoi->SetWidth (IRoi->GetWidth() );
							 SingleLine->IRoi->SetHeight(ImgH-(ASideCircleHeight+50));
							 SingleLine->SetIncrement(1 );
						 }
						 else {
							 SingleLine->IRoi->SetOrgX  (IRoi->GetOrgX()  );
							 SingleLine->IRoi->SetOrgY  (IRoi->GetOrgY()  );
							 SingleLine->IRoi->SetWidth (IRoi->GetWidth() );
							 SingleLine->IRoi->SetHeight(IRoi->GetHeight());
							 SingleLine->SetIncrement(5 );
						 }
						 SingleLine->SetOrientation(orWest);

						 // 							 if(IRoi->GetHeight()<350) SingleLine->SetIncrement(1 );
						 // 							 else                      SingleLine->SetIncrement(5 );

						 SingleLine->SetFindLineId(0);
						 // 							 SingleLine->SetEdgeType(0);  // Black To White 
						 if(IsMarkBtm) SingleLine->SetEdgeType(0); // Black to White 
						 else          SingleLine->SetEdgeType(1); // White to Black  

						 SingleLine->OnExecute();
						 Line[0].FP0 = SingleLine->GetResultP0();
						 Line[0].FP1 = SingleLine->GetResultP1();

						 // Multi Round Test 
						 if((fabs(Line[0].FP0.x - Line[0].FP1.x)>2) && (Line[0].FP1.x <Line[0].FP0.x)) Line[0].FP0.x = Line[0].FP1.x;

						 // Btm,Top 상관없이 첫번째
						 // 비선형 아크영역으로 인해서 LeftLine 추가 조절해야함 
						 // 							 if(fabs(Line[0].FP0.x - Line[0].FP1.x)>2){
						 // 								 if(Line[0].FP0.x> Line[0].FP1.x) Line[0].FP0.x = Line[0].FP1.x;
						 // 								 if(Line[0].FP0.x< Line[0].FP1.x) Line[0].FP0.x = Line[0].FP1.x;
						 // 							 }
						 LeftOutLine[0].FP0.x = Line[0].FP0.x;
						 LeftOutLine[0].FP0.y = Line[0].FP0.y;
						 LeftOutLine[0].FP1.x = Line[0].FP1.x;
						 LeftOutLine[0].FP1.y = Line[0].FP1.y;

						 // LeftOutLine....make OutLine Data 
						 // 현재의 데이터를 넘겨준다 
						 // 검사중 기준라인을 찾지 못할경우 이전데이터 넘겨줘서 기준라인 생성함 
						 if(LeftOutLine[0].FP0.x!=0.0f && LeftOutLine[0].FP0.y!=0.0f && LeftOutLine[0].FP1.x!=0.0f && LeftOutLine[0].FP1.y!=0.0f){
							 PreLeftOutLine[0].FP0.x = LeftOutLine[0].FP0.x;    PreLeftOutLine[0].FP1.x = LeftOutLine[0].FP1.x;       
							 PreLeftOutLine[0].FP0.y = LeftOutLine[0].FP0.y;    PreLeftOutLine[0].FP1.y = LeftOutLine[0].FP1.y;       
						 } // 셀의 상단 시작부터 Broken 발생으로 데이터가 없는경우 
						 else if(LeftOutLine[0].FP0.x==0.0f || LeftOutLine[0].FP0.y==0.0f || LeftOutLine[0].FP1.x==0.0f || LeftOutLine[0].FP1.y==0.0f){
							 if(PreLeftOutLine[0].FP0.x==0.0f && PreLeftOutLine[0].FP0.y==0.0f && PreLeftOutLine[0].FP1.x==0.0f && PreLeftOutLine[0].FP1.y==0.0f){// 시작부분 Broken발생으로 데이터가 없는경우 
								 // Mark좌표를 기준으로 라인좌표값을 다시 설정함 
								 ROI_H = IRoi->GetHeight();
								 LeftOutLine[0].FP0.x = Line[0].FP0.x;    LeftOutLine[0].FP0.y = 0.0f        ;
								 LeftOutLine[0].FP1.x = Line[0].FP1.x;    LeftOutLine[0].FP1.y = (float)ROI_H;

								 //Line 데이터를 PreLine에 넘겨준다 
								 PreLeftOutLine[0].FP0.x = LeftOutLine[0].FP0.x;    PreLeftOutLine[0].FP1.x = LeftOutLine[0].FP1.x;       
								 PreLeftOutLine[0].FP0.y = LeftOutLine[0].FP0.y;    PreLeftOutLine[0].FP1.y = LeftOutLine[0].FP1.y;       
							 }
							 else { // 중간부분 Broken발생으로 데이터가 없는경우 
								 // PreLine 데이터를 넘겨줌 
								 LeftOutLine[0].FP0.x = PreLeftOutLine[0].FP0.x;  LeftOutLine[0].FP1.x = PreLeftOutLine[0].FP1.x;  
								 LeftOutLine[0].FP0.y = PreLeftOutLine[0].FP0.y;  LeftOutLine[0].FP1.y = PreLeftOutLine[0].FP1.y;  
							 }
						 }
					 }
					 if(FTopWall ){ // ImageRotate 
						 EasyImage::Threshold(&RotateImg,&RotateBinaryImg, TopEdgeThresHold);
						 if(TopEdgeThresHold==0)  {SingleLine->GImage = &RotateImg      ;  SingleLine->FThreshold = 5;}
						 else                     {SingleLine->GImage = &RotateBinaryImg;  SingleLine->FThreshold =10;}

						 SingleLine->IRoi->SetOrgX  (IRoi->GetOrgX()  );
						 SingleLine->IRoi->SetOrgY  (IRoi->GetOrgY()  );
						 SingleLine->IRoi->SetWidth (IRoi->GetWidth() );
						 SingleLine->IRoi->SetHeight(IRoi->GetHeight());

						 // 							 int OrgX = IRoi->GetOrgX()  ;
						 // 							 int OrgY = IRoi->GetOrgY()  ;
						 // 							 int OrgW = IRoi->GetWidth() ;
						 // 							 int OrgH = IRoi->GetHeight();

						 if(IRoi->GetOrgX()<=0 || IRoi->GetWidth()<=0 || IRoi->GetHeight()<=0){
							 return false;
						 }

						 SingleLine->SetOrientation(orNorth);
						 SingleLine->FIncrement =100;
						 SingleLine->SetFindLineId(0);
						 SingleLine->FThreshold =5;

						 if(FCutMode==Normal_Cut){
							 SingleLine->SetEdgeType(0);  // Black To White 
							 SingleLine->OnExecute();
							 Line[1].FP0 = SingleLine->GetResultP0();
							 Line[1].FP1 = SingleLine->GetResultP1();
						 }
						 if(FCutMode==CAI_Cut)    {
							 SingleLine->SetEdgeType(1);  // White To Black  
							 SingleLine->OnExecute();
							 Line[1].FP0 = SingleLine->GetResultP0();
							 Line[1].FP1 = SingleLine->GetResultP1();

							 // 연마 외곽라인 
							 TopOutLine[0].FP0 = SingleLine->GetResultP0();
							 TopOutLine[0].FP1 = SingleLine->GetResultP1();

							 // Image Rotate 후 빈공간에 데이터 생성됨 이로인해서 ROI양역 추가 설정해야함 
							 SingleLine->IRoi->SetOrgX  (TopOutLine[0].FP0.GetX()-10                             );
							 SingleLine->IRoi->SetOrgY  (TopOutLine[0].FP0.GetY()-10                             );
							 SingleLine->IRoi->SetWidth ((TopOutLine[0].FP1.GetX() - TopOutLine[0].FP0.GetX())+20);
							 SingleLine->IRoi->SetHeight(100                                                     );

							 if((TopOutLine[0].FP0.GetX()-10)<=0 ||((TopOutLine[0].FP1.GetX() - TopOutLine[0].FP0.GetX())+20)<=0 || (TopOutLine[0].FP0.GetY()-10)<=0){
								 return false;
							 }

							 SingleLine->SetEdgeType(0);  // Black To White  
							 SingleLine->OnExecute();

							 // 연마 안쪽라인 
							 TopInLine[0].FP0 = SingleLine->GetResultP0();
							 TopInLine[0].FP1 = SingleLine->GetResultP1();

							 // 연마폭 계산  
							 // 								 Top_Grind_Width = Math.GetLengthFrLineToPoint(TopOutLine[0].FP0 ,  TopOutLine[0].FP1, TopInLine[0].FP0);
							 // 								 Top_Grind_Mea   = 0.0f; // 가공량 측정 기준이 현재 없음(20180710)

							 // 최대 개수는 10까지...단, 현재 테스트 진행시 첫번째에 데이터 넘겨준다 
							 ASideGrindWd [0] = Math.GetLengthFrLineToPoint(TopOutLine[0].FP0 ,  TopOutLine[0].FP1, TopInLine[0].FP0);
							 ASideGrindMea[0] = 0.0f; // 가공량 측정 기준이 현재 없음(20180710)

						 }
					 }
					 if(FRightWall){
						 EasyImage::Threshold(&RotateImg,&RotateBinaryImg, RightEdgeThresHold);
						 if(LeftEdgeThresHold==0) {SingleLine->GImage = &RotateImg      ;  SingleLine->FThreshold =5 ;}
						 else                     {SingleLine->GImage = &RotateBinaryImg;  SingleLine->FThreshold =10;}

						 if(IsCircleTop){
							 SingleLine->IRoi->SetOrgX  (IRoi->GetOrgX()  );
							 SingleLine->IRoi->SetOrgY  (ASideCircleHeight+50);
							 SingleLine->IRoi->SetWidth (IRoi->GetWidth() );
							 SingleLine->IRoi->SetHeight(ImgH-(ASideCircleHeight+50));
							 SingleLine->SetIncrement(1 );
						 }
						 else {
							 SingleLine->IRoi->SetOrgX  (IRoi->GetOrgX()  );
							 SingleLine->IRoi->SetOrgY  (IRoi->GetOrgY()  );
							 SingleLine->IRoi->SetWidth (IRoi->GetWidth() );
							 SingleLine->IRoi->SetHeight(IRoi->GetHeight());
							 SingleLine->SetIncrement(5 );
						 }

						 SingleLine->SetOrientation(orEast);
						 // 							 if(IRoi->GetHeight()<350) SingleLine->SetIncrement(1 );
						 // 							 else                      SingleLine->SetIncrement(5 );
						 SingleLine->SetFindLineId(0);
						 SingleLine->FThreshold =10;

						 if(IsMarkBtm) SingleLine->SetEdgeType(0); // Black to White 
						 else          SingleLine->SetEdgeType(1); // White to Black  

						 SingleLine->OnExecute();
						 Line[2].FP0 = SingleLine->GetResultP0();
						 Line[2].FP1 = SingleLine->GetResultP1();

						 // Multi Round Test 
						 if((fabs(Line[2].FP0.x - Line[2].FP1.x)>2) && (Line[2].FP1.x >Line[2].FP0.x)) Line[2].FP0.x = Line[2].FP1.x;

						 // Btm,Top 상관없이 첫번째
						 // 비선형 아크영역으로 인해서 LeftLine 추가 조절해야함 
						 // 							 if(fabs(Line[2].FP0.x - Line[2].FP1.x)>2){
						 // 								 if(Line[2].FP0.x> Line[2].FP1.x) Line[2].FP1.x = Line[2].FP0.x;
						 // 								 if(Line[2].FP0.x< Line[2].FP1.x) Line[2].FP0.x = Line[2].FP1.x;
						 // 							 }

						 RightOutLine[0].FP0.x = Line[2].FP0.x;
						 RightOutLine[0].FP0.y = Line[2].FP0.y;
						 RightOutLine[0].FP1.x = Line[2].FP1.x;
						 RightOutLine[0].FP1.y = Line[2].FP1.y;

						 // LeftOutLine....make OutLine Data 
						 // 현재의 데이터를 넘겨준다 
						 // 검사중 기준라인을 찾지 못할경우 이전데이터 넘겨줘서 기준라인 생성함 
						 if(RightOutLine[0].FP0.x!=0.0f && RightOutLine[0].FP0.y!=0.0f && RightOutLine[0].FP1.x!=0.0f && RightOutLine[0].FP1.y!=0.0f){
							 PreRightOutLine[0].FP0.x = RightOutLine[0].FP0.x;    PreRightOutLine[0].FP1.x = RightOutLine[0].FP1.x;       
							 PreRightOutLine[0].FP0.y = RightOutLine[0].FP0.y;    PreRightOutLine[0].FP1.y = RightOutLine[0].FP1.y;       
						 } // 셀의 상단 시작부터 Broken 발생으로 데이터가 없는경우 
						 else if(RightOutLine[0].FP0.x==0.0f || RightOutLine[0].FP0.y==0.0f || RightOutLine[0].FP1.x==0.0f || RightOutLine[0].FP1.y==0.0f){
							 if(PreRightOutLine[0].FP0.x==0.0f && PreRightOutLine[0].FP0.y==0.0f && PreRightOutLine[0].FP1.x==0.0f && PreRightOutLine[0].FP1.y==0.0f){// 시작부분 Broken발생으로 데이터가 없는경우 
								 // Mark좌표를 기준으로 라인좌표값을 다시 설정함 
								 ROI_H = IRoi->GetHeight();
								 RightOutLine[0].FP0.x = Line[2].FP0.x;    RightOutLine[0].FP0.y = 0.0f        ;
								 RightOutLine[0].FP1.x = Line[2].FP1.x;    RightOutLine[0].FP1.y = (float)ROI_H;

								 //Line 데이터를 PreLine에 넘겨준다 
								 PreRightOutLine[0].FP0.x = RightOutLine[0].FP0.x;    PreRightOutLine[0].FP1.x = RightOutLine[0].FP1.x;       
								 PreRightOutLine[0].FP0.y = RightOutLine[0].FP0.y;    PreRightOutLine[0].FP1.y = RightOutLine[0].FP1.y;       
							 }
							 else { // 중간부분 Broken발생으로 데이터가 없는경우 
								 // PreLine 데이터를 넘겨줌 
								 RightOutLine[0].FP0.x = PreRightOutLine[0].FP0.x;  RightOutLine[0].FP1.x = PreRightOutLine[0].FP1.x;  
								 RightOutLine[0].FP0.y = PreRightOutLine[0].FP0.y;  RightOutLine[0].FP1.y = PreRightOutLine[0].FP1.y;  
							 }
						 }
					 }
					 // Org Image Rotate 후 교차점 다시 계산 
					 FLTPoint = Math.OnIntersect(Line[waLeftWall ].FP0, Line[waLeftWall ].FP1, Line[waTopWall].FP0, Line[waTopWall].FP1);
					 FRTPoint = Math.OnIntersect(Line[waRightWall].FP0, Line[waRightWall].FP1, Line[waTopWall].FP0, Line[waTopWall].FP1);

					 if(FLeftTop){ // Notch 교차점은 무조건 찾는다 
						 // 						     LogUnit.SetLog("shRectH_Rotate_LeftTop_Start");     
						 EasyImage::Threshold(&RotateImg,&RotateBinaryImg, ECThresHold);
						 EasyImage::Threshold(&RotateImg,&RotateGrindBinaryImg, CorGrindMeaThresHold);
						 // 							 RotateGrindBinaryImg.Save("D:\\ROTATE_IMG\\RotateImg회전_HAP_CorGrind.bmp");
						 // 						     RotateImg.Save("D:\\ROTATE_IMG\\RotateImg_HAP_원본.bmp");

						 if(ECThresHold==0)  {SingleLine->GImage = &RotateImg      ;  SingleLine->FThreshold =5 ;}
						 else                {SingleLine->GImage = &RotateBinaryImg;  SingleLine->FThreshold =10;}

						 OrgPoint = Math.OnIntersect(Line[waLeftWall].FP0, Line[waLeftWall].FP1, Line[waTopWall].FP0, Line[waTopWall].FP1);
						 FLTPoint = OrgPoint;

						 // Left Mark To TopSide Height 
						 if(IsMarkBtm){
							 if(FP0.x!=0.0f && FP0.y!=0.0f && Line[1].FP0.x!=0.0f && Line[1].FP0.y!=0.0f && Line[1].FP1.x!=0.0f && Line[1].FP1.y!=0.0f ) {
								 FP0 = Math.OnRotate(CenterPoint,FP0, -ImgDegree);
								 LeftMarkToTopHeight = GetLengthFrLineToPoint(Line[1].FP0, Line[1].FP1, FP0);
								 // 								 LeftMarkToTopHeight = FP0.y - Line[1].FP0.y;
							 }
							 // Right Mark To TopSide Height 
							 if(FP1.x!=0.0f && FP1.y!=0.0f && Line[1].FP0.x!=0.0f && Line[1].FP0.y!=0.0f && Line[1].FP1.x!=0.0f && Line[1].FP1.y!=0.0f ) {
								 FP1 = Math.OnRotate(CenterPoint,FP1, -ImgDegree);
								 RightMarkToTopHeight = GetLengthFrLineToPoint(Line[1].FP0, Line[1].FP1, FP1);
								 // 								 RightMarkToTopHeight = FP1.y - Line[1].FP1.y;
							 }
							 // Center Mark To TopSide Height
							 if(LeftMarkToTopHeight!=0.0f && RightMarkToTopHeight!=0.0f){
								 CenMarkToTopHeight = ((FP0.y+FP1.y)/2.0) - ((Line[1].FP0.y+Line[1].FP1.y)/2.0);
							 }
						 }

						 if(IsCornerTop){ //코너 연마량 설정되어 있을경우 코너 검사진행함(Dx,Dy,R,GW,GM 측정함)
							 if(AMarkToGrindMarkDvX==0.0f && AMarkToGrindMarkDvY==0.0f){ // 3Point 기준으로 가공량 측정 방법 적용 시퀀스 
								 // Corner 연마 외곽라인 
								 SingleLine->IRoi->SetOrgX  ((int)OrgPoint.x-10    );
								 SingleLine->IRoi->SetOrgY  ((int)OrgPoint.y       );
								 SingleLine->IRoi->SetWidth ((int)LTCornerWidth+20 );
								 SingleLine->IRoi->SetHeight((int)LTCornerHeight   );

								 // 								 SingleLine->SetOrientation(orNorth);
								 SingleLine->SetOrientation(orWest);
								 SingleLine->FIncrement =1;
								 SingleLine->FThreshold =15;
								 SingleLine->SetFindLineId(0);
								 SingleLine->SetEdgeType(1);  //White To Black 
								 SingleLine->OnExecute();
								 // 									Line[waLeftTop].FP0 = SingleLine->GetResultP0();
								 // 									Line[waLeftTop].FP1 = SingleLine->GetResultP1();
								 Line[4].FP0 = SingleLine->GetResultP0();
								 Line[4].FP1 = SingleLine->GetResultP1();

								 // ORG 교차점 
								 FLTLPoint = Math.OnIntersect(SingleLine->GetResultP0(), SingleLine->GetResultP1(), Line[waLeftWall].FP0, Line[waLeftWall].FP1);
								 FLTTPoint = Math.OnIntersect(SingleLine->GetResultP0(), SingleLine->GetResultP1(), Line[waTopWall ].FP0, Line[waTopWall ].FP1);

								 if((FLTLPoint.x==0 || FLTLPoint.y==0 || FLTTPoint.x==0 || FLTTPoint.y==0) || (SingleLine->FEdgePointCount <30)){
									 LTDx = 0.0f;
									 LTDy = 0.0f;
									 //화면에 디스플레이 위해서 
									 FLTLPoint.x = FLTPoint.x;
									 FLTLPoint.y = FLTPoint.y;
									 FLTTPoint.x = FLTPoint.x;
									 FLTTPoint.y = FLTPoint.y;
								 }
								 else { 
									 LTDx = Math.GetLengthFrPointToPoint(FLTPoint, FLTTPoint);
									 LTDy = Math.GetLengthFrPointToPoint(FLTPoint, FLTLPoint);

									 // OutLine C1Corner Data 
									 if((SingleLine->FEdgePointCount) - (CornerMargin*2)>0){
										 if(C1Point!=NULL) delete[] C1Point;
										 C1Point  = new TFPoint [(SingleLine->FEdgePointCount) - (CornerMargin*2)];
										 C1EdgeCount = (SingleLine->FEdgePointCount) -(CornerMargin*2);

										 CornerCount =0;  
										 for(int k=CornerMargin; k<((SingleLine->FEdgePointCount)-CornerMargin); k++){
											 if(CornerCount>=MAX_CORNER_POINT) break;
											 C1Point[CornerCount].x = SingleLine->FEdgePoint[k].x;
											 C1Point[CornerCount].y = SingleLine->FEdgePoint[k].y;
											 CornerCount++;
										 }
									 }

									 double Dis =0.0f, AvgGrindWidth=0.0f, AvgGrindMea=0.0f, TotalGrindWidth=0.0f, TotalGrindMeasure=0.0f;
									 // Corner Grind In Gray Level 편차로 인해서 Corner Grind Out/In ThresHold값을 분류하다 
									 // Corner Grind In Start 
									 if(CorGrindInThresHold!=0){ // Corner InLine Search Sequence 
										 EasyImage::Threshold(&RotateImg,&RotateBinaryImg, CorGrindInThresHold);
										 SingleLine->GImage = &RotateBinaryImg;  SingleLine->FThreshold =10;

										 // Corner 기울기 완만하여 Edge찾을 경우 Defect 오버킬 발생함 
										 // 방향을 Top방향에서 다시 엣지를 찾음 (Corner Defect OverKill 감소 목적)
										 // if(LTCornerWidth >(LTCornerHeight*3)){
										 if(LTCornerWidth >(LTCornerHeight*1.5)){
											 SingleLine->IRoi->SetOrgX  ((int)FLTPoint.x );
											 SingleLine->IRoi->SetOrgY  ((int)FLTPoint.y );
											 SingleLine->IRoi->SetWidth ((int)((FLTTPoint.x - FLTLPoint.x+5 )));
											 SingleLine->IRoi->SetHeight((int)((FLTLPoint.y - FLTTPoint.y+10)));

											 if(FLTPoint.x<=0    || FLTPoint.y<=0    || (FLTTPoint.x - FLTLPoint.x)<=0    || (FLTLPoint.y - FLTTPoint.y)<=0   ) return false;
											 if(FLTPoint.x>=ImgW || FLTPoint.y>=ImgH || (FLTTPoint.x - FLTLPoint.x)>=ImgW || (FLTLPoint.y - FLTTPoint.y)>=ImgH) return false;

											 SingleLine->SetOrientation(orNorth);
											 SingleLine->FIncrement =2;
											 SingleLine->SetFindLineId(0);
											 SingleLine->SetEdgeType(0);  //Black To White 
											 SingleLine->OnExecute();

											 // InLine C1Corner Data 
											 if((SingleLine->FEdgePointCount) - (CornerMargin*2)>0){
												 if(C1InPoint!=NULL) delete[] C1InPoint;
												 C1InPoint  = new TFPoint [(SingleLine->FEdgePointCount) - (CornerMargin*2)];
												 C1InEdgeCount = (SingleLine->FEdgePointCount) -(CornerMargin*2);

												 CornerCount =0;  
												 for(int k=CornerMargin; k<((SingleLine->FEdgePointCount)-CornerMargin); k++){
													 if(CornerCount>=MAX_CORNER_POINT) break;
													 C1InPoint[CornerCount].x = SingleLine->FEdgePoint[k].x;
													 C1InPoint[CornerCount].y = SingleLine->FEdgePoint[k].y;
													 CornerCount++;
												 }
											 }
										 }
										 else {
											 // Corner 연마 안쪽라인 찾는다 
											 SingleLine->SetOrientation(orWest);
											 SingleLine->SetFindLineId(0);
											 SingleLine->FIncrement =1;
											 SingleLine->SetEdgeType(0);  //Black To White 
											 SingleLine->OnExecute();

											 // InLine C1Corner Data 
											 if((SingleLine->FEdgePointCount) - (CornerMargin*2)>0){
												 if(C1InPoint!=NULL) delete[] C1InPoint;
												 C1InPoint  = new TFPoint [(SingleLine->FEdgePointCount) - (CornerMargin*2)];
												 C1InEdgeCount = (SingleLine->FEdgePointCount) -(CornerMargin*2);

												 CornerCount =0;  
												 for(int k=CornerMargin; k<((SingleLine->FEdgePointCount)-CornerMargin); k++){
													 if(CornerCount>=MAX_CORNER_POINT) break;
													 C1InPoint[CornerCount].x = SingleLine->FEdgePoint[k].x;
													 C1InPoint[CornerCount].y = SingleLine->FEdgePoint[k].y;
													 CornerCount++;
												 }
											 }
										 }

										 //코너 연마안쪽라인 기준 새로운 교차점 생성 
										 FLTLInPoint = Math.OnIntersect(SingleLine->GetResultP0(), SingleLine->GetResultP1(), Line[waLeftWall].FP0, Line[waLeftWall].FP1);
										 FLTTInPoint = Math.OnIntersect(SingleLine->GetResultP0(), SingleLine->GetResultP1(), Line[waTopWall ].FP0, Line[waTopWall ].FP1);

										 //코너 연마폭 
										 Dis =0.0f, AvgGrindWidth=0.0f, AvgGrindMea=0.0f, TotalGrindWidth=0.0f, TotalGrindMeasure=0.0f;
										 for(int k=0; k<C1InEdgeCount; k++){
											 Dis = Math.GetLengthFrLineToPoint(FLTLPoint, FLTTPoint, C1InPoint[k]);
											 TotalGrindWidth+=Dis;
										 }
										 if(C1InEdgeCount!=0){
											 AvgGrindWidth = (TotalGrindWidth/C1InEdgeCount);
											 C1CorGrindWd  = AvgGrindWidth;
										 }
									 }
									 // Corner Grind In End 

									 if(CorGrindMeaThresHold!=0){ // Corner Grind ThresHold값이 설정되어 있을경우만 연마량 검사를 진행한다 
										 // 코너 연마량 기준 라인을 찾는다 
										 // ROI 영역 설정(3개의 흰색 점선 기준 라인을 찾는다)
										 if(CorGrindMeaThresHold==0){SingleLine->GImage = &RotateImg           ;  SingleLine->FThreshold =5 ;}
										 else                       {SingleLine->GImage = &RotateGrindBinaryImg;  SingleLine->FThreshold =10;}

										 // 존나 찝찝함....일단 스팩을 받기전까지 임시로 영역을 분류하여 CornerEdgePoint 찾자 
										 if(LTCornerWidth >(LTCornerHeight*1.5)){
											 SingleLine->IRoi->SetOrgX  ((int)OrgPoint.x       );
											 SingleLine->IRoi->SetOrgY  ((int)OrgPoint.y+30    );
											 SingleLine->IRoi->SetWidth (LTCornerWidth -50     );
											 SingleLine->IRoi->SetHeight((int)LTCornerHeight-40);

											 SingleLine->SetOrientation(orNorth);
											 SingleLine->SetFindLineId(0);
											 SingleLine->FIncrement =1;
											 SingleLine->SetEdgeType(0);  //Black To White 
											 SingleLine->OnExecute();

											 // C1Corner Grind Measure Stand Data 
											 if((SingleLine->FEdgePointCount)>0){
												 if(C1MeaPoint!=NULL) delete[] C1MeaPoint;
												 C1MeaPoint     = new TFPoint [(SingleLine->FEdgePointCount)];
												 C1MeaEdgeCount = (SingleLine->FEdgePointCount);

												 CornerCount =0;  
												 for(int k=0; k<(SingleLine->FEdgePointCount); k++){
													 if(CornerCount>=MAX_CORNER_POINT) break;
													 if(k==0               ) P1 = SingleLine->FEdgePoint[k];
													 if(k==C1MeaEdgeCount-1) P2 = SingleLine->FEdgePoint[k];
													 C1MeaPoint[CornerCount].x = SingleLine->FEdgePoint[k].x;
													 C1MeaPoint[CornerCount].y = SingleLine->FEdgePoint[k].y;
													 CornerCount++;
												 }
											 }

											 FLTLMeaPoint = Math.OnIntersect(P1, P2, Line[waLeftWall].FP0, Line[waLeftWall].FP1);
											 FLTTMeaPoint = Math.OnIntersect(P1, P2, Line[waTopWall ].FP0, Line[waTopWall ].FP1);


											 //코너 연마량 계산  
											 Dis =0.0f, AvgGrindMea=0.0f, TotalGrindMeasure=0.0f;
											 for(int k=0; k<C1EdgeCount; k++){
												 Dis = Math.GetLengthFrLineToPoint(FLTLMeaPoint, FLTTMeaPoint, C1Point[k]);
												 TotalGrindMeasure+=Dis;
											 }
											 if(C1EdgeCount!=0){
												 AvgGrindMea    = (TotalGrindMeasure/C1EdgeCount);
												 C1CorGrindMea  = AvgGrindMea;
											 }
										 }
										 else {
											 SingleLine->IRoi->SetOrgX  ((int)OrgPoint.x+15    );
											 SingleLine->IRoi->SetOrgY  ((int)OrgPoint.y+15    );
											 SingleLine->IRoi->SetWidth ((int)LTCornerWidth    );
											 SingleLine->IRoi->SetHeight((int)LTCornerHeight   );

											 SingleLine->SetOrientation(orWest);
											 SingleLine->SetFindLineId(0);
											 SingleLine->FIncrement =1;
											 SingleLine->SetEdgeType(0);  //Black To White 
											 SingleLine->OnExecute();

											 P1 = SingleLine->GetResultP0();
											 P2 = SingleLine->GetResultP1();

											 //코너 연마량 기준 라인과 새로운 교차점 생성 
											 FLTLMeaPoint = Math.OnIntersect(SingleLine->GetResultP0(), SingleLine->GetResultP1(), Line[waLeftWall].FP0, Line[waLeftWall].FP1);
											 FLTTMeaPoint = Math.OnIntersect(SingleLine->GetResultP0(), SingleLine->GetResultP1(), Line[waTopWall ].FP0, Line[waTopWall ].FP1);

											 // C1Corner Grind Measure Stand Data 
											 if((SingleLine->FEdgePointCount)>0){
												 if(C1MeaPoint!=NULL) delete[] C1MeaPoint;
												 C1MeaPoint     = new TFPoint [(SingleLine->FEdgePointCount)];
												 C1MeaEdgeCount = (SingleLine->FEdgePointCount);

												 CornerCount =0;  
												 for(int k=0; k<(SingleLine->FEdgePointCount); k++){
													 if(CornerCount>=MAX_CORNER_POINT) break;
													 C1MeaPoint[CornerCount].x = SingleLine->FEdgePoint[k].x;
													 C1MeaPoint[CornerCount].y = SingleLine->FEdgePoint[k].y;
													 CornerCount++;
												 }
											 }
											 //코너 연마량 계산  
											 Dis =0.0f, AvgGrindMea=0.0f, TotalGrindMeasure=0.0f;
											 for(int k=0; k<C1EdgeCount; k++){
												 Dis = Math.GetLengthFrLineToPoint(FLTLMeaPoint, FLTTMeaPoint, C1Point[k]);
												 TotalGrindMeasure+=Dis;
											 }
											 if(C1EdgeCount!=0){
												 AvgGrindMea    = (TotalGrindMeasure/C1EdgeCount);
												 C1CorGrindMea  = AvgGrindMea;
											 }
										 }
									 }
								 }		
							 }
							 else { // 십자가 마크 기준 연마량,가공량 측정 시퀀스 
								 TFPoint C1GrindRectPoint(0.0f, 0.0f);
								 // Corner 연마 외곽라인 
								 SingleLine->IRoi->SetOrgX  ((int)OrgPoint.x-10    );
								 SingleLine->IRoi->SetOrgY  ((int)OrgPoint.y       );
								 SingleLine->IRoi->SetWidth ((int)LTCornerWidth+20 );
								 SingleLine->IRoi->SetHeight((int)LTCornerHeight   );

								 SingleLine->SetOrientation(orWest);
								 SingleLine->FIncrement =1;
								 SingleLine->FThreshold =15;
								 SingleLine->SetFindLineId(0);
								 SingleLine->SetEdgeType(1);  //White To Black 
								 SingleLine->OnExecute();

								 Line[4].FP0 = SingleLine->GetResultP0();
								 Line[4].FP1 = SingleLine->GetResultP1();

								 // ORG 교차점 
								 FLTLPoint = Math.OnIntersect(SingleLine->GetResultP0(), SingleLine->GetResultP1(), Line[waLeftWall].FP0, Line[waLeftWall].FP1);
								 FLTTPoint = Math.OnIntersect(SingleLine->GetResultP0(), SingleLine->GetResultP1(), Line[waTopWall ].FP0, Line[waTopWall ].FP1);

								 if((FLTLPoint.x==0 || FLTLPoint.y==0 || FLTTPoint.x==0 || FLTTPoint.y==0) || (SingleLine->FEdgePointCount <30)){
									 LTDx = 0.0f;
									 LTDy = 0.0f;
									 //화면에 디스플레이 위해서 
									 FLTLPoint.x = FLTPoint.x;
									 FLTLPoint.y = FLTPoint.y;
									 FLTTPoint.x = FLTPoint.x;
									 FLTTPoint.y = FLTPoint.y;
								 }
								 else { 
									 LTDx = Math.GetLengthFrPointToPoint(FLTPoint, FLTTPoint);
									 LTDy = Math.GetLengthFrPointToPoint(FLTPoint, FLTLPoint);

									 // OutLine C1Corner Data 
									 if((SingleLine->FEdgePointCount) - (CornerMargin*2)>0){
										 if(C1Point!=NULL) {
											 delete[] C1Point;
										 }
										 C1Point  = new TFPoint [(SingleLine->FEdgePointCount) - (CornerMargin*2)];
										 C1EdgeCount = (SingleLine->FEdgePointCount) -(CornerMargin*2);

										 CornerCount =0;  
										 for(int k=CornerMargin; k<((SingleLine->FEdgePointCount)-CornerMargin); k++){
											 if(CornerCount>=MAX_CORNER_POINT) break;
											 C1Point[CornerCount].x = SingleLine->FEdgePoint[k].x;
											 C1Point[CornerCount].y = SingleLine->FEdgePoint[k].y;
											 CornerCount++;
										 }
									 }

									 double Dis =0.0f, AvgGrindWidth=0.0f, AvgGrindMea=0.0f, TotalGrindWidth=0.0f, TotalGrindMeasure=0.0f;
									 // Corner Grind In Gray Level 편차로 인해서 Corner Grind Out/In ThresHold값을 분류하다 
									 // Corner Grind In Start 
									 if(CorGrindInThresHold!=0){ // Corner InLine Search Sequence 
										 EasyImage::Threshold(&RotateImg,&RotateBinaryImg, CorGrindInThresHold);
										 SingleLine->GImage = &RotateBinaryImg;  SingleLine->FThreshold =10;

										 // Corner 기울기 완만하여 Edge찾을 경우 Defect 오버킬 발생함 
										 // 방향을 Top방향에서 다시 엣지를 찾음 (Corner Defect OverKill 감소 목적)
										 // if(LTCornerWidth >(LTCornerHeight*3)){
										 if(LTCornerWidth >(LTCornerHeight*1.5)){
											 SingleLine->IRoi->SetOrgX  ((int)FLTPoint.x );
											 SingleLine->IRoi->SetOrgY  ((int)FLTPoint.y );
											 SingleLine->IRoi->SetWidth ((int)((FLTTPoint.x - FLTLPoint.x+5 )));
											 SingleLine->IRoi->SetHeight((int)((FLTLPoint.y - FLTTPoint.y+10)));

											 if(FLTPoint.x<=0    || FLTPoint.y<=0    || (FLTTPoint.x - FLTLPoint.x)<=0    || (FLTLPoint.y - FLTTPoint.y)<=0   ) return false;
											 if(FLTPoint.x>=ImgW || FLTPoint.y>=ImgH || (FLTTPoint.x - FLTLPoint.x)>=ImgW || (FLTLPoint.y - FLTTPoint.y)>=ImgH) return false;

											 SingleLine->SetOrientation(orNorth);
											 SingleLine->FIncrement =2;
											 SingleLine->SetFindLineId(0);
											 SingleLine->SetEdgeType(0);  //Black To White 
											 SingleLine->OnExecute();

											 // InLine C1Corner Data 
											 if((SingleLine->FEdgePointCount) - (CornerMargin*2)>0){
												 if(C1InPoint!=NULL) delete[] C1InPoint;
												 C1InPoint  = new TFPoint [(SingleLine->FEdgePointCount) - (CornerMargin*2)];
												 C1InEdgeCount = (SingleLine->FEdgePointCount) -(CornerMargin*2);

												 CornerCount =0;  
												 for(int k=CornerMargin; k<((SingleLine->FEdgePointCount)-CornerMargin); k++){
													 if(CornerCount>=MAX_CORNER_POINT) break;
													 C1InPoint[CornerCount].x = SingleLine->FEdgePoint[k].x;
													 C1InPoint[CornerCount].y = SingleLine->FEdgePoint[k].y;
													 CornerCount++;
												 }
											 }
										 }
										 else {
											 // Corner 연마 안쪽라인 찾는다 
											 SingleLine->SetOrientation(orWest);
											 SingleLine->SetFindLineId(0);
											 SingleLine->FIncrement =1;
											 SingleLine->SetEdgeType(0);  //Black To White 
											 SingleLine->OnExecute();

											 // InLine C1Corner Data 
											 if((SingleLine->FEdgePointCount) - (CornerMargin*2)>0){
												 if(C1InPoint!=NULL){
													 delete[] C1InPoint;
												 }
												 C1InPoint  = new TFPoint [(SingleLine->FEdgePointCount) - (CornerMargin*2)];
												 C1InEdgeCount = (SingleLine->FEdgePointCount) -(CornerMargin*2);

												 CornerCount =0;  
												 for(int k=CornerMargin; k<((SingleLine->FEdgePointCount)-CornerMargin); k++){
													 if(CornerCount>=MAX_CORNER_POINT) break;
													 C1InPoint[CornerCount].x = SingleLine->FEdgePoint[k].x;
													 C1InPoint[CornerCount].y = SingleLine->FEdgePoint[k].y;
													 CornerCount++;
												 }
											 }
										 }

										 //코너 연마안쪽라인 기준 새로운 교차점 생성 
										 FLTLInPoint = Math.OnIntersect(SingleLine->GetResultP0(), SingleLine->GetResultP1(), Line[waLeftWall].FP0, Line[waLeftWall].FP1);
										 FLTTInPoint = Math.OnIntersect(SingleLine->GetResultP0(), SingleLine->GetResultP1(), Line[waTopWall ].FP0, Line[waTopWall ].FP1);
									 }

									 // GrindMark기준 연마량,가공량 측정함 
									 // LeftTop 
									 if(FP0.x!=0.0f && FP0.y!=0.0f){
										 GrindMarkRect[25].left   = (FP0.x-AMarkToGrindMarkDvX)-40;
										 GrindMarkRect[25].top    = (FP0.y+AMarkToGrindMarkDvY)-40;
										 GrindMarkRect[25].right  = (GrindMarkRect[25].left + 80);
										 GrindMarkRect[25].bottom = (GrindMarkRect[25].top  + 80);

										 GrindRectWidth  = (GrindMarkRect[25].right  - GrindMarkRect[25].left);
										 GrindRectHeight = (GrindMarkRect[25].bottom - GrindMarkRect[25].top );

										 // 원본이미지에서 Mark 찾는다 
										 Find->OnLoad(true,FindDir,1)                   ;
										 Find->GImage  = &RotateImg                     ;
										 //Find->SetContrastMode(EFindContrastMode_Any)   ;
										 Find->SetContrastMode(EFindContrastMode_Normal);
										 //Find->SetMinScore(0.8f)                        ;
										 Find->SetMinScore (GrindPadMarkMinScore)       ; // PatternrFind 검사 최소 Score
										 Find->SetZeroScore(GrindPadMarkMinScore)       ; // 검사 후 최소 Score 
										 //ind->SetMinScore (0.75)                       ; // PatternrFind 검사 최소 Score
										 //ind->SetZeroScore(0.75)                       ; // 검사 후 최소 Score 
										 Find->SetMaxInstances(1)                       ;
										 Find->SetAngleTolerance(20.0f)                 ;
										 Find->SetAngleBias(45.0f)                      ;
										 Find->SetScaleBias(1.00f)                      ;
										 Find->SetScaleTolerance(0.0f)                  ;
										 Find->Property.Ox = (float)ImgW/2              ;
										 Find->Property.Oy = (float)ImgH/2              ;

										 Find->IRoi->SetPlacement(GrindMarkRect[25].left,GrindMarkRect[25].top,GrindRectWidth,GrindRectHeight);
										 if(GrindMarkRect[25].left<=0 || GrindMarkRect[25].top<=0 || GrindRectWidth<=0 || GrindRectHeight<=0) return false;

										 // 검사 및 Match Pos 좌표 받어온다 
										 // Find 검사 성공시 데이터 받아옴 
										 if(Find->OnExecute()){
											 GrindMarkPoint[25].x = Find->Result[0].Px;
											 GrindMarkPoint[25].y = Find->Result[0].Py;
											 GrindMarkScore[25]   = Find->Result[0].Score;
										 }
										 // Contrast Gradient Pixel Value
										 GrindMarkGradient[25] = EasyImage::Focusing(Find->IRoi);
									 }

									 // GrindMakr찾을경우 연마량,가공량 측정함
									 if(GrindMarkPoint[25].x!=0.0f && GrindMarkPoint[25].y!=0.0f){
										 // GrindMark기준 OutData 최단거리 Count정보 Calc 
										 GrindMeaDis =0.0f, MinDis =10000.0f; GrindMarkOutCnt=0;
										 for(int k=0; k<C1EdgeCount; k++){
											 if(C1Point[k].x  ==0.0f       || C1Point[k].y        ==0.0f) continue;
											 if(GrindMarkPoint[25].x==0.0f || GrindMarkPoint[25].y==0.0f) continue;

											 GrindMeaDis = Math.GetLength(GrindMarkPoint[25], C1Point[k]);
											 if(GrindMeaDis<MinDis){
												 MinDis = GrindMeaDis;
												 GrindMarkOutCnt = k;
											 }
										 }
										 // OutData기준 InData 최단거리 Count정보 Calc 
										 if(GrindMarkOutCnt!=0){
											 GrindMeaDis =0.0f, MinDis =10000.0f; GrindMarkInCnt=0;
											 for(int k=0; k<C1InEdgeCount; k++){
												 if(C1InPoint[k].x   ==0.0f          || C1InPoint[k].y             ==0.0f) continue;
												 if(C1Point[GrindMarkOutCnt].x==0.0f || C1Point[GrindMarkOutCnt].y ==0.0f) continue;

												 GrindMeaDis = Math.GetLength(C1Point[GrindMarkOutCnt], C1InPoint[k]);
												 if(GrindMeaDis<MinDis){
													 MinDis = GrindMeaDis;
													 GrindMarkInCnt = k;
												 }
											 }
										 }

										 // GrindMark기준 수직 포인트 주변값 Avg산출한다 ==>가공량 측정(OutData기준)
										 if(GrindMarkOutCnt!=0 && GrindMarkOutCnt>5){
											 CircleCount=0,TotalCirDis=0.0f,GrindMeaDis=0.0f;
											 for(int k=GrindMarkOutCnt-5; k<GrindMarkOutCnt+5; k++){
												 if(C1Point[k].x==0.0f || C1Point[k].y==0.0f) continue;

												 GrindMeaDis = Math.GetLength(GrindMarkPoint[25], C1Point[k]);
												 TotalCirDis+= GrindMeaDis;
												 CircleCount++;
											 }
											 if(TotalCirDis!=0.0f && CircleCount!=0){
												 C1CorGrindMea = TotalCirDis/CircleCount;
											 }
										 }

										 // GrindMark기준 수직 포인트 주변값 Avg산출한다 ==>연마량 측정(OutData,InData기준)
										 if((GrindMarkOutCnt!=0 && GrindMarkOutCnt>5) && (GrindMarkInCnt!=0 && GrindMarkInCnt>5)){
											 CircleCount=0,TotalCirDis=0.0f,GrindWidthDis=0.0f;
											 for(int k=-5; k<5; k++){
												 if(C1Point  [GrindMarkOutCnt+k].x==0.0f && C1Point  [GrindMarkOutCnt+k].y==0.0f) continue;
												 if(C1InPoint[GrindMarkInCnt +k].x==0.0f && C1InPoint[GrindMarkInCnt +k].y==0.0f) continue;
												 GrindWidthDis = Math.GetLength(C1InPoint[GrindMarkInCnt+k], C1Point[GrindMarkOutCnt+k]);
												 TotalCirDis+=   GrindWidthDis;
												 CircleCount++;
											 }
											 if(TotalCirDis!=0.0f && CircleCount!=0){
												 C1CorGrindWd  = TotalCirDis/CircleCount;
											 }
										 }
									 }
									 else { // GrindMrk 못찾을경우 연마량만 측정함 
										 // OutData기준 최소값 데이터 Count산출 
										 GrindMeaDis =0.0f, MinDis =10000.0f; GrindMarkOutCnt=0;
										 for(int k=0; k<C1EdgeCount; k++){
											 if(C1Point[k].x==0.0f || C1Point[k].y==0.0f) continue;

											 C1GrindRectPoint.x = GrindMarkRect[25].left + (GrindMarkRect[25].right  - GrindMarkRect[25].left)/2; 
											 C1GrindRectPoint.y = GrindMarkRect[25].top  + (GrindMarkRect[25].bottom - GrindMarkRect[25].top )/2; 

											 GrindMeaDis = Math.GetLength(C1GrindRectPoint, C1Point[k]);
											 if(GrindMeaDis<MinDis){
												 MinDis = GrindMeaDis;
												 GrindMarkOutCnt = k;
											 }
										 }

										 // 최단거리OUtCount기준 InData 최단거리 Count정보 Calc 
										 if(GrindMarkOutCnt!=0){
											 GrindMeaDis =0.0f, MinDis =10000.0f; GrindMarkInCnt=0;
											 for(int k=0; k<C1InEdgeCount; k++){
												 if(C1InPoint[k].x            ==0.0f || C1InPoint[k].y             ==0.0f) continue;
												 if(C1Point[GrindMarkOutCnt].x==0.0f || C1Point[GrindMarkOutCnt].y ==0.0f) continue;

												 GrindMeaDis = Math.GetLength(C1Point[GrindMarkOutCnt], C1InPoint[k]);
												 if(GrindMeaDis<MinDis){
													 MinDis = GrindMeaDis;
													 GrindMarkInCnt = k;
												 }
											 }
										 }

										 // GrindMark기준 수직 포인트 주변값 Avg산출한다 ==>연마량 측정(OutData,InData기준)
										 if((GrindMarkOutCnt!=0 && GrindMarkOutCnt>5) && (GrindMarkInCnt!=0 && GrindMarkInCnt>5)){
											 CircleCount=0,TotalCirDis=0.0f,GrindWidthDis=0.0f;
											 for(int k=-5; k<5; k++){
												 if(C1Point  [GrindMarkOutCnt+k].x==0.0f && C1Point  [GrindMarkOutCnt+k].y==0.0f) continue;
												 if(C1InPoint[GrindMarkInCnt +k].x==0.0f && C1InPoint[GrindMarkInCnt +k].y==0.0f) continue;
												 GrindWidthDis = Math.GetLength(C1InPoint[GrindMarkInCnt+k], C1Point[GrindMarkOutCnt+k]);
												 TotalCirDis+=   GrindWidthDis;
												 CircleCount++;
											 }
											 if(TotalCirDis!=0.0f && CircleCount!=0){
												 C1CorGrindWd = TotalCirDis/CircleCount;
											 }
										 }
									 }
								 }		
							 }
						 }
						 else if(IsRectTop){ // 코너 설정값이 없을경우 교차점 기준 검사 Rect검사  
							 LTDx = 0.0f;
							 LTDy = 0.0f;
							 //화면에 디스플레이 위해서 
							 FLTLPoint.x = FLTPoint.x;
							 FLTLPoint.y = FLTPoint.y;
							 FLTTPoint.x = FLTPoint.x;
							 FLTTPoint.y = FLTPoint.y;
						 }
						 else if(IsCircleTop){ // TOP영역 LeftTop Circle 검사 
							 // A_Side Pad영역에는 TrackLine존재하지 않음, 즉 GrindMark기준 가공량,연마량 측정만 가능함 
							 // Org A1CircleData 
							 int OrgA1CirInEdgeCount =0;		  
							 int OrgA1CirOutEdgeCount=0;	    
							 int A1GrindWidthCount   =0;		  
							 int A1GrindMarkCount    =0;
							 int A1Diameter          =0;
							 GrindRectWidth          =0;
							 GrindRectHeight         =0;

							 TFPoint *OrgA1CirInPoint =NULL;	 
							 TFPoint *OrgA1CirOutPoint=NULL;

							 TFPoint AGrindMarkRectPoint1(0.0f, 0.0f);

							 // Find Mark Search Start
							 ////////////////////////////////////////////////////////////////////////////
							 if(IsMarkBtm && FInspectMode!=Insp_Track){
								 // 									 LogUnit.SetLog("CellID:%d, CamID:%d ==>A1MarkFind_START",CellId,CamId);     

								 if(FP0.x!=0.0f && FP0.y!=0.0f){
									 // 원본이미지에서 Mark 찾는다 
									 Find->OnLoad(true,FindDir,1)                   ;
									 Find->GImage  = &RotateImg                     ;
									 // 										 Find->SetContrastMode(EFindContrastMode_Any)   ;
									 Find->SetContrastMode(EFindContrastMode_Normal);
									 // 										 Find->SetMinScore(0.8f)                        ;
									 Find->SetMinScore (GrindPadMarkMinScore)       ; // PatternrFind 검사 최소 Score
									 Find->SetZeroScore(GrindPadMarkMinScore)       ; // 검사 후 최소 Score 
									 // 										 Find->SetMinScore (0.75)                       ; // PatternrFind 검사 최소 Score
									 // 										 Find->SetZeroScore(0.75)                       ; // 검사 후 최소 Score 
									 Find->SetMaxInstances(1)                       ;
									 Find->SetAngleTolerance(20.0f)                 ;
									 // 										 Find->SetAngleBias(45.0f)                      ;
									 Find->SetScaleBias(1.00f)                      ;
									 Find->SetScaleTolerance(0.0f)                  ;
									 Find->Property.Ox = (float)ImgW/2              ;
									 Find->Property.Oy = (float)ImgH/2              ;

									 // 첫번째 GrindMark기준 센터 25번 Search 
									 if(AMarkToGrindMarkDvX!=0.0f && AMarkToGrindMarkDvY!=0.0f){
										 GrindMarkRect[25].left   = (FP0.x-AMarkToGrindMarkDvX)-40;
										 GrindMarkRect[25].top    = (FP0.y+AMarkToGrindMarkDvY)-40;
										 GrindMarkRect[25].right  = (GrindMarkRect[25].left + 80);
										 GrindMarkRect[25].bottom = (GrindMarkRect[25].top  + 80);

										 GrindRectWidth  = (GrindMarkRect[25].right  - GrindMarkRect[25].left);
										 GrindRectHeight = (GrindMarkRect[25].bottom - GrindMarkRect[25].top );

										 Find->IRoi->SetPlacement(GrindMarkRect[25].left,GrindMarkRect[25].top,GrindRectWidth,GrindRectHeight);
										 if(GrindMarkRect[25].left<=0 || GrindMarkRect[25].top<=0 || GrindRectWidth<=0 || GrindRectHeight<=0) return false;

										 // 검사 및 Match Pos 좌표 받어온다 
										 // Find 검사 성공시 데이터 받아옴 
										 if(RqMode == true)
											 Find->SetAngleBias(35.0f);
										 else
											 Find->SetAngleBias(45.0f);
										 //Find->SetAngleBias(45.0f);
										 if(Find->OnExecute()){
											 GrindMarkPoint[25].x = Find->Result[0].Px;
											 GrindMarkPoint[25].y = Find->Result[0].Py;
											 GrindMarkScore[25]   = Find->Result[0].Score;
										 }
										 // Contrast Gradient Pixel Value
										 GrindMarkGradient[25] = EasyImage::Focusing(Find->IRoi);
									 }

									 // 두번째 GrindMark기준 센터 24번 Search 
									 if(AMarkToGrindMarkDvX2!=0.0f && AMarkToGrindMarkDvY2!=0.0f){
										 GrindMarkRect[24].left   = (FP0.x+AMarkToGrindMarkDvX2)-40;
										 GrindMarkRect[24].top    = (FP0.y+AMarkToGrindMarkDvY2)-40;
										 GrindMarkRect[24].right  = (GrindMarkRect[24].left + 80);
										 GrindMarkRect[24].bottom = (GrindMarkRect[24].top  + 80);

										 GrindRectWidth  = (GrindMarkRect[24].right  - GrindMarkRect[24].left);
										 GrindRectHeight = (GrindMarkRect[24].bottom - GrindMarkRect[24].top );

										 Find->IRoi->SetPlacement(GrindMarkRect[24].left,GrindMarkRect[24].top,GrindRectWidth,GrindRectHeight);
										 if(GrindMarkRect[24].left<=0 || GrindMarkRect[24].top<=0 || GrindRectWidth<=0 || GrindRectHeight<=0) return false;

										 // 검사 및 Match Pos 좌표 받어온다 
										 // Find 검사 성공시 데이터 받아옴 
										 Find->SetAngleBias(90.0f);
										 if(Find->OnExecute()){
											 GrindMarkPoint[24].x = Find->Result[0].Px;
											 GrindMarkPoint[24].y = Find->Result[0].Py;
											 GrindMarkScore[24]   = Find->Result[0].Score;
										 }
										 // Contrast Gradient Pixel Value
										 GrindMarkGradient[24] = EasyImage::Focusing(Find->IRoi);
									 }
								 }
								 // Find Mark Search Start
								 ////////////////////////////////////////////////////////////////////////////
								 // 									 LogUnit.SetLog("CellID:%d, CamID:%d ==>A1MarkFind_END",CellId,CamId);     
							 }

							 // NOTCH LeftTop 
							 if(FInspectMode==Insp_Polygon){ // 비선형 곡선 알고리즘 

								 // 									 RotateBinaryImg.Save("D:\\ROTATE_IMG\\Normal_LeftTop.bmp");
								 // 									 LogUnit.SetLog("CellID:%d, CamID:%d ==>LeftTop_Polygon_START",CellId,CamId);     

								 TPoint P1(0,0),P2(0,0),P3(0,0),P4(0,0);

								 // 									 P1.x = (int)(FLTPoint.x-20);    P1.y =(int)(FLTPoint.y-20            ); P2.x = (int)(P1.x+ASideCircleWidth+50);    P2.y = (int)(P1.y);
								 // 									 P3.x = (int)(FLTPoint.x-20);    P3.y =(int)(P1.y+ASideCircleHeight+50); P4.x = (int)(P2.x                    );    P4.y = (int)(P3.y);

								 // 									 P1.x = (int)(FLTPoint.x-20);    P1.y =(int)(FLTPoint.y-20            ); P2.x = (int)(P1.x+ASideCircleWidth+40);    P2.y = (int)(P1.y);
								 // 									 P3.x = (int)(FLTPoint.x-20);    P3.y =(int)(P1.y+ASideCircleHeight+40); P4.x = (int)(P2.x                    );    P4.y = (int)(P3.y);

								 P1.x = (int)(FLTPoint.x-20);    P1.y =(int)(FLTPoint.y-20            ); P2.x = (int)(P1.x+ASideCircleWidth+20);    P2.y = (int)(P1.y);
								 P3.x = (int)(FLTPoint.x-20);    P3.y =(int)(P1.y+ASideCircleHeight+20); P4.x = (int)(P2.x                    );    P4.y = (int)(P3.y);

								 // 검사화면 Display 목적 
								 PadPolyRect[0].left  = P1.x;   PadPolyRect[0].top    = P1.y;
								 PadPolyRect[0].right = P2.x;   PadPolyRect[0].bottom = P3.y;

								 int PixelCnt =0;

								 // Median Filter 적용 
								 if(P1.x<=0    || P1.y<=0    || (P2.x - P1.x)<=0    || (P3.y - P1.y)<=0   ) return false;
								 if(P1.x>=ImgW || P1.y>=ImgH || (P2.x - P1.x)>=ImgW || (P3.y - P1.y)>=ImgH) return false;
								 FilterROI.SetSize(int(P2.x - P1.x),int(P3.y - P1.y) )                      ;
								 FilterROI.Attach(&RotateBinaryImg)                                         ;
								 FilterROI.SetPlacement(P1.x, P1.y, int(P2.x - P1.x), int(P3.y - P1.y))     ;
								 LogUnit.SetLog(L"LeftTop ==>Px:%d, Py:%d, Width:%d, Height:%d ==>Median Filter",P1.x, P1.y, int(P2.x - P1.x), int(P3.y - P1.y));     
								 LogUnit.SetLog(L"LeftTop ==>P1x:%d, P1y:%d, P2x:%d, P2y:%d, P3x:%d, P3y:%d, P4x:%d, P4y:%d,",P1.x,P1.y,P2.x,P2.y,P3.x,P3.y,P4.x,P4.y);     
								 EasyImage::Median(&FilterROI, &FilterROI)                                  ;
								 //  									 RotateBinaryImg.Save("D:\\ROTATE_IMG\\Polygon_LeftTop_필터.bmp");

								 Polygon->GImage = &RotateBinaryImg                          ;
								 Polygon->IWidth = ImgW                                      ;
								 Polygon->IHeight= ImgH                                      ;
								 Polygon->PoPa.FMinWidth  =(int)(ASideCircleWidth/2)         ;                       
								 // 									 Polygon->PoPa.FMaxWidth  =(int)((FRTPoint.x - FLTPoint.x)/2);
								 Polygon->PoPa.FMaxWidth  =(int)(ASideCircleWidth+100)       ;
								 Polygon->PoPa.FMinHeight =(int)(ASideCircleHeight/2)        ;
								 // 									 Polygon->PoPa.FMaxHeight =1000                              ;
								 Polygon->PoPa.FMaxHeight =(int)(ASideCircleHeight+100)      ;
								 Polygon->PoPa.MinPxCnt   =100                               ;
								 Polygon->PoPa.MaxPxCnt   =20000                             ;
								 Polygon->PoPa.MaxBbCnt   =10                                ;
								 Polygon->PoPa.IsSeparate =true                              ;
								 Polygon->PoPa.IsInToOut  =false                             ;
								 Polygon->PoPa.HiThHold   = ECThresHold                      ;
								 Polygon->PoPa.LoThHold   = 0                                ;

								 if(P1.x!=0 && P1.y!=0 && P2.x!=0 && P2.y!=0 && P3.x!=0 && P3.y!=0 && P4.x!=0 && P4.y!=0){
									 Polygon->OnExecute(P1,P2,P3,P4);
								 }

								 // Polygon Algorithm InEdgeData/OutEdgeData Separate 
								 if(Polygon->BlobCount==1){
									 PolygonMarginCnt = (IsMarkBtm)? 5:20;
									 if(Polygon->Blob[0].InCnt>(PolygonMarginCnt*2)){
										 A1CirInEdgeCount=0;
										 A1CirInEdgeCount = (Polygon->Blob[0].InCnt - (PolygonMarginCnt*2));
										 if(A1CirInEdgeCount>0){
											 if(A1CirInPoint!=NULL) delete[] A1CirInPoint;
											 A1CirInPoint = new TFPoint[A1CirInEdgeCount];

											 PixelCnt=0;
											 for(int k=0; k<Polygon->Blob[0].InCnt; k++){
												 if(k<PolygonMarginCnt || k>=(Polygon->Blob[0].InCnt-PolygonMarginCnt)) continue;
												 A1CirInPoint[PixelCnt].x   = Polygon->Blob[0].InPoint[k].x ;
												 A1CirInPoint[PixelCnt].y   = Polygon->Blob[0].InPoint[k].y ;
												 PixelCnt++;
											 }
										 }
									 }

									 if(Polygon->Blob[0].OutCnt>(PolygonMarginCnt*2)){
										 A1CirOutEdgeCount=0;
										 A1CirOutEdgeCount = (Polygon->Blob[0].OutCnt - (PolygonMarginCnt*2));
										 if(A1CirOutEdgeCount>0){
											 if(A1CirOutPoint!=NULL) delete[] A1CirOutPoint;
											 A1CirOutPoint = new TFPoint[A1CirOutEdgeCount];

											 PixelCnt=0;
											 for(int k=0; k<Polygon->Blob[0].OutCnt; k++){
												 if(k<PolygonMarginCnt || k>=(Polygon->Blob[0].OutCnt-PolygonMarginCnt)) continue;
												 A1CirOutPoint[PixelCnt].x  = Polygon->Blob[0].OutPoint[k].x ;
												 A1CirOutPoint[PixelCnt].y  = Polygon->Blob[0].OutPoint[k].y ;
												 PixelCnt++;
											 }
										 }
									 }
									 // Polygon Data Clear
									 // 										 Polygon->ClearData();
								 }

								 // InEdgeData/OutEdgeData 기준 가공량 및 연마량 계산
								 // Polygon 알고리즘에서는 GrindMark기준 OutData,InData 최단거리 2개 Tag값 산출해야함 
								 if(IsMarkBtm){ // LTPS 가공량,연마량 계산 
									 if(A1CirOutEdgeCount!=0 && A1CirInEdgeCount!=0){ // MarkMode경우 가공량 검사를 먼저 진행 후 연마량 산출 
										 // 25번째 GrindMark Search 및 연마,가공 데이터 계산
										 /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
										 if(GrindMarkPoint[25].x!=0.0f && GrindMarkPoint[25].y!=0.0f){  //GrindMark 찾았을경우 
											 // GrindMark기준 OutData 최단거리 Count정보 Calc 
											 GrindMeaDis =0.0f, MinDis =10000.0f; GrindMarkOutCnt=0;
											 for(int k=0; k<A1CirOutEdgeCount; k++){
												 if(A1CirOutPoint[k].x  ==0.0f || A1CirOutPoint[k].y  ==0.0f) continue;
												 if(GrindMarkPoint[25].x==0.0f || GrindMarkPoint[25].y==0.0f) continue;

												 GrindMeaDis = Math.GetLength(GrindMarkPoint[25], A1CirOutPoint[k]);
												 if(GrindMeaDis<MinDis){
													 MinDis = GrindMeaDis;
													 GrindMarkOutCnt = k;
												 }
											 }
											 // GrindMark기준 InData 최단거리 Count정보 Calc 
											 GrindMeaDis =0.0f, MinDis =10000.0f; GrindMarkInCnt=0;
											 for(int k=0; k<A1CirInEdgeCount; k++){
												 if(A1CirInPoint[k].x   ==0.0f || A1CirInPoint[k].y    ==0.0f) continue;
												 if(GrindMarkPoint[25].x==0.0f || GrindMarkPoint[25].y ==0.0f) continue;

												 GrindMeaDis = Math.GetLength(GrindMarkPoint[25], A1CirInPoint[k]);
												 if(GrindMeaDis<MinDis){
													 MinDis = GrindMeaDis;
													 GrindMarkInCnt = k;
												 }
											 }

											 // GrindMark기준 InData 최단거리 Count정보 Calc 
											 if(GrindMarkOutCnt!=0){
												 GrindMeaDis =0.0f, MinDis =10000.0f; GrindMarkInCnt=0;
												 for(int k=0; k<A1CirInEdgeCount; k++){
													 if(A1CirInPoint[k].x   ==0.0f             || A1CirInPoint[k].y                ==0.0f) continue;
													 if(A1CirOutPoint[GrindMarkOutCnt].x==0.0f || A1CirOutPoint[GrindMarkOutCnt].y ==0.0f) continue;

													 GrindMeaDis = Math.GetLength(A1CirOutPoint[GrindMarkOutCnt], A1CirInPoint[k]);
													 if(GrindMeaDis<MinDis){
														 MinDis = GrindMeaDis;
														 GrindMarkInCnt = k;
													 }
												 }
											 }

											 // GrindMark기준 수직 포인트 주변값 Avg산출한다 ==>가공량 측정(OutData기준)
											 if(GrindMarkOutCnt!=0 && GrindMarkOutCnt>5){
												 CircleCount=0,TotalCirDis=0.0f,GrindMeaDis=0.0f;
												 for(int k=GrindMarkOutCnt-5; k<GrindMarkOutCnt+5; k++){
													 if(A1CirOutPoint[k].x==0.0f || A1CirOutPoint[k].y==0.0f) continue;

													 GrindMeaDis = Math.GetLength(GrindMarkPoint[25], A1CirOutPoint[k]);
													 TotalCirDis+= GrindMeaDis;
													 CircleCount++;
												 }
												 if(TotalCirDis!=0.0f && CircleCount!=0){
													 A1CirGrindMea[2] = TotalCirDis/CircleCount;
													 A1CirGrindMea[2] = A1CirGrindMea[2]+0.5; //SubPixel 
												 }
											 }

											 // GrindMark기준 수직 포인트 주변값 Avg산출한다 ==>연마량 측정(OutData,InData기준)
											 if((GrindMarkOutCnt!=0 && GrindMarkOutCnt>5) && (GrindMarkInCnt!=0 && GrindMarkInCnt>5)){
												 CircleCount=0,TotalCirDis=0.0f,GrindWidthDis=0.0f;
												 for(int k=-5; k<5; k++){
													 if(A1CirOutPoint[GrindMarkOutCnt+k].x==0.0f && A1CirOutPoint[GrindMarkOutCnt+k].y==0.0f) continue;
													 if(A1CirInPoint [GrindMarkInCnt +k].x==0.0f && A1CirInPoint [GrindMarkInCnt +k].y==0.0f) continue;
													 GrindWidthDis = Math.GetLength(A1CirInPoint[GrindMarkInCnt+k], A1CirOutPoint[GrindMarkOutCnt+k]);
													 TotalCirDis+=   GrindWidthDis;
													 CircleCount++;
												 }
												 if(TotalCirDis!=0.0f && CircleCount!=0){
													 A1CirGrindWd[2] = TotalCirDis/CircleCount;
													 A1CirGrindWd[2] = A1CirGrindWd[2]+0.5; //SubPixel
												 }
											 }
										 }
										 else if(GrindMarkRect[25].left!=0 && GrindMarkRect[25].top!=0 && GrindMarkRect[25].right!=0 && GrindMarkRect[25].bottom!=0){  //GrindMark 못 찾았을경우
											 // OutData기준 최소값 데이터 Count산출 
											 GrindMeaDis =0.0f, MinDis =10000.0f; GrindMarkOutCnt=0;
											 for(int k=0; k<A1CirOutEdgeCount; k++){
												 if(A1CirOutPoint[k].x==0.0f || A1CirOutPoint[k].y==0.0f) continue;

												 AGrindMarkRectPoint1.x = GrindMarkRect[25].left + (GrindMarkRect[25].right  - GrindMarkRect[25].left)/2; 
												 AGrindMarkRectPoint1.y = GrindMarkRect[25].top  + (GrindMarkRect[25].bottom - GrindMarkRect[25].top )/2; 

												 GrindMeaDis = Math.GetLength(AGrindMarkRectPoint1, A1CirOutPoint[k]);
												 if(GrindMeaDis<MinDis){
													 MinDis = GrindMeaDis;
													 GrindMarkOutCnt = k;
												 }
											 }

											 // 최단거리OUtCount기준 InData 최단거리 Count정보 Calc 
											 if(GrindMarkOutCnt!=0){
												 GrindMeaDis =0.0f, MinDis =10000.0f; GrindMarkInCnt=0;
												 for(int k=0; k<A1CirInEdgeCount; k++){
													 if(A1CirInPoint[k].x   ==0.0f             || A1CirInPoint[k].y                ==0.0f) continue;
													 if(A1CirOutPoint[GrindMarkOutCnt].x==0.0f || A1CirOutPoint[GrindMarkOutCnt].y ==0.0f) continue;

													 GrindMeaDis = Math.GetLength(A1CirOutPoint[GrindMarkOutCnt], A1CirInPoint[k]);
													 if(GrindMeaDis<MinDis){
														 MinDis = GrindMeaDis;
														 GrindMarkInCnt = k;
													 }
												 }
											 }

											 // GrindMark기준 수직 포인트 주변값 Avg산출한다 ==>연마량 측정(OutData,InData기준)
											 if((GrindMarkOutCnt!=0 && GrindMarkOutCnt>5) && (GrindMarkInCnt!=0 && GrindMarkInCnt>5)){
												 CircleCount=0,TotalCirDis=0.0f,GrindWidthDis=0.0f;
												 for(int k=-5; k<5; k++){
													 if(A1CirOutPoint[GrindMarkOutCnt+k].x==0.0f && A1CirOutPoint[GrindMarkOutCnt+k].y==0.0f) continue;
													 if(A1CirInPoint [GrindMarkInCnt +k].x==0.0f && A1CirInPoint [GrindMarkInCnt +k].y==0.0f) continue;
													 GrindWidthDis = Math.GetLength(A1CirInPoint[GrindMarkInCnt+k], A1CirOutPoint[GrindMarkOutCnt+k]);
													 TotalCirDis+=   GrindWidthDis;
													 CircleCount++;
												 }
												 if(TotalCirDis!=0.0f && CircleCount!=0){
													 A1CirGrindWd[2] = TotalCirDis/CircleCount;
													 A1CirGrindWd[2] = A1CirGrindWd[2]+0.5; //SubPixel
												 }
											 }
										 }
										 /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


										 // 24번째 GrindMark Search 및 연마,가공 데이터 계산
										 /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
										 if(GrindMarkPoint[24].x!=0.0f && GrindMarkPoint[24].y!=0.0f){  //GrindMark 찾았을경우 
											 // GrindMark기준 OutData 최단거리 Count정보 Calc 
											 GrindMeaDis =0.0f, MinDis =10000.0f; GrindMarkOutCnt=0;
											 for(int k=0; k<A1CirOutEdgeCount; k++){
												 if(A1CirOutPoint[k].x  ==0.0f || A1CirOutPoint[k].y  ==0.0f) continue;
												 if(GrindMarkPoint[24].x==0.0f || GrindMarkPoint[24].y==0.0f) continue;

												 GrindMeaDis = Math.GetLength(GrindMarkPoint[24], A1CirOutPoint[k]);
												 if(GrindMeaDis<MinDis){
													 MinDis = GrindMeaDis;
													 GrindMarkOutCnt = k;
												 }
											 }
											 // GrindMark기준 InData 최단거리 Count정보 Calc 
											 GrindMeaDis =0.0f, MinDis =10000.0f; GrindMarkInCnt=0;
											 for(int k=0; k<A1CirInEdgeCount; k++){
												 if(A1CirInPoint[k].x   ==0.0f || A1CirInPoint[k].y    ==0.0f) continue;
												 if(GrindMarkPoint[24].x==0.0f || GrindMarkPoint[24].y ==0.0f) continue;

												 GrindMeaDis = Math.GetLength(GrindMarkPoint[24], A1CirInPoint[k]);
												 if(GrindMeaDis<MinDis){
													 MinDis = GrindMeaDis;
													 GrindMarkInCnt = k;
												 }
											 }

											 // GrindMark기준 InData 최단거리 Count정보 Calc 
											 if(GrindMarkOutCnt!=0){
												 GrindMeaDis =0.0f, MinDis =10000.0f; GrindMarkInCnt=0;
												 for(int k=0; k<A1CirInEdgeCount; k++){
													 if(A1CirInPoint[k].x   ==0.0f             || A1CirInPoint[k].y                ==0.0f) continue;
													 if(A1CirOutPoint[GrindMarkOutCnt].x==0.0f || A1CirOutPoint[GrindMarkOutCnt].y ==0.0f) continue;

													 GrindMeaDis = Math.GetLength(A1CirOutPoint[GrindMarkOutCnt], A1CirInPoint[k]);
													 if(GrindMeaDis<MinDis){
														 MinDis = GrindMeaDis;
														 GrindMarkInCnt = k;
													 }
												 }
											 }

											 // GrindMark기준 수직 포인트 주변값 Avg산출한다 ==>가공량 측정(OutData기준)
											 if(GrindMarkOutCnt!=0 && GrindMarkOutCnt>5){
												 CircleCount=0,TotalCirDis=0.0f,GrindMeaDis=0.0f;
												 for(int k=GrindMarkOutCnt-5; k<GrindMarkOutCnt+5; k++){
													 if(A1CirOutPoint[k].x==0.0f || A1CirOutPoint[k].y==0.0f) continue;

													 GrindMeaDis = Math.GetLength(GrindMarkPoint[24], A1CirOutPoint[k]);
													 TotalCirDis+= GrindMeaDis;
													 CircleCount++;
												 }
												 if(TotalCirDis!=0.0f && CircleCount!=0){
													 A1CirGrindMea[1] = TotalCirDis/CircleCount;
													 A1CirGrindMea[1] = A1CirGrindMea[1]+0.5; //SubPixel 
												 }
											 }

											 // GrindMark기준 수직 포인트 주변값 Avg산출한다 ==>연마량 측정(OutData,InData기준)
											 if((GrindMarkOutCnt!=0 && GrindMarkOutCnt>5) && (GrindMarkInCnt!=0 && GrindMarkInCnt>5)){
												 CircleCount=0,TotalCirDis=0.0f,GrindWidthDis=0.0f;
												 for(int k=-5; k<5; k++){
													 if(A1CirOutPoint[GrindMarkOutCnt+k].x==0.0f && A1CirOutPoint[GrindMarkOutCnt+k].y==0.0f) continue;
													 if(A1CirInPoint [GrindMarkInCnt +k].x==0.0f && A1CirInPoint [GrindMarkInCnt +k].y==0.0f) continue;
													 GrindWidthDis = Math.GetLength(A1CirInPoint[GrindMarkInCnt+k], A1CirOutPoint[GrindMarkOutCnt+k]);
													 TotalCirDis+=   GrindWidthDis;
													 CircleCount++;
												 }
												 if(TotalCirDis!=0.0f && CircleCount!=0){
													 A1CirGrindWd[1] = TotalCirDis/CircleCount;
													 A1CirGrindWd[1] = A1CirGrindWd[1]+0.5; //SubPixel
												 }
											 }
										 }
										 else if(GrindMarkRect[24].left!=0 && GrindMarkRect[24].top!=0 && GrindMarkRect[24].right!=0 && GrindMarkRect[24].bottom!=0){  //GrindMark 못 찾았을경우
											 // OutData기준 최소값 데이터 Count산출 
											 GrindMeaDis =0.0f, MinDis =10000.0f; GrindMarkOutCnt=0;
											 for(int k=0; k<A1CirOutEdgeCount; k++){
												 if(A1CirOutPoint[k].x==0.0f || A1CirOutPoint[k].y==0.0f) continue;

												 AGrindMarkRectPoint1.x = GrindMarkRect[24].left + (GrindMarkRect[24].right  - GrindMarkRect[24].left)/2; 
												 AGrindMarkRectPoint1.y = GrindMarkRect[24].top  + (GrindMarkRect[24].bottom - GrindMarkRect[24].top )/2; 

												 GrindMeaDis = Math.GetLength(AGrindMarkRectPoint1, A1CirOutPoint[k]);
												 if(GrindMeaDis<MinDis){
													 MinDis = GrindMeaDis;
													 GrindMarkOutCnt = k;
												 }
											 }

											 // 최단거리OUtCount기준 InData 최단거리 Count정보 Calc 
											 if(GrindMarkOutCnt!=0){
												 GrindMeaDis =0.0f, MinDis =10000.0f; GrindMarkInCnt=0;
												 for(int k=0; k<A1CirInEdgeCount; k++){
													 if(A1CirInPoint[k].x   ==0.0f             || A1CirInPoint[k].y                ==0.0f) continue;
													 if(A1CirOutPoint[GrindMarkOutCnt].x==0.0f || A1CirOutPoint[GrindMarkOutCnt].y ==0.0f) continue;

													 GrindMeaDis = Math.GetLength(A1CirOutPoint[GrindMarkOutCnt], A1CirInPoint[k]);
													 if(GrindMeaDis<MinDis){
														 MinDis = GrindMeaDis;
														 GrindMarkInCnt = k;
													 }
												 }
											 }

											 // GrindMark기준 수직 포인트 주변값 Avg산출한다 ==>연마량 측정(OutData,InData기준)
											 if((GrindMarkOutCnt!=0 && GrindMarkOutCnt>5) && (GrindMarkInCnt!=0 && GrindMarkInCnt>5)){
												 CircleCount=0,TotalCirDis=0.0f,GrindWidthDis=0.0f;
												 for(int k=-5; k<5; k++){
													 if(A1CirOutPoint[GrindMarkOutCnt+k].x==0.0f && A1CirOutPoint[GrindMarkOutCnt+k].y==0.0f) continue;
													 if(A1CirInPoint [GrindMarkInCnt +k].x==0.0f && A1CirInPoint [GrindMarkInCnt +k].y==0.0f) continue;
													 GrindWidthDis = Math.GetLength(A1CirInPoint[GrindMarkInCnt+k], A1CirOutPoint[GrindMarkOutCnt+k]);
													 TotalCirDis+=   GrindWidthDis;
													 CircleCount++;
												 }
												 if(TotalCirDis!=0.0f && CircleCount!=0){
													 A1CirGrindWd[1] = TotalCirDis/CircleCount;
													 A1CirGrindWd[1] = A1CirGrindWd[1]+0.5; //SubPixel
												 }
											 }
										 }
										 /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
									 }
								 }
								 else         { //Polygon EnCap 계산시 OutPoint 중간값 기준 실측 거리 평균값을 계산한다(LeftTop) 
									 if(A1CirInEdgeCount!=0 && A1CirOutEdgeCount!=0){
										 GrindMeaDis =0.0f, MinDis =10000.0f; GrindMarkOutCnt=0;
										 GrindMarkOutCnt = (int)(A1CirOutEdgeCount/2);
										 // 최단거리OUtCount기준 InData 최단거리 Count정보 Calc 
										 if(GrindMarkOutCnt!=0){
											 GrindMeaDis =0.0f, MinDis =10000.0f; GrindMarkInCnt=0;
											 for(int k=0; k<A1CirInEdgeCount; k++){
												 if(A1CirInPoint[k].x   ==0.0f             || A1CirInPoint[k].y                ==0.0f) continue;
												 if(A1CirOutPoint[GrindMarkOutCnt].x==0.0f || A1CirOutPoint[GrindMarkOutCnt].y ==0.0f) continue;

												 GrindMeaDis = Math.GetLength(A1CirOutPoint[GrindMarkOutCnt], A1CirInPoint[k]);
												 if(GrindMeaDis<MinDis){
													 MinDis = GrindMeaDis;
													 GrindMarkInCnt = k;
												 }
											 }
										 }

										 // GrindMark기준 수직 포인트 주변값 Avg산출한다 ==>연마량 측정(OutData,InData기준)
										 if((GrindMarkOutCnt!=0 && GrindMarkOutCnt>5) && (GrindMarkInCnt!=0 && GrindMarkInCnt>5)){
											 CircleCount=0,TotalCirDis=0.0f,GrindWidthDis=0.0f;
											 for(int k=-5; k<5; k++){
												 if(A1CirOutPoint[GrindMarkOutCnt+k].x==0.0f && A1CirOutPoint[GrindMarkOutCnt+k].y==0.0f) continue;
												 if(A1CirInPoint [GrindMarkInCnt +k].x==0.0f && A1CirInPoint [GrindMarkInCnt +k].y==0.0f) continue;
												 GrindWidthDis = Math.GetLength(A1CirInPoint[GrindMarkInCnt+k], A1CirOutPoint[GrindMarkOutCnt+k]);
												 TotalCirDis+=   GrindWidthDis;
												 CircleCount++;
											 }
											 if(TotalCirDis!=0.0f && CircleCount!=0){
												 A1CirGrindWd[2] = TotalCirDis/CircleCount;
												 A1CirGrindWd[2] = A1CirGrindWd[2]+0.5; //SubPixel
											 }
										 }
									 }
								 }

								 // FAVION Circle Fitting 결과물(LeftTop)
								 SampleSize = A1CirInEdgeCount*0.75; //0.5~0.8이하로 입력할것
								 DistDevRatio = 0.15; //0.1~0.25 이하로 입력할것
								 CircleFit->OnRansac(A1CirInPoint,A1CirInEdgeCount,SampleSize,DistDevRatio,&ACircleFit1Center,&ACirFitDiameter1);

								 // Polygon 박리 검사 시퀀스(LeftTop) 
								 if(!IsMarkBtm && BrokenThresHold!=0){
									 RotateBrokenImg.SetSize(RotateImg.GetWidth(), RotateImg.GetHeight());
									 EasyImage::Oper(EArithmeticLogicOperation_Copy,&RotateImg,&RotateBrokenImg);
									 EasyImage::Threshold(&RotateImg,&RotateBrokenImg, BrokenThresHold);
									 Edge->GImage = &RotateBrokenImg;
									 Edge->SetEdgeType(0);
									 // 										 RotateBrokenImg.Save("D:\\ROTATE_IMG\\Polygon_LeftTop_박리.bmp");

									 int DvCnt =0, DataCount=0;
									 double deg =0.0f; 
									 TFPoint Target(0.0f, 0.0f);

									 if(GrindMarkInCnt>GrindMarkOutCnt){
										 DvCnt = GrindMarkInCnt - GrindMarkOutCnt;
										 for(int k=0; k<A1CirOutEdgeCount; k++){
											 deg =0.0f, Target.x =0.0f, Target.y =0.0f;
											 if(((k+DvCnt)<A1CirInEdgeCount) && A1CirInPoint[k+DvCnt].x>0  && A1CirInPoint[k+DvCnt].y>0){
												 deg = Math.GetDegree(A1CirOutPoint[k],A1CirInPoint[k+DvCnt]);

												 Target  = Math.OnFindPerpendicularPointXY(A1CirOutPoint[k],dEdgeToTrapLineDis,dEdgeToTrapLineDis,deg);
												 Edge->OnExecute(A1CirOutPoint[k],Target); // 연마외곽라인에서 Target까지 White Point Search 
												 if(Edge->GetResultEdgePointCount()>0){
													 A1CircleData[DataCount].Dis =0.0f;
													 A1CircleData[DataCount].Dv  =0.0f;
													 A1CircleData[DataCount].P   = Edge->GetResultEdgePoint(0);
													 A1CircleData[DataCount].P.y = A1CircleData[DataCount].P.y - ImageHeight; // Frame기준 단위좌표로 변경함  
													 DataCount++;
												 }
											 }
										 }
										 A1CirInCrackCount = DataCount;
									 }
									 else if(GrindMarkInCnt<GrindMarkOutCnt)   {
										 DvCnt = GrindMarkOutCnt - GrindMarkInCnt;
										 for(int k=DvCnt; k<A1CirOutEdgeCount; k++){
											 deg =0.0f, Target.x =0.0f, Target.y =0.0f;
											 if(((k-DvCnt)<A1CirInEdgeCount) && A1CirInPoint[k-DvCnt].x>0  && A1CirInPoint[k-DvCnt].y>0 && k-DvCnt>=0){
												 deg = Math.GetDegree(A1CirOutPoint[k],A1CirInPoint[k-DvCnt]);

												 Target  = Math.OnFindPerpendicularPointXY(A1CirOutPoint[k],dEdgeToTrapLineDis,dEdgeToTrapLineDis,deg);
												 Edge->OnExecute(A1CirOutPoint[k],Target); // 연마외곽라인에서 Target까지 White Point Search 
												 if(Edge->GetResultEdgePointCount()>0){
													 A1CircleData[DataCount].Dis =0.0f;
													 A1CircleData[DataCount].Dv  =0.0f;
													 A1CircleData[DataCount].P   = Edge->GetResultEdgePoint(0);
													 A1CircleData[DataCount].P.y = A1CircleData[DataCount].P.y - ImageHeight; // Frame기준 단위좌표로 변경함  
													 DataCount++;
												 }
											 }
										 }
										 A1CirInCrackCount = DataCount;
									 }
								 }
								 // 									 LogUnit.SetLog("CellID:%d, CamID:%d ==>LeftTop_Polygon_END",CellId,CamId);     
							 }
							 else if(FInspectMode==Insp_Mark){
								 // 									 RotateBinaryImg.Save("D:\\ROTATE_IMG\\RotateBinaryImg_HAP.bmp");
								 // 									 LogUnit.SetLog("LeftTop_Mark_START");     

								 // 자재의 외곽라인 교차점 기준 CirCenter 설정함 
								 if(ASideCircleWidth!=0.0f && ASideCircleHeight!=0.0f) A1CirCenter.x = FLTPoint.x + ASideCircleWidth;  A1CirCenter.y = FLTPoint.y + ASideCircleHeight;  
								 // Circle Fitting 진행시 공통으로 사용하는 설정값
								 Circle->SetSamplingStep(1)                              ; // A1Circle Edge 간격 
								 //A1 In Circle EdgePoint Data 추출 
								 if(A1CirCenter.x!=0 && A1CirCenter.y!=0){
									 // 										 RotateBinaryImg.Save("D:\\ROTATE_IMG\\LeftTop_원본.bmp");

									 // A_Side Circle 검사전 Median 필터 적용 
									 TPoint P1(0,0),P2(0,0),P3(0,0),P4(0,0);
									 P1.x = (int)(FLTPoint.x-20);    P1.y =(int)(FLTPoint.y-20            ); P2.x = (int)(P1.x+ASideCircleWidth+40);    P2.y = (int)(P1.y);
									 P3.x = (int)(FLTPoint.x-20);    P3.y =(int)(P1.y+ASideCircleHeight+40); P4.x = (int)(P2.x                    );    P4.y = (int)(P3.y);

									 // Median Filter 적용 
									 if(P1.x<=0    || P1.y<=0    || (P2.x - P1.x)<=0    || (P3.y - P1.y)<=0   ) return false;
									 if(P1.x>=ImgW || P1.y>=ImgH || (P2.x - P1.x)>=ImgW || (P3.y - P1.y)>=ImgH) return false;
									 FilterROI.SetSize(int(P2.x - P1.x),int(P3.y - P1.y) )                 ;
									 FilterROI.Attach(&RotateBinaryImg)                                    ;
									 FilterROI.SetPlacement(P1.x, P1.y, int(P2.x - P1.x), int(P3.y - P1.y));
									 LogUnit.SetLog(L"Px : %d, Py : %d, Width : %d, Height : %d => MedianFilter", P1.x, P1.y, int(P2.x - P1.x), int(P3.y - P1.y));
									 LogUnit.SetLog(L"P1.x : %d, P1.y : %d, P2.x : %d, P2.y : %d, P3.x : %d, P3.y : %d, P4.x : %d, P4.y : %d => MedianFilter", P1.x, P1.y, P2.x, P2.y, P3.x, P3.y, P4.x, P4.y);
									 EasyImage::Median(&FilterROI, &FilterROI)                             ;

									 // 										 RotateBinaryImg.Save("D:\\ROTATE_IMG\\LeftTop_필터.bmp");


									 if(ECThresHold==0) Circle->GImage = &RotateImg      ; //Org Image 넘겨줌 
									 else               Circle->GImage = &RotateBinaryImg; //Binary Image 넘겨줌 

									 Circle->SetCenterXY(A1CirCenter.x , A1CirCenter.y)  ; // Circle Center 좌표설정 
									 // 									 A1Diameter = ((ASideCircleWidth*2)+((ASideCircleWidth-OutToTrackLineDis)*2))/2;
									 A1Diameter = (ASideCircleWidth*2);

									 Circle->SetDiameter(A1Diameter)             ;
									 Circle->SetTolerance(60.0f )                ; // A1Circle Tolerance 
									 Circle->SetCircleChoice(1)                  ; // 0:From Begin, 1:From End, 2:Largest Amplitude 
									 Circle->SetCircleIndex (1)                  ; // Circle EdgePoint Index 
									 Circle->SetAngle(180+CirAngleMargin)        ; // Cirlce Angle 
									 Circle->SetAmplitude(90-(2*CirAngleMargin)) ; // Circle Amplitude

									 // Circle InData EdgePoint 
									 //////////////////////////////////////////////////////////////////////////////////////////////////////
									 Circle->SetCircleType(2)                          ; // 0:Black to White, 1:White to Black 2: Both Black, White 
									 Circle->OnExecute()                               ;

									 // Circle In Data 기준 새로운 Circle Center 좌표 받아옴 
									 // Euresys Circle Fitting Center & Diameter  
									 RealA1CirCenter.x = Circle->FCP.x;
									 RealA1CirCenter.y = Circle->FCP.y;
									 ACirDiameter1     = (Circle->Diameter)/2.0;

									 // Circle In Data취합 
									 OrgA1CirInEdgeCount = Circle->FCirclePointCount;
									 if(OrgA1CirInEdgeCount>0){
										 if(OrgA1CirInPoint!=NULL) delete[] OrgA1CirInPoint;
										 OrgA1CirInPoint = new TFPoint[OrgA1CirInEdgeCount];

										 for(int k=0; k<OrgA1CirInEdgeCount; k++){
											 if(k>MAX_CIRCLE_EDGEPOINT) break;
											 OrgA1CirInPoint[k].x = Circle->FCirclePoint[k].x;
											 OrgA1CirInPoint[k].y = Circle->FCirclePoint[k].y;
											 if(OrgA1CirInPoint[k].x==0.0f && OrgA1CirInPoint[k].y==0.0f) A1CirInEdgeCount++;
										 }
									 }
									 //////////////////////////////////////////////////////////////////////////////////////////////////////

									 // Circle Out Data 다시 검사  
									 //////////////////////////////////////////////////////////////////////////////////////////////////////
									 Circle->SetTolerance(60.0f )      ; // Circle Tolerance 
									 Circle->SetDiameter (A1Diameter)  ; // Circle Diameter 
									 Circle->SetCircleChoice(1)        ; // 0:From Begin, 1:From End, 2:Largest Amplitude 
									 Circle->SetCircleType(2)          ; // 0:Black to White, 1:White to Black 2: Both Black, White 
									 Circle->SetCircleIndex (0)        ; // Circle EdgePoint Index 

									 Circle->OnExecute()               ;

									 // Circle Out Data취합 
									 OrgA1CirOutEdgeCount = Circle->FCirclePointCount;
									 if(OrgA1CirOutEdgeCount>0){
										 if(OrgA1CirOutPoint!=NULL) delete[] OrgA1CirOutPoint;
										 OrgA1CirOutPoint = new TFPoint[OrgA1CirOutEdgeCount];

										 for(int k=0; k<OrgA1CirOutEdgeCount; k++){
											 if(k>MAX_CIRCLE_EDGEPOINT) break;
											 OrgA1CirOutPoint[k].x = Circle->FCirclePoint[k].x;
											 OrgA1CirOutPoint[k].y = Circle->FCirclePoint[k].y;
											 // BTM영역 Circle을 제외한 영역 Defect검사 목적에 좌표계산 
											 if(k==0                     ) {TopEdgePoint[0].x = OrgA1CirOutPoint[k].x; TopEdgePoint[0].y = OrgA1CirOutPoint[k].y;}
											 if(k==OrgA1CirOutEdgeCount-1) {TopEdgePoint[1].x = OrgA1CirOutPoint[k].x; TopEdgePoint[1].y = OrgA1CirOutPoint[k].y;}
											 if(OrgA1CirOutPoint[k].x==0.0f && OrgA1CirOutPoint[k].y==0.0f) A1CirOutEdgeCount++;
										 }
									 }

									 // A1Circle Grind_Width Calculate (연마량 계산)
									 if(IsMarkBtm){ // LTPS경우 가공량 계산 ==> 연마량 계산 
										 if(OrgA1CirOutEdgeCount!=0 && OrgA1CirInEdgeCount!=0){ // MarkMode경우 가공량 검사를 먼저 진행 후 연마량 산출  
											 GrindMeaDis =0.0f, MinDis =10000.0f; A1GrindMarkCount=0;
											 if(GrindMarkPoint[25].x!=0.0f && GrindMarkPoint[25].y!=0.0f){  //GrindMark 찾았을경우 
												 for(int k=0; k<OrgA1CirOutEdgeCount; k++){
													 if(OrgA1CirOutPoint[k].x==0.0f || OrgA1CirOutPoint[k].y==0.0f) continue;
													 if(GrindMarkPoint[25].x  ==0.0f || GrindMarkPoint[25].y  ==0.0f) continue;

													 GrindMeaDis = Math.GetLength(GrindMarkPoint[25], OrgA1CirOutPoint[k]);
													 if(GrindMeaDis<MinDis){
														 MinDis = GrindMeaDis;
														 A1GrindMarkCount = k;
													 }
												 }
												 // GrindMark기준 수직 포인트 주변값 Avg산출한다 ==>가공량 측정 
												 if(A1GrindMarkCount!=0 && A1GrindMarkCount>5){
													 CircleCount=0,TotalCirDis=0.0f,GrindMeaDis=0.0f;
													 for(int k=A1GrindMarkCount-5; k<A1GrindMarkCount+5; k++){
														 if(OrgA1CirOutPoint[k].x==0.0f || OrgA1CirOutPoint[k].y==0.0f) continue;

														 GrindMeaDis = Math.GetLength(GrindMarkPoint[25], OrgA1CirOutPoint[k]);
														 TotalCirDis+= GrindMeaDis;
														 CircleCount++;
													 }
													 if(TotalCirDis!=0.0f && CircleCount!=0){
														 A1CirGrindMea[2] = TotalCirDis/CircleCount;
													 }
												 }

												 // GrindMark기준 수직 평균값 연마량 측정 
												 if(A1GrindMarkCount!=0 && A1GrindMarkCount>5){
													 CircleCount=0,TotalCirDis=0.0f,GrindWidthDis=0.0f;
													 for(int k=A1GrindMarkCount-5; k<A1GrindMarkCount+5; k++){
														 if(OrgA1CirOutPoint[k].x==0.0f && OrgA1CirOutPoint[k].y==0.0f) continue;
														 if(OrgA1CirInPoint [k].x==0.0f && OrgA1CirInPoint [k].y==0.0f) continue;
														 GrindWidthDis = Math.GetLength(OrgA1CirInPoint[k], OrgA1CirOutPoint[k]);
														 TotalCirDis+=   GrindWidthDis;
														 CircleCount++;
													 }
													 if(TotalCirDis!=0.0f && CircleCount!=0){
														 A1CirGrindWd[2] = TotalCirDis/CircleCount;
													 }
												 }
											 }
											 else {  //GrindMark 못 찾았을경우
												 for(int k=0; k<OrgA1CirOutEdgeCount; k++){
													 if(OrgA1CirOutPoint[k].x==0.0f || OrgA1CirOutPoint[k].y==0.0f) continue;

													 AGrindMarkRectPoint1.x = GrindMarkRect[25].left + (GrindMarkRect[25].right  - GrindMarkRect[25].left)/2; 
													 AGrindMarkRectPoint1.y = GrindMarkRect[25].top  + (GrindMarkRect[25].bottom - GrindMarkRect[25].top )/2; 

													 GrindMeaDis = Math.GetLength(AGrindMarkRectPoint1, OrgA1CirOutPoint[k]);
													 if(GrindMeaDis<MinDis){
														 MinDis = GrindMeaDis;
														 A1GrindMarkCount = k;
													 }
												 }
												 // GrindMark기준 수직 평균값 연마량 측정 
												 if(A1GrindMarkCount!=0 && A1GrindMarkCount>5 && (A1GrindMarkCount+5<OrgA1CirOutEdgeCount)){
													 CircleCount=0,TotalCirDis=0.0f,GrindWidthDis=0.0f;
													 for(int k=A1GrindMarkCount-5; k<A1GrindMarkCount+5; k++){
														 if(OrgA1CirOutPoint[k].x==0.0f && OrgA1CirOutPoint[k].y==0.0f) continue;
														 if(OrgA1CirInPoint [k].x==0.0f && OrgA1CirInPoint [k].y==0.0f) continue;
														 GrindWidthDis = Math.GetLength(OrgA1CirInPoint[k], OrgA1CirOutPoint[k]);
														 TotalCirDis+=   GrindWidthDis;
														 CircleCount++;
													 }
													 if(TotalCirDis!=0.0f && CircleCount!=0){
														 A1CirGrindWd[2] = TotalCirDis/CircleCount;
													 }
												 }
											 }
										 }
									 }
									 else     { // MarkMode ==> EnCap경우 연마량만 계산한다 
										 if(OrgA1CirInEdgeCount==OrgA1CirOutEdgeCount){
											 double OutDis=0.0f, InDis=0.0f, TotalGrindWidth=0.0f, AvgGrindWidth=0.0f;A1GrindWidthCount=0;
											 for(int k=0; k<OrgA1CirInEdgeCount; k++){
												 if(OrgA1CirOutPoint[k].x==0.0f && OrgA1CirOutPoint[k].y==0.0f){
													 OutDis =0.0f;
												 }
												 else {
													 OutDis = Math.GetLengthFrPointToPoint(A1CirCenter,OrgA1CirOutPoint[k]);
												 }

												 if(OrgA1CirInPoint[k].x==0.0f && OrgA1CirInPoint[k].y==0.0f){
													 InDis =0.0f;
												 }
												 else {
													 InDis = Math.GetLengthFrPointToPoint(A1CirCenter,OrgA1CirInPoint[k]);
												 }

												 // CircleFitting 진행시 실제 EdgePoint 데이터가 존재 할 경우만 포함하여 계산한다
												 if(OutDis!=0.0f && InDis!=0.0f){
													 TotalGrindWidth+=(OutDis - InDis);
													 A1GrindWidthCount++;
												 }
											 }
											 if(A1GrindWidthCount!=0){
												 AvgGrindWidth = (TotalGrindWidth/A1GrindWidthCount);
												 A1CirGrindWd[2] = AvgGrindWidth;
											 }
										 }
									 }

									 //////////////////////////////////////////////////////////////////////////////////////////////////////
									 // Org Circle데이터중 유호하지 않은 값을 제외한 실제 존재하는 데이터 기준으로 동적 메모리 생성함
									 // Circle Defect검사에 필요한 Edge데이터 값
									 int Count=0;
									 if(OrgA1CirInEdgeCount>0){ // A1 CircleInData
										 A1CirInEdgeCount = OrgA1CirInEdgeCount - A1CirInEdgeCount;
										 if(A1CirInEdgeCount>0){
											 if(A1CirInPoint!=NULL) delete[] A1CirInPoint;
											 A1CirInPoint = new TFPoint[A1CirInEdgeCount];

											 for(int k=0; k<OrgA1CirInEdgeCount; k++){
												 if(k>MAX_CIRCLE_EDGEPOINT) break;
												 if(OrgA1CirInPoint[k].x==0.0f && OrgA1CirInPoint[k].y==0.0f) continue;
												 A1CirInPoint[Count].x = OrgA1CirInPoint[k].x;
												 A1CirInPoint[Count].y = OrgA1CirInPoint[k].y;
												 Count++;
											 }
										 }
										 // Circle 원본 데이터 메모리 삭제
										 if(OrgA1CirInPoint!=NULL) delete[] OrgA1CirInPoint;
									 }
									 // FAVION Circle Fitting 결과물 
									 SampleSize = A1CirInEdgeCount*0.75; //0.5~0.8이하로 입력할것
									 DistDevRatio = 0.15; //0.1~0.25 이하로 입력할것
									 CircleFit->OnRansac(A1CirInPoint,A1CirInEdgeCount,SampleSize,DistDevRatio,&ACircleFit1Center,&ACirFitDiameter1);

									 if(OrgA1CirOutEdgeCount>0){// A1 CircleOutData 
										 A1CirOutEdgeCount = OrgA1CirOutEdgeCount - A1CirOutEdgeCount;
										 Count =0;
										 if(A1CirOutEdgeCount>0){
											 if(A1CirOutPoint!=NULL) delete[] A1CirOutPoint;
											 A1CirOutPoint = new TFPoint[A1CirOutEdgeCount];

											 for(int k=0; k<OrgA1CirOutEdgeCount; k++){
												 if(k>MAX_CIRCLE_EDGEPOINT) break;
												 if(OrgA1CirOutPoint[k].x==0.0f && OrgA1CirOutPoint[k].y==0.0f) continue;
												 A1CirOutPoint[Count].x = OrgA1CirOutPoint[k].x;
												 A1CirOutPoint[Count].y = OrgA1CirOutPoint[k].y;
												 Count++;
											 }
										 }
										 // Circle 원본 데이터 메모리 삭제
										 if(OrgA1CirOutPoint!=NULL) delete[] OrgA1CirOutPoint;
									 }
									 // Circle 영역 꽃박리, 원형박리 검출 목적 시퀀스(EnCap)
									 // 정식 명칭은 몰라서.....일단 Crack으로 정함 
									 // NOTCH LeftTop 박리 검사 
									 if(!IsMarkBtm && BrokenThresHold!=0){
										 RotateBrokenImg.SetSize(RotateImg.GetWidth(), RotateImg.GetHeight());
										 EasyImage::Oper(EArithmeticLogicOperation_Copy,&RotateImg,&RotateBrokenImg);
										 EasyImage::Threshold(&RotateImg,&RotateBrokenImg, BrokenThresHold);
										 // 										 RotateBrokenImg.Save("D:\\ROTATE_IMG\\RotateBrokenImg_HAP.bmp");

										 if(ACirFitDiameter1!=0.0f && ACircleFit1Center.x!=0.0f && ACircleFit1Center.y!=0.0f){ // FAVION Circle Fitting 성공시 박리검사 진행 
											 Circle->GImage = &RotateBrokenImg;                                             //Binary Image 넘겨줌 

											 Circle->SetCenterXY(ACircleFit1Center.x,ACircleFit1Center.y);
											 // 											 Circle->SetTolerance(CirCrackMargin)                      ; // Circle Tolerance 
											 // 											 Circle->SetDiameter ((ACirFitDiameter1-CirCrackMargin)*2)  ; // Circle Diameter 
											 Circle->SetTolerance((dEdgeToTrapLineDis/2)-CirOffsetMargin)      ; // Circle Tolerance 
											 Circle->SetDiameter ((ACirFitDiameter1-(dEdgeToTrapLineDis/2))*2) ; // Circle Diameter 
											 Circle->SetCircleChoice(0)                                ; // 0:From Begin, 1:From End, 2:Largest Amplitude 
											 Circle->SetCircleType  (0)                                ; // 0:Black to White, 1:White to Black 2: Both Black, White 
											 Circle->SetCircleIndex (0)                                ; // Circle EdgePoint Index 
											 Circle->SetAmplitude(25)                                  ; // 패턴으로 인해서 오버킬 발생...범위를 좁혀준다 
											 Circle->OnExecute(true)                                   ;
											 CrackACirDiameter1 = (ACirFitDiameter1-(dEdgeToTrapLineDis/2))+((dEdgeToTrapLineDis/2)-CirOffsetMargin);

											 A1CirInCrackCount = Circle->FCirclePointCount;

											 if(A1CirInCrackCount>0){
												 if(A1CirInCrackPoint!=NULL) delete[] A1CirInCrackPoint;
												 A1CirInCrackPoint = new TFPoint[A1CirInCrackCount];

												 for(int k=0; k<A1CirInCrackCount; k++){
													 if(k>MAX_CIRCLE_EDGEPOINT) break;
													 A1CirInCrackPoint[k].x = Circle->FCirclePoint[k].x;
													 A1CirInCrackPoint[k].y = Circle->FCirclePoint[k].y;
												 }
											 }
										 }
									 }
								 }
								 // 									 LogUnit.SetLog("LeftTop_Mark_END");     
							 }
						 }
					 }

					 if(FRightTop){
						 // 							 LogUnit.SetLog("shRectH_Rotate_RightTop_Start");     
						 EasyImage::Threshold(&RotateImg,&RotateBinaryImg, ECThresHold);
						 EasyImage::Threshold(&RotateImg,&RotateGrindBinaryImg, CorGrindMeaThresHold);
						 //							 RotateBinaryImg.Save("D:\\ROTATE_IMG\\RotateBinaryImg회전_HAP.bmp");

						 if(ECThresHold==0)  {SingleLine->GImage = &RotateImg      ;  SingleLine->FThreshold =5 ;}
						 else                {SingleLine->GImage = &RotateBinaryImg;  SingleLine->FThreshold =10;}

						 OrgPoint = Math.OnIntersect(Line[waRightWall].FP0, Line[waRightWall].FP1, Line[waTopWall].FP0, Line[waTopWall].FP1);
						 FRTPoint = OrgPoint;

						 if(IsCornerTop){
							 if(AMarkToGrindMarkDvX==0.0f && AMarkToGrindMarkDvY==0.0f){ // 3Point 기준으로 가공량 측정 방법 적용 시퀀스 
								 SingleLine->IRoi->SetOrgX  ((int)(OrgPoint.x-RTCornerWidth));
								 SingleLine->IRoi->SetOrgY  ((int) OrgPoint.y               );
								 SingleLine->IRoi->SetWidth (RTCornerWidth +10              );
								 SingleLine->IRoi->SetHeight(RTCornerHeight                 );

								 SingleLine->SetOrientation(orEast);
								 SingleLine->FIncrement =1;
								 SingleLine->FThreshold =15;
								 SingleLine->SetFindLineId(0);
								 SingleLine->SetEdgeType(1);  //White To Black 
								 SingleLine->OnExecute();
								 Line[waRightTop].FP0 = SingleLine->GetResultP0();
								 Line[waRightTop].FP1 = SingleLine->GetResultP1();

								 // ORG 
								 FRTRPoint = Math.OnIntersect(SingleLine->GetResultP0(), SingleLine->GetResultP1(), Line[waRightWall].FP0, Line[waRightWall].FP1);
								 FRTTPoint = Math.OnIntersect(SingleLine->GetResultP0(), SingleLine->GetResultP1(), Line[waTopWall  ].FP0, Line[waTopWall].FP1  );

								 if((FRTRPoint.x==0 || FRTRPoint.y==0 || FRTTPoint.x==0 || FRTTPoint.y==0) || (SingleLine->FEdgePointCount <30)){
									 RTDx = 0.0f;
									 RTDy = 0.0f;
									 //화면에 디스플레이 위해서 
									 FRTRPoint.x = FRTPoint.x;
									 FRTRPoint.y = FRTPoint.y;
									 FRTTPoint.x = FRTPoint.x;
									 FRTTPoint.y = FRTPoint.y;
								 }
								 else {
									 RTDx = Math.GetLengthFrPointToPoint(FRTPoint, FRTTPoint);
									 RTDy = Math.GetLengthFrPointToPoint(FRTPoint, FRTRPoint);

									 // OutLine C2Corner Data 
									 if((SingleLine->FEdgePointCount) - (CornerMargin*2)>0){
										 if(C2Point!=NULL) delete[] C2Point;
										 C2Point  = new TFPoint [(SingleLine->FEdgePointCount) - (CornerMargin*2)];
										 C2EdgeCount = (SingleLine->FEdgePointCount) -(CornerMargin*2);

										 CornerCount =0;  
										 for(int k=CornerMargin; k<((SingleLine->FEdgePointCount)-CornerMargin); k++){
											 if(CornerCount>=MAX_CORNER_POINT) break;
											 C2Point[CornerCount].x = SingleLine->FEdgePoint[k].x;
											 C2Point[CornerCount].y = SingleLine->FEdgePoint[k].y;
											 CornerCount++;
										 }
									 }

									 // Value Init 
									 double Dis =0.0f, AvgGrindWidth=0.0f, AvgGrindMea=0.0f, TotalGrindWidth=0.0f, TotalGrindMeasure=0.0f;

									 // Corner Grind In Start 
									 if(CorGrindInThresHold!=0){
										 EasyImage::Threshold(&RotateImg,&RotateBinaryImg, CorGrindInThresHold);
										 SingleLine->GImage = &RotateBinaryImg;  SingleLine->FThreshold =10;

										 // Corner 기울기 완만하여 Edge찾을 경우 Defect 오버킬 발생함 
										 // 방향을 Top방향에서 다시 엣지를 찾음 (Corner Defect OverKill 감소 목적)
										 // if(RTCornerWidth >(RTCornerHeight*3)){
										 if(RTCornerWidth >(RTCornerHeight*1.5)){
											 if(FRTTPoint.x!=0.0f && FRTTPoint.y!=0.0f && FRTRPoint.x!=0.0f && FRTRPoint.y!=0.0f){

												 SingleLine->IRoi->SetOrgX  ((int)(FRTPoint.x-(FRTRPoint.x-FRTTPoint.x)+5));
												 SingleLine->IRoi->SetOrgY  ((int) FRTPoint.y                             );
												 SingleLine->IRoi->SetWidth ((int)((FRTRPoint.x-FRTTPoint.x)+5)           );
												 SingleLine->IRoi->SetHeight((int)((FRTRPoint.y - FRTTPoint.y)+10)        );

												 if(FRTTPoint.x<=0    || FRTTPoint.y<=0    || (FRTRPoint.x - FRTTPoint.x)<=0    || (FRTRPoint.y - FRTTPoint.y)<=0   ) return false;
												 if(FRTTPoint.x>=ImgW || FRTTPoint.y>=ImgH || (FRTRPoint.x - FRTTPoint.x)>=ImgW || (FRTRPoint.y - FRTTPoint.y)>=ImgH) return false;

												 //SingleLine->SetOrientation(orNorth);
												 SingleLine->SetOrientation(orSouth);
												 SingleLine->FIncrement =2;
												 SingleLine->SetFindLineId(0);
												 //SingleLine->SetEdgeType(0);  //Black To White 
												 SingleLine->SetEdgeType(1);  //Black To White 
												 SingleLine->OnExecute();

												 // InLine C2Corner Data 
												 if((SingleLine->FEdgePointCount) - (CornerMargin*2)>0){
													 if(C2InPoint!=NULL) delete[] C2InPoint;
													 C2InPoint  = new TFPoint [(SingleLine->FEdgePointCount) - (CornerMargin*2)];
													 C2InEdgeCount = (SingleLine->FEdgePointCount) -(CornerMargin*2);

													 CornerCount =0;  
													 for(int k=CornerMargin; k<((SingleLine->FEdgePointCount)-CornerMargin); k++){
														 if(CornerCount>=MAX_CORNER_POINT) break;
														 C2InPoint[CornerCount].x = SingleLine->FEdgePoint[k].x;
														 C2InPoint[CornerCount].y = SingleLine->FEdgePoint[k].y;
														 CornerCount++;
													 }
												 }
											 }
										 }
										 else {
											 // Corner 연마 안쪽라인 찾는다 
											 SingleLine->SetOrientation(orEast);
											 SingleLine->SetFindLineId(0);
											 SingleLine->FIncrement =1;
											 SingleLine->SetEdgeType(0);  //Black To White 
											 SingleLine->OnExecute();

											 // InLine C2Corner Data 
											 if((SingleLine->FEdgePointCount) - (CornerMargin*2)>0){
												 if(C2InPoint!=NULL) delete[] C2InPoint;
												 C2InPoint  = new TFPoint [(SingleLine->FEdgePointCount) - (CornerMargin*2)];
												 C2InEdgeCount = (SingleLine->FEdgePointCount) -(CornerMargin*2);

												 CornerCount =0;  
												 for(int k=CornerMargin; k<((SingleLine->FEdgePointCount)-CornerMargin); k++){
													 if(CornerCount>=MAX_CORNER_POINT) break;
													 C2InPoint[CornerCount].x = SingleLine->FEdgePoint[k].x;
													 C2InPoint[CornerCount].y = SingleLine->FEdgePoint[k].y;
													 CornerCount++;
												 }
											 }
										 }

										 //코너 연마안쪽라인 기준 새로운 교차점 생성 
										 FRTRInPoint = Math.OnIntersect(SingleLine->GetResultP0(), SingleLine->GetResultP1(), Line[waRightWall].FP0, Line[waRightWall].FP1);
										 FRTTInPoint = Math.OnIntersect(SingleLine->GetResultP0(), SingleLine->GetResultP1(), Line[waTopWall  ].FP0, Line[waTopWall].FP1  );

										 //코너 연마폭, 연마량 계산 
										 Dis =0.0f, AvgGrindWidth=0.0f, AvgGrindMea=0.0f, TotalGrindWidth=0.0f, TotalGrindMeasure=0.0f;
										 for(int k=0; k<C2InEdgeCount; k++){
											 Dis = Math.GetLengthFrLineToPoint(FRTRPoint, FRTTPoint, C2InPoint[k]);
											 TotalGrindWidth+=Dis;
										 }
										 if(C2InEdgeCount!=0){
											 AvgGrindWidth = (TotalGrindWidth/C2InEdgeCount);
											 C2CorGrindWd  = AvgGrindWidth;
										 }
									 }

									 if(CorGrindMeaThresHold!=0){ // Corner Grind ThresHold값이 설정되어 있을경우만 연마량 검사를 진행한다 
										 // 코너 연마량 기준 라인을 찾는다 
										 // ROI 영역 설정 
										 if(CorGrindMeaThresHold==0){SingleLine->GImage = &RotateImg           ;  SingleLine->FThreshold =5 ;}
										 else                       {SingleLine->GImage = &RotateGrindBinaryImg;  SingleLine->FThreshold =10;}

										 // 존나 찝찝함....일단 스팩을 받기전까지 임시로 영역을 분류하여 CornerEdgePoint 찾자 
										 if(RTCornerWidth >(RTCornerHeight*1.5)){
											 SingleLine->IRoi->SetOrgX  ((int) OrgPoint.x-(RTCornerWidth-50));
											 SingleLine->IRoi->SetOrgY  ((int) OrgPoint.y+30                );
											 SingleLine->IRoi->SetWidth (RTCornerWidth -50                  );
											 SingleLine->IRoi->SetHeight(RTCornerHeight-40                  );

											 SingleLine->SetOrientation(orNorth);
											 SingleLine->SetFindLineId(0);
											 SingleLine->FIncrement =1;
											 SingleLine->SetEdgeType(0);  //Black To White 
											 SingleLine->OnExecute();

											 P1 = SingleLine->GetResultP0();
											 P2 = SingleLine->GetResultP1();

											 //코너 연마안쪽라인 기준 새로운 교차점 생성 
											 FRTRMeaPoint = Math.OnIntersect(SingleLine->GetResultP0(), SingleLine->GetResultP1(), Line[waRightWall].FP0, Line[waRightWall].FP1);
											 FRTTMeaPoint = Math.OnIntersect(SingleLine->GetResultP0(), SingleLine->GetResultP1(), Line[waTopWall  ].FP0, Line[waTopWall].FP1  );

											 // C1Corner Grind Measure Stand Data 
											 if((SingleLine->FEdgePointCount)>0){
												 if(C2MeaPoint!=NULL) delete[] C2MeaPoint;
												 C2MeaPoint     = new TFPoint [(SingleLine->FEdgePointCount)];
												 C2MeaEdgeCount = (SingleLine->FEdgePointCount);

												 CornerCount =0;  
												 for(int k=0; k<(SingleLine->FEdgePointCount); k++){
													 if(CornerCount>=MAX_CORNER_POINT) break;
													 C2MeaPoint[CornerCount].x = SingleLine->FEdgePoint[k].x;
													 C2MeaPoint[CornerCount].y = SingleLine->FEdgePoint[k].y;
													 CornerCount++;
												 }
											 }
											 //코너 연마량 계산  
											 Dis =0.0f, AvgGrindMea=0.0f, TotalGrindMeasure=0.0f;
											 for(int k=0; k<C2EdgeCount; k++){
												 Dis = Math.GetLengthFrLineToPoint(FRTRMeaPoint, FRTTMeaPoint, C2Point[k]);
												 TotalGrindMeasure+=Dis;
											 }
											 if(C2EdgeCount!=0){
												 AvgGrindMea    = (TotalGrindMeasure/C2EdgeCount);
												 C2CorGrindMea  = AvgGrindMea;
											 }
										 }
										 else {
											 // 											 SingleLine->IRoi->SetOrgX  ((int) OrgPoint.x-RTCornerWidth    );
											 SingleLine->IRoi->SetOrgX  ((int) OrgPoint.x-RTCornerWidth+20 );
											 SingleLine->IRoi->SetOrgY  ((int) OrgPoint.y+15               );
											 SingleLine->IRoi->SetWidth (RTCornerWidth                     );
											 // 											 SingleLine->IRoi->SetHeight(RTCornerHeight                    );
											 SingleLine->IRoi->SetHeight(RTCornerHeight+10                 );

											 SingleLine->SetOrientation(orEast);
											 SingleLine->SetFindLineId(0);
											 SingleLine->FIncrement =1;
											 SingleLine->SetEdgeType(0);  //Black To White 
											 SingleLine->OnExecute();

											 P1 = SingleLine->GetResultP0();
											 P2 = SingleLine->GetResultP1();

											 //코너 연마안쪽라인 기준 새로운 교차점 생성 
											 FRTRMeaPoint = Math.OnIntersect(SingleLine->GetResultP0(), SingleLine->GetResultP1(), Line[waRightWall].FP0, Line[waRightWall].FP1);
											 FRTTMeaPoint = Math.OnIntersect(SingleLine->GetResultP0(), SingleLine->GetResultP1(), Line[waTopWall  ].FP0, Line[waTopWall].FP1  );

											 // C1Corner Grind Measure Stand Data 
											 if((SingleLine->FEdgePointCount)>0){
												 if(C2MeaPoint!=NULL) delete[] C2MeaPoint;
												 C2MeaPoint     = new TFPoint [(SingleLine->FEdgePointCount)];
												 C2MeaEdgeCount = (SingleLine->FEdgePointCount);

												 CornerCount =0;  
												 for(int k=0; k<(SingleLine->FEdgePointCount); k++){
													 if(CornerCount>=MAX_CORNER_POINT) break;
													 C2MeaPoint[CornerCount].x = SingleLine->FEdgePoint[k].x;
													 C2MeaPoint[CornerCount].y = SingleLine->FEdgePoint[k].y;
													 CornerCount++;
												 }
											 }
											 //코너 연마량 계산  
											 Dis =0.0f, AvgGrindMea=0.0f, TotalGrindMeasure=0.0f;
											 for(int k=0; k<C2EdgeCount; k++){
												 Dis = Math.GetLengthFrLineToPoint(FRTRMeaPoint, FRTTMeaPoint, C2Point[k]);
												 TotalGrindMeasure+=Dis;
											 }
											 if(C2EdgeCount!=0){
												 AvgGrindMea    = (TotalGrindMeasure/C2EdgeCount);
												 C2CorGrindMea  = AvgGrindMea;
											 }
										 }
									 }
								 }
							 }
							 else { //십자가 마크 기준 연마량,가공량 측정 시퀀스 
								 TFPoint C2GrindRectPoint(0.0f, 0.0f);

								 SingleLine->IRoi->SetOrgX  ((int)(OrgPoint.x-RTCornerWidth));
								 SingleLine->IRoi->SetOrgY  ((int) OrgPoint.y               );
								 SingleLine->IRoi->SetWidth (RTCornerWidth +10              );
								 SingleLine->IRoi->SetHeight(RTCornerHeight                 );

								 SingleLine->SetOrientation(orEast);
								 SingleLine->FIncrement =1;
								 SingleLine->FThreshold =15;
								 SingleLine->SetFindLineId(0);
								 SingleLine->SetEdgeType(1);  //White To Black 
								 SingleLine->OnExecute();
								 Line[waRightTop].FP0 = SingleLine->GetResultP0();
								 Line[waRightTop].FP1 = SingleLine->GetResultP1();

								 // ORG 
								 FRTRPoint = Math.OnIntersect(SingleLine->GetResultP0(), SingleLine->GetResultP1(), Line[waRightWall].FP0, Line[waRightWall].FP1);
								 FRTTPoint = Math.OnIntersect(SingleLine->GetResultP0(), SingleLine->GetResultP1(), Line[waTopWall  ].FP0, Line[waTopWall].FP1  );

								 if((FRTRPoint.x==0 || FRTRPoint.y==0 || FRTTPoint.x==0 || FRTTPoint.y==0) || (SingleLine->FEdgePointCount <30)){
									 RTDx = 0.0f;
									 RTDy = 0.0f;
									 //화면에 디스플레이 위해서 
									 FRTRPoint.x = FRTPoint.x;
									 FRTRPoint.y = FRTPoint.y;
									 FRTTPoint.x = FRTPoint.x;
									 FRTTPoint.y = FRTPoint.y;
								 }
								 else {
									 RTDx = Math.GetLengthFrPointToPoint(FRTPoint, FRTTPoint);
									 RTDy = Math.GetLengthFrPointToPoint(FRTPoint, FRTRPoint);

									 // OutLine C2Corner Data 
									 if((SingleLine->FEdgePointCount) - (CornerMargin*2)>0){
										 if(C2Point!=NULL) delete[] C2Point;
										 C2Point  = new TFPoint [(SingleLine->FEdgePointCount) - (CornerMargin*2)];
										 C2EdgeCount = (SingleLine->FEdgePointCount) -(CornerMargin*2);

										 CornerCount =0;  
										 for(int k=CornerMargin; k<((SingleLine->FEdgePointCount)-CornerMargin); k++){
											 if(CornerCount>=MAX_CORNER_POINT) break;
											 C2Point[CornerCount].x = SingleLine->FEdgePoint[k].x;
											 C2Point[CornerCount].y = SingleLine->FEdgePoint[k].y;
											 CornerCount++;
										 }
									 }

									 // Value Init 
									 double Dis =0.0f, AvgGrindWidth=0.0f, AvgGrindMea=0.0f, TotalGrindWidth=0.0f, TotalGrindMeasure=0.0f;

									 // Corner Grind In Start 
									 if(CorGrindInThresHold!=0){
										 EasyImage::Threshold(&RotateImg,&RotateBinaryImg, CorGrindInThresHold);
										 SingleLine->GImage = &RotateBinaryImg;  SingleLine->FThreshold =10;

										 // Corner 기울기 완만하여 Edge찾을 경우 Defect 오버킬 발생함 
										 // 방향을 Top방향에서 다시 엣지를 찾음 (Corner Defect OverKill 감소 목적)
										 // if(RTCornerWidth >(RTCornerHeight*3)){
										 if(RTCornerWidth >(RTCornerHeight*1.5)){
											 if(FRTTPoint.x!=0.0f && FRTTPoint.y!=0.0f && FRTRPoint.x!=0.0f && FRTRPoint.y!=0.0f){

												 SingleLine->IRoi->SetOrgX  ((int)(FRTPoint.x-(FRTRPoint.x-FRTTPoint.x)+5));
												 SingleLine->IRoi->SetOrgY  ((int) FRTPoint.y                             );
												 SingleLine->IRoi->SetWidth ((int)((FRTRPoint.x-FRTTPoint.x)+5)           );
												 SingleLine->IRoi->SetHeight((int)((FRTRPoint.y - FRTTPoint.y)+10)        );

												 if(FRTTPoint.x<=0    || FRTTPoint.y<=0    || (FRTRPoint.x - FRTTPoint.x)<=0    || (FRTRPoint.y - FRTTPoint.y)<=0   ) return false;
												 if(FRTTPoint.x>=ImgW || FRTTPoint.y>=ImgH || (FRTRPoint.x - FRTTPoint.x)>=ImgW || (FRTRPoint.y - FRTTPoint.y)>=ImgH) return false;

												 SingleLine->SetOrientation(orNorth);
												 SingleLine->FIncrement =2;
												 SingleLine->SetFindLineId(0);
												 SingleLine->SetEdgeType(0);  //Black To White 
												 SingleLine->OnExecute();

												 // InLine C2Corner Data 
												 if((SingleLine->FEdgePointCount) - (CornerMargin*2)>0){
													 if(C2InPoint!=NULL) delete[] C2InPoint;
													 C2InPoint  = new TFPoint [(SingleLine->FEdgePointCount) - (CornerMargin*2)];
													 C2InEdgeCount = (SingleLine->FEdgePointCount) -(CornerMargin*2);

													 CornerCount =0;  
													 for(int k=CornerMargin; k<((SingleLine->FEdgePointCount)-CornerMargin); k++){
														 if(CornerCount>=MAX_CORNER_POINT) break;
														 C2InPoint[CornerCount].x = SingleLine->FEdgePoint[k].x;
														 C2InPoint[CornerCount].y = SingleLine->FEdgePoint[k].y;
														 CornerCount++;
													 }
												 }
											 }
										 }
										 else {
											 // Corner 연마 안쪽라인 찾는다 
											 SingleLine->SetOrientation(orEast);
											 SingleLine->SetFindLineId(0);
											 SingleLine->FIncrement =1;
											 SingleLine->SetEdgeType(0);  //Black To White 
											 SingleLine->OnExecute();

											 // InLine C2Corner Data 
											 if((SingleLine->FEdgePointCount) - (CornerMargin*2)>0){
												 if(C2InPoint!=NULL) delete[] C2InPoint;
												 C2InPoint  = new TFPoint [(SingleLine->FEdgePointCount) - (CornerMargin*2)];
												 C2InEdgeCount = (SingleLine->FEdgePointCount) -(CornerMargin*2);

												 CornerCount =0;  
												 for(int k=CornerMargin; k<((SingleLine->FEdgePointCount)-CornerMargin); k++){
													 if(CornerCount>=MAX_CORNER_POINT) break;
													 C2InPoint[CornerCount].x = SingleLine->FEdgePoint[k].x;
													 C2InPoint[CornerCount].y = SingleLine->FEdgePoint[k].y;
													 CornerCount++;
												 }
											 }
										 }

										 //코너 연마안쪽라인 기준 새로운 교차점 생성 
										 FRTRInPoint = Math.OnIntersect(SingleLine->GetResultP0(), SingleLine->GetResultP1(), Line[waRightWall].FP0, Line[waRightWall].FP1);
										 FRTTInPoint = Math.OnIntersect(SingleLine->GetResultP0(), SingleLine->GetResultP1(), Line[waTopWall  ].FP0, Line[waTopWall].FP1  );
									 }

									 // GrindMark기준 연마량,가공량 측정함 
									 // RightTop 
									 if(FP1.x!=0.0f && FP1.y!=0.0f){
										 GrindMarkRect[20].left   = (FP1.x+AMarkToGrindMarkDvX)-40;
										 GrindMarkRect[20].top    = (FP1.y+AMarkToGrindMarkDvY)-40;
										 GrindMarkRect[20].right  = (GrindMarkRect[20].left + 80);
										 GrindMarkRect[20].bottom = (GrindMarkRect[20].top  + 80);

										 GrindRectWidth  = (GrindMarkRect[20].right  - GrindMarkRect[20].left);
										 GrindRectHeight = (GrindMarkRect[20].bottom - GrindMarkRect[20].top );

										 // 원본이미지에서 Mark 찾는다 
										 Find->OnLoad(true,FindDir,1)                   ;
										 Find->GImage  = &RotateImg                     ;
										 //Find->SetContrastMode(EFindContrastMode_Any)   ;
										 Find->SetContrastMode(EFindContrastMode_Normal);
										 //Find->SetMinScore(0.8f)                        ;
										 Find->SetMinScore (GrindPadMarkMinScore)       ; // PatternrFind 검사 최소 Score
										 Find->SetZeroScore(GrindPadMarkMinScore)       ; // 검사 후 최소 Score 
										 //ind->SetMinScore (0.75)                       ; // PatternrFind 검사 최소 Score
										 //ind->SetZeroScore(0.75)                       ; // 검사 후 최소 Score 
										 Find->SetMaxInstances(1)                       ;
										 Find->SetAngleTolerance(20.0f)                 ;
										 Find->SetAngleBias(135.0f)                     ;
										 Find->SetScaleBias(1.00f)                      ;
										 Find->SetScaleTolerance(0.0f)                  ;
										 Find->Property.Ox = (float)ImgW/2              ;
										 Find->Property.Oy = (float)ImgH/2              ;

										 Find->IRoi->SetPlacement(GrindMarkRect[20].left,GrindMarkRect[20].top,GrindRectWidth,GrindRectHeight);
										 if(GrindMarkRect[20].left<=0 || GrindMarkRect[20].top<=0 || GrindRectWidth<=0 || GrindRectHeight<=0) return false;

										 // 검사 및 Match Pos 좌표 받어온다 
										 // Find 검사 성공시 데이터 받아옴 
										 if(Find->OnExecute()){
											 GrindMarkPoint[20].x = Find->Result[0].Px;
											 GrindMarkPoint[20].y = Find->Result[0].Py;
											 GrindMarkScore[20]   = Find->Result[0].Score;
										 }
										 // Contrast Gradient Pixel Value
										 GrindMarkGradient[20] = EasyImage::Focusing(Find->IRoi);
									 }

									 // GrindMakr찾을경우 연마량,가공량 측정함
									 if(GrindMarkPoint[20].x!=0.0f && GrindMarkPoint[20].y!=0.0f){
										 // GrindMark기준 OutData 최단거리 Count정보 Calc 
										 GrindMeaDis =0.0f, MinDis =10000.0f; GrindMarkOutCnt=0;
										 for(int k=0; k<C2EdgeCount; k++){
											 if(C2Point[k].x  ==0.0f       || C2Point[k].y        ==0.0f) continue;
											 if(GrindMarkPoint[20].x==0.0f || GrindMarkPoint[20].y==0.0f) continue;

											 GrindMeaDis = Math.GetLength(GrindMarkPoint[20], C2Point[k]);
											 if(GrindMeaDis<MinDis){
												 MinDis = GrindMeaDis;
												 GrindMarkOutCnt = k;
											 }
										 }
										 // OutData기준 InData 최단거리 Count정보 Calc 
										 if(GrindMarkOutCnt!=0){
											 GrindMeaDis =0.0f, MinDis =10000.0f; GrindMarkInCnt=0;
											 for(int k=0; k<C2InEdgeCount; k++){
												 if(C2InPoint[k].x   ==0.0f          || C2InPoint[k].y             ==0.0f) continue;
												 if(C2Point[GrindMarkOutCnt].x==0.0f || C2Point[GrindMarkOutCnt].y ==0.0f) continue;

												 GrindMeaDis = Math.GetLength(C2Point[GrindMarkOutCnt], C2InPoint[k]);
												 if(GrindMeaDis<MinDis){
													 MinDis = GrindMeaDis;
													 GrindMarkInCnt = k;
												 }
											 }
										 }

										 // GrindMark기준 수직 포인트 주변값 Avg산출한다 ==>가공량 측정(OutData기준)
										 if(GrindMarkOutCnt!=0 && GrindMarkOutCnt>5){
											 CircleCount=0,TotalCirDis=0.0f,GrindMeaDis=0.0f;
											 for(int k=GrindMarkOutCnt-5; k<GrindMarkOutCnt+5; k++){
												 if(C2Point[k].x==0.0f || C2Point[k].y==0.0f) continue;

												 GrindMeaDis = Math.GetLength(GrindMarkPoint[20], C2Point[k]);
												 TotalCirDis+= GrindMeaDis;
												 CircleCount++;
											 }
											 if(TotalCirDis!=0.0f && CircleCount!=0){
												 C2CorGrindMea = TotalCirDis/CircleCount;
											 }
										 }

										 // GrindMark기준 수직 포인트 주변값 Avg산출한다 ==>연마량 측정(OutData,InData기준)
										 if((GrindMarkOutCnt!=0 && GrindMarkOutCnt>5) && (GrindMarkInCnt!=0 && GrindMarkInCnt>5)){
											 CircleCount=0,TotalCirDis=0.0f,GrindWidthDis=0.0f;
											 for(int k=-5; k<5; k++){
												 if(C2Point  [GrindMarkOutCnt+k].x==0.0f && C2Point  [GrindMarkOutCnt+k].y==0.0f) continue;
												 if(C2InPoint[GrindMarkInCnt +k].x==0.0f && C2InPoint[GrindMarkInCnt +k].y==0.0f) continue;
												 GrindWidthDis = Math.GetLength(C2InPoint[GrindMarkInCnt+k], C2Point[GrindMarkOutCnt+k]);
												 TotalCirDis+=   GrindWidthDis;
												 CircleCount++;
											 }
											 if(TotalCirDis!=0.0f && CircleCount!=0){
												 C2CorGrindWd  = TotalCirDis/CircleCount;
											 }
										 }
									 }
									 else { // GrindMrk 못찾을경우 연마량만 측정함 
										 // OutData기준 최소값 데이터 Count산출 
										 GrindMeaDis =0.0f, MinDis =10000.0f; GrindMarkOutCnt=0;
										 for(int k=0; k<C2EdgeCount; k++){
											 if(C2Point[k].x==0.0f || C2Point[k].y==0.0f) continue;

											 C2GrindRectPoint.x = GrindMarkRect[20].left + (GrindMarkRect[20].right  - GrindMarkRect[20].left)/2; 
											 C2GrindRectPoint.y = GrindMarkRect[20].top  + (GrindMarkRect[20].bottom - GrindMarkRect[20].top )/2; 

											 GrindMeaDis = Math.GetLength(C2GrindRectPoint, C2Point[k]);
											 if(GrindMeaDis<MinDis){
												 MinDis = GrindMeaDis;
												 GrindMarkOutCnt = k;
											 }
										 }

										 // 최단거리OUtCount기준 InData 최단거리 Count정보 Calc 
										 if(GrindMarkOutCnt!=0){
											 GrindMeaDis =0.0f, MinDis =10000.0f; GrindMarkInCnt=0;
											 for(int k=0; k<C2InEdgeCount; k++){
												 if(C2InPoint[k].x            ==0.0f || C2InPoint[k].y             ==0.0f) continue;
												 if(C2Point[GrindMarkOutCnt].x==0.0f || C2Point[GrindMarkOutCnt].y ==0.0f) continue;

												 GrindMeaDis = Math.GetLength(C2Point[GrindMarkOutCnt], C2InPoint[k]);
												 if(GrindMeaDis<MinDis){
													 MinDis = GrindMeaDis;
													 GrindMarkInCnt = k;
												 }
											 }
										 }

										 // GrindMark기준 수직 포인트 주변값 Avg산출한다 ==>연마량 측정(OutData,InData기준)
										 if((GrindMarkOutCnt!=0 && GrindMarkOutCnt>5) && (GrindMarkInCnt!=0 && GrindMarkInCnt>5)){
											 CircleCount=0,TotalCirDis=0.0f,GrindWidthDis=0.0f;
											 for(int k=-5; k<5; k++){
												 if(C2Point  [GrindMarkOutCnt+k].x==0.0f && C2Point  [GrindMarkOutCnt+k].y==0.0f) continue;
												 if(C2InPoint[GrindMarkInCnt +k].x==0.0f && C2InPoint[GrindMarkInCnt +k].y==0.0f) continue;
												 GrindWidthDis = Math.GetLength(C2InPoint[GrindMarkInCnt+k], C2Point[GrindMarkOutCnt+k]);
												 TotalCirDis+=   GrindWidthDis;
												 CircleCount++;
											 }
											 if(TotalCirDis!=0.0f && CircleCount!=0){
												 C2CorGrindWd = TotalCirDis/CircleCount;
											 }
										 }
									 }
								 }
							 }
						 }
						 else if(IsRectTop){
							 RTDx = 0.0f;
							 RTDy = 0.0f;
							 //화면에 디스플레이 위해서 
							 FRTRPoint.x = FRTPoint.x;
							 FRTRPoint.y = FRTPoint.y;
							 FRTTPoint.x = FRTPoint.x;
							 FRTTPoint.y = FRTPoint.y;
						 }
						 else if(IsCircleTop){ // TOP영역 RightTop Circle 검사  A2Circle 
							 // Org A1CircleData 
							 int OrgA2CirInEdgeCount =0;		  
							 int OrgA2CirOutEdgeCount=0;	    
							 int A2GrindWidthCount   =0;		  
							 int A2GrindMarkCount    =0;
							 int A2Diameter          =0;
							 GrindRectWidth          =0;
							 GrindRectHeight         =0;

							 TFPoint *OrgA2CirInPoint =NULL;	 
							 TFPoint *OrgA2CirOutPoint=NULL;

							 TFPoint AGrindMarkRectPoint2(0.0f, 0.0f);

							 // Find Mark Search Start
							 ////////////////////////////////////////////////////////////////////////////
							 if(IsMarkBtm && FInspectMode!=Insp_Track){
								 // 									 LogUnit.SetLog("CellID:%d, CamID:%d ==>A2MarkFind_START",CellId,CamId);     

								 if(FP1.x!=0.0f && FP1.y!=0.0f){
									 Find->OnLoad(true,FindDir,1)                   ;
									 Find->GImage = &RotateImg                      ;
									 Find->SetContrastMode(EFindContrastMode_Normal);
									 // 										 Find->SetContrastMode(EFindContrastMode_Any    );
									 // 										 Find->SetMinScore(0.8f)                        ;
									 Find->SetMinScore (GrindPadMarkMinScore)       ; // PatternrFind 검사 최소 Score
									 Find->SetZeroScore(GrindPadMarkMinScore)       ; // 검사 후 최소 Score 
									 // 										 Find->SetMinScore (0.75)                       ; // PatternrFind 검사 최소 Score
									 // 										 Find->SetZeroScore(0.75)                       ; // 검사 후 최소 Score 
									 Find->SetMaxInstances(1)                       ;
									 Find->SetAngleTolerance(20.0f)                 ;
									 // 										 Find->SetAngleBias(135.0f)                     ;
									 Find->SetScaleBias(1.00f)                      ;
									 Find->SetScaleTolerance(0.0f)                  ;
									 Find->Property.Ox = (float)ImgW/2              ;
									 Find->Property.Oy = (float)ImgH/2              ;

									 // 첫번째 GrindMark기준 센터 20번 Search
									 if(AMarkToGrindMarkDvX!=0.0f && AMarkToGrindMarkDvX!=0.0f){
										 GrindMarkRect[20].left   = (FP1.x+AMarkToGrindMarkDvX)-40;
										 GrindMarkRect[20].top    = (FP1.y+AMarkToGrindMarkDvY)-40;
										 GrindMarkRect[20].right  = (GrindMarkRect[20].left + 80);
										 GrindMarkRect[20].bottom = (GrindMarkRect[20].top  + 80);

										 GrindRectWidth  = (GrindMarkRect[20].right  - GrindMarkRect[20].left);
										 GrindRectHeight = (GrindMarkRect[20].bottom - GrindMarkRect[20].top );

										 Find->IRoi->SetPlacement(GrindMarkRect[20].left,GrindMarkRect[20].top,GrindRectWidth,GrindRectHeight);
										 if(GrindMarkRect[20].left<=0 || GrindMarkRect[20].top<=0 || GrindRectWidth<=0 || GrindRectHeight<=0) return false;

										 // 검사 및 Match Pos 좌표 받어온다 
										 // Find 검사 성공시 데이터 받아옴 

										 if(RqMode == true)
											 Find->SetAngleBias(150.0f);
										 else
											 Find->SetAngleBias(135.0f);

										 if(Find->OnExecute()){
											 GrindMarkPoint[20].x = Find->Result[0].Px;
											 GrindMarkPoint[20].y = Find->Result[0].Py;
											 GrindMarkScore[20]   = Find->Result[0].Score;
										 }
										 // Contrast Gradient Pixel Value
										 GrindMarkGradient[20] = EasyImage::Focusing(Find->IRoi);
									 }

									 // 두번째 GrindMark기준 센터 20번 Search
									 if(AMarkToGrindMarkDvX2!=0.0f && AMarkToGrindMarkDvX2!=0.0f){
										 GrindMarkRect[21].left   = (FP1.x-AMarkToGrindMarkDvX2)-40;
										 GrindMarkRect[21].top    = (FP1.y+AMarkToGrindMarkDvY2)-40;
										 GrindMarkRect[21].right  = (GrindMarkRect[21].left + 80);
										 GrindMarkRect[21].bottom = (GrindMarkRect[21].top  + 80);

										 GrindRectWidth  = (GrindMarkRect[21].right  - GrindMarkRect[21].left);
										 GrindRectHeight = (GrindMarkRect[21].bottom - GrindMarkRect[21].top );

										 Find->IRoi->SetPlacement(GrindMarkRect[21].left,GrindMarkRect[21].top,GrindRectWidth,GrindRectHeight);
										 if(GrindMarkRect[21].left<=0 || GrindMarkRect[21].top<=0 || GrindRectWidth<=0 || GrindRectHeight<=0) return false;

										 // 검사 및 Match Pos 좌표 받어온다 
										 // Find 검사 성공시 데이터 받아옴 
										 Find->SetAngleBias(90.0f);
										 if(Find->OnExecute()){
											 GrindMarkPoint[21].x = Find->Result[0].Px;
											 GrindMarkPoint[21].y = Find->Result[0].Py;
											 GrindMarkScore[21]   = Find->Result[0].Score;
										 }
										 // Contrast Gradient Pixel Value
										 GrindMarkGradient[21] = EasyImage::Focusing(Find->IRoi);
									 }
								 }
								 // 									 LogUnit.SetLog("CellID:%d, CamID:%d ==>A2MarkFind_END",CellId,CamId);     
							 }
							 // Find Mark Search Start
							 ////////////////////////////////////////////////////////////////////////////

							 // NOTCH RightTop
							 if(FInspectMode==Insp_Polygon){
								 // 									 LogUnit.SetLog("CellID:%d, CamID:%d ==>RightTop_Polygon_START",CellId,CamId);     

								 // 									 RotateBinaryImg.Save("D:\\ROTATE_IMG\\Polygon_BinaryImg2.bmp");
								 TPoint P1(0,0),P2(0,0),P3(0,0),P4(0,0);

								 // 									 P1.x = (int)(FRTPoint.x-ASideCircleWidth-30);    P1.y =(int)(FRTPoint.y-20            );    P2.x = (int)(FRTPoint.x+20);    P2.y = (int)(P1.y);
								 // 									 P3.x = (int)(P1.x)                          ;    P3.y =(int)(P1.y+ASideCircleHeight+50);    P4.x = (int)(P2.x         );    P4.y = (int)(P3.y);
								 P1.x = (int)(FRTPoint.x-ASideCircleWidth   );    P1.y =(int)(FRTPoint.y-20            );    P2.x = (int)(FRTPoint.x+20);    P2.y = (int)(P1.y);
								 P3.x = (int)(P1.x)                          ;    P3.y =(int)(P1.y+ASideCircleHeight+20);    P4.x = (int)(P2.x         );    P4.y = (int)(P3.y);

								 // 검사화면 Display 목적 
								 PadPolyRect[1].left  = P1.x;   PadPolyRect[1].top    = P1.y;
								 PadPolyRect[1].right = P2.x;   PadPolyRect[1].bottom = P3.y;

								 int PixelCnt =0;

								 // Median Filter 적용 
								 if(P1.x<=0    || P1.y<=0    || (P2.x - P1.x)<=0    || (P3.y - P1.y)<=0   ) return false;
								 if(P1.x>=ImgW || P1.y>=ImgH || (P2.x - P1.x)>=ImgW || (P3.y - P1.y)>=ImgH) return false;
								 FilterROI.SetSize(int(P2.x - P1.x),int(P3.y - P1.y) )                 ;
								 FilterROI.Attach(&RotateBinaryImg)                                    ;
								 FilterROI.SetPlacement(P1.x, P1.y, int(P2.x - P1.x), int(P3.y - P1.y));
								 LogUnit.SetLog(L"RightTop ==>Px :%d, Py :%d, Width:%d, Height:%d ==>Median Filter",P1.x, P1.y, int(P2.x - P1.x), int(P3.y - P1.y));     
								 LogUnit.SetLog(L"RightTop ==>P1x:%d, P1y:%d, P2x:%d, P2y:%d, P3x:%d, P3y:%d, P4x:%d, P4y:%d,",P1.x,P1.y,P2.x,P2.y,P3.x,P3.y,P4.x,P4.y);     
								 EasyImage::Median(&FilterROI, &FilterROI)                             ;
								 // 									 RotateBinaryImg.Save("D:\\ROTATE_IMG\\Polygon_RightTop_필터.bmp");

								 Polygon->GImage = &RotateBinaryImg                          ;
								 Polygon->IWidth = ImgW                                      ;
								 Polygon->IHeight= ImgH                                      ;
								 Polygon->PoPa.FMinWidth  =(int)(ASideCircleWidth/2)         ;                       
								 // 									 Polygon->PoPa.FMaxWidth  =(int)((FRTPoint.x - FLTPoint.x)/2);
								 Polygon->PoPa.FMaxWidth  =(int)(ASideCircleWidth+100)       ;
								 Polygon->PoPa.FMinHeight =(int)(ASideCircleHeight/2)        ;
								 // 									 Polygon->PoPa.FMaxHeight =1000                              ;
								 Polygon->PoPa.FMaxHeight =(int)(ASideCircleHeight+100)      ;
								 Polygon->PoPa.MinPxCnt   =100                               ;
								 Polygon->PoPa.MaxPxCnt   =20000                             ;
								 Polygon->PoPa.MaxBbCnt   =10                                ;
								 Polygon->PoPa.IsSeparate =true                              ;
								 Polygon->PoPa.IsInToOut  =false                             ;
								 Polygon->PoPa.HiThHold   = ECThresHold                      ;
								 Polygon->PoPa.LoThHold   = 0                                ;

								 if(P1.x!=0 && P1.y!=0 && P2.x!=0 && P2.y!=0 && P3.x!=0 && P3.y!=0 && P4.x!=0 && P4.y!=0){
									 Polygon->OnExecute(P1,P2,P3,P4);
								 }
								 // Polygon Algorithm InEdgeData/OutEdgeData Separate 
								 if(Polygon->BlobCount==1){
									 PolygonMarginCnt = (IsMarkBtm)? 5:20;
									 if(Polygon->Blob[0].InCnt>(PolygonMarginCnt*2)){
										 A2CirInEdgeCount=0;
										 A2CirInEdgeCount = (Polygon->Blob[0].InCnt - (PolygonMarginCnt*2));
										 if(A2CirInEdgeCount>0){
											 if(A2CirInPoint!=NULL) delete[] A2CirInPoint;
											 A2CirInPoint = new TFPoint[A2CirInEdgeCount];

											 PixelCnt=0;
											 for(int k=0; k<Polygon->Blob[0].InCnt; k++){
												 if(k<PolygonMarginCnt || k>=(Polygon->Blob[0].InCnt-PolygonMarginCnt)) continue;
												 A2CirInPoint[PixelCnt].x = Polygon->Blob[0].InPoint[k].x ;
												 A2CirInPoint[PixelCnt].y = Polygon->Blob[0].InPoint[k].y ;
												 PixelCnt++;
											 }
										 }
									 }

									 if(Polygon->Blob[0].OutCnt>(PolygonMarginCnt*2)){
										 A2CirOutEdgeCount=0;
										 A2CirOutEdgeCount = (Polygon->Blob[0].OutCnt - (PolygonMarginCnt*2));
										 if(A2CirOutEdgeCount>0){
											 if(A2CirOutPoint!=NULL) delete[] A2CirOutPoint;
											 A2CirOutPoint = new TFPoint[A2CirOutEdgeCount];

											 PixelCnt=0;
											 for(int k=0; k<Polygon->Blob[0].OutCnt; k++){
												 if(k<PolygonMarginCnt || k>=(Polygon->Blob[0].OutCnt-PolygonMarginCnt)) continue;
												 A2CirOutPoint[PixelCnt].x = Polygon->Blob[0].OutPoint[k].x ;
												 A2CirOutPoint[PixelCnt].y = Polygon->Blob[0].OutPoint[k].y ;
												 PixelCnt++;
											 }
										 }
									 }
									 // Polygon Data Clear
									 // 										 Polygon->ClearData();
								 }


								 // InEdgeData/OutEdgeData 기준 가공량 및 연마량 계산
								 if(IsMarkBtm){ // LTPS 가공량,연마량 계산 
									 if(A2CirOutEdgeCount!=0 && A2CirInEdgeCount!=0){ // MarkMode경우 가공량 검사를 먼저 진행 후 연마량 산출
										 ////////////////////////////////////////////////////////////////////////////////////////////////////
										 if(GrindMarkPoint[20].x!=0.0f && GrindMarkPoint[20].y!=0.0f){  //GrindMark 찾았을경우 
											 // GrindMark기준 OutData 최단거리 Count정보 Calc 
											 GrindMeaDis =0.0f, MinDis =10000.0f; GrindMarkOutCnt=0;
											 for(int k=0; k<A2CirOutEdgeCount; k++){
												 if(A2CirOutPoint[k].x  ==0.0f || A2CirOutPoint[k].y  ==0.0f) continue;
												 if(GrindMarkPoint[20].x==0.0f || GrindMarkPoint[20].y==0.0f) continue;

												 GrindMeaDis = Math.GetLength(GrindMarkPoint[20], A2CirOutPoint[k]);
												 if(GrindMeaDis<MinDis){
													 MinDis = GrindMeaDis;
													 GrindMarkOutCnt = k;
												 }
											 }
											 // GrindMark기준 InData 최단거리 Count정보 Calc 
											 GrindMeaDis =0.0f, MinDis =10000.0f; GrindMarkInCnt=0;
											 for(int k=0; k<A2CirInEdgeCount; k++){
												 if(A2CirInPoint[k].x   ==0.0f || A2CirInPoint[k].y    ==0.0f) continue;
												 if(GrindMarkPoint[20].x==0.0f || GrindMarkPoint[20].y ==0.0f) continue;

												 GrindMeaDis = Math.GetLength(GrindMarkPoint[20], A2CirInPoint[k]);
												 if(GrindMeaDis<MinDis){
													 MinDis = GrindMeaDis;
													 GrindMarkInCnt = k;
												 }
											 }

											 if(GrindMarkOutCnt!=0){
												 // GrindMark기준 InData 최단거리 Count정보 Calc 
												 GrindMeaDis =0.0f, MinDis =10000.0f; GrindMarkInCnt=0;
												 for(int k=0; k<A2CirInEdgeCount; k++){
													 if(A2CirInPoint[k].x               ==0.0f || A2CirInPoint[k].y                ==0.0f) continue;
													 if(A2CirOutPoint[GrindMarkOutCnt].x==0.0f || A2CirOutPoint[GrindMarkOutCnt].y ==0.0f) continue;

													 GrindMeaDis = Math.GetLength(A2CirOutPoint[GrindMarkOutCnt], A2CirInPoint[k]);
													 if(GrindMeaDis<MinDis){
														 MinDis = GrindMeaDis;
														 GrindMarkInCnt = k;
													 }
												 }
											 }

											 // GrindMark기준 수직 포인트 주변값 Avg산출한다 ==>가공량 측정(OutData기준)
											 if(GrindMarkOutCnt!=0 && GrindMarkOutCnt>5){
												 CircleCount=0,TotalCirDis=0.0f,GrindMeaDis=0.0f;
												 for(int k=GrindMarkOutCnt-5; k<GrindMarkOutCnt+5; k++){
													 if(A2CirOutPoint[k].x==0.0f || A2CirOutPoint[k].y==0.0f) continue;

													 GrindMeaDis = Math.GetLength(GrindMarkPoint[20], A2CirOutPoint[k]);
													 TotalCirDis+= GrindMeaDis;
													 CircleCount++;
												 }
												 if(TotalCirDis!=0.0f && CircleCount!=0){
													 A2CirGrindMea[2] = TotalCirDis/CircleCount;
													 A2CirGrindMea[2] = A2CirGrindMea[2]+0.5; //SubPixel 
												 }
											 }

											 // GrindMark기준 수직 포인트 주변값 Avg산출한다 ==>연마량 측정(OutData,InData기준)
											 if((GrindMarkOutCnt!=0 && GrindMarkOutCnt>5) && (GrindMarkInCnt!=0 && GrindMarkInCnt>5)){
												 CircleCount=0,TotalCirDis=0.0f,GrindWidthDis=0.0f;
												 for(int k=-5; k<5; k++){
													 if(A2CirOutPoint[GrindMarkOutCnt+k].x==0.0f && A2CirOutPoint[GrindMarkOutCnt+k].y==0.0f) continue;
													 if(A2CirInPoint [GrindMarkInCnt +k].x==0.0f && A2CirInPoint [GrindMarkInCnt +k].y==0.0f) continue;
													 GrindWidthDis = Math.GetLength(A2CirInPoint[GrindMarkInCnt+k], A2CirOutPoint[GrindMarkOutCnt+k]);
													 TotalCirDis+=   GrindWidthDis;
													 CircleCount++;
												 }
												 if(TotalCirDis!=0.0f && CircleCount!=0){
													 A2CirGrindWd[2] = TotalCirDis/CircleCount;
													 A2CirGrindWd[2] = A2CirGrindWd[2]+0.5; //SubPixel
												 }
											 }
										 }
										 else if(GrindMarkRect[20].left!=0 && GrindMarkRect[20].top!=0 && GrindMarkRect[20].right!=0 && GrindMarkRect[20].bottom!=0){  //GrindMark 못 찾았을경우
											 // OutData기준 최소값 데이터 Count산출 
											 GrindMeaDis =0.0f, MinDis =10000.0f; GrindMarkOutCnt=0;
											 for(int k=0; k<A2CirOutEdgeCount; k++){
												 if(A2CirOutPoint[k].x==0.0f || A2CirOutPoint[k].y==0.0f) continue;

												 AGrindMarkRectPoint2.x = GrindMarkRect[20].left + (GrindMarkRect[20].right  - GrindMarkRect[20].left)/2; 
												 AGrindMarkRectPoint2.y = GrindMarkRect[20].top  + (GrindMarkRect[20].bottom - GrindMarkRect[20].top )/2; 

												 GrindMeaDis = Math.GetLength(AGrindMarkRectPoint2, A2CirOutPoint[k]);
												 if(GrindMeaDis<MinDis){
													 MinDis = GrindMeaDis;
													 GrindMarkOutCnt = k;
												 }
											 }

											 // 최단거리OUtCount기준 InData 최단거리 Count정보 Calc 
											 if(GrindMarkOutCnt!=0){
												 GrindMeaDis =0.0f, MinDis =10000.0f; GrindMarkInCnt=0;
												 for(int k=0; k<A2CirInEdgeCount; k++){
													 if(A2CirInPoint[k].x   ==0.0f             || A2CirInPoint[k].y                ==0.0f) continue;
													 if(A2CirOutPoint[GrindMarkOutCnt].x==0.0f || A2CirOutPoint[GrindMarkOutCnt].y ==0.0f) continue;

													 GrindMeaDis = Math.GetLength(A2CirOutPoint[GrindMarkOutCnt], A2CirInPoint[k]);
													 if(GrindMeaDis<MinDis){
														 MinDis = GrindMeaDis;
														 GrindMarkInCnt = k;
													 }
												 }
											 }

											 // GrindMark기준 수직 포인트 주변값 Avg산출한다 ==>연마량 측정(OutData,InData기준)
											 if((GrindMarkOutCnt!=0 && GrindMarkOutCnt>5) && (GrindMarkInCnt!=0 && GrindMarkInCnt>5)){
												 CircleCount=0,TotalCirDis=0.0f,GrindWidthDis=0.0f;
												 for(int k=-5; k<5; k++){
													 if(A2CirOutPoint[GrindMarkOutCnt+k].x==0.0f && A2CirOutPoint[GrindMarkOutCnt+k].y==0.0f) continue;
													 if(A2CirInPoint [GrindMarkInCnt +k].x==0.0f && A2CirInPoint [GrindMarkInCnt +k].y==0.0f) continue;
													 GrindWidthDis = Math.GetLength(A2CirInPoint[GrindMarkInCnt+k], A2CirOutPoint[GrindMarkOutCnt+k]);
													 TotalCirDis+=   GrindWidthDis;
													 CircleCount++;
												 }
												 if(TotalCirDis!=0.0f && CircleCount!=0){
													 A2CirGrindWd[2] = TotalCirDis/CircleCount;
													 A2CirGrindWd[2] = A2CirGrindWd[2]+0.5; //SubPixel
												 }
											 }
										 }
										 /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

										 ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
										 if(GrindMarkPoint[21].x!=0.0f && GrindMarkPoint[21].y!=0.0f){  //GrindMark 찾았을경우 
											 // GrindMark기준 OutData 최단거리 Count정보 Calc 
											 GrindMeaDis =0.0f, MinDis =10000.0f; GrindMarkOutCnt=0;
											 for(int k=0; k<A2CirOutEdgeCount; k++){
												 if(A2CirOutPoint[k].x  ==0.0f || A2CirOutPoint[k].y  ==0.0f) continue;
												 if(GrindMarkPoint[21].x==0.0f || GrindMarkPoint[21].y==0.0f) continue;

												 GrindMeaDis = Math.GetLength(GrindMarkPoint[21], A2CirOutPoint[k]);
												 if(GrindMeaDis<MinDis){
													 MinDis = GrindMeaDis;
													 GrindMarkOutCnt = k;
												 }
											 }
											 // GrindMark기준 InData 최단거리 Count정보 Calc 
											 GrindMeaDis =0.0f, MinDis =10000.0f; GrindMarkInCnt=0;
											 for(int k=0; k<A2CirInEdgeCount; k++){
												 if(A2CirInPoint[k].x   ==0.0f || A2CirInPoint[k].y    ==0.0f) continue;
												 if(GrindMarkPoint[21].x==0.0f || GrindMarkPoint[21].y ==0.0f) continue;

												 GrindMeaDis = Math.GetLength(GrindMarkPoint[21], A2CirInPoint[k]);
												 if(GrindMeaDis<MinDis){
													 MinDis = GrindMeaDis;
													 GrindMarkInCnt = k;
												 }
											 }
											 if(GrindMarkOutCnt!=0){
												 // GrindMark기준 InData 최단거리 Count정보 Calc 
												 GrindMeaDis =0.0f, MinDis =10000.0f; GrindMarkInCnt=0;
												 for(int k=0; k<A2CirInEdgeCount; k++){
													 if(A2CirInPoint[k].x               ==0.0f || A2CirInPoint[k].y                ==0.0f) continue;
													 if(A2CirOutPoint[GrindMarkOutCnt].x==0.0f || A2CirOutPoint[GrindMarkOutCnt].y ==0.0f) continue;

													 GrindMeaDis = Math.GetLength(A2CirOutPoint[GrindMarkOutCnt], A2CirInPoint[k]);
													 if(GrindMeaDis<MinDis){
														 MinDis = GrindMeaDis;
														 GrindMarkInCnt = k;
													 }
												 }
											 }

											 // GrindMark기준 수직 포인트 주변값 Avg산출한다 ==>가공량 측정(OutData기준)
											 if(GrindMarkOutCnt!=0 && GrindMarkOutCnt>5){
												 CircleCount=0,TotalCirDis=0.0f,GrindMeaDis=0.0f;
												 for(int k=GrindMarkOutCnt-5; k<GrindMarkOutCnt+5; k++){
													 if(A2CirOutPoint[k].x==0.0f || A2CirOutPoint[k].y==0.0f) continue;

													 GrindMeaDis = Math.GetLength(GrindMarkPoint[21], A2CirOutPoint[k]);
													 TotalCirDis+= GrindMeaDis;
													 CircleCount++;
												 }
												 if(TotalCirDis!=0.0f && CircleCount!=0){
													 A2CirGrindMea[1] = TotalCirDis/CircleCount;
													 A2CirGrindMea[1] = A2CirGrindMea[1]+0.5; //SubPixel 
												 }
											 }

											 // GrindMark기준 수직 포인트 주변값 Avg산출한다 ==>연마량 측정(OutData,InData기준)
											 if((GrindMarkOutCnt!=0 && GrindMarkOutCnt>5) && (GrindMarkInCnt!=0 && GrindMarkInCnt>5)){
												 CircleCount=0,TotalCirDis=0.0f,GrindWidthDis=0.0f;
												 for(int k=-5; k<5; k++){
													 if(A2CirOutPoint[GrindMarkOutCnt+k].x==0.0f && A2CirOutPoint[GrindMarkOutCnt+k].y==0.0f) continue;
													 if(A2CirInPoint [GrindMarkInCnt +k].x==0.0f && A2CirInPoint [GrindMarkInCnt +k].y==0.0f) continue;
													 GrindWidthDis = Math.GetLength(A2CirInPoint[GrindMarkInCnt+k], A2CirOutPoint[GrindMarkOutCnt+k]);
													 TotalCirDis+=   GrindWidthDis;
													 CircleCount++;
												 }
												 if(TotalCirDis!=0.0f && CircleCount!=0){
													 A2CirGrindWd[1] = TotalCirDis/CircleCount;
													 A2CirGrindWd[1] = A2CirGrindWd[1]+0.5; //SubPixel
												 }
											 }
										 }
										 else if(GrindMarkRect[21].left!=0 && GrindMarkRect[21].top!=0 && GrindMarkRect[21].right!=0 && GrindMarkRect[21].bottom!=0){  //GrindMark 못 찾았을경우
											 // OutData기준 최소값 데이터 Count산출 
											 GrindMeaDis =0.0f, MinDis =10000.0f; GrindMarkOutCnt=0;
											 for(int k=0; k<A2CirOutEdgeCount; k++){
												 if(A2CirOutPoint[k].x==0.0f || A2CirOutPoint[k].y==0.0f) continue;

												 AGrindMarkRectPoint2.x = GrindMarkRect[21].left + (GrindMarkRect[21].right  - GrindMarkRect[21].left)/2; 
												 AGrindMarkRectPoint2.y = GrindMarkRect[21].top  + (GrindMarkRect[21].bottom - GrindMarkRect[21].top )/2; 

												 GrindMeaDis = Math.GetLength(AGrindMarkRectPoint2, A2CirOutPoint[k]);
												 if(GrindMeaDis<MinDis){
													 MinDis = GrindMeaDis;
													 GrindMarkOutCnt = k;
												 }
											 }

											 // 최단거리OUtCount기준 InData 최단거리 Count정보 Calc 
											 if(GrindMarkOutCnt!=0){
												 GrindMeaDis =0.0f, MinDis =10000.0f; GrindMarkInCnt=0;
												 for(int k=0; k<A2CirInEdgeCount; k++){
													 if(A2CirInPoint[k].x   ==0.0f             || A2CirInPoint[k].y                ==0.0f) continue;
													 if(A2CirOutPoint[GrindMarkOutCnt].x==0.0f || A2CirOutPoint[GrindMarkOutCnt].y ==0.0f) continue;

													 GrindMeaDis = Math.GetLength(A2CirOutPoint[GrindMarkOutCnt], A2CirInPoint[k]);
													 if(GrindMeaDis<MinDis){
														 MinDis = GrindMeaDis;
														 GrindMarkInCnt = k;
													 }
												 }
											 }

											 // GrindMark기준 수직 포인트 주변값 Avg산출한다 ==>연마량 측정(OutData,InData기준)
											 if((GrindMarkOutCnt!=0 && GrindMarkOutCnt>5) && (GrindMarkInCnt!=0 && GrindMarkInCnt>5)){
												 CircleCount=0,TotalCirDis=0.0f,GrindWidthDis=0.0f;
												 for(int k=-5; k<5; k++){
													 if(A2CirOutPoint[GrindMarkOutCnt+k].x==0.0f && A2CirOutPoint[GrindMarkOutCnt+k].y==0.0f) continue;
													 if(A2CirInPoint [GrindMarkInCnt +k].x==0.0f && A2CirInPoint [GrindMarkInCnt +k].y==0.0f) continue;
													 GrindWidthDis = Math.GetLength(A2CirInPoint[GrindMarkInCnt+k], A2CirOutPoint[GrindMarkOutCnt+k]);
													 TotalCirDis+=   GrindWidthDis;
													 CircleCount++;
												 }
												 if(TotalCirDis!=0.0f && CircleCount!=0){
													 A2CirGrindWd[1] = TotalCirDis/CircleCount;
													 A2CirGrindWd[1] = A2CirGrindWd[1]+0.5; //SubPixel
												 }
											 }
										 }
										 /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
									 }
								 }
								 else         { //Polygon EnCap 계산시 OutPoint 중간값 기준 실측 거리 평균값을 계산한다(RightTop)
									 if(A2CirInEdgeCount!=0 &&A2CirOutEdgeCount!=0){
										 GrindMeaDis =0.0f, MinDis =10000.0f; GrindMarkOutCnt=0;
										 GrindMarkOutCnt = (int)(A2CirOutEdgeCount/2);
										 // 최단거리OUtCount기준 InData 최단거리 Count정보 Calc 
										 if(GrindMarkOutCnt!=0){
											 GrindMeaDis =0.0f, MinDis =10000.0f; GrindMarkInCnt=0;
											 for(int k=0; k<A2CirInEdgeCount; k++){
												 if(A2CirInPoint[k].x   ==0.0f             || A2CirInPoint[k].y                ==0.0f) continue;
												 if(A2CirOutPoint[GrindMarkOutCnt].x==0.0f || A2CirOutPoint[GrindMarkOutCnt].y ==0.0f) continue;

												 GrindMeaDis = Math.GetLength(A2CirOutPoint[GrindMarkOutCnt], A2CirInPoint[k]);
												 if(GrindMeaDis<MinDis){
													 MinDis = GrindMeaDis;
													 GrindMarkInCnt = k;
												 }
											 }
										 }

										 // GrindMark기준 수직 포인트 주변값 Avg산출한다 ==>연마량 측정(OutData,InData기준)
										 if((GrindMarkOutCnt!=0 && GrindMarkOutCnt>5) && (GrindMarkInCnt!=0 && GrindMarkInCnt>5)){
											 CircleCount=0,TotalCirDis=0.0f,GrindWidthDis=0.0f;
											 for(int k=-5; k<5; k++){
												 if(A2CirOutPoint[GrindMarkOutCnt+k].x==0.0f && A2CirOutPoint[GrindMarkOutCnt+k].y==0.0f) continue;
												 if(A2CirInPoint [GrindMarkInCnt +k].x==0.0f && A2CirInPoint [GrindMarkInCnt +k].y==0.0f) continue;
												 GrindWidthDis = Math.GetLength(A2CirInPoint[GrindMarkInCnt+k], A2CirOutPoint[GrindMarkOutCnt+k]);
												 TotalCirDis+=   GrindWidthDis;
												 CircleCount++;
											 }
											 if(TotalCirDis!=0.0f && CircleCount!=0){
												 A2CirGrindWd[2] = TotalCirDis/CircleCount;
												 A2CirGrindWd[2] = A2CirGrindWd[2]+0.5; //SubPixel
											 }
										 }
									 }
								 }
								 // FAVION Circle Fitting 결과물(RightTop)
								 SampleSize = A2CirInEdgeCount*0.75; //0.5~0.8이하로 입력할것
								 DistDevRatio = 0.15; //0.1~0.25 이하로 입력할것
								 CircleFit->OnRansac(A2CirInPoint,A2CirInEdgeCount,SampleSize,DistDevRatio,&ACircleFit2Center,&ACirFitDiameter2);
								 // 									 LogUnit.SetLog("RightTop_Mark_END");     


								 // Polygon 박리 검사 시퀀스(RightTop)
								 if(!IsMarkBtm && BrokenThresHold!=0){
									 // 										 RotateBrokenImg.SetSize(RotateImg.GetWidth(), RotateImg.GetHeight());
									 // 										 EasyImage::Oper(EArithmeticLogicOperation_Copy,&RotateImg,&RotateBrokenImg);
									 // 										 EasyImage::Threshold(&RotateImg,&RotateBrokenImg, BrokenThresHold);
									 Edge->GImage = &RotateBrokenImg;
									 Edge->SetEdgeType(0);

									 int DvCnt =0, DataCount=0;
									 double deg =0.0f; 
									 TFPoint Target(0.0f, 0.0f);

									 if(GrindMarkInCnt>GrindMarkOutCnt){
										 DvCnt = GrindMarkInCnt - GrindMarkOutCnt;
										 for(int k=0; k<A2CirOutEdgeCount; k++){
											 deg =0.0f, Target.x =0.0f, Target.y =0.0f;
											 if(((k+DvCnt)<A2CirInEdgeCount) && A2CirInPoint[k+DvCnt].x>0  && A2CirInPoint[k+DvCnt].y>0){
												 deg = Math.GetDegree(A2CirOutPoint[k],A2CirInPoint[k+DvCnt]);

												 Target  = Math.OnFindPerpendicularPointXY(A2CirOutPoint[k],-dEdgeToTrapLineDis,dEdgeToTrapLineDis,deg);
												 Edge->OnExecute(A2CirOutPoint[k],Target); // 연마외곽라인에서 Target까지 White Point Search 
												 if(Edge->GetResultEdgePointCount()>0){
													 A2CircleData[DataCount].Dis =0.0f;
													 A2CircleData[DataCount].Dv  =0.0f;
													 A2CircleData[DataCount].P   = Edge->GetResultEdgePoint(0);
													 A2CircleData[DataCount].P.y = A2CircleData[DataCount].P.y - ImageHeight; // Frame기준 단위좌표로 변경함  
													 DataCount++;
												 }
											 }
										 }
										 A2CirInCrackCount = DataCount;
									 }
									 else if(GrindMarkInCnt<GrindMarkOutCnt)   {
										 DvCnt = GrindMarkOutCnt - GrindMarkInCnt;
										 for(int k=DvCnt; k<A2CirOutEdgeCount; k++){
											 deg =0.0f, Target.x =0.0f, Target.y =0.0f;
											 if(((k-DvCnt)<A2CirInEdgeCount) && A2CirInPoint[k-DvCnt].x>0  && A2CirInPoint[k-DvCnt].y>0 && k-DvCnt>=0){
												 deg = Math.GetDegree(A2CirOutPoint[k],A2CirInPoint[k-DvCnt]);

												 Target  = Math.OnFindPerpendicularPointXY(A2CirOutPoint[k],-dEdgeToTrapLineDis,dEdgeToTrapLineDis,deg);
												 Edge->OnExecute(A2CirOutPoint[k],Target); // 연마외곽라인에서 Target까지 White Point Search 
												 if(Edge->GetResultEdgePointCount()>0){
													 A2CircleData[DataCount].Dis =0.0f;
													 A2CircleData[DataCount].Dv  =0.0f;
													 A2CircleData[DataCount].P   = Edge->GetResultEdgePoint(0);
													 A2CircleData[DataCount].P.y = A2CircleData[DataCount].P.y - ImageHeight; // Frame기준 단위좌표로 변경함  
													 DataCount++;
												 }
											 }
										 }
										 A2CirInCrackCount = DataCount;
									 }
								 }
								 // 									 LogUnit.SetLog("CellID:%d, CamID:%d ==>RightTop_Polygon_END",CellId,CamId);     
							 }
							 else if(FInspectMode==Insp_Mark){
								 // 									 LogUnit.SetLog("RightTop_Mark_START");     

								 // 자재의 외곽라인 교차점 기준 CirCenter 설정함 
								 if(ASideCircleWidth!=0.0f && ASideCircleHeight!=0.0f)  A2CirCenter.x = FRTPoint.x - ASideCircleWidth;  A2CirCenter.y = FRTPoint.y + ASideCircleHeight;  

								 // Circle Fitting 진행시 공통으로 사용하는 설정값
								 // Circle Fitting 진행시 공통으로 사용하는 설정값
								 Circle->SetSamplingStep(1)                              ; // A2Circle Edge 간격 

								 //A1 In Circle EdgePoint Data 추출 
								 // TrackLine or GrindMark기준 선택하여 가공량 측정 시퀀스는 코딩하지 않음
								 if(A2CirCenter.x!=0 && A2CirCenter.y!=0){
									 // 										 RotateBinaryImg.Save("D:\\ROTATE_IMG\\RightTop_원본.bmp");

									 // A_Side Circle 검사전 Median 필터 적용 
									 TPoint P1(0,0),P2(0,0),P3(0,0),P4(0,0);
									 P1.x = (int)(FRTPoint.x-ASideCircleWidth   );    P1.y =(int)(FRTPoint.y-20            );    P2.x = (int)(FRTPoint.x+20);    P2.y = (int)(P1.y);
									 P3.x = (int)(P1.x)                          ;    P3.y =(int)(P1.y+ASideCircleHeight+20);    P4.x = (int)(P2.x         );    P4.y = (int)(P3.y);
									 // Median Filter 적용 
									 if(P1.x<=0    || P1.y<=0    || (P2.x - P1.x)<=0    || (P3.y - P1.y)<=0   ) return false;
									 if(P1.x>=ImgW || P1.y>=ImgH || (P2.x - P1.x)>=ImgW || (P3.y - P1.y)>=ImgH) return false;
									 FilterROI.SetSize(int(P2.x - P1.x),int(P3.y - P1.y) )                 ;
									 FilterROI.Attach(&RotateBinaryImg)                                    ;
									 FilterROI.SetPlacement(P1.x, P1.y, int(P2.x - P1.x), int(P3.y - P1.y));
									 LogUnit.SetLog(L"Px : %d, Py : %d, Width : %d, Height : %d => MedianFilter", P1.x, P1.y, int(P2.x - P1.x), int(P3.y - P1.y));
									 LogUnit.SetLog(L"P1.x : %d, P1.y : %d, P2.x : %d, P2.y : %d, P3.x : %d, P3.y : %d, P4.x : %d, P4.y : %d => MedianFilter", P1.x, P1.y, P2.x, P2.y, P3.x, P3.y, P4.x, P4.y);
									 EasyImage::Median(&FilterROI, &FilterROI)                             ;
									 // 										 RotateBinaryImg.Save("D:\\ROTATE_IMG\\RightTop_필터.bmp");


									 if(ECThresHold==0) Circle->GImage = &RotateImg      ; //Org Image 넘겨줌 
									 else               Circle->GImage = &RotateBinaryImg; //Binary Image 넘겨줌 

									 Circle->SetCenterXY(A2CirCenter.x , A2CirCenter.y)  ; // Circle Center 좌표설정 
									 // 									 A2Diameter = ((ASideCircleWidth*2)+((ASideCircleWidth-OutToTrackLineDis)*2))/2;
									 A2Diameter = (ASideCircleWidth*2);

									 Circle->SetDiameter(A2Diameter)             ;
									 Circle->SetTolerance(60.0f )                ; // A1Circle Tolerance 
									 Circle->SetCircleChoice(1)                  ; // 0:From Begin, 1:From End, 2:Largest Amplitude 
									 Circle->SetCircleIndex (1)                  ; // Circle EdgePoint Index 
									 Circle->SetAngle(270+CirAngleMargin)        ; // Cirlce Angle 
									 Circle->SetAmplitude(90-(2*CirAngleMargin)) ; // Circle Amplitude

									 // Circle InData EdgePoint 
									 //////////////////////////////////////////////////////////////////////////////////////////////////////
									 Circle->SetCircleType(2)                    ; // 0:Black to White, 1:White to Black 2: Both Black, White 
									 Circle->OnExecute()                         ;

									 // Circle In Data 기준 새로운 Circle Center 좌표 받아옴 
									 // Euresys Circle Fitting Center 
									 RealA2CirCenter.x = Circle->FCP.x;
									 RealA2CirCenter.y = Circle->FCP.y;
									 ACirDiameter2     = (Circle->Diameter)/2.0;

									 // Circle In Data취합 
									 OrgA2CirInEdgeCount = Circle->FCirclePointCount;
									 if(OrgA2CirInEdgeCount>0){
										 if(OrgA2CirInPoint!=NULL) delete[] OrgA2CirInPoint;
										 OrgA2CirInPoint = new TFPoint[OrgA2CirInEdgeCount];

										 for(int k=0; k<OrgA2CirInEdgeCount; k++){
											 if(k>MAX_CIRCLE_EDGEPOINT) break;
											 OrgA2CirInPoint[k].x = Circle->FCirclePoint[k].x;
											 OrgA2CirInPoint[k].y = Circle->FCirclePoint[k].y;
											 if(OrgA2CirInPoint[k].x==0.0f && OrgA2CirInPoint[k].y==0.0f) A2CirInEdgeCount++;
										 }
									 }
									 //////////////////////////////////////////////////////////////////////////////////////////////////////

									 // Circle Out Data 다시 검사  
									 //////////////////////////////////////////////////////////////////////////////////////////////////////
									 Circle->SetTolerance(60.0f )      ; // Circle Tolerance 
									 Circle->SetDiameter (A2Diameter)  ; // Circle Diameter 
									 Circle->SetCircleChoice(1)        ; // 0:From Begin, 1:From End, 2:Largest Amplitude 
									 Circle->SetCircleType(2)          ; // 0:Black to White, 1:White to Black 2: Both Black, White 
									 Circle->SetCircleIndex (0)        ; // Circle EdgePoint Index 

									 Circle->OnExecute()               ;

									 // Circle Out Data취합 
									 OrgA2CirOutEdgeCount = Circle->FCirclePointCount;
									 if(OrgA2CirOutEdgeCount>0){
										 if(OrgA2CirOutPoint!=NULL) delete[] OrgA2CirOutPoint;
										 OrgA2CirOutPoint = new TFPoint[OrgA2CirOutEdgeCount];

										 for(int k=0; k<OrgA2CirOutEdgeCount; k++){
											 if(k>MAX_CIRCLE_EDGEPOINT) break;
											 OrgA2CirOutPoint[k].x = Circle->FCirclePoint[k].x;
											 OrgA2CirOutPoint[k].y = Circle->FCirclePoint[k].y;
											 // BTM영역 Circle을 제외한 영역 Defect검사 목적에 좌표계산 
											 if(k==0                     ) {TopEdgePoint[2].x = OrgA2CirOutPoint[k].x; TopEdgePoint[2].y = OrgA2CirOutPoint[k].y;}
											 if(k==OrgA2CirOutEdgeCount-1) {TopEdgePoint[3].x = OrgA2CirOutPoint[k].x; TopEdgePoint[3].y = OrgA2CirOutPoint[k].y;}
											 if(OrgA2CirOutPoint[k].x==0.0f && OrgA2CirOutPoint[k].y==0.0f) A2CirOutEdgeCount++;
										 }
									 }
									 // A2Circle Grind_Width Calculate (연마량 계산)
									 if(IsMarkBtm){ // LTPS경우 가공량 계산 ==> 연마량 계산 
										 if(OrgA2CirOutEdgeCount!=0 && OrgA2CirInEdgeCount!=0){// MarkMode경우 가공량 검사를 먼저 진행 후 연마량 산출  
											 GrindMeaDis =0.0f, MinDis =10000.0f; A2GrindMarkCount=0;
											 if(GrindMarkPoint[20].x!=0.0f && GrindMarkPoint[20].y!=0.0f){  // GrindMark 찾았을경우 
												 for(int k=0; k<OrgA2CirOutEdgeCount; k++){
													 if(OrgA2CirOutPoint[k].x==0.0f || OrgA2CirOutPoint[k].y==0.0f) continue;
													 if(GrindMarkPoint[20].x ==0.0f || GrindMarkPoint[20].y  ==0.0f) continue;

													 GrindMeaDis = Math.GetLength(GrindMarkPoint[20], OrgA2CirOutPoint[k]);
													 if(GrindMeaDis<MinDis){
														 MinDis = GrindMeaDis;
														 A2GrindMarkCount = k;
													 }
												 }

												 // GrindMark기준 수직 포인트 주변값 Avg산출한다 ==>가공량 측정 
												 if(A2GrindMarkCount!=0 && A2GrindMarkCount>5){
													 CircleCount=0,TotalCirDis=0.0f,GrindMeaDis=0.0f;
													 for(int k=A2GrindMarkCount-5; k<A2GrindMarkCount+5; k++){
														 if(OrgA2CirOutPoint[k].x==0.0f || OrgA2CirOutPoint[k].y==0.0f) continue;

														 GrindMeaDis = Math.GetLength(GrindMarkPoint[20], OrgA2CirOutPoint[k]);
														 TotalCirDis+= GrindMeaDis;
														 CircleCount++;
													 }
													 if(TotalCirDis!=0.0f && CircleCount!=0){
														 A2CirGrindMea[2] = TotalCirDis/CircleCount;
													 }
												 }

												 // GrindMark기준 수직 평균값 연마량 측정 
												 if(A2GrindMarkCount!=0 && A2GrindMarkCount>5){
													 CircleCount=0,TotalCirDis=0.0f,GrindWidthDis=0.0f;
													 for(int k=A2GrindMarkCount-5; k<A2GrindMarkCount+5; k++){
														 if(OrgA2CirOutPoint[k].x==0.0f && OrgA2CirOutPoint[k].y==0.0f) continue;
														 if(OrgA2CirInPoint [k].x==0.0f && OrgA2CirInPoint [k].y==0.0f) continue;
														 GrindWidthDis = Math.GetLength(OrgA2CirInPoint[k], OrgA2CirOutPoint[k]);
														 TotalCirDis+=   GrindWidthDis;
														 CircleCount++;
													 }
													 if(TotalCirDis!=0.0f && CircleCount!=0){
														 A2CirGrindWd[2] = TotalCirDis/CircleCount;
													 }
												 }
											 }
											 else { // GrindMark 못 찾았을 경우 
												 for(int k=0; k<OrgA2CirOutEdgeCount; k++){
													 if(OrgA2CirOutPoint[k].x==0.0f || OrgA2CirOutPoint[k].y==0.0f) continue;

													 AGrindMarkRectPoint2.x = GrindMarkRect[20].left + (GrindMarkRect[20].right  - GrindMarkRect[20].left)/2; 
													 AGrindMarkRectPoint2.y = GrindMarkRect[20].top  + (GrindMarkRect[20].bottom - GrindMarkRect[20].top )/2; 

													 GrindMeaDis = Math.GetLength(AGrindMarkRectPoint2, OrgA2CirOutPoint[k]);
													 if(GrindMeaDis<MinDis){
														 MinDis = GrindMeaDis;
														 A2GrindMarkCount = k;
													 }
												 }
												 // GrindMark기준 수직 평균값 연마량 측정 
												 if(A2GrindMarkCount!=0 && A2GrindMarkCount>5 && (A2GrindMarkCount+5<OrgA2CirOutEdgeCount)){
													 CircleCount=0,TotalCirDis=0.0f,GrindWidthDis=0.0f;
													 for(int k=A2GrindMarkCount-5; k<A2GrindMarkCount+5; k++){
														 if(OrgA2CirOutPoint[k].x==0.0f && OrgA2CirOutPoint[k].y==0.0f) continue;
														 if(OrgA2CirInPoint [k].x==0.0f && OrgA2CirInPoint [k].y==0.0f) continue;
														 GrindWidthDis = Math.GetLength(OrgA2CirInPoint[k], OrgA2CirOutPoint[k]);
														 TotalCirDis+=   GrindWidthDis;
														 CircleCount++;
													 }
													 if(TotalCirDis!=0.0f && CircleCount!=0){
														 A2CirGrindWd[2] = TotalCirDis/CircleCount;
													 }
												 }
											 }
										 }
									 }
									 else     { // MarkMode ==> EnCap경우 연마량만 계산한다 
										 if(OrgA2CirInEdgeCount==OrgA2CirOutEdgeCount){
											 double OutDis=0.0f, InDis=0.0f, TotalGrindWidth=0.0f, AvgGrindWidth=0.0f;A2GrindWidthCount=0;
											 for(int k=0; k<OrgA2CirInEdgeCount; k++){
												 if(OrgA2CirOutPoint[k].x==0.0f && OrgA2CirOutPoint[k].y==0.0f){
													 OutDis =0.0f;
												 }
												 else {
													 OutDis = Math.GetLengthFrPointToPoint(A2CirCenter,OrgA2CirOutPoint[k]);
												 }

												 if(OrgA2CirInPoint[k].x==0.0f && OrgA2CirInPoint[k].y==0.0f){
													 InDis =0.0f;
												 }
												 else {
													 InDis = Math.GetLengthFrPointToPoint(A2CirCenter,OrgA2CirInPoint[k]);
												 }

												 // CircleFitting 진행시 실제 EdgePoint 데이터가 존재 할 경우만 포함하여 계산한다
												 if(OutDis!=0.0f && InDis!=0.0f){
													 TotalGrindWidth+=(OutDis - InDis);
													 A2GrindWidthCount++;
												 }
											 }
											 if(A2GrindWidthCount!=0){
												 AvgGrindWidth = (TotalGrindWidth/A2GrindWidthCount);
												 A2CirGrindWd[2] = AvgGrindWidth;
											 }
										 }
									 }

									 //////////////////////////////////////////////////////////////////////////////////////////////////////
									 // Org Circle데이터중 유호하지 않은 값을 제외한 실제 존재하는 데이터 기준으로 동적 메모리 생성함
									 // Circle Defect검사에 필요한 Edge데이터 값
									 int Count=0;
									 if(OrgA2CirInEdgeCount>0){ // A2 CircleInData
										 A2CirInEdgeCount = OrgA2CirInEdgeCount - A2CirInEdgeCount;
										 if(A2CirInEdgeCount>0){
											 if(A2CirInPoint!=NULL) delete[] A2CirInPoint;
											 A2CirInPoint = new TFPoint[A2CirInEdgeCount];

											 for(int k=0; k<OrgA2CirInEdgeCount; k++){
												 if(k>MAX_CIRCLE_EDGEPOINT) break;
												 if(OrgA2CirInPoint[k].x==0.0f && OrgA2CirInPoint[k].y==0.0f) continue;
												 A2CirInPoint[Count].x = OrgA2CirInPoint[k].x;
												 A2CirInPoint[Count].y = OrgA2CirInPoint[k].y;
												 Count++;
											 }
										 }
										 // Circle 원본 데이터 메모리 삭제
										 if(OrgA2CirInPoint!=NULL) delete[] OrgA2CirInPoint;
									 }
									 // FAVION Circle Fitting 결과물 
									 SampleSize = A2CirInEdgeCount*0.75; //0.5~0.8이하로 입력할것
									 DistDevRatio = 0.15; //0.1~0.25 이하로 입력할것
									 CircleFit->OnRansac(A2CirInPoint,A2CirInEdgeCount,SampleSize,DistDevRatio,&ACircleFit2Center,&ACirFitDiameter2);

									 if(OrgA2CirOutEdgeCount>0){// A1 CircleOutData 
										 A2CirOutEdgeCount = OrgA2CirOutEdgeCount - A2CirOutEdgeCount;
										 Count =0;
										 if(A2CirOutEdgeCount>0){
											 if(A2CirOutPoint!=NULL) delete[] A2CirOutPoint;
											 A2CirOutPoint = new TFPoint[A2CirOutEdgeCount];

											 for(int k=0; k<OrgA2CirOutEdgeCount; k++){
												 if(k>MAX_CIRCLE_EDGEPOINT) break;
												 if(OrgA2CirOutPoint[k].x==0.0f && OrgA2CirOutPoint[k].y==0.0f) continue;
												 A2CirOutPoint[Count].x = OrgA2CirOutPoint[k].x;
												 A2CirOutPoint[Count].y = OrgA2CirOutPoint[k].y;
												 Count++;
											 }
										 }
										 // Circle 원본 데이터 메모리 삭제
										 if(OrgA2CirOutPoint!=NULL) delete[] OrgA2CirOutPoint;
									 }
									 // Circle 영역 꽃박리, 원형박리 검출 목적 시퀀스(EnCap)
									 // 정식 명칭은 몰라서.....일단 Crack으로 정함 
									 if(!IsMarkBtm && BrokenThresHold!=0){
										 if(ACirFitDiameter2!=0.0f && ACircleFit2Center.x!=0.0f && ACircleFit2Center.y!=0.0f){ // FAVION Circle Fitting 성공시 박리검사 진행 
											 Circle->GImage = &RotateBrokenImg;                                             //Binary Image 넘겨줌 

											 Circle->SetCenterXY(ACircleFit2Center.x,ACircleFit2Center.y);
											 // 											 Circle->SetTolerance(CirCrackMargin)                      ; // Circle Tolerance 
											 // 											 Circle->SetDiameter ((ACirFitDiameter2-CirCrackMargin)*2) ; // Circle Diameter 
											 Circle->SetTolerance((dEdgeToTrapLineDis/2)-CirOffsetMargin); // Circle Tolerance 
											 Circle->SetDiameter ((ACirFitDiameter2-(dEdgeToTrapLineDis/2))*2) ; // Circle Diameter 
											 Circle->SetCircleChoice(0)                                ; // 0:From Begin, 1:From End, 2:Largest Amplitude 
											 Circle->SetCircleType  (0)                                ; // 0:Black to White, 1:White to Black 2: Both Black, White 
											 Circle->SetCircleIndex (0)                                ; // Circle EdgePoint Index 
											 Circle->SetAngle(325)                                     ; // 패턴으로 인해서 오버킬 발생...범위를 좁혀준다 
											 Circle->SetAmplitude(25)                                  ; // 패턴으로 인해서 오버킬 발생...범위를 좁혀준다 
											 Circle->OnExecute(true)                                   ;
											 CrackACirDiameter2 = (ACirFitDiameter2-(dEdgeToTrapLineDis/2))+((dEdgeToTrapLineDis/2)-CirOffsetMargin);

											 A2CirInCrackCount = Circle->FCirclePointCount;

											 if(A2CirInCrackCount>0){
												 if(A2CirInCrackPoint!=NULL) delete[] A2CirInCrackPoint;
												 A2CirInCrackPoint = new TFPoint[A2CirInCrackCount];

												 for(int k=0; k<A2CirInCrackCount; k++){
													 if(k>MAX_CIRCLE_EDGEPOINT) break;
													 A2CirInCrackPoint[k].x = Circle->FCirclePoint[k].x;
													 A2CirInCrackPoint[k].y = Circle->FCirclePoint[k].y;
												 }
											 }
										 }
									 }
								 }
								 LogUnit.SetLog(L"RightTop_Mark_END");     
							 }
						 }
						 LogUnit.SetLog(L"shRectH_Rotate_RightTop_End");     
					 }
				 }

				 if(FShape==shRectC ){ // NOTCH ROTATE IMAGE 
					 // Circle 검사에 필요한 로컬변수 초기화 
					 const int GrindMarkRange =40;    const int GrindMarkLength=80;
					 int OrgC1CirInEdgeCount=0;		  int OrgC1CirOutEdgeCount=0;	    int OrgC1CirStandEdgeCount=0;
					 int OrgC2CirInEdgeCount=0;		  int OrgC2CirOutEdgeCount=0;	    int OrgC2CirStandEdgeCount=0;
					 int OrgC3CirInEdgeCount=0;		  int OrgC3CirOutEdgeCount=0;	    int OrgC3CirStandEdgeCount=0;
					 int OrgC4CirInEdgeCount=0;		  int OrgC4CirOutEdgeCount=0;	    int OrgC4CirStandEdgeCount=0;
					 int OrgC5CirInEdgeCount=0;		  int OrgC5CirOutEdgeCount=0;	    int OrgC5CirStandEdgeCount=0;
					 int OrgC6CirInEdgeCount=0;		  int OrgC6CirOutEdgeCount=0;	    int OrgC6CirStandEdgeCount=0;

					 int OrgBtm1InEdgeCount =0;		  int OrgBtm3InEdgeCount =0;	    int OrgBtm5InEdgeCount =0;
					 int OrgBtm1OutEdgeCount=0;		  int OrgBtm3OutEdgeCount=0;	    int OrgBtm5OutEdgeCount=0;
					 int Btm1GrindMarkCount =0;       int Btm3GrindMarkCount =0;        int Btm5GrindMarkCount =0;

					 int C1GrindWidthCount=0;		  int C1GrindMeasureCount=0;
					 int C2GrindWidthCount=0;		  int C2GrindMeasureCount=0;
					 int C3GrindWidthCount=0;		  int C3GrindMeasureCount=0;
					 int C4GrindWidthCount=0;		  int C4GrindMeasureCount=0;
					 int C5GrindWidthCount=0;		  int C5GrindMeasureCount=0;
					 int C6GrindWidthCount=0;		  int C6GrindMeasureCount=0;

					 int C1GrindMarkCount =0;         int C2GrindMarkCount =0;
					 int C3GrindMarkCount =0;         int C4GrindMarkCount =0;
					 int C5GrindMarkCount =0;         int C6GrindMarkCount =0;

					 // Circle Diameter 
					 int C1Diameter       =0;         int C2Diameter         =0; 
					 int C3Diameter       =0;         int C4Diameter         =0; 
					 int C5Diameter       =0;         int C6Diameter         =0; 

					 // Circle In Coordinate Data     // Circle Out Coordinate Data     // Circle(Grind_Measure) Stand Edge Coordinate Data
					 TFPoint *OrgC1CirInPoint=NULL;	  TFPoint *OrgC1CirOutPoint=NULL;	TFPoint *OrgC1CirStandPoint=NULL;
					 TFPoint *OrgC2CirInPoint=NULL;	  TFPoint *OrgC2CirOutPoint=NULL;	TFPoint *OrgC2CirStandPoint=NULL;
					 TFPoint *OrgC3CirInPoint=NULL;	  TFPoint *OrgC3CirOutPoint=NULL;	TFPoint *OrgC3CirStandPoint=NULL;
					 TFPoint *OrgC4CirInPoint=NULL;	  TFPoint *OrgC4CirOutPoint=NULL;	TFPoint *OrgC4CirStandPoint=NULL;
					 TFPoint *OrgC5CirInPoint=NULL;	  TFPoint *OrgC5CirOutPoint=NULL;	TFPoint *OrgC5CirStandPoint=NULL;
					 TFPoint *OrgC6CirInPoint=NULL;	  TFPoint *OrgC6CirOutPoint=NULL;	TFPoint *OrgC6CirStandPoint=NULL;

					 // Notch 직선영영 데이터 취합에 필요함 
					 TFPoint *OrgBtm1InPoint =NULL;	  TFPoint *OrgBtm3InPoint =NULL;	TFPoint *OrgBtm5InPoint =NULL;
					 TFPoint *OrgBtm1OutPoint=NULL;	  TFPoint *OrgBtm3OutPoint=NULL;	TFPoint *OrgBtm5OutPoint=NULL;

					 TFPoint PreC1CirStandPoint[1];   TFPoint PreC4CirStandPoint[1];
					 TFPoint PreC2CirStandPoint[1];	  TFPoint PreC5CirStandPoint[1];
					 TFPoint PreC3CirStandPoint[1];	  TFPoint PreC6CirStandPoint[1];

					 // Polygon Value 
					 int PixelCnt =0;
					 CRect PolyRect[6];
					 if(FInspectMode==Insp_Polygon){
						 for(int k=0; k<6; k++){
							 PolyRect[k].left   =0;
							 PolyRect[k].top    =0;
							 PolyRect[k].right  =0;
							 PolyRect[k].bottom =0;
						 }
					 }
					 // Image Roate 전 원본이미지 기준 교차점 산출 
					 FLBPoint = Math.OnIntersect(Line[0].FP0 , Line[0].FP1 , Line[3].FP0, Line[3].FP1);
					 FRBPoint = Math.OnIntersect(Line[2].FP0 , Line[2].FP1 , Line[3].FP0, Line[3].FP1);


					 if(FLBPoint.x!=0 && FLBPoint.y!=0 && FRBPoint.x!=0 && FRBPoint.y!=0) ImgDegree = -(Math.GetDegree(FLBPoint.x , FLBPoint.y, FRBPoint.x, FRBPoint.y));

					 // Left_Mark와 Right_Mark각도가 정확히 0도인경우 발생하여 조건을 바꿈
					 // 						 if(ImgDegree!=0.0f){ // 원본이미지 교차점 기준 Align틀어졌을경우 이미지 회전 
					 if(FLBPoint.x!=0 && FLBPoint.y!=0 && FRBPoint.x!=0 && FRBPoint.y!=0){ // 원본이미지 교차점 기준 Align틀어졌을경우 이미지 회전 
						 // 원본 RotateImg Size 설정 및 복사 
						 LogUnit.SetLog(L"shRectC_RotateImg_Start");     
						 RotateImg.SetSize(GImage->GetWidth(), GImage->GetHeight());
						 EasyImage::Oper(EArithmeticLogicOperation_Copy,GImage,&RotateImg);

						 // 원본 복사하여 이미지 회전 
						 EasyImage::ScaleRotate(GImage, (float)ImgW/2, (float)ImgH/2, (float)ImgW/2, (float)ImgH/2, 1.0f, 1.0f, ImgDegree, &RotateImg, 4);
						 CenterPoint.x = ImgW/2;
						 CenterPoint.y = ImgH/2;

						 // Binary RotateImg Size 설정 및 복사 
						 RotateBinaryImg.SetSize(RotateImg.GetWidth(), RotateImg.GetHeight());
						 EasyImage::Oper(EArithmeticLogicOperation_Copy,&RotateImg,&RotateBinaryImg);
						 // 							 RotateBinaryImg.Save("D:\\ROTATE_IMG\\RotateImg_CUP_원본.bmp");

						 // Circle Grind In EdgePoint 검출목적 이미지 
						 RotateGrindInBinaryImg.SetSize(RotateImg.GetWidth(), RotateImg.GetHeight());
						 EasyImage::Oper(EArithmeticLogicOperation_Copy,&RotateImg,&RotateGrindInBinaryImg);

						 // Grind Measure Corner, Circle 검사 목적 
						 RotateGrindBinaryImg.SetSize(RotateImg.GetWidth(), RotateImg.GetHeight());
						 EasyImage::Oper(EArithmeticLogicOperation_Copy,&RotateImg,&RotateGrindBinaryImg);
						 //							 RotateImg.Save("D:\\ROTATE_IMG\\RotateImg회전_CUP.bmp");
						 LogUnit.SetLog(L"shRectC_RotateImg_End");    

						 if(FLeftWall){ // shRectC Image Rotate Sequence  
							 EasyImage::Threshold(&RotateImg,&RotateBinaryImg, LeftEdgeThresHold);
							 if(LeftEdgeThresHold==0) {SingleLine->GImage = &RotateImg      ;  SingleLine->FThreshold =5 ;}
							 else                     {SingleLine->GImage = &RotateBinaryImg;  SingleLine->FThreshold =10;}


							 SingleLine->IRoi->SetOrgX  (IRoi->GetOrgX()          );
							 SingleLine->IRoi->SetOrgY  (IRoi->GetOrgY()          );
							 SingleLine->IRoi->SetWidth (IRoi->GetWidth()         );
							 // ChamberCut VS Circle VS Rect경우에 따라서 Left영역 Fitting구간 높이가 달라짐 
							 if(IsCornerBtm) SingleLine->IRoi->SetHeight(FEndLine-LBCornerHeight   );
							 else            SingleLine->IRoi->SetHeight(FEndLine-CSideCircleHeight);

							 SingleLine->SetIncrement(5 );

							 SingleLine->SetOrientation(orWest);

							 SingleLine->SetFindLineId(0);
							 // 							 SingleLine->SetEdgeType(0);  //Black To White  

							 // TEST 
							 if(IsMarkBtm) SingleLine->SetEdgeType(0); // Black to White 
							 else          SingleLine->SetEdgeType(1); // White to Black  

							 SingleLine->OnExecute();
							 Line[0].FP0 = SingleLine->GetResultP0();
							 Line[0].FP1 = SingleLine->GetResultP1();

							 if((fabs(Line[0].FP0.x - Line[0].FP1.x)>2) && (Line[0].FP1.x >Line[0].FP0.x)) Line[0].FP1.x = Line[0].FP0.x;

							 // Btm,Top 상관없이 첫번째
							 LeftOutLine[0].FP0.x = Line[0].FP0.x;
							 LeftOutLine[0].FP0.y = Line[0].FP0.y;
							 LeftOutLine[0].FP1.x = Line[0].FP1.x;
							 LeftOutLine[0].FP1.y = Line[0].FP1.y;

							 if(fabs(LeftOutLine[0].FP0.x - LeftOutLine[0].FP1.x)>=0.5){
								 LeftOutLine[0].FP0.x = (LeftOutLine[0].FP0.x+LeftOutLine[0].FP1.x)/2.0;
								 LeftOutLine[0].FP1.x = (LeftOutLine[0].FP0.x+LeftOutLine[0].FP1.x)/2.0;
							 }

							 // LeftOutLine....make OutLine Data 
							 // 현재의 데이터를 넘겨준다 
							 // 검사중 기준라인을 찾지 못할경우 이전데이터 넘겨줘서 기준라인 생성함 
							 if(LeftOutLine[0].FP0.x!=0.0f && LeftOutLine[0].FP0.y!=0.0f && LeftOutLine[0].FP1.x!=0.0f && LeftOutLine[0].FP1.y!=0.0f){
								 PreLeftOutLine[0].FP0.x = LeftOutLine[0].FP0.x;    PreLeftOutLine[0].FP1.x = LeftOutLine[0].FP1.x;       
								 PreLeftOutLine[0].FP0.y = LeftOutLine[0].FP0.y;    PreLeftOutLine[0].FP1.y = LeftOutLine[0].FP1.y;       
							 } // 셀의 상단 시작부터 Broken 발생으로 데이터가 없는경우 
							 else if(LeftOutLine[0].FP0.x==0.0f || LeftOutLine[0].FP0.y==0.0f || LeftOutLine[0].FP1.x==0.0f || LeftOutLine[0].FP1.y==0.0f){
								 if(PreLeftOutLine[0].FP0.x==0.0f && PreLeftOutLine[0].FP0.y==0.0f && PreLeftOutLine[0].FP1.x==0.0f && PreLeftOutLine[0].FP1.y==0.0f){// 시작부분 Broken발생으로 데이터가 없는경우 
									 // Mark좌표를 기준으로 라인좌표값을 다시 설정함 
									 ROI_H = IRoi->GetHeight();
									 LeftOutLine[0].FP0.x = Line[0].FP0.x;    LeftOutLine[0].FP0.y = 0.0f        ;
									 LeftOutLine[0].FP1.x = Line[0].FP1.x;    LeftOutLine[0].FP1.y = (float)ROI_H;

									 //Line 데이터를 PreLine에 넘겨준다 
									 PreLeftOutLine[0].FP0.x = LeftOutLine[0].FP0.x;    PreLeftOutLine[0].FP1.x = LeftOutLine[0].FP1.x;       
									 PreLeftOutLine[0].FP0.y = LeftOutLine[0].FP0.y;    PreLeftOutLine[0].FP1.y = LeftOutLine[0].FP1.y;       
								 }
								 else { // 중간부분 Broken발생으로 데이터가 없는경우 
									 // PreLine 데이터를 넘겨줌 
									 LeftOutLine[0].FP0.x = PreLeftOutLine[0].FP0.x;  LeftOutLine[0].FP1.x = PreLeftOutLine[0].FP1.x;  
									 LeftOutLine[0].FP0.y = PreLeftOutLine[0].FP0.y;  LeftOutLine[0].FP1.y = PreLeftOutLine[0].FP1.y;  
								 }
							 }

							 if(IsAllGrind){ 
								 if(IsMarkBtm){ //LeftInLine, LeftTrackLine Search, Data생성 
									 // LeftInLine Search Start 
									 EasyImage::Threshold(&RotateImg,&RotateBinaryImg, LeftEdgeThresHold);
									 if(LeftEdgeThresHold==0) {SingleLine->GImage = &RotateImg      ;  SingleLine->FThreshold =5 ;}
									 else                     {SingleLine->GImage = &RotateBinaryImg;  SingleLine->FThreshold =10;}

									 // 영역설정 
									 if(fabs(LeftOutLine[0].FP0.x - LeftOutLine[0].FP1.x) > 3){
										 LSP.x = (LeftOutLine[0].FP0.x + LeftOutLine[0].FP1.x)/2;
										 LSP.y = 0.0f;
									 }
									 else {
										 LSP = Math.OnIntersect(LeftOutLine[0].FP0, LeftOutLine[0].FP1, LT, RT);
									 }

									 SingleLine->IRoi->SetOrgX  ((int)LSP.x+3 );
									 SingleLine->IRoi->SetOrgY  (0            );
									 SingleLine->IRoi->SetWidth (100          );
									 SingleLine->IRoi->SetHeight(ImgH         );
									 SingleLine->SetIncrement(5 );

									 if(((LSP.x+3)<=0) || ImgH<=0) return false;

									 // 									 if(IRoi->GetHeight()<300) SingleLine->SetIncrement(5 );
									 // 									 else                      SingleLine->SetIncrement(10);

									 // 연마량 측정 OutLine
									 SingleLine->SetFindLineId(0);
									 SingleLine->SetOrientation(orWest);
									 SingleLine->SetEdgeType(0); // Black to White 
									 SingleLine->OnExecute();
									 LeftInLine[0].FP0 = SingleLine->GetResultP0();
									 LeftInLine[0].FP1 = SingleLine->GetResultP1();

									 SingleLine->SetEdgeType(2); // Line Search Org 

									 // LeftInLine None....make InLine Data 
									 // 현재의 데이터를 넘겨준다 
									 if(LeftInLine[0].FP0.x!=0.0f && LeftInLine[0].FP0.y!=0.0f && LeftInLine[0].FP1.x!=0.0f && LeftInLine[0].FP1.y!=0.0f){
										 PreLeftInLine[0].FP0.x = LeftInLine[0].FP0.x;    PreLeftInLine[0].FP1.x = LeftInLine[0].FP1.x;       
										 PreLeftInLine[0].FP0.y = LeftInLine[0].FP0.y;    PreLeftInLine[0].FP1.y = LeftInLine[0].FP1.y;       
									 }
									 else if(LeftInLine[0].FP0.x==0.0f || LeftInLine[0].FP0.y==0.0f || LeftInLine[0].FP1.x==0.0f || LeftInLine[0].FP1.y==0.0f){
										 if(PreLeftInLine[0].FP0.x==0.0f && PreLeftInLine[0].FP0.y==0.0f && PreLeftInLine[0].FP1.x==0.0f && PreLeftInLine[0].FP1.y==0.0f){// 시작부분 Broken발생으로 데이터가 없는경우 
											 // Mark좌표를 기준으로 라인좌표값을 다시 설정함 
											 ROI_H = IRoi->GetHeight();
											 ROI_L = IRoi->GetOrgX()  ;
											 LeftInLine[0].FP0.x = ROI_L;   LeftInLine[0].FP0.y = 0.0f        ;
											 LeftInLine[0].FP1.x = ROI_L;   LeftInLine[0].FP1.y = (float)ROI_H;

											 //Line 데이터를 PreLine에 넘겨준다 
											 PreLeftInLine[0].FP0.x = LeftInLine[0].FP0.x;    PreLeftInLine[0].FP1.x = LeftInLine[0].FP1.x;       
											 PreLeftInLine[0].FP0.y = LeftInLine[0].FP0.y;    PreLeftInLine[0].FP1.y = LeftInLine[0].FP1.y;       
										 }
										 else {                                                                                                    // 중간부분 Broken발생으로 데이터가 없는경우 
											 // PreLine 데이터를 넘겨줌 
											 LeftInLine[0].FP0.x = PreLeftInLine[0].FP0.x;  LeftInLine[0].FP1.x = PreLeftInLine[0].FP1.x;  
											 LeftInLine[0].FP0.y = PreLeftInLine[0].FP0.y;  LeftInLine[0].FP1.y = PreLeftInLine[0].FP1.y;  
										 }
									 }
									 // NOTCH CELL Btm 검사에서만 연마폭 측정함 
									 Left_Grind_Width =(float)(Math.GetLengthFrLineToPoint (LeftOutLine[0].FP0,LeftOutLine[0].FP1, LeftInLine[0].FP0 ));
									 ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////


									 // LeftTrackLine Search Start 
									 EasyImage::Threshold(&RotateImg,&RotateBinaryImg, CirGrindMeaThresHold);

									 // LeftInLine기준 LeftTrackLine 검출  
									 if(CirGrindMeaThresHold==0) {SingleLine->GImage = &RotateImg      ;  SingleLine->FThreshold =5 ;}
									 else                        {SingleLine->GImage = &RotateBinaryImg;  SingleLine->FThreshold =10;}

									 // 영역설정 
									 if(fabs(LeftInLine[0].FP0.x - LeftInLine[0].FP1.x) > 3){
										 LSP.x = (LeftInLine[0].FP0.x + LeftInLine[0].FP1.x)/2;
										 LSP.y = 0.0f;
									 }
									 else {
										 LSP = Math.OnIntersect(LeftInLine[0].FP0, LeftInLine[0].FP1, LT, RT);
									 }

									 SingleLine->IRoi->SetOrgX  ((int)LSP.x+3 );
									 SingleLine->IRoi->SetOrgY  (0            );
									 SingleLine->IRoi->SetWidth (100          );
									 SingleLine->IRoi->SetHeight(ImgH         );
									 SingleLine->SetIncrement(5 );

									 if(((LSP.x+3)<=0) || ImgH<=0) return false;

									 // 									 if(IRoi->GetHeight()<300) SingleLine->SetIncrement(5 );
									 // 									 else                      SingleLine->SetIncrement(10);

									 // Left Track Line Search 
									 SingleLine->SetFindLineId(0);
									 SingleLine->SetOrientation(orWest);
									 SingleLine->SetEdgeType(1); // White To Black  
									 SingleLine->OnExecute();
									 LeftTrackLine[0].FP0 = SingleLine->GetResultP0();
									 LeftTrackLine[0].FP1 = SingleLine->GetResultP1();

									 SingleLine->SetEdgeType(2); // Line Search Type Normal 

									 // LeftTrackLine....make OutLine Data 
									 // 현재의 데이터를 넘겨준다 
									 // 검사중 기준라인을 찾지 못할경우 이전데이터 넘겨줘서 기준라인 생성함 
									 if(LeftTrackLine[0].FP0.x!=0.0f && LeftTrackLine[0].FP0.y!=0.0f && LeftTrackLine[0].FP1.x!=0.0f && LeftTrackLine[0].FP1.y!=0.0f){
										 PreLeftTrackLine[0].FP0.x = LeftTrackLine[0].FP0.x;    PreLeftTrackLine[0].FP1.x = LeftTrackLine[0].FP1.x;       
										 PreLeftTrackLine[0].FP0.y = LeftTrackLine[0].FP0.y;    PreLeftTrackLine[0].FP1.y = LeftTrackLine[0].FP1.y;       
									 } // 셀의 상단 시작부터 Broken 발생으로 데이터가 없는경우 
									 else if(LeftTrackLine[0].FP0.x==0.0f || LeftTrackLine[0].FP0.y==0.0f || LeftTrackLine[0].FP1.x==0.0f || LeftTrackLine[0].FP1.y==0.0f){
										 if(PreLeftTrackLine[0].FP0.x==0.0f && PreLeftTrackLine[0].FP0.y==0.0f && PreLeftTrackLine[0].FP1.x==0.0f && PreLeftTrackLine[0].FP1.y==0.0f){// 시작부분 Broken발생으로 데이터가 없는경우 
											 // Mark좌표를 기준으로 라인좌표값을 다시 설정함 
											 ROI_H = IRoi->GetHeight();
											 ROI_L = IRoi->GetOrgX()  ;
											 LeftTrackLine[0].FP0.x = ROI_L;    LeftTrackLine[0].FP0.y = 0.0f        ;
											 LeftTrackLine[0].FP1.x = ROI_L;    LeftTrackLine[0].FP1.y = (float)ROI_H;

											 //LeftTrackLine 데이터를 PreLeftTrackLine에 넘겨준다 
											 PreLeftTrackLine[0].FP0.x = LeftTrackLine[0].FP0.x;    PreLeftTrackLine[0].FP1.x = LeftTrackLine[0].FP1.x;       
											 PreLeftTrackLine[0].FP0.y = LeftTrackLine[0].FP0.y;    PreLeftTrackLine[0].FP1.y = LeftTrackLine[0].FP1.y;       
										 }
										 else { // 중간부분 Broken발생으로 데이터가 없는경우 
											 // PreLeftTrackLine 데이터를 넘겨줌 
											 LeftTrackLine[0].FP0.x = PreLeftTrackLine[0].FP0.x;  LeftTrackLine[0].FP1.x = PreLeftTrackLine[0].FP1.x;  
											 LeftTrackLine[0].FP0.y = PreLeftTrackLine[0].FP0.y;  LeftTrackLine[0].FP1.y = PreLeftTrackLine[0].FP1.y;  
										 }
									 }
									 // NOTCH CELL Btm 검사에서만 연마폭 측정함 
									 Left_Grind_Mea =(float)(Math.GetLengthFrLineToPoint (LeftOutLine[0].FP0,LeftOutLine[0].FP1, LeftTrackLine[0].FP0 ));

									 // 마크라인에서 부터 LeftTrackLine 까지 거리 산출 
									 // LeftTrackLine Data 존재할 경우 거리 측정함 
									 if(LeftTrackLine[0].FP0.x!=0.0f && LeftTrackLine[0].FP0.y!=0.0f && LeftTrackLine[0].FP1.x!=0.0f && LeftTrackLine[0].FP1.y!=0.0f){
										 // 											 LeftTrackLine[0].FP0.y = LeftTrackLine[0].FP0.y + ImageHeight; //전체 이미지 기준 y좌표
										 // 											 LeftTrackLine[0].FP1.y = LeftTrackLine[0].FP1.y + ImageHeight; //전체 이미지 기준 y좌표
										 // 
										 // 											 MarkToTrackLineDis1 = Math.GetLengthFrLineToPoint(LeftMarkSta, LeftMarkEnd, LeftTrackLine[0].FP0);//Mark라인에서 TrackLine거리 
										 // 											 MarkToTrackLineDis2 = Math.GetLengthFrLineToPoint(LeftMarkSta, LeftMarkEnd, LeftTrackLine[0].FP1);//Mark라인에서 TrackLine거리 
										 // 
										 // 											 TotalLeftTrackDis  +=  (int)((MarkToTrackLineDis1 + MarkToTrackLineDis2)/2.0); //Mark라인에서 TrackLine거리 누적                   
										 // 											 LeftTrackLineCount++; //누적 카운트 증가
										 // 
										 // 											 // Org Data 
										 // 											 LeftTrackLine[0].FP0.y = LeftTrackLine[0].FP0.y - ImageHeight; //Frame 이미지 기준 y좌표 원복
										 // 											 LeftTrackLine[0].FP1.y = LeftTrackLine[0].FP1.y - ImageHeight; //Frame 이미지 기준 y좌표 원복 
									 }
									 ///////////////////////////////////////////////////////////////////////////////////////////////////////
								 }
								 else { //LeftInLine Search, LeftTrackLine Data Overlap 
									 // LeftInLine Search Start 
									 EasyImage::Threshold(&RotateImg,&RotateBinaryImg, LeftEdgeThresHold);
									 if(LeftEdgeThresHold==0) {SingleLine->GImage = &RotateImg      ;  SingleLine->FThreshold =5 ;}
									 else                     {SingleLine->GImage = &RotateBinaryImg;  SingleLine->FThreshold =10;}

									 // 영역설정 
									 if(fabs(LeftOutLine[0].FP0.x - LeftOutLine[0].FP1.x) > 3){
										 LSP.x = (LeftOutLine[0].FP0.x + LeftOutLine[0].FP1.x)/2;
										 LSP.y = 0.0f;
									 }
									 else {
										 LSP = Math.OnIntersect(LeftOutLine[0].FP0, LeftOutLine[0].FP1, LT, RT);
									 }

									 SingleLine->IRoi->SetOrgX  ((int)LSP.x+3 );
									 SingleLine->IRoi->SetOrgY  (0            );
									 SingleLine->IRoi->SetWidth (100          );
									 SingleLine->IRoi->SetHeight(ImgH         );
									 SingleLine->SetIncrement(5 );

									 if(((LSP.x+3)<=0) || ImgH<=0) return false;

									 // 									 if(IRoi->GetHeight()<300) SingleLine->SetIncrement(5 );
									 // 									 else                      SingleLine->SetIncrement(10);

									 // 연마량 측정 OutLine
									 SingleLine->SetFindLineId(0);
									 SingleLine->SetOrientation(orWest);
									 SingleLine->SetEdgeType(0); // Black to White 
									 SingleLine->OnExecute();
									 LeftInLine[0].FP0 = SingleLine->GetResultP0();
									 LeftInLine[0].FP1 = SingleLine->GetResultP1();

									 SingleLine->SetEdgeType(2); // Line Search Org 

									 // LeftInLine None....make InLine Data 
									 // 현재의 데이터를 넘겨준다 
									 if(LeftInLine[0].FP0.x!=0.0f && LeftInLine[0].FP0.y!=0.0f && LeftInLine[0].FP1.x!=0.0f && LeftInLine[0].FP1.y!=0.0f){
										 PreLeftInLine[0].FP0.x = LeftInLine[0].FP0.x;    PreLeftInLine[0].FP1.x = LeftInLine[0].FP1.x;       
										 PreLeftInLine[0].FP0.y = LeftInLine[0].FP0.y;    PreLeftInLine[0].FP1.y = LeftInLine[0].FP1.y;       
									 }
									 else if(LeftInLine[0].FP0.x==0.0f || LeftInLine[0].FP0.y==0.0f || LeftInLine[0].FP1.x==0.0f || LeftInLine[0].FP1.y==0.0f){
										 if(PreLeftInLine[0].FP0.x==0.0f && PreLeftInLine[0].FP0.y==0.0f && PreLeftInLine[0].FP1.x==0.0f && PreLeftInLine[0].FP1.y==0.0f){// 시작부분 Broken발생으로 데이터가 없는경우 
											 // Mark좌표를 기준으로 라인좌표값을 다시 설정함 
											 ROI_H = IRoi->GetHeight();
											 ROI_L = IRoi->GetOrgX()  ;
											 LeftInLine[0].FP0.x = ROI_L;   LeftInLine[0].FP0.y = 0.0f        ;
											 LeftInLine[0].FP1.x = ROI_L;   LeftInLine[0].FP1.y = (float)ROI_H;

											 //Line 데이터를 PreLine에 넘겨준다 
											 PreLeftInLine[0].FP0.x = LeftInLine[0].FP0.x;    PreLeftInLine[0].FP1.x = LeftInLine[0].FP1.x;       
											 PreLeftInLine[0].FP0.y = LeftInLine[0].FP0.y;    PreLeftInLine[0].FP1.y = LeftInLine[0].FP1.y;       
										 }
										 else {                                                                                                    // 중간부분 Broken발생으로 데이터가 없는경우 
											 // PreLine 데이터를 넘겨줌 
											 LeftInLine[0].FP0.x = PreLeftInLine[0].FP0.x;  LeftInLine[0].FP1.x = PreLeftInLine[0].FP1.x;  
											 LeftInLine[0].FP0.y = PreLeftInLine[0].FP0.y;  LeftInLine[0].FP1.y = PreLeftInLine[0].FP1.y;  
										 }
									 }
									 // NOTCH CELL Btm 검사에서만 연마폭 측정함 
									 Left_Grind_Width =(float)(Math.GetLengthFrLineToPoint (LeftOutLine[0].FP0,LeftOutLine[0].FP1, LeftInLine[0].FP0 ));
									 ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////

									 // LeftTrackLine Data Overlap 
									 if(AvgLeftTrackLineDis!=0){
										 // 											 LeftOutLine[0].FP0.y = LeftOutLine[0].FP0.y + ImageHeight; //전체 이미지 기준 y좌표
										 // 											 LeftOutLine[0].FP1.y = LeftOutLine[0].FP1.y + ImageHeight; //전체 이미지 기준 y좌표
										 // 
										 // 											 MarkToTrackLineDis1 = Math.GetLengthFrLineToPoint(LeftMarkSta, LeftMarkEnd, LeftOutLine[0].FP0);//Mark라인에서 OutLine까지 거리 
										 // 											 MarkToTrackLineDis2 = Math.GetLengthFrLineToPoint(LeftMarkSta, LeftMarkEnd, LeftOutLine[0].FP1);//Mark라인에서 OutLine까지 거리 
										 // 
										 // 											 if(MarkToTrackLineDis1>AvgLeftTrackLineDis) LeftTrackLine[0].FP0.x = LeftOutLine[0].FP0.x+(MarkToTrackLineDis1 - AvgLeftTrackLineDis);
										 // 											 if(MarkToTrackLineDis2>AvgLeftTrackLineDis) LeftTrackLine[0].FP1.x = LeftOutLine[0].FP1.x+(MarkToTrackLineDis2 - AvgLeftTrackLineDis);
										 // 
										 // 											 // LeftOutLine Data 원본 
										 // 											 LeftOutLine[0].FP0.y = LeftOutLine[0].FP0.y - ImageHeight; 
										 // 											 LeftOutLine[0].FP1.y = LeftOutLine[0].FP1.y - ImageHeight; 
										 // 
										 // 											 LeftTrackLine[0].FP0.y = LeftOutLine[0].FP0.y;
										 // 											 LeftTrackLine[0].FP1.y = LeftOutLine[0].FP1.y;
									 }
								 }
							 }
							 else {
								 if(IsMarkBtm){ //LeftTrackLine Search,Data생성
									 if(FInspectMode==Insp_Track){
										 // LeftTrackLine Search Start 
										 EasyImage::Threshold(&RotateImg,&RotateBinaryImg, CirGrindMeaThresHold);
										 if(CirGrindMeaThresHold==0) {SingleLine->GImage = &RotateImg      ;  SingleLine->FThreshold =5 ;}
										 else                        {SingleLine->GImage = &RotateBinaryImg;  SingleLine->FThreshold =10;}

										 // 영역설정 
										 if(fabs(LeftOutLine[0].FP0.x - LeftOutLine[0].FP1.x) > 3){
											 LSP.x = (LeftOutLine[0].FP0.x + LeftOutLine[0].FP1.x)/2;
											 LSP.y = 0.0f;
										 }
										 else {
											 LSP = Math.OnIntersect(LeftOutLine[0].FP0, LeftOutLine[0].FP1, LT, RT);
										 }

										 SingleLine->IRoi->SetOrgX  ((int)LSP.x+3             );
										 SingleLine->IRoi->SetOrgY  (0                        );
										 SingleLine->IRoi->SetWidth (100                      );
										 SingleLine->IRoi->SetHeight(FEndLine-CSideCircleHeight);
										 SingleLine->SetIncrement( 1);

										 if(((LSP.x+3)<=0) || ImgH<=0) return false;

										 // 									 if(IRoi->GetHeight()<300) SingleLine->SetIncrement(5 );
										 // 									 else                      SingleLine->SetIncrement(10);

										 // Left Track Line Search 
										 SingleLine->SetFindLineId(0);
										 SingleLine->SetOrientation(orWest);
										 SingleLine->SetEdgeType(1); // White To Black  
										 SingleLine->OnExecute();
										 LeftTrackLine[0].FP0 = SingleLine->GetResultP0();
										 LeftTrackLine[0].FP1 = SingleLine->GetResultP1();

										 if(fabs(LeftTrackLine[0].FP0.x - LeftTrackLine[0].FP1.x)>=0.5){
											 LeftTrackLine[0].FP0.x = (LeftTrackLine[0].FP0.x+LeftTrackLine[0].FP1.x)/2.0;
											 LeftTrackLine[0].FP1.x = (LeftTrackLine[0].FP0.x+LeftTrackLine[0].FP1.x)/2.0;
										 }

										 SingleLine->SetEdgeType(2); // Line Search Type Normal 

										 // LeftTrackLine....Make OutLine Data 
										 // 현재의 데이터를 넘겨준다 
										 // 검사중 기준라인을 찾지 못할경우 이전데이터 넘겨줘서 기준라인 생성함 
										 if(LeftTrackLine[0].FP0.x!=0.0f && LeftTrackLine[0].FP0.y!=0.0f && LeftTrackLine[0].FP1.x!=0.0f && LeftTrackLine[0].FP1.y!=0.0f){
											 PreLeftTrackLine[0].FP0.x = LeftTrackLine[0].FP0.x;    PreLeftTrackLine[0].FP1.x = LeftTrackLine[0].FP1.x;       
											 PreLeftTrackLine[0].FP0.y = LeftTrackLine[0].FP0.y;    PreLeftTrackLine[0].FP1.y = LeftTrackLine[0].FP1.y;       
										 } // 셀의 상단 시작부터 Broken 발생으로 데이터가 없는경우 
										 else if(LeftTrackLine[0].FP0.x==0.0f || LeftTrackLine[0].FP0.y==0.0f || LeftTrackLine[0].FP1.x==0.0f || LeftTrackLine[0].FP1.y==0.0f){
											 if(PreLeftTrackLine[0].FP0.x==0.0f && PreLeftTrackLine[0].FP0.y==0.0f && PreLeftTrackLine[0].FP1.x==0.0f && PreLeftTrackLine[0].FP1.y==0.0f){// 시작부분 Broken발생으로 데이터가 없는경우 
												 // Mark좌표를 기준으로 라인좌표값을 다시 설정함 
												 ROI_H = IRoi->GetHeight();
												 ROI_L = IRoi->GetOrgX()  ;
												 LeftTrackLine[0].FP0.x = ROI_L;    LeftTrackLine[0].FP0.y = 0.0f        ;
												 LeftTrackLine[0].FP1.x = ROI_L;    LeftTrackLine[0].FP1.y = (float)ROI_H;

												 //LeftTrackLine 데이터를 PreLeftTrackLine에 넘겨준다 
												 PreLeftTrackLine[0].FP0.x = LeftTrackLine[0].FP0.x;    PreLeftTrackLine[0].FP1.x = LeftTrackLine[0].FP1.x;       
												 PreLeftTrackLine[0].FP0.y = LeftTrackLine[0].FP0.y;    PreLeftTrackLine[0].FP1.y = LeftTrackLine[0].FP1.y;       
											 }
											 else { // 중간부분 Broken발생으로 데이터가 없는경우 
												 // PreLeftTrackLine 데이터를 넘겨줌 
												 LeftTrackLine[0].FP0.x = PreLeftTrackLine[0].FP0.x;  LeftTrackLine[0].FP1.x = PreLeftTrackLine[0].FP1.x;  
												 LeftTrackLine[0].FP0.y = PreLeftTrackLine[0].FP0.y;  LeftTrackLine[0].FP1.y = PreLeftTrackLine[0].FP1.y;  
											 }
										 }

										 // 마크라인에서 부터 LeftTrackLine 까지 거리 산출 
										 // LeftTrackLine Data 존재할 경우 거리 측정함 
										 // Image Rotate 있음 
										 // 외곽라인 기준 EnCap에 필요한 데이터 생성 
										 if(LeftTrackLine[0].FP0.x!=0.0f && LeftTrackLine[0].FP0.y!=0.0f && LeftTrackLine[0].FP1.x!=0.0f && LeftTrackLine[0].FP1.y!=0.0f){
											 if(LeftOutLine[0].FP0.x!=0.0f && LeftOutLine[0].FP0.y!=0.0f && LeftOutLine[0].FP1.x!=0.0f && LeftOutLine[0].FP1.y!=0.0f){
												 LeftToTrackLineDis1 = Math.GetLengthFrLineToPoint(LeftOutLine[0].FP0, LeftOutLine[0].FP1, LeftTrackLine[0].FP0);//외곽라인에서 TrackLine거리 
												 LeftToTrackLineDis2 = Math.GetLengthFrLineToPoint(LeftOutLine[0].FP0, LeftOutLine[0].FP1, LeftTrackLine[0].FP1);//외곽라인에서 TrackLine거리 

												 TotalLeftTrackDis  +=  (int)((LeftToTrackLineDis1 + LeftToTrackLineDis2)/2.0); //Mark라인에서 TrackLine거리 누적                   
												 LeftTrackLineCount++; //누적 카운트 증가
											 }
										 }
									 }
								 }
								 else {  //LeftTrackLine Data Overlap
									 // LeftTrackLine Data Overlap 
									 if(AvgLeftTrackLineDis!=0){
										 if(FInspectMode==Insp_Track){ // Mark기준 
											 if(LeftOutLine[0].FP0.x!=0.0f && LeftOutLine[0].FP0.y!=0.0f && LeftOutLine[0].FP1.x!=0.0f && LeftOutLine[0].FP1.y!=0.0f){
												 // TOP영역 LeftTrackLine x좌표 
												 LeftTrackLine[0].FP0.x = LeftOutLine[0].FP0.x+AvgLeftTrackLineDis;
												 LeftTrackLine[0].FP1.x = LeftOutLine[0].FP1.x+AvgLeftTrackLineDis;

												 // TOP영역 LeftTrackLine y좌표 
												 LeftTrackLine[0].FP0.y = LeftOutLine[0].FP0.y;
												 LeftTrackLine[0].FP1.y = LeftOutLine[0].FP1.y;
											 }
										 }
									 }
								 }
							 }
						 }
						 if(FRightWall){ // Image Rotate 적용 
							 EasyImage::Threshold(&RotateImg,&RotateBinaryImg, RightEdgeThresHold);
							 if(RightEdgeThresHold==0) {SingleLine->GImage = &RotateImg      ;  SingleLine->FThreshold =5 ;}
							 else                      {SingleLine->GImage = &RotateBinaryImg;  SingleLine->FThreshold =10;}

							 SingleLine->IRoi->SetOrgX  (IRoi->GetOrgX()           );
							 SingleLine->IRoi->SetOrgY  (IRoi->GetOrgY()           );
							 SingleLine->IRoi->SetWidth (IRoi->GetWidth()          );
							 // ChamberCut VS Circle VS Rect경우에 따라서 Left영역 Fitting구간 높이가 달라짐 
							 if(IsCornerBtm) SingleLine->IRoi->SetHeight(FEndLine-RBCornerHeight   );
							 else            SingleLine->IRoi->SetHeight(FEndLine-CSideCircleHeight);
							 SingleLine->SetIncrement(5 );

							 int OrgX  = IRoi->GetOrgX();
							 int OrgY  = IRoi->GetOrgX();
							 int Width = IRoi->GetOrgX();
							 int Height= IRoi->GetOrgX();

							 SingleLine->SetOrientation(orEast);
							 // 								 if(IRoi->GetHeight()<350) SingleLine->SetIncrement(5 );
							 // 								 else                      SingleLine->SetIncrement(10);

							 SingleLine->SetFindLineId(0);
							 SingleLine->FThreshold =10;
							 // 								 SingleLine->SetEdgeType(0);  //Black To White  

							 // TEST 
							 if(IsMarkBtm) SingleLine->SetEdgeType(0); // Black to White 
							 else          SingleLine->SetEdgeType(1); // White to Black  

							 SingleLine->OnExecute();
							 Line[2].FP0 = SingleLine->GetResultP0();
							 Line[2].FP1 = SingleLine->GetResultP1();

							 if((fabs(Line[2].FP0.x - Line[2].FP1.x)>2) && (Line[2].FP1.x <Line[2].FP0.x)) Line[2].FP1.x = Line[2].FP0.x;

							 // Btm,Top 상관없이 첫번째
							 RightOutLine[0].FP0.x = Line[2].FP0.x;
							 RightOutLine[0].FP0.y = Line[2].FP0.y;
							 RightOutLine[0].FP1.x = Line[2].FP1.x;
							 RightOutLine[0].FP1.y = Line[2].FP1.y;

							 if(fabs(RightOutLine[0].FP0.x - RightOutLine[0].FP1.x)>=0.5){
								 RightOutLine[0].FP0.x = (RightOutLine[0].FP0.x+RightOutLine[0].FP1.x)/2.0;
								 RightOutLine[0].FP1.x = (RightOutLine[0].FP0.x+RightOutLine[0].FP1.x)/2.0;
							 }

							 // LeftOutLine....make OutLine Data 
							 // 현재의 데이터를 넘겨준다 
							 // 검사중 기준라인을 찾지 못할경우 이전데이터 넘겨줘서 기준라인 생성함 
							 if(RightOutLine[0].FP0.x!=0.0f && RightOutLine[0].FP0.y!=0.0f && RightOutLine[0].FP1.x!=0.0f && RightOutLine[0].FP1.y!=0.0f){
								 PreRightOutLine[0].FP0.x = RightOutLine[0].FP0.x;    PreRightOutLine[0].FP1.x = RightOutLine[0].FP1.x;       
								 PreRightOutLine[0].FP0.y = RightOutLine[0].FP0.y;    PreRightOutLine[0].FP1.y = RightOutLine[0].FP1.y;       
							 } // 셀의 상단 시작부터 Broken 발생으로 데이터가 없는경우 
							 else if(RightOutLine[0].FP0.x==0.0f || RightOutLine[0].FP0.y==0.0f || RightOutLine[0].FP1.x==0.0f || RightOutLine[0].FP1.y==0.0f){
								 if(PreRightOutLine[0].FP0.x==0.0f && PreRightOutLine[0].FP0.y==0.0f && PreRightOutLine[0].FP1.x==0.0f && PreRightOutLine[0].FP1.y==0.0f){// 시작부분 Broken발생으로 데이터가 없는경우 
									 // Mark좌표를 기준으로 라인좌표값을 다시 설정함 
									 ROI_H = IRoi->GetHeight();
									 RightOutLine[0].FP0.x = Line[2].FP0.x;    RightOutLine[0].FP0.y = 0.0f        ;
									 RightOutLine[0].FP1.x = Line[2].FP1.x;    RightOutLine[0].FP1.y = (float)ROI_H;

									 //Line 데이터를 PreLine에 넘겨준다 
									 PreRightOutLine[0].FP0.x = RightOutLine[0].FP0.x;    PreRightOutLine[0].FP1.x = RightOutLine[0].FP1.x;       
									 PreRightOutLine[0].FP0.y = RightOutLine[0].FP0.y;    PreRightOutLine[0].FP1.y = RightOutLine[0].FP1.y;       
								 }
								 else { // 중간부분 Broken발생으로 데이터가 없는경우 
									 // PreLine 데이터를 넘겨줌 
									 RightOutLine[0].FP0.x = PreRightOutLine[0].FP0.x;  RightOutLine[0].FP1.x = PreRightOutLine[0].FP1.x;  
									 RightOutLine[0].FP0.y = PreRightOutLine[0].FP0.y;  RightOutLine[0].FP1.y = PreRightOutLine[0].FP1.y;  
								 }
							 }

							 if(IsAllGrind){ 
								 if(IsMarkBtm){ //RightInLine, RightTrackLine Search, Data생성 
									 // RightInLine Search Start 
									 EasyImage::Threshold(&RotateImg,&RotateBinaryImg, RightEdgeThresHold);
									 //RightOutLine기준 RightInLine 검출
									 if(RightEdgeThresHold==0) {SingleLine->GImage = &RotateImg      ;  SingleLine->FThreshold =5 ;}
									 else                      {SingleLine->GImage = &RotateBinaryImg;  SingleLine->FThreshold =10;}

									 // 영역설정 
									 if(fabs(RightOutLine[0].FP0.x - RightOutLine[0].FP1.x) > 3){
										 LSP.x = (RightOutLine[0].FP0.x + RightOutLine[0].FP1.x)/2;
										 LSP.y = 0.0f;
									 }
									 else {
										 LSP = Math.OnIntersect(RightOutLine[0].FP0, RightOutLine[0].FP1, LT, RT);
									 }

									 SingleLine->IRoi->SetOrgX  ((int)LSP.x-100);
									 SingleLine->IRoi->SetOrgY  (0             );
									 SingleLine->IRoi->SetWidth (97            );
									 SingleLine->IRoi->SetHeight(ImgH          );
									 SingleLine->SetIncrement(5 );

									 if(((LSP.x+3)<=0) || ImgH<=0) return false;

									 // 										 if(IRoi->GetHeight()<300) SingleLine->SetIncrement(5 );
									 // 										 else                      SingleLine->SetIncrement(10);

									 // 연마량 측정 OutLine
									 SingleLine->SetFindLineId(0);
									 SingleLine->SetOrientation(orEast);
									 SingleLine->SetEdgeType(0); // Black to White 
									 SingleLine->OnExecute();
									 RightInLine[0].FP0 = SingleLine->GetResultP0();
									 RightInLine[0].FP1 = SingleLine->GetResultP1();

									 SingleLine->SetEdgeType(2); // Line Search Org 

									 // RightInLine None....make InLine Data 
									 // 현재의 데이터를 넘겨준다 
									 if(RightInLine[0].FP0.x!=0.0f && RightInLine[0].FP0.y!=0.0f && RightInLine[0].FP1.x!=0.0f && RightInLine[0].FP1.y!=0.0f){
										 PreRightInLine[0].FP0.x = RightInLine[0].FP0.x;    PreRightInLine[0].FP1.x = RightInLine[0].FP1.x;       
										 PreRightInLine[0].FP0.y = RightInLine[0].FP0.y;    PreRightInLine[0].FP1.y = RightInLine[0].FP1.y;       
									 }
									 else if(RightInLine[0].FP0.x==0.0f || RightInLine[0].FP0.y==0.0f || RightInLine[0].FP1.x==0.0f || RightInLine[0].FP1.y==0.0f){
										 if(PreRightInLine[0].FP0.x==0.0f && PreRightInLine[0].FP0.y==0.0f && PreRightInLine[0].FP1.x==0.0f && PreRightInLine[0].FP1.y==0.0f){// 시작부분 Broken발생으로 데이터가 없는경우 
											 // Mark좌표를 기준으로 라인좌표값을 다시 설정함 
											 ROI_H = IRoi->GetHeight();
											 ROI_L = IRoi->GetOrgX()  ;
											 RightInLine[0].FP0.x = ROI_L;   RightInLine[0].FP0.y = 0.0f        ;
											 RightInLine[0].FP1.x = ROI_L;   RightInLine[0].FP1.y = (float)ROI_H;

											 //Line 데이터를 PreLine에 넘겨준다 
											 PreRightInLine[0].FP0.x = RightInLine[0].FP0.x;    PreRightInLine[0].FP1.x = RightInLine[0].FP1.x;       
											 PreRightInLine[0].FP0.y = RightInLine[0].FP0.y;    PreRightInLine[0].FP1.y = RightInLine[0].FP1.y;       
										 }
										 else {                                                                                                    // 중간부분 Broken발생으로 데이터가 없는경우 
											 // PreLine 데이터를 넘겨줌 
											 RightInLine[0].FP0.x = PreRightInLine[0].FP0.x;  RightInLine[0].FP1.x = PreRightInLine[0].FP1.x;  
											 RightInLine[0].FP0.y = PreRightInLine[0].FP0.y;  RightInLine[0].FP1.y = PreRightInLine[0].FP1.y;  
										 }
									 }
									 // NOTCH CELL Btm 검사에서만 연마폭 측정함 
									 Right_Grind_Width =(float)(Math.GetLengthFrLineToPoint (RightOutLine[0].FP0,RightOutLine[0].FP1, RightInLine[0].FP0 ));
									 /////////////////////////////////////////////////////////////////////////////////////////////


									 // Right TrackLine Search 
									 /////////////////////////////////////////////////////////////////////////////////////////////
									 // 									 BinaryImg.SetSize(GImage->GetWidth(), GImage->GetHeight());
									 // 									 EasyImage::Oper(EArithmeticLogicOperation_Copy,GImage,&BinaryImg);
									 EasyImage::Threshold(&RotateImg,&RotateBinaryImg, CirGrindMeaThresHold);
									 //RightInLine기준 RightTrackLine 검출
									 if(CirGrindMeaThresHold==0) {SingleLine->GImage = &RotateImg      ;  SingleLine->FThreshold =5 ;}
									 else                        {SingleLine->GImage = &RotateBinaryImg;  SingleLine->FThreshold =10;}


									 // 영역설정 
									 if(fabs(RightInLine[0].FP0.x - RightInLine[0].FP1.x) > 3){
										 LSP.x = (RightInLine[0].FP0.x + RightInLine[0].FP1.x)/2;
										 LSP.y = 0.0f;
									 }
									 else {
										 LSP = Math.OnIntersect(RightInLine[0].FP0, RightInLine[0].FP1, LT, RT);
									 }

									 SingleLine->IRoi->SetOrgX  ((int)LSP.x-100);
									 SingleLine->IRoi->SetOrgY  (0             );
									 SingleLine->IRoi->SetWidth (97            );
									 SingleLine->IRoi->SetHeight(ImgH          );
									 SingleLine->SetIncrement(5 );

									 if(((LSP.x+3)<=0) || ImgH<=0) return false;

									 // 										 if(IRoi->GetHeight()<300) SingleLine->SetIncrement(5 );
									 // 										 else                      SingleLine->SetIncrement(10);

									 // 연마량 측정 OutLine
									 SingleLine->SetFindLineId(0);
									 SingleLine->SetOrientation(orEast);
									 SingleLine->SetEdgeType(1); // White To Black  
									 SingleLine->OnExecute();
									 RightTrackLine[0].FP0 = SingleLine->GetResultP0();
									 RightTrackLine[0].FP1 = SingleLine->GetResultP1();

									 SingleLine->SetEdgeType(2); // Line Search Org 

									 // RightTrackLine....make OutLine Data 
									 // 현재의 데이터를 넘겨준다 
									 // 검사중 기준라인을 찾지 못할경우 이전데이터 넘겨줘서 기준라인 생성함 
									 if(RightTrackLine[0].FP0.x!=0.0f && RightTrackLine[0].FP0.y!=0.0f && RightTrackLine[0].FP1.x!=0.0f && RightTrackLine[0].FP1.y!=0.0f){
										 PreRightTrackLine[0].FP0.x = RightTrackLine[0].FP0.x;    PreRightTrackLine[0].FP1.x = RightTrackLine[0].FP1.x;       
										 PreRightTrackLine[0].FP0.y = RightTrackLine[0].FP0.y;    PreRightTrackLine[0].FP1.y = RightTrackLine[0].FP1.y;       
									 } // 셀의 상단 시작부터 Broken 발생으로 데이터가 없는경우 
									 else if(RightTrackLine[0].FP0.x==0.0f || RightTrackLine[0].FP0.y==0.0f || RightTrackLine[0].FP1.x==0.0f || RightTrackLine[0].FP1.y==0.0f){
										 if(PreRightTrackLine[0].FP0.x==0.0f && PreRightTrackLine[0].FP0.y==0.0f && PreRightTrackLine[0].FP1.x==0.0f && PreRightTrackLine[0].FP1.y==0.0f){// 시작부분 Broken발생으로 데이터가 없는경우 
											 // Mark좌표를 기준으로 라인좌표값을 다시 설정함 
											 ROI_H = IRoi->GetHeight();
											 ROI_L = IRoi->GetOrgX()  ;
											 RightTrackLine[0].FP0.x = ROI_L;    RightTrackLine[0].FP0.y = 0.0f        ;
											 RightTrackLine[0].FP1.x = ROI_L;    RightTrackLine[0].FP1.y = (float)ROI_H;

											 //RightTrackLine 데이터를 PreRightTrackLine에 넘겨준다 
											 PreRightTrackLine[0].FP0.x = RightTrackLine[0].FP0.x;    PreRightTrackLine[0].FP1.x = RightTrackLine[0].FP1.x;       
											 PreRightTrackLine[0].FP0.y = RightTrackLine[0].FP0.y;    PreRightTrackLine[0].FP1.y = RightTrackLine[0].FP1.y;       
										 }
										 else { // 중간부분 Broken발생으로 데이터가 없는경우 
											 // PreRightTrackLine 데이터를 넘겨줌 
											 RightTrackLine[0].FP0.x = PreRightTrackLine[0].FP0.x;  RightTrackLine[0].FP1.x = PreRightTrackLine[0].FP1.x;  
											 RightTrackLine[0].FP0.y = PreRightTrackLine[0].FP0.y;  RightTrackLine[0].FP1.y = PreRightTrackLine[0].FP1.y;  
										 }
									 }
									 // NOTCH CELL Btm 검사에서만 연마폭 측정함 
									 Right_Grind_Mea =(float)(Math.GetLengthFrLineToPoint (RightOutLine[0].FP0,RightOutLine[0].FP1,RightTrackLine[0].FP0));

									 // 마크라인에서 부터 RightTrackLine 까지 거리 산출 
									 // RightTrackLine Data 존재할 경우 거리 측정함 
									 if(RightTrackLine[0].FP0.x!=0.0f && RightTrackLine[0].FP0.y!=0.0f && RightTrackLine[0].FP1.x!=0.0f && RightTrackLine[0].FP1.y!=0.0f){
										 // 											 RightTrackLine[0].FP0.y = RightTrackLine[0].FP0.y + ImageHeight; //전체 이미지 기준 y좌표
										 // 											 RightTrackLine[0].FP1.y = RightTrackLine[0].FP1.y + ImageHeight; //전체 이미지 기준 y좌표
										 // 
										 // 											 MarkToTrackLineDis1 = Math.GetLengthFrLineToPoint(RightMarkSta, RightMarkEnd, RightTrackLine[0].FP0);//Mark라인에서 TrackLine거리 
										 // 											 MarkToTrackLineDis2 = Math.GetLengthFrLineToPoint(RightMarkSta, RightMarkEnd, RightTrackLine[0].FP1);//Mark라인에서 TrackLine거리 
										 // 
										 // 											 TotalRightTrackDis  +=  (int)((MarkToTrackLineDis1 + MarkToTrackLineDis2)/2.0); //Mark라인에서 TrackLine거리 누적                   
										 // 											 RightTrackLineCount++; //누적 카운트 증가
										 // 
										 // 											 // Org Data 
										 // 											 RightTrackLine[0].FP0.y = RightTrackLine[0].FP0.y - ImageHeight; //Frame 이미지 기준 y좌표 원복
										 // 											 RightTrackLine[0].FP1.y = RightTrackLine[0].FP1.y - ImageHeight; //Frame 이미지 기준 y좌표 원복 
									 }
								 }
								 else { //RightInLine Search, RightTrackLine Data Overlap 
									 // RightInLine Search Start 
									 EasyImage::Threshold(&RotateImg,&RotateBinaryImg, RightEdgeThresHold);
									 //RightOutLine기준 RightInLine 검출
									 if(RightEdgeThresHold==0) {SingleLine->GImage = &RotateImg      ;  SingleLine->FThreshold =5 ;}
									 else                      {SingleLine->GImage = &RotateBinaryImg;  SingleLine->FThreshold =10;}

									 // 영역설정 
									 if(fabs(RightOutLine[0].FP0.x - RightOutLine[0].FP1.x) > 3){
										 LSP.x = (RightOutLine[0].FP0.x + RightOutLine[0].FP1.x)/2;
										 LSP.y = 0.0f;
									 }
									 else {
										 LSP = Math.OnIntersect(RightOutLine[0].FP0, RightOutLine[0].FP1, LT, RT);
									 }

									 SingleLine->IRoi->SetOrgX  ((int)LSP.x-100);
									 SingleLine->IRoi->SetOrgY  (0             );
									 SingleLine->IRoi->SetWidth (97            );
									 SingleLine->IRoi->SetHeight(ImgH          );
									 SingleLine->SetIncrement(5 );

									 if(((LSP.x+3)<=0) || ImgH<=0) return false;

									 // 										 if(IRoi->GetHeight()<300) SingleLine->SetIncrement(5 );
									 // 										 else                      SingleLine->SetIncrement(10);

									 // 연마량 측정 OutLine
									 SingleLine->SetFindLineId(0);
									 SingleLine->SetOrientation(orEast);
									 SingleLine->SetEdgeType(0); // Black to White 
									 SingleLine->OnExecute();
									 RightInLine[0].FP0 = SingleLine->GetResultP0();
									 RightInLine[0].FP1 = SingleLine->GetResultP1();

									 SingleLine->SetEdgeType(2); // Line Search Org 

									 // RightInLine None....make InLine Data 
									 // 현재의 데이터를 넘겨준다 
									 if(RightInLine[0].FP0.x!=0.0f && RightInLine[0].FP0.y!=0.0f && RightInLine[0].FP1.x!=0.0f && RightInLine[0].FP1.y!=0.0f){
										 PreRightInLine[0].FP0.x = RightInLine[0].FP0.x;    PreRightInLine[0].FP1.x = RightInLine[0].FP1.x;       
										 PreRightInLine[0].FP0.y = RightInLine[0].FP0.y;    PreRightInLine[0].FP1.y = RightInLine[0].FP1.y;       
									 }
									 else if(RightInLine[0].FP0.x==0.0f || RightInLine[0].FP0.y==0.0f || RightInLine[0].FP1.x==0.0f || RightInLine[0].FP1.y==0.0f){
										 if(PreRightInLine[0].FP0.x==0.0f && PreRightInLine[0].FP0.y==0.0f && PreRightInLine[0].FP1.x==0.0f && PreRightInLine[0].FP1.y==0.0f){// 시작부분 Broken발생으로 데이터가 없는경우 
											 // Mark좌표를 기준으로 라인좌표값을 다시 설정함 
											 ROI_H = IRoi->GetHeight();
											 ROI_L = IRoi->GetOrgX()  ;
											 RightInLine[0].FP0.x = ROI_L;   RightInLine[0].FP0.y = 0.0f        ;
											 RightInLine[0].FP1.x = ROI_L;   RightInLine[0].FP1.y = (float)ROI_H;

											 //Line 데이터를 PreLine에 넘겨준다 
											 PreRightInLine[0].FP0.x = RightInLine[0].FP0.x;    PreRightInLine[0].FP1.x = RightInLine[0].FP1.x;       
											 PreRightInLine[0].FP0.y = RightInLine[0].FP0.y;    PreRightInLine[0].FP1.y = RightInLine[0].FP1.y;       
										 }
										 else {                                                                                                    // 중간부분 Broken발생으로 데이터가 없는경우 
											 // PreLine 데이터를 넘겨줌 
											 RightInLine[0].FP0.x = PreRightInLine[0].FP0.x;  RightInLine[0].FP1.x = PreRightInLine[0].FP1.x;  
											 RightInLine[0].FP0.y = PreRightInLine[0].FP0.y;  RightInLine[0].FP1.y = PreRightInLine[0].FP1.y;  
										 }
									 }
									 // NOTCH CELL Btm 검사에서만 연마폭 측정함 
									 Right_Grind_Width =(float)(Math.GetLengthFrLineToPoint (RightOutLine[0].FP0,RightOutLine[0].FP1, RightInLine[0].FP0 ));
									 /////////////////////////////////////////////////////////////////////////////////////////////

									 // RightTrackLine Data Overlap
									 if(AvgRightTrackLineDis!=0){
										 // 											 RightOutLine[0].FP0.y = RightOutLine[0].FP0.y + ImageHeight; //전체 이미지 기준 y좌표
										 // 											 RightOutLine[0].FP1.y = RightOutLine[0].FP1.y + ImageHeight; //전체 이미지 기준 y좌표
										 // 
										 // 											 MarkToTrackLineDis1 = Math.GetLengthFrLineToPoint(RightMarkSta, RightMarkEnd, RightOutLine[0].FP0);//Mark라인에서 OutLine까지 거리 
										 // 											 MarkToTrackLineDis2 = Math.GetLengthFrLineToPoint(RightMarkSta, RightMarkEnd, RightOutLine[0].FP1);//Mark라인에서 OutLine까지 거리 
										 // 
										 // 											 if(MarkToTrackLineDis1>AvgRightTrackLineDis) RightTrackLine[0].FP0.x = RightOutLine[0].FP0.x-(MarkToTrackLineDis1 - AvgRightTrackLineDis);
										 // 											 if(MarkToTrackLineDis2>AvgRightTrackLineDis) RightTrackLine[0].FP1.x = RightOutLine[0].FP1.x-(MarkToTrackLineDis2 - AvgRightTrackLineDis);
										 // 
										 // 											 // RightOutLine Data 원본 
										 // 											 RightOutLine[0].FP0.y = RightOutLine[0].FP0.y - ImageHeight; 
										 // 											 RightOutLine[0].FP1.y = RightOutLine[0].FP1.y - ImageHeight; 
										 // 
										 // 											 RightTrackLine[0].FP0.y = RightOutLine[0].FP0.y;
										 // 											 RightTrackLine[0].FP1.y = RightOutLine[0].FP1.y;
									 }
								 }
							 }
							 else {
								 if(IsMarkBtm){ //RightTrackLine Search,Data생성 
									 if(FInspectMode==Insp_Track){
										 // Right TrackLine Search 
										 /////////////////////////////////////////////////////////////////////////////////////////////
										 // 									 BinaryImg.SetSize(GImage->GetWidth(), GImage->GetHeight());
										 // 									 EasyImage::Oper(EArithmeticLogicOperation_Copy,GImage,&BinaryImg);
										 EasyImage::Threshold(&RotateImg,&RotateBinaryImg, CirGrindMeaThresHold);
										 //RightInLine기준 RightTrackLine 검출
										 if(CirGrindMeaThresHold==0) {SingleLine->GImage = &RotateImg      ;  SingleLine->FThreshold =5 ;}
										 else                        {SingleLine->GImage = &RotateBinaryImg;  SingleLine->FThreshold =10;}

										 // 영역설정 
										 if(fabs(RightOutLine[0].FP0.x - RightOutLine[0].FP1.x) > 3){
											 LSP.x = (RightOutLine[0].FP0.x + RightOutLine[0].FP1.x)/2;
											 LSP.y = 0.0f;
										 }
										 else {
											 LSP = Math.OnIntersect(RightOutLine[0].FP0, RightOutLine[0].FP1, LT, RT);
										 }

										 SingleLine->IRoi->SetOrgX  ((int)LSP.x-50            );
										 SingleLine->IRoi->SetOrgY  (0                        );
										 SingleLine->IRoi->SetWidth (47                       );
										 SingleLine->IRoi->SetHeight(FEndLine-CSideCircleHeight);
										 SingleLine->SetIncrement(1 );

										 if(((LSP.x+3)<=0) || ImgH<=0) return false;

										 // 										 if(IRoi->GetHeight()<300) SingleLine->SetIncrement(5 );
										 // 										 else                      SingleLine->SetIncrement(10);

										 // 연마량 측정 OutLine
										 SingleLine->SetFindLineId(0);
										 SingleLine->SetOrientation(orEast);
										 SingleLine->SetEdgeType(1); // White To Black  
										 SingleLine->OnExecute();
										 RightTrackLine[0].FP0 = SingleLine->GetResultP0();
										 RightTrackLine[0].FP1 = SingleLine->GetResultP1();

										 if(fabs(RightTrackLine[0].FP0.x - RightTrackLine[0].FP1.x)>=0.5){
											 RightTrackLine[0].FP0.x = (RightTrackLine[0].FP0.x+RightTrackLine[0].FP1.x)/2.0;
											 RightTrackLine[0].FP1.x = (RightTrackLine[0].FP0.x+RightTrackLine[0].FP1.x)/2.0;
										 }


										 SingleLine->SetEdgeType(2); // Line Search Org 

										 // RightTrackLine....make OutLine Data 
										 // 현재의 데이터를 넘겨준다 
										 // 검사중 기준라인을 찾지 못할경우 이전데이터 넘겨줘서 기준라인 생성함 
										 if(RightTrackLine[0].FP0.x!=0.0f && RightTrackLine[0].FP0.y!=0.0f && RightTrackLine[0].FP1.x!=0.0f && RightTrackLine[0].FP1.y!=0.0f){
											 PreRightTrackLine[0].FP0.x = RightTrackLine[0].FP0.x;    PreRightTrackLine[0].FP1.x = RightTrackLine[0].FP1.x;       
											 PreRightTrackLine[0].FP0.y = RightTrackLine[0].FP0.y;    PreRightTrackLine[0].FP1.y = RightTrackLine[0].FP1.y;       
										 } // 셀의 상단 시작부터 Broken 발생으로 데이터가 없는경우 
										 else if(RightTrackLine[0].FP0.x==0.0f || RightTrackLine[0].FP0.y==0.0f || RightTrackLine[0].FP1.x==0.0f || RightTrackLine[0].FP1.y==0.0f){
											 if(PreRightTrackLine[0].FP0.x==0.0f && PreRightTrackLine[0].FP0.y==0.0f && PreRightTrackLine[0].FP1.x==0.0f && PreRightTrackLine[0].FP1.y==0.0f){// 시작부분 Broken발생으로 데이터가 없는경우 
												 // Mark좌표를 기준으로 라인좌표값을 다시 설정함 
												 ROI_H = IRoi->GetHeight();
												 ROI_L = IRoi->GetOrgX()  ;
												 RightTrackLine[0].FP0.x = ROI_L;    RightTrackLine[0].FP0.y = 0.0f        ;
												 RightTrackLine[0].FP1.x = ROI_L;    RightTrackLine[0].FP1.y = (float)ROI_H;

												 //RightTrackLine 데이터를 PreRightTrackLine에 넘겨준다 
												 PreRightTrackLine[0].FP0.x = RightTrackLine[0].FP0.x;    PreRightTrackLine[0].FP1.x = RightTrackLine[0].FP1.x;       
												 PreRightTrackLine[0].FP0.y = RightTrackLine[0].FP0.y;    PreRightTrackLine[0].FP1.y = RightTrackLine[0].FP1.y;       
											 }
											 else { // 중간부분 Broken발생으로 데이터가 없는경우 
												 // PreRightTrackLine 데이터를 넘겨줌 
												 RightTrackLine[0].FP0.x = PreRightTrackLine[0].FP0.x;  RightTrackLine[0].FP1.x = PreRightTrackLine[0].FP1.x;  
												 RightTrackLine[0].FP0.y = PreRightTrackLine[0].FP0.y;  RightTrackLine[0].FP1.y = PreRightTrackLine[0].FP1.y;  
											 }
										 }

										 // 마크라인에서 부터 RightTrackLine 까지 거리 산출 
										 // RightTrackLine Data 존재할 경우 거리 측정함 
										 // Image Rotate 있음 
										 if(RightTrackLine[0].FP0.x!=0.0f && RightTrackLine[0].FP0.y!=0.0f && RightTrackLine[0].FP1.x!=0.0f && RightTrackLine[0].FP1.y!=0.0f){ // Mark기준 
											 if(RightOutLine[0].FP0.x!=0.0f && RightOutLine[0].FP0.y!=0.0f && RightOutLine[0].FP1.x!=0.0f && RightOutLine[0].FP1.y!=0.0f){
												 RightToTrackLineDis1 = Math.GetLengthFrLineToPoint(RightOutLine[0].FP0, RightOutLine[0].FP1, RightTrackLine[0].FP0);//외곽라인에서 TrackLine거리 
												 RightToTrackLineDis2 = Math.GetLengthFrLineToPoint(RightOutLine[0].FP0, RightOutLine[0].FP1, RightTrackLine[0].FP1);//외곽라인에서 TrackLine거리 

												 TotalRightTrackDis  +=  (int)((RightToTrackLineDis1 + RightToTrackLineDis2)/2.0); //Mark라인에서 TrackLine거리 누적                   
												 RightTrackLineCount++; //누적 카운트 증가
											 }
										 }
									 }
								 }
								 else { //RightTrackLine Data Overlap
									 if(AvgRightTrackLineDis!=0){
										 if(FInspectMode==Insp_Track){ //Mark기준 
											 if(RightOutLine[0].FP0.x!=0.0f && RightOutLine[0].FP0.y!=0.0f && RightOutLine[0].FP1.x!=0.0f && RightOutLine[0].FP1.y!=0.0f){
												 // TOP영역 LeftTrackLine x좌표 
												 RightTrackLine[0].FP0.x = RightOutLine[0].FP0.x - AvgRightTrackLineDis;
												 RightTrackLine[0].FP1.x = RightOutLine[0].FP1.x - AvgRightTrackLineDis;

												 // TOP영역 LeftTrackLine y좌표 
												 RightTrackLine[0].FP0.y = RightOutLine[0].FP0.y;
												 RightTrackLine[0].FP1.y = RightOutLine[0].FP1.y;
											 }
										 }
									 }
								 }
							 }
						 }
						 if(FBottomWall ){
							 EasyImage::Threshold(&RotateImg,&RotateBinaryImg, BtmEdgeThresHold);
							 if(BtmEdgeThresHold==0)    {SingleLine->GImage = &RotateImg      ;  SingleLine->FThreshold =5 ;}
							 else                       {SingleLine->GImage = &RotateBinaryImg;  SingleLine->FThreshold =10;}

							 SingleLine->IRoi->SetOrgX  (IRoi->GetOrgX());
							 SingleLine->IRoi->SetOrgY  (FEndLine-100   );
							 SingleLine->IRoi->SetWidth (IRoi->GetWidth());
							 SingleLine->IRoi->SetHeight(200             );

							 SingleLine->SetOrientation(orSouth);
							 SingleLine->FIncrement =20;
							 SingleLine->SetFindLineId(0);
							 SingleLine->FThreshold =5;

							 if(IsMarkBtm) SingleLine->SetEdgeType(1);  //White To Black
							 else          SingleLine->SetEdgeType(1);  //White To Black

							 SingleLine->OnExecute();
							 // 								 Line[waBottomWall].FP0 = SingleLine->GetResultP0();
							 // 								 Line[waBottomWall].FP1 = SingleLine->GetResultP1();
							 Line[3].FP0 = SingleLine->GetResultP0();
							 Line[3].FP1 = SingleLine->GetResultP1();

							 // Image Roate 후 기준 데이터 다시 산출 
							 FLBPoint = Math.OnIntersect(LeftOutLine [0].FP0 , LeftOutLine [0].FP1 , Line[3].FP0, Line[3].FP1);
							 FRBPoint = Math.OnIntersect(RightOutLine[0].FP0 , RightOutLine[0].FP1 , Line[3].FP0, Line[3].FP1);


							 // Btm TrackLine Search Only LTCell ==> Btm 검사시 
							 if(IsMarkBtm && IsCircleBtm && FInspectMode==Insp_Track){

								 EasyImage::Threshold(&RotateImg,&RotateBinaryImg, CirGrindMeaThresHold);
								 if(CirGrindMeaThresHold==0) {SingleLine->GImage = &RotateImg      ;  SingleLine->FThreshold =5 ;}
								 else                        {SingleLine->GImage = &RotateBinaryImg;  SingleLine->FThreshold =10;}

								 SingleLine->IRoi->SetOrgX  (IRoi->GetOrgX());
								 SingleLine->IRoi->SetOrgY  (FEndLine-100   );
								 SingleLine->IRoi->SetWidth (IRoi->GetWidth());
								 SingleLine->IRoi->SetHeight(200             );

								 // 									 SingleLine->IRoi->SetOrgX  (FLBPoint.x+CSideCircleWidth                               );
								 // 									 SingleLine->IRoi->SetOrgY  (FEndLine-100                                             );
								 // 									 SingleLine->IRoi->SetWidth ((FRBPoint.x-CSideCircleWidth)-(FLBPoint.x+CSideCircleWidth));
								 // 									 SingleLine->IRoi->SetHeight(200                                                      );

								 if((FEndLine-100<=0)|| (FEndLine-100>=ImgW)) return false;

								 SingleLine->SetOrientation(orSouth);
								 SingleLine->FIncrement =50;
								 SingleLine->SetFindLineId(0);
								 SingleLine->FThreshold =5;

								 SingleLine->SetEdgeType(1);  //White To Black 

								 SingleLine->OnExecute();
								 BtmTrackLine[0].FP0 = SingleLine->GetResultP0();
								 BtmTrackLine[0].FP1 = SingleLine->GetResultP1();

								 if(fabs(BtmTrackLine[0].FP0.y - BtmTrackLine[0].FP1.y)>=1){
									 BtmTrackLine[0].FP0.y = (BtmTrackLine[0].FP0.y+BtmTrackLine[0].FP1.y)/2.0;
									 BtmTrackLine[0].FP1.y = (BtmTrackLine[0].FP0.y+BtmTrackLine[0].FP1.y)/2.0;
								 }

								 // TrackLine CrossPoint Calculate (Org Data)
								 FTRLBPoint = Math.OnIntersect(LeftTrackLine [0].FP0, LeftTrackLine [0].FP1, BtmTrackLine[0].FP0 , BtmTrackLine[0].FP1);
								 FTRRBPoint = Math.OnIntersect(RightTrackLine[0].FP0, RightTrackLine[0].FP1, BtmTrackLine[0].FP0 , BtmTrackLine[0].FP1);

								 if(TotalLeftTrackDis!=0  && LeftTrackLineCount!=0){ //LeftTrackLine 거리편차 평균값 
									 AvgLeftTrackLineDis  = (int)(TotalLeftTrackDis/LeftTrackLineCount);
								 }
								 if(TotalRightTrackDis!=0 && RightTrackLineCount!=0){//RightTrackLine 거리편차 평균값 
									 AvgRightTrackLineDis = (int)(TotalRightTrackDis/RightTrackLineCount);
								 }

								 // LeftBtmTrackLine, RightBtmTrackLine Dis Calculate 
								 // TrackLine에서 Mark까지 거리를 개별 계산함 
								 // Image Rotate 있음 
								 if(FInspectMode==Insp_Track){ // 외곽라인 기준 
									 if(BtmTrackLine[0].FP0.x!=0 && BtmTrackLine[0].FP0.y!=0 && BtmTrackLine[0].FP1.x!=0 && BtmTrackLine[0].FP1.y!=0){
										 // 상단에 마크기준으로 거리값을 계산시 이미지 회전으로 인해서 정확성 떨어짐....
										 if(Line[3].FP0.x!=0 && Line[3].FP0.y!=0 && Line[3].FP1.x!=0 && Line[3].FP1.y!=0){
											 AvgLeftBtmTrackLineDis = Math.GetLengthFrLineToPoint(Line[3].FP0, Line[3].FP1, BtmTrackLine[0].FP0);//외곽라인에서 TrackLine거리 
											 AvgRightBtmTrackLineDis= Math.GetLengthFrLineToPoint(Line[3].FP0, Line[3].FP1, BtmTrackLine[0].FP1);//외곽라인에서 TrackLine거리 
										 }
									 }
								 }
							 }
							 else if(!IsMarkBtm && IsCircleBtm && FInspectMode==Insp_Track){ // EnCap Cell 검사시 TrackLine 데이터 만들어 준다 
								 if(AvgLeftBtmTrackLineDis!=0 && AvgRightBtmTrackLineDis!=0){
									 BtmTrackLine[0].FP0.y = Line[3].FP0.y - AvgLeftBtmTrackLineDis ;
									 BtmTrackLine[0].FP1.y = Line[3].FP1.y - AvgRightBtmTrackLineDis;

									 BtmTrackLine[0].FP0.x = Line[3].FP0.x;
									 BtmTrackLine[0].FP1.x = Line[3].FP1.x;
								 }
								 // EnCap영역에 TrackLine 교차점을 LT영역 데이터를 이용하여 가상으로 생성해준다 
								 // Image Rotate 있음 
								 if(LeftTrackLine[0].FP0.x!=0.0f && LeftTrackLine[0].FP0.y!=0.0f && RightTrackLine[0].FP0.x!=0.0f && RightTrackLine[0].FP0.y!=0.0f&&
									 LeftTrackLine[0].FP1.x!=0.0f && LeftTrackLine[0].FP1.y!=0.0f && RightTrackLine[0].FP1.x!=0.0f && RightTrackLine[0].FP1.y!=0.0f){
										 if(BtmTrackLine[0].FP0.x!=0.0f && BtmTrackLine[0].FP0.y!=0.0f && BtmTrackLine[0].FP1.x!=0.0f && BtmTrackLine[0].FP1.y!=0.0f){
											 FTRLBPoint = Math.OnIntersect(LeftTrackLine [0].FP0, LeftTrackLine [0].FP1, BtmTrackLine[0].FP0 , BtmTrackLine[0].FP1);
											 FTRRBPoint = Math.OnIntersect(RightTrackLine[0].FP0, RightTrackLine[0].FP1, BtmTrackLine[0].FP0 , BtmTrackLine[0].FP1);
										 }
								 }
							 }
							 else if(IsCornerBtm){ // Btm영역이 Corner일경우 
								 // 3Point 패턴 기준으로 연마량,가공량 측정 
								 if(GrindRectSpec[1].DvX==0.0f && GrindRectSpec[1].DvY==0.0f){
									 double Dis =0.0f, AvgGrindWidth=0.0f, AvgGrindMea=0.0f, TotalGrindWidth=0.0f, TotalGrindMeasure=0.0f;

									 EasyImage::Threshold(&RotateImg,&RotateBinaryImg, ECThresHold);               // Corner Out GinrdThresHold 
									 EasyImage::Threshold(&RotateImg,&RotateGrindBinaryImg, CorGrindMeaThresHold); // Corner Measure GrindThresHold(3Point)

									 if(ECThresHold==0)    {SingleLine->GImage = &RotateImg      ;  SingleLine->FThreshold =5 ;}
									 else                  {SingleLine->GImage = &RotateBinaryImg;  SingleLine->FThreshold =10;}

									 // LEFTBTM START 
									 ///////////////////////////////////////////////////////////////////////////////////////////////////
									 SingleLine->IRoi->SetOrgX  ((int)FLBPoint.x-10            );
									 SingleLine->IRoi->SetOrgY  ((int)FLBPoint.y-LBCornerHeight);
									 SingleLine->IRoi->SetWidth ((int)LBCornerWidth+20         );
									 SingleLine->IRoi->SetHeight((int)LBCornerHeight           );

									 SingleLine->SetOrientation(orWest);
									 SingleLine->FIncrement =1;
									 SingleLine->FThreshold =15;
									 SingleLine->SetFindLineId(0);
									 SingleLine->SetEdgeType(1);  //White To Black 
									 SingleLine->OnExecute();

									 Line[7].FP0 = SingleLine->GetResultP0();
									 Line[7].FP1 = SingleLine->GetResultP1();

									 // ORG 
									 FLBLPoint = Math.OnIntersect(SingleLine->GetResultP0(), SingleLine->GetResultP1(), Line[waLeftWall].FP0   , Line[waLeftWall].FP1);
									 FLBBPoint = Math.OnIntersect(SingleLine->GetResultP0(), SingleLine->GetResultP1(), Line[waBottomWall ].FP0, Line[waBottomWall ].FP1);

									 if((FLBLPoint.x==0 || FLBLPoint.y==0 || FLBBPoint.x==0 || FLBBPoint.y==0) || (SingleLine->FEdgePointCount <30)){
										 LBDx = 0.0f;
										 LBDy = 0.0f;
										 //화면에 디스플레이 위해서 
										 FLBLPoint.x = FLBPoint.x;
										 FLBLPoint.y = FLBPoint.y;
										 FLBBPoint.x = FLBPoint.x;
										 FLBBPoint.y = FLBPoint.y;
									 }
									 else { 
										 LBDx = Math.GetLengthFrPointToPoint(FLBPoint, FLBBPoint);
										 LBDy = Math.GetLengthFrPointToPoint(FLBPoint, FLBLPoint);

										 // OutLine C3Corner Data 
										 if((SingleLine->FEdgePointCount) - (CornerMargin*2)>0){
											 if(C3Point!=NULL) delete[] C3Point;
											 C3Point  = new TFPoint [(SingleLine->FEdgePointCount) - (CornerMargin*2)];
											 C3EdgeCount = (SingleLine->FEdgePointCount) -(CornerMargin*2);

											 CornerCount =0;  
											 for(int k=CornerMargin; k<((SingleLine->FEdgePointCount)-CornerMargin); k++){
												 if(CornerCount>=MAX_CORNER_POINT) break;
												 C3Point[CornerCount].x = SingleLine->FEdgePoint[k].x;
												 C3Point[CornerCount].y = SingleLine->FEdgePoint[k].y;
												 CornerCount++;
											 }
										 }

										 // Corner 연마 안쪽라인 
										 if(CorGrindInThresHold!=0){
											 EasyImage::Threshold(&RotateImg,&RotateBinaryImg, CorGrindInThresHold);
											 SingleLine->GImage = &RotateBinaryImg;  SingleLine->FThreshold =10;

											 // Corner 기울기 완만하여 Edge찾을 경우 Defect 오버킬 발생함 
											 // 방향을 Top방향에서 다시 엣지를 찾음 (Corner Defect OverKill 감소 목적)
											 if(LBCornerWidth >(LBCornerHeight*1.5)){
												 SingleLine->IRoi->SetOrgX  ((int)FLBPoint.x );
												 SingleLine->IRoi->SetOrgY  ((int)FLBPoint.y - LBCornerHeight    );
												 SingleLine->IRoi->SetWidth ((int)((FLBBPoint.x - FLBPoint.x)+20));
												 SingleLine->IRoi->SetHeight((int)((FLBPoint.y  - FLBLPoint.y)  ));

												 if(FLBPoint.x<=0    || FLBPoint.y - LBCornerHeight<=0    || (FLBBPoint.x - FLBPoint.x )<=0    || ((FLBPoint.y  - FLBLPoint.y)+20)<=0   ) return false;
												 if(FLBPoint.x>=ImgW || FLBPoint.y - LBCornerHeight>=ImgH || (FLBBPoint.x - FLBPoint.x )>=ImgW || ((FLBPoint.y  - FLBLPoint.y)+20)>=ImgH) return false;

												 SingleLine->SetOrientation(orSouth);
												 SingleLine->FIncrement =1;
												 SingleLine->SetFindLineId(0);
												 SingleLine->SetEdgeType(0);  //Black To White 
												 SingleLine->OnExecute();

												 // InLine C3Corner Data 
												 if((SingleLine->FEdgePointCount) - (CornerMargin*2)>0){
													 if(C3InPoint!=NULL) delete[] C3InPoint;
													 C3InPoint  = new TFPoint [(SingleLine->FEdgePointCount) - (CornerMargin*2)];
													 C3InEdgeCount = (SingleLine->FEdgePointCount) -(CornerMargin*2);

													 CornerCount =0;  
													 for(int k=CornerMargin; k<((SingleLine->FEdgePointCount)-CornerMargin); k++){
														 if(CornerCount>=MAX_CORNER_POINT) break;
														 C3InPoint[CornerCount].x = SingleLine->FEdgePoint[k].x;
														 C3InPoint[CornerCount].y = SingleLine->FEdgePoint[k].y;
														 CornerCount++;
													 }
												 }
											 }
											 else {
												 // Corner 연마 안쪽라인 찾는다 
												 SingleLine->SetOrientation(orWest);
												 SingleLine->SetFindLineId(0);
												 SingleLine->SetEdgeType(0);  //Black To White 
												 SingleLine->OnExecute();

												 // InLine C1Corner Data 
												 if((SingleLine->FEdgePointCount) - (CornerMargin*2)>0){
													 if(C3InPoint!=NULL) delete[] C3InPoint;
													 C3InPoint  = new TFPoint [(SingleLine->FEdgePointCount) - (CornerMargin*2)];
													 C3InEdgeCount = (SingleLine->FEdgePointCount) -(CornerMargin*2);

													 CornerCount =0;  
													 for(int k=CornerMargin; k<((SingleLine->FEdgePointCount)-CornerMargin); k++){
														 if(CornerCount>=MAX_CORNER_POINT) break;
														 C3InPoint[CornerCount].x = SingleLine->FEdgePoint[k].x;
														 C3InPoint[CornerCount].y = SingleLine->FEdgePoint[k].y;
														 CornerCount++;
													 }
												 }
											 }

											 //코너 연마안쪽라인 기준 새로운 교차점 생성 
											 FLBLInPoint = Math.OnIntersect(SingleLine->GetResultP0(), SingleLine->GetResultP1(), Line[waLeftWall].FP0   , Line[waLeftWall].FP1);
											 FLBBInPoint = Math.OnIntersect(SingleLine->GetResultP0(), SingleLine->GetResultP1(), Line[waBottomWall ].FP0, Line[waBottomWall ].FP1);

											 //코너 연마폭 
											 Dis =0.0f, AvgGrindWidth=0.0f, AvgGrindMea=0.0f, TotalGrindWidth=0.0f, TotalGrindMeasure=0.0f;
											 for(int k=0; k<C3InEdgeCount; k++){
												 Dis = Math.GetLengthFrLineToPoint(FLBLPoint, FLBBPoint, C3InPoint[k]);
												 TotalGrindWidth+=Dis;
											 }
											 if(C3InEdgeCount!=0){
												 AvgGrindWidth = (TotalGrindWidth/C3InEdgeCount);
												 C3CorGrindWd  = AvgGrindWidth;
											 }
										 }
										 // 코너 연마량 기준 라인을 찾는다 
										 // ROI 영역 설정(3개의 흰색 점선 기준 라인을 찾는다)
										 if(CorGrindMeaThresHold!=0){
											 if(CorGrindMeaThresHold==0){SingleLine->GImage = &RotateImg           ;  SingleLine->FThreshold =5 ;}
											 else                       {SingleLine->GImage = &RotateGrindBinaryImg;  SingleLine->FThreshold =10;}

											 SingleLine->IRoi->SetOrgX  ((int)FLBPoint.x                   );
											 SingleLine->IRoi->SetOrgY  ((int)FLBPoint.y-LBCornerHeight +20);
											 SingleLine->IRoi->SetWidth ((int)LBCornerWidth +50            );
											 SingleLine->IRoi->SetHeight((int)LBCornerHeight               );

											 SingleLine->SetOrientation(orWest);
											 SingleLine->SetFindLineId(0);
											 SingleLine->SetEdgeType(0);  //Black To White 
											 SingleLine->OnExecute();

											 P1 = SingleLine->GetResultP0();
											 P2 = SingleLine->GetResultP1();

											 //코너 연마량 기준 라인과 새로운 교차점 생성 
											 FLBLMeaPoint = Math.OnIntersect(SingleLine->GetResultP0(), SingleLine->GetResultP1(), Line[waLeftWall].FP0   , Line[waLeftWall].FP1);
											 FLBBMeaPoint = Math.OnIntersect(SingleLine->GetResultP0(), SingleLine->GetResultP1(), Line[waBottomWall ].FP0, Line[waBottomWall ].FP1);

											 // C3Corner Grind Measure Stand Data 
											 if((SingleLine->FEdgePointCount)>0){
												 if(C3MeaPoint!=NULL) delete[] C3MeaPoint;
												 C3MeaPoint     = new TFPoint [(SingleLine->FEdgePointCount)];
												 C3MeaEdgeCount = (SingleLine->FEdgePointCount);

												 CornerCount =0;  
												 for(int k=0; k<(SingleLine->FEdgePointCount); k++){
													 if(CornerCount>=MAX_CORNER_POINT) break;
													 C3MeaPoint[CornerCount].x = SingleLine->FEdgePoint[k].x;
													 C3MeaPoint[CornerCount].y = SingleLine->FEdgePoint[k].y;
													 CornerCount++;
												 }
											 }
											 //코너 연마량 계산  
											 Dis =0.0f, AvgGrindMea=0.0f, TotalGrindMeasure=0.0f;
											 for(int k=0; k<C3MeaEdgeCount; k++){
												 Dis = Math.GetLengthFrLineToPoint(FLBLPoint, FLBBPoint, C3MeaPoint[k]);
												 TotalGrindMeasure+=Dis;
											 }
											 if(C3MeaEdgeCount!=0){
												 AvgGrindMea    = (TotalGrindMeasure/C3MeaEdgeCount);
												 C3CorGrindMea  = AvgGrindMea;
											 }
										 }
									 }	
									 // LEFTBTM END 
									 ///////////////////////////////////////////////////////////////////////////////////////////////////


									 // RIGHTBTOM START 
									 ///////////////////////////////////////////////////////////////////////////////////////////////////
									 EasyImage::Threshold(&RotateImg,&RotateBinaryImg, ECThresHold);               // Corner Out GinrdThresHold 
									 EasyImage::Threshold(&RotateImg,&RotateGrindBinaryImg, CorGrindMeaThresHold); // Corner Measure GrindThresHold(3Point)

									 if(ECThresHold==0)    {SingleLine->GImage = &RotateImg      ;  SingleLine->FThreshold =5 ;}
									 else                  {SingleLine->GImage = &RotateBinaryImg;  SingleLine->FThreshold =10;}

									 SingleLine->IRoi->SetOrgX  ((int)FRBPoint.x-RBCornerWidth );
									 SingleLine->IRoi->SetOrgY  ((int)FRBPoint.y-RBCornerHeight);
									 SingleLine->IRoi->SetWidth ((int)RBCornerWidth+10         );
									 SingleLine->IRoi->SetHeight((int)RBCornerHeight           );

									 SingleLine->SetOrientation(orEast);
									 SingleLine->FIncrement =1;
									 SingleLine->FThreshold =15;
									 SingleLine->SetFindLineId(0);
									 SingleLine->SetEdgeType(1);  //White To Black 
									 SingleLine->OnExecute();

									 Line[6].FP0 = SingleLine->GetResultP0();
									 Line[6].FP1 = SingleLine->GetResultP1();

									 // ORG 
									 FRBRPoint = Math.OnIntersect(SingleLine->GetResultP0(), SingleLine->GetResultP1(), Line[waRightWall ].FP0, Line[waRightWall] .FP1);
									 FRBBPoint = Math.OnIntersect(SingleLine->GetResultP0(), SingleLine->GetResultP1(), Line[waBottomWall].FP0, Line[waBottomWall].FP1);

									 if((FRBRPoint.x==0 || FRBRPoint.y==0 || FRBBPoint.x==0 || FRBBPoint.y==0) || (SingleLine->FEdgePointCount <30)){
										 RBDx = 0.0f;
										 RBDy = 0.0f;
										 //화면에 디스플레이 위해서 
										 FRBRPoint.x = FRBPoint.x;
										 FRBRPoint.y = FRBPoint.y;
										 FRBBPoint.x = FRBPoint.x;
										 FRBBPoint.y = FRBPoint.y;
									 }
									 else { 
										 RBDx = Math.GetLengthFrPointToPoint(FRBPoint, FRBBPoint);
										 RBDy = Math.GetLengthFrPointToPoint(FRBPoint, FRBRPoint);

										 // OutLine C4Corner Data 
										 if((SingleLine->FEdgePointCount) - (CornerMargin*2)>0){
											 if(C4Point!=NULL) delete[] C4Point;
											 C4Point  = new TFPoint [(SingleLine->FEdgePointCount) - (CornerMargin*2)];
											 C4EdgeCount = (SingleLine->FEdgePointCount) -(CornerMargin*2);

											 CornerCount =0;  
											 for(int k=CornerMargin; k<((SingleLine->FEdgePointCount)-CornerMargin); k++){
												 if(CornerCount>=MAX_CORNER_POINT) break;
												 C4Point[CornerCount].x = SingleLine->FEdgePoint[k].x;
												 C4Point[CornerCount].y = SingleLine->FEdgePoint[k].y;
												 CornerCount++;
											 }
										 }

										 // Corner 기울기 완만하여 Edge찾을 경우 Defect 오버킬 발생함 
										 // 방향을 Top방향에서 다시 엣지를 찾음 (Corner Defect OverKill 감소 목적)
										 if(CorGrindInThresHold!=0){
											 EasyImage::Threshold(&RotateImg,&RotateBinaryImg, CorGrindInThresHold);
											 SingleLine->GImage = &RotateBinaryImg;  SingleLine->FThreshold =10;

											 if(RBCornerWidth >(RBCornerHeight*1.5)){
												 SingleLine->IRoi->SetOrgX  ((int)FRBBPoint.x                 ) ;
												 SingleLine->IRoi->SetOrgY  ((int)FRBBPoint.y - RBCornerHeight) ;
												 SingleLine->IRoi->SetWidth ((int)(RBCornerWidth+10           ));
												 SingleLine->IRoi->SetHeight((int)(RBCornerHeight             ));

												 if(FRBBPoint.x<=0    || FRBBPoint.y - RBCornerHeight<=0    || RBCornerWidth+10<=0    || RBCornerHeight+10 <=0    ) return false;
												 if(FRBBPoint.x>=ImgW || FRBBPoint.y - RBCornerHeight>=ImgH || RBCornerWidth+10>=ImgW || RBCornerHeight+10 >=ImgH ) return false;

												 SingleLine->SetOrientation(orSouth);
												 SingleLine->FIncrement =1;
												 SingleLine->SetFindLineId(0);
												 SingleLine->SetEdgeType(0);  //Black To White 
												 SingleLine->OnExecute();

												 // InLine C4Corner Data 
												 if((SingleLine->FEdgePointCount) - (CornerMargin*2)>0){
													 if(C4InPoint!=NULL) delete[] C4InPoint;
													 C4InPoint  = new TFPoint [(SingleLine->FEdgePointCount) - (CornerMargin*2)];
													 C4InEdgeCount = (SingleLine->FEdgePointCount) -(CornerMargin*2);

													 CornerCount =0;  
													 for(int k=CornerMargin; k<((SingleLine->FEdgePointCount)-CornerMargin); k++){
														 if(CornerCount>=MAX_CORNER_POINT) break;
														 C4InPoint[CornerCount].x = SingleLine->FEdgePoint[k].x;
														 C4InPoint[CornerCount].y = SingleLine->FEdgePoint[k].y;
														 CornerCount++;
													 }
												 }
											 }
											 else {
												 // Corner 연마 안쪽라인 찾는다 
												 SingleLine->SetOrientation(orEast);
												 SingleLine->SetFindLineId(0);
												 SingleLine->SetEdgeType(0);  //Black To White 
												 SingleLine->OnExecute();

												 // InLine C4Corner Data 
												 if((SingleLine->FEdgePointCount) - (CornerMargin*2)>0){
													 if(C4InPoint!=NULL) delete[] C4InPoint;
													 C4InPoint  = new TFPoint [(SingleLine->FEdgePointCount) - (CornerMargin*2)];
													 C4InEdgeCount = (SingleLine->FEdgePointCount) -(CornerMargin*2);

													 CornerCount =0;  
													 for(int k=CornerMargin; k<((SingleLine->FEdgePointCount)-CornerMargin); k++){
														 if(CornerCount>=MAX_CORNER_POINT) break;
														 C4InPoint[CornerCount].x = SingleLine->FEdgePoint[k].x;
														 C4InPoint[CornerCount].y = SingleLine->FEdgePoint[k].y;
														 CornerCount++;
													 }
												 }
											 }

											 //코너 연마안쪽라인 기준 새로운 교차점 생성 
											 FRBRInPoint = Math.OnIntersect(SingleLine->GetResultP0(), SingleLine->GetResultP1(), Line[waRightWall ].FP0, Line[waRightWall ].FP1);
											 FRBBInPoint = Math.OnIntersect(SingleLine->GetResultP0(), SingleLine->GetResultP1(), Line[waBottomWall].FP0, Line[waBottomWall].FP1);

											 //코너 연마폭 
											 Dis =0.0f, AvgGrindWidth=0.0f, AvgGrindMea=0.0f, TotalGrindWidth=0.0f, TotalGrindMeasure=0.0f;
											 for(int k=0; k<C4InEdgeCount; k++){
												 Dis = Math.GetLengthFrLineToPoint(FLBLPoint, FLBBPoint, C4InPoint[k]);
												 TotalGrindWidth+=Dis;
											 }
											 if(C4InEdgeCount!=0){
												 AvgGrindWidth = (TotalGrindWidth/C4InEdgeCount);
												 C4CorGrindWd  = AvgGrindWidth;
											 }
										 }

										 // 코너 연마량 기준 라인을 찾는다 
										 // ROI 영역 설정(3개의 흰색 점선 기준 라인을 찾는다)
										 if(CorGrindMeaThresHold!=0){
											 if(CorGrindMeaThresHold==0){SingleLine->GImage = &RotateImg           ;  SingleLine->FThreshold =5 ;}
											 else                       {SingleLine->GImage = &RotateGrindBinaryImg;  SingleLine->FThreshold =10;}

											 SingleLine->IRoi->SetOrgX  ((int)FRBPoint.x -RBCornerWidth -20 );
											 SingleLine->IRoi->SetOrgY  ((int)FRBPoint.y -RBCornerHeight +20);
											 SingleLine->IRoi->SetWidth ((int)RBCornerWidth                 );
											 SingleLine->IRoi->SetHeight((int)RBCornerHeight                );

											 SingleLine->SetOrientation(orEast);
											 SingleLine->SetFindLineId(0);
											 SingleLine->SetEdgeType(0);  //Black To White 
											 SingleLine->OnExecute();

											 P1 = SingleLine->GetResultP0();
											 P2 = SingleLine->GetResultP1();

											 //코너 연마량 기준 라인과 새로운 교차점 생성 
											 FRBRMeaPoint = Math.OnIntersect(SingleLine->GetResultP0(), SingleLine->GetResultP1(), Line[waRightWall ].FP0, Line[waRightWall ].FP1);
											 FRBBMeaPoint = Math.OnIntersect(SingleLine->GetResultP0(), SingleLine->GetResultP1(), Line[waBottomWall].FP0, Line[waBottomWall].FP1);

											 // C4Corner Grind Measure Stand Data 
											 if((SingleLine->FEdgePointCount)>0){
												 if(C4MeaPoint!=NULL) delete[] C4MeaPoint;
												 C4MeaPoint     = new TFPoint [(SingleLine->FEdgePointCount)];
												 C4MeaEdgeCount = (SingleLine->FEdgePointCount);

												 CornerCount =0;  
												 for(int k=0; k<(SingleLine->FEdgePointCount); k++){
													 if(CornerCount>=MAX_CORNER_POINT) break;
													 C4MeaPoint[CornerCount].x = SingleLine->FEdgePoint[k].x;
													 C4MeaPoint[CornerCount].y = SingleLine->FEdgePoint[k].y;
													 CornerCount++;
												 }
											 }
											 //코너 연마량 계산  
											 Dis =0.0f, AvgGrindMea=0.0f, TotalGrindMeasure=0.0f;
											 for(int k=0; k<C4MeaEdgeCount; k++){
												 Dis = Math.GetLengthFrLineToPoint(FRBRPoint, FRBBPoint, C4MeaPoint[k]);
												 TotalGrindMeasure+=Dis;
											 }
											 if(C4MeaEdgeCount!=0){
												 AvgGrindMea    = (TotalGrindMeasure/C4MeaEdgeCount);
												 C4CorGrindMea  = AvgGrindMea;
											 }
										 }
									 }	
									 // RightBottom End 
									 ///////////////////////////////////////////////////////////////////////////////////////////////////
								 }
								 else { // GrindMark 기준으로 연마량,가공량 측정 
									 double Dis =0.0f, AvgGrindWidth=0.0f, AvgGrindMea=0.0f, TotalGrindWidth=0.0f, TotalGrindMeasure=0.0f;

									 EasyImage::Threshold(&RotateImg,&RotateBinaryImg, ECThresHold);               // Corner Out GinrdThresHold 
									 EasyImage::Threshold(&RotateImg,&RotateGrindBinaryImg, CorGrindMeaThresHold); // Corner Measure GrindThresHold(3Point)

									 if(ECThresHold==0)    {SingleLine->GImage = &RotateImg      ;  SingleLine->FThreshold =5 ;}
									 else                  {SingleLine->GImage = &RotateBinaryImg;  SingleLine->FThreshold =10;}

									 // LEFTBTM START 
									 ///////////////////////////////////////////////////////////////////////////////////////////////////
									 SingleLine->IRoi->SetOrgX  ((int)FLBPoint.x-10            );
									 SingleLine->IRoi->SetOrgY  ((int)FLBPoint.y-LBCornerHeight);
									 SingleLine->IRoi->SetWidth ((int)LBCornerWidth+20         );
									 SingleLine->IRoi->SetHeight((int)LBCornerHeight           );

									 SingleLine->SetOrientation(orWest);
									 SingleLine->FIncrement =1;
									 SingleLine->FThreshold =15;
									 SingleLine->SetFindLineId(0);
									 SingleLine->SetEdgeType(1);  //White To Black 
									 SingleLine->OnExecute();

									 Line[7].FP0 = SingleLine->GetResultP0();
									 Line[7].FP1 = SingleLine->GetResultP1();

									 // ORG 
									 FLBLPoint = Math.OnIntersect(SingleLine->GetResultP0(), SingleLine->GetResultP1(), Line[waLeftWall].FP0   , Line[waLeftWall].FP1);
									 FLBBPoint = Math.OnIntersect(SingleLine->GetResultP0(), SingleLine->GetResultP1(), Line[waBottomWall ].FP0, Line[waBottomWall ].FP1);

									 if((FLBLPoint.x==0 || FLBLPoint.y==0 || FLBBPoint.x==0 || FLBBPoint.y==0) || (SingleLine->FEdgePointCount <30)){
										 LBDx = 0.0f;
										 LBDy = 0.0f;
										 //화면에 디스플레이 위해서 
										 FLBLPoint.x = FLBPoint.x;
										 FLBLPoint.y = FLBPoint.y;
										 FLBBPoint.x = FLBPoint.x;
										 FLBBPoint.y = FLBPoint.y;
									 }
									 else { 
										 LBDx = Math.GetLengthFrPointToPoint(FLBPoint, FLBBPoint);
										 LBDy = Math.GetLengthFrPointToPoint(FLBPoint, FLBLPoint);

										 // OutLine C3Corner Data 
										 if((SingleLine->FEdgePointCount) - (CornerMargin*2)>0){
											 if(C3Point!=NULL) delete[] C3Point;
											 C3Point  = new TFPoint [(SingleLine->FEdgePointCount) - (CornerMargin*2)];
											 C3EdgeCount = (SingleLine->FEdgePointCount) -(CornerMargin*2);

											 CornerCount =0;  
											 for(int k=CornerMargin; k<((SingleLine->FEdgePointCount)-CornerMargin); k++){
												 if(CornerCount>=MAX_CORNER_POINT) break;
												 C3Point[CornerCount].x = SingleLine->FEdgePoint[k].x;
												 C3Point[CornerCount].y = SingleLine->FEdgePoint[k].y;
												 CornerCount++;
											 }
										 }

										 // Corner 연마 안쪽라인 
										 if(CorGrindInThresHold!=0){
											 EasyImage::Threshold(&RotateImg,&RotateBinaryImg, CorGrindInThresHold);
											 SingleLine->GImage = &RotateBinaryImg;  SingleLine->FThreshold =10;

											 // Corner 기울기 완만하여 Edge찾을 경우 Defect 오버킬 발생함 
											 // 방향을 Top방향에서 다시 엣지를 찾음 (Corner Defect OverKill 감소 목적)
											 if(LBCornerWidth >(LBCornerHeight*1.5)){
												 SingleLine->IRoi->SetOrgX  ((int)FLBPoint.x );
												 SingleLine->IRoi->SetOrgY  ((int)FLBPoint.y - LBCornerHeight    );
												 SingleLine->IRoi->SetWidth ((int)((FLBBPoint.x - FLBPoint.x)+20));
												 SingleLine->IRoi->SetHeight((int)((FLBPoint.y  - FLBLPoint.y)  ));

												 if(FLBPoint.x<=0    || FLBPoint.y - LBCornerHeight<=0    || (FLBBPoint.x - FLBPoint.x )<=0    || ((FLBPoint.y  - FLBLPoint.y)+20)<=0   ) return false;
												 if(FLBPoint.x>=ImgW || FLBPoint.y - LBCornerHeight>=ImgH || (FLBBPoint.x - FLBPoint.x )>=ImgW || ((FLBPoint.y  - FLBLPoint.y)+20)>=ImgH) return false;

												 SingleLine->SetOrientation(orSouth);
												 SingleLine->FIncrement =1;
												 SingleLine->SetFindLineId(0);
												 SingleLine->SetEdgeType(0);  //Black To White 
												 SingleLine->OnExecute();

												 // InLine C3Corner Data 
												 if((SingleLine->FEdgePointCount) - (CornerMargin*2)>0){
													 if(C3InPoint!=NULL) delete[] C3InPoint;
													 C3InPoint  = new TFPoint [(SingleLine->FEdgePointCount) - (CornerMargin*2)];
													 C3InEdgeCount = (SingleLine->FEdgePointCount) -(CornerMargin*2);

													 CornerCount =0;  
													 for(int k=CornerMargin; k<((SingleLine->FEdgePointCount)-CornerMargin); k++){
														 if(CornerCount>=MAX_CORNER_POINT) break;
														 C3InPoint[CornerCount].x = SingleLine->FEdgePoint[k].x;
														 C3InPoint[CornerCount].y = SingleLine->FEdgePoint[k].y;
														 CornerCount++;
													 }
												 }
											 }
											 else {
												 // Corner 연마 안쪽라인 찾는다 
												 SingleLine->SetOrientation(orWest);
												 SingleLine->SetFindLineId(0);
												 SingleLine->SetEdgeType(0);  //Black To White 
												 SingleLine->OnExecute();

												 // InLine C1Corner Data 
												 if((SingleLine->FEdgePointCount) - (CornerMargin*2)>0){
													 if(C3InPoint!=NULL) delete[] C3InPoint;
													 C3InPoint  = new TFPoint [(SingleLine->FEdgePointCount) - (CornerMargin*2)];
													 C3InEdgeCount = (SingleLine->FEdgePointCount) -(CornerMargin*2);

													 CornerCount =0;  
													 for(int k=CornerMargin; k<((SingleLine->FEdgePointCount)-CornerMargin); k++){
														 if(CornerCount>=MAX_CORNER_POINT) break;
														 C3InPoint[CornerCount].x = SingleLine->FEdgePoint[k].x;
														 C3InPoint[CornerCount].y = SingleLine->FEdgePoint[k].y;
														 CornerCount++;
													 }
												 }
											 }

											 //코너 연마안쪽라인 기준 새로운 교차점 생성 
											 FLBLInPoint = Math.OnIntersect(SingleLine->GetResultP0(), SingleLine->GetResultP1(), Line[waLeftWall].FP0   , Line[waLeftWall].FP1);
											 FLBBInPoint = Math.OnIntersect(SingleLine->GetResultP0(), SingleLine->GetResultP1(), Line[waBottomWall ].FP0, Line[waBottomWall ].FP1);
										 }

										 // GrindMark기준 연마량,가공량 측정함 
										 // LeftBtm 
										 if(GrindRectSpec[1].DvX!=0.0f && GrindRectSpec[1].DvY!=0.0f){
											 GrindMarkRect[1].left = (FLBPoint.x + GrindRectSpec[1].DvX) -GrindMarkRange;
											 GrindMarkRect[1].top  = (FLBPoint.y - GrindRectSpec[1].DvY) -GrindMarkRange;
											 GrindMarkRect[1].right  = GrindMarkRect[1].left+GrindMarkLength;
											 GrindMarkRect[1].bottom = GrindMarkRect[1].top +GrindMarkLength;

											 // 원본이미지에서 Mark 찾는다 
											 Find->OnLoad(true,FindDir)                     ;
											 Find->GImage = &RotateImg                      ;
											 Find->SetContrastMode(EFindContrastMode_Normal);
											 Find->SetMinScore (GrindPadMarkMinScore)       ; // PatternrFind 검사 최소 Score
											 Find->SetZeroScore(GrindPadMarkMinScore)       ; // 검사 후 최소 Score 
											 Find->SetMaxInstances(1)                       ;
											 Find->SetAngleTolerance(20.0f)                 ;
											 Find->SetAngleBias(45.0f)                      ;
											 Find->SetScaleBias(1.00f)                      ;
											 Find->SetScaleTolerance(0.0f)                  ;
											 Find->Property.Ox = (float)ImgW/2              ;
											 Find->Property.Oy = (float)ImgH/2              ;

											 GrindRectWidth  = (GrindMarkRect[1].right  - GrindMarkRect[1].left);
											 GrindRectHeight = (GrindMarkRect[1].bottom - GrindMarkRect[1].top );
											 Find->IRoi->SetPlacement(GrindMarkRect[1].left,GrindMarkRect[1].top,GrindRectWidth,GrindRectHeight);
											 if(GrindMarkRect[1].left<=0    || GrindMarkRect[1].top<=0    || GrindRectWidth<=0    || GrindRectHeight<=0   ) return false;
											 if(GrindMarkRect[1].left>=ImgW || GrindMarkRect[1].top>=ImgH || GrindRectWidth>=ImgW || GrindRectHeight>=ImgH) return false;

											 // 검사 및 Match Pos 좌표 받어온다 
											 // Find 검사 성공시 데이터 받아옴 
											 if(Find->OnExecute()){
												 GrindMarkPoint[1].x = Find->Result[0].Px;
												 GrindMarkPoint[1].y = Find->Result[0].Py;
												 GrindMarkScore[1]   = Find->Result[0].Score;
											 }
											 // Contrast Gradient Pixel Value
											 GrindMarkGradient[1] = EasyImage::Focusing(Find->IRoi);

											 // Left CellSize 측정 목적 
											 ///////////////////////////////////////////////////////////////////////////////////
											 GrindMarkRect[2].left = (FLBPoint.x + GrindRectSpec[2].DvX) -GrindMarkRange;
											 GrindMarkRect[2].top  = (FLBPoint.y - GrindRectSpec[2].DvY) -GrindMarkRange;
											 GrindMarkRect[2].right  = GrindMarkRect[2].left+GrindMarkLength;
											 GrindMarkRect[2].bottom = GrindMarkRect[2].top +GrindMarkLength;

											 GrindRectWidth  = (GrindMarkRect[2].right  - GrindMarkRect[2].left);
											 GrindRectHeight = (GrindMarkRect[2].bottom - GrindMarkRect[2].top );
											 Find->IRoi->SetPlacement(GrindMarkRect[2].left,GrindMarkRect[2].top,GrindRectWidth,GrindRectHeight);
											 if(GrindMarkRect[2].left<=0    || GrindMarkRect[2].top<=0    || GrindRectWidth<=0    || GrindRectHeight<=0   ) return false;
											 if(GrindMarkRect[2].left>=ImgW || GrindMarkRect[2].top>=ImgH || GrindRectWidth>=ImgW || GrindRectHeight>=ImgH) return false;

											 // 검사 및 Match Pos 좌표 받어온다 
											 // Find 검사 성공시 데이터 받아옴 
											 Find->SetAngleBias(0.0f);
											 if(Find->OnExecute()){
												 GrindMarkPoint[2].x = Find->Result[0].Px;
												 GrindMarkPoint[2].y = Find->Result[0].Py;
												 GrindMarkScore[2]   = Find->Result[0].Score;

												 // Chamber CUt 기준 Cell Size 측정 
												 if(Line[3].FP0.x!=0.0f && Line[3].FP0.y!=0.0f && Line[3].FP1.x!=0.0f && Line[3].FP1.y!=0.0f){
													 BtmGrindMeasure1 = Math.GetLengthFrLineToPoint(Line[3].FP0, Line[3].FP1, GrindMarkPoint[2]);
												 }
											 }
											 ///////////////////////////////////////////////////////////////////////////////////
										 }

										 // GrindMakr찾을경우 연마량,가공량 측정함
										 if(GrindMarkPoint[1].x!=0.0f && GrindMarkPoint[1].y!=0.0f){
											 // GrindMark기준 OutData 최단거리 Count정보 Calc 
											 GrindMeaDis =0.0f, MinDis =10000.0f; GrindMarkOutCnt=0;
											 for(int k=0; k<C3EdgeCount; k++){
												 if(C3Point[k].x  ==0.0f       || C3Point[k].y       ==0.0f) continue;
												 if(GrindMarkPoint[1].x==0.0f  || GrindMarkPoint[1].y==0.0f) continue;

												 GrindMeaDis = Math.GetLength(GrindMarkPoint[1], C3Point[k]);
												 if(GrindMeaDis<MinDis){
													 MinDis = GrindMeaDis;
													 GrindMarkOutCnt = k;
												 }
											 }
											 // OutData기준 InData 최단거리 Count정보 Calc 
											 if(GrindMarkOutCnt!=0){
												 GrindMeaDis =0.0f, MinDis =10000.0f; GrindMarkInCnt=0;
												 for(int k=0; k<C3InEdgeCount; k++){
													 if(C3InPoint[k].x   ==0.0f          || C3InPoint[k].y             ==0.0f) continue;
													 if(C3Point[GrindMarkOutCnt].x==0.0f || C3Point[GrindMarkOutCnt].y ==0.0f) continue;

													 GrindMeaDis = Math.GetLength(C3Point[GrindMarkOutCnt], C3InPoint[k]);
													 if(GrindMeaDis<MinDis){
														 MinDis = GrindMeaDis;
														 GrindMarkInCnt = k;
													 }
												 }
											 }

											 // GrindMark기준 수직 포인트 주변값 Avg산출한다 ==>가공량 측정(OutData기준)
											 if(GrindMarkOutCnt!=0 && GrindMarkOutCnt>5){
												 CircleCount=0,TotalCirDis=0.0f,GrindMeaDis=0.0f;
												 for(int k=GrindMarkOutCnt-5; k<GrindMarkOutCnt+5; k++){
													 if(C3Point[k].x==0.0f || C3Point[k].y==0.0f) continue;
													 if(k>=C3EdgeCount                          ) continue;

													 GrindMeaDis = Math.GetLength(GrindMarkPoint[1], C3Point[k]);
													 TotalCirDis+= GrindMeaDis;
													 CircleCount++;
												 }
												 if(TotalCirDis!=0.0f && CircleCount!=0){
													 C3CorGrindMea = TotalCirDis/CircleCount;
												 }
											 }

											 // GrindMark기준 수직 포인트 주변값 Avg산출한다 ==>연마량 측정(OutData,InData기준)
											 if((GrindMarkOutCnt!=0 && GrindMarkOutCnt>5) && (GrindMarkInCnt!=0 && GrindMarkInCnt>5)){
												 CircleCount=0,TotalCirDis=0.0f,GrindWidthDis=0.0f;
												 for(int k=-5; k<5; k++){
													 if(C3Point  [GrindMarkOutCnt+k].x==0.0f && C3Point  [GrindMarkOutCnt+k].y==0.0f) continue;
													 if(C3InPoint[GrindMarkInCnt +k].x==0.0f && C3InPoint[GrindMarkInCnt +k].y==0.0f) continue;
													 if((GrindMarkOutCnt+k)>=C3EdgeCount                                            ) continue;
													 if((GrindMarkInCnt +k)>=C3InEdgeCount                                          ) continue;

													 GrindWidthDis = Math.GetLength(C3InPoint[GrindMarkInCnt+k], C3Point[GrindMarkOutCnt+k]);
													 TotalCirDis+=   GrindWidthDis;
													 CircleCount++;
												 }
												 if(TotalCirDis!=0.0f && CircleCount!=0){
													 C3CorGrindWd  = TotalCirDis/CircleCount;
												 }
											 }
										 }
										 else { // GrindMrk 못찾을경우 연마량만 측정함 
											 // OutData기준 최소값 데이터 Count산출 
											 GrindMeaDis =0.0f, MinDis =10000.0f; GrindMarkOutCnt=0;
											 for(int k=0; k<C3EdgeCount; k++){
												 if(C3Point[k].x==0.0f || C3Point[k].y==0.0f) continue;

												 GrindMarkRectCenter[1].x = GrindMarkRect[1].left + (GrindMarkRect[1].right  - GrindMarkRect[1].left)/2; 
												 GrindMarkRectCenter[1].y = GrindMarkRect[1].top  + (GrindMarkRect[1].bottom - GrindMarkRect[1].top )/2; 

												 GrindMeaDis = Math.GetLength(GrindMarkRectCenter[1], C3Point[k]);
												 if(GrindMeaDis<MinDis){
													 MinDis = GrindMeaDis;
													 GrindMarkOutCnt = k;
												 }
											 }

											 // 최단거리OUtCount기준 InData 최단거리 Count정보 Calc 
											 if(GrindMarkOutCnt!=0){
												 GrindMeaDis =0.0f, MinDis =10000.0f; GrindMarkInCnt=0;
												 for(int k=0; k<C3InEdgeCount; k++){
													 if(C3InPoint[k].x            ==0.0f || C3InPoint[k].y             ==0.0f) continue;
													 if(C3Point[GrindMarkOutCnt].x==0.0f || C3Point[GrindMarkOutCnt].y ==0.0f) continue;

													 GrindMeaDis = Math.GetLength(C3Point[GrindMarkOutCnt], C3InPoint[k]);
													 if(GrindMeaDis<MinDis){
														 MinDis = GrindMeaDis;
														 GrindMarkInCnt = k;
													 }
												 }
											 }

											 // GrindMark기준 수직 포인트 주변값 Avg산출한다 ==>연마량 측정(OutData,InData기준)
											 if((GrindMarkOutCnt!=0 && GrindMarkOutCnt>5) && (GrindMarkInCnt!=0 && GrindMarkInCnt>5)){
												 CircleCount=0,TotalCirDis=0.0f,GrindWidthDis=0.0f;
												 for(int k=-5; k<5; k++){
													 if(C3Point  [GrindMarkOutCnt+k].x==0.0f && C3Point  [GrindMarkOutCnt+k].y==0.0f) continue;
													 if(C3InPoint[GrindMarkInCnt +k].x==0.0f && C3InPoint[GrindMarkInCnt +k].y==0.0f) continue;
													 if((GrindMarkOutCnt+k)>=C3EdgeCount                                            ) continue;
													 if((GrindMarkInCnt +k)>=C3InEdgeCount                                          ) continue;

													 GrindWidthDis = Math.GetLength(C3InPoint[GrindMarkInCnt+k], C3Point[GrindMarkOutCnt+k]);
													 TotalCirDis+=   GrindWidthDis;
													 CircleCount++;
												 }
												 if(TotalCirDis!=0.0f && CircleCount!=0){
													 C3CorGrindWd = TotalCirDis/CircleCount;
												 }
											 }
										 }
									 }	
									 // LEFTBTM END 
									 ///////////////////////////////////////////////////////////////////////////////////////////////////


									 // RIGHTBTOM START 
									 ///////////////////////////////////////////////////////////////////////////////////////////////////
									 EasyImage::Threshold(&RotateImg,&RotateBinaryImg, ECThresHold);               // Corner Out GinrdThresHold 
									 EasyImage::Threshold(&RotateImg,&RotateGrindBinaryImg, CorGrindMeaThresHold); // Corner Measure GrindThresHold(3Point)

									 if(ECThresHold==0)    {SingleLine->GImage = &RotateImg      ;  SingleLine->FThreshold =5 ;}
									 else                  {SingleLine->GImage = &RotateBinaryImg;  SingleLine->FThreshold =10;}

									 SingleLine->IRoi->SetOrgX  ((int)FRBPoint.x-RBCornerWidth );
									 SingleLine->IRoi->SetOrgY  ((int)FRBPoint.y-RBCornerHeight);
									 SingleLine->IRoi->SetWidth ((int)RBCornerWidth+10         );
									 SingleLine->IRoi->SetHeight((int)RBCornerHeight           );

									 SingleLine->SetOrientation(orEast);
									 SingleLine->FIncrement =1;
									 SingleLine->FThreshold =15;
									 SingleLine->SetFindLineId(0);
									 SingleLine->SetEdgeType(1);  //White To Black 
									 SingleLine->OnExecute();

									 Line[6].FP0 = SingleLine->GetResultP0();
									 Line[6].FP1 = SingleLine->GetResultP1();

									 // ORG 
									 FRBRPoint = Math.OnIntersect(SingleLine->GetResultP0(), SingleLine->GetResultP1(), Line[waRightWall ].FP0, Line[waRightWall] .FP1);
									 FRBBPoint = Math.OnIntersect(SingleLine->GetResultP0(), SingleLine->GetResultP1(), Line[waBottomWall].FP0, Line[waBottomWall].FP1);

									 if((FRBRPoint.x==0 || FRBRPoint.y==0 || FRBBPoint.x==0 || FRBBPoint.y==0) || (SingleLine->FEdgePointCount <30)){
										 RBDx = 0.0f;
										 RBDy = 0.0f;
										 //화면에 디스플레이 위해서 
										 FRBRPoint.x = FRBPoint.x;
										 FRBRPoint.y = FRBPoint.y;
										 FRBBPoint.x = FRBPoint.x;
										 FRBBPoint.y = FRBPoint.y;
									 }
									 else { 
										 RBDx = Math.GetLengthFrPointToPoint(FRBPoint, FRBBPoint);
										 RBDy = Math.GetLengthFrPointToPoint(FRBPoint, FRBRPoint);

										 // OutLine C4Corner Data 
										 if((SingleLine->FEdgePointCount) - (CornerMargin*2)>0){
											 if(C4Point!=NULL) delete[] C4Point;
											 C4Point  = new TFPoint [(SingleLine->FEdgePointCount) - (CornerMargin*2)];
											 C4EdgeCount = (SingleLine->FEdgePointCount) -(CornerMargin*2);

											 CornerCount =0;  
											 for(int k=CornerMargin; k<((SingleLine->FEdgePointCount)-CornerMargin); k++){
												 if(CornerCount>=MAX_CORNER_POINT) break;
												 C4Point[CornerCount].x = SingleLine->FEdgePoint[k].x;
												 C4Point[CornerCount].y = SingleLine->FEdgePoint[k].y;
												 CornerCount++;
											 }
										 }

										 // Corner 기울기 완만하여 Edge찾을 경우 Defect 오버킬 발생함 
										 // 방향을 Top방향에서 다시 엣지를 찾음 (Corner Defect OverKill 감소 목적)
										 if(CorGrindInThresHold!=0){
											 EasyImage::Threshold(&RotateImg,&RotateBinaryImg, CorGrindInThresHold);
											 SingleLine->GImage = &RotateBinaryImg;  SingleLine->FThreshold =10;

											 if(RBCornerWidth >(RBCornerHeight*1.5)){
												 SingleLine->IRoi->SetOrgX  ((int)FRBBPoint.x                 ) ;
												 SingleLine->IRoi->SetOrgY  ((int)FRBBPoint.y - RBCornerHeight) ;
												 SingleLine->IRoi->SetWidth ((int)(RBCornerWidth+10           ));
												 SingleLine->IRoi->SetHeight((int)(RBCornerHeight             ));

												 if(FRBBPoint.x<=0    || FRBBPoint.y - RBCornerHeight<=0    || RBCornerWidth+10<=0    || RBCornerHeight+10 <=0    ) return false;
												 if(FRBBPoint.x>=ImgW || FRBBPoint.y - RBCornerHeight>=ImgH || RBCornerWidth+10>=ImgW || RBCornerHeight+10 >=ImgH ) return false;

												 SingleLine->SetOrientation(orSouth);
												 SingleLine->FIncrement =1;
												 SingleLine->SetFindLineId(0);
												 SingleLine->SetEdgeType(0);  //Black To White 
												 SingleLine->OnExecute();

												 // InLine C4Corner Data 
												 if((SingleLine->FEdgePointCount) - (CornerMargin*2)>0){
													 if(C4InPoint!=NULL) delete[] C4InPoint;
													 C4InPoint  = new TFPoint [(SingleLine->FEdgePointCount) - (CornerMargin*2)];
													 C4InEdgeCount = (SingleLine->FEdgePointCount) -(CornerMargin*2);

													 CornerCount =0;  
													 for(int k=CornerMargin; k<((SingleLine->FEdgePointCount)-CornerMargin); k++){
														 if(CornerCount>=MAX_CORNER_POINT) break;
														 C4InPoint[CornerCount].x = SingleLine->FEdgePoint[k].x;
														 C4InPoint[CornerCount].y = SingleLine->FEdgePoint[k].y;
														 CornerCount++;
													 }
												 }
											 }
											 else {
												 // Corner 연마 안쪽라인 찾는다 
												 SingleLine->SetOrientation(orEast);
												 SingleLine->SetFindLineId(0);
												 SingleLine->SetEdgeType(0);  //Black To White 
												 SingleLine->OnExecute();

												 // InLine C4Corner Data 
												 if((SingleLine->FEdgePointCount) - (CornerMargin*2)>0){
													 if(C4InPoint!=NULL) delete[] C4InPoint;
													 C4InPoint  = new TFPoint [(SingleLine->FEdgePointCount) - (CornerMargin*2)];
													 C4InEdgeCount = (SingleLine->FEdgePointCount) -(CornerMargin*2);

													 CornerCount =0;  
													 for(int k=CornerMargin; k<((SingleLine->FEdgePointCount)-CornerMargin); k++){
														 if(CornerCount>=MAX_CORNER_POINT) break;
														 C4InPoint[CornerCount].x = SingleLine->FEdgePoint[k].x;
														 C4InPoint[CornerCount].y = SingleLine->FEdgePoint[k].y;
														 CornerCount++;
													 }
												 }
											 }

											 //코너 연마안쪽라인 기준 새로운 교차점 생성 
											 FRBRInPoint = Math.OnIntersect(SingleLine->GetResultP0(), SingleLine->GetResultP1(), Line[waRightWall ].FP0, Line[waRightWall ].FP1);
											 FRBBInPoint = Math.OnIntersect(SingleLine->GetResultP0(), SingleLine->GetResultP1(), Line[waBottomWall].FP0, Line[waBottomWall].FP1);
										 }

										 // GrindMark기준 연마량,가공량 측정함 
										 // RightBtm 
										 if(GrindRectSpec[1].DvX!=0.0f && GrindRectSpec[1].DvY!=0.0f){
											 GrindMarkRect[17].left = (FRBPoint.x - GrindRectSpec[1].DvX) -GrindMarkRange;
											 GrindMarkRect[17].top  = (FRBPoint.y - GrindRectSpec[1].DvY) -GrindMarkRange;
											 GrindMarkRect[17].right  = GrindMarkRect[17].left+GrindMarkLength;
											 GrindMarkRect[17].bottom = GrindMarkRect[17].top +GrindMarkLength;

											 // 원본이미지에서 Mark 찾는다 
											 Find->OnLoad(true,FindDir)                     ;
											 Find->GImage = &RotateImg                      ;
											 Find->SetContrastMode(EFindContrastMode_Normal);
											 Find->SetMinScore (GrindPadMarkMinScore)       ; // PatternrFind 검사 최소 Score
											 Find->SetZeroScore(GrindPadMarkMinScore)       ; // 검사 후 최소 Score 
											 Find->SetMaxInstances(1)                       ;
											 Find->SetAngleTolerance(20.0f)                 ;
											 Find->SetAngleBias(315.0f)                     ;
											 Find->SetScaleBias(1.00f)                      ;
											 Find->SetScaleTolerance(0.0f)                  ;
											 Find->Property.Ox = (float)ImgW/2              ;
											 Find->Property.Oy = (float)ImgH/2              ;

											 GrindRectWidth  = (GrindMarkRect[17].right  - GrindMarkRect[17].left);
											 GrindRectHeight = (GrindMarkRect[17].bottom - GrindMarkRect[17].top );
											 Find->IRoi->SetPlacement(GrindMarkRect[17].left,GrindMarkRect[17].top,GrindRectWidth,GrindRectHeight);
											 if(GrindMarkRect[17].left<=0    || GrindMarkRect[17].top<=0    || GrindRectWidth<=0    || GrindRectHeight<=0   ) return false;
											 if(GrindMarkRect[17].left>=ImgW || GrindMarkRect[17].top>=ImgH || GrindRectWidth>=ImgW || GrindRectHeight>=ImgH) return false;

											 // 검사 및 Match Pos 좌표 받어온다 
											 // Find 검사 성공시 데이터 받아옴 
											 if(Find->OnExecute()){
												 GrindMarkPoint[17].x = Find->Result[0].Px;
												 GrindMarkPoint[17].y = Find->Result[0].Py;
												 GrindMarkScore[17]   = Find->Result[0].Score;
											 }
											 // Contrast Gradient Pixel Value
											 GrindMarkGradient[17] = EasyImage::Focusing(Find->IRoi);

											 // Right CellSize 측정 목적 
											 ///////////////////////////////////////////////////////////////////////////////////
											 GrindMarkRect[16].left = (FRBPoint.x - GrindRectSpec[2].DvX) -GrindMarkRange;
											 GrindMarkRect[16].top  = (FRBPoint.y - GrindRectSpec[2].DvY) -GrindMarkRange;
											 GrindMarkRect[16].right  = GrindMarkRect[16].left+GrindMarkLength;
											 GrindMarkRect[16].bottom = GrindMarkRect[16].top +GrindMarkLength;

											 GrindRectWidth  = (GrindMarkRect[16].right  - GrindMarkRect[16].left);
											 GrindRectHeight = (GrindMarkRect[16].bottom - GrindMarkRect[16].top );
											 Find->IRoi->SetPlacement(GrindMarkRect[16].left,GrindMarkRect[16].top,GrindRectWidth,GrindRectHeight);
											 if(GrindMarkRect[16].left<=0    || GrindMarkRect[16].top<=0    || GrindRectWidth<=0    || GrindRectHeight<=0   ) return false;
											 if(GrindMarkRect[16].left>=ImgW || GrindMarkRect[16].top>=ImgH || GrindRectWidth>=ImgW || GrindRectHeight>=ImgH) return false;

											 // 검사 및 Match Pos 좌표 받어온다 
											 // Find 검사 성공시 데이터 받아옴 
											 Find->SetAngleBias(0.0f);
											 if(Find->OnExecute()){
												 GrindMarkPoint[16].x = Find->Result[0].Px;
												 GrindMarkPoint[16].y = Find->Result[0].Py;
												 GrindMarkScore[16]   = Find->Result[0].Score;

												 // Chamber CUt 기준 Cell Size 측정 
												 if(Line[3].FP0.x!=0.0f && Line[3].FP0.y!=0.0f && Line[3].FP1.x!=0.0f && Line[3].FP1.y!=0.0f){
													 BtmGrindMeasure9 = Math.GetLengthFrLineToPoint(Line[3].FP0, Line[3].FP1, GrindMarkPoint[16]);
												 }
											 }
										 }

										 // GrindMakr찾을경우 연마량,가공량 측정함
										 if(GrindMarkPoint[17].x!=0.0f && GrindMarkPoint[17].y!=0.0f){
											 // GrindMark기준 OutData 최단거리 Count정보 Calc 
											 GrindMeaDis =0.0f, MinDis =10000.0f; GrindMarkOutCnt=0;
											 for(int k=0; k<C4EdgeCount; k++){
												 if(C4Point[k].x  ==0.0f       || C4Point[k].y        ==0.0f) continue;
												 if(GrindMarkPoint[17].x==0.0f || GrindMarkPoint[17].y==0.0f) continue;

												 GrindMeaDis = Math.GetLength(GrindMarkPoint[17], C4Point[k]);
												 if(GrindMeaDis<MinDis){
													 MinDis = GrindMeaDis;
													 GrindMarkOutCnt = k;
												 }
											 }
											 // OutData기준 InData 최단거리 Count정보 Calc 
											 if(GrindMarkOutCnt!=0){
												 GrindMeaDis =0.0f, MinDis =10000.0f; GrindMarkInCnt=0;
												 for(int k=0; k<C4InEdgeCount; k++){
													 if(C4InPoint[k].x   ==0.0f          || C4InPoint[k].y             ==0.0f) continue;
													 if(C4Point[GrindMarkOutCnt].x==0.0f || C4Point[GrindMarkOutCnt].y ==0.0f) continue;

													 GrindMeaDis = Math.GetLength(C4Point[GrindMarkOutCnt], C4InPoint[k]);
													 if(GrindMeaDis<MinDis){
														 MinDis = GrindMeaDis;
														 GrindMarkInCnt = k;
													 }
												 }
											 }

											 // GrindMark기준 수직 포인트 주변값 Avg산출한다 ==>가공량 측정(OutData기준)
											 if(GrindMarkOutCnt!=0 && GrindMarkOutCnt>5){
												 CircleCount=0,TotalCirDis=0.0f,GrindMeaDis=0.0f;
												 for(int k=GrindMarkOutCnt-5; k<GrindMarkOutCnt+5; k++){
													 if(C4Point[k].x==0.0f || C4Point[k].y==0.0f) continue;
													 if(k>=C4EdgeCount                          ) continue;

													 GrindMeaDis = Math.GetLength(GrindMarkPoint[17], C4Point[k]);
													 TotalCirDis+= GrindMeaDis;
													 CircleCount++;
												 }
												 if(TotalCirDis!=0.0f && CircleCount!=0){
													 C4CorGrindMea = TotalCirDis/CircleCount;
												 }
											 }

											 // GrindMark기준 수직 포인트 주변값 Avg산출한다 ==>연마량 측정(OutData,InData기준)
											 if((GrindMarkOutCnt!=0 && GrindMarkOutCnt>5) && (GrindMarkInCnt!=0 && GrindMarkInCnt>5)){
												 CircleCount=0,TotalCirDis=0.0f,GrindWidthDis=0.0f;
												 for(int k=-5; k<5; k++){
													 if(C4Point  [GrindMarkOutCnt+k].x==0.0f && C4Point  [GrindMarkOutCnt+k].y==0.0f) continue;
													 if(C4InPoint[GrindMarkInCnt +k].x==0.0f && C4InPoint[GrindMarkInCnt +k].y==0.0f) continue;
													 if((GrindMarkOutCnt+k)>=C4EdgeCount                                            ) continue;
													 if((GrindMarkInCnt +k)>=C4InEdgeCount                                          ) continue;

													 GrindWidthDis = Math.GetLength(C4InPoint[GrindMarkInCnt+k], C4Point[GrindMarkOutCnt+k]);
													 TotalCirDis+=   GrindWidthDis;
													 CircleCount++;
												 }
												 if(TotalCirDis!=0.0f && CircleCount!=0){
													 C4CorGrindWd  = TotalCirDis/CircleCount;
												 }
											 }
										 }
										 else { // GrindMrk 못찾을경우 연마량만 측정함 
											 // OutData기준 최소값 데이터 Count산출 
											 GrindMeaDis =0.0f, MinDis =10000.0f; GrindMarkOutCnt=0;
											 for(int k=0; k<C4EdgeCount; k++){
												 if(C4Point[k].x==0.0f || C4Point[k].y==0.0f) continue;

												 GrindMarkRectCenter[17].x = GrindMarkRect[17].left + (GrindMarkRect[17].right  - GrindMarkRect[17].left)/2; 
												 GrindMarkRectCenter[17].y = GrindMarkRect[17].top  + (GrindMarkRect[17].bottom - GrindMarkRect[17].top )/2; 

												 GrindMeaDis = Math.GetLength(GrindMarkRectCenter[17], C4Point[k]);
												 if(GrindMeaDis<MinDis){
													 MinDis = GrindMeaDis;
													 GrindMarkOutCnt = k;
												 }
											 }

											 // 최단거리OUtCount기준 InData 최단거리 Count정보 Calc 
											 if(GrindMarkOutCnt!=0){
												 GrindMeaDis =0.0f, MinDis =10000.0f; GrindMarkInCnt=0;
												 for(int k=0; k<C4InEdgeCount; k++){
													 if(C4InPoint[k].x            ==0.0f || C4InPoint[k].y             ==0.0f) continue;
													 if(C4Point[GrindMarkOutCnt].x==0.0f || C4Point[GrindMarkOutCnt].y ==0.0f) continue;

													 GrindMeaDis = Math.GetLength(C4Point[GrindMarkOutCnt], C4InPoint[k]);
													 if(GrindMeaDis<MinDis){
														 MinDis = GrindMeaDis;
														 GrindMarkInCnt = k;
													 }
												 }
											 }

											 // GrindMark기준 수직 포인트 주변값 Avg산출한다 ==>연마량 측정(OutData,InData기준)
											 if((GrindMarkOutCnt!=0 && GrindMarkOutCnt>5) && (GrindMarkInCnt!=0 && GrindMarkInCnt>5)){
												 CircleCount=0,TotalCirDis=0.0f,GrindWidthDis=0.0f;
												 for(int k=-5; k<5; k++){
													 if(C4Point  [GrindMarkOutCnt+k].x==0.0f && C4Point  [GrindMarkOutCnt+k].y==0.0f) continue;
													 if(C4InPoint[GrindMarkInCnt +k].x==0.0f && C4InPoint[GrindMarkInCnt +k].y==0.0f) continue;
													 if((GrindMarkOutCnt+k)>=C4EdgeCount                                            ) continue;
													 if((GrindMarkInCnt +k)>=C4InEdgeCount                                          ) continue;

													 GrindWidthDis = Math.GetLength(C4InPoint[GrindMarkInCnt+k], C4Point[GrindMarkOutCnt+k]);
													 TotalCirDis+=   GrindWidthDis;
													 CircleCount++;
												 }
												 if(TotalCirDis!=0.0f && CircleCount!=0){
													 C4CorGrindWd = TotalCirDis/CircleCount;
												 }
											 }
										 }
									 }	
								 }
							 }
							 else if(IsRectBtm){ // Btm영역이 Rect일경우 
								 LBDx = 0.0f;
								 LBDy = 0.0f;
								 RBDx = 0.0f;
								 RBDy = 0.0f;

								 //화면에 디스플레이 위해서 
								 FLBLPoint.x = FLBPoint.x;
								 FLBLPoint.y = FLBPoint.y;
								 FLBBPoint.x = FLBPoint.x;
								 FLBBPoint.y = FLBPoint.y;

								 FRBRPoint.x = FRBPoint.x;
								 FRBRPoint.y = FRBPoint.y;
								 FRBBPoint.x = FRBPoint.x;
								 FRBBPoint.y = FRBPoint.y;
							 }
						 }
					 }
					 // Image 회전 후 FLBPoint, FRBPoint 기준 BTM 6개의 기준 포인트 및 Circle_Point 기준으로 치수 측정(Circle Dx,Dy,R) 및 데이터 산출 
					 // Corner 교차점 기준 스팩 Dx, Dy만큼 이동하여 Circle Center 설정시(Sawing 편차+Cutting 편차+Grind 편차) 정확성 떨어짐...ㅜ.ㅜ;;
					 // TrackLine EdgePoint 기준 Circle_Fitting하여 Center설정시 교차점 기준보다는 정확성 높아짐 
					 // TrackLine 교차점 기준 스팩 Dx, Dy만큼 이동하여 Circle Center 설정시????
					 // Btm 검사시 Circle 형태일경우만 검사 진행함 
					 if(FLBPoint.x!=0 && FLBPoint.y!=0 && FRBPoint.x!=0 && FRBPoint.y!=0 && IsCircleBtm==1){
						 // 6개의 Circle Center Point 산출 
						 // Cell의 R크기 및 Center부분의 깊이에 따라서 개별 CenterPoint가 변경된다....규칙을 찾아야 한다??......
						 // 외곽라인 기준 Circle Center 설정함 
						 // 연마라인이 불규칙함 이로인해서 CircleEdge 못찾더라도 원본데이터는 가지고 있어야함 
						 // Circle In_Edge Point Count    // Circle Out_Edge Point Count    // Circle(Grind_Measure) Stand Edge Point Count

						 //자재의 외곽라인 교차점 기준 CirCenter 설정함 
						 if(CSideCircleWidth!=0.0f && CSideCircleHeight!=0.0f){
							 C1CirCenter.x = FLBPoint.x + CSideCircleWidth + dCirOffsetX;  C1CirCenter.y = FLBPoint.y -  CSideCircleHeight - dCirOffsetY;  
							 C6CirCenter.x = FRBPoint.x - CSideCircleWidth - dCirOffsetX;  C6CirCenter.y = FRBPoint.y -  CSideCircleHeight              ;  
						 }

						 if(CenterCircleWidth!=0.0f && CenterCircleHeight!=0.0f){ 
							 C2CirCenter.x = FLBPoint.x + CELL_E - CELL_F               ;  C2CirCenter.y = FLBPoint.y -  CenterCircleHeight             ;  
							 C3CirCenter.x = FLBPoint.x + CELL_E                        ;  C3CirCenter.y = FLBPoint.y -  CELL_D+(CenterCircleHeight)    ;  
							 C4CirCenter.x = FRBPoint.x - CELL_E                        ;  C4CirCenter.y = FRBPoint.y -  CELL_D+(CenterCircleHeight)    ;  
							 C5CirCenter.x = FRBPoint.x - CELL_E + CELL_F               ;  C5CirCenter.y = FRBPoint.y -  CenterCircleHeight             ;  
						 }

						 if(FInspectMode==Insp_Track){ //TrackMode TrackLine교자점 기준으로 Circle 센터 좌표 계산함 
							 TrackC1CirCenter.x = FTRLBPoint.x + TrackCircleWidth + dCirOffsetX     ;  TrackC1CirCenter.y = FTRLBPoint.y - TrackCircleHeight - dCirOffsetY                ;  
							 TrackC2CirCenter.x = FTRLBPoint.x + CELL_E - CELL_F - OutToTrackLineDis;  TrackC2CirCenter.y = FTRLBPoint.y - CenterCircleHeight+OutToTrackLineDis           ;  
							 TrackC3CirCenter.x = FTRLBPoint.x + CELL_E - OutToTrackLineDis         ;  TrackC3CirCenter.y = FTRLBPoint.y - CELL_D + (CenterCircleHeight)+OutToTrackLineDis;  
							 TrackC4CirCenter.x = FTRRBPoint.x - CELL_E + OutToTrackLineDis         ;  TrackC4CirCenter.y = FTRRBPoint.y - CELL_D + (CenterCircleHeight)+OutToTrackLineDis;  
							 TrackC5CirCenter.x = FTRRBPoint.x - CELL_E + CELL_F + OutToTrackLineDis;  TrackC5CirCenter.y = FTRRBPoint.y - CenterCircleHeight+OutToTrackLineDis           ;  
							 TrackC6CirCenter.x = FTRRBPoint.x - TrackCircleWidth - dCirOffsetX     ;  TrackC6CirCenter.y = FTRRBPoint.y - TrackCircleHeight - dCirOffsetY                ;
						 }

						 // 비선형 곡선 알고리즘에 필요한 영역 설정 
						 if(FInspectMode==Insp_Polygon){
							 if(CSideCircleWidth!=0.0f && CSideCircleHeight!=0.0f  ){ // Notch부 좌우 영역설정 
								 PolyRect[0].left  = (long)(FLBPoint.x                 );  PolyRect[0].top    = (long)(FLBPoint.y - CSideCircleHeight);
								 PolyRect[0].right = (long)(FLBPoint.x+CSideCircleWidth);  PolyRect[0].bottom = (long)(FLBPoint.y                    );
								 PolyRect[5].left  = (long)(FRBPoint.x-CSideCircleWidth);  PolyRect[5].top    = (long)(FRBPoint.y - CSideCircleHeight);
								 PolyRect[5].right = (long)(FRBPoint.x                 );  PolyRect[5].bottom = (long)(FLBPoint.y                    );

								 // 검사화면 Display 목적 
								 NotchPolyRect[0].left  = PolyRect[0].left ;   NotchPolyRect[0].top    = PolyRect[0].top   ;
								 NotchPolyRect[0].right = PolyRect[0].right;   NotchPolyRect[0].bottom = PolyRect[0].bottom;

								 NotchPolyRect[5].left  = PolyRect[5].left ;   NotchPolyRect[5].top    = PolyRect[5].top   ;
								 NotchPolyRect[5].right = PolyRect[5].right;   NotchPolyRect[5].bottom = PolyRect[5].bottom;
							 }

							 if(CenterCircleWidth!=0.0f && CenterCircleHeight!=0.0f){ // Trench부 영역설정
								 if(Center1CircleWidth==0.0f && Center2CircleWidth==0.0f){ // 
									 PolyRect[1].left  = (long)(FLBPoint.x+CELL_E-CELL_F                  ); PolyRect[1].top    = (long)(FLBPoint.y - CenterCircleHeight   );
									 PolyRect[1].right = (long)(PolyRect[1].left+CenterCircleWidth        ); PolyRect[1].bottom = (long)(PolyRect[1].top+CenterCircleHeight);

									 PolyRect[2].left  = (long)(FLBPoint.x+CELL_E-CenterCircleWidth       ); PolyRect[2].top    = (long)(FLBPoint.y - CELL_D               );
									 PolyRect[2].right = (long)(PolyRect[2].left+CenterCircleWidth        ); PolyRect[2].bottom = (long)(PolyRect[2].top+CenterCircleHeight);

									 PolyRect[3].left  = (long)(FRBPoint.x-CELL_E                         ); PolyRect[3].top    = (long)(FRBPoint.y - CELL_D               );
									 PolyRect[3].right = (long)(PolyRect[3].left+CenterCircleWidth        ); PolyRect[3].bottom = (long)(PolyRect[3].top+CenterCircleHeight);

									 PolyRect[4].left  = (long)(FRBPoint.x-CELL_E+CELL_F-CenterCircleWidth); PolyRect[4].top    = (long)(FRBPoint.y - CenterCircleHeight   );
									 PolyRect[4].right = (long)(PolyRect[4].left+CenterCircleWidth        ); PolyRect[4].bottom = (long)(PolyRect[4].top+CenterCircleHeight);
								 }
								 else                                                    {
									 PolyRect[1].left  = (long)(FLBPoint.x+CELL_E-CELL_F                   ); PolyRect[1].top    = (long)(FLBPoint.y - CenterCircleHeight   );
									 PolyRect[1].right = (long)(PolyRect[1].left+Center1CircleWidth        ); PolyRect[1].bottom = (long)(PolyRect[1].top+CenterCircleHeight);

									 PolyRect[2].left  = (long)(FLBPoint.x+CELL_E-Center2CircleWidth       ); PolyRect[2].top    = (long)(FLBPoint.y - CELL_D               );
									 PolyRect[2].right = (long)(PolyRect[2].left+Center2CircleWidth        ); PolyRect[2].bottom = (long)(PolyRect[2].top+CELL_D            );

									 PolyRect[3].left  = (long)(FRBPoint.x-CELL_E                          ); PolyRect[3].top    = (long)(FRBPoint.y - CELL_D               );
									 PolyRect[3].right = (long)(PolyRect[3].left+Center2CircleWidth        ); PolyRect[3].bottom = (long)(PolyRect[3].top+CELL_D            );

									 PolyRect[4].left  = (long)(FRBPoint.x-CELL_E+CELL_F-Center1CircleWidth); PolyRect[4].top    = (long)(FRBPoint.y - CenterCircleHeight   );
									 PolyRect[4].right = (long)(PolyRect[4].left+Center1CircleWidth        ); PolyRect[4].bottom = (long)(PolyRect[4].top+CenterCircleHeight);
								 }
								 // 검사화면 Display 목적 
								 NotchPolyRect[1].left  = PolyRect[1].left ;   NotchPolyRect[1].top    = PolyRect[1].top   ;
								 NotchPolyRect[1].right = PolyRect[1].right;   NotchPolyRect[1].bottom = PolyRect[1].bottom;

								 NotchPolyRect[2].left  = PolyRect[2].left ;   NotchPolyRect[2].top    = PolyRect[2].top   ;
								 NotchPolyRect[2].right = PolyRect[2].right;   NotchPolyRect[2].bottom = PolyRect[2].bottom;

								 NotchPolyRect[3].left  = PolyRect[3].left ;   NotchPolyRect[3].top    = PolyRect[3].top   ;
								 NotchPolyRect[3].right = PolyRect[3].right;   NotchPolyRect[3].bottom = PolyRect[3].bottom;

								 NotchPolyRect[4].left  = PolyRect[4].left ;   NotchPolyRect[4].top    = PolyRect[4].top   ;
								 NotchPolyRect[4].right = PolyRect[4].right;   NotchPolyRect[4].bottom = PolyRect[4].bottom;
							 }
						 }

						 // 자재의 외곽라인 교차점 기준 GrindMark Match 영역 설정 및 Match 검사 시퀀스 
						 if(IsMarkBtm && FInspectMode!=Insp_Track){
							 // Match 알고리즘 적용한 검사 시퀀스 
							 double OrgDis=0.0f, MatchDis=0.0f, DvDis=0.0f, AvgDvDis=0.0f, MinDvDis=100000.0f; 
							 // Find 알고리즘 적용한 검사 시퀀스 
							 // GrindMarkRect영역 설정 (Find)
							 // 화면에 설정값을 최소화 목적으로 영역설정값을 다시 계산함
							 for(int k=0; k<19; k++){
								 // 특정 포인트는 현재 GrindMark없음...
								 // 									 if(k==0 || k==3 || k==4|| k==6 || k==8 || k==10|| k==12 ||k==14|| k==15 || k==18) continue;
								 if(k<9)    {
									 if(GrindRectSpec[k].DvX==0.0f || GrindRectSpec[k].DvY==0.0f)  continue;
								 }
								 else if(k>9){
									 if(GrindRectSpec[18 -k].DvX==0.0f || GrindRectSpec[18 -k].DvY==0.0f)  continue;
								 }


								 if(k<9){ // Left 영역 
									 GrindMarkRect[k].left = (FLBPoint.x + GrindRectSpec[k].DvX) -GrindMarkRange;
									 GrindMarkRect[k].top  = (FLBPoint.y - GrindRectSpec[k].DvY) -GrindMarkRange;
								 }
								 else if(k==9 && CenterCircleHeight!=0.0f && CenterCircleWidth!=0.0f){																	      
									 GrindMarkRect[k].left   = (FLBPoint.x + ((FRBPoint.x -FLBPoint.x)/2) -GrindMarkRange);
									 GrindMarkRect[k].top    = (FLBPoint.y - CELL_D - OutToGrindMarkDis1  -GrindMarkRange);
								 }																				      
								 else if(k>9){ //Right 영역 
									 GrindMarkRect[k].left = (FRBPoint.x - GrindRectSpec[18 -k].DvX) -GrindMarkRange;
									 GrindMarkRect[k].top  = (FRBPoint.y - GrindRectSpec[18 -k].DvY) -GrindMarkRange;
								 }
								 // GrindMarkRect Right/Bottom 영역 좌표 계산 
								 GrindMarkRect[k].right  = GrindMarkRect[k].left+GrindMarkLength;
								 GrindMarkRect[k].bottom = GrindMarkRect[k].top +GrindMarkLength;
							 }

							 // Match 검사시 기본 설정 
							 // 								 if(IsMarkBtm) Find->OnLoad(true,FindDir  );
							 // 								 else          Find->OnLoad(true,FindDir,1);
							 LogUnit.SetLog(L"CellID:%d, CamID:%d ==>GindMark_Find_Circle_Start",CellId,CamId);     
							 Find->OnLoad(true,FindDir  )                   ;
							 Find->GImage  = &RotateImg                      ;
							 // 								 Find->SetContrastMode(EFindContrastMode_Any)   ;
							 Find->SetContrastMode(EFindContrastMode_Normal);
							 // 								 Find->SetMinScore(0.8f)                        ;
							 Find->SetMinScore (GrindMarkMinScore)          ; // PatternrFind 검사 최소 Score
							 Find->SetZeroScore(GrindMarkMinScore)          ; // 검사 후 최소 Score 
							 Find->SetMaxInstances(1)                       ;
							 Find->SetAngleTolerance(20.0f)                 ;
							 Find->SetScaleBias(1.00f)                      ;
							 Find->SetScaleTolerance(0.0f)                  ;
							 Find->Property.Ox = (float)ImgW/2              ;
							 Find->Property.Oy = (float)ImgH/2              ;

							 // 								 int GrindRectWidth=0, GrindRectHeight=0;
							 GrindRectWidth=0, GrindRectHeight=0;
							 // Math 검사 진행 및 ㅏ Mark 중심좌표 산출 
							 // 								 for(int k=0; k<MAX_FIND_MARK_COUNT; k++){
							 for(int k=0; k<19; k++){ 

								 // 특정 포인트는 현재 GrindMark없음...
								 // 									 if(k==0 || k==3 || k==4|| k==6 || k==8 || k==10|| k==12 ||k==14|| k==15 || k==18) continue;

								 if(k<9)    {
									 if(GrindRectSpec[k].DvX==0.0f || GrindRectSpec[k].DvY==0.0f)  continue;
								 }
								 else if(k>9){
									 if(GrindRectSpec[18 -k].DvX==0.0f || GrindRectSpec[18 -k].DvY==0.0f)  continue;
								 }


								 GrindRectWidth  = (GrindMarkRect[k].right  - GrindMarkRect[k].left);
								 GrindRectHeight = (GrindMarkRect[k].bottom - GrindMarkRect[k].top );
								 Find->IRoi->SetPlacement(GrindMarkRect[k].left,GrindMarkRect[k].top,GrindRectWidth,GrindRectHeight);
								 if(GrindMarkRect[k].left<=0    || GrindMarkRect[k].top<=0    || GrindRectWidth<=0    || GrindRectHeight<=0   ) continue;
								 if(GrindMarkRect[k].left>=ImgW || GrindMarkRect[k].top>=ImgH || GrindRectWidth>=ImgW || GrindRectHeight>=ImgH) continue;

								 if     (k==0 ) Find->SetAngleBias(60.0f ); //LHJ Add // Cir1
								 else if(k==1 ) Find->SetAngleBias(45.0f );			  // CIr2
								 else if(k==2 ) Find->SetAngleBias(0.0f  );			  // Cir3
								 else if(k==4 ) Find->SetAngleBias(0.0f  );			  // Cir5
								 else if(k==5 ) Find->SetAngleBias(315.0f);			  // Cir6	
								 else if(k==7 ){
									 if(WkMode)
										 Find->SetAngleBias(290.0f);         // Cir8
									 else
										 Find->SetAngleBias(315.0f);			  // Cir8
								 }
								 else if(k==8 ) Find->SetAngleBias(315.0f);			  // Cir9	
								 else if(k==9 ) Find->SetAngleBias(0.0f  );			  // Cir10
								 else if(k==10) Find->SetAngleBias(45.0f );			  // Cir11
								 else if(k==11){
									 if(WkMode)
										 Find->SetAngleBias(85.0f );			  // Cir12
									 else
										 Find->SetAngleBias(45.0f );			  // Cir12
								 }
								 else if(k==13) Find->SetAngleBias(45.0f );			  // Cir14
								 else if(k==14) Find->SetAngleBias(0.0f  );			  // Cir16
								 else if(k==16) Find->SetAngleBias(0.0f  );			  // Cir17
								 else if(k==17) Find->SetAngleBias(315.0f);			  // Cir18
								 else if(k==18) Find->SetAngleBias(300.0f); //LHJ Add // Cir19
								 // 검사 및 Match Pos 좌표 받어온다 
								 // Find 검사 성공시 데이터 받아옴 
								 if(Find->OnExecute()){
									 GrindMarkPoint[k].x = Find->Result[0].Px;
									 GrindMarkPoint[k].y = Find->Result[0].Py;
									 GrindMarkScore[k]   = Find->Result[0].Score;// 실제 Pattern Finder Score Value
								 }
								 // Contrast Gradient Pixel Value
								 // 									 GrindMarkGradient[k] = EasyImage::Focusing(Find->IRoi);
							 }
							 LogUnit.SetLog(L"CellID:%d, CamID:%d ==>GindMark_Find_Circle_End",CellId,CamId);     
						 }

						 // 각각의 CirCenter_Point 기준 Circle_Fitting 및 검사진행 
						 if(FBottomWall){
							 EasyImage::Threshold(&RotateImg,&RotateBinaryImg       , BtmEdgeThresHold    ); // Circle Grind Edge
							 EasyImage::Threshold(&RotateImg,&RotateGrindBinaryImg  , CirGrindMeaThresHold); // Circle Grind Measure 측정 기준 패턴Edge(Circle Track Line)
							 EasyImage::Threshold(&RotateImg,&RotateGrindInBinaryImg, CirGrindInThresHold ); // Circle Grind In_EdgePoint 측정 목적

							 //								 RotateImg.Save             ("D:\\ROTATE_IMG\\RotateImage회전_CUP.bmp");
							 // 								 RotateBinaryImg.Save       ("D:\\ROTATE_IMG\\RotateBinaryImg회전_CUP.bmp");
							 // 								 RotateGrindBinaryImg.Save  ("D:\\ROTATE_IMG\\RotateGrindBinaryImg회전_CUP.bmp");
							 // 								 RotateGrindInBinaryImg.Save("D:\\ROTATE_IMG\\RotateGrindInBinaryImg회전_CUP.bmp");

							 if(FInspectMode==Insp_Polygon){
								 LogUnit.SetLog(L"CellID:%d, CamID:%d ==>Polygon_Insp_Start",CellId,CamId);     
								 TPoint P1(0,0),P2(0,0),P3(0,0),P4(0,0);
								 // Polygon Algorithm Setting 
								 Polygon->IWidth          = ImgW;
								 Polygon->IHeight         = ImgH;
								 Polygon->PoPa.MinPxCnt   =300  ;
								 Polygon->PoPa.MaxPxCnt   =20000;
								 Polygon->PoPa.MaxBbCnt   =10   ;
								 // 									 Polygon->PoPa.FMinWidth  =300  ;
								 // 									 Polygon->PoPa.FMinHeight =100  ;

								 // 첫번째 Polygon, Circle 1
								 if(PolyRect[0].left!=0 && PolyRect[0].top!=0 && PolyRect[0].right!=0 && PolyRect[0].bottom!=0){
									 P1.x=0, P1.y=0, P2.x=0, P2.y=0, P3.x=0, P3.y=0, P4.x=0, P4.y=0;
									 LogUnit.SetLog(L"CellID:%d, CamID:%d ==>Polygon1_Insp_Start",CellId,CamId);     

									 // 										 P1.x = (PolyRect[0].left-30); P1.y =(PolyRect[0].top-20          ); P2.x = (P1.x+PolyRect[0].Width()+60); P2.y = (P1.y);
									 // 										 P3.x = (PolyRect[0].left-30); P3.y =(P1.y+PolyRect[0].Height()+40); P4.x = (P2.x                       ); P4.y = (P3.y);

									 // 										 P1.x = (PolyRect[0].left-50); P1.y =(PolyRect[0].top             ); P2.x = (P1.x+PolyRect[0].Width()); P2.y = (P1.y);
									 // 										 P3.x = (PolyRect[0].left-50); P3.y =(P1.y+PolyRect[0].Height()+50); P4.x = (P2.x                    ); P4.y = (P3.y);

									 P1.x = (PolyRect[0].left); P1.y =(PolyRect[0].top             ); P2.x = (P1.x+PolyRect[0].Width()); P2.y = (P1.y);
									 P3.x = (PolyRect[0].left); P3.y =(P1.y+PolyRect[0].Height()+50); P4.x = (P2.x                    ); P4.y = (P3.y);

									 // Median Filter 적용 
									 if(P1.x<=0    || P1.y<=0    || (P2.x - P1.x)<=0    || (P3.y - P1.y)<=0   ) return false;
									 if(P1.x>=ImgW || P1.y>=ImgH || (P2.x - P1.x)>=ImgW || (P3.y - P1.y)>=ImgH) return false;
									 //ROI x + Width = 16384 넘어가면 Return //20180808 추가
									 //ROI y + Hight = 1500  넘어가면 Return
									 if( (P1.x + int(P2.x - P1.x)) >= ImgW || (P1.y + int(P3.y - P1.y)) >= ImgH ) return false;
									 FilterROI.SetSize(int(P2.x - P1.x),int(P3.y - P1.y) )                 ;
									 FilterROI.Attach(&RotateBinaryImg)                                    ;
									 FilterROI.SetPlacement(P1.x, P1.y, int(P2.x - P1.x), int(P3.y - P1.y));
									 LogUnit.SetLog(L"Polygon1 ==>Px :%d, Py :%d, Width:%d, Height:%d ==>Median Filter",P1.x, P1.y, int(P2.x - P1.x), int(P3.y - P1.y));     
									 LogUnit.SetLog(L"Polygon1 ==>P1x:%d, P1y:%d, P2x:%d, P2y:%d, P3x:%d, P3y:%d, P4x:%d, P4y:%d,",P1.x,P1.y,P2.x,P2.y,P3.x,P3.y,P4.x,P4.y);     
									 EasyImage::Median(&FilterROI, &FilterROI)                             ;
									 // 										 RotateBinaryImg.Save("D:\\ROTATE_IMG\\Polygon_BinaryImg_필터1.bmp");

									 Polygon->GImage          = &RotateBinaryImg           ;
									 Polygon->PoPa.FMaxWidth  =(int)(CSideCircleWidth+100 );
									 Polygon->PoPa.FMaxHeight =(int)(CSideCircleHeight+100);
									 Polygon->PoPa.IsSeparate =true                        ;
									 Polygon->PoPa.IsInToOut  =true                        ;
									 Polygon->PoPa.HiThHold   = BtmEdgeThresHold           ;
									 Polygon->PoPa.LoThHold   = 0                          ;
									 Polygon->PoPa.FMinWidth  =(int)(CSideCircleWidth/2)   ;
									 Polygon->PoPa.FMinHeight =(int)(CSideCircleHeight/2)  ;


									 if(P1.x!=0 && P1.y!=0 && P2.x!=0 && P2.y!=0 && P3.x!=0 && P3.y!=0 && P4.x!=0 && P4.y!=0){
										 Polygon->OnExecute(P1,P2,P3,P4);
									 }

									 // Polygon Algorithm InEdgeData/OutEdgeData Separate 및 데이터 추출 
									 if(Polygon->BlobCount==1){
										 PolygonMarginCnt =10;
										 if(Polygon->Blob[0].InCnt>(PolygonMarginCnt*2)){
											 C1CirInEdgeCount=0;
											 C1CirInEdgeCount = (Polygon->Blob[0].InCnt - (PolygonMarginCnt*2));
											 if(C1CirInEdgeCount>0){
												 if(C1CirInPoint!=NULL){
													 delete[] C1CirInPoint;
												 }
												 C1CirInPoint = new TFPoint[C1CirInEdgeCount];

												 PixelCnt=0;
												 for(int k=0; k<Polygon->Blob[0].InCnt; k++){
													 if(k<PolygonMarginCnt || k>=(Polygon->Blob[0].InCnt-PolygonMarginCnt)) continue;
													 C1CirInPoint[PixelCnt].x   = Polygon->Blob[0].InPoint[k].x ;
													 C1CirInPoint[PixelCnt].y   = Polygon->Blob[0].InPoint[k].y ;
													 PixelCnt++;
												 }
											 }
										 }

										 if(Polygon->Blob[0].OutCnt>(PolygonMarginCnt*2)){
											 C1CirOutEdgeCount=0;
											 C1CirOutEdgeCount = (Polygon->Blob[0].OutCnt - (PolygonMarginCnt*2));
											 if(C1CirOutEdgeCount>0){
												 if(C1CirOutPoint!=NULL) delete[] C1CirOutPoint;
												 C1CirOutPoint = new TFPoint[C1CirOutEdgeCount];

												 PixelCnt=0;
												 for(int k=0; k<Polygon->Blob[0].OutCnt; k++){
													 if(k<PolygonMarginCnt || k>=(Polygon->Blob[0].OutCnt-PolygonMarginCnt)) continue;
													 C1CirOutPoint[PixelCnt].x  = Polygon->Blob[0].OutPoint[k].x ;
													 C1CirOutPoint[PixelCnt].y  = Polygon->Blob[0].OutPoint[k].y ;
													 if(k==(Polygon->Blob[0].OutCnt-PolygonMarginCnt-1)){ // 직선구간에 필요한 시작점 데이터 좌료 
														 BtmEdgePoint[0].x = C1CirOutPoint[PixelCnt].x;
														 BtmEdgePoint[0].y = C1CirOutPoint[PixelCnt].y;
													 }
													 PixelCnt++;
												 }
											 }
										 }
										 // Polygon Data Clear
										 //                                              Polygon->ClearData();
									 }
									 // Polygon Data Clear
									 // 										 Polygon->ClearData();
									 /////////////////////////////////////////////////////////////////////////////////////////////

									 // InEdgeData/OutEdgeData 기준 가공량 및 연마량 계산
									 // Polygon 알고리즘에서는 GrindMark기준 OutData,InData 최단거리 2개 Tag값 산출해야함 
									 if(IsMarkBtm){ // LTPS 가공량,연마량 계산 
										 if(C1CirOutEdgeCount!=0 && C1CirInEdgeCount!=0){ // MarkMode경우 가공량 검사를 먼저 진행 후 연마량 산출

											 // GrindMark[0] 기준으로 연마량,가공량 측정 시퀀스 
											 //////////////////////////////////////////////////////////////////////////////////////
											 if(GrindMarkPoint[0].x!=0.0f && GrindMarkPoint[0].y!=0.0f){  //GrindMark 찾았을경우 

												 // GrindMark기준 OutData 최단거리 Count정보 Calc 
												 GrindMeaDis =0.0f, MinDis =10000.0f; GrindMarkOutCnt=0;
												 for(int k=0; k<C1CirOutEdgeCount; k++){
													 if(C1CirOutPoint[k].x ==0.0f || C1CirOutPoint[k].y ==0.0f) continue;
													 if(GrindMarkPoint[0].x==0.0f || GrindMarkPoint[0].y==0.0f) continue;

													 GrindMeaDis = Math.GetLength(GrindMarkPoint[0], C1CirOutPoint[k]);
													 if(GrindMeaDis<MinDis){
														 MinDis = GrindMeaDis;
														 GrindMarkOutCnt = k;
													 }
												 }

												 // GrindMark기준 InData 최단거리 Count정보 Calc 
												 if(GrindMarkOutCnt!=0){
													 GrindMeaDis =0.0f, MinDis =10000.0f; GrindMarkInCnt=0;
													 for(int k=0; k<C1CirInEdgeCount; k++){
														 if(C1CirInPoint[k].x   ==0.0f             || C1CirInPoint[k].y                ==0.0f) continue;
														 if(C1CirOutPoint[GrindMarkOutCnt].x==0.0f || C1CirOutPoint[GrindMarkOutCnt].y ==0.0f) continue;

														 GrindMeaDis = Math.GetLength(C1CirOutPoint[GrindMarkOutCnt], C1CirInPoint[k]);
														 if(GrindMeaDis<MinDis){
															 MinDis = GrindMeaDis;
															 GrindMarkInCnt = k;
														 }
													 }
												 }

												 // GrindMark기준 수직 포인트 주변값 Avg산출한다 ==>가공량 측정(OutData기준)
												 if(GrindMarkOutCnt!=0 && GrindMarkOutCnt>5){
													 CircleCount=0,TotalCirDis=0.0f,GrindMeaDis=0.0f;
													 for(int k=GrindMarkOutCnt-5; k<GrindMarkOutCnt+5; k++){
														 if(C1CirOutPoint[k].x==0.0f || C1CirOutPoint[k].y==0.0f) continue;
														 if(k>=C1CirOutEdgeCount                                ) continue;

														 GrindMeaDis = Math.GetLength(GrindMarkPoint[0], C1CirOutPoint[k]);
														 TotalCirDis+= GrindMeaDis;
														 CircleCount++;
													 }
													 if(TotalCirDis!=0.0f && CircleCount!=0){
														 C0CirGrindMea = TotalCirDis/CircleCount;
														 C0CirGrindMea = C0CirGrindMea+0.5; //SubPixel 
													 }
												 }

												 // GrindMark기준 수직 포인트 주변값 Avg산출한다 ==>연마량 측정(OutData,InData기준)
												 if((GrindMarkOutCnt!=0 && GrindMarkOutCnt>5) && (GrindMarkInCnt!=0 && GrindMarkInCnt>5)){
													 CircleCount=0,TotalCirDis=0.0f,GrindWidthDis=0.0f;
													 for(int k=-5; k<5; k++){
														 if(C1CirOutPoint[GrindMarkOutCnt+k].x==0.0f && C1CirOutPoint[GrindMarkOutCnt+k].y==0.0f) continue;
														 if(C1CirInPoint [GrindMarkInCnt +k].x==0.0f && C1CirInPoint [GrindMarkInCnt +k].y==0.0f) continue;
														 if((GrindMarkOutCnt+k)>=C1CirOutEdgeCount                                              ) continue;
														 if((GrindMarkInCnt +k)>=C1CirInEdgeCount                                               ) continue;

														 GrindWidthDis = Math.GetLength(C1CirInPoint[GrindMarkInCnt+k], C1CirOutPoint[GrindMarkOutCnt+k]);
														 TotalCirDis+=   GrindWidthDis;
														 CircleCount++;
													 }
													 if(TotalCirDis!=0.0f && CircleCount!=0){
														 C0CirGrindWd = TotalCirDis/CircleCount;
														 C0CirGrindWd = C0CirGrindWd+0.5; //SubPixel
													 }
												 }
											 }
											 else if(GrindMarkRect[0].left!=0 && GrindMarkRect[0].top!=0 && GrindMarkRect[0].right!=0 &&GrindMarkRect[0].bottom!=0) {  //GrindMark 못 찾았을경우

												 // OutData기준 최소값 데이터 Count산출 
												 GrindMeaDis =0.0f, MinDis =10000.0f; GrindMarkOutCnt=0;
												 for(int k=0; k<C1CirOutEdgeCount; k++){
													 if(C1CirOutPoint[k].x==0.0f || C1CirOutPoint[k].y==0.0f) continue;

													 GrindMarkRectCenter[0].x = GrindMarkRect[0].left + (GrindMarkRect[0].right  - GrindMarkRect[0].left)/2; 
													 GrindMarkRectCenter[0].y = GrindMarkRect[0].top  + (GrindMarkRect[0].bottom - GrindMarkRect[0].top )/2; 

													 GrindMeaDis = Math.GetLength(GrindMarkRectCenter[0], C1CirOutPoint[k]);
													 if(GrindMeaDis<MinDis){
														 MinDis = GrindMeaDis;
														 GrindMarkOutCnt = k;
													 }
												 }

												 // 최단거리OUtCount기준 InData 최단거리 Count정보 Calc 
												 if(GrindMarkOutCnt!=0){
													 GrindMeaDis =0.0f, MinDis =10000.0f; GrindMarkInCnt=0;
													 for(int k=0; k<C1CirInEdgeCount; k++){
														 if(C1CirInPoint[k].x   ==0.0f             || C1CirInPoint[k].y                ==0.0f) continue;
														 if(C1CirOutPoint[GrindMarkOutCnt].x==0.0f || C1CirOutPoint[GrindMarkOutCnt].y ==0.0f) continue;

														 GrindMeaDis = Math.GetLength(C1CirOutPoint[GrindMarkOutCnt], C1CirInPoint[k]);
														 if(GrindMeaDis<MinDis){
															 MinDis = GrindMeaDis;
															 GrindMarkInCnt = k;
														 }
													 }
												 }

												 // GrindMark기준 수직 포인트 주변값 Avg산출한다 ==>연마량 측정(OutData,InData기준)
												 if((GrindMarkOutCnt!=0 && GrindMarkOutCnt>5) && (GrindMarkInCnt!=0 && GrindMarkInCnt>5)){
													 CircleCount=0,TotalCirDis=0.0f,GrindWidthDis=0.0f;
													 for(int k=-5; k<5; k++){
														 if(C1CirOutPoint[GrindMarkOutCnt+k].x==0.0f && C1CirOutPoint[GrindMarkOutCnt+k].y==0.0f) continue;
														 if(C1CirInPoint [GrindMarkInCnt +k].x==0.0f && C1CirInPoint [GrindMarkInCnt +k].y==0.0f) continue;
														 if((GrindMarkOutCnt+k)>=C1CirOutEdgeCount                                              ) continue;
														 if((GrindMarkInCnt +k)>=C1CirInEdgeCount                                               ) continue;

														 GrindWidthDis = Math.GetLength(C1CirInPoint[GrindMarkInCnt+k], C1CirOutPoint[GrindMarkOutCnt+k]);
														 TotalCirDis+=   GrindWidthDis;
														 CircleCount++;
													 }
													 if(TotalCirDis!=0.0f && CircleCount!=0){
														 C0CirGrindWd = TotalCirDis/CircleCount;
														 C0CirGrindWd = C0CirGrindWd+0.5; //SubPixel
													 }
												 }
											 }

											 // GrindMark[1] 기준으로 연마량,가공량 측정 시퀀스 
											 //////////////////////////////////////////////////////////////////////////////////////
											 if(GrindMarkPoint[1].x!=0.0f && GrindMarkPoint[1].y!=0.0f){  //GrindMark 찾았을경우 

												 // GrindMark기준 OutData 최단거리 Count정보 Calc 
												 GrindMeaDis =0.0f, MinDis =10000.0f; GrindMarkOutCnt=0;
												 for(int k=0; k<C1CirOutEdgeCount; k++){
													 if(C1CirOutPoint[k].x ==0.0f || C1CirOutPoint[k].y ==0.0f) continue;
													 if(GrindMarkPoint[1].x==0.0f || GrindMarkPoint[1].y==0.0f) continue;

													 GrindMeaDis = Math.GetLength(GrindMarkPoint[1], C1CirOutPoint[k]);
													 if(GrindMeaDis<MinDis){
														 MinDis = GrindMeaDis;
														 GrindMarkOutCnt = k;
													 }
												 }

												 // GrindMark기준 InData 최단거리 Count정보 Calc 
												 if(GrindMarkOutCnt!=0){
													 GrindMeaDis =0.0f, MinDis =10000.0f; GrindMarkInCnt=0;
													 for(int k=0; k<C1CirInEdgeCount; k++){
														 if(C1CirInPoint[k].x   ==0.0f             || C1CirInPoint[k].y                ==0.0f) continue;
														 if(C1CirOutPoint[GrindMarkOutCnt].x==0.0f || C1CirOutPoint[GrindMarkOutCnt].y ==0.0f) continue;

														 GrindMeaDis = Math.GetLength(C1CirOutPoint[GrindMarkOutCnt], C1CirInPoint[k]);
														 if(GrindMeaDis<MinDis){
															 MinDis = GrindMeaDis;
															 GrindMarkInCnt = k;
														 }
													 }
												 }

												 // GrindMark기준 수직 포인트 주변값 Avg산출한다 ==>가공량 측정(OutData기준)
												 if(GrindMarkOutCnt!=0 && GrindMarkOutCnt>5){
													 CircleCount=0,TotalCirDis=0.0f,GrindMeaDis=0.0f;
													 for(int k=GrindMarkOutCnt-5; k<GrindMarkOutCnt+5; k++){
														 if(C1CirOutPoint[k].x==0.0f || C1CirOutPoint[k].y==0.0f) continue;
														 if(k>=C1CirOutEdgeCount                                ) continue;

														 GrindMeaDis = Math.GetLength(GrindMarkPoint[1], C1CirOutPoint[k]);
														 TotalCirDis+= GrindMeaDis;
														 CircleCount++;
													 }
													 if(TotalCirDis!=0.0f && CircleCount!=0){
														 C1CirGrindMea = TotalCirDis/CircleCount;
														 C1CirGrindMea = C1CirGrindMea+0.5; //SubPixel 
													 }
												 }

												 // GrindMark기준 수직 포인트 주변값 Avg산출한다 ==>연마량 측정(OutData,InData기준)
												 if((GrindMarkOutCnt!=0 && GrindMarkOutCnt>5) && (GrindMarkInCnt!=0 && GrindMarkInCnt>5)){
													 CircleCount=0,TotalCirDis=0.0f,GrindWidthDis=0.0f;
													 for(int k=-5; k<5; k++){
														 if(C1CirOutPoint[GrindMarkOutCnt+k].x==0.0f && C1CirOutPoint[GrindMarkOutCnt+k].y==0.0f) continue;
														 if(C1CirInPoint [GrindMarkInCnt +k].x==0.0f && C1CirInPoint [GrindMarkInCnt +k].y==0.0f) continue;
														 if((GrindMarkOutCnt+k)>=C1CirOutEdgeCount                                              ) continue;
														 if((GrindMarkInCnt +k)>=C1CirInEdgeCount                                               ) continue;

														 GrindWidthDis = Math.GetLength(C1CirInPoint[GrindMarkInCnt+k], C1CirOutPoint[GrindMarkOutCnt+k]);
														 TotalCirDis+=   GrindWidthDis;
														 CircleCount++;
													 }
													 if(TotalCirDis!=0.0f && CircleCount!=0){
														 C1CirGrindWd = TotalCirDis/CircleCount;
														 C1CirGrindWd = C1CirGrindWd+0.5; //SubPixel
													 }
												 }
											 }
											 else if(GrindMarkRect[1].left!=0 && GrindMarkRect[1].top!=0 && GrindMarkRect[1].right!=0 &&GrindMarkRect[1].bottom!=0){  //GrindMark 못 찾았을경우
												 // OutData기준 최소값 데이터 Count산출 
												 GrindMeaDis =0.0f, MinDis =10000.0f; GrindMarkOutCnt=0;
												 for(int k=0; k<C1CirOutEdgeCount; k++){
													 if(C1CirOutPoint[k].x==0.0f || C1CirOutPoint[k].y==0.0f) continue;

													 GrindMarkRectCenter[1].x = GrindMarkRect[1].left + (GrindMarkRect[1].right  - GrindMarkRect[1].left)/2; 
													 GrindMarkRectCenter[1].y = GrindMarkRect[1].top  + (GrindMarkRect[1].bottom - GrindMarkRect[1].top )/2; 

													 GrindMeaDis = Math.GetLength(GrindMarkRectCenter[1], C1CirOutPoint[k]);
													 if(GrindMeaDis<MinDis){
														 MinDis = GrindMeaDis;
														 GrindMarkOutCnt = k;
													 }
												 }

												 // 최단거리OUtCount기준 InData 최단거리 Count정보 Calc 
												 if(GrindMarkOutCnt!=0){
													 GrindMeaDis =0.0f, MinDis =10000.0f; GrindMarkInCnt=0;
													 for(int k=0; k<C1CirInEdgeCount; k++){
														 if(C1CirInPoint[k].x   ==0.0f             || C1CirInPoint[k].y                ==0.0f) continue;
														 if(C1CirOutPoint[GrindMarkOutCnt].x==0.0f || C1CirOutPoint[GrindMarkOutCnt].y ==0.0f) continue;

														 GrindMeaDis = Math.GetLength(C1CirOutPoint[GrindMarkOutCnt], C1CirInPoint[k]);
														 if(GrindMeaDis<MinDis){
															 MinDis = GrindMeaDis;
															 GrindMarkInCnt = k;
														 }
													 }
												 }

												 // GrindMark기준 수직 포인트 주변값 Avg산출한다 ==>연마량 측정(OutData,InData기준)
												 if((GrindMarkOutCnt!=0 && GrindMarkOutCnt>5) && (GrindMarkInCnt!=0 && GrindMarkInCnt>5)){
													 CircleCount=0,TotalCirDis=0.0f,GrindWidthDis=0.0f;
													 for(int k=-5; k<5; k++){
														 if(C1CirOutPoint[GrindMarkOutCnt+k].x==0.0f && C1CirOutPoint[GrindMarkOutCnt+k].y==0.0f) continue;
														 if(C1CirInPoint [GrindMarkInCnt +k].x==0.0f && C1CirInPoint [GrindMarkInCnt +k].y==0.0f) continue;
														 if((GrindMarkOutCnt+k)>=C1CirOutEdgeCount                                              ) continue;
														 if((GrindMarkInCnt +k)>=C1CirInEdgeCount                                               ) continue;

														 GrindWidthDis = Math.GetLength(C1CirInPoint[GrindMarkInCnt+k], C1CirOutPoint[GrindMarkOutCnt+k]);
														 TotalCirDis+=   GrindWidthDis;
														 CircleCount++;
													 }
													 if(TotalCirDis!=0.0f && CircleCount!=0){
														 C1CirGrindWd = TotalCirDis/CircleCount;
														 C1CirGrindWd = C1CirGrindWd+0.5; //SubPixel
													 }
												 }
											 }
										 }
									 }
									 else         { //Polygon EnCap 계산시 OutPoint 중간값 기준 실측 거리 평균값을 계산한다(LeftTop) 
										 if(C1CirInEdgeCount!=0 && C1CirOutEdgeCount!=0){
											 GrindMeaDis =0.0f, MinDis =10000.0f; GrindMarkOutCnt=0;
											 GrindMarkOutCnt = (int)(C1CirOutEdgeCount/2);
											 // 최단거리OUtCount기준 InData 최단거리 Count정보 Calc 
											 if(GrindMarkOutCnt!=0){
												 GrindMeaDis =0.0f, MinDis =10000.0f; GrindMarkInCnt=0;
												 for(int k=0; k<C1CirInEdgeCount; k++){
													 if(C1CirInPoint[k].x   ==0.0f             || C1CirInPoint[k].y                ==0.0f) continue;
													 if(C1CirOutPoint[GrindMarkOutCnt].x==0.0f || C1CirOutPoint[GrindMarkOutCnt].y ==0.0f) continue;

													 GrindMeaDis = Math.GetLength(C1CirOutPoint[GrindMarkOutCnt], C1CirInPoint[k]);
													 if(GrindMeaDis<MinDis){
														 MinDis = GrindMeaDis;
														 GrindMarkInCnt = k;
													 }
												 }
											 }

											 // GrindMark기준 수직 포인트 주변값 Avg산출한다 ==>연마량 측정(OutData,InData기준)
											 if((GrindMarkOutCnt!=0 && GrindMarkOutCnt>5) && (GrindMarkInCnt!=0 && GrindMarkInCnt>5)){
												 CircleCount=0,TotalCirDis=0.0f,GrindWidthDis=0.0f;
												 for(int k=-5; k<5; k++){
													 if(C1CirOutPoint[GrindMarkOutCnt+k].x==0.0f && C1CirOutPoint[GrindMarkOutCnt+k].y==0.0f) continue;
													 if(C1CirInPoint [GrindMarkInCnt +k].x==0.0f && C1CirInPoint [GrindMarkInCnt +k].y==0.0f) continue;
													 if((GrindMarkOutCnt+k)>=C1CirOutEdgeCount                                              ) continue;
													 if((GrindMarkInCnt +k)>=C1CirInEdgeCount                                               ) continue;

													 GrindWidthDis = Math.GetLength(C1CirInPoint[GrindMarkInCnt+k], C1CirOutPoint[GrindMarkOutCnt+k]);
													 TotalCirDis+=   GrindWidthDis;
													 CircleCount++;
												 }
												 if(TotalCirDis!=0.0f && CircleCount!=0){
													 C1CirGrindWd = TotalCirDis/CircleCount;
													 C1CirGrindWd = C1CirGrindWd+0.5; //SubPixel
												 }
											 }
										 }
									 }
									 ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
									 // FAVION Circle Fitting 결과물(Circle_1)
									 SampleSize   = C1CirInEdgeCount*0.75; //0.5~0.8이하로 입력할것
									 DistDevRatio = 0.15                 ; //0.1~0.25 이하로 입력할것
									 CircleFit->OnRansac(C1CirInPoint,C1CirInEdgeCount,SampleSize,DistDevRatio,&CircleFit1Center,&CirFitDiameter1);

									 // Polygon 박리 검사 시퀀스 
									 if(!IsMarkBtm && BrokenThresHold!=0){
										 RotateBrokenImg.SetSize(RotateImg.GetWidth(), RotateImg.GetHeight());
										 EasyImage::Oper(EArithmeticLogicOperation_Copy,&RotateImg,&RotateBrokenImg);
										 EasyImage::Threshold(&RotateImg,&RotateBrokenImg, BrokenThresHold);
										 Edge->GImage = &RotateBrokenImg;
										 Edge->SetEdgeType(0);
										 // 											 RotateBrokenImg.Save("D:\\ROTATE_IMG\\Polygon_박리.bmp");

										 int DvCnt =0, DataCount=0;
										 double deg =0.0f; 
										 TFPoint Target(0.0f, 0.0f);

										 if(GrindMarkInCnt>GrindMarkOutCnt){
											 DvCnt = GrindMarkInCnt - GrindMarkOutCnt;
											 for(int k=0; k<C1CirOutEdgeCount; k++){
												 deg =0.0f, Target.x =0.0f, Target.y =0.0f;
												 if(((k+DvCnt)<C1CirInEdgeCount) && C1CirInPoint[k+DvCnt].x>0  && C1CirInPoint[k+DvCnt].y>0){
													 deg = Math.GetDegree(C1CirOutPoint[k],C1CirInPoint[k+DvCnt]);

													 Target  = Math.OnFindPerpendicularPointXY(C1CirOutPoint[k],dEdgeToTrapLineDis,-dEdgeToTrapLineDis,deg);
													 Edge->OnExecute(C1CirOutPoint[k],Target); // 연마외곽라인에서 Target까지 White Point Search 
													 if(Edge->GetResultEdgePointCount()>0){
														 C1CircleData[DataCount].Dis =0.0f;
														 C1CircleData[DataCount].Dv  =0.0f;
														 C1CircleData[DataCount].P   = Edge->GetResultEdgePoint(0);
														 C1CircleData[DataCount].P.y = C1CircleData[DataCount].P.y - ImageHeight; // Frame기준 단위좌표로 변경함  
														 DataCount++;
													 }
												 }
											 }
											 C1CirInCrackCount = DataCount;
										 }
										 else if(GrindMarkInCnt<GrindMarkOutCnt)   {
											 DvCnt = GrindMarkOutCnt - GrindMarkInCnt;
											 for(int k=DvCnt; k<C1CirOutEdgeCount; k++){
												 deg =0.0f, Target.x =0.0f, Target.y =0.0f;
												 if(((k-DvCnt)<C1CirInEdgeCount) && C1CirInPoint[k-DvCnt].x>0  && C1CirInPoint[k-DvCnt].y>0 && k-DvCnt>=0){
													 deg = Math.GetDegree(C1CirOutPoint[k],C1CirInPoint[k-DvCnt]);

													 Target  = Math.OnFindPerpendicularPointXY(C1CirOutPoint[k],dEdgeToTrapLineDis,-dEdgeToTrapLineDis,deg);
													 Edge->OnExecute(C1CirOutPoint[k],Target); // 연마외곽라인에서 Target까지 White Point Search 
													 if(Edge->GetResultEdgePointCount()>0){
														 C1CircleData[DataCount].Dis =0.0f;
														 C1CircleData[DataCount].Dv  =0.0f;
														 C1CircleData[DataCount].P   = Edge->GetResultEdgePoint(0);
														 C1CircleData[DataCount].P.y = C1CircleData[DataCount].P.y - ImageHeight; // Frame기준 단위좌표로 변경함  
														 DataCount++;
													 }
												 }
											 }
											 C1CirInCrackCount = DataCount;
										 }
									 }
									 LogUnit.SetLog(L"CellID:%d, CamID:%d ==>Polygon1_Insp_End",CellId,CamId);     
								 }

								 // 두번째 Polygon, Circle 1
								 if(PolyRect[1].left!=0 && PolyRect[1].top!=0 && PolyRect[1].right!=0 && PolyRect[1].bottom!=0){
									 P1.x=0, P1.y=0, P2.x=0, P2.y=0, P3.x=0, P3.y=0, P4.x=0, P4.y=0;
									 LogUnit.SetLog(L"CellID:%d, CamID:%d ==>Polygon2_Insp_Start",CellId,CamId);     


									 // 										 P1.x = (PolyRect[1].left); P1.y =(PolyRect[1].top             ); P2.x = (P1.x+PolyRect[1].Width()+50); P2.y = (P1.y);
									 // 										 P3.x = (PolyRect[1].left); P3.y =(P1.y+PolyRect[1].Height()+50); P4.x = (P2.x                       ); P4.y = (P3.y);

									 P1.x = (PolyRect[1].left); P1.y =(PolyRect[1].top             ); P2.x = (P1.x+PolyRect[1].Width()); P2.y = (P1.y);
									 P3.x = (PolyRect[1].left); P3.y =(P1.y+PolyRect[1].Height()+20); P4.x = (P2.x                    ); P4.y = (P3.y);


									 // Median Filter 적용 
									 if(P1.x<=0    || P1.y<=0    || (P2.x - P1.x)<=0    || (P3.y - P1.y)<=0   ) return false;
									 if(P1.x>=ImgW || P1.y>=ImgH || (P2.x - P1.x)>=ImgW || (P3.y - P1.y)>=ImgH) return false;
									 //ROI x + Width = 16384 넘어가면 Return //20180808 추가
									 //ROI y + Hight = 1500  넘어가면 Return
									 if( (P1.x + int(P2.x - P1.x)) >= ImgW || (P1.y + int(P3.y - P1.y)) >= ImgH ) return false;
									 FilterROI.SetSize(int(P2.x - P1.x),int(P3.y - P1.y) )                 ;
									 FilterROI.Attach(&RotateBinaryImg)                                    ;
									 FilterROI.SetPlacement(P1.x, P1.y, int(P2.x - P1.x), int(P3.y - P1.y));
									 LogUnit.SetLog(L"Polygon2 ==>Px :%d, Py :%d, Width:%d, Height:%d ==>Median Filter",P1.x, P1.y, int(P2.x - P1.x), int(P3.y - P1.y));     
									 LogUnit.SetLog(L"Polygon2 ==>P1x:%d, P1y:%d, P2x:%d, P2y:%d, P3x:%d, P3y:%d, P4x:%d, P4y:%d,",P1.x,P1.y,P2.x,P2.y,P3.x,P3.y,P4.x,P4.y);     
									 EasyImage::Median(&FilterROI, &FilterROI)                             ;
									 // 										 RotateBinaryImg.Save("D:\\ROTATE_IMG\\Polygon2_필터.bmp");



									 Polygon->GImage          = &RotateBinaryImg            ;
									 Polygon->PoPa.FMaxWidth  =(int)(CenterCircleWidth +200);
									 Polygon->PoPa.FMaxHeight =(int)(CenterCircleHeight+200);
									 Polygon->PoPa.IsSeparate =true                         ;
									 Polygon->PoPa.IsInToOut  =true                         ;
									 Polygon->PoPa.HiThHold   = BtmEdgeThresHold            ;
									 Polygon->PoPa.LoThHold   = 0                           ;
									 Polygon->PoPa.FMinWidth  =(int)(CenterCircleWidth /3)  ;
									 Polygon->PoPa.FMinHeight =(int)(CenterCircleHeight/3)  ;

									 if(P1.x!=0 && P1.y!=0 && P2.x!=0 && P2.y!=0 && P3.x!=0 && P3.y!=0 && P4.x!=0 && P4.y!=0){
										 Polygon->OnExecute(P1,P2,P3,P4);
									 }

									 // Polygon Algorithm InEdgeData/OutEdgeData Separate 및 데이터 추출 
									 if(Polygon->BlobCount==1){
										 PolygonMarginCnt =10;
										 if(Polygon->Blob[0].InCnt>(PolygonMarginCnt*2)){
											 C2CirInEdgeCount=0;
											 C2CirInEdgeCount = (Polygon->Blob[0].InCnt - (PolygonMarginCnt*2));
											 if(C2CirInEdgeCount>0){
												 if(C2CirInPoint!=NULL){
													 delete[] C2CirInPoint;
												 }
												 C2CirInPoint = new TFPoint[C2CirInEdgeCount];

												 PixelCnt=0;
												 for(int k=0; k<Polygon->Blob[0].InCnt; k++){
													 if(k<PolygonMarginCnt || k>=(Polygon->Blob[0].InCnt-PolygonMarginCnt)) continue;
													 C2CirInPoint[PixelCnt].x   = Polygon->Blob[0].InPoint[k].x ;
													 C2CirInPoint[PixelCnt].y   = Polygon->Blob[0].InPoint[k].y ;
													 PixelCnt++;
												 }
											 }
										 }

										 if(Polygon->Blob[0].OutCnt>(PolygonMarginCnt*2)){
											 C2CirOutEdgeCount=0;
											 C2CirOutEdgeCount = (Polygon->Blob[0].OutCnt - (PolygonMarginCnt*2));
											 if(C2CirOutEdgeCount>0){
												 if(C2CirOutPoint!=NULL) delete[] C2CirOutPoint;
												 C2CirOutPoint = new TFPoint[C2CirOutEdgeCount];

												 PixelCnt=0;
												 for(int k=0; k<Polygon->Blob[0].OutCnt; k++){
													 if(k<PolygonMarginCnt || k>=(Polygon->Blob[0].OutCnt-PolygonMarginCnt)) continue;
													 C2CirOutPoint[PixelCnt].x  = Polygon->Blob[0].OutPoint[k].x ;
													 C2CirOutPoint[PixelCnt].y  = Polygon->Blob[0].OutPoint[k].y ;

													 if(k==PolygonMarginCnt)                              { //직선구간에 필요한 시작점  
														 BtmEdgePoint[1].x = C2CirOutPoint[PixelCnt].x;
														 BtmEdgePoint[1].y = C2CirOutPoint[PixelCnt].y;
													 }
													 if(k==(Polygon->Blob[0].OutCnt-(PolygonMarginCnt+1))){ //직선구간에 필요한 끝점 
														 BtmEdgePoint[2].x = C2CirOutPoint[PixelCnt].x;
														 BtmEdgePoint[2].y = C2CirOutPoint[PixelCnt].y;
													 }
													 PixelCnt++;
												 }
											 }
										 }
										 // Polygon Data Clear
										 // 											 Polygon->ClearData();
									 }
									 /////////////////////////////////////////////////////////////////////////////////////////////

									 // InEdgeData/OutEdgeData 기준 가공량 및 연마량 계산
									 // Polygon 알고리즘에서는 GrindMark기준 OutData,InData 최단거리 2개 Tag값 산출해야함 
									 if(IsMarkBtm){ // LTPS 가공량,연마량 계산 
										 if(C2CirOutEdgeCount!=0 && C2CirInEdgeCount!=0){ // MarkMode경우 가공량 검사를 먼저 진행 후 연마량 산출  
											 // 가공량,연마량 측정 전 데이터 존재시 가상GrindMark 생성한다 
											 if(GrindMarkPoint[5].x!=0.0f && GrindMarkPoint[5].y!=0.0f && GrindRectSpec[6].DvX!=0.0f && GrindRectSpec[6].DvY!=0.0f){
												 GrindMarkPoint[6].x     = GrindMarkPoint[5].x + GrindRectSpec[6].DvX;
												 GrindMarkPoint[6].y     = GrindMarkPoint[5].y - GrindRectSpec[6].DvY;
												 GrindMarkRect [6].left  = GrindMarkPoint[6].x    - GrindMarkRange  ;  
												 GrindMarkRect [6].top   = GrindMarkPoint[6].y    - GrindMarkRange  ;  
												 GrindMarkRect [6].right = GrindMarkRect [6].left + GrindMarkLength ;  
												 GrindMarkRect [6].bottom= GrindMarkRect [6].top  + GrindMarkLength ;  
											 }

											 if(GrindMarkPoint[5].x!=0.0f && GrindMarkPoint[5].y!=0.0f){  //GrindMark 찾았을경우 
												 // GrindMark기준 OutData 최단거리 Count정보 Calc 
												 GrindMeaDis =0.0f, MinDis =10000.0f; GrindMarkOutCnt=0;
												 for(int k=0; k<C2CirOutEdgeCount; k++){
													 if(C2CirOutPoint[k].x ==0.0f || C2CirOutPoint[k].y ==0.0f) continue;
													 if(GrindMarkPoint[5].x==0.0f || GrindMarkPoint[5].y==0.0f) continue;

													 GrindMeaDis = Math.GetLength(GrindMarkPoint[5], C2CirOutPoint[k]);
													 if(GrindMeaDis<MinDis){
														 MinDis = GrindMeaDis;
														 GrindMarkOutCnt = k;
													 }
												 }

												 // GrindMark기준 InData 최단거리 Count정보 Calc 
												 if(GrindMarkOutCnt!=0){
													 GrindMeaDis =0.0f, MinDis =10000.0f; GrindMarkInCnt=0;
													 for(int k=0; k<C2CirInEdgeCount; k++){
														 if(C2CirInPoint[k].x   ==0.0f             || C2CirInPoint[k].y                ==0.0f) continue;
														 if(C2CirOutPoint[GrindMarkOutCnt].x==0.0f || C2CirOutPoint[GrindMarkOutCnt].y ==0.0f) continue;

														 GrindMeaDis = Math.GetLength(C2CirOutPoint[GrindMarkOutCnt], C2CirInPoint[k]);
														 if(GrindMeaDis<MinDis){
															 MinDis = GrindMeaDis;
															 GrindMarkInCnt = k;
														 }
													 }
												 }

												 // GrindMark기준 수직 포인트 주변값 Avg산출한다 ==>가공량 측정(OutData기준)
												 if(GrindMarkOutCnt!=0 && GrindMarkOutCnt>5){
													 CircleCount=0,TotalCirDis=0.0f,GrindMeaDis=0.0f;
													 for(int k=GrindMarkOutCnt-5; k<GrindMarkOutCnt+5; k++){
														 if(C2CirOutPoint[k].x==0.0f || C2CirOutPoint[k].y==0.0f) continue;
														 if(k>=C2CirOutEdgeCount                                ) continue;

														 GrindMeaDis = Math.GetLength(GrindMarkPoint[5], C2CirOutPoint[k]);
														 TotalCirDis+= GrindMeaDis;
														 CircleCount++;
													 }
													 if(TotalCirDis!=0.0f && CircleCount!=0){
														 C2CirGrindMea = TotalCirDis/CircleCount;
														 C2CirGrindMea = C2CirGrindMea+0.5; //SubPixel 
													 }
												 }

												 // GrindMark기준 수직 포인트 주변값 Avg산출한다 ==>연마량 측정(OutData,InData기준)
												 if((GrindMarkOutCnt!=0 && GrindMarkOutCnt>5) && (GrindMarkInCnt!=0 && GrindMarkInCnt>5)){
													 CircleCount=0,TotalCirDis=0.0f,GrindWidthDis=0.0f;
													 for(int k=-5; k<5; k++){
														 if(C2CirOutPoint[GrindMarkOutCnt+k].x==0.0f && C2CirOutPoint[GrindMarkOutCnt+k].y==0.0f) continue;
														 if(C2CirInPoint [GrindMarkInCnt +k].x==0.0f && C2CirInPoint [GrindMarkInCnt +k].y==0.0f) continue;
														 if((GrindMarkOutCnt+k)>=C2CirOutEdgeCount                                              ) continue;
														 if((GrindMarkInCnt +k)>=C2CirInEdgeCount                                               ) continue;

														 GrindWidthDis = Math.GetLength(C2CirInPoint[GrindMarkInCnt+k], C2CirOutPoint[GrindMarkOutCnt+k]);
														 TotalCirDis+=   GrindWidthDis;
														 CircleCount++;
													 }
													 if(TotalCirDis!=0.0f && CircleCount!=0){
														 C2CirGrindWd = TotalCirDis/CircleCount;
														 C2CirGrindWd = C2CirGrindWd+0.5; //SubPixel
													 }
												 }
											 }
											 else if(GrindMarkRect[5].left!=0 && GrindMarkRect[5].top!=0 && GrindMarkRect[5].right!=0 &&GrindMarkRect[5].bottom!=0){  //GrindMark 못 찾았을경우
												 // OutData기준 최소값 데이터 Count산출 
												 GrindMeaDis =0.0f, MinDis =10000.0f; GrindMarkOutCnt=0;
												 for(int k=0; k<C2CirOutEdgeCount; k++){
													 if(C2CirOutPoint[k].x==0.0f || C2CirOutPoint[k].y==0.0f) continue;

													 GrindMarkRectCenter[5].x = GrindMarkRect[5].left + (GrindMarkRect[5].right  - GrindMarkRect[5].left)/2; 
													 GrindMarkRectCenter[5].y = GrindMarkRect[5].top  + (GrindMarkRect[5].bottom - GrindMarkRect[5].top )/2; 

													 GrindMeaDis = Math.GetLength(GrindMarkRectCenter[5], C2CirOutPoint[k]);
													 if(GrindMeaDis<MinDis){
														 MinDis = GrindMeaDis;
														 GrindMarkOutCnt = k;
													 }
												 }

												 // 최단거리OUtCount기준 InData 최단거리 Count정보 Calc 
												 if(GrindMarkOutCnt!=0){
													 GrindMeaDis =0.0f, MinDis =10000.0f; GrindMarkInCnt=0;
													 for(int k=0; k<C2CirInEdgeCount; k++){
														 if(C2CirInPoint[k].x   ==0.0f             || C2CirInPoint[k].y                ==0.0f) continue;
														 if(C2CirOutPoint[GrindMarkOutCnt].x==0.0f || C2CirOutPoint[GrindMarkOutCnt].y ==0.0f) continue;

														 GrindMeaDis = Math.GetLength(C2CirOutPoint[GrindMarkOutCnt], C2CirInPoint[k]);
														 if(GrindMeaDis<MinDis){
															 MinDis = GrindMeaDis;
															 GrindMarkInCnt = k;
														 }
													 }
												 }

												 // GrindMark기준 수직 포인트 주변값 Avg산출한다 ==>연마량 측정(OutData,InData기준)
												 if((GrindMarkOutCnt!=0 && GrindMarkOutCnt>5) && (GrindMarkInCnt!=0 && GrindMarkInCnt>5)){
													 CircleCount=0,TotalCirDis=0.0f,GrindWidthDis=0.0f;
													 for(int k=-5; k<5; k++){
														 if(C2CirOutPoint[GrindMarkOutCnt+k].x==0.0f && C2CirOutPoint[GrindMarkOutCnt+k].y==0.0f) continue;
														 if(C2CirInPoint [GrindMarkInCnt +k].x==0.0f && C2CirInPoint [GrindMarkInCnt +k].y==0.0f) continue;
														 if((GrindMarkOutCnt+k)>=C2CirOutEdgeCount                                              ) continue;
														 if((GrindMarkInCnt +k)>=C2CirInEdgeCount                                               ) continue;

														 GrindWidthDis = Math.GetLength(C2CirInPoint[GrindMarkInCnt+k], C2CirOutPoint[GrindMarkOutCnt+k]);
														 TotalCirDis+=   GrindWidthDis;
														 CircleCount++;
													 }
													 if(TotalCirDis!=0.0f && CircleCount!=0){
														 C2CirGrindWd = TotalCirDis/CircleCount;
														 C2CirGrindWd = C2CirGrindWd+0.5; //SubPixel
													 }
												 }
											 }

											 // Grind Mark[6] 가상 마크 데이터 생성 
											 if(GrindMarkPoint[6].x!=0.0f && GrindMarkPoint[6].y!=0.0f){  //GrindMark 찾았을경우 
												 // GrindMark기준 OutData 최단거리 Count정보 Calc 
												 GrindMeaDis =0.0f, MinDis =10000.0f; GrindMarkOutCnt=0;
												 for(int k=0; k<C2CirOutEdgeCount; k++){
													 if(C2CirOutPoint[k].x ==0.0f || C2CirOutPoint[k].y ==0.0f) continue;
													 if(GrindMarkPoint[6].x==0.0f || GrindMarkPoint[6].y==0.0f) continue;

													 GrindMeaDis = Math.GetLength(GrindMarkPoint[6], C2CirOutPoint[k]);
													 if(GrindMeaDis<MinDis){
														 MinDis = GrindMeaDis;
														 GrindMarkOutCnt = k;
													 }
												 }

												 // GrindMark기준 InData 최단거리 Count정보 Calc 
												 if(GrindMarkOutCnt!=0){
													 GrindMeaDis =0.0f, MinDis =10000.0f; GrindMarkInCnt=0;
													 for(int k=0; k<C2CirInEdgeCount; k++){
														 if(C2CirInPoint[k].x   ==0.0f             || C2CirInPoint[k].y                ==0.0f) continue;
														 if(C2CirOutPoint[GrindMarkOutCnt].x==0.0f || C2CirOutPoint[GrindMarkOutCnt].y ==0.0f) continue;

														 GrindMeaDis = Math.GetLength(C2CirOutPoint[GrindMarkOutCnt], C2CirInPoint[k]);
														 if(GrindMeaDis<MinDis){
															 MinDis = GrindMeaDis;
															 GrindMarkInCnt = k;
														 }
													 }
												 }

												 // GrindMark기준 수직 포인트 주변값 Avg산출한다 ==>가공량 측정(OutData기준)
												 if(GrindMarkOutCnt!=0 && GrindMarkOutCnt>5){
													 CircleCount=0,TotalCirDis=0.0f,GrindMeaDis=0.0f;
													 for(int k=GrindMarkOutCnt-5; k<GrindMarkOutCnt+5; k++){
														 if(C2CirOutPoint[k].x==0.0f || C2CirOutPoint[k].y==0.0f) continue;
														 if(k>=C2CirOutEdgeCount                                ) continue;

														 GrindMeaDis = Math.GetLength(GrindMarkPoint[6], C2CirOutPoint[k]);
														 TotalCirDis+= GrindMeaDis;
														 CircleCount++;
													 }
													 if(TotalCirDis!=0.0f && CircleCount!=0){
														 TrenchLeftGrindMea = TotalCirDis/CircleCount;
														 TrenchLeftGrindMea = TrenchLeftGrindMea+0.5; //SubPixel 
													 }
												 }

												 // GrindMark기준 수직 포인트 주변값 Avg산출한다 ==>연마량 측정(OutData,InData기준)
												 if((GrindMarkOutCnt!=0 && GrindMarkOutCnt>5) && (GrindMarkInCnt!=0 && GrindMarkInCnt>5)){
													 CircleCount=0,TotalCirDis=0.0f,GrindWidthDis=0.0f;
													 for(int k=-5; k<5; k++){
														 if(C2CirOutPoint[GrindMarkOutCnt+k].x==0.0f && C2CirOutPoint[GrindMarkOutCnt+k].y==0.0f) continue;
														 if(C2CirInPoint [GrindMarkInCnt +k].x==0.0f && C2CirInPoint [GrindMarkInCnt +k].y==0.0f) continue;
														 if((GrindMarkOutCnt+k)>=C2CirOutEdgeCount                                              ) continue;
														 if((GrindMarkInCnt +k)>=C2CirInEdgeCount                                               ) continue;

														 GrindWidthDis = Math.GetLength(C2CirInPoint[GrindMarkInCnt+k], C2CirOutPoint[GrindMarkOutCnt+k]);
														 TotalCirDis+=   GrindWidthDis;
														 CircleCount++;
													 }
													 if(TotalCirDis!=0.0f && CircleCount!=0){
														 TrenchLeftGrindWd = TotalCirDis/CircleCount;
														 TrenchLeftGrindWd = TrenchLeftGrindWd+0.5; //SubPixel
													 }
												 }
											 }
											 else if(GrindMarkRect[6].left!=0 && GrindMarkRect[6].top!=0 && GrindMarkRect[6].right!=0 &&GrindMarkRect[6].bottom!=0){  //GrindMark 못 찾았을경우
												 // OutData기준 최소값 데이터 Count산출 
												 if(GrindRectSpec[6].DvX!=0.0f && GrindRectSpec[6].DvY!=0.0f){
													 GrindMeaDis =0.0f, MinDis =10000.0f; GrindMarkOutCnt=0;
													 for(int k=0; k<C2CirOutEdgeCount; k++){
														 if(C2CirOutPoint[k].x==0.0f || C2CirOutPoint[k].y==0.0f) continue;

														 if(k==0){
															 GrindMarkRectCenter[6].x     =  GrindMarkRectCenter[5].x + GrindRectSpec[6].DvX;
															 GrindMarkRectCenter[6].y     =  GrindMarkRectCenter[5].y - GrindRectSpec[6].DvY;

															 GrindMarkRect [6].left  = GrindMarkRectCenter[6].x  - GrindMarkRange  ;  
															 GrindMarkRect [6].top   = GrindMarkRectCenter[6].y  - GrindMarkRange  ;  
															 GrindMarkRect [6].right = GrindMarkRect [6].left + GrindMarkLength ;  
															 GrindMarkRect [6].bottom= GrindMarkRect [6].top  + GrindMarkLength ;  
														 }

														 GrindMeaDis = Math.GetLength(GrindMarkRectCenter[6], C2CirOutPoint[k]);
														 if(GrindMeaDis<MinDis){
															 MinDis = GrindMeaDis;
															 GrindMarkOutCnt = k;
														 }
													 }

													 // 최단거리OUtCount기준 InData 최단거리 Count정보 Calc 
													 if(GrindMarkOutCnt!=0){
														 GrindMeaDis =0.0f, MinDis =10000.0f; GrindMarkInCnt=0;
														 for(int k=0; k<C2CirInEdgeCount; k++){
															 if(C2CirInPoint[k].x   ==0.0f             || C2CirInPoint[k].y                ==0.0f) continue;
															 if(C2CirOutPoint[GrindMarkOutCnt].x==0.0f || C2CirOutPoint[GrindMarkOutCnt].y ==0.0f) continue;

															 GrindMeaDis = Math.GetLength(C2CirOutPoint[GrindMarkOutCnt], C2CirInPoint[k]);
															 if(GrindMeaDis<MinDis){
																 MinDis = GrindMeaDis;
																 GrindMarkInCnt = k;
															 }
														 }
													 }

													 // GrindMark기준 수직 포인트 주변값 Avg산출한다 ==>연마량 측정(OutData,InData기준)
													 if((GrindMarkOutCnt!=0 && GrindMarkOutCnt>5) && (GrindMarkInCnt!=0 && GrindMarkInCnt>5)){
														 CircleCount=0,TotalCirDis=0.0f,GrindWidthDis=0.0f;
														 for(int k=-5; k<5; k++){
															 if(C2CirOutPoint[GrindMarkOutCnt+k].x==0.0f && C2CirOutPoint[GrindMarkOutCnt+k].y==0.0f) continue;
															 if(C2CirInPoint [GrindMarkInCnt +k].x==0.0f && C2CirInPoint [GrindMarkInCnt +k].y==0.0f) continue;
															 if((GrindMarkOutCnt+k)>=C2CirOutEdgeCount                                              ) continue;
															 if((GrindMarkInCnt +k)>=C2CirInEdgeCount                                               ) continue;

															 GrindWidthDis = Math.GetLength(C2CirInPoint[GrindMarkInCnt+k], C2CirOutPoint[GrindMarkOutCnt+k]);
															 TotalCirDis+=   GrindWidthDis;
															 CircleCount++;
														 }
														 if(TotalCirDis!=0.0f && CircleCount!=0){
															 TrenchLeftGrindWd = TotalCirDis/CircleCount;
															 TrenchLeftGrindWd = TrenchLeftGrindWd+0.5; //SubPixel
														 }
													 }
												 }
											 }
										 }
									 }
									 else         { //Polygon EnCap 계산시 OutPoint 중간값 기준 실측 거리 평균값을 계산한다(LeftTop) 
										 if(C2CirInEdgeCount!=0 && C2CirOutEdgeCount!=0){
											 GrindMeaDis =0.0f, MinDis =10000.0f; GrindMarkOutCnt=0;
											 GrindMarkOutCnt = (int)(C2CirOutEdgeCount/2);
											 // 최단거리OUtCount기준 InData 최단거리 Count정보 Calc 
											 if(GrindMarkOutCnt!=0){
												 GrindMeaDis =0.0f, MinDis =10000.0f; GrindMarkInCnt=0;
												 for(int k=0; k<C2CirInEdgeCount; k++){
													 if(C2CirInPoint[k].x   ==0.0f             || C2CirInPoint[k].y                ==0.0f) continue;
													 if(C2CirOutPoint[GrindMarkOutCnt].x==0.0f || C2CirOutPoint[GrindMarkOutCnt].y ==0.0f) continue;

													 GrindMeaDis = Math.GetLength(C2CirOutPoint[GrindMarkOutCnt], C2CirInPoint[k]);
													 if(GrindMeaDis<MinDis){
														 MinDis = GrindMeaDis;
														 GrindMarkInCnt = k;
													 }
												 }
											 }

											 // GrindMark기준 수직 포인트 주변값 Avg산출한다 ==>연마량 측정(OutData,InData기준)
											 if((GrindMarkOutCnt!=0 && GrindMarkOutCnt>5) && (GrindMarkInCnt!=0 && GrindMarkInCnt>5)){
												 CircleCount=0,TotalCirDis=0.0f,GrindWidthDis=0.0f;
												 for(int k=-5; k<5; k++){
													 if(C2CirOutPoint[GrindMarkOutCnt+k].x==0.0f && C2CirOutPoint[GrindMarkOutCnt+k].y==0.0f) continue;
													 if(C2CirInPoint [GrindMarkInCnt +k].x==0.0f && C2CirInPoint [GrindMarkInCnt +k].y==0.0f) continue;
													 if((GrindMarkOutCnt+k)>=C2CirOutEdgeCount                                              ) continue;
													 if((GrindMarkInCnt +k)>=C2CirInEdgeCount                                               ) continue;

													 GrindWidthDis = Math.GetLength(C2CirInPoint[GrindMarkInCnt+k], C2CirOutPoint[GrindMarkOutCnt+k]);
													 TotalCirDis+=   GrindWidthDis;
													 CircleCount++;
												 }
												 if(TotalCirDis!=0.0f && CircleCount!=0){
													 C2CirGrindWd = TotalCirDis/CircleCount;
													 C2CirGrindWd = C2CirGrindWd+0.5; //SubPixel
												 }
											 }
										 }
									 }
									 ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
									 // FAVION Circle Fitting 결과물(Circle_1)
									 SampleSize   = C2CirInEdgeCount*0.75; //0.5~0.8이하로 입력할것
									 DistDevRatio = 0.15                 ; //0.1~0.25 이하로 입력할것
									 CircleFit->OnRansac(C2CirInPoint,C2CirInEdgeCount,SampleSize,DistDevRatio,&CircleFit2Center,&CirFitDiameter2);

									 // Polygon 박리 검사 시퀀스 
									 if(!IsMarkBtm && BrokenThresHold!=0){
										 RotateBrokenImg.SetSize(RotateImg.GetWidth(), RotateImg.GetHeight());
										 EasyImage::Oper(EArithmeticLogicOperation_Copy,&RotateImg,&RotateBrokenImg);
										 EasyImage::Threshold(&RotateImg,&RotateBrokenImg, BrokenThresHold);
										 Edge->GImage = &RotateBrokenImg;
										 Edge->SetEdgeType(0);

										 int DvCnt =0, DataCount=0;
										 double deg =0.0f; 
										 TFPoint Target(0.0f, 0.0f);

										 if(GrindMarkInCnt>GrindMarkOutCnt){
											 DvCnt = GrindMarkInCnt - GrindMarkOutCnt;
											 for(int k=0; k<C2CirOutEdgeCount; k++){
												 deg =0.0f, Target.x =0.0f, Target.y =0.0f;
												 if(((k+DvCnt)<C2CirInEdgeCount) && C2CirInPoint[k+DvCnt].x>0  && C2CirInPoint[k+DvCnt].y>0){
													 deg = Math.GetDegree(C2CirOutPoint[k],C2CirInPoint[k+DvCnt]);

													 Target  = Math.OnFindPerpendicularPointXY(C2CirOutPoint[k],-dEdgeToTrapLineDis,-dEdgeToTrapLineDis,deg);
													 Edge->OnExecute(C2CirOutPoint[k],Target); // 연마외곽라인에서 Target까지 White Point Search 
													 if(Edge->GetResultEdgePointCount()>0){
														 C2CircleData[DataCount].Dis =0.0f;
														 C2CircleData[DataCount].Dv  =0.0f;
														 C2CircleData[DataCount].P   = Edge->GetResultEdgePoint(0);
														 C2CircleData[DataCount].P.y = C2CircleData[DataCount].P.y - ImageHeight; // Frame기준 단위좌표로 변경함  
														 DataCount++;
													 }
												 }
											 }
											 C2CirInCrackCount = DataCount;
										 }
										 else if(GrindMarkInCnt<GrindMarkOutCnt)   {
											 DvCnt = GrindMarkOutCnt - GrindMarkInCnt;
											 for(int k=DvCnt; k<C2CirOutEdgeCount; k++){
												 deg =0.0f, Target.x =0.0f, Target.y =0.0f;
												 if(((k-DvCnt)<C2CirInEdgeCount) && C2CirInPoint[k-DvCnt].x>0  && C2CirInPoint[k-DvCnt].y>0 && k-DvCnt>=0){
													 deg = Math.GetDegree(C2CirOutPoint[k],C2CirInPoint[k-DvCnt]);

													 Target  = Math.OnFindPerpendicularPointXY(C2CirOutPoint[k],-dEdgeToTrapLineDis,-dEdgeToTrapLineDis,deg);
													 Edge->OnExecute(C2CirOutPoint[k],Target); // 연마외곽라인에서 Target까지 White Point Search 
													 if(Edge->GetResultEdgePointCount()>0){
														 C2CircleData[DataCount].Dis =0.0f;
														 C2CircleData[DataCount].Dv  =0.0f;
														 C2CircleData[DataCount].P   = Edge->GetResultEdgePoint(0);
														 C2CircleData[DataCount].P.y = C2CircleData[DataCount].P.y - ImageHeight; // Frame기준 단위좌표로 변경함  
														 DataCount++;
													 }
												 }
											 }
											 C2CirInCrackCount = DataCount;
										 }
									 }
									 LogUnit.SetLog(L"CellID:%d, CamID:%d ==>Polygon2_Insp_End",CellId,CamId);     
								 }

								 // 세번째 Polygon, Circle 1
								 if(PolyRect[2].left!=0 && PolyRect[2].top!=0 && PolyRect[2].right!=0 && PolyRect[2].bottom!=0){
									 P1.x=0, P1.y=0, P2.x=0, P2.y=0, P3.x=0, P3.y=0, P4.x=0, P4.y=0;
									 LogUnit.SetLog(L"CellID:%d, CamID:%d ==>Polygon3_Insp_Start",CellId,CamId);     

									 // 										 P1.x = (PolyRect[2].left-50); P1.y =(PolyRect[2].top-50          ); P2.x = (P1.x+PolyRect[2].Width()+50); P2.y = (P1.y);
									 // 										 P3.x = (PolyRect[2].left-50); P3.y =(P1.y+PolyRect[2].Height()+50); P4.x = (P2.x                       ); P4.y = (P3.y);

									 P1.x = (PolyRect[2].left); P1.y =(PolyRect[2].top-20          ); P2.x = (P1.x+PolyRect[2].Width()); P2.y = (P1.y);
									 P3.x = (PolyRect[2].left); P3.y =(P1.y+PolyRect[2].Height()+20); P4.x = (P2.x                    ); P4.y = (P3.y);


									 // Median Filter 적용 
									 if(P1.x<=0    || P1.y<=0    || (P2.x - P1.x)<=0    || (P3.y - P1.y)<=0   ) return false;
									 if(P1.x>=ImgW || P1.y>=ImgH || (P2.x - P1.x)>=ImgW || (P3.y - P1.y)>=ImgH) return false;
									 //ROI x + Width = 16384 넘어가면 Return //20180808 추가
									 //ROI y + Hight = 1500  넘어가면 Return
									 if( (P1.x + int(P2.x - P1.x)) >= ImgW || (P1.y + int(P3.y - P1.y)) >= ImgH ) return false;
									 FilterROI.SetSize(int(P2.x - P1.x),int(P3.y - P1.y) )                      ;
									 FilterROI.Attach(&RotateBinaryImg)                                    ;
									 FilterROI.SetPlacement(P1.x, P1.y, int(P2.x - P1.x), int(P3.y - P1.y));
									 LogUnit.SetLog(L"Polygon3 ==>Px :%d, Py :%d, Width:%d, Height:%d ==>Median Filter",P1.x, P1.y, int(P2.x - P1.x), int(P3.y - P1.y));     
									 LogUnit.SetLog(L"Polygon3 ==>P1x:%d, P1y:%d, P2x:%d, P2y:%d, P3x:%d, P3y:%d, P4x:%d, P4y:%d,",P1.x,P1.y,P2.x,P2.y,P3.x,P3.y,P4.x,P4.y);     
									 EasyImage::Median(&FilterROI, &FilterROI)                             ;
									 // 										 RotateBinaryImg.Save("D:\\ROTATE_IMG\\Polygon3_필터.bmp")             ;



									 Polygon->GImage          = &RotateBinaryImg            ;
									 Polygon->PoPa.FMaxWidth  =(int)(CenterCircleWidth +200);
									 Polygon->PoPa.FMaxHeight =(int)(CenterCircleHeight+200);
									 Polygon->PoPa.IsSeparate =true                         ;
									 Polygon->PoPa.IsInToOut  =true                         ;
									 Polygon->PoPa.HiThHold   = BtmEdgeThresHold            ;
									 Polygon->PoPa.LoThHold   = 0                           ;
									 Polygon->PoPa.FMinWidth  =(int)(CenterCircleWidth /3)  ;
									 Polygon->PoPa.FMinHeight =(int)(CenterCircleHeight/3)  ;

									 if(P1.x!=0 && P1.y!=0 && P2.x!=0 && P2.y!=0 && P3.x!=0 && P3.y!=0 && P4.x!=0 && P4.y!=0){
										 Polygon->OnExecute(P1,P2,P3,P4);
									 }

									 // Polygon Algorithm InEdgeData/OutEdgeData Separate 및 데이터 추출 
									 if(Polygon->BlobCount==1){
										 PolygonMarginCnt =10;
										 if(Polygon->Blob[0].InCnt>(PolygonMarginCnt*2)){
											 C3CirInEdgeCount=0;
											 C3CirInEdgeCount = (Polygon->Blob[0].InCnt - (PolygonMarginCnt*2));
											 if(C3CirInEdgeCount>0){
												 if(C3CirInPoint!=NULL) {
													 delete[] C3CirInPoint;
												 }
												 C3CirInPoint = new TFPoint[C3CirInEdgeCount];

												 PixelCnt=0;
												 for(int k=0; k<Polygon->Blob[0].InCnt; k++){
													 if(k<PolygonMarginCnt || k>=(Polygon->Blob[0].InCnt-PolygonMarginCnt)) continue;
													 C3CirInPoint[PixelCnt].x   = Polygon->Blob[0].InPoint[k].x ;
													 C3CirInPoint[PixelCnt].y   = Polygon->Blob[0].InPoint[k].y ;
													 PixelCnt++;
												 }
											 }
										 }

										 if(Polygon->Blob[0].OutCnt>(PolygonMarginCnt*2)){
											 C3CirOutEdgeCount=0;
											 C3CirOutEdgeCount = (Polygon->Blob[0].OutCnt - (PolygonMarginCnt*2));
											 if(C3CirOutEdgeCount>0){
												 if(C3CirOutPoint!=NULL) delete[] C3CirOutPoint;
												 C3CirOutPoint = new TFPoint[C3CirOutEdgeCount];

												 PixelCnt=0;
												 for(int k=0; k<Polygon->Blob[0].OutCnt; k++){
													 if(k<PolygonMarginCnt || k>=(Polygon->Blob[0].OutCnt-PolygonMarginCnt)) continue;
													 C3CirOutPoint[PixelCnt].x  = Polygon->Blob[0].OutPoint[k].x ;
													 C3CirOutPoint[PixelCnt].y  = Polygon->Blob[0].OutPoint[k].y ;

													 if(k==PolygonMarginCnt)                              { //직선구간에 필요한 시작점  
														 BtmEdgePoint[3].x = C3CirOutPoint[PixelCnt].x;
														 BtmEdgePoint[3].y = C3CirOutPoint[PixelCnt].y;
													 }
													 if(k==(Polygon->Blob[0].OutCnt-(PolygonMarginCnt+1))){ //직선구간에 필요한 끝점 
														 BtmEdgePoint[4].x = C3CirOutPoint[PixelCnt].x;
														 BtmEdgePoint[4].y = C3CirOutPoint[PixelCnt].y;
													 }
													 PixelCnt++;
												 }
											 }
										 }
										 // Polygon Data Clear
										 // 											 Polygon->ClearData();
									 }
									 /////////////////////////////////////////////////////////////////////////////////////////////

									 // InEdgeData/OutEdgeData 기준 가공량 및 연마량 계산
									 // Polygon 알고리즘에서는 GrindMark기준 OutData,InData 최단거리 2개 Tag값 산출해야함 
									 if(IsMarkBtm){ // LTPS 가공량,연마량 계산 
										 if(C3CirOutEdgeCount!=0 && C3CirInEdgeCount!=0){ // MarkMode경우 가공량 검사를 먼저 진행 후 연마량 산출  
											 if(GrindMarkPoint[7].x!=0.0f && GrindMarkPoint[7].y!=0.0f){  //GrindMark 찾았을경우 
												 // GrindMark기준 OutData 최단거리 Count정보 Calc 
												 GrindMeaDis =0.0f, MinDis =10000.0f; GrindMarkOutCnt=0;
												 for(int k=0; k<C3CirOutEdgeCount; k++){
													 if(C3CirOutPoint[k].x ==0.0f || C3CirOutPoint[k].y ==0.0f) continue;
													 if(GrindMarkPoint[7].x==0.0f || GrindMarkPoint[7].y==0.0f) continue;

													 GrindMeaDis = Math.GetLength(GrindMarkPoint[7], C3CirOutPoint[k]);
													 if(GrindMeaDis<MinDis){
														 MinDis = GrindMeaDis;
														 GrindMarkOutCnt = k;
													 }
												 }

												 // GrindMark기준 InData 최단거리 Count정보 Calc 
												 if(GrindMarkOutCnt!=0){
													 GrindMeaDis =0.0f, MinDis =10000.0f; GrindMarkInCnt=0;
													 for(int k=0; k<C3CirInEdgeCount; k++){
														 if(C3CirInPoint[k].x   ==0.0f             || C3CirInPoint[k].y                ==0.0f) continue;
														 if(C3CirOutPoint[GrindMarkOutCnt].x==0.0f || C3CirOutPoint[GrindMarkOutCnt].y ==0.0f) continue;

														 GrindMeaDis = Math.GetLength(C3CirOutPoint[GrindMarkOutCnt], C3CirInPoint[k]);
														 if(GrindMeaDis<MinDis){
															 MinDis = GrindMeaDis;
															 GrindMarkInCnt = k;
														 }
													 }
												 }

												 // GrindMark기준 수직 포인트 주변값 Avg산출한다 ==>가공량 측정(OutData기준)
												 if(GrindMarkOutCnt!=0 && GrindMarkOutCnt>5){
													 CircleCount=0,TotalCirDis=0.0f,GrindMeaDis=0.0f;
													 for(int k=GrindMarkOutCnt-5; k<GrindMarkOutCnt+5; k++){
														 if(C3CirOutPoint[k].x==0.0f || C3CirOutPoint[k].y==0.0f) continue;
														 if(k>=C3CirOutEdgeCount                                ) continue;

														 GrindMeaDis = Math.GetLength(GrindMarkPoint[7], C3CirOutPoint[k]);
														 TotalCirDis+= GrindMeaDis;
														 CircleCount++;
													 }
													 if(TotalCirDis!=0.0f && CircleCount!=0){
														 C3CirGrindMea = TotalCirDis/CircleCount;
														 C3CirGrindMea = C3CirGrindMea+0.5; //SubPixel 
													 }
												 }

												 // GrindMark기준 수직 포인트 주변값 Avg산출한다 ==>연마량 측정(OutData,InData기준)
												 if((GrindMarkOutCnt!=0 && GrindMarkOutCnt>5) && (GrindMarkInCnt!=0 && GrindMarkInCnt>5)){
													 CircleCount=0,TotalCirDis=0.0f,GrindWidthDis=0.0f;
													 for(int k=-5; k<5; k++){
														 if(C3CirOutPoint[GrindMarkOutCnt+k].x==0.0f && C3CirOutPoint[GrindMarkOutCnt+k].y==0.0f) continue;
														 if(C3CirInPoint [GrindMarkInCnt +k].x==0.0f && C3CirInPoint [GrindMarkInCnt +k].y==0.0f) continue;
														 if((GrindMarkOutCnt+k)>=C3CirOutEdgeCount                                              ) continue;
														 if((GrindMarkInCnt +k)>=C3CirInEdgeCount                                               ) continue;

														 GrindWidthDis = Math.GetLength(C3CirInPoint[GrindMarkInCnt+k], C3CirOutPoint[GrindMarkOutCnt+k]);
														 TotalCirDis+=   GrindWidthDis;
														 CircleCount++;
													 }
													 if(TotalCirDis!=0.0f && CircleCount!=0){
														 C3CirGrindWd = TotalCirDis/CircleCount;
														 C3CirGrindWd = C3CirGrindWd+0.5; //SubPixel
													 }
												 }
											 }
											 else if(GrindMarkRect[7].left!=0 && GrindMarkRect[7].top!=0 && GrindMarkRect[7].right!=0 &&GrindMarkRect[7].bottom!=0){  //GrindMark 못 찾았을경우
												 // OutData기준 최소값 데이터 Count산출 
												 GrindMeaDis =0.0f, MinDis =10000.0f; GrindMarkOutCnt=0;
												 for(int k=0; k<C3CirOutEdgeCount; k++){
													 if(C3CirOutPoint[k].x==0.0f || C3CirOutPoint[k].y==0.0f) continue;

													 GrindMarkRectCenter[7].x = GrindMarkRect[7].left + (GrindMarkRect[7].right  - GrindMarkRect[7].left)/2; 
													 GrindMarkRectCenter[7].y = GrindMarkRect[7].top  + (GrindMarkRect[7].bottom - GrindMarkRect[7].top )/2; 

													 GrindMeaDis = Math.GetLength(GrindMarkRectCenter[7], C3CirOutPoint[k]);
													 if(GrindMeaDis<MinDis){
														 MinDis = GrindMeaDis;
														 GrindMarkOutCnt = k;
													 }
												 }

												 // 최단거리OUtCount기준 InData 최단거리 Count정보 Calc 
												 if(GrindMarkOutCnt!=0){
													 GrindMeaDis =0.0f, MinDis =10000.0f; GrindMarkInCnt=0;
													 for(int k=0; k<C3CirInEdgeCount; k++){
														 if(C3CirInPoint[k].x   ==0.0f             || C3CirInPoint[k].y                ==0.0f) continue;
														 if(C3CirOutPoint[GrindMarkOutCnt].x==0.0f || C3CirOutPoint[GrindMarkOutCnt].y ==0.0f) continue;

														 GrindMeaDis = Math.GetLength(C3CirOutPoint[GrindMarkOutCnt], C3CirInPoint[k]);
														 if(GrindMeaDis<MinDis){
															 MinDis = GrindMeaDis;
															 GrindMarkInCnt = k;
														 }
													 }
												 }

												 // GrindMark기준 수직 포인트 주변값 Avg산출한다 ==>연마량 측정(OutData,InData기준)
												 if((GrindMarkOutCnt!=0 && GrindMarkOutCnt>5) && (GrindMarkInCnt!=0 && GrindMarkInCnt>5)){
													 CircleCount=0,TotalCirDis=0.0f,GrindWidthDis=0.0f;
													 for(int k=-5; k<5; k++){
														 if(C3CirOutPoint[GrindMarkOutCnt+k].x==0.0f && C3CirOutPoint[GrindMarkOutCnt+k].y==0.0f) continue;
														 if(C3CirInPoint [GrindMarkInCnt +k].x==0.0f && C3CirInPoint [GrindMarkInCnt +k].y==0.0f) continue;
														 if((GrindMarkOutCnt+k)>=C3CirOutEdgeCount                                              ) continue;
														 if((GrindMarkInCnt +k)>=C3CirInEdgeCount                                               ) continue;

														 GrindWidthDis = Math.GetLength(C3CirInPoint[GrindMarkInCnt+k], C3CirOutPoint[GrindMarkOutCnt+k]);
														 TotalCirDis+=   GrindWidthDis;
														 CircleCount++;
													 }
													 if(TotalCirDis!=0.0f && CircleCount!=0){
														 C3CirGrindWd = TotalCirDis/CircleCount;
														 C3CirGrindWd = C3CirGrindWd+0.5; //SubPixel
													 }
												 }
											 }
										 }
									 }
									 else         { //Polygon EnCap 계산시 OutPoint 중간값 기준 실측 거리 평균값을 계산한다(LeftTop) 
										 if(C3CirInEdgeCount!=0 && C3CirOutEdgeCount!=0){
											 GrindMeaDis =0.0f, MinDis =10000.0f; GrindMarkOutCnt=0;
											 GrindMarkOutCnt = (int)(C3CirOutEdgeCount/2);
											 // 최단거리OUtCount기준 InData 최단거리 Count정보 Calc 
											 if(GrindMarkOutCnt!=0){
												 GrindMeaDis =0.0f, MinDis =10000.0f; GrindMarkInCnt=0;
												 for(int k=0; k<C3CirInEdgeCount; k++){
													 if(C3CirInPoint[k].x   ==0.0f             || C3CirInPoint[k].y                ==0.0f) continue;
													 if(C3CirOutPoint[GrindMarkOutCnt].x==0.0f || C3CirOutPoint[GrindMarkOutCnt].y ==0.0f) continue;

													 GrindMeaDis = Math.GetLength(C3CirOutPoint[GrindMarkOutCnt], C3CirInPoint[k]);
													 if(GrindMeaDis<MinDis){
														 MinDis = GrindMeaDis;
														 GrindMarkInCnt = k;
													 }
												 }
											 }

											 // GrindMark기준 수직 포인트 주변값 Avg산출한다 ==>연마량 측정(OutData,InData기준)
											 if((GrindMarkOutCnt!=0 && GrindMarkOutCnt>5) && (GrindMarkInCnt!=0 && GrindMarkInCnt>5)){
												 CircleCount=0,TotalCirDis=0.0f,GrindWidthDis=0.0f;
												 for(int k=-5; k<5; k++){
													 if(C3CirOutPoint[GrindMarkOutCnt+k].x==0.0f && C3CirOutPoint[GrindMarkOutCnt+k].y==0.0f) continue;
													 if(C3CirInPoint [GrindMarkInCnt +k].x==0.0f && C3CirInPoint [GrindMarkInCnt +k].y==0.0f) continue;
													 if((GrindMarkOutCnt+k)>=C3CirOutEdgeCount                                              ) continue;
													 if((GrindMarkInCnt +k)>=C3CirInEdgeCount                                               ) continue;

													 GrindWidthDis = Math.GetLength(C3CirInPoint[GrindMarkInCnt+k], C3CirOutPoint[GrindMarkOutCnt+k]);
													 TotalCirDis+=   GrindWidthDis;
													 CircleCount++;
												 }
												 if(TotalCirDis!=0.0f && CircleCount!=0){
													 C3CirGrindWd = TotalCirDis/CircleCount;
													 C3CirGrindWd = C3CirGrindWd+0.5; //SubPixel
												 }
											 }
										 }
									 }
									 ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
									 // FAVION Circle Fitting 결과물(Circle_1)
									 SampleSize   = C3CirInEdgeCount*0.75; //0.5~0.8이하로 입력할것
									 DistDevRatio = 0.15                 ; //0.1~0.25 이하로 입력할것
									 CircleFit->OnRansac(C3CirInPoint,C3CirInEdgeCount,SampleSize,DistDevRatio,&CircleFit3Center,&CirFitDiameter3);

									 // Polygon 박리 검사 시퀀스 
									 if(!IsMarkBtm && BrokenThresHold!=0){
										 RotateBrokenImg.SetSize(RotateImg.GetWidth(), RotateImg.GetHeight());
										 EasyImage::Oper(EArithmeticLogicOperation_Copy,&RotateImg,&RotateBrokenImg);
										 EasyImage::Threshold(&RotateImg,&RotateBrokenImg, BrokenThresHold);
										 Edge->GImage = &RotateBrokenImg;
										 Edge->SetEdgeType(0);
										 // 											 RotateBrokenImg.Save("D:\\ROTATE_IMG\\Polygon_박리.bmp");

										 int DvCnt =0, DataCount=0;
										 double deg =0.0f; 
										 TFPoint Target(0.0f, 0.0f);

										 if(GrindMarkInCnt>GrindMarkOutCnt){
											 DvCnt = GrindMarkInCnt - GrindMarkOutCnt;
											 for(int k=0; k<C3CirOutEdgeCount; k++){
												 deg =0.0f, Target.x =0.0f, Target.y =0.0f;
												 if(((k+DvCnt)<C3CirInEdgeCount) && C3CirInPoint[k+DvCnt].x>0  && C3CirInPoint[k+DvCnt].y>0){
													 deg = Math.GetDegree(C3CirOutPoint[k],C3CirInPoint[k+DvCnt]);

													 Target  = Math.OnFindPerpendicularPointXY(C3CirOutPoint[k],-dEdgeToTrapLineDis,-dEdgeToTrapLineDis,deg);
													 Edge->OnExecute(C3CirOutPoint[k],Target); // 연마외곽라인에서 Target까지 White Point Search 
													 if(Edge->GetResultEdgePointCount()>0){
														 C3CircleData[DataCount].Dis =0.0f;
														 C3CircleData[DataCount].Dv  =0.0f;
														 C3CircleData[DataCount].P   = Edge->GetResultEdgePoint(0);
														 C3CircleData[DataCount].P.y = C3CircleData[DataCount].P.y - ImageHeight; // Frame기준 단위좌표로 변경함  
														 DataCount++;
													 }
												 }
											 }
											 C3CirInCrackCount = DataCount;
										 }
										 else if(GrindMarkInCnt<GrindMarkOutCnt)   {
											 DvCnt = GrindMarkOutCnt - GrindMarkInCnt;
											 for(int k=DvCnt; k<C3CirOutEdgeCount; k++){
												 deg =0.0f, Target.x =0.0f, Target.y =0.0f;
												 if(((k-DvCnt)<C3CirInEdgeCount) && C3CirInPoint[k-DvCnt].x>0  && C3CirInPoint[k-DvCnt].y>0 && k-DvCnt>=0){
													 deg = Math.GetDegree(C3CirOutPoint[k],C3CirInPoint[k-DvCnt]);

													 Target  = Math.OnFindPerpendicularPointXY(C3CirOutPoint[k],-dEdgeToTrapLineDis,-dEdgeToTrapLineDis,deg);
													 Edge->OnExecute(C3CirOutPoint[k],Target); // 연마외곽라인에서 Target까지 White Point Search 
													 if(Edge->GetResultEdgePointCount()>0){
														 C3CircleData[DataCount].Dis =0.0f;
														 C3CircleData[DataCount].Dv  =0.0f;
														 C3CircleData[DataCount].P   = Edge->GetResultEdgePoint(0);
														 C3CircleData[DataCount].P.y = C3CircleData[DataCount].P.y - ImageHeight; // Frame기준 단위좌표로 변경함  
														 DataCount++;
													 }
												 }
											 }
											 C3CirInCrackCount = DataCount;
										 }
									 }
									 LogUnit.SetLog(L"CellID:%d, CamID:%d ==>Polygon3_Insp_End",CellId,CamId);     
								 }

								 // 네번째 Polygon, Circle 1
								 if(PolyRect[3].left!=0 && PolyRect[3].top!=0 && PolyRect[3].right!=0 && PolyRect[3].bottom!=0){
									 P1.x=0, P1.y=0, P2.x=0, P2.y=0, P3.x=0, P3.y=0, P4.x=0, P4.y=0;
									 LogUnit.SetLog(L"CellID:%d, CamID:%d ==>Polygon4_Insp_Start",CellId,CamId);     

									 // 										 P1.x = (PolyRect[3].left); P1.y =(PolyRect[3].top-50          ); P2.x = (P1.x+PolyRect[3].Width()+50); P2.y = (P1.y);
									 // 										 P3.x = (PolyRect[3].left); P3.y =(P1.y+PolyRect[3].Height()+50); P4.x = (P2.x                       ); P4.y = (P3.y);

									 P1.x = (PolyRect[3].left); P1.y =(PolyRect[3].top-20          ); P2.x = (P1.x+PolyRect[3].Width()); P2.y = (P1.y);
									 P3.x = (PolyRect[3].left); P3.y =(P1.y+PolyRect[3].Height()+20); P4.x = (P2.x                    ); P4.y = (P3.y);

									 // Median Filter 적용 
									 if(P1.x<=0    || P1.y<=0    || (P2.x - P1.x)<=0    || (P3.y - P1.y)<=0   ) return false;
									 if(P1.x>=ImgW || P1.y>=ImgH || (P2.x - P1.x)>=ImgW || (P3.y - P1.y)>=ImgH) return false;
									 //ROI x + Width = 16384 넘어가면 Return //20180808 추가
									 //ROI y + Hight = 1500  넘어가면 Return
									 if( (P1.x + int(P2.x - P1.x)) >= ImgW || (P1.y + int(P3.y - P1.y)) >= ImgH ) return false;
									 FilterROI.SetSize(int(P2.x - P1.x),int(P3.y - P1.y) )                      ;
									 FilterROI.Attach(&RotateBinaryImg)                                    ;
									 FilterROI.SetPlacement(P1.x, P1.y, int(P2.x - P1.x), int(P3.y - P1.y));
									 LogUnit.SetLog(L"Polygon4 ==>Px :%d, Py :%d, Width:%d, Height:%d ==>Median Filter",P1.x, P1.y, int(P2.x - P1.x), int(P3.y - P1.y));     
									 LogUnit.SetLog(L"Polygon4 ==>P1x:%d, P1y:%d, P2x:%d, P2y:%d, P3x:%d, P3y:%d, P4x:%d, P4y:%d,",P1.x,P1.y,P2.x,P2.y,P3.x,P3.y,P4.x,P4.y);     
									 EasyImage::Median(&FilterROI, &FilterROI)                             ;
									 // 										 RotateBinaryImg.Save("D:\\ROTATE_IMG\\Polygon4_필터.bmp")             ;



									 Polygon->GImage          = &RotateBinaryImg            ;
									 Polygon->PoPa.FMaxWidth  =(int)(CenterCircleWidth +200);
									 Polygon->PoPa.FMaxHeight =(int)(CenterCircleHeight+200);
									 Polygon->PoPa.IsSeparate =true                         ;
									 Polygon->PoPa.IsInToOut  =true                         ;
									 Polygon->PoPa.HiThHold   = BtmEdgeThresHold            ;
									 Polygon->PoPa.LoThHold   = 0                           ;
									 Polygon->PoPa.FMinWidth  =(int)(CenterCircleWidth /3)  ;
									 Polygon->PoPa.FMinHeight =(int)(CenterCircleHeight/3)  ;

									 if(P1.x!=0 && P1.y!=0 && P2.x!=0 && P2.y!=0 && P3.x!=0 && P3.y!=0 && P4.x!=0 && P4.y!=0){
										 Polygon->OnExecute(P1,P2,P3,P4);
									 }

									 // Polygon Algorithm InEdgeData/OutEdgeData Separate 및 데이터 추출 
									 if(Polygon->BlobCount==1){
										 PolygonMarginCnt =10;
										 if(Polygon->Blob[0].InCnt>(PolygonMarginCnt*2)){
											 C4CirInEdgeCount=0;
											 C4CirInEdgeCount = (Polygon->Blob[0].InCnt - (PolygonMarginCnt*2));
											 if(C4CirInEdgeCount>0){
												 if(C4CirInPoint!=NULL) {
													 delete[] C4CirInPoint;
												 }
												 C4CirInPoint = new TFPoint[C4CirInEdgeCount];

												 PixelCnt=0;
												 for(int k=0; k<Polygon->Blob[0].InCnt; k++){
													 if(k<PolygonMarginCnt || k>=(Polygon->Blob[0].InCnt-PolygonMarginCnt)) continue;
													 C4CirInPoint[PixelCnt].x   = Polygon->Blob[0].InPoint[k].x ;
													 C4CirInPoint[PixelCnt].y   = Polygon->Blob[0].InPoint[k].y ;
													 PixelCnt++;
												 }
											 }
										 }

										 if(Polygon->Blob[0].OutCnt>(PolygonMarginCnt*2)){
											 C4CirOutEdgeCount=0;
											 C4CirOutEdgeCount = (Polygon->Blob[0].OutCnt - (PolygonMarginCnt*2));
											 if(C4CirOutEdgeCount>0){
												 if(C4CirOutPoint!=NULL) delete[] C4CirOutPoint;
												 C4CirOutPoint = new TFPoint[C4CirOutEdgeCount];

												 PixelCnt=0;
												 for(int k=0; k<Polygon->Blob[0].OutCnt; k++){
													 if(k<PolygonMarginCnt || k>=(Polygon->Blob[0].OutCnt-PolygonMarginCnt)) continue;
													 C4CirOutPoint[PixelCnt].x  = Polygon->Blob[0].OutPoint[k].x ;
													 C4CirOutPoint[PixelCnt].y  = Polygon->Blob[0].OutPoint[k].y ;

													 if(k==PolygonMarginCnt)                              { //직선구간에 필요한 시작점  
														 BtmEdgePoint[5].x =C4CirOutPoint[PixelCnt].x;
														 BtmEdgePoint[5].y =C4CirOutPoint[PixelCnt].y;
													 }
													 if(k==(Polygon->Blob[0].OutCnt-(PolygonMarginCnt+1))){ //직선구간에 필요한 끝점 
														 BtmEdgePoint[6].x =C4CirOutPoint[PixelCnt].x;
														 BtmEdgePoint[6].y =C4CirOutPoint[PixelCnt].y;
													 }
													 PixelCnt++;
												 }
											 }
										 }
										 // Polygon Data Clear
										 // 											 Polygon->ClearData();
									 }
									 /////////////////////////////////////////////////////////////////////////////////////////////

									 // InEdgeData/OutEdgeData 기준 가공량 및 연마량 계산
									 // Polygon 알고리즘에서는 GrindMark기준 OutData,InData 최단거리 2개 Tag값 산출해야함 
									 if(IsMarkBtm){ // LTPS 가공량,연마량 계산 
										 if(C4CirOutEdgeCount!=0 && C4CirInEdgeCount!=0){ // MarkMode경우 가공량 검사를 먼저 진행 후 연마량 산출  
											 if(GrindMarkPoint[11].x!=0.0f && GrindMarkPoint[11].y!=0.0f){  //GrindMark 찾았을경우 
												 // GrindMark기준 OutData 최단거리 Count정보 Calc 
												 GrindMeaDis =0.0f, MinDis =10000.0f; GrindMarkOutCnt=0;
												 for(int k=0; k<C4CirOutEdgeCount; k++){
													 if(C4CirOutPoint[k].x ==0.0f || C4CirOutPoint[k].y ==0.0f) continue;
													 if(GrindMarkPoint[11].x==0.0f || GrindMarkPoint[11].y==0.0f) continue;

													 GrindMeaDis = Math.GetLength(GrindMarkPoint[11], C4CirOutPoint[k]);
													 if(GrindMeaDis<MinDis){
														 MinDis = GrindMeaDis;
														 GrindMarkOutCnt = k;
													 }
												 }

												 // GrindMark기준 InData 최단거리 Count정보 Calc 
												 if(GrindMarkOutCnt!=0){
													 GrindMeaDis =0.0f, MinDis =10000.0f; GrindMarkInCnt=0;
													 for(int k=0; k<C4CirInEdgeCount; k++){
														 if(C4CirInPoint[k].x   ==0.0f             || C4CirInPoint[k].y                ==0.0f) continue;
														 if(C4CirOutPoint[GrindMarkOutCnt].x==0.0f || C4CirOutPoint[GrindMarkOutCnt].y ==0.0f) continue;

														 GrindMeaDis = Math.GetLength(C4CirOutPoint[GrindMarkOutCnt], C4CirInPoint[k]);
														 if(GrindMeaDis<MinDis){
															 MinDis = GrindMeaDis;
															 GrindMarkInCnt = k;
														 }
													 }
												 }

												 // GrindMark기준 수직 포인트 주변값 Avg산출한다 ==>가공량 측정(OutData기준)
												 if(GrindMarkOutCnt!=0 && GrindMarkOutCnt>5){
													 CircleCount=0,TotalCirDis=0.0f,GrindMeaDis=0.0f;
													 for(int k=GrindMarkOutCnt-5; k<GrindMarkOutCnt+5; k++){
														 if(C4CirOutPoint[k].x==0.0f || C4CirOutPoint[k].y==0.0f) continue;
														 if(k>=C4CirOutEdgeCount                                ) continue;

														 GrindMeaDis = Math.GetLength(GrindMarkPoint[11], C4CirOutPoint[k]);
														 TotalCirDis+= GrindMeaDis;
														 CircleCount++;
													 }
													 if(TotalCirDis!=0.0f && CircleCount!=0){
														 C4CirGrindMea = TotalCirDis/CircleCount;
														 C4CirGrindMea = C4CirGrindMea+0.5; //SubPixel 
													 }
												 }

												 // GrindMark기준 수직 포인트 주변값 Avg산출한다 ==>연마량 측정(OutData,InData기준)
												 if((GrindMarkOutCnt!=0 && GrindMarkOutCnt>5) && (GrindMarkInCnt!=0 && GrindMarkInCnt>5)){
													 CircleCount=0,TotalCirDis=0.0f,GrindWidthDis=0.0f;
													 for(int k=-5; k<5; k++){
														 if(C4CirOutPoint[GrindMarkOutCnt+k].x==0.0f && C4CirOutPoint[GrindMarkOutCnt+k].y==0.0f) continue;
														 if(C4CirInPoint [GrindMarkInCnt +k].x==0.0f && C4CirInPoint [GrindMarkInCnt +k].y==0.0f) continue;
														 if((GrindMarkOutCnt+k)>=C4CirOutEdgeCount                                              ) continue;
														 if((GrindMarkInCnt +k)>=C4CirInEdgeCount                                               ) continue;

														 GrindWidthDis = Math.GetLength(C4CirInPoint[GrindMarkInCnt+k], C4CirOutPoint[GrindMarkOutCnt+k]);
														 TotalCirDis+=   GrindWidthDis;
														 CircleCount++;
													 }
													 if(TotalCirDis!=0.0f && CircleCount!=0){
														 C4CirGrindWd = TotalCirDis/CircleCount;
														 C4CirGrindWd = C4CirGrindWd+0.5; //SubPixel
													 }
												 }
											 }
											 else if(GrindMarkRect[11].left!=0 && GrindMarkRect[11].top!=0 && GrindMarkRect[11].right!=0 &&GrindMarkRect[11].bottom!=0){  //GrindMark 못 찾았을경우
												 // OutData기준 최소값 데이터 Count산출 
												 GrindMeaDis =0.0f, MinDis =10000.0f; GrindMarkOutCnt=0;
												 for(int k=0; k<C4CirOutEdgeCount; k++){
													 if(C4CirOutPoint[k].x==0.0f || C4CirOutPoint[k].y==0.0f) continue;

													 GrindMarkRectCenter[11].x = GrindMarkRect[11].left + (GrindMarkRect[11].right  - GrindMarkRect[11].left)/2; 
													 GrindMarkRectCenter[11].y = GrindMarkRect[11].top  + (GrindMarkRect[11].bottom - GrindMarkRect[11].top )/2; 

													 GrindMeaDis = Math.GetLength(GrindMarkRectCenter[11], C4CirOutPoint[k]);
													 if(GrindMeaDis<MinDis){
														 MinDis = GrindMeaDis;
														 GrindMarkOutCnt = k;
													 }
												 }

												 // 최단거리OUtCount기준 InData 최단거리 Count정보 Calc 
												 if(GrindMarkOutCnt!=0){
													 GrindMeaDis =0.0f, MinDis =10000.0f; GrindMarkInCnt=0;
													 for(int k=0; k<C4CirInEdgeCount; k++){
														 if(C4CirInPoint[k].x   ==0.0f             || C4CirInPoint[k].y                ==0.0f) continue;
														 if(C4CirOutPoint[GrindMarkOutCnt].x==0.0f || C4CirOutPoint[GrindMarkOutCnt].y ==0.0f) continue;

														 GrindMeaDis = Math.GetLength(C4CirOutPoint[GrindMarkOutCnt], C4CirInPoint[k]);
														 if(GrindMeaDis<MinDis){
															 MinDis = GrindMeaDis;
															 GrindMarkInCnt = k;
														 }
													 }
												 }

												 // GrindMark기준 수직 포인트 주변값 Avg산출한다 ==>연마량 측정(OutData,InData기준)
												 if((GrindMarkOutCnt!=0 && GrindMarkOutCnt>5) && (GrindMarkInCnt!=0 && GrindMarkInCnt>5)){
													 CircleCount=0,TotalCirDis=0.0f,GrindWidthDis=0.0f;
													 for(int k=-5; k<5; k++){
														 if(C4CirOutPoint[GrindMarkOutCnt+k].x==0.0f && C4CirOutPoint[GrindMarkOutCnt+k].y==0.0f) continue;
														 if(C4CirInPoint [GrindMarkInCnt +k].x==0.0f && C4CirInPoint [GrindMarkInCnt +k].y==0.0f) continue;
														 if((GrindMarkOutCnt+k)>=C4CirOutEdgeCount                                              ) continue;
														 if((GrindMarkInCnt +k)>=C4CirInEdgeCount                                               ) continue;

														 GrindWidthDis = Math.GetLength(C4CirInPoint[GrindMarkInCnt+k], C4CirOutPoint[GrindMarkOutCnt+k]);
														 TotalCirDis+=   GrindWidthDis;
														 CircleCount++;
													 }
													 if(TotalCirDis!=0.0f && CircleCount!=0){
														 C4CirGrindWd = TotalCirDis/CircleCount;
														 C4CirGrindWd = C4CirGrindWd+0.5; //SubPixel
													 }
												 }
											 }
										 }
									 }
									 else         { //Polygon EnCap 계산시 OutPoint 중간값 기준 실측 거리 평균값을 계산한다(LeftTop) 
										 if(C4CirInEdgeCount!=0 && C4CirOutEdgeCount!=0){
											 GrindMeaDis =0.0f, MinDis =10000.0f; GrindMarkOutCnt=0;
											 GrindMarkOutCnt = (int)(C4CirOutEdgeCount/2);
											 // 최단거리OUtCount기준 InData 최단거리 Count정보 Calc 
											 if(GrindMarkOutCnt!=0){
												 GrindMeaDis =0.0f, MinDis =10000.0f; GrindMarkInCnt=0;
												 for(int k=0; k<C4CirInEdgeCount; k++){
													 if(C4CirInPoint[k].x   ==0.0f             || C4CirInPoint[k].y                ==0.0f) continue;
													 if(C4CirOutPoint[GrindMarkOutCnt].x==0.0f || C4CirOutPoint[GrindMarkOutCnt].y ==0.0f) continue;

													 GrindMeaDis = Math.GetLength(C4CirOutPoint[GrindMarkOutCnt], C4CirInPoint[k]);
													 if(GrindMeaDis<MinDis){
														 MinDis = GrindMeaDis;
														 GrindMarkInCnt = k;
													 }
												 }
											 }

											 // GrindMark기준 수직 포인트 주변값 Avg산출한다 ==>연마량 측정(OutData,InData기준)
											 if((GrindMarkOutCnt!=0 && GrindMarkOutCnt>5) && (GrindMarkInCnt!=0 && GrindMarkInCnt>5)){
												 CircleCount=0,TotalCirDis=0.0f,GrindWidthDis=0.0f;
												 for(int k=-5; k<5; k++){
													 if(C4CirOutPoint[GrindMarkOutCnt+k].x==0.0f && C4CirOutPoint[GrindMarkOutCnt+k].y==0.0f) continue;
													 if(C4CirInPoint [GrindMarkInCnt +k].x==0.0f && C4CirInPoint [GrindMarkInCnt +k].y==0.0f) continue;
													 if((GrindMarkOutCnt+k)>=C4CirOutEdgeCount                                              ) continue;
													 if((GrindMarkInCnt +k)>=C4CirInEdgeCount                                               ) continue;

													 GrindWidthDis = Math.GetLength(C4CirInPoint[GrindMarkInCnt+k], C4CirOutPoint[GrindMarkOutCnt+k]);
													 TotalCirDis+=   GrindWidthDis;
													 CircleCount++;
												 }
												 if(TotalCirDis!=0.0f && CircleCount!=0){
													 C4CirGrindWd = TotalCirDis/CircleCount;
													 C4CirGrindWd = C4CirGrindWd+0.5; //SubPixel
												 }
											 }
										 }
									 }
									 ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
									 // FAVION Circle Fitting 결과물(Circle_1)
									 SampleSize   = C4CirInEdgeCount*0.75; //0.5~0.8이하로 입력할것
									 DistDevRatio = 0.15                 ; //0.1~0.25 이하로 입력할것
									 CircleFit->OnRansac(C4CirInPoint,C4CirInEdgeCount,SampleSize,DistDevRatio,&CircleFit4Center,&CirFitDiameter4);

									 // Polygon 박리 검사 시퀀스 
									 if(!IsMarkBtm && BrokenThresHold!=0){
										 RotateBrokenImg.SetSize(RotateImg.GetWidth(), RotateImg.GetHeight());
										 EasyImage::Oper(EArithmeticLogicOperation_Copy,&RotateImg,&RotateBrokenImg);
										 EasyImage::Threshold(&RotateImg,&RotateBrokenImg, BrokenThresHold);
										 Edge->GImage = &RotateBrokenImg;
										 Edge->SetEdgeType(0);
										 // 											 RotateBrokenImg.Save("D:\\ROTATE_IMG\\Polygon_박리.bmp");

										 int DvCnt =0, DataCount=0;
										 double deg =0.0f; 
										 TFPoint Target(0.0f, 0.0f);

										 if(GrindMarkInCnt>GrindMarkOutCnt){
											 DvCnt = GrindMarkInCnt - GrindMarkOutCnt;
											 for(int k=0; k<C4CirOutEdgeCount; k++){
												 deg =0.0f, Target.x =0.0f, Target.y =0.0f;
												 if(((k+DvCnt)<C4CirInEdgeCount) && C4CirInPoint[k+DvCnt].x>0  && C4CirInPoint[k+DvCnt].y>0){
													 deg = Math.GetDegree(C4CirOutPoint[k],C4CirInPoint[k+DvCnt]);

													 Target  = Math.OnFindPerpendicularPointXY(C4CirOutPoint[k],-dEdgeToTrapLineDis,dEdgeToTrapLineDis,deg);
													 Edge->OnExecute(C4CirOutPoint[k],Target); // 연마외곽라인에서 Target까지 White Point Search 
													 if(Edge->GetResultEdgePointCount()>0){
														 C4CircleData[DataCount].Dis =0.0f;
														 C4CircleData[DataCount].Dv  =0.0f;
														 C4CircleData[DataCount].P   = Edge->GetResultEdgePoint(0);
														 C4CircleData[DataCount].P.y = C4CircleData[DataCount].P.y - ImageHeight; // Frame기준 단위좌표로 변경함  
														 DataCount++;
													 }
												 }
											 }
											 C4CirInCrackCount = DataCount;
										 }
										 else if(GrindMarkInCnt<GrindMarkOutCnt)   {
											 DvCnt = GrindMarkOutCnt - GrindMarkInCnt;
											 for(int k=DvCnt; k<C4CirOutEdgeCount; k++){
												 deg =0.0f, Target.x =0.0f, Target.y =0.0f;
												 if(((k-DvCnt)<C4CirInEdgeCount) && C4CirInPoint[k-DvCnt].x>0  && C4CirInPoint[k-DvCnt].y>0 && k-DvCnt>=0){
													 deg = Math.GetDegree(C4CirOutPoint[k],C4CirInPoint[k-DvCnt]);

													 Target  = Math.OnFindPerpendicularPointXY(C4CirOutPoint[k],-dEdgeToTrapLineDis,dEdgeToTrapLineDis,deg);
													 Edge->OnExecute(C4CirOutPoint[k],Target); // 연마외곽라인에서 Target까지 White Point Search 
													 if(Edge->GetResultEdgePointCount()>0){
														 C4CircleData[DataCount].Dis =0.0f;
														 C4CircleData[DataCount].Dv  =0.0f;
														 C4CircleData[DataCount].P   = Edge->GetResultEdgePoint(0);
														 C4CircleData[DataCount].P.y = C4CircleData[DataCount].P.y - ImageHeight; // Frame기준 단위좌표로 변경함  
														 DataCount++;
													 }
												 }
											 }
											 C4CirInCrackCount = DataCount;
										 }
									 }
									 LogUnit.SetLog(L"CellID:%d, CamID:%d ==>Polygon4_Insp_End",CellId,CamId);     
								 }

								 // 다섯번째 Polygon, Circle 1
								 if(PolyRect[4].left!=0 && PolyRect[4].top!=0 && PolyRect[4].right!=0 && PolyRect[4].bottom!=0){
									 P1.x=0, P1.y=0, P2.x=0, P2.y=0, P3.x=0, P3.y=0, P4.x=0, P4.y=0;
									 LogUnit.SetLog(L"CellID:%d, CamID:%d ==>Polygon5_Insp_Start",CellId,CamId);     

									 // 										 P1.x = (PolyRect[4].left-50); P1.y =(PolyRect[4].top             ); P2.x = (P1.x+PolyRect[4].Width()+50); P2.y = (P1.y);
									 // 										 P3.x = (PolyRect[4].left-50); P3.y =(P1.y+PolyRect[4].Height()+50); P4.x = (P2.x                       ); P4.y = (P3.y);

									 P1.x = (PolyRect[4].left); P1.y =(PolyRect[4].top-20          ); P2.x = (P1.x+PolyRect[4].Width()); P2.y = (P1.y);
									 P3.x = (PolyRect[4].left); P3.y =(P1.y+PolyRect[4].Height()+20); P4.x = (P2.x                    ); P4.y = (P3.y);

									 // Median Filter 적용 
									 if(P1.x<=0    || P1.y<=0    || (P2.x - P1.x)<=0    || (P3.y - P1.y)<=0   ) return false;
									 if(P1.x>=ImgW || P1.y>=ImgH || (P2.x - P1.x)>=ImgW || (P3.y - P1.y)>=ImgH) return false;
									 //ROI x + Width = 16384 넘어가면 Return //20180808 추가
									 //ROI y + Hight = 1500  넘어가면 Return
									 if( (P1.x + int(P2.x - P1.x)) >= ImgW || (P1.y + int(P3.y - P1.y)) >= ImgH ) return false;
									 FilterROI.SetSize(int(P2.x - P1.x),int(P3.y - P1.y) )                      ;
									 FilterROI.Attach(&RotateBinaryImg)                                    ;
									 FilterROI.SetPlacement(P1.x, P1.y, int(P2.x - P1.x), int(P3.y - P1.y));
									 LogUnit.SetLog(L"Polygon5 ==>Px :%d, Py :%d, Width:%d, Height:%d ==>Median Filter",P1.x, P1.y, int(P2.x - P1.x), int(P3.y - P1.y));     
									 LogUnit.SetLog(L"Polygon5 ==>P1x:%d, P1y:%d, P2x:%d, P2y:%d, P3x:%d, P3y:%d, P4x:%d, P4y:%d,",P1.x,P1.y,P2.x,P2.y,P3.x,P3.y,P4.x,P4.y);     
									 EasyImage::Median(&FilterROI, &FilterROI)                             ;
									 // 										 RotateBinaryImg.Save("D:\\ROTATE_IMG\\Polygon5_필터.bmp")             ;


									 Polygon->GImage          = &RotateBinaryImg            ;
									 Polygon->PoPa.FMaxWidth  =(int)(CenterCircleWidth +200);
									 Polygon->PoPa.FMaxHeight =(int)(CenterCircleHeight+200);
									 Polygon->PoPa.IsSeparate =true                         ;
									 Polygon->PoPa.IsInToOut  =true                         ;
									 Polygon->PoPa.HiThHold   = BtmEdgeThresHold            ;
									 Polygon->PoPa.LoThHold   = 0                           ;
									 Polygon->PoPa.FMinWidth  =(int)(CenterCircleWidth /3)  ;
									 Polygon->PoPa.FMinHeight =(int)(CenterCircleHeight/3)  ;

									 if(P1.x!=0 && P1.y!=0 && P2.x!=0 && P2.y!=0 && P3.x!=0 && P3.y!=0 && P4.x!=0 && P4.y!=0){
										 Polygon->OnExecute(P1,P2,P3,P4);
									 }

									 // Polygon Algorithm InEdgeData/OutEdgeData Separate 및 데이터 추출 
									 if(Polygon->BlobCount==1){
										 PolygonMarginCnt =10;
										 if(Polygon->Blob[0].InCnt>(PolygonMarginCnt*2)){
											 C5CirInEdgeCount=0;
											 C5CirInEdgeCount = (Polygon->Blob[0].InCnt - (PolygonMarginCnt*2));
											 if(C5CirInEdgeCount>0){
												 if(C5CirInPoint!=NULL) {
													 delete[] C5CirInPoint;
												 }
												 C5CirInPoint = new TFPoint[C5CirInEdgeCount];

												 PixelCnt=0;
												 for(int k=0; k<Polygon->Blob[0].InCnt; k++){
													 if(k<PolygonMarginCnt || k>=(Polygon->Blob[0].InCnt-PolygonMarginCnt)) continue;
													 C5CirInPoint[PixelCnt].x   = Polygon->Blob[0].InPoint[k].x ;
													 C5CirInPoint[PixelCnt].y   = Polygon->Blob[0].InPoint[k].y ;
													 PixelCnt++;
												 }
											 }
										 }

										 if(Polygon->Blob[0].OutCnt>(PolygonMarginCnt*2)){
											 C5CirOutEdgeCount=0;
											 C5CirOutEdgeCount = (Polygon->Blob[0].OutCnt - (PolygonMarginCnt*2));
											 if(C5CirOutEdgeCount>0){
												 if(C5CirOutPoint!=NULL) delete[] C5CirOutPoint;
												 C5CirOutPoint = new TFPoint[C5CirOutEdgeCount];

												 PixelCnt=0;
												 for(int k=0; k<Polygon->Blob[0].OutCnt; k++){
													 if(k<PolygonMarginCnt || k>=(Polygon->Blob[0].OutCnt-PolygonMarginCnt)) continue;
													 C5CirOutPoint[PixelCnt].x  = Polygon->Blob[0].OutPoint[k].x ;
													 C5CirOutPoint[PixelCnt].y  = Polygon->Blob[0].OutPoint[k].y ;

													 if(k==PolygonMarginCnt)                              { //직선구간에 필요한 시작점  
														 BtmEdgePoint[7].x = C5CirOutPoint[PixelCnt].x;
														 BtmEdgePoint[7].y = C5CirOutPoint[PixelCnt].y;
													 }
													 if(k==(Polygon->Blob[0].OutCnt-(PolygonMarginCnt+1))){ //직선구간에 필요한 끝점 
														 BtmEdgePoint[8].x = C5CirOutPoint[PixelCnt].x;
														 BtmEdgePoint[8].y = C5CirOutPoint[PixelCnt].y;
													 }
													 PixelCnt++;
												 }
											 }
										 }
										 // Polygon Data Clear
										 // 											 Polygon->ClearData();
									 }
									 /////////////////////////////////////////////////////////////////////////////////////////////

									 // InEdgeData/OutEdgeData 기준 가공량 및 연마량 계산
									 // Polygon 알고리즘에서는 GrindMark기준 OutData,InData 최단거리 2개 Tag값 산출해야함 
									 if(IsMarkBtm){ // LTPS 가공량,연마량 계산 
										 if(C5CirOutEdgeCount!=0 && C5CirInEdgeCount!=0){ // MarkMode경우 가공량 검사를 먼저 진행 후 연마량 산출  
											 // 가공량,연마량 측정 전 데이터 존재시 가상GrindMark 생성한다 
											 if(GrindMarkPoint[13].x!=0.0f && GrindMarkPoint[13].y!=0.0f && GrindRectSpec[6].DvX!=0.0f && GrindRectSpec[6].DvY!=0.0f){
												 GrindMarkPoint[12].x     = GrindMarkPoint[13].x - GrindRectSpec[6].DvX;
												 GrindMarkPoint[12].y     = GrindMarkPoint[13].y - GrindRectSpec[6].DvY;
												 GrindMarkRect [12].left  = GrindMarkPoint[12].x    - GrindMarkRange   ;  
												 GrindMarkRect [12].top   = GrindMarkPoint[12].y    - GrindMarkRange   ;  
												 GrindMarkRect [12].right = GrindMarkRect [12].left + GrindMarkLength  ;  
												 GrindMarkRect [12].bottom= GrindMarkRect [12].top  + GrindMarkLength  ;  
											 }

											 // GrindMarkPoint[12] 가상 마크 생성 시퀀스 
											 if(GrindMarkPoint[12].x!=0.0f && GrindMarkPoint[12].y!=0.0f){  //GrindMark 찾았을경우 
												 // GrindMark기준 OutData 최단거리 Count정보 Calc 
												 GrindMeaDis =0.0f, MinDis =10000.0f; GrindMarkOutCnt=0;
												 for(int k=0; k<C5CirOutEdgeCount; k++){
													 if(C5CirOutPoint[k].x ==0.0f || C5CirOutPoint[k].y ==0.0f) continue;
													 if(GrindMarkPoint[12].x==0.0f || GrindMarkPoint[12].y==0.0f) continue;

													 GrindMeaDis = Math.GetLength(GrindMarkPoint[12], C5CirOutPoint[k]);
													 if(GrindMeaDis<MinDis){
														 MinDis = GrindMeaDis;
														 GrindMarkOutCnt = k;
													 }
												 }

												 // GrindMark기준 InData 최단거리 Count정보 Calc 
												 if(GrindMarkOutCnt!=0){
													 GrindMeaDis =0.0f, MinDis =10000.0f; GrindMarkInCnt=0;
													 for(int k=0; k<C5CirInEdgeCount; k++){
														 if(C5CirInPoint[k].x   ==0.0f             || C5CirInPoint[k].y                ==0.0f) continue;
														 if(C5CirOutPoint[GrindMarkOutCnt].x==0.0f || C5CirOutPoint[GrindMarkOutCnt].y ==0.0f) continue;

														 GrindMeaDis = Math.GetLength(C5CirOutPoint[GrindMarkOutCnt], C5CirInPoint[k]);
														 if(GrindMeaDis<MinDis){
															 MinDis = GrindMeaDis;
															 GrindMarkInCnt = k;
														 }
													 }
												 }

												 // GrindMark기준 수직 포인트 주변값 Avg산출한다 ==>가공량 측정(OutData기준)
												 if(GrindMarkOutCnt!=0 && GrindMarkOutCnt>5){
													 CircleCount=0,TotalCirDis=0.0f,GrindMeaDis=0.0f;
													 for(int k=GrindMarkOutCnt-5; k<GrindMarkOutCnt+5; k++){
														 if(C5CirOutPoint[k].x==0.0f || C5CirOutPoint[k].y==0.0f) continue;
														 if(k>=C5CirOutEdgeCount                                ) continue;

														 GrindMeaDis = Math.GetLength(GrindMarkPoint[12], C5CirOutPoint[k]);
														 TotalCirDis+= GrindMeaDis;
														 CircleCount++;
													 }
													 if(TotalCirDis!=0.0f && CircleCount!=0){
														 TrenchRightGrindMea = TotalCirDis/CircleCount;
														 TrenchRightGrindMea = TrenchRightGrindMea+0.5; //SubPixel 
													 }
												 }

												 // GrindMark기준 수직 포인트 주변값 Avg산출한다 ==>연마량 측정(OutData,InData기준)
												 if((GrindMarkOutCnt!=0 && GrindMarkOutCnt>5) && (GrindMarkInCnt!=0 && GrindMarkInCnt>5)){
													 CircleCount=0,TotalCirDis=0.0f,GrindWidthDis=0.0f;
													 for(int k=-5; k<5; k++){
														 if(C5CirOutPoint[GrindMarkOutCnt+k].x==0.0f && C5CirOutPoint[GrindMarkOutCnt+k].y==0.0f) continue;
														 if(C5CirInPoint [GrindMarkInCnt +k].x==0.0f && C5CirInPoint [GrindMarkInCnt +k].y==0.0f) continue;
														 if((GrindMarkOutCnt+k)>=C5CirOutEdgeCount                                              ) continue;
														 if((GrindMarkInCnt +k)>=C5CirInEdgeCount                                               ) continue;

														 GrindWidthDis = Math.GetLength(C5CirInPoint[GrindMarkInCnt+k], C5CirOutPoint[GrindMarkOutCnt+k]);
														 TotalCirDis+=   GrindWidthDis;
														 CircleCount++;
													 }
													 if(TotalCirDis!=0.0f && CircleCount!=0){
														 TrenchRightGrindWd = TotalCirDis/CircleCount;
														 TrenchRightGrindWd = TrenchRightGrindWd+0.5; //SubPixel
													 }
												 }
											 }
											 else if(GrindMarkRect[12].left!=0 && GrindMarkRect[12].top!=0 && GrindMarkRect[12].right!=0 &&GrindMarkRect[12].bottom!=0){  //GrindMark 못 찾았을경우
												 // OutData기준 최소값 데이터 Count산출 
												 if(GrindRectSpec[6].DvX!=0.0f && GrindRectSpec[6].DvY!=0.0f){
													 GrindMeaDis =0.0f, MinDis =10000.0f; GrindMarkOutCnt=0;
													 for(int k=0; k<C5CirOutEdgeCount; k++){
														 if(C5CirOutPoint[k].x==0.0f || C5CirOutPoint[k].y==0.0f) continue;

														 if(k==0){
															 GrindMarkRectCenter[13].x = GrindMarkRect[13].left + (GrindMarkRect[13].right  - GrindMarkRect[13].left)/2; 
															 GrindMarkRectCenter[13].y = GrindMarkRect[13].top  + (GrindMarkRect[13].bottom - GrindMarkRect[13].top )/2; 

															 GrindMarkRectCenter[12].x = GrindMarkRectCenter[13].x - GrindRectSpec[6].DvX;
															 GrindMarkRectCenter[12].y = GrindMarkRectCenter[13].y - GrindRectSpec[6].DvY;

															 GrindMarkRect [12].left  =  GrindMarkRectCenter[12].x   - GrindMarkRange   ;  
															 GrindMarkRect [12].top   =  GrindMarkRectCenter[12].y   - GrindMarkRange   ;  
															 GrindMarkRect [12].right =  GrindMarkRect [12].left + GrindMarkLength  ;  
															 GrindMarkRect [12].bottom=  GrindMarkRect [12].top  + GrindMarkLength  ;  
														 }

														 GrindMeaDis = Math.GetLength(GrindMarkRectCenter[12], C5CirOutPoint[k]);
														 if(GrindMeaDis<MinDis){
															 MinDis = GrindMeaDis;
															 GrindMarkOutCnt = k;
														 }
													 }

													 // 최단거리OUtCount기준 InData 최단거리 Count정보 Calc 
													 if(GrindMarkOutCnt!=0){
														 GrindMeaDis =0.0f, MinDis =10000.0f; GrindMarkInCnt=0;
														 for(int k=0; k<C5CirInEdgeCount; k++){
															 if(C5CirInPoint[k].x   ==0.0f             || C5CirInPoint[k].y                ==0.0f) continue;
															 if(C5CirOutPoint[GrindMarkOutCnt].x==0.0f || C5CirOutPoint[GrindMarkOutCnt].y ==0.0f) continue;

															 GrindMeaDis = Math.GetLength(C5CirOutPoint[GrindMarkOutCnt], C5CirInPoint[k]);
															 if(GrindMeaDis<MinDis){
																 MinDis = GrindMeaDis;
																 GrindMarkInCnt = k;
															 }
														 }
													 }

													 // GrindMark기준 수직 포인트 주변값 Avg산출한다 ==>연마량 측정(OutData,InData기준)
													 if((GrindMarkOutCnt!=0 && GrindMarkOutCnt>5) && (GrindMarkInCnt!=0 && GrindMarkInCnt>5)){
														 CircleCount=0,TotalCirDis=0.0f,GrindWidthDis=0.0f;
														 for(int k=-5; k<5; k++){
															 if(C5CirOutPoint[GrindMarkOutCnt+k].x==0.0f && C5CirOutPoint[GrindMarkOutCnt+k].y==0.0f) continue;
															 if(C5CirInPoint [GrindMarkInCnt +k].x==0.0f && C5CirInPoint [GrindMarkInCnt +k].y==0.0f) continue;
															 if((GrindMarkOutCnt+k)>=C5CirOutEdgeCount                                              ) continue;
															 if((GrindMarkInCnt +k)>=C5CirInEdgeCount                                               ) continue;

															 GrindWidthDis = Math.GetLength(C5CirInPoint[GrindMarkInCnt+k], C5CirOutPoint[GrindMarkOutCnt+k]);
															 TotalCirDis+=   GrindWidthDis;
															 CircleCount++;
														 }
														 if(TotalCirDis!=0.0f && CircleCount!=0){
															 TrenchRightGrindWd = TotalCirDis/CircleCount;
															 TrenchRightGrindWd = TrenchRightGrindWd+0.5; //SubPixel
														 }
													 }
												 }
											 }


											 if(GrindMarkPoint[13].x!=0.0f && GrindMarkPoint[13].y!=0.0f){  //GrindMark 찾았을경우 
												 // GrindMark기준 OutData 최단거리 Count정보 Calc 
												 GrindMeaDis =0.0f, MinDis =10000.0f; GrindMarkOutCnt=0;
												 for(int k=0; k<C5CirOutEdgeCount; k++){
													 if(C5CirOutPoint[k].x ==0.0f || C5CirOutPoint[k].y ==0.0f) continue;
													 if(GrindMarkPoint[13].x==0.0f || GrindMarkPoint[13].y==0.0f) continue;

													 GrindMeaDis = Math.GetLength(GrindMarkPoint[13], C5CirOutPoint[k]);
													 if(GrindMeaDis<MinDis){
														 MinDis = GrindMeaDis;
														 GrindMarkOutCnt = k;
													 }
												 }

												 // GrindMark기준 InData 최단거리 Count정보 Calc 
												 if(GrindMarkOutCnt!=0){
													 GrindMeaDis =0.0f, MinDis =10000.0f; GrindMarkInCnt=0;
													 for(int k=0; k<C5CirInEdgeCount; k++){
														 if(C5CirInPoint[k].x   ==0.0f             || C5CirInPoint[k].y                ==0.0f) continue;
														 if(C5CirOutPoint[GrindMarkOutCnt].x==0.0f || C5CirOutPoint[GrindMarkOutCnt].y ==0.0f) continue;

														 GrindMeaDis = Math.GetLength(C5CirOutPoint[GrindMarkOutCnt], C5CirInPoint[k]);
														 if(GrindMeaDis<MinDis){
															 MinDis = GrindMeaDis;
															 GrindMarkInCnt = k;
														 }
													 }
												 }

												 // GrindMark기준 수직 포인트 주변값 Avg산출한다 ==>가공량 측정(OutData기준)
												 if(GrindMarkOutCnt!=0 && GrindMarkOutCnt>5){
													 CircleCount=0,TotalCirDis=0.0f,GrindMeaDis=0.0f;
													 for(int k=GrindMarkOutCnt-5; k<GrindMarkOutCnt+5; k++){
														 if(C5CirOutPoint[k].x==0.0f || C5CirOutPoint[k].y==0.0f) continue;
														 if(k>=C5CirOutEdgeCount                                ) continue;

														 GrindMeaDis = Math.GetLength(GrindMarkPoint[13], C5CirOutPoint[k]);
														 TotalCirDis+= GrindMeaDis;
														 CircleCount++;
													 }
													 if(TotalCirDis!=0.0f && CircleCount!=0){
														 C5CirGrindMea = TotalCirDis/CircleCount;
														 C5CirGrindMea = C5CirGrindMea+0.5; //SubPixel 
													 }
												 }

												 // GrindMark기준 수직 포인트 주변값 Avg산출한다 ==>연마량 측정(OutData,InData기준)
												 if((GrindMarkOutCnt!=0 && GrindMarkOutCnt>5) && (GrindMarkInCnt!=0 && GrindMarkInCnt>5)){
													 CircleCount=0,TotalCirDis=0.0f,GrindWidthDis=0.0f;
													 for(int k=-5; k<5; k++){
														 if(C5CirOutPoint[GrindMarkOutCnt+k].x==0.0f && C5CirOutPoint[GrindMarkOutCnt+k].y==0.0f) continue;
														 if(C5CirInPoint [GrindMarkInCnt +k].x==0.0f && C5CirInPoint [GrindMarkInCnt +k].y==0.0f) continue;
														 if((GrindMarkOutCnt+k)>=C5CirOutEdgeCount                                              ) continue;
														 if((GrindMarkInCnt +k)>=C5CirInEdgeCount                                               ) continue;

														 GrindWidthDis = Math.GetLength(C5CirInPoint[GrindMarkInCnt+k], C5CirOutPoint[GrindMarkOutCnt+k]);
														 TotalCirDis+=   GrindWidthDis;
														 CircleCount++;
													 }
													 if(TotalCirDis!=0.0f && CircleCount!=0){
														 C5CirGrindWd = TotalCirDis/CircleCount;
														 C5CirGrindWd = C5CirGrindWd+0.5; //SubPixel
													 }
												 }
											 }
											 else if(GrindMarkRect[13].left!=0 && GrindMarkRect[13].top!=0 && GrindMarkRect[13].right!=0 &&GrindMarkRect[13].bottom!=0){  //GrindMark 못 찾았을경우
												 // OutData기준 최소값 데이터 Count산출 
												 GrindMeaDis =0.0f, MinDis =10000.0f; GrindMarkOutCnt=0;
												 for(int k=0; k<C5CirOutEdgeCount; k++){
													 if(C5CirOutPoint[k].x==0.0f || C5CirOutPoint[k].y==0.0f) continue;

													 GrindMarkRectCenter[13].x = GrindMarkRect[13].left + (GrindMarkRect[13].right  - GrindMarkRect[13].left)/2; 
													 GrindMarkRectCenter[13].y = GrindMarkRect[13].top  + (GrindMarkRect[13].bottom - GrindMarkRect[13].top )/2; 

													 GrindMeaDis = Math.GetLength(GrindMarkRectCenter[13], C5CirOutPoint[k]);
													 if(GrindMeaDis<MinDis){
														 MinDis = GrindMeaDis;
														 GrindMarkOutCnt = k;
													 }
												 }

												 // 최단거리OUtCount기준 InData 최단거리 Count정보 Calc 
												 if(GrindMarkOutCnt!=0){
													 GrindMeaDis =0.0f, MinDis =10000.0f; GrindMarkInCnt=0;
													 for(int k=0; k<C5CirInEdgeCount; k++){
														 if(C5CirInPoint[k].x   ==0.0f             || C5CirInPoint[k].y                ==0.0f) continue;
														 if(C5CirOutPoint[GrindMarkOutCnt].x==0.0f || C5CirOutPoint[GrindMarkOutCnt].y ==0.0f) continue;

														 GrindMeaDis = Math.GetLength(C5CirOutPoint[GrindMarkOutCnt], C5CirInPoint[k]);
														 if(GrindMeaDis<MinDis){
															 MinDis = GrindMeaDis;
															 GrindMarkInCnt = k;
														 }
													 }
												 }

												 // GrindMark기준 수직 포인트 주변값 Avg산출한다 ==>연마량 측정(OutData,InData기준)
												 if((GrindMarkOutCnt!=0 && GrindMarkOutCnt>5) && (GrindMarkInCnt!=0 && GrindMarkInCnt>5)){
													 CircleCount=0,TotalCirDis=0.0f,GrindWidthDis=0.0f;
													 for(int k=-5; k<5; k++){
														 if(C5CirOutPoint[GrindMarkOutCnt+k].x==0.0f && C5CirOutPoint[GrindMarkOutCnt+k].y==0.0f) continue;
														 if(C5CirInPoint [GrindMarkInCnt +k].x==0.0f && C5CirInPoint [GrindMarkInCnt +k].y==0.0f) continue;
														 if((GrindMarkOutCnt+k)>=C5CirOutEdgeCount                                              ) continue;
														 if((GrindMarkInCnt +k)>=C5CirInEdgeCount                                               ) continue;

														 GrindWidthDis = Math.GetLength(C5CirInPoint[GrindMarkInCnt+k], C5CirOutPoint[GrindMarkOutCnt+k]);
														 TotalCirDis+=   GrindWidthDis;
														 CircleCount++;
													 }
													 if(TotalCirDis!=0.0f && CircleCount!=0){
														 C5CirGrindWd = TotalCirDis/CircleCount;
														 C5CirGrindWd = C5CirGrindWd+0.5; //SubPixel
													 }
												 }
											 }
										 }
									 }
									 else         { //Polygon EnCap 계산시 OutPoint 중간값 기준 실측 거리 평균값을 계산한다(LeftTop) 
										 if(C5CirInEdgeCount!=0 && C5CirOutEdgeCount!=0){
											 GrindMeaDis =0.0f, MinDis =10000.0f; GrindMarkOutCnt=0;
											 GrindMarkOutCnt = (int)(C5CirOutEdgeCount/2);
											 // 최단거리OUtCount기준 InData 최단거리 Count정보 Calc 
											 if(GrindMarkOutCnt!=0){
												 GrindMeaDis =0.0f, MinDis =10000.0f; GrindMarkInCnt=0;
												 for(int k=0; k<C5CirInEdgeCount; k++){
													 if(C5CirInPoint[k].x   ==0.0f             || C5CirInPoint[k].y                ==0.0f) continue;
													 if(C5CirOutPoint[GrindMarkOutCnt].x==0.0f || C5CirOutPoint[GrindMarkOutCnt].y ==0.0f) continue;

													 GrindMeaDis = Math.GetLength(C5CirOutPoint[GrindMarkOutCnt], C5CirInPoint[k]);
													 if(GrindMeaDis<MinDis){
														 MinDis = GrindMeaDis;
														 GrindMarkInCnt = k;
													 }
												 }
											 }

											 // GrindMark기준 수직 포인트 주변값 Avg산출한다 ==>연마량 측정(OutData,InData기준)
											 if((GrindMarkOutCnt!=0 && GrindMarkOutCnt>5) && (GrindMarkInCnt!=0 && GrindMarkInCnt>5)){
												 CircleCount=0,TotalCirDis=0.0f,GrindWidthDis=0.0f;
												 for(int k=-5; k<5; k++){
													 if(C5CirOutPoint[GrindMarkOutCnt+k].x==0.0f && C5CirOutPoint[GrindMarkOutCnt+k].y==0.0f) continue;
													 if(C5CirInPoint [GrindMarkInCnt +k].x==0.0f && C5CirInPoint [GrindMarkInCnt +k].y==0.0f) continue;
													 if((GrindMarkOutCnt+k)>=C5CirOutEdgeCount                                              ) continue;
													 if((GrindMarkInCnt +k)>=C5CirInEdgeCount                                               ) continue;

													 GrindWidthDis = Math.GetLength(C5CirInPoint[GrindMarkInCnt+k], C5CirOutPoint[GrindMarkOutCnt+k]);
													 TotalCirDis+=   GrindWidthDis;
													 CircleCount++;
												 }
												 if(TotalCirDis!=0.0f && CircleCount!=0){
													 C5CirGrindWd = TotalCirDis/CircleCount;
													 C5CirGrindWd = C5CirGrindWd+0.5; //SubPixel
												 }
											 }
										 }
									 }
									 ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
									 // FAVION Circle Fitting 결과물(Circle_1)
									 SampleSize   = C5CirInEdgeCount*0.75; //0.5~0.8이하로 입력할것
									 DistDevRatio = 0.15                 ; //0.1~0.25 이하로 입력할것
									 CircleFit->OnRansac(C5CirInPoint,C5CirInEdgeCount,SampleSize,DistDevRatio,&CircleFit5Center,&CirFitDiameter5);

									 // Polygon 박리 검사 시퀀스 
									 if(!IsMarkBtm && BrokenThresHold!=0){
										 RotateBrokenImg.SetSize(RotateImg.GetWidth(), RotateImg.GetHeight());
										 EasyImage::Oper(EArithmeticLogicOperation_Copy,&RotateImg,&RotateBrokenImg);
										 EasyImage::Threshold(&RotateImg,&RotateBrokenImg, BrokenThresHold);
										 Edge->GImage = &RotateBrokenImg;
										 Edge->SetEdgeType(0);

										 int DvCnt =0, DataCount=0;
										 double deg =0.0f; 
										 TFPoint Target(0.0f, 0.0f);

										 if(GrindMarkInCnt>GrindMarkOutCnt){
											 DvCnt = GrindMarkInCnt - GrindMarkOutCnt;
											 for(int k=0; k<C5CirOutEdgeCount; k++){
												 deg =0.0f, Target.x =0.0f, Target.y =0.0f;
												 if(((k+DvCnt)<C5CirInEdgeCount) && C5CirInPoint[k+DvCnt].x>0  && C5CirInPoint[k+DvCnt].y>0){
													 deg = Math.GetDegree(C5CirOutPoint[k],C5CirInPoint[k+DvCnt]);

													 Target  = Math.OnFindPerpendicularPointXY(C5CirOutPoint[k],dEdgeToTrapLineDis,dEdgeToTrapLineDis,deg);
													 Edge->OnExecute(C5CirOutPoint[k],Target); // 연마외곽라인에서 Target까지 White Point Search 
													 if(Edge->GetResultEdgePointCount()>0){
														 C5CircleData[DataCount].Dis =0.0f;
														 C5CircleData[DataCount].Dv  =0.0f;
														 C5CircleData[DataCount].P   = Edge->GetResultEdgePoint(0);
														 C5CircleData[DataCount].P.y = C5CircleData[DataCount].P.y - ImageHeight; // Frame기준 단위좌표로 변경함  
														 DataCount++;
													 }
												 }
											 }
											 C5CirInCrackCount = DataCount;
										 }
										 else if(GrindMarkInCnt<GrindMarkOutCnt)   {
											 DvCnt = GrindMarkOutCnt - GrindMarkInCnt;
											 for(int k=DvCnt; k<C5CirOutEdgeCount; k++){
												 deg =0.0f, Target.x =0.0f, Target.y =0.0f;
												 if(((k-DvCnt)<C5CirInEdgeCount) && C5CirInPoint[k-DvCnt].x>0  && C5CirInPoint[k-DvCnt].y>0 && k-DvCnt>=0){
													 deg = Math.GetDegree(C5CirOutPoint[k],C5CirInPoint[k-DvCnt]);

													 Target  = Math.OnFindPerpendicularPointXY(C5CirOutPoint[k],dEdgeToTrapLineDis,dEdgeToTrapLineDis,deg);
													 Edge->OnExecute(C5CirOutPoint[k],Target); // 연마외곽라인에서 Target까지 White Point Search 
													 if(Edge->GetResultEdgePointCount()>0){
														 C5CircleData[DataCount].Dis =0.0f;
														 C5CircleData[DataCount].Dv  =0.0f;
														 C5CircleData[DataCount].P   = Edge->GetResultEdgePoint(0);
														 C5CircleData[DataCount].P.y = C5CircleData[DataCount].P.y - ImageHeight; // Frame기준 단위좌표로 변경함  
														 DataCount++;
													 }
												 }
											 }
											 C5CirInCrackCount = DataCount;
										 }
									 }
									 LogUnit.SetLog(L"CellID:%d, CamID:%d ==>Polygon5_Insp_End",CellId,CamId);     
								 }

								 // 여섯번째 Polygon, Circle 6
								 if(PolyRect[5].left!=0 && PolyRect[5].top!=0 && PolyRect[5].right!=0 && PolyRect[5].bottom!=0){
									 P1.x=0, P1.y=0, P2.x=0, P2.y=0, P3.x=0, P3.y=0, P4.x=0, P4.y=0;
									 LogUnit.SetLog(L"CellID:%d, CamID:%d ==>Polygon6_Insp_Start",CellId,CamId);     

									 // 										 P1.x = (PolyRect[5].left-30); P1.y =(PolyRect[5].top-20          ); P2.x = (P1.x+PolyRect[5].Width()+60); P2.y = (P1.y);
									 // 										 P3.x = (PolyRect[5].left-30); P3.y =(P1.y+PolyRect[5].Height()+40); P4.x = (P2.x                       ); P4.y = (P3.y);

									 // 										 P1.x = (PolyRect[5].left+50); P1.y =(PolyRect[5].top             ); P2.x = (P1.x+PolyRect[5].Width()); P2.y = (P1.y);
									 // 										 P3.x = (PolyRect[5].left+50); P3.y =(P1.y+PolyRect[5].Height()+50); P4.x = (P2.x                    ); P4.y = (P3.y);

									 P1.x = (PolyRect[5].left); P1.y =(PolyRect[5].top             ); P2.x = (P1.x+PolyRect[5].Width()); P2.y = (P1.y);
									 P3.x = (PolyRect[5].left); P3.y =(P1.y+PolyRect[5].Height()+50); P4.x = (P2.x                    ); P4.y = (P3.y);


									 // Median Filter 적용 
									 if(P1.x<=0    || P1.y<=0    || (P2.x - P1.x)<=0    || (P3.y - P1.y)<=0   ) return false;
									 if(P1.x>=ImgW || P1.y>=ImgH || (P2.x - P1.x)>=ImgW || (P3.y - P1.y)>=ImgH) return false;
									 //ROI x + Width = 16384 넘어가면 Return //20180808 추가
									 //ROI y + Hight = 1500  넘어가면 Return
									 if( (P1.x + int(P2.x - P1.x)) >= ImgW || (P1.y + int(P3.y - P1.y)) >= ImgH ) return false;
									 FilterROI.SetSize(int(P2.x - P1.x),int(P3.y - P1.y) )                      ;
									 FilterROI.Attach(&RotateBinaryImg)                                    ;
									 FilterROI.SetPlacement(P1.x, P1.y, int(P2.x - P1.x), int(P3.y - P1.y));
									 LogUnit.SetLog(L"Polygon6 ==>Px :%d, Py :%d, Width:%d, Height:%d ==>Median Filter",P1.x, P1.y, int(P2.x - P1.x), int(P3.y - P1.y));     
									 LogUnit.SetLog(L"Polygon6 ==>P1x:%d, P1y:%d, P2x:%d, P2y:%d, P3x:%d, P3y:%d, P4x:%d, P4y:%d,",P1.x,P1.y,P2.x,P2.y,P3.x,P3.y,P4.x,P4.y);     
									 EasyImage::Median(&FilterROI, &FilterROI)                             ;

									 Polygon->GImage          = &RotateBinaryImg           ;
									 Polygon->PoPa.FMaxWidth  =(int)(CSideCircleWidth+100 );
									 Polygon->PoPa.FMaxHeight =(int)(CSideCircleHeight+100);
									 Polygon->PoPa.IsSeparate =true                        ;
									 Polygon->PoPa.IsInToOut  =true                        ;
									 Polygon->PoPa.HiThHold   = BtmEdgeThresHold           ;
									 Polygon->PoPa.LoThHold   = 0                          ;
									 Polygon->PoPa.FMinWidth  =(int)(CSideCircleWidth /2)  ;
									 Polygon->PoPa.FMinHeight =(int)(CSideCircleHeight/2)  ;

									 if(P1.x!=0 && P1.y!=0 && P2.x!=0 && P2.y!=0 && P3.x!=0 && P3.y!=0 && P4.x!=0 && P4.y!=0){
										 Polygon->OnExecute(P1,P2,P3,P4);
									 }

									 // Polygon Algorithm InEdgeData/OutEdgeData Separate 및 데이터 추출 
									 if(Polygon->BlobCount==1){
										 PolygonMarginCnt =10;
										 if(Polygon->Blob[0].InCnt>(PolygonMarginCnt*2)){
											 C6CirInEdgeCount=0;
											 C6CirInEdgeCount = (Polygon->Blob[0].InCnt - (PolygonMarginCnt*2));
											 if(C6CirInEdgeCount>0){
												 if(C6CirInPoint!=NULL) {
													 delete[] C6CirInPoint;
												 }
												 C6CirInPoint = new TFPoint[C6CirInEdgeCount];

												 PixelCnt=0;
												 for(int k=0; k<Polygon->Blob[0].InCnt; k++){
													 if(k<PolygonMarginCnt || k>=(Polygon->Blob[0].InCnt-PolygonMarginCnt)) continue;
													 C6CirInPoint[PixelCnt].x   = Polygon->Blob[0].InPoint[k].x ;
													 C6CirInPoint[PixelCnt].y   = Polygon->Blob[0].InPoint[k].y ;
													 PixelCnt++;
												 }
											 }
										 }

										 if(Polygon->Blob[0].OutCnt>(PolygonMarginCnt*2)){
											 C6CirOutEdgeCount=0;
											 C6CirOutEdgeCount = (Polygon->Blob[0].OutCnt - (PolygonMarginCnt*2));
											 if(C6CirOutEdgeCount>0){
												 if(C6CirOutPoint!=NULL) delete[] C6CirOutPoint;
												 C6CirOutPoint = new TFPoint[C6CirOutEdgeCount];

												 PixelCnt=0;
												 for(int k=0; k<Polygon->Blob[0].OutCnt; k++){
													 if(k<PolygonMarginCnt || k>=(Polygon->Blob[0].OutCnt-PolygonMarginCnt)) continue;
													 C6CirOutPoint[PixelCnt].x  = Polygon->Blob[0].OutPoint[k].x ;
													 C6CirOutPoint[PixelCnt].y  = Polygon->Blob[0].OutPoint[k].y ;

													 if(k==PolygonMarginCnt){ //직선구간에 필요한 시작점  
														 BtmEdgePoint[9].x = C6CirOutPoint[PixelCnt].x;
														 BtmEdgePoint[9].y = C6CirOutPoint[PixelCnt].y;
													 }
													 PixelCnt++;
												 }
											 }
										 }
										 // Polygon Data Clear
										 // 											 Polygon->ClearData();
									 }
									 /////////////////////////////////////////////////////////////////////////////////////////////

									 // InEdgeData/OutEdgeData 기준 가공량 및 연마량 계산
									 // Polygon 알고리즘에서는 GrindMark기준 OutData,InData 최단거리 2개 Tag값 산출해야함 
									 if(IsMarkBtm){ // LTPS 가공량,연마량 계산 
										 if(C6CirOutEdgeCount!=0 && C6CirInEdgeCount!=0){ // MarkMode경우 가공량 검사를 먼저 진행 후 연마량 산출 

											 // GrindMark[17]기준 연마량,가공량 측정 시퀀스 
											 ////////////////////////////////////////////////////////////////////////////////////
											 if(GrindMarkPoint[17].x!=0.0f && GrindMarkPoint[17].y!=0.0f){  //GrindMark 찾았을경우 
												 // GrindMark기준 OutData 최단거리 Count정보 Calc 
												 GrindMeaDis =0.0f, MinDis =10000.0f; GrindMarkOutCnt=0;
												 for(int k=0; k<C6CirOutEdgeCount; k++){
													 if(C6CirOutPoint[k].x  ==0.0f || C6CirOutPoint[k].y ==0.0f ) continue;
													 if(GrindMarkPoint[17].x==0.0f || GrindMarkPoint[17].y==0.0f) continue;

													 GrindMeaDis = Math.GetLength(GrindMarkPoint[17], C6CirOutPoint[k]);
													 if(GrindMeaDis<MinDis){
														 MinDis = GrindMeaDis;
														 GrindMarkOutCnt = k;
													 }
												 }

												 // GrindMark기준 InData 최단거리 Count정보 Calc 
												 if(GrindMarkOutCnt!=0){
													 GrindMeaDis =0.0f, MinDis =10000.0f; GrindMarkInCnt=0;
													 for(int k=0; k<C6CirInEdgeCount; k++){
														 if(C6CirInPoint[k].x   ==0.0f             || C6CirInPoint[k].y                ==0.0f) continue;
														 if(C6CirOutPoint[GrindMarkOutCnt].x==0.0f || C6CirOutPoint[GrindMarkOutCnt].y ==0.0f) continue;

														 GrindMeaDis = Math.GetLength(C6CirOutPoint[GrindMarkOutCnt], C6CirInPoint[k]);
														 if(GrindMeaDis<MinDis){
															 MinDis = GrindMeaDis;
															 GrindMarkInCnt = k;
														 }
													 }
												 }

												 // GrindMark기준 수직 포인트 주변값 Avg산출한다 ==>가공량 측정(OutData기준)
												 if(GrindMarkOutCnt!=0 && GrindMarkOutCnt>5){
													 CircleCount=0,TotalCirDis=0.0f,GrindMeaDis=0.0f;
													 for(int k=GrindMarkOutCnt-5; k<GrindMarkOutCnt+5; k++){
														 if(C6CirOutPoint[k].x==0.0f || C6CirOutPoint[k].y==0.0f) continue;
														 if(k>=C6CirOutEdgeCount                                ) continue;

														 GrindMeaDis = Math.GetLength(GrindMarkPoint[17], C6CirOutPoint[k]);
														 TotalCirDis+= GrindMeaDis;
														 CircleCount++;
													 }
													 if(TotalCirDis!=0.0f && CircleCount!=0){
														 C6CirGrindMea = TotalCirDis/CircleCount;
														 C6CirGrindMea = C6CirGrindMea+0.5; //SubPixel 
													 }
												 }

												 // GrindMark기준 수직 포인트 주변값 Avg산출한다 ==>연마량 측정(OutData,InData기준)
												 if((GrindMarkOutCnt!=0 && GrindMarkOutCnt>5) && (GrindMarkInCnt!=0 && GrindMarkInCnt>5)){
													 CircleCount=0,TotalCirDis=0.0f,GrindWidthDis=0.0f;
													 for(int k=-5; k<5; k++){
														 if(C6CirOutPoint[GrindMarkOutCnt+k].x==0.0f && C6CirOutPoint[GrindMarkOutCnt+k].y==0.0f) continue;
														 if(C6CirInPoint [GrindMarkInCnt +k].x==0.0f && C6CirInPoint [GrindMarkInCnt +k].y==0.0f) continue;
														 if((GrindMarkOutCnt+k)>=C6CirOutEdgeCount                                              ) continue;
														 if((GrindMarkInCnt +k)>=C6CirInEdgeCount                                               ) continue;

														 GrindWidthDis = Math.GetLength(C6CirInPoint[GrindMarkInCnt+k], C6CirOutPoint[GrindMarkOutCnt+k]);
														 TotalCirDis+=   GrindWidthDis;
														 CircleCount++;
													 }
													 if(TotalCirDis!=0.0f && CircleCount!=0){
														 C6CirGrindWd = TotalCirDis/CircleCount;
														 C6CirGrindWd = C6CirGrindWd+0.5; //SubPixel
													 }
												 }
											 }
											 else if(GrindMarkRect[17].left!=0 && GrindMarkRect[17].top!=0 && GrindMarkRect[17].right!=0 &&GrindMarkRect[17].bottom!=0){  //GrindMark 못 찾았을경우
												 // OutData기준 최소값 데이터 Count산출 
												 GrindMeaDis =0.0f, MinDis =10000.0f; GrindMarkOutCnt=0;
												 for(int k=0; k<C6CirOutEdgeCount; k++){
													 if(C6CirOutPoint[k].x==0.0f || C6CirOutPoint[k].y==0.0f) continue;

													 GrindMarkRectCenter[17].x = GrindMarkRect[17].left + (GrindMarkRect[17].right  - GrindMarkRect[17].left)/2; 
													 GrindMarkRectCenter[17].y = GrindMarkRect[17].top  + (GrindMarkRect[17].bottom - GrindMarkRect[17].top )/2; 

													 GrindMeaDis = Math.GetLength(GrindMarkRectCenter[17], C6CirOutPoint[k]);
													 if(GrindMeaDis<MinDis){
														 MinDis = GrindMeaDis;
														 GrindMarkOutCnt = k;
													 }
												 }

												 // 최단거리OUtCount기준 InData 최단거리 Count정보 Calc 
												 if(GrindMarkOutCnt!=0){
													 GrindMeaDis =0.0f, MinDis =10000.0f; GrindMarkInCnt=0;
													 for(int k=0; k<C6CirInEdgeCount; k++){
														 if(C6CirInPoint[k].x   ==0.0f             || C6CirInPoint[k].y                ==0.0f) continue;
														 if(C6CirOutPoint[GrindMarkOutCnt].x==0.0f || C6CirOutPoint[GrindMarkOutCnt].y ==0.0f) continue;

														 GrindMeaDis = Math.GetLength(C6CirOutPoint[GrindMarkOutCnt], C6CirInPoint[k]);
														 if(GrindMeaDis<MinDis){
															 MinDis = GrindMeaDis;
															 GrindMarkInCnt = k;
														 }
													 }
												 }

												 // GrindMark기준 수직 포인트 주변값 Avg산출한다 ==>연마량 측정(OutData,InData기준)
												 if((GrindMarkOutCnt!=0 && GrindMarkOutCnt>5) && (GrindMarkInCnt!=0 && GrindMarkInCnt>5)){
													 CircleCount=0,TotalCirDis=0.0f,GrindWidthDis=0.0f;
													 for(int k=-5; k<5; k++){
														 if(C6CirOutPoint[GrindMarkOutCnt+k].x==0.0f && C6CirOutPoint[GrindMarkOutCnt+k].y==0.0f) continue;
														 if(C6CirInPoint [GrindMarkInCnt +k].x==0.0f && C6CirInPoint [GrindMarkInCnt +k].y==0.0f) continue;
														 if((GrindMarkOutCnt+k)>=C6CirOutEdgeCount                                              ) continue;
														 if((GrindMarkInCnt +k)>=C6CirInEdgeCount                                               ) continue;

														 GrindWidthDis = Math.GetLength(C6CirInPoint[GrindMarkInCnt+k], C6CirOutPoint[GrindMarkOutCnt+k]);
														 TotalCirDis+=   GrindWidthDis;
														 CircleCount++;
													 }
													 if(TotalCirDis!=0.0f && CircleCount!=0){
														 C6CirGrindWd = TotalCirDis/CircleCount;
														 C6CirGrindWd = C6CirGrindWd+0.5; //SubPixel
													 }
												 }
											 }

											 // GrindMark[18]기준 연마량,가공량 측정 시퀀스 
											 ////////////////////////////////////////////////////////////////////////////////////
											 if(GrindMarkPoint[18].x!=0.0f && GrindMarkPoint[18].y!=0.0f){  //GrindMark 찾았을경우 
												 // GrindMark기준 OutData 최단거리 Count정보 Calc 
												 GrindMeaDis =0.0f, MinDis =10000.0f; GrindMarkOutCnt=0;
												 for(int k=0; k<C6CirOutEdgeCount; k++){
													 if(C6CirOutPoint[k].x  ==0.0f || C6CirOutPoint[k].y ==0.0f ) continue;
													 if(GrindMarkPoint[18].x==0.0f || GrindMarkPoint[18].y==0.0f) continue;

													 GrindMeaDis = Math.GetLength(GrindMarkPoint[18], C6CirOutPoint[k]);
													 if(GrindMeaDis<MinDis){
														 MinDis = GrindMeaDis;
														 GrindMarkOutCnt = k;
													 }
												 }

												 // GrindMark기준 InData 최단거리 Count정보 Calc 
												 if(GrindMarkOutCnt!=0){
													 GrindMeaDis =0.0f, MinDis =10000.0f; GrindMarkInCnt=0;
													 for(int k=0; k<C6CirInEdgeCount; k++){
														 if(C6CirInPoint[k].x   ==0.0f             || C6CirInPoint[k].y                ==0.0f) continue;
														 if(C6CirOutPoint[GrindMarkOutCnt].x==0.0f || C6CirOutPoint[GrindMarkOutCnt].y ==0.0f) continue;

														 GrindMeaDis = Math.GetLength(C6CirOutPoint[GrindMarkOutCnt], C6CirInPoint[k]);
														 if(GrindMeaDis<MinDis){
															 MinDis = GrindMeaDis;
															 GrindMarkInCnt = k;
														 }
													 }
												 }

												 // GrindMark기준 수직 포인트 주변값 Avg산출한다 ==>가공량 측정(OutData기준)
												 if(GrindMarkOutCnt!=0 && GrindMarkOutCnt>5){
													 CircleCount=0,TotalCirDis=0.0f,GrindMeaDis=0.0f;
													 for(int k=GrindMarkOutCnt-5; k<GrindMarkOutCnt+5; k++){
														 if(C6CirOutPoint[k].x==0.0f || C6CirOutPoint[k].y==0.0f) continue;
														 if(k>=C6CirOutEdgeCount                                ) continue;

														 GrindMeaDis = Math.GetLength(GrindMarkPoint[18], C6CirOutPoint[k]);
														 TotalCirDis+= GrindMeaDis;
														 CircleCount++;
													 }
													 if(TotalCirDis!=0.0f && CircleCount!=0){
														 C7CirGrindMea = TotalCirDis/CircleCount;
														 C7CirGrindMea = C7CirGrindMea+0.5; //SubPixel 
													 }
												 }

												 // GrindMark기준 수직 포인트 주변값 Avg산출한다 ==>연마량 측정(OutData,InData기준)
												 if((GrindMarkOutCnt!=0 && GrindMarkOutCnt>5) && (GrindMarkInCnt!=0 && GrindMarkInCnt>5)){
													 CircleCount=0,TotalCirDis=0.0f,GrindWidthDis=0.0f;
													 for(int k=-5; k<5; k++){
														 if(C6CirOutPoint[GrindMarkOutCnt+k].x==0.0f && C6CirOutPoint[GrindMarkOutCnt+k].y==0.0f) continue;
														 if(C6CirInPoint [GrindMarkInCnt +k].x==0.0f && C6CirInPoint [GrindMarkInCnt +k].y==0.0f) continue;
														 if((GrindMarkOutCnt+k)>=C6CirOutEdgeCount                                              ) continue;
														 if((GrindMarkInCnt +k)>=C6CirInEdgeCount                                               ) continue;

														 GrindWidthDis = Math.GetLength(C6CirInPoint[GrindMarkInCnt+k], C6CirOutPoint[GrindMarkOutCnt+k]);
														 TotalCirDis+=   GrindWidthDis;
														 CircleCount++;
													 }
													 if(TotalCirDis!=0.0f && CircleCount!=0){
														 C7CirGrindWd = TotalCirDis/CircleCount;
														 C7CirGrindWd = C7CirGrindWd+0.5; //SubPixel
													 }
												 }
											 }
											 else if(GrindMarkRect[18].left!=0 && GrindMarkRect[18].top!=0 && GrindMarkRect[18].right!=0 && GrindMarkRect[18].bottom!=0) {  //GrindMark 못 찾았을경우
												 // OutData기준 최소값 데이터 Count산출 
												 GrindMeaDis =0.0f, MinDis =10000.0f; GrindMarkOutCnt=0;
												 for(int k=0; k<C6CirOutEdgeCount; k++){
													 if(C6CirOutPoint[k].x==0.0f || C6CirOutPoint[k].y==0.0f) continue;

													 GrindMarkRectCenter[18].x = GrindMarkRect[18].left + (GrindMarkRect[18].right  - GrindMarkRect[18].left)/2; 
													 GrindMarkRectCenter[18].y = GrindMarkRect[18].top  + (GrindMarkRect[18].bottom - GrindMarkRect[18].top )/2; 

													 GrindMeaDis = Math.GetLength(GrindMarkRectCenter[18], C6CirOutPoint[k]);
													 if(GrindMeaDis<MinDis){
														 MinDis = GrindMeaDis;
														 GrindMarkOutCnt = k;
													 }
												 }

												 // 최단거리OUtCount기준 InData 최단거리 Count정보 Calc 
												 if(GrindMarkOutCnt!=0){
													 GrindMeaDis =0.0f, MinDis =10000.0f; GrindMarkInCnt=0;
													 for(int k=0; k<C6CirInEdgeCount; k++){
														 if(C6CirInPoint[k].x   ==0.0f             || C6CirInPoint[k].y                ==0.0f) continue;
														 if(C6CirOutPoint[GrindMarkOutCnt].x==0.0f || C6CirOutPoint[GrindMarkOutCnt].y ==0.0f) continue;

														 GrindMeaDis = Math.GetLength(C6CirOutPoint[GrindMarkOutCnt], C6CirInPoint[k]);
														 if(GrindMeaDis<MinDis){
															 MinDis = GrindMeaDis;
															 GrindMarkInCnt = k;
														 }
													 }
												 }

												 // GrindMark기준 수직 포인트 주변값 Avg산출한다 ==>연마량 측정(OutData,InData기준)
												 if((GrindMarkOutCnt!=0 && GrindMarkOutCnt>5) && (GrindMarkInCnt!=0 && GrindMarkInCnt>5)){
													 CircleCount=0,TotalCirDis=0.0f,GrindWidthDis=0.0f;
													 for(int k=-5; k<5; k++){
														 if(C6CirOutPoint[GrindMarkOutCnt+k].x==0.0f && C6CirOutPoint[GrindMarkOutCnt+k].y==0.0f) continue;
														 if(C6CirInPoint [GrindMarkInCnt +k].x==0.0f && C6CirInPoint [GrindMarkInCnt +k].y==0.0f) continue;
														 if((GrindMarkOutCnt+k)>=C6CirOutEdgeCount                                              ) continue;
														 if((GrindMarkInCnt +k)>=C6CirInEdgeCount                                               ) continue;

														 GrindWidthDis = Math.GetLength(C6CirInPoint[GrindMarkInCnt+k], C6CirOutPoint[GrindMarkOutCnt+k]);
														 TotalCirDis+=   GrindWidthDis;
														 CircleCount++;
													 }
													 if(TotalCirDis!=0.0f && CircleCount!=0){
														 C7CirGrindWd = TotalCirDis/CircleCount;
														 C7CirGrindWd = C7CirGrindWd+0.5; //SubPixel
													 }
												 }
											 }
										 }
									 }
									 else         { //Polygon EnCap 계산시 OutPoint 중간값 기준 실측 거리 평균값을 계산한다(LeftTop) 
										 if(C6CirInEdgeCount!=0 && C6CirOutEdgeCount!=0){
											 GrindMeaDis =0.0f, MinDis =10000.0f; GrindMarkOutCnt=0;
											 GrindMarkOutCnt = (int)(C6CirOutEdgeCount/2);
											 // 최단거리OUtCount기준 InData 최단거리 Count정보 Calc 
											 if(GrindMarkOutCnt!=0){
												 GrindMeaDis =0.0f, MinDis =10000.0f; GrindMarkInCnt=0;
												 for(int k=0; k<C6CirInEdgeCount; k++){
													 if(C6CirInPoint[k].x   ==0.0f             || C6CirInPoint[k].y                ==0.0f) continue;
													 if(C6CirOutPoint[GrindMarkOutCnt].x==0.0f || C6CirOutPoint[GrindMarkOutCnt].y ==0.0f) continue;

													 GrindMeaDis = Math.GetLength(C6CirOutPoint[GrindMarkOutCnt], C6CirInPoint[k]);
													 if(GrindMeaDis<MinDis){
														 MinDis = GrindMeaDis;
														 GrindMarkInCnt = k;
													 }
												 }
											 }

											 // GrindMark기준 수직 포인트 주변값 Avg산출한다 ==>연마량 측정(OutData,InData기준)
											 if((GrindMarkOutCnt!=0 && GrindMarkOutCnt>5) && (GrindMarkInCnt!=0 && GrindMarkInCnt>5)){
												 CircleCount=0,TotalCirDis=0.0f,GrindWidthDis=0.0f;
												 for(int k=-5; k<5; k++){
													 if(C6CirOutPoint[GrindMarkOutCnt+k].x==0.0f && C6CirOutPoint[GrindMarkOutCnt+k].y==0.0f) continue;
													 if(C6CirInPoint [GrindMarkInCnt +k].x==0.0f && C6CirInPoint [GrindMarkInCnt +k].y==0.0f) continue;
													 if((GrindMarkOutCnt+k)>=C6CirOutEdgeCount                                              ) continue;
													 if((GrindMarkInCnt +k)>=C6CirInEdgeCount                                               ) continue;

													 GrindWidthDis = Math.GetLength(C6CirInPoint[GrindMarkInCnt+k], C6CirOutPoint[GrindMarkOutCnt+k]);
													 TotalCirDis+=   GrindWidthDis;
													 CircleCount++;
												 }
												 if(TotalCirDis!=0.0f && CircleCount!=0){
													 C6CirGrindWd = TotalCirDis/CircleCount;
													 C6CirGrindWd = C6CirGrindWd+0.5; //SubPixel
												 }
											 }
										 }
									 }
									 ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
									 // FAVION Circle Fitting 결과물(Circle_1)
									 SampleSize   = C6CirInEdgeCount*0.75; //0.5~0.8이하로 입력할것
									 DistDevRatio = 0.15                 ; //0.1~0.25 이하로 입력할것
									 CircleFit->OnRansac(C6CirInPoint,C6CirInEdgeCount,SampleSize,DistDevRatio,&CircleFit6Center,&CirFitDiameter6);

									 // Polygon 박리 검사 시퀀스 
									 if(!IsMarkBtm && BrokenThresHold!=0){
										 RotateBrokenImg.SetSize(RotateImg.GetWidth(), RotateImg.GetHeight());
										 EasyImage::Oper(EArithmeticLogicOperation_Copy,&RotateImg,&RotateBrokenImg);
										 EasyImage::Threshold(&RotateImg,&RotateBrokenImg, BrokenThresHold);
										 // 											 RotateBrokenImg.Save("D:\\ROTATE_IMG\\Polygon_하단박리.bmp");
										 Edge->GImage = &RotateBrokenImg;
										 Edge->SetEdgeType(0);

										 int DvCnt =0, DataCount=0;
										 double deg =0.0f; 
										 TFPoint Target(0.0f, 0.0f);

										 if(GrindMarkInCnt>GrindMarkOutCnt){
											 DvCnt = GrindMarkInCnt - GrindMarkOutCnt;
											 for(int k=0; k<C6CirOutEdgeCount; k++){
												 deg =0.0f, Target.x =0.0f, Target.y =0.0f;
												 if(((k+DvCnt)<C6CirInEdgeCount) && C6CirInPoint[k+DvCnt].x>0  && C6CirInPoint[k+DvCnt].y>0){
													 deg = Math.GetDegree(C6CirOutPoint[k],C6CirInPoint[k+DvCnt]);

													 Target  = Math.OnFindPerpendicularPointXY(C6CirOutPoint[k],-dEdgeToTrapLineDis,-dEdgeToTrapLineDis,deg);
													 Edge->OnExecute(C6CirOutPoint[k],Target); // 연마외곽라인에서 Target까지 White Point Search 
													 if(Edge->GetResultEdgePointCount()>0){
														 C6CircleData[DataCount].Dis =0.0f;
														 C6CircleData[DataCount].Dv  =0.0f;
														 C6CircleData[DataCount].P   = Edge->GetResultEdgePoint(0);
														 C6CircleData[DataCount].P.y = C6CircleData[DataCount].P.y - ImageHeight; // Frame기준 단위좌표로 변경함  
														 DataCount++;
													 }
												 }
											 }
											 C6CirInCrackCount = DataCount;
										 }
										 else if(GrindMarkInCnt<GrindMarkOutCnt)   {
											 DvCnt = GrindMarkOutCnt - GrindMarkInCnt;
											 for(int k=DvCnt; k<C6CirOutEdgeCount; k++){
												 deg =0.0f, Target.x =0.0f, Target.y =0.0f;
												 if(((k-DvCnt)<C6CirInEdgeCount) && C6CirInPoint[k-DvCnt].x>0  && C6CirInPoint[k-DvCnt].y>0 && k-DvCnt>=0){
													 deg = Math.GetDegree(C6CirOutPoint[k],C6CirInPoint[k-DvCnt]);

													 Target  = Math.OnFindPerpendicularPointXY(C6CirOutPoint[k],-dEdgeToTrapLineDis,-dEdgeToTrapLineDis,deg);
													 Edge->OnExecute(C6CirOutPoint[k],Target); // 연마외곽라인에서 Target까지 White Point Search 
													 if(Edge->GetResultEdgePointCount()>0){
														 C6CircleData[DataCount].Dis =0.0f;
														 C6CircleData[DataCount].Dv  =0.0f;
														 C6CircleData[DataCount].P   = Edge->GetResultEdgePoint(0);
														 C6CircleData[DataCount].P.y = C6CircleData[DataCount].P.y - ImageHeight; // Frame기준 단위좌표로 변경함  
														 DataCount++;
													 }
												 }
											 }
											 C6CirInCrackCount = DataCount;
										 }
									 }
									 LogUnit.SetLog(L"CellID:%d, CamID:%d ==>Polygon6_Insp_End",CellId,CamId);     
								 }

								 // 비선형 곡선 영역을 제외한 직선 영역 검사 시퀀스 
								 // 첫번째 직선 영역 
								 if(BtmEdgePoint[0].x!=0 && BtmEdgePoint[0].y!=0 && BtmEdgePoint[1].x!=0 && BtmEdgePoint[1].y!=0 ){
									 P1.x=0, P1.y=0, P2.x=0, P2.y=0, P3.x=0, P3.y=0, P4.x=0, P4.y=0;
									 LogUnit.SetLog(L"CellID:%d, CamID:%d ==>Straight1_Insp_Start",CellId,CamId);     

									 P1.x = (BtmEdgePoint[0].x); P1.y =(BtmEdgePoint[0].y-30); P2.x = (P1.x+(BtmEdgePoint[1].x - BtmEdgePoint[0].x )); P2.y = (P1.y);
									 P3.x = (BtmEdgePoint[0].x); P3.y =(BtmEdgePoint[0].y+30); P4.x = (P2.x                                         ); P4.y = (P3.y);

									 // Median Filter 적용 
									 if(P1.x<=0    || P1.y<=0    || (P2.x - P1.x)<=0    || (P3.y - P1.y)<=0   ) return false;
									 if(P1.x>=ImgW || P1.y>=ImgH || (P2.x - P1.x)>=ImgW || (P3.y - P1.y)>=ImgH) return false;
									 FilterROI.SetSize(int(P2.x - P1.x),int(P3.y - P1.y) )                      ;
									 FilterROI.Attach(&RotateBinaryImg)                                    ;
									 FilterROI.SetPlacement(P1.x, P1.y, int(P2.x - P1.x), int(P3.y - P1.y));
									 LogUnit.SetLog(L"첫번째 직선 ==>Px :%d, Py :%d, Width:%d, Height:%d ==>Median Filter",P1.x, P1.y, int(P2.x - P1.x), int(P3.y - P1.y));     
									 LogUnit.SetLog(L"첫번째 직선 ==>P1x:%d, P1y:%d, P2x:%d, P2y:%d, P3x:%d, P3y:%d, P4x:%d, P4y:%d,",P1.x,P1.y,P2.x,P2.y,P3.x,P3.y,P4.x,P4.y);     
									 EasyImage::Median(&FilterROI, &FilterROI)                             ;

									 Polygon->PoPa.FMinHeight = 5                          ;
									 Polygon->GImage          = &RotateBinaryImg           ;
									 Polygon->PoPa.FMaxWidth  =(int)(P2.x - P1.x)+100      ;
									 Polygon->PoPa.FMaxHeight =(int)(P3.y - P1.y)          ;
									 Polygon->PoPa.FMinWidth  =(int)(P2.x - P1.x)-100      ; 
									 Polygon->PoPa.IsSeparate =true                        ;
									 Polygon->PoPa.IsInToOut  =true                        ;
									 Polygon->PoPa.HiThHold   = BtmEdgeThresHold           ;
									 Polygon->PoPa.LoThHold   = 0                          ;

									 if(P1.x!=0 && P1.y!=0 && P2.x!=0 && P2.y!=0 && P3.x!=0 && P3.y!=0 && P4.x!=0 && P4.y!=0){
										 Polygon->OnExecute(P1,P2,P3,P4);
									 }

									 // Polygon Algorithm InEdgeData/OutEdgeData Separate 및 데이터 추출 
									 if(Polygon->BlobCount==1){
										 PolygonMarginCnt =10;
										 if(Polygon->Blob[0].InCnt>(PolygonMarginCnt*2)){
											 OrgBtm1InEdgeCount=0;
											 OrgBtm1InEdgeCount = (Polygon->Blob[0].InCnt - (PolygonMarginCnt*2));
											 if(OrgBtm1InEdgeCount>0){
												 if(OrgBtm1InPoint!=NULL) delete[] OrgBtm1InPoint;
												 OrgBtm1InPoint = new TFPoint[OrgBtm1InEdgeCount];

												 PixelCnt=0;
												 for(int k=0; k<Polygon->Blob[0].InCnt; k++){
													 if(k<PolygonMarginCnt || k>=(Polygon->Blob[0].InCnt-PolygonMarginCnt)) continue;
													 OrgBtm1InPoint[PixelCnt].x   = Polygon->Blob[0].InPoint[k].x ;
													 OrgBtm1InPoint[PixelCnt].y   = Polygon->Blob[0].InPoint[k].y ;
													 PixelCnt++;
												 }
											 }
											 // Org Data 
											 BtmInLine[0].FP0 = OrgBtm1InPoint[0];
											 BtmInLine[0].FP1 = OrgBtm1InPoint[PixelCnt-1];
										 }

										 if(Polygon->Blob[0].OutCnt>(PolygonMarginCnt*2)){
											 OrgBtm1OutEdgeCount=0;
											 OrgBtm1OutEdgeCount = (Polygon->Blob[0].OutCnt - (PolygonMarginCnt*2));
											 if(OrgBtm1OutEdgeCount>0){
												 if(OrgBtm1OutPoint!=NULL) delete[] OrgBtm1OutPoint;
												 OrgBtm1OutPoint = new TFPoint[OrgBtm1OutEdgeCount];

												 PixelCnt=0;
												 for(int k=0; k<Polygon->Blob[0].OutCnt; k++){
													 if(k<PolygonMarginCnt || k>=(Polygon->Blob[0].OutCnt-PolygonMarginCnt)) continue;
													 OrgBtm1OutPoint[PixelCnt].x  = Polygon->Blob[0].OutPoint[k].x ;
													 OrgBtm1OutPoint[PixelCnt].y  = Polygon->Blob[0].OutPoint[k].y ;
													 PixelCnt++;
												 }
											 }
											 // Org Data 
											 BtmOutLine[0].FP0 = OrgBtm1OutPoint[0];
											 BtmOutLine[0].FP1 = OrgBtm1OutPoint[PixelCnt-1];
										 }
										 // Polygon Data Clear
										 // 											 Polygon->ClearData();
									 }

									 // 연마량 측정 및 가공량 측정 (비선형)
									 if(IsMarkBtm){
										 if(OrgBtm1InEdgeCount>10 && OrgBtm1OutEdgeCount>10){
											 // 가공량,연마량 측정 전 데이터 존재시 가상GrindMark 생성한다 
											 if(GrindMarkPoint[2].x!=0.0f && GrindMarkPoint[2].y!=0.0f && GrindRectSpec[4].DvX==0.0f && GrindRectSpec[4].DvY==0.0f &&!IsNarrowTrench){
												 GrindMarkPoint[4].x     = OrgBtm1InPoint[OrgBtm1InEdgeCount-10].x ;
												 GrindMarkPoint[4].y     = GrindMarkPoint[2].y                     ;
												 GrindMarkRect [4].left  = GrindMarkPoint[4].x    - GrindMarkRange ;  
												 GrindMarkRect [4].top   = GrindMarkPoint[4].y    - GrindMarkRange ;  
												 GrindMarkRect [4].right = GrindMarkRect [4].left + GrindMarkLength;  
												 GrindMarkRect [4].bottom= GrindMarkRect [4].top  + GrindMarkLength;  
											 }
											 // GrindMark[2] 가공량,연마량 측정 
											 ////////////////////////////////////////////////////////////////////////////////////////////////////
											 if(GrindMarkPoint[2].x!=0.0f && GrindMarkPoint[2].y!=0.0f) { 
												 // GrindMark기준 OutData 최단거리 Count정보 Calc 
												 GrindMeaDis =0.0f, MinDis =10000.0f;  GrindMarkOutCnt=0;
												 for(int k=0; k<OrgBtm1OutEdgeCount; k++){
													 if(OrgBtm1OutPoint[k].x==0.0f || OrgBtm1OutPoint[k].y==0.0f) continue;
													 if(GrindMarkPoint[2].x ==0.0f || GrindMarkPoint[2].y ==0.0f) continue;

													 GrindMeaDis = Math.GetLength(GrindMarkPoint[2], OrgBtm1OutPoint[k]);
													 if(GrindMeaDis<MinDis){
														 MinDis = GrindMeaDis;
														 GrindMarkOutCnt = k;
													 }
												 }

												 // GrindMark기준 InData 최단거리 Count정보 Calc 
												 if(GrindMarkOutCnt!=0){
													 GrindMeaDis =0.0f, MinDis =10000.0f; GrindMarkInCnt=0;
													 for(int k=0; k<OrgBtm1InEdgeCount; k++){
														 if(OrgBtm1InPoint[k].x   ==0.0f             || OrgBtm1InPoint[k].y                ==0.0f) continue;
														 if(OrgBtm1OutPoint[GrindMarkOutCnt].x==0.0f || OrgBtm1OutPoint[GrindMarkOutCnt].y ==0.0f) continue;

														 GrindMeaDis = Math.GetLength(OrgBtm1OutPoint[GrindMarkOutCnt], OrgBtm1InPoint[k]);
														 if(GrindMeaDis<MinDis){
															 MinDis = GrindMeaDis;
															 GrindMarkInCnt = k;
														 }
													 }
												 }

												 // GrindMark기준 수직 포인트 주변값 Avg산출한다 ==>가공량 측정(OutData기준)
												 if(GrindMarkOutCnt!=0 && GrindMarkOutCnt>5){
													 CircleCount=0,TotalCirDis=0.0f,GrindMeaDis=0.0f;
													 for(int k=GrindMarkOutCnt-5; k<GrindMarkOutCnt+5; k++){
														 if(OrgBtm1OutPoint[k].x==0.0f || OrgBtm1OutPoint[k].y==0.0f) continue;
														 if(k>=OrgBtm1OutEdgeCount                                  ) continue;

														 GrindMeaDis = Math.GetLength(GrindMarkPoint[2], OrgBtm1OutPoint[k]);
														 TotalCirDis+= GrindMeaDis;
														 CircleCount++;
													 }
													 if(TotalCirDis!=0.0f && CircleCount!=0){
														 BtmGrindMeasure1 = TotalCirDis/CircleCount;
														 BtmGrindMeasure1 = BtmGrindMeasure1+0.5; //SubPixel 
													 }
												 }

												 // GrindMark기준 수직 포인트 주변값 Avg산출한다 ==>연마량 측정(OutData,InData기준)
												 if((GrindMarkOutCnt!=0 && GrindMarkOutCnt>5) && (GrindMarkInCnt!=0 && GrindMarkInCnt>5)){
													 CircleCount=0,TotalCirDis=0.0f,GrindWidthDis=0.0f;
													 for(int k=-5; k<5; k++){
														 if(OrgBtm1OutPoint[GrindMarkOutCnt+k].x==0.0f && OrgBtm1OutPoint[GrindMarkOutCnt+k].y==0.0f) continue;
														 if(OrgBtm1InPoint [GrindMarkInCnt +k].x==0.0f && OrgBtm1InPoint [GrindMarkInCnt +k].y==0.0f) continue;
														 if((GrindMarkOutCnt+k)>=OrgBtm1OutEdgeCount                                                ) continue;
														 if((GrindMarkInCnt +k)>=OrgBtm1InEdgeCount                                                 ) continue;

														 GrindWidthDis = Math.GetLength(OrgBtm1InPoint[GrindMarkInCnt+k], OrgBtm1OutPoint[GrindMarkOutCnt+k]);
														 TotalCirDis+=   GrindWidthDis;
														 CircleCount++;
													 }
													 if(TotalCirDis!=0.0f && CircleCount!=0){
														 BtmGrindWidth1 = TotalCirDis/CircleCount;
														 BtmGrindWidth1 = BtmGrindWidth1+0.5; //SubPixel
													 }
												 }
											 }
											 else if(GrindMarkRect[2].left!=0 && GrindMarkRect[2].top!=0 && GrindMarkRect[2].right!=0 && GrindMarkRect[2].bottom!=0) {  //GrindMark 못 찾았을경우
												 // OutData기준 최소값 데이터 Count산출 
												 GrindMeaDis =0.0f, MinDis =10000.0f; GrindMarkOutCnt=0;
												 for(int k=0; k<OrgBtm1OutEdgeCount; k++){
													 if(OrgBtm1OutPoint[k].x==0.0f || OrgBtm1OutPoint[k].y==0.0f) continue;

													 GrindMarkRectCenter[2].x = GrindMarkRect[2].left + (GrindMarkRect[2].right  - GrindMarkRect[2].left)/2; 
													 GrindMarkRectCenter[2].y = GrindMarkRect[2].top  + (GrindMarkRect[2].bottom - GrindMarkRect[2].top )/2; 

													 GrindMeaDis = Math.GetLength(GrindMarkRectCenter[2], OrgBtm1OutPoint[k]);
													 if(GrindMeaDis<MinDis){
														 MinDis = GrindMeaDis;
														 GrindMarkOutCnt = k;
													 }
												 }

												 // 최단거리OUtCount기준 InData 최단거리 Count정보 Calc 
												 if(GrindMarkOutCnt!=0){
													 GrindMeaDis =0.0f, MinDis =10000.0f; GrindMarkInCnt=0;
													 for(int k=0; k<OrgBtm1InEdgeCount; k++){
														 if(OrgBtm1InPoint[k].x              ==0.0f  || OrgBtm1InPoint[k].y                ==0.0f) continue;
														 if(OrgBtm1OutPoint[GrindMarkOutCnt].x==0.0f || OrgBtm1OutPoint[GrindMarkOutCnt].y ==0.0f) continue;

														 GrindMeaDis = Math.GetLength(OrgBtm1OutPoint[GrindMarkOutCnt], OrgBtm1InPoint[k]);
														 if(GrindMeaDis<MinDis){
															 MinDis = GrindMeaDis;
															 GrindMarkInCnt = k;
														 }
													 }
												 }

												 // GrindMark기준 수직 포인트 주변값 Avg산출한다 ==>연마량 측정(OutData,InData기준)
												 if((GrindMarkOutCnt!=0 && GrindMarkOutCnt>5) && (GrindMarkInCnt!=0 && GrindMarkInCnt>5)){
													 CircleCount=0,TotalCirDis=0.0f,GrindWidthDis=0.0f;
													 for(int k=-5; k<5; k++){
														 if(OrgBtm1OutPoint[GrindMarkOutCnt+k].x==0.0f && OrgBtm1OutPoint[GrindMarkOutCnt+k].y==0.0f) continue;
														 if(OrgBtm1InPoint [GrindMarkInCnt +k].x==0.0f && OrgBtm1InPoint [GrindMarkInCnt +k].y==0.0f) continue;
														 if((GrindMarkOutCnt+k)>=OrgBtm1OutEdgeCount                                                ) continue;
														 if((GrindMarkInCnt +k)>=OrgBtm1InEdgeCount                                                 ) continue;

														 GrindWidthDis = Math.GetLength(OrgBtm1InPoint[GrindMarkInCnt+k], OrgBtm1OutPoint[GrindMarkOutCnt+k]);
														 TotalCirDis+=   GrindWidthDis;
														 CircleCount++;
													 }
													 if(TotalCirDis!=0.0f && CircleCount!=0){
														 BtmGrindWidth1 = TotalCirDis/CircleCount;
														 BtmGrindWidth1 = BtmGrindWidth1+0.5; //SubPixel
													 }
												 }
											 }

											 // GrindMark[4] 가공량,연마량 측정 
											 ////////////////////////////////////////////////////////////////////////////////////////////////////
											 if(GrindMarkPoint[4].x!=0.0f && GrindMarkPoint[4].y!=0.0f){ 
												 // GrindMark기준 OutData 최단거리 Count정보 Calc 
												 GrindMeaDis =0.0f, MinDis =10000.0f;  GrindMarkOutCnt=0;
												 for(int k=0; k<OrgBtm1OutEdgeCount; k++){
													 if(OrgBtm1OutPoint[k].x==0.0f || OrgBtm1OutPoint[k].y==0.0f) continue;
													 if(GrindMarkPoint[4].x ==0.0f || GrindMarkPoint[4].y ==0.0f) continue;

													 GrindMeaDis = Math.GetLength(GrindMarkPoint[4], OrgBtm1OutPoint[k]);
													 if(GrindMeaDis<MinDis){
														 MinDis = GrindMeaDis;
														 GrindMarkOutCnt = k;
													 }
												 }

												 // GrindMark기준 InData 최단거리 Count정보 Calc 
												 if(GrindMarkOutCnt!=0){
													 GrindMeaDis =0.0f, MinDis =10000.0f; GrindMarkInCnt=0;
													 for(int k=0; k<OrgBtm1InEdgeCount; k++){
														 if(OrgBtm1InPoint[k].x   ==0.0f             || OrgBtm1InPoint[k].y                ==0.0f) continue;
														 if(OrgBtm1OutPoint[GrindMarkOutCnt].x==0.0f || OrgBtm1OutPoint[GrindMarkOutCnt].y ==0.0f) continue;

														 GrindMeaDis = Math.GetLength(OrgBtm1OutPoint[GrindMarkOutCnt], OrgBtm1InPoint[k]);
														 if(GrindMeaDis<MinDis){
															 MinDis = GrindMeaDis;
															 GrindMarkInCnt = k;
														 }
													 }
												 }

												 // GrindMark기준 수직 포인트 주변값 Avg산출한다 ==>가공량 측정(OutData기준)
												 if(GrindMarkOutCnt!=0 && GrindMarkOutCnt>5){
													 CircleCount=0,TotalCirDis=0.0f,GrindMeaDis=0.0f;
													 for(int k=GrindMarkOutCnt-5; k<GrindMarkOutCnt+5; k++){
														 if(OrgBtm1OutPoint[k].x==0.0f || OrgBtm1OutPoint[k].y==0.0f) continue;
														 if(k>=OrgBtm1OutEdgeCount                                  ) continue;

														 GrindMeaDis = Math.GetLength(GrindMarkPoint[4], OrgBtm1OutPoint[k]);
														 TotalCirDis+= GrindMeaDis;
														 CircleCount++;
													 }
													 if(TotalCirDis!=0.0f && CircleCount!=0){
														 BtmGrindMeasure3 = TotalCirDis/CircleCount;
														 BtmGrindMeasure3 = BtmGrindMeasure3+0.5; //SubPixel 
													 }
												 }

												 // GrindMark기준 수직 포인트 주변값 Avg산출한다 ==>연마량 측정(OutData,InData기준)
												 if((GrindMarkOutCnt!=0 && GrindMarkOutCnt>5) && (GrindMarkInCnt!=0 && GrindMarkInCnt>5)){
													 CircleCount=0,TotalCirDis=0.0f,GrindWidthDis=0.0f;
													 for(int k=-5; k<5; k++){
														 if(OrgBtm1OutPoint[GrindMarkOutCnt+k].x==0.0f && OrgBtm1OutPoint[GrindMarkOutCnt+k].y==0.0f) continue;
														 if(OrgBtm1InPoint [GrindMarkInCnt +k].x==0.0f && OrgBtm1InPoint [GrindMarkInCnt +k].y==0.0f) continue;
														 if((GrindMarkOutCnt+k)>=OrgBtm1OutEdgeCount                                                ) continue;
														 if((GrindMarkInCnt +k)>=OrgBtm1InEdgeCount                                                 ) continue;

														 GrindWidthDis = Math.GetLength(OrgBtm1InPoint[GrindMarkInCnt+k], OrgBtm1OutPoint[GrindMarkOutCnt+k]);
														 TotalCirDis+=   GrindWidthDis;
														 CircleCount++;
													 }
													 if(TotalCirDis!=0.0f && CircleCount!=0){
														 BtmGrindWidth3 = TotalCirDis/CircleCount;
														 BtmGrindWidth3 = BtmGrindWidth3+0.5; //SubPixel
													 }
												 }
											 }
											 else if(GrindMarkRect[4].left!=0 && GrindMarkRect[4].top!=0 && GrindMarkRect[4].right!=0 && GrindMarkRect[4].bottom!=0) {  //GrindMark 못 찾았을경우
												 // OutData기준 최소값 데이터 Count산출 
												 GrindMeaDis =0.0f, MinDis =10000.0f; GrindMarkOutCnt=0;
												 for(int k=0; k<OrgBtm1OutEdgeCount; k++){
													 if(OrgBtm1OutPoint[k].x==0.0f || OrgBtm1OutPoint[k].y==0.0f) continue;

													 // 가상마크 사용 유무에 따라서 데이터 다르게 생성함 
													 if(k==0 && GrindRectSpec[4].DvX==0.0f && GrindRectSpec[4].DvY==0.0f){// 가상마크 사용 
														 GrindMarkRectCenter[4].x     =  OrgBtm1InPoint[OrgBtm1InEdgeCount-10].x;
														 GrindMarkRectCenter[4].y     =  GrindMarkRectCenter[2].y               ;

														 GrindMarkRect [4].left  = GrindMarkRectCenter[4].x  - GrindMarkRange  ;  
														 GrindMarkRect [4].top   = GrindMarkRectCenter[4].y  - GrindMarkRange  ;  
														 GrindMarkRect [4].right = GrindMarkRect [4].left    + GrindMarkLength ;  
														 GrindMarkRect [4].bottom= GrindMarkRect [4].top     + GrindMarkLength ;  
													 }
													 else if(k==0 && GrindRectSpec[4].DvX!=0.0f && GrindRectSpec[4].DvY!=0.0f){ //진성마크 사용 
														 GrindMarkRectCenter[4].x = GrindMarkRect[4].left + (GrindMarkRect[4].right  - GrindMarkRect[4].left)/2; 
														 GrindMarkRectCenter[4].y = GrindMarkRect[4].top  + (GrindMarkRect[4].bottom - GrindMarkRect[4].top )/2; 
													 }

													 GrindMeaDis = Math.GetLength(GrindMarkRectCenter[4], OrgBtm1OutPoint[k]);
													 if(GrindMeaDis<MinDis){
														 MinDis = GrindMeaDis;
														 GrindMarkOutCnt = k;
													 }
												 }

												 // 최단거리OUtCount기준 InData 최단거리 Count정보 Calc 
												 if(GrindMarkOutCnt!=0){
													 GrindMeaDis =0.0f, MinDis =10000.0f; GrindMarkInCnt=0;
													 for(int k=0; k<OrgBtm1InEdgeCount; k++){
														 if(OrgBtm1InPoint[k].x              ==0.0f  || OrgBtm1InPoint[k].y                ==0.0f) continue;
														 if(OrgBtm1OutPoint[GrindMarkOutCnt].x==0.0f || OrgBtm1OutPoint[GrindMarkOutCnt].y ==0.0f) continue;

														 GrindMeaDis = Math.GetLength(OrgBtm1OutPoint[GrindMarkOutCnt], OrgBtm1InPoint[k]);
														 if(GrindMeaDis<MinDis){
															 MinDis = GrindMeaDis;
															 GrindMarkInCnt = k;
														 }
													 }
												 }

												 // GrindMark기준 수직 포인트 주변값 Avg산출한다 ==>연마량 측정(OutData,InData기준)
												 if((GrindMarkOutCnt!=0 && GrindMarkOutCnt>5) && (GrindMarkInCnt!=0 && GrindMarkInCnt>5)){
													 CircleCount=0,TotalCirDis=0.0f,GrindWidthDis=0.0f;
													 for(int k=-5; k<5; k++){
														 if(OrgBtm1OutPoint[GrindMarkOutCnt+k].x==0.0f && OrgBtm1OutPoint[GrindMarkOutCnt+k].y==0.0f) continue;
														 if(OrgBtm1InPoint [GrindMarkInCnt +k].x==0.0f && OrgBtm1InPoint [GrindMarkInCnt +k].y==0.0f) continue;
														 if((GrindMarkOutCnt+k)>=OrgBtm1OutEdgeCount                                                ) continue;
														 if((GrindMarkInCnt +k)>=OrgBtm1InEdgeCount                                                 ) continue;

														 GrindWidthDis = Math.GetLength(OrgBtm1InPoint[GrindMarkInCnt+k], OrgBtm1OutPoint[GrindMarkOutCnt+k]);
														 TotalCirDis+=   GrindWidthDis;
														 CircleCount++;
													 }
													 if(TotalCirDis!=0.0f && CircleCount!=0){
														 BtmGrindWidth3 = TotalCirDis/CircleCount;
														 BtmGrindWidth3 = BtmGrindWidth3+0.5; //SubPixel
													 }
												 }
											 }
										 }
									 }
									 else { // ENCAP 연마량 데이터만 계측함
										 if(BtmOutLine[0].FP0.x!=0.0f && BtmOutLine[0].FP0.y!=0.0f && BtmOutLine[0].FP1.x!=0.0f && BtmOutLine[0].FP1.y!=0.0f &&
											 BtmInLine [0].FP0.x!=0.0f && BtmInLine [0].FP0.y!=0.0f && BtmInLine [0].FP1.x!=0.0f && BtmInLine [0].FP1.y!=0.0f ){
												 // 연마량 계산  
												 if((fabs(BtmOutLine[0].FP0.y - BtmOutLine[0].FP1.y))>1
													 ||(fabs(BtmInLine[0].FP0.y - BtmInLine[0].FP1.y))>1){
														 BtmGrindWidth1 = BtmOutLine[0].FP0.y - BtmInLine[0].FP0.y; 
												 }
												 else{
													 BtmGrindWidth1 = Math.GetLengthFrLineToPoint(BtmOutLine[0].FP0, BtmOutLine[0].FP1, BtmInLine[0].FP0);
												 }
										 }
									 }
									 // 동적 생성한 데이터를 지운다 
									 if(OrgBtm1InPoint !=NULL) delete[] OrgBtm1InPoint;
									 if(OrgBtm1OutPoint!=NULL) delete[] OrgBtm1OutPoint;
									 LogUnit.SetLog(L"CellID:%d, CamID:%d ==>Straight1_Insp_End",CellId,CamId);     
								 }

								 // 비선형 곡선 영역을 제외한 직선 영역 검사 시퀀스 
								 // 세번째 직선 영역 
								 if(BtmEdgePoint[4].x!=0 && BtmEdgePoint[4].y!=0 && BtmEdgePoint[5].x!=0 && BtmEdgePoint[5].y!=0 ){
									 P1.x=0, P1.y=0, P2.x=0, P2.y=0, P3.x=0, P3.y=0, P4.x=0, P4.y=0;
									 LogUnit.SetLog(L"CellID:%d, CamID:%d ==>Straight3_Insp_Start",CellId,CamId);     

									 // Trench 내측부 Circle형태 ROI영역 설정 (NarrowTrench)
									 if((GrindRectSpec[8].DvX!=0.0f && GrindRectSpec[8].DvY!=0.0f) ||(IsNarrowTrench)){
										 if(GrindMarkRect[9].left!=0 && GrindMarkRect[9].top!=0 && GrindMarkRect[9].right!=0 && GrindMarkRect[9].bottom!=0){// LTPS
											 GrindMarkRectCenter[9].y = GrindMarkRect[9].top  + (GrindMarkRect[9].bottom - GrindMarkRect[9].top )/2; 
											 if(BtmEdgePoint[4].y>GrindMarkRectCenter[9].y){
												 P1.x = (BtmEdgePoint[4].x);                             P1.y =(BtmEdgePoint[4].y-(BtmEdgePoint[4].y-GrindMarkRectCenter[9].y)); 
												 P2.x = (P1.x+(BtmEdgePoint[5].x - BtmEdgePoint[4].x )); P2.y =(P1.y);
												 P3.x = (BtmEdgePoint[4].x);                             P3.y =(BtmEdgePoint[4].y+30); 
												 P4.x = (P2.x                                         ); P4.y =(P3.y);
											 }
										 }
										 else { // EnCap
											 P1.x = (BtmEdgePoint[4].x);                             P1.y =(BtmEdgePoint[4].y-(int)(CELL_D/2)); 
											 P2.x = (P1.x+(BtmEdgePoint[5].x - BtmEdgePoint[4].x )); P2.y =(P1.y);
											 P3.x = (BtmEdgePoint[4].x);                             P3.y =(BtmEdgePoint[4].y+30); 
											 P4.x = (P2.x                                         ); P4.y =(P3.y);
										 }
									 }
									 else { // Trench 내측부 직선형태 ROI영역 설정 
										 P1.x = (BtmEdgePoint[4].x); P1.y =(BtmEdgePoint[4].y-30); P2.x = (P1.x+(BtmEdgePoint[5].x - BtmEdgePoint[4].x )); P2.y = (P1.y);
										 P3.x = (BtmEdgePoint[4].x); P3.y =(BtmEdgePoint[4].y+30); P4.x = (P2.x                                         ); P4.y = (P3.y);
									 }

									 // Median Filter 적용 
									 if(P1.x<=0    || P1.y<=0    || (P2.x - P1.x)<=0    || (P3.y - P1.y)<=0   ) return false;
									 if(P1.x>=ImgW || P1.y>=ImgH || (P2.x - P1.x)>=ImgW || (P3.y - P1.y)>=ImgH) return false;
									 FilterROI.SetSize(int(P2.x - P1.x),int(P3.y - P1.y) )                      ;
									 FilterROI.Attach(&RotateBinaryImg)                                    ;
									 FilterROI.SetPlacement(P1.x, P1.y, int(P2.x - P1.x), int(P3.y - P1.y));
									 LogUnit.SetLog(L"세번째 직선 ==>Px :%d, Py :%d, Width:%d, Height:%d ==>Median Filter",P1.x, P1.y, int(P2.x - P1.x), int(P3.y - P1.y));     
									 LogUnit.SetLog(L"세번째 직선 ==>P1x:%d, P1y:%d, P2x:%d, P2y:%d, P3x:%d, P3y:%d, P4x:%d, P4y:%d,",P1.x,P1.y,P2.x,P2.y,P3.x,P3.y,P4.x,P4.y);     
									 EasyImage::Median(&FilterROI, &FilterROI)                             ;
									 // 										 RotateBinaryImg.Save("D:\\ROTATE_IMG\\Polygon직선영역_필터.bmp")      ;


									 Polygon->GImage          = &RotateBinaryImg      ;
									 Polygon->PoPa.FMaxWidth  =(int)(P2.x - P1.x)+100 ;
									 Polygon->PoPa.FMaxHeight =(int)(P3.y - P1.y)+100 ;
									 Polygon->PoPa.FMinWidth  =(int)(P2.x - P1.x)-100 ; 
									 Polygon->PoPa.IsSeparate =true                   ;
									 Polygon->PoPa.IsInToOut  =true                   ;
									 Polygon->PoPa.HiThHold   = BtmEdgeThresHold      ;
									 Polygon->PoPa.LoThHold   = 0                     ;

									 if(P1.x!=0 && P1.y!=0 && P2.x!=0 && P2.y!=0 && P3.x!=0 && P3.y!=0 && P4.x!=0 && P4.y!=0){
										 Polygon->OnExecute(P1,P2,P3,P4);
									 }

									 // Polygon Algorithm InEdgeData/OutEdgeData Separate 및 데이터 추출 
									 if(Polygon->BlobCount==1){
										 PolygonMarginCnt =10;
										 if(IsNarrowTrench){ // Narrow Trench(비선형 곡선 형태)
											 if(Polygon->Blob[0].InCnt>(PolygonMarginCnt*2)){
												 Btm3InEdgeCount=0;
												 Btm3InEdgeCount = (Polygon->Blob[0].InCnt - (PolygonMarginCnt*2));
												 if(Btm3InEdgeCount>0){
													 if(Btm3InPoint!=NULL) delete[] Btm3InPoint;
													 Btm3InPoint = new TFPoint[Btm3InEdgeCount];

													 PixelCnt=0;
													 for(int k=0; k<Polygon->Blob[0].InCnt; k++){
														 if(k<PolygonMarginCnt || k>=(Polygon->Blob[0].InCnt-PolygonMarginCnt)) continue;
														 Btm3InPoint[PixelCnt].x    = Polygon->Blob[0].InPoint[k].x ;
														 Btm3InPoint[PixelCnt].y    = Polygon->Blob[0].InPoint[k].y ;
														 PixelCnt++;
													 }
												 }
											 }

											 if(Polygon->Blob[0].OutCnt>(PolygonMarginCnt*2)){
												 Btm3OutEdgeCount=0;
												 Btm3OutEdgeCount = (Polygon->Blob[0].OutCnt - (PolygonMarginCnt*2));
												 if(Btm3OutEdgeCount>0){
													 if(Btm3OutPoint!=NULL) delete[] Btm3OutPoint;
													 Btm3OutPoint = new TFPoint[Btm3OutEdgeCount];

													 PixelCnt=0;
													 for(int k=0; k<Polygon->Blob[0].OutCnt; k++){
														 if(k<PolygonMarginCnt || k>=(Polygon->Blob[0].OutCnt-PolygonMarginCnt)) continue;
														 Btm3OutPoint[PixelCnt].x   = Polygon->Blob[0].OutPoint[k].x ;
														 Btm3OutPoint[PixelCnt].y   = Polygon->Blob[0].OutPoint[k].y ;
														 PixelCnt++;
													 }
												 }
											 }
										 }
										 else              { // Normal Trench(직선 형태)
											 if(Polygon->Blob[0].InCnt>(PolygonMarginCnt*2)){
												 OrgBtm3InEdgeCount=0;
												 OrgBtm3InEdgeCount = (Polygon->Blob[0].InCnt - (PolygonMarginCnt*2));
												 if(OrgBtm3InEdgeCount>0){
													 if(OrgBtm3InPoint!=NULL) delete[] OrgBtm3InPoint;
													 OrgBtm3InPoint = new TFPoint[OrgBtm3InEdgeCount];

													 PixelCnt=0;
													 for(int k=0; k<Polygon->Blob[0].InCnt; k++){
														 if(k<PolygonMarginCnt || k>=(Polygon->Blob[0].InCnt-PolygonMarginCnt)) continue;
														 OrgBtm3InPoint[PixelCnt].x   = Polygon->Blob[0].InPoint[k].x ;
														 OrgBtm3InPoint[PixelCnt].y   = Polygon->Blob[0].InPoint[k].y ;
														 PixelCnt++;
													 }
												 }
												 // Org Data 
												 BtmInLine[2].FP0 = OrgBtm3InPoint[0];
												 BtmInLine[2].FP1 = OrgBtm3InPoint[PixelCnt-1];
											 }

											 if(Polygon->Blob[0].OutCnt>(PolygonMarginCnt*2)){
												 OrgBtm3OutEdgeCount=0;
												 OrgBtm3OutEdgeCount = (Polygon->Blob[0].OutCnt - (PolygonMarginCnt*2));
												 if(OrgBtm3OutEdgeCount>0){
													 if(OrgBtm3OutPoint!=NULL) delete[] OrgBtm3OutPoint;
													 OrgBtm3OutPoint = new TFPoint[OrgBtm3OutEdgeCount];

													 PixelCnt=0;
													 for(int k=0; k<Polygon->Blob[0].OutCnt; k++){
														 if(k<PolygonMarginCnt || k>=(Polygon->Blob[0].OutCnt-PolygonMarginCnt)) continue;
														 OrgBtm3OutPoint[PixelCnt].x  = Polygon->Blob[0].OutPoint[k].x ;
														 OrgBtm3OutPoint[PixelCnt].y  = Polygon->Blob[0].OutPoint[k].y ;
														 PixelCnt++;
													 }
												 }
												 // Org Data 
												 BtmOutLine[2].FP0 = OrgBtm3OutPoint[0];
												 BtmOutLine[2].FP1 = OrgBtm3OutPoint[PixelCnt-1];
											 }
										 }
										 // Polygon Data Clear
										 // 											 Polygon->ClearData();
									 }

									 // 연마량 측정 및 가공량 측정 (비선형)
									 if(IsNarrowTrench){ // Trench 내측부 비선형 곡선일 경우 
										 if(IsMarkBtm){
											 if(Btm3InEdgeCount>10 && Btm3OutEdgeCount>10){
												 // GrindMark[8] 가공량,연마량 측정 
												 ////////////////////////////////////////////////////////////////////////////////////////////////////
												 if(GrindMarkPoint[8].x!=0.0f && GrindMarkPoint[8].y!=0.0f) { 
													 // GrindMark기준 OutData 최단거리 Count정보 Calc 
													 GrindMeaDis =0.0f, MinDis =10000.0f;  GrindMarkOutCnt=0;
													 for(int k=0; k<Btm3OutEdgeCount; k++){
														 if(Btm3OutPoint  [k].x ==0.0f || Btm3OutPoint  [k].y ==0.0f) continue;
														 if(GrindMarkPoint[8].x ==0.0f || GrindMarkPoint[8].y ==0.0f) continue;

														 GrindMeaDis = Math.GetLength(GrindMarkPoint[8], Btm3OutPoint[k]);
														 if(GrindMeaDis<MinDis){
															 MinDis = GrindMeaDis;
															 GrindMarkOutCnt = k;
														 }
													 }

													 // GrindMark기준 InData 최단거리 Count정보 Calc 
													 if(GrindMarkOutCnt!=0){
														 GrindMeaDis =0.0f, MinDis =10000.0f; GrindMarkInCnt=0;
														 for(int k=0; k<Btm3InEdgeCount; k++){
															 if(Btm3InPoint[k].x   ==0.0f             || Btm3InPoint[k].y                ==0.0f) continue;
															 if(Btm3OutPoint[GrindMarkOutCnt].x==0.0f || Btm3OutPoint[GrindMarkOutCnt].y ==0.0f) continue;

															 GrindMeaDis = Math.GetLength(Btm3OutPoint[GrindMarkOutCnt], Btm3InPoint[k]);
															 if(GrindMeaDis<MinDis){
																 MinDis = GrindMeaDis;
																 GrindMarkInCnt = k;
															 }
														 }
													 }

													 // GrindMark기준 수직 포인트 주변값 Avg산출한다 ==>가공량 측정(OutData기준)
													 if(GrindMarkOutCnt!=0 && GrindMarkOutCnt>5){
														 CircleCount=0,TotalCirDis=0.0f,GrindMeaDis=0.0f;
														 for(int k=GrindMarkOutCnt-5; k<GrindMarkOutCnt+5; k++){
															 if(Btm3OutPoint[k].x==0.0f || Btm3OutPoint[k].y==0.0f) continue;
															 if(k>=Btm3OutEdgeCount                               ) continue;

															 GrindMeaDis = Math.GetLength(GrindMarkPoint[8], Btm3OutPoint[k]);
															 TotalCirDis+= GrindMeaDis;
															 CircleCount++;
														 }
														 if(TotalCirDis!=0.0f && CircleCount!=0){
															 BtmGrindMeasure4 = TotalCirDis/CircleCount;
															 BtmGrindMeasure4 = BtmGrindMeasure4+0.5; //SubPixel 
														 }
													 }

													 // GrindMark기준 수직 포인트 주변값 Avg산출한다 ==>연마량 측정(OutData,InData기준)
													 if((GrindMarkOutCnt!=0 && GrindMarkOutCnt>5) && (GrindMarkInCnt!=0 && GrindMarkInCnt>5)){
														 CircleCount=0,TotalCirDis=0.0f,GrindWidthDis=0.0f;
														 for(int k=-5; k<5; k++){
															 if(Btm3OutPoint[GrindMarkOutCnt+k].x==0.0f && Btm3OutPoint[GrindMarkOutCnt+k].y==0.0f) continue;
															 if(Btm3InPoint [GrindMarkInCnt +k].x==0.0f && Btm3InPoint [GrindMarkInCnt +k].y==0.0f) continue;
															 if((GrindMarkOutCnt+k)>=Btm3OutEdgeCount                                             ) continue;
															 if((GrindMarkInCnt +k)>=Btm3InEdgeCount                                              ) continue;

															 GrindWidthDis = Math.GetLength(Btm3InPoint[GrindMarkInCnt+k], Btm3OutPoint[GrindMarkOutCnt+k]);
															 TotalCirDis+=   GrindWidthDis;
															 CircleCount++;
														 }
														 if(TotalCirDis!=0.0f && CircleCount!=0){
															 BtmGrindWidth4 = TotalCirDis/CircleCount;
															 BtmGrindWidth4 = BtmGrindWidth4+0.5; //SubPixel
														 }
													 }
												 }
												 else if(GrindMarkRect[8].left!=0 && GrindMarkRect[8].top!=0 && GrindMarkRect[8].right!=0 && GrindMarkRect[8].bottom!=0) {  //GrindMark 못 찾았을경우
													 // OutData기준 최소값 데이터 Count산출 
													 GrindMeaDis =0.0f, MinDis =10000.0f; GrindMarkOutCnt=0;
													 for(int k=0; k<Btm3OutEdgeCount; k++){
														 if(Btm3OutPoint[k].x==0.0f || Btm3OutPoint[k].y==0.0f) continue;

														 if(k==0 && GrindRectSpec[8].DvX!=0.0f && GrindRectSpec[8].DvY!=0.0f){ //진성마크 
															 GrindMarkRectCenter[8].x = GrindMarkRect[8].left + (GrindMarkRect[8].right  - GrindMarkRect[8].left)/2; 
															 GrindMarkRectCenter[8].y = GrindMarkRect[8].top  + (GrindMarkRect[8].bottom - GrindMarkRect[8].top )/2; 
														 }

														 GrindMeaDis = Math.GetLength(GrindMarkRectCenter[8], Btm3OutPoint[k]);
														 if(GrindMeaDis<MinDis){
															 MinDis = GrindMeaDis;
															 GrindMarkOutCnt = k;
														 }
													 }

													 // 최단거리OUtCount기준 InData 최단거리 Count정보 Calc 
													 if(GrindMarkOutCnt!=0){
														 GrindMeaDis =0.0f, MinDis =10000.0f; GrindMarkInCnt=0;
														 for(int k=0; k<Btm3InEdgeCount; k++){
															 if(Btm3InPoint[k].x              ==0.0f  || Btm3InPoint[k].y                ==0.0f) continue;
															 if(Btm3OutPoint[GrindMarkOutCnt].x==0.0f || Btm3OutPoint[GrindMarkOutCnt].y ==0.0f) continue;

															 GrindMeaDis = Math.GetLength(Btm3OutPoint[GrindMarkOutCnt], Btm3InPoint[k]);
															 if(GrindMeaDis<MinDis){
																 MinDis = GrindMeaDis;
																 GrindMarkInCnt = k;
															 }
														 }
													 }

													 // GrindMark기준 수직 포인트 주변값 Avg산출한다 ==>연마량 측정(OutData,InData기준)
													 if((GrindMarkOutCnt!=0 && GrindMarkOutCnt>5) && (GrindMarkInCnt!=0 && GrindMarkInCnt>5)){
														 CircleCount=0,TotalCirDis=0.0f,GrindWidthDis=0.0f;
														 for(int k=-5; k<5; k++){
															 if(Btm3OutPoint[GrindMarkOutCnt+k].x==0.0f && Btm3OutPoint[GrindMarkOutCnt+k].y==0.0f) continue;
															 if(Btm3InPoint [GrindMarkInCnt +k].x==0.0f && Btm3InPoint [GrindMarkInCnt +k].y==0.0f) continue;
															 if((GrindMarkOutCnt+k)>=Btm3OutEdgeCount                                             ) continue;
															 if((GrindMarkInCnt +k)>=Btm3InEdgeCount                                              ) continue;

															 GrindWidthDis = Math.GetLength(Btm3InPoint[GrindMarkInCnt+k], Btm3OutPoint[GrindMarkOutCnt+k]);
															 TotalCirDis+=   GrindWidthDis;
															 CircleCount++;
														 }
														 if(TotalCirDis!=0.0f && CircleCount!=0){
															 BtmGrindWidth4 = TotalCirDis/CircleCount;
															 BtmGrindWidth4 = BtmGrindWidth4+0.5; //SubPixel
														 }
													 }
												 }

												 // GrindMark[9] 가공량,연마량 측정 
												 ////////////////////////////////////////////////////////////////////////////////////////////////////
												 if(GrindMarkPoint[9].x!=0.0f && GrindMarkPoint[9].y!=0.0f) { 
													 // GrindMark기준 OutData 최단거리 Count정보 Calc 
													 GrindMeaDis =0.0f, MinDis =10000.0f;  GrindMarkOutCnt=0;
													 for(int k=0; k<Btm3OutEdgeCount; k++){
														 if(Btm3OutPoint[k].x   ==0.0f || Btm3OutPoint[k].y   ==0.0f) continue;
														 if(GrindMarkPoint[9].x ==0.0f || GrindMarkPoint[9].y ==0.0f) continue;

														 GrindMeaDis = Math.GetLength(GrindMarkPoint[9], Btm3OutPoint[k]);
														 if(GrindMeaDis<MinDis){
															 MinDis = GrindMeaDis;
															 GrindMarkOutCnt = k;
														 }
													 }

													 // GrindMark기준 InData 최단거리 Count정보 Calc 
													 if(GrindMarkOutCnt!=0){
														 GrindMeaDis =0.0f, MinDis =10000.0f; GrindMarkInCnt=0;
														 for(int k=0; k<Btm3InEdgeCount; k++){
															 if(Btm3InPoint[k].x               ==0.0f || Btm3InPoint[k].y                ==0.0f) continue;
															 if(Btm3OutPoint[GrindMarkOutCnt].x==0.0f || Btm3OutPoint[GrindMarkOutCnt].y ==0.0f) continue;

															 GrindMeaDis = Math.GetLength(Btm3OutPoint[GrindMarkOutCnt], Btm3InPoint[k]);
															 if(GrindMeaDis<MinDis){
																 MinDis = GrindMeaDis;
																 GrindMarkInCnt = k;
															 }
														 }
													 }

													 // GrindMark기준 수직 포인트 주변값 Avg산출한다 ==>가공량 측정(OutData기준)
													 if(GrindMarkOutCnt!=0 && GrindMarkOutCnt>5){
														 CircleCount=0,TotalCirDis=0.0f,GrindMeaDis=0.0f;
														 for(int k=GrindMarkOutCnt-5; k<GrindMarkOutCnt+5; k++){
															 if(Btm3OutPoint[k].x==0.0f || Btm3OutPoint[k].y==0.0f) continue;
															 if(k>=Btm3OutEdgeCount                               ) continue;

															 GrindMeaDis = Math.GetLength(GrindMarkPoint[9], Btm3OutPoint[k]);
															 TotalCirDis+= GrindMeaDis;
															 CircleCount++;
														 }
														 if(TotalCirDis!=0.0f && CircleCount!=0){
															 BtmGrindMeasure5 = TotalCirDis/CircleCount;
															 BtmGrindMeasure5 = BtmGrindMeasure5+0.5; //SubPixel 
														 }
													 }

													 // GrindMark기준 수직 포인트 주변값 Avg산출한다 ==>연마량 측정(OutData,InData기준)
													 if((GrindMarkOutCnt!=0 && GrindMarkOutCnt>5) && (GrindMarkInCnt!=0 && GrindMarkInCnt>5)){
														 CircleCount=0,TotalCirDis=0.0f,GrindWidthDis=0.0f;
														 for(int k=-5; k<5; k++){
															 if(Btm3OutPoint[GrindMarkOutCnt+k].x==0.0f && Btm3OutPoint[GrindMarkOutCnt+k].y==0.0f) continue;
															 if(Btm3InPoint [GrindMarkInCnt +k].x==0.0f && Btm3InPoint [GrindMarkInCnt +k].y==0.0f) continue;
															 if((GrindMarkOutCnt+k)>=Btm3OutEdgeCount                                             ) continue;
															 if((GrindMarkInCnt +k)>=Btm3InEdgeCount                                              ) continue;

															 GrindWidthDis = Math.GetLength(Btm3InPoint[GrindMarkInCnt+k], Btm3OutPoint[GrindMarkOutCnt+k]);
															 TotalCirDis+=   GrindWidthDis;
															 CircleCount++;
														 }
														 if(TotalCirDis!=0.0f && CircleCount!=0){
															 BtmGrindWidth5 = TotalCirDis/CircleCount;
															 BtmGrindWidth5 = BtmGrindWidth5+0.5; //SubPixel
														 }
													 }
												 }
												 else if(GrindMarkRect[9].left!=0 && GrindMarkRect[9].top!=0 && GrindMarkRect[9].right!=0 && GrindMarkRect[9].bottom!=0) { //GrindMark 못 찾았을경우
													 // OutData기준 최소값 데이터 Count산출 
													 GrindMeaDis =0.0f, MinDis =10000.0f; GrindMarkOutCnt=0;
													 for(int k=0; k<Btm3OutEdgeCount; k++){
														 if(Btm3OutPoint[k].x==0.0f || Btm3OutPoint[k].y==0.0f) continue;

														 if(k==0){ // 순서상 9번이 없는경우 
															 GrindMarkRectCenter[9].x = GrindMarkRect[9].left + (GrindMarkRect[9].right  - GrindMarkRect[9].left)/2; 
															 GrindMarkRectCenter[9].y = GrindMarkRect[9].top  + (GrindMarkRect[9].bottom - GrindMarkRect[9].top )/2; 
														 }

														 GrindMeaDis = Math.GetLength(GrindMarkRectCenter[9], Btm3OutPoint[k]);
														 if(GrindMeaDis<MinDis){
															 MinDis = GrindMeaDis;
															 GrindMarkOutCnt = k;
														 }
													 }

													 // 최단거리OUtCount기준 InData 최단거리 Count정보 Calc 
													 if(GrindMarkOutCnt!=0){
														 GrindMeaDis =0.0f, MinDis =10000.0f; GrindMarkInCnt=0;
														 for(int k=0; k<Btm3InEdgeCount; k++){
															 if(Btm3InPoint[k].x               ==0.0f || Btm3InPoint[k].y                ==0.0f) continue;
															 if(Btm3OutPoint[GrindMarkOutCnt].x==0.0f || Btm3OutPoint[GrindMarkOutCnt].y ==0.0f) continue;

															 GrindMeaDis = Math.GetLength(Btm3OutPoint[GrindMarkOutCnt], Btm3InPoint[k]);
															 if(GrindMeaDis<MinDis){
																 MinDis = GrindMeaDis;
																 GrindMarkInCnt = k;
															 }
														 }
													 }

													 // GrindMark기준 수직 포인트 주변값 Avg산출한다 ==>연마량 측정(OutData,InData기준)
													 if((GrindMarkOutCnt!=0 && GrindMarkOutCnt>5) && (GrindMarkInCnt!=0 && GrindMarkInCnt>5)){
														 CircleCount=0,TotalCirDis=0.0f,GrindWidthDis=0.0f;
														 for(int k=-5; k<5; k++){
															 if(Btm3OutPoint[GrindMarkOutCnt+k].x==0.0f && Btm3OutPoint[GrindMarkOutCnt+k].y==0.0f) continue;
															 if(Btm3InPoint [GrindMarkInCnt +k].x==0.0f && Btm3InPoint [GrindMarkInCnt +k].y==0.0f) continue;
															 if((GrindMarkOutCnt+k)>=Btm3OutEdgeCount                                             ) continue;
															 if((GrindMarkInCnt +k)>=Btm3InEdgeCount                                              ) continue;

															 GrindWidthDis = Math.GetLength(Btm3InPoint[GrindMarkInCnt+k], Btm3OutPoint[GrindMarkOutCnt+k]);
															 TotalCirDis+=   GrindWidthDis;
															 CircleCount++;
														 }
														 if(TotalCirDis!=0.0f && CircleCount!=0){
															 BtmGrindWidth5 = TotalCirDis/CircleCount;
															 BtmGrindWidth5 = BtmGrindWidth5+0.5; //SubPixel
														 }
													 }
												 }

												 // GrindMark[10] 가공량,연마량 측정 
												 ////////////////////////////////////////////////////////////////////////////////////////////////////
												 if(GrindMarkPoint[10].x!=0.0f && GrindMarkPoint[10].y!=0.0f) { 
													 // GrindMark기준 OutData 최단거리 Count정보 Calc 
													 GrindMeaDis =0.0f, MinDis =10000.0f;  GrindMarkOutCnt=0;
													 for(int k=0; k<Btm3OutEdgeCount; k++){
														 if(Btm3OutPoint[k].x    ==0.0f || Btm3OutPoint[k].y    ==0.0f) continue;
														 if(GrindMarkPoint[10].x ==0.0f || GrindMarkPoint[10].y ==0.0f) continue;

														 GrindMeaDis = Math.GetLength(GrindMarkPoint[10], Btm3OutPoint[k]);
														 if(GrindMeaDis<MinDis){
															 MinDis = GrindMeaDis;
															 GrindMarkOutCnt = k;
														 }
													 }

													 // GrindMark기준 InData 최단거리 Count정보 Calc 
													 if(GrindMarkOutCnt!=0){
														 GrindMeaDis =0.0f, MinDis =10000.0f; GrindMarkInCnt=0;
														 for(int k=0; k<Btm3InEdgeCount; k++){
															 if(Btm3InPoint [k].x              ==0.0f || Btm3InPoint[k].y                ==0.0f) continue;
															 if(Btm3OutPoint[GrindMarkOutCnt].x==0.0f || Btm3OutPoint[GrindMarkOutCnt].y ==0.0f) continue;

															 GrindMeaDis = Math.GetLength(Btm3OutPoint[GrindMarkOutCnt], Btm3InPoint[k]);
															 if(GrindMeaDis<MinDis){
																 MinDis = GrindMeaDis;
																 GrindMarkInCnt = k;
															 }
														 }
													 }

													 // GrindMark기준 수직 포인트 주변값 Avg산출한다 ==>가공량 측정(OutData기준)
													 if(GrindMarkOutCnt!=0 && GrindMarkOutCnt>5){
														 CircleCount=0,TotalCirDis=0.0f,GrindMeaDis=0.0f;
														 for(int k=GrindMarkOutCnt-5; k<GrindMarkOutCnt+5; k++){
															 if(Btm3OutPoint[k].x==0.0f || Btm3OutPoint[k].y==0.0f) continue;
															 if(k>=Btm3OutEdgeCount                               ) continue;

															 GrindMeaDis = Math.GetLength(GrindMarkPoint[10], Btm3OutPoint[k]);
															 TotalCirDis+= GrindMeaDis;
															 CircleCount++;
														 }
														 if(TotalCirDis!=0.0f && CircleCount!=0){
															 BtmGrindMeasure6 = TotalCirDis/CircleCount;
															 BtmGrindMeasure6 = BtmGrindMeasure6+0.5; //SubPixel 
														 }
													 }

													 // GrindMark기준 수직 포인트 주변값 Avg산출한다 ==>연마량 측정(OutData,InData기준)
													 if((GrindMarkOutCnt!=0 && GrindMarkOutCnt>5) && (GrindMarkInCnt!=0 && GrindMarkInCnt>5)){
														 CircleCount=0,TotalCirDis=0.0f,GrindWidthDis=0.0f;
														 for(int k=-5; k<5; k++){
															 if(Btm3OutPoint[GrindMarkOutCnt+k].x==0.0f && Btm3OutPoint[GrindMarkOutCnt+k].y==0.0f) continue;
															 if(Btm3InPoint [GrindMarkInCnt +k].x==0.0f && Btm3InPoint [GrindMarkInCnt +k].y==0.0f) continue;
															 if((GrindMarkOutCnt+k)>=Btm3OutEdgeCount                                             ) continue;
															 if((GrindMarkInCnt +k)>=Btm3InEdgeCount                                              ) continue;

															 GrindWidthDis = Math.GetLength(Btm3InPoint[GrindMarkInCnt+k], Btm3OutPoint[GrindMarkOutCnt+k]);
															 TotalCirDis+=   GrindWidthDis;
															 CircleCount++;
														 }
														 if(TotalCirDis!=0.0f && CircleCount!=0){
															 BtmGrindWidth6 = TotalCirDis/CircleCount;
															 BtmGrindWidth6 = BtmGrindWidth6+0.5; //SubPixel
														 }
													 }
												 }
												 else if(GrindMarkRect[10].left!=0 && GrindMarkRect[10].top!=0 && GrindMarkRect[10].right!=0 && GrindMarkRect[10].bottom!=0) {  //GrindMark 못 찾았을경우
													 // OutData기준 최소값 데이터 Count산출 
													 GrindMeaDis =0.0f, MinDis =10000.0f; GrindMarkOutCnt=0;
													 for(int k=0; k<Btm3OutEdgeCount; k++){
														 if(Btm3OutPoint[k].x==0.0f || Btm3OutPoint[k].y==0.0f) continue;

														 if(k==0 && GrindRectSpec[8].DvX!=0.0f && GrindRectSpec[8].DvY!=0.0f){ //진성마크 
															 GrindMarkRectCenter[10].x = GrindMarkRect[10].left + (GrindMarkRect[10].right  - GrindMarkRect[10].left)/2; 
															 GrindMarkRectCenter[10].y = GrindMarkRect[10].top  + (GrindMarkRect[10].bottom - GrindMarkRect[10].top )/2; 
														 }

														 GrindMeaDis = Math.GetLength(GrindMarkRectCenter[10], Btm3OutPoint[k]);
														 if(GrindMeaDis<MinDis){
															 MinDis = GrindMeaDis;
															 GrindMarkOutCnt = k;
														 }
													 }

													 // 최단거리OUtCount기준 InData 최단거리 Count정보 Calc 
													 if(GrindMarkOutCnt!=0){
														 GrindMeaDis =0.0f, MinDis =10000.0f; GrindMarkInCnt=0;
														 for(int k=0; k<Btm3InEdgeCount; k++){
															 if(Btm3InPoint[k].x              ==0.0f  || Btm3InPoint[k].y                ==0.0f) continue;
															 if(Btm3OutPoint[GrindMarkOutCnt].x==0.0f || Btm3OutPoint[GrindMarkOutCnt].y ==0.0f) continue;

															 GrindMeaDis = Math.GetLength(Btm3OutPoint[GrindMarkOutCnt], Btm3InPoint[k]);
															 if(GrindMeaDis<MinDis){
																 MinDis = GrindMeaDis;
																 GrindMarkInCnt = k;
															 }
														 }
													 }

													 // GrindMark기준 수직 포인트 주변값 Avg산출한다 ==>연마량 측정(OutData,InData기준)
													 if((GrindMarkOutCnt!=0 && GrindMarkOutCnt>5) && (GrindMarkInCnt!=0 && GrindMarkInCnt>5)){
														 CircleCount=0,TotalCirDis=0.0f,GrindWidthDis=0.0f;
														 for(int k=-5; k<5; k++){
															 if(Btm3OutPoint[GrindMarkOutCnt+k].x==0.0f && Btm3OutPoint[GrindMarkOutCnt+k].y==0.0f) continue;
															 if(Btm3InPoint [GrindMarkInCnt +k].x==0.0f && Btm3InPoint [GrindMarkInCnt +k].y==0.0f) continue;
															 if((GrindMarkOutCnt+k)>=Btm3OutEdgeCount                                             ) continue;
															 if((GrindMarkInCnt +k)>=Btm3InEdgeCount                                              ) continue;

															 GrindWidthDis = Math.GetLength(Btm3InPoint[GrindMarkInCnt+k], Btm3OutPoint[GrindMarkOutCnt+k]);
															 TotalCirDis+=   GrindWidthDis;
															 CircleCount++;
														 }
														 if(TotalCirDis!=0.0f && CircleCount!=0){
															 BtmGrindWidth6 = TotalCirDis/CircleCount;
															 BtmGrindWidth6 = BtmGrindWidth6+0.5; //SubPixel
														 }
													 }
												 }
											 }
										 }
										 else { //  Narrow Trench ENCAP 연마량 데이터만 계측함
											 if(Btm3InEdgeCount!=0 && Btm3OutEdgeCount!=0){
												 GrindMeaDis =0.0f, MinDis =10000.0f; GrindMarkOutCnt=0;
												 GrindMarkOutCnt = (int)(Btm3OutEdgeCount/2);
												 // 최단거리OUtCount기준 InData 최단거리 Count정보 Calc 
												 if(GrindMarkOutCnt!=0){
													 GrindMeaDis =0.0f, MinDis =10000.0f; GrindMarkInCnt=0;
													 for(int k=0; k<Btm3InEdgeCount; k++){
														 if(Btm3InPoint [k].x              ==0.0f || Btm3InPoint [k].y               ==0.0f) continue;
														 if(Btm3OutPoint[GrindMarkOutCnt].x==0.0f || Btm3OutPoint[GrindMarkOutCnt].y ==0.0f) continue;

														 GrindMeaDis = Math.GetLength(Btm3OutPoint[GrindMarkOutCnt], Btm3InPoint[k]);
														 if(GrindMeaDis<MinDis){
															 MinDis = GrindMeaDis;
															 GrindMarkInCnt = k;
														 }
													 }
												 }

												 // GrindMark기준 수직 포인트 주변값 Avg산출한다 ==>연마량 측정(OutData,InData기준)
												 if((GrindMarkOutCnt!=0 && GrindMarkOutCnt>5) && (GrindMarkInCnt!=0 && GrindMarkInCnt>5)){
													 CircleCount=0,TotalCirDis=0.0f,GrindWidthDis=0.0f;
													 for(int k=-5; k<5; k++){
														 if(Btm3InPoint [GrindMarkOutCnt+k].x==0.0f && Btm3InPoint [GrindMarkOutCnt+k].y==0.0f) continue;
														 if(Btm3OutPoint[GrindMarkInCnt +k].x==0.0f && Btm3OutPoint[GrindMarkInCnt +k].y==0.0f) continue;
														 if((GrindMarkOutCnt+k)>=Btm3OutEdgeCount                                             ) continue;
														 if((GrindMarkInCnt +k)>=Btm3InEdgeCount                                              ) continue;

														 GrindWidthDis = Math.GetLength(Btm3InPoint[GrindMarkInCnt+k], Btm3OutPoint[GrindMarkOutCnt+k]);
														 TotalCirDis+=   GrindWidthDis;
														 CircleCount++;
													 }
													 if(TotalCirDis!=0.0f && CircleCount!=0){
														 BtmGrindWidth5 = TotalCirDis/CircleCount;
														 BtmGrindWidth5 = BtmGrindWidth4+0.5; //SubPixel
													 }
												 }
											 }
										 }
										 ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
										 // FAVION Circle Fitting 결과물(Btm3CircleFitting)
										 SampleSize   = Btm3OutEdgeCount*0.75; //0.5~0.8이하로 입력할것
										 DistDevRatio = 0.15                 ; //0.1~0.25 이하로 입력할것
										 CircleFit->OnRansac(Btm3OutPoint,Btm3OutEdgeCount,SampleSize,DistDevRatio,&CircleFitBtm3Center,&CirFitDiameterBtm3);

										 // Polygon 박리 검사 시퀀스 
										 if(!IsMarkBtm && BrokenThresHold!=0 && IsNarrowTrench){
											 RotateBrokenImg.SetSize(RotateImg.GetWidth(), RotateImg.GetHeight());
											 EasyImage::Oper(EArithmeticLogicOperation_Copy,&RotateImg,&RotateBrokenImg);
											 EasyImage::Threshold(&RotateImg,&RotateBrokenImg, BrokenThresHold);
											 Edge->GImage = &RotateBrokenImg;
											 Edge->SetEdgeType(0);

											 int DvCnt =0, DataCount=0;
											 double deg =0.0f; 
											 TFPoint Target(0.0f, 0.0f);

											 if(GrindMarkInCnt>GrindMarkOutCnt){
												 DvCnt = GrindMarkInCnt - GrindMarkOutCnt;
												 for(int k=0; k<Btm3OutEdgeCount; k++){
													 deg =0.0f, Target.x =0.0f, Target.y =0.0f;
													 if(((k+DvCnt)<Btm3InEdgeCount) && Btm3InPoint[k+DvCnt].x>0  && Btm3InPoint[k+DvCnt].y>0){
														 deg = Math.GetDegree(Btm3OutPoint[k],Btm3InPoint[k+DvCnt]);

														 Target  = Math.OnFindPerpendicularPointXY(Btm3OutPoint[k],-dEdgeToTrapLineDis,-dEdgeToTrapLineDis,deg);
														 Edge->OnExecute(Btm3OutPoint[k],Target); // 연마외곽라인에서 Target까지 White Point Search 
														 if(Edge->GetResultEdgePointCount()>0){
															 Btm3CircleData[DataCount].Dis =0.0f;
															 Btm3CircleData[DataCount].Dv  =0.0f;
															 Btm3CircleData[DataCount].P   = Edge->GetResultEdgePoint(0);
															 Btm3CircleData[DataCount].P.y = Btm3CircleData[DataCount].P.y - ImageHeight; // Frame기준 단위좌표로 변경함  
															 DataCount++;
														 }
													 }
												 }
												 Btm3CirInCrackCount = DataCount;
											 }
											 else if(GrindMarkInCnt<GrindMarkOutCnt)   {
												 DvCnt = GrindMarkOutCnt - GrindMarkInCnt;
												 for(int k=DvCnt; k<Btm3OutEdgeCount; k++){
													 deg =0.0f, Target.x =0.0f, Target.y =0.0f;
													 if(((k-DvCnt)<Btm3InEdgeCount) && Btm3InPoint[k-DvCnt].x>0  && Btm3InPoint[k-DvCnt].y>0 && k-DvCnt>=0){
														 deg = Math.GetDegree(Btm3OutPoint[k],Btm3InPoint[k-DvCnt]);

														 Target  = Math.OnFindPerpendicularPointXY(Btm3OutPoint[k],-dEdgeToTrapLineDis,-dEdgeToTrapLineDis,deg);
														 Edge->OnExecute(Btm3OutPoint[k],Target); // 연마외곽라인에서 Target까지 White Point Search 
														 if(Edge->GetResultEdgePointCount()>0){
															 Btm3CircleData[DataCount].Dis =0.0f;
															 Btm3CircleData[DataCount].Dv  =0.0f;
															 Btm3CircleData[DataCount].P   = Edge->GetResultEdgePoint(0);
															 Btm3CircleData[DataCount].P.y = Btm3CircleData[DataCount].P.y - ImageHeight; // Frame기준 단위좌표로 변경함  
															 DataCount++;
														 }
													 }
												 }
												 Btm3CirInCrackCount = DataCount;
											 }
										 }
									 }
									 else              { // Trench 내측부 직선일 경우 
										 if(IsMarkBtm){
											 if(OrgBtm3InEdgeCount>10 && OrgBtm3OutEdgeCount>10){
												 // 가공량,연마량 측정 전 데이터 존재시 가상GrindMark 생성한다 
												 if(GrindMarkPoint[9].x!=0.0f && GrindMarkPoint[9].y!=0.0f && GrindRectSpec[8].DvX==0.0f && GrindRectSpec[8].DvY==0.0f){ //가상마크
													 // GrindMark 8
													 GrindMarkPoint[8].x     = OrgBtm3InPoint[10].x ;
													 GrindMarkPoint[8].y     = GrindMarkPoint[9 ].y                     ;
													 GrindMarkRect [8].left  = GrindMarkPoint[8 ].x    - GrindMarkRange ;  
													 GrindMarkRect [8].top   = GrindMarkPoint[8 ].y    - GrindMarkRange ;  
													 GrindMarkRect [8].right = GrindMarkRect [8 ].left + GrindMarkLength;  
													 GrindMarkRect [8].bottom= GrindMarkRect [8 ].top  + GrindMarkLength;  

													 // GrindMark 9
													 GrindMarkPoint[10].x     = OrgBtm3InPoint[OrgBtm3InEdgeCount-10].x  ;
													 GrindMarkPoint[10].y     = GrindMarkPoint[9 ].y                     ;
													 GrindMarkRect [10].left  = GrindMarkPoint[10].x    - GrindMarkRange ;  
													 GrindMarkRect [10].top   = GrindMarkPoint[10].y    - GrindMarkRange ;  
													 GrindMarkRect [10].right = GrindMarkRect [10].left + GrindMarkLength;  
													 GrindMarkRect [10].bottom= GrindMarkRect [10].top  + GrindMarkLength;  
												 }

												 // GrindMark[8] 가공량,연마량 측정 
												 ////////////////////////////////////////////////////////////////////////////////////////////////////
												 if(GrindMarkPoint[8].x!=0.0f && GrindMarkPoint[8].y!=0.0f) { 
													 // GrindMark기준 OutData 최단거리 Count정보 Calc 
													 GrindMeaDis =0.0f, MinDis =10000.0f;  GrindMarkOutCnt=0;
													 for(int k=0; k<OrgBtm3OutEdgeCount; k++){
														 if(OrgBtm3OutPoint[k].x==0.0f || OrgBtm3OutPoint[k].y==0.0f) continue;
														 if(GrindMarkPoint[8].x ==0.0f || GrindMarkPoint[8].y ==0.0f) continue;

														 GrindMeaDis = Math.GetLength(GrindMarkPoint[8], OrgBtm3OutPoint[k]);
														 if(GrindMeaDis<MinDis){
															 MinDis = GrindMeaDis;
															 GrindMarkOutCnt = k;
														 }
													 }

													 // GrindMark기준 InData 최단거리 Count정보 Calc 
													 if(GrindMarkOutCnt!=0){
														 GrindMeaDis =0.0f, MinDis =10000.0f; GrindMarkInCnt=0;
														 for(int k=0; k<OrgBtm3InEdgeCount; k++){
															 if(OrgBtm3InPoint[k].x   ==0.0f             || OrgBtm3InPoint[k].y                ==0.0f) continue;
															 if(OrgBtm3OutPoint[GrindMarkOutCnt].x==0.0f || OrgBtm3OutPoint[GrindMarkOutCnt].y ==0.0f) continue;

															 GrindMeaDis = Math.GetLength(OrgBtm3OutPoint[GrindMarkOutCnt], OrgBtm3InPoint[k]);
															 if(GrindMeaDis<MinDis){
																 MinDis = GrindMeaDis;
																 GrindMarkInCnt = k;
															 }
														 }
													 }

													 // GrindMark기준 수직 포인트 주변값 Avg산출한다 ==>가공량 측정(OutData기준)
													 if(GrindMarkOutCnt!=0 && GrindMarkOutCnt>5){
														 CircleCount=0,TotalCirDis=0.0f,GrindMeaDis=0.0f;
														 for(int k=GrindMarkOutCnt-5; k<GrindMarkOutCnt+5; k++){
															 if(OrgBtm3OutPoint[k].x==0.0f || OrgBtm3OutPoint[k].y==0.0f) continue;
															 if(k>=OrgBtm3OutEdgeCount                                  ) continue;

															 GrindMeaDis = Math.GetLength(GrindMarkPoint[8], OrgBtm3OutPoint[k]);
															 TotalCirDis+= GrindMeaDis;
															 CircleCount++;
														 }
														 if(TotalCirDis!=0.0f && CircleCount!=0){
															 BtmGrindMeasure4 = TotalCirDis/CircleCount;
															 BtmGrindMeasure4 = BtmGrindMeasure4+0.5; //SubPixel 
														 }
													 }

													 // GrindMark기준 수직 포인트 주변값 Avg산출한다 ==>연마량 측정(OutData,InData기준)
													 if((GrindMarkOutCnt!=0 && GrindMarkOutCnt>5) && (GrindMarkInCnt!=0 && GrindMarkInCnt>5)){
														 CircleCount=0,TotalCirDis=0.0f,GrindWidthDis=0.0f;
														 for(int k=-5; k<5; k++){
															 if(OrgBtm3OutPoint[GrindMarkOutCnt+k].x==0.0f && OrgBtm3OutPoint[GrindMarkOutCnt+k].y==0.0f) continue;
															 if(OrgBtm3InPoint [GrindMarkInCnt +k].x==0.0f && OrgBtm3InPoint [GrindMarkInCnt +k].y==0.0f) continue;
															 if((GrindMarkOutCnt+k)>=OrgBtm3OutEdgeCount                                                ) continue;
															 if((GrindMarkInCnt +k)>=OrgBtm3InEdgeCount                                                 ) continue;

															 GrindWidthDis = Math.GetLength(OrgBtm3InPoint[GrindMarkInCnt+k], OrgBtm3OutPoint[GrindMarkOutCnt+k]);
															 TotalCirDis+=   GrindWidthDis;
															 CircleCount++;
														 }
														 if(TotalCirDis!=0.0f && CircleCount!=0){
															 BtmGrindWidth4 = TotalCirDis/CircleCount;
															 BtmGrindWidth4 = BtmGrindWidth4+0.5; //SubPixel
														 }
													 }
												 }
												 else if(GrindMarkRect[8].left!=0 && GrindMarkRect[8].top!=0 && GrindMarkRect[8].right!=0 && GrindMarkRect[8].bottom!=0) {  //GrindMark 못 찾았을경우
													 // OutData기준 최소값 데이터 Count산출 
													 GrindMeaDis =0.0f, MinDis =10000.0f; GrindMarkOutCnt=0;
													 for(int k=0; k<OrgBtm3OutEdgeCount; k++){
														 if(OrgBtm3OutPoint[k].x==0.0f || OrgBtm3OutPoint[k].y==0.0f) continue;

														 if(k==0 && GrindRectSpec[8].DvX==0.0f && GrindRectSpec[8].DvY==0.0f){ // 가상마크  
															 GrindMarkRectCenter[9].x = GrindMarkRect[9].left + (GrindMarkRect[9].right  - GrindMarkRect[9].left)/2; 
															 GrindMarkRectCenter[9].y = GrindMarkRect[9].top  + (GrindMarkRect[9].bottom - GrindMarkRect[9].top )/2; 

															 GrindMarkRectCenter[8].x = OrgBtm3InPoint[10].x     ;
															 GrindMarkRectCenter[8].y = GrindMarkRectCenter[9].y; 

															 GrindMarkRect [8].left  = GrindMarkRectCenter[8].x    - GrindMarkRange ;  
															 GrindMarkRect [8].top   = GrindMarkRectCenter[8].y    - GrindMarkRange ;  
															 GrindMarkRect [8].right = GrindMarkRect [8].left      + GrindMarkLength;  
															 GrindMarkRect [8].bottom= GrindMarkRect [8].top       + GrindMarkLength;  
														 }
														 else if(k==0 && GrindRectSpec[8].DvX!=0.0f && GrindRectSpec[8].DvY!=0.0f){ //진성마크 
															 GrindMarkRectCenter[8].x = GrindMarkRect[8].left + (GrindMarkRect[8].right  - GrindMarkRect[8].left)/2; 
															 GrindMarkRectCenter[8].y = GrindMarkRect[8].top  + (GrindMarkRect[8].bottom - GrindMarkRect[8].top )/2; 
														 }

														 GrindMeaDis = Math.GetLength(GrindMarkRectCenter[8], OrgBtm3OutPoint[k]);
														 if(GrindMeaDis<MinDis){
															 MinDis = GrindMeaDis;
															 GrindMarkOutCnt = k;
														 }
													 }

													 // 최단거리OUtCount기준 InData 최단거리 Count정보 Calc 
													 if(GrindMarkOutCnt!=0){
														 GrindMeaDis =0.0f, MinDis =10000.0f; GrindMarkInCnt=0;
														 for(int k=0; k<OrgBtm3InEdgeCount; k++){
															 if(OrgBtm3InPoint[k].x              ==0.0f  || OrgBtm3InPoint[k].y                ==0.0f) continue;
															 if(OrgBtm3OutPoint[GrindMarkOutCnt].x==0.0f || OrgBtm3OutPoint[GrindMarkOutCnt].y ==0.0f) continue;

															 GrindMeaDis = Math.GetLength(OrgBtm3OutPoint[GrindMarkOutCnt], OrgBtm3InPoint[k]);
															 if(GrindMeaDis<MinDis){
																 MinDis = GrindMeaDis;
																 GrindMarkInCnt = k;
															 }
														 }
													 }

													 // GrindMark기준 수직 포인트 주변값 Avg산출한다 ==>연마량 측정(OutData,InData기준)
													 if((GrindMarkOutCnt!=0 && GrindMarkOutCnt>5) && (GrindMarkInCnt!=0 && GrindMarkInCnt>5)){
														 CircleCount=0,TotalCirDis=0.0f,GrindWidthDis=0.0f;
														 for(int k=-5; k<5; k++){
															 if(OrgBtm3OutPoint[GrindMarkOutCnt+k].x==0.0f && OrgBtm3OutPoint[GrindMarkOutCnt+k].y==0.0f) continue;
															 if(OrgBtm3InPoint [GrindMarkInCnt +k].x==0.0f && OrgBtm3InPoint [GrindMarkInCnt +k].y==0.0f) continue;
															 if((GrindMarkOutCnt+k)>=OrgBtm3OutEdgeCount                                                ) continue;
															 if((GrindMarkInCnt +k)>=OrgBtm3InEdgeCount                                                 ) continue;

															 GrindWidthDis = Math.GetLength(OrgBtm3InPoint[GrindMarkInCnt+k], OrgBtm3OutPoint[GrindMarkOutCnt+k]);
															 TotalCirDis+=   GrindWidthDis;
															 CircleCount++;
														 }
														 if(TotalCirDis!=0.0f && CircleCount!=0){
															 BtmGrindWidth4 = TotalCirDis/CircleCount;
															 BtmGrindWidth4 = BtmGrindWidth4+0.5; //SubPixel
														 }
													 }
												 }

												 // GrindMark[9] 가공량,연마량 측정 
												 ////////////////////////////////////////////////////////////////////////////////////////////////////
												 if(GrindMarkPoint[9].x!=0.0f && GrindMarkPoint[9].y!=0.0f) { 
													 // GrindMark기준 OutData 최단거리 Count정보 Calc 
													 GrindMeaDis =0.0f, MinDis =10000.0f;  GrindMarkOutCnt=0;
													 for(int k=0; k<OrgBtm3OutEdgeCount; k++){
														 if(OrgBtm3OutPoint[k].x==0.0f || OrgBtm3OutPoint[k].y==0.0f) continue;
														 if(GrindMarkPoint[9].x ==0.0f || GrindMarkPoint[9].y ==0.0f) continue;

														 GrindMeaDis = Math.GetLength(GrindMarkPoint[9], OrgBtm3OutPoint[k]);
														 if(GrindMeaDis<MinDis){
															 MinDis = GrindMeaDis;
															 GrindMarkOutCnt = k;
														 }
													 }

													 // GrindMark기준 InData 최단거리 Count정보 Calc 
													 if(GrindMarkOutCnt!=0){
														 GrindMeaDis =0.0f, MinDis =10000.0f; GrindMarkInCnt=0;
														 for(int k=0; k<OrgBtm3InEdgeCount; k++){
															 if(OrgBtm3InPoint[k].x   ==0.0f             || OrgBtm3InPoint[k].y                ==0.0f) continue;
															 if(OrgBtm3OutPoint[GrindMarkOutCnt].x==0.0f || OrgBtm3OutPoint[GrindMarkOutCnt].y ==0.0f) continue;

															 GrindMeaDis = Math.GetLength(OrgBtm3OutPoint[GrindMarkOutCnt], OrgBtm3InPoint[k]);
															 if(GrindMeaDis<MinDis){
																 MinDis = GrindMeaDis;
																 GrindMarkInCnt = k;
															 }
														 }
													 }

													 // GrindMark기준 수직 포인트 주변값 Avg산출한다 ==>가공량 측정(OutData기준)
													 if(GrindMarkOutCnt!=0 && GrindMarkOutCnt>5){
														 CircleCount=0,TotalCirDis=0.0f,GrindMeaDis=0.0f;
														 for(int k=GrindMarkOutCnt-5; k<GrindMarkOutCnt+5; k++){
															 if(OrgBtm3OutPoint[k].x==0.0f || OrgBtm3OutPoint[k].y==0.0f) continue;
															 if(k>=OrgBtm3OutEdgeCount                                  ) continue;

															 GrindMeaDis = Math.GetLength(GrindMarkPoint[9], OrgBtm3OutPoint[k]);
															 TotalCirDis+= GrindMeaDis;
															 CircleCount++;
														 }
														 if(TotalCirDis!=0.0f && CircleCount!=0){
															 BtmGrindMeasure5 = TotalCirDis/CircleCount;
															 BtmGrindMeasure5 = BtmGrindMeasure5+0.5; //SubPixel 
														 }
													 }

													 // GrindMark기준 수직 포인트 주변값 Avg산출한다 ==>연마량 측정(OutData,InData기준)
													 if((GrindMarkOutCnt!=0 && GrindMarkOutCnt>5) && (GrindMarkInCnt!=0 && GrindMarkInCnt>5)){
														 CircleCount=0,TotalCirDis=0.0f,GrindWidthDis=0.0f;
														 for(int k=-5; k<5; k++){
															 if(OrgBtm3OutPoint[GrindMarkOutCnt+k].x==0.0f && OrgBtm3OutPoint[GrindMarkOutCnt+k].y==0.0f) continue;
															 if(OrgBtm3InPoint [GrindMarkInCnt +k].x==0.0f && OrgBtm3InPoint [GrindMarkInCnt +k].y==0.0f) continue;
															 if((GrindMarkOutCnt+k)>=OrgBtm3OutEdgeCount                                                ) continue;
															 if((GrindMarkInCnt +k)>=OrgBtm3InEdgeCount                                                 ) continue;

															 GrindWidthDis = Math.GetLength(OrgBtm3InPoint[GrindMarkInCnt+k], OrgBtm3OutPoint[GrindMarkOutCnt+k]);
															 TotalCirDis+=   GrindWidthDis;
															 CircleCount++;
														 }
														 if(TotalCirDis!=0.0f && CircleCount!=0){
															 BtmGrindWidth5 = TotalCirDis/CircleCount;
															 BtmGrindWidth5 = BtmGrindWidth5+0.5; //SubPixel
														 }
													 }
												 }
												 else if(GrindMarkRect[9].left!=0 && GrindMarkRect[9].top!=0 && GrindMarkRect[9].right!=0 && GrindMarkRect[9].bottom!=0) {  //GrindMark 못 찾았을경우
													 // OutData기준 최소값 데이터 Count산출 
													 GrindMeaDis =0.0f, MinDis =10000.0f; GrindMarkOutCnt=0;
													 for(int k=0; k<OrgBtm3OutEdgeCount; k++){
														 if(OrgBtm3OutPoint[k].x==0.0f || OrgBtm3OutPoint[k].y==0.0f) continue;

														 if(k==0){ // 순서상 9번이 없는경우 
															 GrindMarkRectCenter[9].x = GrindMarkRect[9].left + (GrindMarkRect[9].right  - GrindMarkRect[9].left)/2; 
															 GrindMarkRectCenter[9].y = GrindMarkRect[9].top  + (GrindMarkRect[9].bottom - GrindMarkRect[9].top )/2; 
														 }

														 GrindMeaDis = Math.GetLength(GrindMarkRectCenter[9], OrgBtm3OutPoint[k]);
														 if(GrindMeaDis<MinDis){
															 MinDis = GrindMeaDis;
															 GrindMarkOutCnt = k;
														 }
													 }

													 // 최단거리OUtCount기준 InData 최단거리 Count정보 Calc 
													 if(GrindMarkOutCnt!=0){
														 GrindMeaDis =0.0f, MinDis =10000.0f; GrindMarkInCnt=0;
														 for(int k=0; k<OrgBtm3InEdgeCount; k++){
															 if(OrgBtm3InPoint[k].x              ==0.0f  || OrgBtm3InPoint[k].y                ==0.0f) continue;
															 if(OrgBtm3OutPoint[GrindMarkOutCnt].x==0.0f || OrgBtm3OutPoint[GrindMarkOutCnt].y ==0.0f) continue;

															 GrindMeaDis = Math.GetLength(OrgBtm3OutPoint[GrindMarkOutCnt], OrgBtm3InPoint[k]);
															 if(GrindMeaDis<MinDis){
																 MinDis = GrindMeaDis;
																 GrindMarkInCnt = k;
															 }
														 }
													 }

													 // GrindMark기준 수직 포인트 주변값 Avg산출한다 ==>연마량 측정(OutData,InData기준)
													 if((GrindMarkOutCnt!=0 && GrindMarkOutCnt>5) && (GrindMarkInCnt!=0 && GrindMarkInCnt>5)){
														 CircleCount=0,TotalCirDis=0.0f,GrindWidthDis=0.0f;
														 for(int k=-5; k<5; k++){
															 if(OrgBtm3OutPoint[GrindMarkOutCnt+k].x==0.0f && OrgBtm3OutPoint[GrindMarkOutCnt+k].y==0.0f) continue;
															 if(OrgBtm3InPoint [GrindMarkInCnt +k].x==0.0f && OrgBtm3InPoint [GrindMarkInCnt +k].y==0.0f) continue;
															 if((GrindMarkOutCnt+k)>=OrgBtm3OutEdgeCount                                                ) continue;
															 if((GrindMarkInCnt +k)>=OrgBtm3InEdgeCount                                                 ) continue;

															 GrindWidthDis = Math.GetLength(OrgBtm3InPoint[GrindMarkInCnt+k], OrgBtm3OutPoint[GrindMarkOutCnt+k]);
															 TotalCirDis+=   GrindWidthDis;
															 CircleCount++;
														 }
														 if(TotalCirDis!=0.0f && CircleCount!=0){
															 BtmGrindWidth5 = TotalCirDis/CircleCount;
															 BtmGrindWidth5 = BtmGrindWidth5+0.5; //SubPixel
														 }
													 }
												 }

												 // GrindMark[10] 가공량,연마량 측정 
												 ////////////////////////////////////////////////////////////////////////////////////////////////////
												 if(GrindMarkPoint[10].x!=0.0f && GrindMarkPoint[10].y!=0.0f) { 
													 // GrindMark기준 OutData 최단거리 Count정보 Calc 
													 GrindMeaDis =0.0f, MinDis =10000.0f;  GrindMarkOutCnt=0;
													 for(int k=0; k<OrgBtm3OutEdgeCount; k++){
														 if(OrgBtm3OutPoint[k].x==0.0f || OrgBtm3OutPoint[k].y==0.0f) continue;
														 if(GrindMarkPoint[10].x ==0.0f || GrindMarkPoint[10].y ==0.0f) continue;

														 GrindMeaDis = Math.GetLength(GrindMarkPoint[10], OrgBtm3OutPoint[k]);
														 if(GrindMeaDis<MinDis){
															 MinDis = GrindMeaDis;
															 GrindMarkOutCnt = k;
														 }
													 }

													 // GrindMark기준 InData 최단거리 Count정보 Calc 
													 if(GrindMarkOutCnt!=0){
														 GrindMeaDis =0.0f, MinDis =10000.0f; GrindMarkInCnt=0;
														 for(int k=0; k<OrgBtm3InEdgeCount; k++){
															 if(OrgBtm3InPoint[k].x   ==0.0f             || OrgBtm3InPoint[k].y                ==0.0f) continue;
															 if(OrgBtm3OutPoint[GrindMarkOutCnt].x==0.0f || OrgBtm3OutPoint[GrindMarkOutCnt].y ==0.0f) continue;

															 GrindMeaDis = Math.GetLength(OrgBtm3OutPoint[GrindMarkOutCnt], OrgBtm3InPoint[k]);
															 if(GrindMeaDis<MinDis){
																 MinDis = GrindMeaDis;
																 GrindMarkInCnt = k;
															 }
														 }
													 }

													 // GrindMark기준 수직 포인트 주변값 Avg산출한다 ==>가공량 측정(OutData기준)
													 if(GrindMarkOutCnt!=0 && GrindMarkOutCnt>5){
														 CircleCount=0,TotalCirDis=0.0f,GrindMeaDis=0.0f;
														 for(int k=GrindMarkOutCnt-5; k<GrindMarkOutCnt+5; k++){
															 if(OrgBtm3OutPoint[k].x==0.0f || OrgBtm3OutPoint[k].y==0.0f) continue;
															 if(k>=OrgBtm3OutEdgeCount                                  ) continue;

															 GrindMeaDis = Math.GetLength(GrindMarkPoint[10], OrgBtm3OutPoint[k]);
															 TotalCirDis+= GrindMeaDis;
															 CircleCount++;
														 }
														 if(TotalCirDis!=0.0f && CircleCount!=0){
															 BtmGrindMeasure6 = TotalCirDis/CircleCount;
															 BtmGrindMeasure6 = BtmGrindMeasure6+0.5; //SubPixel 
														 }
													 }

													 // GrindMark기준 수직 포인트 주변값 Avg산출한다 ==>연마량 측정(OutData,InData기준)
													 if((GrindMarkOutCnt!=0 && GrindMarkOutCnt>5) && (GrindMarkInCnt!=0 && GrindMarkInCnt>5)){
														 CircleCount=0,TotalCirDis=0.0f,GrindWidthDis=0.0f;
														 for(int k=-5; k<5; k++){
															 if(OrgBtm3OutPoint[GrindMarkOutCnt+k].x==0.0f && OrgBtm3OutPoint[GrindMarkOutCnt+k].y==0.0f) continue;
															 if(OrgBtm3InPoint [GrindMarkInCnt +k].x==0.0f && OrgBtm3InPoint [GrindMarkInCnt +k].y==0.0f) continue;
															 if((GrindMarkOutCnt+k)>=OrgBtm3OutEdgeCount                                                ) continue;
															 if((GrindMarkInCnt +k)>=OrgBtm3InEdgeCount                                                 ) continue;

															 GrindWidthDis = Math.GetLength(OrgBtm3InPoint[GrindMarkInCnt+k], OrgBtm3OutPoint[GrindMarkOutCnt+k]);
															 TotalCirDis+=   GrindWidthDis;
															 CircleCount++;
														 }
														 if(TotalCirDis!=0.0f && CircleCount!=0){
															 BtmGrindWidth6 = TotalCirDis/CircleCount;
															 BtmGrindWidth6 = BtmGrindWidth6+0.5; //SubPixel
														 }
													 }
												 }
												 else if(GrindMarkRect[10].left!=0 && GrindMarkRect[10].top!=0 && GrindMarkRect[10].right!=0 && GrindMarkRect[10].bottom!=0) {  //GrindMark 못 찾았을경우
													 // OutData기준 최소값 데이터 Count산출 
													 GrindMeaDis =0.0f, MinDis =10000.0f; GrindMarkOutCnt=0;
													 for(int k=0; k<OrgBtm3OutEdgeCount; k++){
														 if(OrgBtm3OutPoint[k].x==0.0f || OrgBtm3OutPoint[k].y==0.0f) continue;

														 if(k==0 && GrindRectSpec[8].DvX==0.0f && GrindRectSpec[8].DvY==0.0f){ //가상마크 
															 GrindMarkRectCenter[10].x = OrgBtm3InPoint[OrgBtm3InEdgeCount-10].x ;
															 GrindMarkRectCenter[10].y = GrindMarkRectCenter[9].y               ; 

															 GrindMarkRect [10].left  = GrindMarkRectCenter[10].x - GrindMarkRange ;  
															 GrindMarkRect [10].top   = GrindMarkRectCenter[10].y - GrindMarkRange ;  
															 GrindMarkRect [10].right = GrindMarkRect [10].left   + GrindMarkLength;  
															 GrindMarkRect [10].bottom= GrindMarkRect [10].top    + GrindMarkLength;  
														 }
														 else if(k==0 && GrindRectSpec[8].DvX!=0.0f && GrindRectSpec[8].DvY!=0.0f){ //진성마크 
															 GrindMarkRectCenter[10].x = GrindMarkRect[10].left + (GrindMarkRect[10].right  - GrindMarkRect[10].left)/2; 
															 GrindMarkRectCenter[10].y = GrindMarkRect[10].top  + (GrindMarkRect[10].bottom - GrindMarkRect[10].top )/2; 
														 }

														 GrindMeaDis = Math.GetLength(GrindMarkRectCenter[10], OrgBtm3OutPoint[k]);
														 if(GrindMeaDis<MinDis){
															 MinDis = GrindMeaDis;
															 GrindMarkOutCnt = k;
														 }
													 }

													 // 최단거리OUtCount기준 InData 최단거리 Count정보 Calc 
													 if(GrindMarkOutCnt!=0){
														 GrindMeaDis =0.0f, MinDis =10000.0f; GrindMarkInCnt=0;
														 for(int k=0; k<OrgBtm3InEdgeCount; k++){
															 if(OrgBtm3InPoint[k].x              ==0.0f  || OrgBtm3InPoint[k].y                ==0.0f) continue;
															 if(OrgBtm3OutPoint[GrindMarkOutCnt].x==0.0f || OrgBtm3OutPoint[GrindMarkOutCnt].y ==0.0f) continue;

															 GrindMeaDis = Math.GetLength(OrgBtm3OutPoint[GrindMarkOutCnt], OrgBtm3InPoint[k]);
															 if(GrindMeaDis<MinDis){
																 MinDis = GrindMeaDis;
																 GrindMarkInCnt = k;
															 }
														 }
													 }

													 // GrindMark기준 수직 포인트 주변값 Avg산출한다 ==>연마량 측정(OutData,InData기준)
													 if((GrindMarkOutCnt!=0 && GrindMarkOutCnt>5) && (GrindMarkInCnt!=0 && GrindMarkInCnt>5)){
														 CircleCount=0,TotalCirDis=0.0f,GrindWidthDis=0.0f;
														 for(int k=-5; k<5; k++){
															 if(OrgBtm3OutPoint[GrindMarkOutCnt+k].x==0.0f && OrgBtm3OutPoint[GrindMarkOutCnt+k].y==0.0f) continue;
															 if(OrgBtm3InPoint [GrindMarkInCnt +k].x==0.0f && OrgBtm3InPoint [GrindMarkInCnt +k].y==0.0f) continue;
															 if((GrindMarkOutCnt+k)>=OrgBtm3OutEdgeCount                                                ) continue;
															 if((GrindMarkInCnt +k)>=OrgBtm3InEdgeCount                                                 ) continue;

															 GrindWidthDis = Math.GetLength(OrgBtm3InPoint[GrindMarkInCnt+k], OrgBtm3OutPoint[GrindMarkOutCnt+k]);
															 TotalCirDis+=   GrindWidthDis;
															 CircleCount++;
														 }
														 if(TotalCirDis!=0.0f && CircleCount!=0){
															 BtmGrindWidth6 = TotalCirDis/CircleCount;
															 BtmGrindWidth6 = BtmGrindWidth6+0.5; //SubPixel
														 }
													 }
												 }
											 }
										 }
										 else { // ENCAP 연마량 데이터만 계측함
											 if(BtmOutLine[2].FP0.x!=0.0f && BtmOutLine[2].FP0.y!=0.0f && BtmOutLine[2].FP1.x!=0.0f && BtmOutLine[2].FP1.y!=0.0f &&
												 BtmInLine [2].FP0.x!=0.0f && BtmInLine [2].FP0.y!=0.0f && BtmInLine [2].FP1.x!=0.0f && BtmInLine [2].FP1.y!=0.0f ){
													 // 연마량 계산  
													 if((fabs(BtmOutLine[2].FP0.y - BtmOutLine[2].FP1.y))>1
														 ||(fabs(BtmInLine[2].FP0.y - BtmInLine[2].FP1.y))>1){
															 BtmGrindWidth4 = BtmOutLine[2].FP0.y - BtmInLine[2].FP0.y; 
													 }
													 else{
														 BtmGrindWidth4 = Math.GetLengthFrLineToPoint(BtmOutLine[2].FP0, BtmOutLine[2].FP1, BtmInLine[2].FP0);
													 }
											 }
										 }
									 }
									 // 동적 생성한 데이터를 지운다 
									 if(OrgBtm3InPoint !=NULL) delete[] OrgBtm3InPoint;
									 if(OrgBtm3OutPoint!=NULL) delete[] OrgBtm3OutPoint;
									 LogUnit.SetLog(L"CellID:%d, CamID:%d ==>Straight1_Insp_End",CellId,CamId);     
								 }


								 // 비선형 곡선 영역을 제외한 직선 영역 검사 시퀀스 
								 // 다섯번째 직선 영역 
								 if(BtmEdgePoint[8].x!=0 && BtmEdgePoint[8].y!=0 && BtmEdgePoint[9].x!=0 && BtmEdgePoint[9].y!=0 ){
									 P1.x=0, P1.y=0, P2.x=0, P2.y=0, P3.x=0, P3.y=0, P4.x=0, P4.y=0;
									 LogUnit.SetLog(L"CellID:%d, CamID:%d ==>Straight5_Insp_Start",CellId,CamId);     

									 P1.x = (BtmEdgePoint[8].x); P1.y =(BtmEdgePoint[8].y-30); P2.x = (P1.x+(BtmEdgePoint[9].x - BtmEdgePoint[8].x )); P2.y = (P1.y);
									 P3.x = (BtmEdgePoint[8].x); P3.y =(BtmEdgePoint[8].y+30); P4.x = (P2.x                                         ); P4.y = (P3.y);

									 // Median Filter 적용 
									 if(P1.x<=0    || P1.y<=0    || (P2.x - P1.x)<=0    || (P3.y - P1.y)<=0   ) return false;
									 if(P1.x>=ImgW || P1.y>=ImgH || (P2.x - P1.x)>=ImgW || (P3.y - P1.y)>=ImgH) return false;
									 FilterROI.SetSize(int(P2.x - P1.x),int(P3.y - P1.y) )                      ;
									 FilterROI.Attach(&RotateBinaryImg)                                    ;
									 FilterROI.SetPlacement(P1.x, P1.y, int(P2.x - P1.x), int(P3.y - P1.y));
									 LogUnit.SetLog(L"다섯번째 직선 ==>Px :%d, Py :%d, Width:%d, Height:%d ==>Median Filter",P1.x, P1.y, int(P2.x - P1.x), int(P3.y - P1.y));     
									 LogUnit.SetLog(L"다섯번째 직선 ==>P1x:%d, P1y:%d, P2x:%d, P2y:%d, P3x:%d, P3y:%d, P4x:%d, P4y:%d,",P1.x,P1.y,P2.x,P2.y,P3.x,P3.y,P4.x,P4.y);     
									 EasyImage::Median(&FilterROI, &FilterROI)                             ;

									 Polygon->GImage          = &RotateBinaryImg           ;
									 Polygon->PoPa.FMaxWidth  =(int)(P2.x - P1.x)+100      ;
									 Polygon->PoPa.FMaxHeight =(int)(P3.y - P1.y)          ;
									 Polygon->PoPa.FMinWidth  =(int)(P2.x - P1.x)-100      ; 
									 Polygon->PoPa.IsSeparate =true                        ;
									 Polygon->PoPa.IsInToOut  =true                        ;
									 Polygon->PoPa.HiThHold   = BtmEdgeThresHold           ;
									 Polygon->PoPa.LoThHold   = 0                          ;

									 if(P1.x!=0 && P1.y!=0 && P2.x!=0 && P2.y!=0 && P3.x!=0 && P3.y!=0 && P4.x!=0 && P4.y!=0){
										 Polygon->OnExecute(P1,P2,P3,P4);
									 }

									 // Polygon Algorithm InEdgeData/OutEdgeData Separate 및 데이터 추출 
									 if(Polygon->BlobCount==1){
										 PolygonMarginCnt =10;
										 if(Polygon->Blob[0].InCnt>(PolygonMarginCnt*2)){
											 OrgBtm5InEdgeCount=0;
											 OrgBtm5InEdgeCount = (Polygon->Blob[0].InCnt - (PolygonMarginCnt*2));
											 if(OrgBtm5InEdgeCount>0){
												 if(OrgBtm5InPoint!=NULL) delete[] OrgBtm5InPoint;
												 OrgBtm5InPoint = new TFPoint[OrgBtm5InEdgeCount];

												 PixelCnt=0;
												 for(int k=0; k<Polygon->Blob[0].InCnt; k++){
													 if(k<PolygonMarginCnt || k>=(Polygon->Blob[0].InCnt-PolygonMarginCnt)) continue;
													 OrgBtm5InPoint[PixelCnt].x   = Polygon->Blob[0].InPoint[k].x ;
													 OrgBtm5InPoint[PixelCnt].y   = Polygon->Blob[0].InPoint[k].y ;
													 PixelCnt++;
												 }
											 }
											 // Org Data 
											 BtmInLine[4].FP0 = OrgBtm5InPoint[0];
											 BtmInLine[4].FP1 = OrgBtm5InPoint[PixelCnt-1];
										 }

										 if(Polygon->Blob[0].OutCnt>(PolygonMarginCnt*2)){
											 OrgBtm5OutEdgeCount=0;
											 OrgBtm5OutEdgeCount = (Polygon->Blob[0].OutCnt - (PolygonMarginCnt*2));
											 if(OrgBtm5OutEdgeCount>0){
												 if(OrgBtm5OutPoint!=NULL) delete[] OrgBtm5OutPoint;
												 OrgBtm5OutPoint = new TFPoint[OrgBtm5OutEdgeCount];

												 PixelCnt=0;
												 for(int k=0; k<Polygon->Blob[0].OutCnt; k++){
													 if(k<PolygonMarginCnt || k>=(Polygon->Blob[0].OutCnt-PolygonMarginCnt)) continue;
													 OrgBtm5OutPoint[PixelCnt].x  = Polygon->Blob[0].OutPoint[k].x ;
													 OrgBtm5OutPoint[PixelCnt].y  = Polygon->Blob[0].OutPoint[k].y ;
													 PixelCnt++;
												 }
											 }
											 // Org Data 
											 BtmOutLine[4].FP0 = OrgBtm5OutPoint[0];
											 BtmOutLine[4].FP1 = OrgBtm5OutPoint[PixelCnt-1];
										 }


									 }

									 // 연마량 측정 및 가공량 측정 (비선형)
									 if(IsMarkBtm){
										 if(OrgBtm5InEdgeCount>10 && OrgBtm5OutEdgeCount>10){
											 // 가공량,연마량 측정 전 데이터 존재시 가상GrindMark 생성한다 
											 if(GrindMarkPoint[16].x!=0.0f && GrindMarkPoint[16].y!=0.0f && GrindRectSpec[4].DvX==0.0f && GrindRectSpec[4].DvY==0.0f &&!IsNarrowTrench){
												 GrindMarkPoint[14].x     = OrgBtm5InPoint[10].x                     ;
												 GrindMarkPoint[14].y     = GrindMarkPoint[16].y                     ;
												 GrindMarkRect [14].left  = GrindMarkPoint[14].x    - GrindMarkRange ;  
												 GrindMarkRect [14].top   = GrindMarkPoint[14].y    - GrindMarkRange ;  
												 GrindMarkRect [14].right = GrindMarkRect [14].left + GrindMarkLength;  
												 GrindMarkRect [14].bottom= GrindMarkRect [14].top  + GrindMarkLength;  
											 }
											 // GrindMark[14] 가공량,연마량 측정 
											 ////////////////////////////////////////////////////////////////////////////////////////////////////
											 if(GrindMarkPoint[14].x!=0.0f && GrindMarkPoint[14].y!=0.0f) { 
												 // GrindMark기준 OutData 최단거리 Count정보 Calc 
												 GrindMeaDis =0.0f, MinDis =10000.0f;  GrindMarkOutCnt=0;
												 for(int k=0; k<OrgBtm5OutEdgeCount; k++){
													 if(OrgBtm5OutPoint[k].x==0.0f || OrgBtm5OutPoint[k].y==0.0f) continue;
													 if(GrindMarkPoint[14].x ==0.0f || GrindMarkPoint[14].y ==0.0f) continue;

													 GrindMeaDis = Math.GetLength(GrindMarkPoint[14], OrgBtm5OutPoint[k]);
													 if(GrindMeaDis<MinDis){
														 MinDis = GrindMeaDis;
														 GrindMarkOutCnt = k;
													 }
												 }

												 // GrindMark기준 InData 최단거리 Count정보 Calc 
												 if(GrindMarkOutCnt!=0){
													 GrindMeaDis =0.0f, MinDis =10000.0f; GrindMarkInCnt=0;
													 for(int k=0; k<OrgBtm5InEdgeCount; k++){
														 if(OrgBtm5InPoint[k].x   ==0.0f             || OrgBtm5InPoint[k].y                ==0.0f) continue;
														 if(OrgBtm5OutPoint[GrindMarkOutCnt].x==0.0f || OrgBtm5OutPoint[GrindMarkOutCnt].y ==0.0f) continue;

														 GrindMeaDis = Math.GetLength(OrgBtm5OutPoint[GrindMarkOutCnt], OrgBtm5InPoint[k]);
														 if(GrindMeaDis<MinDis){
															 MinDis = GrindMeaDis;
															 GrindMarkInCnt = k;
														 }
													 }
												 }

												 // GrindMark기준 수직 포인트 주변값 Avg산출한다 ==>가공량 측정(OutData기준)
												 if(GrindMarkOutCnt!=0 && GrindMarkOutCnt>5){
													 CircleCount=0,TotalCirDis=0.0f,GrindMeaDis=0.0f;
													 for(int k=GrindMarkOutCnt-5; k<GrindMarkOutCnt+5; k++){
														 if(OrgBtm5OutPoint[k].x==0.0f || OrgBtm5OutPoint[k].y==0.0f) continue;
														 if(k>=OrgBtm5OutEdgeCount                                  ) continue;

														 GrindMeaDis = Math.GetLength(GrindMarkPoint[14], OrgBtm5OutPoint[k]);
														 TotalCirDis+= GrindMeaDis;
														 CircleCount++;
													 }
													 if(TotalCirDis!=0.0f && CircleCount!=0){
														 BtmGrindMeasure7 = TotalCirDis/CircleCount;
														 BtmGrindMeasure7 = BtmGrindMeasure7+0.5; //SubPixel 
													 }
												 }

												 // GrindMark기준 수직 포인트 주변값 Avg산출한다 ==>연마량 측정(OutData,InData기준)
												 if((GrindMarkOutCnt!=0 && GrindMarkOutCnt>5) && (GrindMarkInCnt!=0 && GrindMarkInCnt>5)){
													 CircleCount=0,TotalCirDis=0.0f,GrindWidthDis=0.0f;
													 for(int k=-5; k<5; k++){
														 if(OrgBtm5OutPoint[GrindMarkOutCnt+k].x==0.0f && OrgBtm5OutPoint[GrindMarkOutCnt+k].y==0.0f) continue;
														 if(OrgBtm5InPoint [GrindMarkInCnt +k].x==0.0f && OrgBtm5InPoint [GrindMarkInCnt +k].y==0.0f) continue;
														 if((GrindMarkOutCnt+k)>=OrgBtm5OutEdgeCount                                                ) continue;
														 if((GrindMarkInCnt +k)>=OrgBtm5InEdgeCount                                                 ) continue;

														 GrindWidthDis = Math.GetLength(OrgBtm5InPoint[GrindMarkInCnt+k], OrgBtm5OutPoint[GrindMarkOutCnt+k]);
														 TotalCirDis+=   GrindWidthDis;
														 CircleCount++;
													 }
													 if(TotalCirDis!=0.0f && CircleCount!=0){
														 BtmGrindWidth7 = TotalCirDis/CircleCount;
														 BtmGrindWidth7 = BtmGrindWidth7+0.5; //SubPixel
													 }
												 }
											 }
											 else if(GrindMarkRect[14].left!=0 && GrindMarkRect[14].top!=0 && GrindMarkRect[14].right!=0 && GrindMarkRect[14].bottom!=0) {  //GrindMark 못 찾았을경우
												 // OutData기준 최소값 데이터 Count산출 
												 GrindMeaDis =0.0f, MinDis =10000.0f; GrindMarkOutCnt=0;
												 for(int k=0; k<OrgBtm5OutEdgeCount; k++){
													 if(OrgBtm5OutPoint[k].x==0.0f || OrgBtm5OutPoint[k].y==0.0f) continue;

													 if(k==0 && GrindRectSpec[4].DvX==0.0f && GrindRectSpec[4].DvY==0.0f){ //가상마크 
														 GrindMarkRectCenter[16].x = GrindMarkRect[16].left + (GrindMarkRect[16].right  - GrindMarkRect[16].left)/2; 
														 GrindMarkRectCenter[16].y = GrindMarkRect[16].top  + (GrindMarkRect[16].bottom - GrindMarkRect[16].top )/2; 

														 GrindMarkRectCenter[14].x     = OrgBtm5InPoint     [10].x                     ;
														 GrindMarkRectCenter[14].y     = GrindMarkRectCenter[16].y                     ;
														 GrindMarkRect      [14].left  = GrindMarkRectCenter[14].x    - GrindMarkRange ;  
														 GrindMarkRect      [14].top   = GrindMarkRectCenter[14].y    - GrindMarkRange ;  
														 GrindMarkRect      [14].right = GrindMarkRect      [14].left + GrindMarkLength;  
														 GrindMarkRect      [14].bottom= GrindMarkRect      [14].top  + GrindMarkLength;  
													 }
													 else if(k==0 && GrindRectSpec[4].DvX!=0.0f && GrindRectSpec[4].DvY!=0.0f){// 진성 마크 
														 GrindMarkRectCenter[14].x = GrindMarkRect[14].left + (GrindMarkRect[14].right  - GrindMarkRect[14].left)/2; 
														 GrindMarkRectCenter[14].y = GrindMarkRect[14].top  + (GrindMarkRect[14].bottom - GrindMarkRect[14].top )/2; 
													 }

													 GrindMeaDis = Math.GetLength(GrindMarkRectCenter[14], OrgBtm5OutPoint[k]);
													 if(GrindMeaDis<MinDis){
														 MinDis = GrindMeaDis;
														 GrindMarkOutCnt = k;
													 }
												 }

												 // 최단거리OUtCount기준 InData 최단거리 Count정보 Calc 
												 if(GrindMarkOutCnt!=0){
													 GrindMeaDis =0.0f, MinDis =10000.0f; GrindMarkInCnt=0;
													 for(int k=0; k<OrgBtm5InEdgeCount; k++){
														 if(OrgBtm5InPoint[k].x              ==0.0f  || OrgBtm5InPoint[k].y                ==0.0f) continue;
														 if(OrgBtm5OutPoint[GrindMarkOutCnt].x==0.0f || OrgBtm5OutPoint[GrindMarkOutCnt].y ==0.0f) continue;

														 GrindMeaDis = Math.GetLength(OrgBtm5OutPoint[GrindMarkOutCnt], OrgBtm5InPoint[k]);
														 if(GrindMeaDis<MinDis){
															 MinDis = GrindMeaDis;
															 GrindMarkInCnt = k;
														 }
													 }
												 }

												 // GrindMark기준 수직 포인트 주변값 Avg산출한다 ==>연마량 측정(OutData,InData기준)
												 if((GrindMarkOutCnt!=0 && GrindMarkOutCnt>5) && (GrindMarkInCnt!=0 && GrindMarkInCnt>5)){
													 CircleCount=0,TotalCirDis=0.0f,GrindWidthDis=0.0f;
													 for(int k=-5; k<5; k++){
														 if(OrgBtm5OutPoint[GrindMarkOutCnt+k].x==0.0f && OrgBtm5OutPoint[GrindMarkOutCnt+k].y==0.0f) continue;
														 if(OrgBtm5InPoint [GrindMarkInCnt +k].x==0.0f && OrgBtm5InPoint [GrindMarkInCnt +k].y==0.0f) continue;
														 if((GrindMarkOutCnt+k)>=OrgBtm5OutEdgeCount                                                ) continue;
														 if((GrindMarkInCnt +k)>=OrgBtm5InEdgeCount                                                 ) continue;

														 GrindWidthDis = Math.GetLength(OrgBtm5InPoint[GrindMarkInCnt+k], OrgBtm5OutPoint[GrindMarkOutCnt+k]);
														 TotalCirDis+=   GrindWidthDis;
														 CircleCount++;
													 }
													 if(TotalCirDis!=0.0f && CircleCount!=0){
														 BtmGrindWidth7 = TotalCirDis/CircleCount;
														 BtmGrindWidth7 = BtmGrindWidth7+0.5; //SubPixel
													 }
												 }
											 }

											 // GrindMark[16] 가공량,연마량 측정 
											 ////////////////////////////////////////////////////////////////////////////////////////////////////
											 if(GrindMarkPoint[16].x!=0.0f && GrindMarkPoint[16].y!=0.0f){ 
												 // GrindMark기준 OutData 최단거리 Count정보 Calc 
												 GrindMeaDis =0.0f, MinDis =10000.0f;  GrindMarkOutCnt=0;
												 for(int k=0; k<OrgBtm5OutEdgeCount; k++){
													 if(OrgBtm5OutPoint[k].x==0.0f || OrgBtm5OutPoint[k].y==0.0f) continue;
													 if(GrindMarkPoint[16].x ==0.0f || GrindMarkPoint[16].y ==0.0f) continue;

													 GrindMeaDis = Math.GetLength(GrindMarkPoint[16], OrgBtm5OutPoint[k]);
													 if(GrindMeaDis<MinDis){
														 MinDis = GrindMeaDis;
														 GrindMarkOutCnt = k;
													 }
												 }

												 // GrindMark기준 InData 최단거리 Count정보 Calc 
												 if(GrindMarkOutCnt!=0){
													 GrindMeaDis =0.0f, MinDis =10000.0f; GrindMarkInCnt=0;
													 for(int k=0; k<OrgBtm5InEdgeCount; k++){
														 if(OrgBtm5InPoint[k].x   ==0.0f             || OrgBtm5InPoint[k].y                ==0.0f) continue;
														 if(OrgBtm5OutPoint[GrindMarkOutCnt].x==0.0f || OrgBtm5OutPoint[GrindMarkOutCnt].y ==0.0f) continue;

														 GrindMeaDis = Math.GetLength(OrgBtm5OutPoint[GrindMarkOutCnt], OrgBtm5InPoint[k]);
														 if(GrindMeaDis<MinDis){
															 MinDis = GrindMeaDis;
															 GrindMarkInCnt = k;
														 }
													 }
												 }

												 // GrindMark기준 수직 포인트 주변값 Avg산출한다 ==>가공량 측정(OutData기준)
												 if(GrindMarkOutCnt!=0 && GrindMarkOutCnt>5){
													 CircleCount=0,TotalCirDis=0.0f,GrindMeaDis=0.0f;
													 for(int k=GrindMarkOutCnt-5; k<GrindMarkOutCnt+5; k++){
														 if(OrgBtm5OutPoint[k].x==0.0f || OrgBtm5OutPoint[k].y==0.0f) continue;
														 if(k>=OrgBtm5OutEdgeCount                                  ) continue;

														 GrindMeaDis = Math.GetLength(GrindMarkPoint[16], OrgBtm5OutPoint[k]);
														 TotalCirDis+= GrindMeaDis;
														 CircleCount++;
													 }
													 if(TotalCirDis!=0.0f && CircleCount!=0){
														 BtmGrindMeasure9 = TotalCirDis/CircleCount;
														 BtmGrindMeasure9 = BtmGrindMeasure9+0.5; //SubPixel 
													 }
												 }

												 // GrindMark기준 수직 포인트 주변값 Avg산출한다 ==>연마량 측정(OutData,InData기준)
												 if((GrindMarkOutCnt!=0 && GrindMarkOutCnt>5) && (GrindMarkInCnt!=0 && GrindMarkInCnt>5)){
													 CircleCount=0,TotalCirDis=0.0f,GrindWidthDis=0.0f;
													 for(int k=-5; k<5; k++){
														 if(OrgBtm5OutPoint[GrindMarkOutCnt+k].x==0.0f && OrgBtm5OutPoint[GrindMarkOutCnt+k].y==0.0f) continue;
														 if(OrgBtm5InPoint [GrindMarkInCnt +k].x==0.0f && OrgBtm5InPoint [GrindMarkInCnt +k].y==0.0f) continue;
														 if((GrindMarkOutCnt+k)>=OrgBtm5OutEdgeCount                                                ) continue;
														 if((GrindMarkInCnt +k)>=OrgBtm5InEdgeCount                                                 ) continue;

														 GrindWidthDis = Math.GetLength(OrgBtm5InPoint[GrindMarkInCnt+k], OrgBtm5OutPoint[GrindMarkOutCnt+k]);
														 TotalCirDis+=   GrindWidthDis;
														 CircleCount++;
													 }
													 if(TotalCirDis!=0.0f && CircleCount!=0){
														 BtmGrindWidth9 = TotalCirDis/CircleCount;
														 BtmGrindWidth9 = BtmGrindWidth9+0.5; //SubPixel
													 }
												 }
											 }
											 else if(GrindMarkRect[16].left!=0 && GrindMarkRect[16].top!=0 && GrindMarkRect[16].right!=0 && GrindMarkRect[16].bottom!=0) {  //GrindMark 못 찾았을경우
												 // OutData기준 최소값 데이터 Count산출 
												 GrindMeaDis =0.0f, MinDis =10000.0f; GrindMarkOutCnt=0;
												 for(int k=0; k<OrgBtm5OutEdgeCount; k++){
													 if(OrgBtm5OutPoint[k].x==0.0f || OrgBtm5OutPoint[k].y==0.0f) continue;

													 if(k==0){
														 GrindMarkRectCenter[16].x = GrindMarkRect[16].left + (GrindMarkRect[16].right  - GrindMarkRect[16].left)/2; 
														 GrindMarkRectCenter[16].y = GrindMarkRect[16].top  + (GrindMarkRect[16].bottom - GrindMarkRect[16].top )/2; 
													 }
													 GrindMeaDis = Math.GetLength(GrindMarkRectCenter[16], OrgBtm5OutPoint[k]);
													 if(GrindMeaDis<MinDis){
														 MinDis = GrindMeaDis;
														 GrindMarkOutCnt = k;
													 }
												 }

												 // 최단거리OUtCount기준 InData 최단거리 Count정보 Calc 
												 if(GrindMarkOutCnt!=0){
													 GrindMeaDis =0.0f, MinDis =10000.0f; GrindMarkInCnt=0;
													 for(int k=0; k<OrgBtm5InEdgeCount; k++){
														 if(OrgBtm5InPoint[k].x              ==0.0f  || OrgBtm5InPoint[k].y                ==0.0f) continue;
														 if(OrgBtm5OutPoint[GrindMarkOutCnt].x==0.0f || OrgBtm5OutPoint[GrindMarkOutCnt].y ==0.0f) continue;

														 GrindMeaDis = Math.GetLength(OrgBtm5OutPoint[GrindMarkOutCnt], OrgBtm5InPoint[k]);
														 if(GrindMeaDis<MinDis){
															 MinDis = GrindMeaDis;
															 GrindMarkInCnt = k;
														 }
													 }
												 }

												 // GrindMark기준 수직 포인트 주변값 Avg산출한다 ==>연마량 측정(OutData,InData기준)
												 if((GrindMarkOutCnt!=0 && GrindMarkOutCnt>5) && (GrindMarkInCnt!=0 && GrindMarkInCnt>5)){
													 CircleCount=0,TotalCirDis=0.0f,GrindWidthDis=0.0f;
													 for(int k=-5; k<5; k++){
														 if(OrgBtm5OutPoint[GrindMarkOutCnt+k].x==0.0f && OrgBtm5OutPoint[GrindMarkOutCnt+k].y==0.0f) continue;
														 if(OrgBtm5InPoint [GrindMarkInCnt +k].x==0.0f && OrgBtm5InPoint [GrindMarkInCnt +k].y==0.0f) continue;
														 if((GrindMarkOutCnt+k)>=OrgBtm1OutEdgeCount                                                ) continue;
														 if((GrindMarkInCnt +k)>=OrgBtm1InEdgeCount                                                 ) continue;

														 GrindWidthDis = Math.GetLength(OrgBtm5InPoint[GrindMarkInCnt+k], OrgBtm5OutPoint[GrindMarkOutCnt+k]);
														 TotalCirDis+=   GrindWidthDis;
														 CircleCount++;
													 }
													 if(TotalCirDis!=0.0f && CircleCount!=0){
														 BtmGrindWidth9 = TotalCirDis/CircleCount;
														 BtmGrindWidth9 = BtmGrindWidth9+0.5; //SubPixel
													 }
												 }
											 }
										 }
									 }
									 else { // ENCAP 연마량 데이터만 계측함
										 if(BtmOutLine[0].FP0.x!=0.0f && BtmOutLine[0].FP0.y!=0.0f && BtmOutLine[0].FP1.x!=0.0f && BtmOutLine[0].FP1.y!=0.0f &&
											 BtmInLine [0].FP0.x!=0.0f && BtmInLine [0].FP0.y!=0.0f && BtmInLine [0].FP1.x!=0.0f && BtmInLine [0].FP1.y!=0.0f ){
												 // 연마량 계산  
												 if((fabs(BtmOutLine[0].FP0.y - BtmOutLine[0].FP1.y))>1
													 ||(fabs(BtmInLine[0].FP0.y - BtmInLine[0].FP1.y))>1){
														 BtmGrindWidth9 = BtmOutLine[0].FP0.y - BtmInLine[0].FP0.y; 
												 }
												 else{
													 BtmGrindWidth9 = Math.GetLengthFrLineToPoint(BtmOutLine[0].FP0, BtmOutLine[0].FP1, BtmInLine[0].FP0);
												 }
										 }
									 }
									 // 동적 생성한 데이터를 지운다 
									 if(OrgBtm5InPoint !=NULL) delete[] OrgBtm5InPoint;
									 if(OrgBtm5OutPoint!=NULL) delete[] OrgBtm5OutPoint;
									 LogUnit.SetLog(L"CellID:%d, CamID:%d ==>Straight5_Insp_End",CellId,CamId);     
								 }

								 // 4_Round Cell 시퀀스 
								 //Notch부 Side만 Arc가공이 존재할 경우 (Polygon_Mode)
								 // 연마량,가공량 측정 없이 Defect 검사만 진행함 
								 if(CenterCircleWidth==0.0f && CenterCircleHeight==0.0f){
									 if(BtmEdgePoint[0].x!=0 && BtmEdgePoint[0].y!=0 && BtmEdgePoint[9].x!=0 && BtmEdgePoint[9].y!=0 ){ // BTM
										 P1.x=0, P1.y=0, P2.x=0, P2.y=0, P3.x=0, P3.y=0, P4.x=0, P4.y=0;

										 P1.x = (BtmEdgePoint[0].x); P1.y =(BtmEdgePoint[0].y-30); P2.x = (P1.x+(BtmEdgePoint[9].x - BtmEdgePoint[0].x )); P2.y = (P1.y);
										 P3.x = (BtmEdgePoint[0].x); P3.y =(BtmEdgePoint[0].y+30); P4.x = (P2.x                                         ); P4.y = (P3.y);

										 // Median Filter 적용 
										 if(P1.x<=0    || P1.y<=0    || (P2.x - P1.x)<=0    || (P3.y - P1.y)<=0   ) return false;
										 if(P1.x>=ImgW || P1.y>=ImgH || (P2.x - P1.x)>=ImgW || (P3.y - P1.y)>=ImgH) return false;
										 //ROI x + Width = 16384 넘어가면 Return //20180808 추가
										 //ROI y + Hight = 1500  넘어가면 Return
										 if( (P1.x + int(P2.x - P1.x)) >= ImgW || (P1.y + int(P3.y - P1.y)) >= ImgH ) return false;
										 FilterROI.SetSize(int(P2.x - P1.x),int(P3.y - P1.y) )                      ;
										 FilterROI.Attach(&RotateBinaryImg)                                    ;
										 FilterROI.SetPlacement(P1.x, P1.y, int(P2.x - P1.x), int(P3.y - P1.y));
										 LogUnit.SetLog(L"Px : %d, Py : %d, Width : %d, Height : %d => MedianFilter", P1.x, P1.y, int(P2.x - P1.x), int(P3.y - P1.y));
										 LogUnit.SetLog(L"P1.x : %d, P1.y : %d, P2.x : %d, P2.y : %d, P3.x : %d, P3.y : %d, P4.x : %d, P4.y : %d => MedianFilter", P1.x, P1.y, P2.x, P2.y, P3.x, P3.y, P4.x, P4.y);
										 EasyImage::Median(&FilterROI, &FilterROI)                             ;

										 Polygon->PoPa.FMinHeight = 5                          ;
										 Polygon->GImage          = &RotateBinaryImg           ;
										 Polygon->PoPa.FMaxWidth  =(int)(P2.x - P1.x)+100      ;
										 Polygon->PoPa.FMaxHeight =(int)(P3.y - P1.y)          ;
										 Polygon->PoPa.IsSeparate =true                        ;
										 Polygon->PoPa.IsInToOut  =true                        ;
										 Polygon->PoPa.HiThHold   = BtmEdgeThresHold           ;
										 Polygon->PoPa.LoThHold   = 0                          ;

										 if(P1.x!=0 && P1.y!=0 && P2.x!=0 && P2.y!=0 && P3.x!=0 && P3.y!=0 && P4.x!=0 && P4.y!=0){
											 Polygon->OnExecute(P1,P2,P3,P4);
										 }

										 // Polygon Algorithm InEdgeData/OutEdgeData Separate 및 데이터 추출 
										 if(Polygon->BlobCount==1){
											 PolygonMarginCnt =10;
											 if(Polygon->Blob[0].InCnt>(PolygonMarginCnt*2)){
												 OrgBtm1InEdgeCount=0;
												 OrgBtm1InEdgeCount = (Polygon->Blob[0].InCnt - (PolygonMarginCnt*2));
												 if(OrgBtm1InEdgeCount>0){
													 if(OrgBtm1InPoint!=NULL) delete[] OrgBtm1InPoint;
													 OrgBtm1InPoint = new TFPoint[OrgBtm1InEdgeCount];

													 PixelCnt=0;
													 for(int k=0; k<Polygon->Blob[0].InCnt; k++){
														 if(k<PolygonMarginCnt || k>=(Polygon->Blob[0].InCnt-PolygonMarginCnt)) continue;
														 OrgBtm1InPoint[PixelCnt].x   = Polygon->Blob[0].InPoint[k].x ;
														 OrgBtm1InPoint[PixelCnt].y   = Polygon->Blob[0].InPoint[k].y ;
														 PixelCnt++;
													 }
												 }
												 // Org Data 
												 BtmInLine[0].FP0 = OrgBtm1InPoint[0];
												 BtmInLine[0].FP1 = OrgBtm1InPoint[PixelCnt-1];
											 }

											 if(Polygon->Blob[0].OutCnt>(PolygonMarginCnt*2)){
												 OrgBtm1OutEdgeCount=0;
												 OrgBtm1OutEdgeCount = (Polygon->Blob[0].OutCnt - (PolygonMarginCnt*2));
												 if(OrgBtm1OutEdgeCount>0){
													 if(OrgBtm1OutPoint!=NULL) delete[] OrgBtm1OutPoint;
													 OrgBtm1OutPoint = new TFPoint[OrgBtm1OutEdgeCount];

													 PixelCnt=0;
													 for(int k=0; k<Polygon->Blob[0].OutCnt; k++){
														 if(k<PolygonMarginCnt || k>=(Polygon->Blob[0].OutCnt-PolygonMarginCnt)) continue;
														 OrgBtm1OutPoint[PixelCnt].x  = Polygon->Blob[0].OutPoint[k].x ;
														 OrgBtm1OutPoint[PixelCnt].y  = Polygon->Blob[0].OutPoint[k].y ;
														 PixelCnt++;
													 }
												 }
												 // Org Data 
												 BtmOutLine[0].FP0 = OrgBtm1OutPoint[0];
												 BtmOutLine[0].FP1 = OrgBtm1OutPoint[PixelCnt-1];
											 }
											 // Polygon Data Clear
											 // 												 Polygon->ClearData();
										 }

										 // Size 측정 목적으로 가공량만 산출한다 
										 if(GrindMarkPoint[2].x!=0.0f && GrindMarkPoint[2].y!=0.0f) { 
											 // GrindMark기준 OutData 최단거리 Count정보 Calc 
											 GrindMeaDis =0.0f, MinDis =10000.0f;  GrindMarkOutCnt=0;
											 for(int k=0; k<OrgBtm1OutEdgeCount; k++){
												 if(OrgBtm1OutPoint[k].x==0.0f || OrgBtm1OutPoint[k].y==0.0f) continue;
												 if(GrindMarkPoint[2].x ==0.0f || GrindMarkPoint[2].y ==0.0f) continue;

												 GrindMeaDis = Math.GetLength(GrindMarkPoint[2], OrgBtm1OutPoint[k]);
												 if(GrindMeaDis<MinDis){
													 MinDis = GrindMeaDis;
													 GrindMarkOutCnt = k;
												 }
											 }

											 // GrindMark기준 수직 포인트 주변값 Avg산출한다 ==>가공량 측정(OutData기준)
											 if(GrindMarkOutCnt!=0 && GrindMarkOutCnt>5){
												 CircleCount=0,TotalCirDis=0.0f,GrindMeaDis=0.0f;
												 for(int k=GrindMarkOutCnt-5; k<GrindMarkOutCnt+5; k++){
													 if(OrgBtm1OutPoint[k].x==0.0f || OrgBtm1OutPoint[k].y==0.0f) continue;
													 if(k>=OrgBtm1OutEdgeCount                                  ) continue;

													 GrindMeaDis = Math.GetLength(GrindMarkPoint[2], OrgBtm1OutPoint[k]);
													 TotalCirDis+= GrindMeaDis;
													 CircleCount++;
												 }
												 if(TotalCirDis!=0.0f && CircleCount!=0){
													 BtmGrindMeasure1 = TotalCirDis/CircleCount;
													 BtmGrindMeasure1 = BtmGrindMeasure1+0.5; //SubPixel 
												 }
											 }
										 }

										 // Size 측정 목적으로 가공량만 산출한다 
										 if(GrindMarkPoint[16].x!=0.0f && GrindMarkPoint[16].y!=0.0f) { 
											 // GrindMark기준 OutData 최단거리 Count정보 Calc 
											 GrindMeaDis =0.0f, MinDis =10000.0f;  GrindMarkOutCnt=0;
											 for(int k=0; k<OrgBtm1OutEdgeCount; k++){
												 if(OrgBtm1OutPoint[k].x==0.0f || OrgBtm1OutPoint[k].y==0.0f) continue;
												 if(GrindMarkPoint[16].x ==0.0f || GrindMarkPoint[16].y ==0.0f) continue;

												 GrindMeaDis = Math.GetLength(GrindMarkPoint[16], OrgBtm1OutPoint[k]);
												 if(GrindMeaDis<MinDis){
													 MinDis = GrindMeaDis;
													 GrindMarkOutCnt = k;
												 }
											 }

											 // GrindMark기준 수직 포인트 주변값 Avg산출한다 ==>가공량 측정(OutData기준)
											 if(GrindMarkOutCnt!=0 && GrindMarkOutCnt>5){
												 CircleCount=0,TotalCirDis=0.0f,GrindMeaDis=0.0f;
												 for(int k=GrindMarkOutCnt-5; k<GrindMarkOutCnt+5; k++){
													 if(OrgBtm1OutPoint[k].x==0.0f || OrgBtm1OutPoint[k].y==0.0f) continue;
													 if(k>=OrgBtm1OutEdgeCount                                  ) continue;

													 GrindMeaDis = Math.GetLength(GrindMarkPoint[16], OrgBtm1OutPoint[k]);
													 TotalCirDis+= GrindMeaDis;
													 CircleCount++;
												 }
												 if(TotalCirDis!=0.0f && CircleCount!=0){
													 BtmGrindMeasure9 = TotalCirDis/CircleCount;
													 BtmGrindMeasure9 = BtmGrindMeasure9+0.5; //SubPixel 
												 }
											 }
										 }
										 // 동적 생성한 데이터를 지운다 
										 if(OrgBtm1InPoint !=NULL) delete[] OrgBtm1InPoint;
										 if(OrgBtm1OutPoint!=NULL) delete[] OrgBtm1OutPoint;
									 }
								 }
								 LogUnit.SetLog(L"CellID:%d, CamID:%d ==>Polygon_Insp_End",CellId,CamId);     
							 } // NOTCH shRectC
							 else if(FInspectMode==Insp_Mark || FInspectMode==Insp_Track){ // 연마안쪽,연마외곽 검출기준을 각각 ThresHold값 적용하여 진행함 
								 Circle->SetSamplingStep(1)                            ; // Circle Edge 간격 

								 // 첫번째 Circle EdgePoint Data 추출 
								 if(C1CirCenter.x!=0 && C1CirCenter.y!=0){
									 LogUnit.SetLog(L"Circle_1_Insp_Start");    

									 // 									 if(BtmEdgeThresHold==0) Circle->GImage = &RotateImg      ; //Org Image 넘겨줌 
									 // 									 else                    Circle->GImage = &RotateBinaryImg; //Binary Image 넘겨줌 

									 if(CirGrindInThresHold==0) Circle->GImage = &RotateImg             ; //Org Image 넘겨줌 
									 else                       Circle->GImage = &RotateGrindInBinaryImg; //Binary Image 넘겨줌 

									 if      (FInspectMode==Insp_Track) Circle->SetCenterXY(TrackC1CirCenter.x , TrackC1CirCenter.y); // TrackLine 교차점 기준 센터 
									 else if (FInspectMode==Insp_Mark ) Circle->SetCenterXY(C1CirCenter.x      , C1CirCenter.y     ); // 외곽라인 교차점 기준 센터 

									 // Diameter 계산함(OutCircle과 TrackCircle 중간값 기준)
									 // 									 C1Diameter = ((CSideCircleWidth*2)+(TrackCircleWidth*2))/2;
									 C1Diameter = (CSideCircleWidth*2);
									 // 									 C1Diameter = (CSideCircleWidth*2);
									 // 검사 영역으로 인해서 불량 미검출 발생할수 있음....LTPS와 EnCap분류함
									 if(IsMarkBtm) Circle->SetTolerance(60.0f);
									 else          Circle->SetTolerance(80.0f);
									 // 									 Circle->SetTolerance(40.0f )                              ; // Circle Tolerance 
									 Circle->SetDiameter (C1Diameter)                          ; // Circle Diameter 
									 // 									 Circle->SetCircleChoice(0)                                ; // 0:From Begin, 1:From End, 2:Largest Amplitude 
									 // 									 Circle->SetCircleIndex (0)                                ; // Circle EdgePoint Index 
									 Circle->SetCircleChoice(1)                                ; // 0:From Begin, 1:From End, 2:Largest Amplitude 
									 Circle->SetCircleType  (2)                                ; // 0:Black to White, 1:White to Black 2: Both Black, White 
									 Circle->SetCircleIndex (1)                                ; // Circle EdgePoint Index 

									 // Angle 및 Amplitude 설정 
									 if(SideCirDeg>=0){
										 Circle->SetAngle    (90+CirAngleMargin          );  // Circle Fitting 시작점 각도
										 Circle->SetAmplitude(SideCirDeg-2*CirAngleMargin);  // Circle Fitting 시작점 부터 검사 범위 
									 }

									 // Circle1 InData EdgePoint 
									 //////////////////////////////////////////////////////////////////////////////////////////////////////
									 Circle->OnExecute()                               ;

									 // Circle In Data 기준 새로운 Circle Center 좌표 받아옴 
									 RealC1CirCenter.x = Circle->FCP.x;
									 RealC1CirCenter.y = Circle->FCP.y;
									 CirDiameter1      = (Circle->Diameter)/2.0;

									 // Circle In Data취합 
									 OrgC1CirInEdgeCount = Circle->FCirclePointCount;
									 if(OrgC1CirInEdgeCount>0){
										 if(OrgC1CirInPoint!=NULL) delete[] OrgC1CirInPoint;
										 OrgC1CirInPoint = new TFPoint[OrgC1CirInEdgeCount];

										 for(int k=0; k<OrgC1CirInEdgeCount; k++){
											 if(k>MAX_CIRCLE_EDGEPOINT) break;
											 OrgC1CirInPoint[k].x = Circle->FCirclePoint[k].x;
											 OrgC1CirInPoint[k].y = Circle->FCirclePoint[k].y;
											 if(OrgC1CirInPoint[k].x==0.0f && OrgC1CirInPoint[k].y==0.0f) C1CirInEdgeCount++;
											 // BTM영역 Circle을 제외한 영역 Defect검사 목적에 좌표계산 
											 // 											 if(k==0) {BtmEdgePoint1.x = C1CirInPoint[k].x; BtmEdgePoint1.y = C1CirInPoint[k].y;}
										 }
									 }
									 //////////////////////////////////////////////////////////////////////////////////////////////////////

									 // Circle Out Data 다시 검사  
									 //////////////////////////////////////////////////////////////////////////////////////////////////////
									 if(BtmEdgeThresHold==0) Circle->GImage = &RotateImg      ; //Org Image 넘겨줌 
									 else                    Circle->GImage = &RotateBinaryImg; //Binary Image 넘겨줌 

									 // 검사 영역으로 인해서 불량 미검출 발생할수 있음....LTPS와 EnCap분류함
									 if(IsMarkBtm) Circle->SetTolerance(60.0f);
									 else          Circle->SetTolerance(80.0f);
									 // 									Circle->SetTolerance(40.0f )      ; // Circle Tolerance 
									 Circle->SetDiameter (C1Diameter)  ; // Circle Diameter 
									 Circle->SetCircleChoice(1)        ; // 0:From Begin, 1:From End, 2:Largest Amplitude 
									 Circle->SetCircleType(2)          ; // 0:Black to White, 1:White to Black 2: Both Black, White 
									 Circle->SetCircleIndex (0)        ; // Circle EdgePoint Index 
									 // Circle1 OutData EdgePoint 
									 /////////////////////////////////////////////////////////////////////////////////////////////////////////
									 Circle->OnExecute()               ;

									 // Circle Out Data취합 
									 OrgC1CirOutEdgeCount = Circle->FCirclePointCount;
									 if(OrgC1CirOutEdgeCount>0){
										 if(OrgC1CirOutPoint!=NULL) delete[] OrgC1CirOutPoint;
										 OrgC1CirOutPoint = new TFPoint[OrgC1CirOutEdgeCount];

										 for(int k=0; k<OrgC1CirOutEdgeCount; k++){
											 if(k>MAX_CIRCLE_EDGEPOINT) break;
											 OrgC1CirOutPoint[k].x = Circle->FCirclePoint[k].x;
											 OrgC1CirOutPoint[k].y = Circle->FCirclePoint[k].y;
											 // BTM영역 Circle을 제외한 영역 Defect검사 목적에 좌표계산 
											 if(k==0) {BtmEdgePoint[0].x = OrgC1CirOutPoint[k].x; BtmEdgePoint[0].y = OrgC1CirOutPoint[k].y;}
											 if(OrgC1CirOutPoint[k].x==0.0f && OrgC1CirOutPoint[k].y==0.0f) C1CirOutEdgeCount++;
										 }
									 }
									 // C1Circle Grind_Width Calculate 
									 // TrackMode CirInEdgePoint 기준과 CirOutEdgePoint 수직거리 산출
									 if(FInspectMode==Insp_Track){
										 // 연마량 계산 
										 if(OrgC1CirInEdgeCount==OrgC1CirOutEdgeCount){
											 double OutDis=0.0f, InDis=0.0f, TotalGrindWidth=0.0f, AvgGrindWidth=0.0f;C1GrindWidthCount=0;
											 for(int k=0; k<OrgC1CirInEdgeCount; k++){
												 if(OrgC1CirOutPoint[k].x==0.0f && OrgC1CirOutPoint[k].y==0.0f){
													 OutDis =0.0f;
												 }
												 else {
													 OutDis = Math.GetLengthFrPointToPoint(C1CirCenter,OrgC1CirOutPoint[k]);
												 }

												 if(OrgC1CirInPoint[k].x==0.0f && OrgC1CirInPoint[k].y==0.0f){
													 InDis =0.0f;
												 }
												 else {
													 InDis = Math.GetLengthFrPointToPoint(C1CirCenter,OrgC1CirInPoint[k]);
												 }

												 // CircleFitting 진행시 실제 EdgePoint 데이터가 존재 할 경우만 포함하여 계산한다
												 if(OutDis!=0.0f && InDis!=0.0f){
													 TotalGrindWidth+=(OutDis - InDis);
													 C1GrindWidthCount++;
												 }
											 }
											 if(C1GrindWidthCount!=0){
												 AvgGrindWidth = (TotalGrindWidth/C1GrindWidthCount);
												 C1CirGrindWd = AvgGrindWidth;
											 }
										 }
										 if(IsMarkBtm){ // 가공량 계산(TrackMode)==>LTPS
											 if(CirGrindMeaThresHold!=0){
												 Circle->GImage = &RotateGrindBinaryImg    ; //Binary Image 넘겨줌 
												 Circle->SetCircleChoice(1)                ; // 0:From Begin, 1:From End, 2:Largest Amplitude 
												 Circle->SetCircleType(2)                  ; // 0:Black to White, 1:White to Black 2: Both Black, White 
												 Circle->SetCircleIndex (1)                ; // Circle EdgePoint Index 
												 Circle->SetTolerance(40.0f )              ; // Circle Tolerance 
												 Circle->SetDiameter (C1Diameter)          ; // Circle Diameter 
												 Circle->OnExecute()                       ;

												 // Circle TrackLine Data 기준 새로운 Circle Center 좌표 받아옴 
												 // Circle Defect검사시 필요한 기준데이터 좌표 
												 RealC1CirCenter.x = Circle->FCP.x;
												 RealC1CirCenter.y = Circle->FCP.y;

												 OrgC1CirStandEdgeCount = Circle->FCirclePointCount;
												 if(OrgC1CirStandEdgeCount>0){
													 if(OrgC1CirStandPoint!=NULL) delete[] OrgC1CirStandPoint;
													 OrgC1CirStandPoint = new TFPoint[OrgC1CirStandEdgeCount];

													 PreC1CirStandPoint[0].x=0.0f; PreC1CirStandPoint[0].y=0.0f; 
													 for(int k=0; k<OrgC1CirStandEdgeCount; k++){
														 if(k>MAX_CIRCLE_EDGEPOINT) break;
														 OrgC1CirStandPoint[k].x = Circle->FCirclePoint[k].x;
														 OrgC1CirStandPoint[k].y = Circle->FCirclePoint[k].y;
														 if(OrgC1CirStandPoint[k].x==0.0f && OrgC1CirStandPoint[k].y==0.0f) C1CirStandEdgeCount++;
														 // TrackLine 자재 상태에 따라서 잘못된 EdgePoint를 찾을경우 대비하여 이전데이터 기준 데이터 복원 
														 if(OrgC1CirStandPoint[k].x!=0.0f && OrgC1CirStandPoint[k].y!=0.0f){
															 // 첫번째는 무조건 데이터 넘겨줌 
															 if(PreC1CirStandPoint[0].x==0.0f && PreC1CirStandPoint[0].y==0.0f){
																 PreC1CirStandPoint[0].x = OrgC1CirStandPoint[k].x; 
																 PreC1CirStandPoint[0].y = OrgC1CirStandPoint[k].y; 
															 }
															 else {
																 if(fabs(OrgC1CirStandPoint[k].x-PreC1CirStandPoint[0].x)>TrackLineMargin ||
																	 fabs(OrgC1CirStandPoint[k].y-PreC1CirStandPoint[0].y)>TrackLineMargin   ){
																		 OrgC1CirStandPoint[k].x = PreC1CirStandPoint[0].x-0.5;
																		 OrgC1CirStandPoint[k].y = PreC1CirStandPoint[0].y-0.5;

																		 PreC1CirStandPoint[0].x = OrgC1CirStandPoint[k].x; 
																		 PreC1CirStandPoint[0].y = OrgC1CirStandPoint[k].y; 
																 }
																 else {
																	 PreC1CirStandPoint[0].x = OrgC1CirStandPoint[k].x; 
																	 PreC1CirStandPoint[0].y = OrgC1CirStandPoint[k].y; 
																 }
															 }
														 }
													 }
													 //C1Circle Grind_Measure Calculate 
													 if(OrgC1CirOutEdgeCount==OrgC1CirStandEdgeCount){
														 double GrindMeaDis=0.0f, TotalGrindMeasure=0.0f, AvgGrindMeasure=0.0f;C1GrindMeasureCount=0;
														 double Degree =0.0f;
														 for(int k=0; k<OrgC1CirStandEdgeCount; k++){
															 if(OrgC1CirOutPoint[k].x==0.0f || OrgC1CirOutPoint[k].y==0.0f || OrgC1CirStandPoint[k].x==0.0f || OrgC1CirStandPoint[k].y==0.0f){
																 GrindMeaDis =0.0f;
															 }
															 else {
																 Degree = Math.GetDegree(OrgC1CirStandPoint[k],OrgC1CirOutPoint[k]);
																 GrindMeaDis = Math.GetLengthFrPointToPoint(OrgC1CirStandPoint[k],OrgC1CirOutPoint[k]);
															 }

															 if(GrindMeaDis!=0.0f){
																 TotalGrindMeasure+= GrindMeaDis;
																 C1GrindMeasureCount++;
															 }
														 }
														 if(C1GrindMeasureCount!=0){
															 AvgGrindMeasure = (TotalGrindMeasure/C1GrindMeasureCount);
															 C1CirGrindMea= AvgGrindMeasure;
														 }
													 }
													 else if(OrgC1CirStandEdgeCount>OrgC1CirOutEdgeCount) { // 연마가 적게되어 실제 TrackLine보다 EdgePoint데이터가 적을경우 
														 double GrindMeaDis=0.0f, TotalGrindMeasure=0.0f, AvgGrindMeasure=0.0f;C1GrindMeasureCount=0;
														 for(int k=0; k<OrgC1CirOutEdgeCount; k++){
															 if(OrgC1CirOutPoint[k].x==0.0f || OrgC1CirOutPoint[k].y==0.0f || OrgC1CirStandPoint[k].x==0.0f || OrgC1CirStandPoint[k].y==0.0f ){
																 GrindMeaDis =0.0f;
															 }
															 else {
																 GrindMeaDis = Math.GetLengthFrPointToPoint(OrgC1CirStandPoint[k],OrgC1CirOutPoint[k]);
															 }

															 if(GrindMeaDis!=0.0f){
																 TotalGrindMeasure+= GrindMeaDis;
																 C1GrindMeasureCount++;
															 }
														 }
														 if(C1GrindMeasureCount!=0){
															 AvgGrindMeasure = (TotalGrindMeasure/C1GrindMeasureCount);
															 C1CirGrindMea= AvgGrindMeasure;
														 }
													 }
													 else if(OrgC1CirStandEdgeCount<OrgC1CirOutEdgeCount){
														 double GrindMeaDis=0.0f, TotalGrindMeasure=0.0f, AvgGrindMeasure=0.0f;C1GrindMeasureCount=0;
														 // test 
														 double OutDegree=0.0f, TrackDegree=0.0f;
														 for(int k=0; k<OrgC1CirStandEdgeCount; k++){
															 if(OrgC1CirOutPoint[k].x==0.0f || OrgC1CirOutPoint[k].y==0.0f || OrgC1CirStandPoint[k].x==0.0f || OrgC1CirStandPoint[k].y==0.0f ){
																 GrindMeaDis =0.0f;
															 }
															 else {
																 OutDegree   = Math.GetDegree(TrackC1CirCenter, OrgC1CirOutPoint[k]  );
																 TrackDegree = Math.GetDegree(TrackC1CirCenter, OrgC1CirStandPoint[k]); 
																 GrindMeaDis = Math.GetLengthFrPointToPoint(OrgC1CirStandPoint[k],OrgC1CirOutPoint[k]);
															 }

															 if(GrindMeaDis!=0.0f){
																 TotalGrindMeasure+= GrindMeaDis;
																 C1GrindMeasureCount++;
															 }
														 }
														 if(C1GrindMeasureCount!=0){
															 AvgGrindMeasure = (TotalGrindMeasure/C1GrindMeasureCount);
															 C1CirGrindMea= AvgGrindMeasure;
														 }
													 }
												 }
											 }
										 }
									 }
									 else if(FInspectMode==Insp_Mark){ // MarkMode 
										 if(IsMarkBtm){ // LTPS경우 가공량 계산 ==> 연마량 계산 
											 if(OrgC1CirOutEdgeCount!=0 && OrgC1CirInEdgeCount!=0) { // MarkMode경우 가공량 검사를 먼저 진행 후 연마량 산출  
												 GrindMeaDis =0.0f, MinDis =10000.0f;C1GrindMarkCount=0;
												 if(GrindMarkPoint[1].x!=0.0f && GrindMarkPoint[1].y!=0.0f){ // Grind Mark 찾았을경우 
													 for(int k=0; k<OrgC1CirOutEdgeCount; k++){
														 if(OrgC1CirOutPoint[k].x==0.0f || OrgC1CirOutPoint[k].y==0.0f) continue;
														 if(GrindMarkPoint[1].x  ==0.0f || GrindMarkPoint[1].y  ==0.0f) continue;

														 GrindMeaDis = Math.GetLength(GrindMarkPoint[1], OrgC1CirOutPoint[k]);
														 if(GrindMeaDis<MinDis){
															 MinDis = GrindMeaDis;
															 C1GrindMarkCount = k;
														 }
													 }
													 // GrindMark기준 수직 포인트 주변값 Avg산출한다 ==>가공량 측정 
													 if(C1GrindMarkCount!=0 && C1GrindMarkCount>5){
														 CircleCount=0,TotalCirDis=0.0f,GrindMeaDis=0.0f;
														 for(int k=C1GrindMarkCount-5; k<C1GrindMarkCount+5; k++){
															 if(OrgC1CirOutPoint[k].x==0.0f || OrgC1CirOutPoint[k].y==0.0f) continue;
															 GrindMeaDis = Math.GetLength(GrindMarkPoint[1], OrgC1CirOutPoint[k]);
															 TotalCirDis+= GrindMeaDis;
															 CircleCount++;
														 }
														 if(TotalCirDis!=0.0f && CircleCount!=0){
															 C1CirGrindMea = TotalCirDis/CircleCount;
														 }
													 }

													 // GrindMark기준 수직 평균값 연마량 측정 
													 if(C1GrindMarkCount!=0 && C1GrindMarkCount>5){
														 CircleCount=0,TotalCirDis=0.0f,GrindWidthDis=0.0f;
														 for(int k=C1GrindMarkCount-5; k<C1GrindMarkCount+5; k++){
															 if(OrgC1CirOutPoint[k].x==0.0f && OrgC1CirOutPoint[k].y==0.0f) continue;
															 if(OrgC1CirInPoint [k].x==0.0f && OrgC1CirInPoint [k].y==0.0f) continue;

															 GrindWidthDis = Math.GetLength(OrgC1CirInPoint[k], OrgC1CirOutPoint[k]);
															 TotalCirDis+=   GrindWidthDis;
															 CircleCount++;
														 }
														 if(TotalCirDis!=0.0f && CircleCount!=0){
															 C1CirGrindWd = TotalCirDis/CircleCount;
														 }
													 }
												 }
												 else { // Grind Mark 못 찾았을경우 (가공량 0, 연마량 계산함)
													 for(int k=0; k<OrgC1CirOutEdgeCount; k++){
														 if(OrgC1CirOutPoint[k].x==0.0f || OrgC1CirOutPoint[k].y==0.0f) continue;

														 GrindMarkRectCenter[1].x = GrindMarkRect[1].left + (GrindMarkRect[1].right  - GrindMarkRect[1].left)/2; 
														 GrindMarkRectCenter[1].y = GrindMarkRect[1].top  + (GrindMarkRect[1].bottom - GrindMarkRect[1].top )/2; 

														 GrindMeaDis = Math.GetLength(GrindMarkRectCenter[1], OrgC1CirOutPoint[k]);
														 if(GrindMeaDis<MinDis){
															 MinDis = GrindMeaDis;
															 C1GrindMarkCount = k;
														 }
													 }
													 // GrindMark기준 수직 평균값 연마량 측정 
													 if(C1GrindMarkCount!=0 && C1GrindMarkCount>5){
														 CircleCount=0,TotalCirDis=0.0f,GrindWidthDis=0.0f;
														 for(int k=C1GrindMarkCount-5; k<C1GrindMarkCount+5; k++){
															 if(OrgC1CirOutPoint[k].x==0.0f && OrgC1CirOutPoint[k].y==0.0f) continue;
															 if(OrgC1CirInPoint [k].x==0.0f && OrgC1CirInPoint [k].y==0.0f) continue;
															 GrindWidthDis = Math.GetLength(OrgC1CirInPoint[k], OrgC1CirOutPoint[k]);
															 TotalCirDis+=   GrindWidthDis;
															 CircleCount++;
														 }
														 if(TotalCirDis!=0.0f && CircleCount!=0){
															 C1CirGrindWd = TotalCirDis/CircleCount;
														 }
													 }
												 }
											 }
										 }
										 else     { // MarkMode ==> EnCap경우 연마량만 계산한다 
											 if(OrgC1CirInEdgeCount==OrgC1CirOutEdgeCount){
												 double OutDis=0.0f, InDis=0.0f, TotalGrindWidth=0.0f, AvgGrindWidth=0.0f;C1GrindWidthCount=0;
												 for(int k=0; k<OrgC1CirInEdgeCount; k++){
													 if(OrgC1CirOutPoint[k].x==0.0f && OrgC1CirOutPoint[k].y==0.0f){
														 OutDis =0.0f;
													 }
													 else {
														 OutDis = Math.GetLengthFrPointToPoint(C1CirCenter,OrgC1CirOutPoint[k]);
													 }

													 if(OrgC1CirInPoint[k].x==0.0f && OrgC1CirInPoint[k].y==0.0f){
														 InDis =0.0f;
													 }
													 else {
														 InDis = Math.GetLengthFrPointToPoint(C1CirCenter,OrgC1CirInPoint[k]);
													 }

													 // CircleFitting 진행시 실제 EdgePoint 데이터가 존재 할 경우만 포함하여 계산한다
													 if(OutDis!=0.0f && InDis!=0.0f){
														 TotalGrindWidth+=(OutDis - InDis);
														 C1GrindWidthCount++;
													 }
												 }
												 if(C1GrindWidthCount!=0){
													 AvgGrindWidth = (TotalGrindWidth/C1GrindWidthCount);
													 C1CirGrindWd = AvgGrindWidth;
												 }
											 }
										 }
									 }
									 // C1 Grind Mark 기준 가공량 측정 시퀀스 종료  
									 //////////////////////////////////////////////////////////////////////////////////////////////////////

									 // Org Circle데이터중 유호하지 않은 값을 제외한 실제 존재하는 데이터 기준으로 동적 메모리 생성함
									 // Circle Defect검사에 필요한 Edge데이터 값
									 int Count=0;
									 if(OrgC1CirInEdgeCount>0){
										 C1CirInEdgeCount = OrgC1CirInEdgeCount - C1CirInEdgeCount;
										 // 										 C1CirInEdgeCount = OrgC1CirInEdgeCount;
										 if(C1CirInEdgeCount>0){
											 if(C1CirInPoint!=NULL) delete[] C1CirInPoint;
											 C1CirInPoint = new TFPoint[C1CirInEdgeCount];

											 for(int k=0; k<OrgC1CirInEdgeCount; k++){
												 if(k>MAX_CIRCLE_EDGEPOINT) break;
												 if(OrgC1CirInPoint[k].x==0.0f && OrgC1CirInPoint[k].y==0.0f) continue;
												 C1CirInPoint[Count].x = OrgC1CirInPoint[k].x;
												 C1CirInPoint[Count].y = OrgC1CirInPoint[k].y;
												 Count++;
											 }
										 }
										 // Circle 원본 데이터 메모리 삭제
										 if(OrgC1CirInPoint!=NULL) delete[] OrgC1CirInPoint;
									 }
									 // FAVION Circle Fitting 결과물 
									 SampleSize = C1CirInEdgeCount*0.75; //0.5~0.8이하로 입력할것
									 DistDevRatio = 0.15;                //0.1~0.25 이하로 입력할것
									 CircleFit->OnRansac(C1CirInPoint,C1CirInEdgeCount,SampleSize,DistDevRatio,&CircleFit1Center,&CirFitDiameter1);

									 if(OrgC1CirOutEdgeCount>0){
										 C1CirOutEdgeCount = OrgC1CirOutEdgeCount - C1CirOutEdgeCount;
										 C1CirOutEdgeCount = OrgC1CirOutEdgeCount;
										 Count =0;
										 if(C1CirOutEdgeCount>0){
											 if(C1CirOutPoint!=NULL) delete[] C1CirOutPoint;
											 C1CirOutPoint = new TFPoint[C1CirOutEdgeCount];

											 for(int k=0; k<OrgC1CirOutEdgeCount; k++){
												 if(k>MAX_CIRCLE_EDGEPOINT) break;
												 if(OrgC1CirOutPoint[k].x==0.0f && OrgC1CirOutPoint[k].y==0.0f) continue;
												 C1CirOutPoint[Count].x = OrgC1CirOutPoint[k].x;
												 C1CirOutPoint[Count].y = OrgC1CirOutPoint[k].y;
												 Count++;
											 }
										 }
										 // Circle 원본 데이터 메모리 삭제
										 if(OrgC1CirOutPoint!=NULL) delete[] OrgC1CirOutPoint;
									 }
									 if(OrgC1CirStandEdgeCount>0){
										 C1CirStandEdgeCount = OrgC1CirStandEdgeCount - C1CirStandEdgeCount;
										 // 										 C1CirStandEdgeCount = OrgC1CirStandEdgeCount;
										 Count =0;
										 if(C1CirStandEdgeCount>0){
											 if(C1CirStandPoint!=NULL) delete[] C1CirStandPoint;
											 C1CirStandPoint = new TFPoint[C1CirStandEdgeCount];

											 for(int k=0; k<OrgC1CirStandEdgeCount; k++){
												 if(k>MAX_CIRCLE_EDGEPOINT) break;
												 if(OrgC1CirStandPoint[k].x==0.0f && OrgC1CirStandPoint[k].y==0.0f) continue;
												 C1CirStandPoint[Count].x = OrgC1CirStandPoint[k].x;
												 C1CirStandPoint[Count].y = OrgC1CirStandPoint[k].y;
												 Count++;
											 }
										 }
										 // Circle 원본 데이터 메모리 삭제
										 if(OrgC1CirStandPoint!=NULL) delete[] OrgC1CirStandPoint;
									 }
									 LogUnit.SetLog(L"Circle_1_Insp_End");   

									 // Circle 영역 꽃박리, 원형박리 검출 목적 시퀀스(EnCap)
									 // 정식 명칭은 몰라서.....일단 Crack으로 정함 
									 if(!IsMarkBtm && BrokenThresHold!=0){
										 RotateBrokenImg.SetSize(RotateImg.GetWidth(), RotateImg.GetHeight());
										 EasyImage::Oper(EArithmeticLogicOperation_Copy,&RotateImg,&RotateBrokenImg);

										 EasyImage::Threshold(&RotateImg,&RotateBrokenImg,BrokenThresHold);                 //박리 검사 목적 이미지 변환
										 //										 RotateBrokenImg.Save("D:\\ROTATE_IMG\\RotateBrokenImg_CUP.bmp");

										 if(CirFitDiameter1!=0.0f && CircleFit1Center.x!=0.0f && CircleFit1Center.y!=0.0f){ // FAVION Circle Fitting 성공시 박리검사 진행 
											 Circle->GImage = &RotateBrokenImg;                                             //Binary Image 넘겨줌 

											 Circle->SetCenterXY(CircleFit1Center.x,CircleFit1Center.y)      ;
											 Circle->SetTolerance((dEdgeToTrapLineDis/2)-CirOffsetMargin)    ; // Circle Tolerance 
											 Circle->SetDiameter ((CirFitDiameter1-(dEdgeToTrapLineDis/2))*2); // Circle Diameter 
											 Circle->SetCircleChoice(0)                                      ; // 0:From Begin, 1:From End, 2:Largest Amplitude 
											 Circle->SetCircleType  (2)                                      ; // 0:Black to White, 1:White to Black 2: Both Black, White 
											 Circle->SetCircleIndex (0)                                      ; // Circle EdgePoint Index 
											 Circle->OnExecute(true)                                         ;
											 CrackCirDiameter1 = (CirFitDiameter1-(dEdgeToTrapLineDis/2))+((dEdgeToTrapLineDis/2)-CirOffsetMargin);

											 C1CirInCrackCount = Circle->FCirclePointCount;

											 if(C1CirInCrackCount>0){
												 if(C1CirInCrackPoint!=NULL) delete[] C1CirInCrackPoint;
												 C1CirInCrackPoint = new TFPoint[C1CirInCrackCount];

												 for(int k=0; k<C1CirInCrackCount; k++){
													 if(k>MAX_CIRCLE_EDGEPOINT) break;
													 C1CirInCrackPoint[k].x = Circle->FCirclePoint[k].x;
													 C1CirInCrackPoint[k].y = Circle->FCirclePoint[k].y;
												 }
											 }
										 }
									 }
								 }

								 // 두번째 Circle EdgePoint Data 추출 
								 if(C2CirCenter.x!=0 && C2CirCenter.y!=0){
									 LogUnit.SetLog(L"Circle_2_Insp_Start");    

									 // 									 if(BtmEdgeThresHold==0) Circle->GImage = &RotateImg      ; //Org Image 넘겨줌 
									 // 									 else                    Circle->GImage = &RotateBinaryImg; //Binary Image 넘겨줌 
									 if(CirGrindInThresHold==0) Circle->GImage = &RotateImg             ; //Org Image 넘겨줌 
									 else                       Circle->GImage = &RotateGrindInBinaryImg; //Binary Image 넘겨줌 

									 if      (FInspectMode==Insp_Track) Circle->SetCenterXY(TrackC2CirCenter.x , TrackC2CirCenter.y); // TrackLine 교차점 기준 센터 
									 else if (FInspectMode==Insp_Mark ) Circle->SetCenterXY(C2CirCenter.x      , C2CirCenter.y     ); // 외곽라인 교차점 기준 센터 

									 // Diameter 계산함(OutCircle과 TrackCircle 중간값 기준)
									 // 									 C2Diameter = (CenterCircleHeight*2);
									 C2Diameter = ((CenterCircleHeight*2)+((CenterCircleHeight-OutToTrackLineDis)*2))/2;
									 // 검사 영역으로 인해서 불량 미검출 발생할수 있음....LTPS와 EnCap분류함
									 if(IsMarkBtm) Circle->SetTolerance(60.0f);
									 else          Circle->SetTolerance(80.0f);
									 // 									 Circle->SetTolerance(40.0f )                      ; // Circle Tolerance 
									 Circle->SetDiameter (C2Diameter)                  ; // Circle Diameter 
									 Circle->SetCircleChoice(1)                        ; // 0:From Begin, 1:From End, 2:Largest Amplitude 
									 Circle->SetCircleType  (2)                        ; // 0:Black to White, 1:White to Black 2: Both Black, White 
									 Circle->SetCircleIndex (1)                        ; // Circle EdgePoint Index 

									 if(CenterCirDeg>=0){
										 CenterCirDeg = (CenterCirDeg==0)? 90:CenterCirDeg;
										 // 										 if(90-CenterCirDeg>=0) Circle->SetAngle    (90-CenterCirDeg+CirAngleMargin);   // Circle Fitting 시작점 각도
										 // 										                        Circle->SetAmplitude(CenterCirDeg-2*CirAngleMargin );  // Circle Fitting 시작점 부터 검사 범위 
										 if(90-CenterCirDeg>=0) Circle->SetAngle    (90-CenterCirDeg);   // Circle Fitting 시작점 각도
										 Circle->SetAmplitude(CenterCirDeg   );  // Circle Fitting 시작점 부터 검사 범위 

									 }
									 // 									 Circle->SetCircleType(1)                          ; // 0:Black to White, 1:White to Black 2: Both Black, White 
									 Circle->OnExecute()                               ;

									 // Circle In Data 기준 새로운 Circle Center 좌표 받아옴 
									 RealC2CirCenter.x = Circle->FCP.x   ;
									 RealC2CirCenter.y = Circle->FCP.y   ;
									 CirDiameter2      = (Circle->Diameter)/2.0;

									 // Circle In Data취합 
									 OrgC2CirInEdgeCount = Circle->FCirclePointCount;
									 if(OrgC2CirInEdgeCount>0){
										 if(OrgC2CirInPoint!=NULL) delete[] OrgC2CirInPoint;
										 OrgC2CirInPoint = new TFPoint[OrgC2CirInEdgeCount];

										 for(int k=0; k<OrgC2CirInEdgeCount; k++){
											 if(k>MAX_CIRCLE_EDGEPOINT) break;
											 OrgC2CirInPoint[k].x = Circle->FCirclePoint[k].x;
											 OrgC2CirInPoint[k].y = Circle->FCirclePoint[k].y;
											 if(OrgC2CirInPoint[k].x==0.0f && OrgC2CirInPoint[k].y==0.0f) C2CirInEdgeCount++;
											 // BTM영역 Circle을 제외한 영역 Defect검사 목적에 좌표계산 
											 // 											 if(k==0) {BtmEdgePoint1.x = C1CirInPoint[k].x; BtmEdgePoint1.y = C1CirInPoint[k].y;}
										 }
									 }

									 // Circle Out Data목적 다시 검사  
									 if(BtmEdgeThresHold==0) Circle->GImage = &RotateImg      ; //Org Image 넘겨줌 
									 else                    Circle->GImage = &RotateBinaryImg; //Binary Image 넘겨줌 

									 // 검사 영역으로 인해서 불량 미검출 발생할수 있음....LTPS와 EnCap분류함
									 if(IsMarkBtm) Circle->SetTolerance(60.0f);
									 else          Circle->SetTolerance(80.0f);
									 // 									Circle->SetTolerance(40.0f )                      ; // Circle Tolerance 
									 Circle->SetDiameter (C2Diameter)                  ; // Circle Diameter 
									 Circle->SetCircleChoice(1)                        ; // 0:From Begin, 1:From End, 2:Largest Amplitude 
									 Circle->SetCircleType  (2)                        ; // 0:Black to White, 1:White to Black 2: Both Black, White 
									 Circle->SetCircleIndex (0)                        ; // Circle EdgePoint Index 
									 Circle->OnExecute()                               ;

									 // Circle Out Data취합 
									 OrgC2CirOutEdgeCount = Circle->FCirclePointCount;
									 if(OrgC2CirOutEdgeCount>0){
										 if(OrgC2CirOutPoint!=NULL) delete[] OrgC2CirOutPoint;
										 OrgC2CirOutPoint = new TFPoint[OrgC2CirOutEdgeCount];

										 for(int k=0; k<OrgC2CirOutEdgeCount; k++){
											 if(k>MAX_CIRCLE_EDGEPOINT) break;
											 OrgC2CirOutPoint[k].x = Circle->FCirclePoint[k].x;
											 OrgC2CirOutPoint[k].y = Circle->FCirclePoint[k].y;
											 // BTM영역 Circle을 제외한 영역 Defect검사 목적에 좌표계산 
											 if(k==(OrgC2CirOutEdgeCount-1)) {BtmEdgePoint[1].x = OrgC2CirOutPoint[k].x; BtmEdgePoint[1].y = OrgC2CirOutPoint[k].y;}
											 if(k==0                       ) {BtmEdgePoint[2].x = OrgC2CirOutPoint[k].x; BtmEdgePoint[2].y = OrgC2CirOutPoint[k].y;}
											 if(OrgC2CirOutPoint[k].x==0.0f && OrgC2CirOutPoint[k].y==0.0f) C2CirOutEdgeCount++;
										 }
									 }
									 // C2Circle Grind_Width, Grind_Measure 
									 // C2Circle 연마량 가공량 검사 시퀀스(TrackMode VS MarkMode)
									 if(FInspectMode==Insp_Track){
										 if(OrgC2CirInEdgeCount==OrgC2CirOutEdgeCount){// 연마량 계산(LTPS, EnCap)
											 double OutDis=0.0f, InDis=0.0f, TotalGrindWidth=0.0f, AvgGrindWidth=0.0f;C2GrindWidthCount=0;
											 for(int k=0; k<OrgC2CirInEdgeCount; k++){
												 if(OrgC2CirOutPoint[k].x==0.0f && OrgC2CirOutPoint[k].y==0.0f){
													 OutDis =0.0f;
												 }
												 else {
													 OutDis = Math.GetLengthFrPointToPoint(C2CirCenter,OrgC2CirOutPoint[k]);
												 }

												 if(OrgC2CirInPoint[k].x==0.0f && OrgC2CirInPoint[k].y==0.0f){
													 InDis =0.0f;
												 }
												 else {
													 InDis = Math.GetLengthFrPointToPoint(C2CirCenter,OrgC2CirInPoint[k]);
												 }

												 if(OutDis!=0.0f && InDis!=0.0f){
													 TotalGrindWidth+=(OutDis - InDis);
													 C2GrindWidthCount++;
												 }
											 }
											 if(C2GrindWidthCount!=0){
												 AvgGrindWidth = (TotalGrindWidth/C2GrindWidthCount);
												 C2CirGrindWd = AvgGrindWidth;
											 }
										 }
										 if(IsMarkBtm){ // LTPS일경우만 가공량 계산 
											 if(CirGrindMeaThresHold!=0){
												 Circle->GImage = &RotateGrindBinaryImg; //Binary Image 넘겨줌 
												 Circle->SetCircleChoice(1)                ; // 0:From Begin, 1:From End, 2:Largest Amplitude 
												 Circle->SetCircleType(2)                  ; // 0:Black to White, 1:White to Black 2: Both Black, White 
												 Circle->SetCircleIndex (1)                ; // Circle EdgePoint Index 
												 Circle->SetTolerance(40.0f )              ; // Circle Tolerance 
												 Circle->SetDiameter (C2Diameter)          ; // Circle Diameter 
												 Circle->OnExecute()                       ;

												 // Circle In Data 기준 새로운 Circle Center 좌표 받아옴 
												 RealC2CirCenter.x = Circle->FCP.x;
												 RealC2CirCenter.y = Circle->FCP.y;

												 OrgC2CirStandEdgeCount = Circle->FCirclePointCount;
												 if(OrgC2CirStandEdgeCount>0){
													 if(OrgC2CirStandPoint!=NULL) delete[] OrgC2CirStandPoint;
													 OrgC2CirStandPoint = new TFPoint[OrgC2CirStandEdgeCount];

													 PreC2CirStandPoint[0].x=0.0f; PreC2CirStandPoint[0].y=0.0f;
													 for(int k=0; k<OrgC2CirStandEdgeCount; k++){
														 if(k>MAX_CIRCLE_EDGEPOINT) break;
														 OrgC2CirStandPoint[k].x = Circle->FCirclePoint[k].x;
														 OrgC2CirStandPoint[k].y = Circle->FCirclePoint[k].y;
														 if(OrgC2CirStandPoint[k].x==0.0f && OrgC2CirStandPoint[k].y==0.0f)C2CirStandEdgeCount++;
														 // TrackLine 자재 상태에 따라서 잘못된 EdgePoint를 찾을경우 대비하여 이전데이터 기준 데이터 복원 
														 if(OrgC2CirStandPoint[k].x!=0.0f && OrgC2CirStandPoint[k].y!=0.0f){
															 // 첫번째는 무조건 데이터 넘겨줌 
															 if(PreC2CirStandPoint[0].x==0.0f && PreC2CirStandPoint[0].y==0.0f){
																 PreC2CirStandPoint[0].x = OrgC2CirStandPoint[k].x; 
																 PreC2CirStandPoint[0].y = OrgC2CirStandPoint[k].y; 
															 }
															 else {
																 if(fabs (OrgC2CirStandPoint[k].x-PreC2CirStandPoint[0].x)>TrackLineMargin ||
																	 fabs(OrgC2CirStandPoint[k].y-PreC2CirStandPoint[0].y)>TrackLineMargin   ){
																		 OrgC2CirStandPoint[k].x = PreC2CirStandPoint[0].x-0.5;
																		 OrgC2CirStandPoint[k].y = PreC2CirStandPoint[0].y+0.5;

																		 PreC2CirStandPoint[0].x = OrgC2CirStandPoint[k].x; 
																		 PreC2CirStandPoint[0].y = OrgC2CirStandPoint[k].y; 
																 }
																 else {
																	 PreC2CirStandPoint[0].x = OrgC2CirStandPoint[k].x; 
																	 PreC2CirStandPoint[0].y = OrgC2CirStandPoint[k].y; 
																 }
															 }
														 }
													 }
													 //C1Circle Grind_Measure Calculate 
													 if(OrgC2CirOutEdgeCount==OrgC2CirStandEdgeCount){
														 double GrindMeaDis=0.0f, TotalGrindMeasure=0.0f, AvgGrindMeasure=0.0f;C2GrindMeasureCount=0;
														 for(int k=0; k<OrgC2CirStandEdgeCount; k++){
															 if(OrgC2CirOutPoint[k].x==0.0f || OrgC2CirOutPoint[k].y==0.0f || OrgC2CirStandPoint[k].x==0.0f || OrgC2CirStandPoint[k].y==0.0f){
																 GrindMeaDis =0.0f;
															 }
															 else {
																 GrindMeaDis = Math.GetLengthFrPointToPoint(OrgC2CirStandPoint[k],OrgC2CirOutPoint[k]);
															 }

															 if(GrindMeaDis!=0.0f){
																 TotalGrindMeasure+= GrindMeaDis;
																 C2GrindMeasureCount++;
															 }
														 }
														 if(C2GrindMeasureCount!=0){
															 AvgGrindMeasure = (TotalGrindMeasure/C2GrindMeasureCount);
															 C2CirGrindMea= AvgGrindMeasure;
														 }
													 }
													 else if(OrgC2CirStandEdgeCount>OrgC2CirOutEdgeCount) { // 연마가 적게되어 실제 TrackLine보다 EdgePoint데이터가 적을경우 
														 double GrindMeaDis=0.0f, TotalGrindMeasure=0.0f, AvgGrindMeasure=0.0f;C2GrindMeasureCount=0;
														 for(int k=0; k<OrgC2CirOutEdgeCount; k++){
															 if(OrgC2CirOutPoint[k].x==0.0f || OrgC2CirOutPoint[k].y==0.0f || OrgC2CirStandPoint[k].x==0.0f || OrgC2CirStandPoint[k].y==0.0f ){
																 GrindMeaDis =0.0f;
															 }
															 else {
																 GrindMeaDis = Math.GetLengthFrPointToPoint(OrgC2CirStandPoint[k],OrgC2CirOutPoint[k]);
															 }

															 if(GrindMeaDis!=0.0f){
																 TotalGrindMeasure+= GrindMeaDis;
																 C2GrindMeasureCount++;
															 }
														 }
														 if(C2GrindMeasureCount!=0){
															 AvgGrindMeasure = (TotalGrindMeasure/C2GrindMeasureCount);
															 C2CirGrindMea= AvgGrindMeasure;
														 }
													 }
													 else if(OrgC2CirStandEdgeCount<OrgC2CirOutEdgeCount){
														 double GrindMeaDis=0.0f, TotalGrindMeasure=0.0f, AvgGrindMeasure=0.0f;C2GrindMeasureCount=0;
														 for(int k=0; k<OrgC2CirStandEdgeCount; k++){
															 if(OrgC2CirOutPoint[k].x==0.0f || OrgC2CirOutPoint[k].y==0.0f || OrgC2CirStandPoint[k].x==0.0f || OrgC2CirStandPoint[k].y==0.0f ){
																 GrindMeaDis =0.0f;
															 }
															 else {
																 GrindMeaDis = Math.GetLengthFrPointToPoint(OrgC2CirStandPoint[k],OrgC2CirOutPoint[k]);
															 }

															 if(GrindMeaDis!=0.0f){
																 TotalGrindMeasure+= GrindMeaDis;
																 C2GrindMeasureCount++;
															 }
														 }
														 if(C2GrindMeasureCount!=0){
															 AvgGrindMeasure = (TotalGrindMeasure/C2GrindMeasureCount);
															 C2CirGrindMea= AvgGrindMeasure;
														 }
													 }
												 }
											 }
										 }
									 }
									 else if(FInspectMode==Insp_Mark){ // MarkMode 
										 if(IsMarkBtm){ // LTPS 가공량 계산 ==> 연마량 계산 
											 if(OrgC2CirOutEdgeCount!=0 && OrgC2CirInEdgeCount!=0){ // 연마량이 존재할경우 가공량 검사를 진행함 
												 // 가공량,연마량 측정 전 데이터 존재시 가상GrindMark 생성한다 
												 if(GrindMarkPoint[5].x!=0.0f && GrindMarkPoint[5].y!=0.0f){
													 GrindMarkPoint[6].x     = GrindMarkPoint[5].x + GrindRectSpec[6].DvX;
													 GrindMarkPoint[6].y     = GrindMarkPoint[5].y - GrindRectSpec[6].DvY;
													 GrindMarkRect [6].left  = GrindMarkPoint[6].x    - GrindMarkRange  ;  
													 GrindMarkRect [6].top   = GrindMarkPoint[6].y    - GrindMarkRange  ;  
													 GrindMarkRect [6].right = GrindMarkRect [6].left + GrindMarkLength ;  
													 GrindMarkRect [6].bottom= GrindMarkRect [6].top  + GrindMarkLength ;  
												 }

												 // GrindMarkPoint5 Calc 진행함(연마량,가공량)
												 if(GrindMarkPoint[5].x!=0.0f && GrindMarkPoint[5].y!=0.0f){
													 GrindMeaDis =0.0f, MinDis =10000.0f;C2GrindMarkCount=0;
													 for(int k=0; k<OrgC2CirOutEdgeCount; k++){
														 if(OrgC2CirOutPoint[k].x==0.0f || OrgC2CirOutPoint[k].y==0.0f) continue;
														 if(GrindMarkPoint[5].x  ==0.0f || GrindMarkPoint[5].y  ==0.0f) continue;

														 GrindMeaDis = Math.GetLength(GrindMarkPoint[5], OrgC2CirOutPoint[k]);
														 if(GrindMeaDis<MinDis){
															 MinDis = GrindMeaDis;
															 C2GrindMarkCount = k;
														 }
													 }
													 // GrindMark기준 수직 포인트 주변값 Avg산출한다 
													 if(C2GrindMarkCount!=0 && C2GrindMarkCount>5){
														 CircleCount=0,TotalCirDis=0.0f,GrindMeaDis=0.0f;
														 for(int k=C2GrindMarkCount-5; k<C2GrindMarkCount+5; k++){
															 if(OrgC2CirOutPoint[k].x==0.0f || OrgC2CirOutPoint[k].y==0.0f) continue;

															 GrindMeaDis = Math.GetLength(GrindMarkPoint[5], OrgC2CirOutPoint[k]);
															 TotalCirDis+= GrindMeaDis;
															 CircleCount++;
														 }
														 if(TotalCirDis!=0.0f && CircleCount!=0){
															 C2CirGrindMea = TotalCirDis/CircleCount;
														 }
													 }
													 // GrindMark기준 수직 평균값 연마량 측정 
													 if(C2GrindMarkCount!=0 && C2GrindMarkCount>5){
														 CircleCount=0,TotalCirDis=0.0f,GrindWidthDis=0.0f;
														 for(int k=C2GrindMarkCount-5; k<C2GrindMarkCount+5; k++){
															 if(OrgC2CirOutPoint[k].x==0.0f && OrgC2CirOutPoint[k].y==0.0f) continue;
															 if(OrgC2CirInPoint [k].x==0.0f && OrgC2CirInPoint [k].y==0.0f) continue;
															 GrindWidthDis = Math.GetLength(OrgC2CirInPoint[k], OrgC2CirOutPoint[k]);
															 TotalCirDis+=   GrindWidthDis;
															 CircleCount++;
														 }
														 if(TotalCirDis!=0.0f && CircleCount!=0){
															 C2CirGrindWd = TotalCirDis/CircleCount;
														 }
													 }
												 }
												 else { // Grind Mark 못 찾았을경우 (가공량 0, 연마량 계산함)
													 GrindMeaDis =0.0f, MinDis =10000.0f;C2GrindMarkCount=0;
													 for(int k=0; k<OrgC2CirOutEdgeCount; k++){
														 if(OrgC2CirOutPoint[k].x==0.0f || OrgC2CirOutPoint[k].y==0.0f) continue;

														 GrindMarkRectCenter[5].x = GrindMarkRect[5].left + (GrindMarkRect[5].right  - GrindMarkRect[5].left)/2; 
														 GrindMarkRectCenter[5].y = GrindMarkRect[5].top  + (GrindMarkRect[5].bottom - GrindMarkRect[5].top )/2; 

														 GrindMeaDis = Math.GetLength(GrindMarkRectCenter[5], OrgC2CirOutPoint[k]);
														 if(GrindMeaDis<MinDis){
															 MinDis = GrindMeaDis;
															 C2GrindMarkCount = k;
														 }
													 }
													 // GrindMark기준 수직 평균값 연마량 측정 
													 if(C2GrindMarkCount!=0 && C2GrindMarkCount>5){
														 CircleCount=0,TotalCirDis=0.0f,GrindWidthDis=0.0f;
														 for(int k=C2GrindMarkCount-5; k<C2GrindMarkCount+5; k++){
															 if(OrgC2CirOutPoint[k].x==0.0f && OrgC2CirOutPoint[k].y==0.0f) continue;
															 if(OrgC2CirInPoint [k].x==0.0f && OrgC2CirInPoint [k].y==0.0f) continue;
															 GrindWidthDis = Math.GetLength(OrgC2CirInPoint[k], OrgC2CirOutPoint[k]);
															 TotalCirDis+=   GrindWidthDis;
															 CircleCount++;
														 }
														 if(TotalCirDis!=0.0f && CircleCount!=0){
															 C2CirGrindWd = TotalCirDis/CircleCount;
														 }
													 }
												 }

												 // GrindMarkPoint6 Calc 진행함(연마량,가공량)
												 if(GrindMarkPoint[6].x!=0.0f && GrindMarkPoint[6].y!=0.0f){
													 GrindMeaDis =0.0f, MinDis =10000.0f;C2GrindMarkCount=0;
													 for(int k=0; k<OrgC2CirOutEdgeCount; k++){
														 if(OrgC2CirOutPoint[k].x==0.0f || OrgC2CirOutPoint[k].y==0.0f) continue;
														 if(GrindMarkPoint[6].x  ==0.0f || GrindMarkPoint[6].y  ==0.0f) continue;

														 GrindMeaDis = Math.GetLength(GrindMarkPoint[6], OrgC2CirOutPoint[k]);
														 if(GrindMeaDis<MinDis){
															 MinDis = GrindMeaDis;
															 C2GrindMarkCount = k;
														 }
													 }
													 // GrindMark기준 수직 포인트 주변값 Avg산출한다 
													 if(C2GrindMarkCount!=0 && C2GrindMarkCount>5 && (C2GrindMarkCount+5)<OrgC2CirOutEdgeCount){
														 CircleCount=0,TotalCirDis=0.0f,GrindMeaDis=0.0f;
														 for(int k=C2GrindMarkCount-5; k<C2GrindMarkCount+5; k++){
															 if(OrgC2CirOutPoint[k].x==0.0f || OrgC2CirOutPoint[k].y==0.0f) continue;

															 GrindMeaDis = Math.GetLength(GrindMarkPoint[6], OrgC2CirOutPoint[k]);
															 TotalCirDis+= GrindMeaDis;
															 CircleCount++;
														 }
														 if(TotalCirDis!=0.0f && CircleCount!=0){
															 TrenchLeftGrindMea = TotalCirDis/CircleCount;
														 }
													 }
													 // GrindMark기준 수직 평균값 연마량 측정 
													 if(C2GrindMarkCount!=0 && C2GrindMarkCount>5 && (C2GrindMarkCount+5)<OrgC2CirOutEdgeCount){
														 CircleCount=0,TotalCirDis=0.0f,GrindWidthDis=0.0f;
														 for(int k=C2GrindMarkCount-5; k<C2GrindMarkCount+5; k++){
															 if(OrgC2CirOutPoint[k].x==0.0f && OrgC2CirOutPoint[k].y==0.0f) continue;
															 if(OrgC2CirInPoint [k].x==0.0f && OrgC2CirInPoint [k].y==0.0f) continue;
															 GrindWidthDis = Math.GetLength(OrgC2CirInPoint[k], OrgC2CirOutPoint[k]);
															 TotalCirDis+=   GrindWidthDis;
															 CircleCount++;
														 }
														 if(TotalCirDis!=0.0f && CircleCount!=0){
															 TrenchLeftGrindWd = TotalCirDis/CircleCount;
														 }
													 }
												 }
												 else { // Grind Mark 못 찾았을경우 (가공량 0, 연마량 계산함)
													 GrindMeaDis =0.0f, MinDis =10000.0f;C2GrindMarkCount=0;
													 for(int k=0; k<OrgC2CirOutEdgeCount; k++){
														 if(OrgC2CirOutPoint[k].x==0.0f || OrgC2CirOutPoint[k].y==0.0f) continue;

														 if(k==0){
															 GrindMarkRectCenter[6].x     =  GrindMarkRectCenter[5].x + GrindRectSpec[6].DvX;
															 GrindMarkRectCenter[6].y     =  GrindMarkRectCenter[5].y - GrindRectSpec[6].DvY;

															 GrindMarkRect [6].left  = GrindMarkRectCenter[6].x  - GrindMarkRange  ;  
															 GrindMarkRect [6].top   = GrindMarkRectCenter[6].y  - GrindMarkRange  ;  
															 GrindMarkRect [6].right = GrindMarkRect [6].left + GrindMarkLength ;  
															 GrindMarkRect [6].bottom= GrindMarkRect [6].top  + GrindMarkLength ;  
														 }

														 // 														GrindMarkRectPoint2.x = GrindMarkRect[6].left + (GrindMarkRect[6].right  - GrindMarkRect[6].left)/2; 
														 // 														GrindMarkRectPoint2.y = GrindMarkRect[6].top  + (GrindMarkRect[6].bottom - GrindMarkRect[6].top )/2; 

														 GrindMeaDis = Math.GetLength(GrindMarkRectCenter[6], OrgC2CirOutPoint[k]);
														 if(GrindMeaDis<MinDis){
															 MinDis = GrindMeaDis;
															 C2GrindMarkCount = k;
														 }
													 }
													 // GrindMark기준 수직 평균값 연마량 측정 
													 if(C2GrindMarkCount!=0 && C2GrindMarkCount>5 && (C2GrindMarkCount+5)<OrgC2CirOutEdgeCount){
														 CircleCount=0,TotalCirDis=0.0f,GrindWidthDis=0.0f;
														 for(int k=C2GrindMarkCount-5; k<C2GrindMarkCount+5; k++){
															 if(OrgC2CirOutPoint[k].x==0.0f && OrgC2CirOutPoint[k].y==0.0f) continue;
															 if(OrgC2CirInPoint [k].x==0.0f && OrgC2CirInPoint [k].y==0.0f) continue;
															 GrindWidthDis = Math.GetLength(OrgC2CirInPoint[k], OrgC2CirOutPoint[k]);
															 TotalCirDis+=   GrindWidthDis;
															 CircleCount++;
														 }
														 if(TotalCirDis!=0.0f && CircleCount!=0){
															 TrenchLeftGrindWd = TotalCirDis/CircleCount;
														 }
													 }
												 }
											 }
										 }
										 else         { // EnCap 연마량만 계산 
											 if(OrgC2CirInEdgeCount==OrgC2CirOutEdgeCount){
												 double OutDis=0.0f, InDis=0.0f, TotalGrindWidth=0.0f, AvgGrindWidth=0.0f;C2GrindWidthCount=0;
												 for(int k=0; k<OrgC2CirInEdgeCount; k++){
													 if(OrgC2CirOutPoint[k].x==0.0f && OrgC2CirOutPoint[k].y==0.0f){
														 OutDis =0.0f;
													 }
													 else {
														 OutDis = Math.GetLengthFrPointToPoint(C2CirCenter,OrgC2CirOutPoint[k]);
													 }

													 if(OrgC2CirInPoint[k].x==0.0f && OrgC2CirInPoint[k].y==0.0f){
														 InDis =0.0f;
													 }
													 else {
														 InDis = Math.GetLengthFrPointToPoint(C2CirCenter,OrgC2CirInPoint[k]);
													 }

													 if(OutDis!=0.0f && InDis!=0.0f){
														 TotalGrindWidth+=(OutDis - InDis);
														 C2GrindWidthCount++;
													 }
												 }
												 if(C2GrindWidthCount!=0){
													 AvgGrindWidth = (TotalGrindWidth/C2GrindWidthCount);
													 C2CirGrindWd = AvgGrindWidth;
												 }
											 }
										 }
									 }

									 // Org Circle데이터중 유호하지 않은 값을 제외한 실제 존재하는 데이터 기준으로 동적 메모리 생성함
									 // Circle Defect검사에 필요한 Edge데이터 값
									 int Count=0;
									 if(OrgC2CirInEdgeCount>0){
										 C2CirInEdgeCount = OrgC2CirInEdgeCount - C2CirInEdgeCount;
										 // 										C2CirInEdgeCount = OrgC2CirInEdgeCount;
										 if(C2CirInEdgeCount>0){
											 if(C2CirInPoint!=NULL) delete[] C2CirInPoint;
											 C2CirInPoint = new TFPoint[C2CirInEdgeCount];

											 for(int k=0; k<OrgC2CirInEdgeCount; k++){
												 if(k>MAX_CIRCLE_EDGEPOINT) break;
												 if(OrgC2CirInPoint[k].x==0.0f && OrgC2CirInPoint[k].y==0.0f) continue;
												 C2CirInPoint[Count].x = OrgC2CirInPoint[k].x;
												 C2CirInPoint[Count].y = OrgC2CirInPoint[k].y;
												 Count++;
											 }
										 }
										 // Circle 원본 데이터 메모리 삭제
										 if(OrgC2CirInPoint!=NULL) delete[] OrgC2CirInPoint;
									 }
									 // Circle Fitting 결과물 
									 SampleSize = C2CirInEdgeCount*0.75; //0.5~0.8이하로 입력할것
									 DistDevRatio = 0.15; //0.1~0.25 이하로 입력할것
									 // 									Radius = 0;
									 CircleFit->OnRansac(C2CirInPoint,C2CirInEdgeCount,SampleSize,DistDevRatio,&CircleFit2Center,&CirFitDiameter2);

									 if(OrgC2CirOutEdgeCount>0){
										 C2CirOutEdgeCount = OrgC2CirOutEdgeCount - C2CirOutEdgeCount;
										 Count =0;
										 if(C2CirOutEdgeCount>0){
											 if(C2CirOutPoint!=NULL) delete[] C2CirOutPoint;
											 C2CirOutPoint = new TFPoint[C2CirOutEdgeCount];

											 for(int k=0; k<OrgC2CirOutEdgeCount; k++){
												 if(k>MAX_CIRCLE_EDGEPOINT) break;
												 if(OrgC2CirOutPoint[k].x==0.0f && OrgC2CirOutPoint[k].y==0.0f) continue;
												 C2CirOutPoint[Count].x = OrgC2CirOutPoint[k].x;
												 C2CirOutPoint[Count].y = OrgC2CirOutPoint[k].y;
												 Count++;
											 }
										 }
										 // Circle 원본 데이터 메모리 삭제
										 if(OrgC2CirOutPoint!=NULL) delete[] OrgC2CirOutPoint;
									 }
									 if(OrgC2CirStandEdgeCount>0){
										 C2CirStandEdgeCount = OrgC2CirStandEdgeCount - C2CirStandEdgeCount;
										 // 										C2CirStandEdgeCount = OrgC2CirStandEdgeCount;
										 Count =0;
										 if(C2CirStandEdgeCount>0){
											 if(C2CirStandPoint!=NULL) delete[] C2CirStandPoint;
											 C2CirStandPoint = new TFPoint[C2CirStandEdgeCount];

											 for(int k=0; k<OrgC2CirStandEdgeCount; k++){
												 if(k>MAX_CIRCLE_EDGEPOINT) break;
												 if(OrgC2CirStandPoint[k].x==0.0f && OrgC2CirStandPoint[k].y==0.0f) continue;
												 C2CirStandPoint[Count].x = OrgC2CirStandPoint[k].x;
												 C2CirStandPoint[Count].y = OrgC2CirStandPoint[k].y;
												 Count++;
											 }
										 }
										 // Circle 원본 데이터 메모리 삭제
										 if(OrgC2CirStandPoint!=NULL) delete[] OrgC2CirStandPoint;
									 }
									 LogUnit.SetLog(L"Circle_2_Insp_End");    

									 // Circle 영역 꽃박리, 원형박리 검출 목적 시퀀스(EnCap)
									 // 정식 명칭은 몰라서.....일단 Crack으로 정함 
									 if(!IsMarkBtm && BrokenThresHold!=0){
										 if(CirFitDiameter2!=0.0f && CircleFit2Center.x!=0.0f && CircleFit2Center.y!=0.0f){ // FAVION Circle Fitting 성공시 박리검사 진행 
											 Circle->GImage = &RotateBrokenImg;                                             //Binary Image 넘겨줌 

											 Circle->SetCenterXY(CircleFit2Center.x,CircleFit2Center.y);
											 Circle->SetTolerance((dEdgeToTrapLineDis/2)-CirOffsetMargin)    ; // Circle Tolerance 
											 Circle->SetDiameter ((CirFitDiameter2-(dEdgeToTrapLineDis/2))*2); // Circle Diameter 
											 Circle->SetCircleChoice(0)                                      ; // 0:From Begin, 1:From End, 2:Largest Amplitude 
											 Circle->SetCircleType  (2)                                      ; // 0:Black to White, 1:White to Black 2: Both Black, White 
											 Circle->SetCircleIndex (0)                                      ; // Circle EdgePoint Index 
											 Circle->OnExecute(true)                                         ;
											 CrackCirDiameter2 = (CirFitDiameter2-(dEdgeToTrapLineDis/2))+((dEdgeToTrapLineDis/2)-CirOffsetMargin);

											 C2CirInCrackCount = Circle->FCirclePointCount;

											 if(C2CirInCrackCount>0){
												 if(C2CirInCrackPoint!=NULL) delete[] C2CirInCrackPoint;
												 C2CirInCrackPoint = new TFPoint[C2CirInCrackCount];

												 for(int k=0; k<C2CirInCrackCount; k++){
													 if(k>MAX_CIRCLE_EDGEPOINT) break;
													 C2CirInCrackPoint[k].x = Circle->FCirclePoint[k].x;
													 C2CirInCrackPoint[k].y = Circle->FCirclePoint[k].y;
												 }
											 }
										 }
									 }
								 }

								 // 세번째 Circle EdgePoint Data 추출 
								 if(C3CirCenter.x!=0 && C3CirCenter.y!=0){
									 LogUnit.SetLog(L"Circle_3_Insp_Start");    

									 if(BtmEdgeThresHold==0) Circle->GImage = &RotateImg      ; //Org Image 넘겨줌 
									 else                    Circle->GImage = &RotateBinaryImg; //Binary Image 넘겨줌 

									 if      (FInspectMode==Insp_Track) Circle->SetCenterXY(TrackC3CirCenter.x , TrackC3CirCenter.y); // TrackLine 교차점 기준 센터 
									 else if (FInspectMode==Insp_Mark ) Circle->SetCenterXY(C3CirCenter.x      , C3CirCenter.y     ); // 외곽라인 교차점 기준 센터 
									 // Diameter 계산함(OutCircle과 TrackCircle 중간값 기준)
									 C3Diameter = ((CenterCircleHeight*2)+((CenterCircleHeight+OutToTrackLineDis)*2))/2;
									 // 									 C3Diameter = (CenterCircleHeight*2);
									 if(IsMarkBtm) Circle->SetTolerance(60.0f);
									 else          Circle->SetTolerance(80.0f);
									 // 									 Circle->SetTolerance(60.0f )              ; // Circle Tolerance 
									 Circle->SetDiameter (C3Diameter)          ; // Circle Diameter 
									 Circle->SetCircleChoice(0)                ; // 0:From Begin, 1:From End, 2:Largest Amplitude 
									 Circle->SetCircleIndex (0)                ; // Circle EdgePoint Index 
									 if(CenterCirDeg>=0){
										 CenterCirDeg = (CenterCirDeg==0)? 90:CenterCirDeg;
										 // 										 if(270-CenterCirDeg>=0) Circle->SetAngle(270-CenterCirDeg+CirAngleMargin);   // Circle Fitting 시작점 각도
										 // 										                         Circle->SetAmplitude(CenterCirDeg-2*CirAngleMargin);  // Circle Fitting 시작점 부터 검사 범위 
										 if(270-CenterCirDeg>=0) Circle->SetAngle(270-CenterCirDeg);   // Circle Fitting 시작점 각도
										 Circle->SetAmplitude(CenterCirDeg);  // Circle Fitting 시작점 부터 검사 범위 
									 }
									 Circle->SetCircleType(1)                          ; // 0:Black to White, 1:White to Black 2: Both Black, White 
									 Circle->OnExecute()                               ;

									 // Circle Out Data취합 
									 OrgC3CirOutEdgeCount = Circle->FCirclePointCount;
									 if(OrgC3CirOutEdgeCount>0){
										 if(OrgC3CirOutPoint!=NULL) delete[] OrgC3CirOutPoint;
										 OrgC3CirOutPoint = new TFPoint[OrgC3CirOutEdgeCount];

										 for(int k=0; k<OrgC3CirOutEdgeCount; k++){
											 if(k>MAX_CIRCLE_EDGEPOINT) break;
											 OrgC3CirOutPoint[k].x = Circle->FCirclePoint[k].x;
											 OrgC3CirOutPoint[k].y = Circle->FCirclePoint[k].y;

											 // BTM영역 Circle을 제외한 영역 Defect검사 목적에 좌표계산
											 // Circle2에서 TrenchWidth 가로길이 기준점을 찾지 못할경우 Circle3에서 새로운 좌표를 넘겨준다 
											 if(k==0 && (BtmEdgePoint[2].x==0 || BtmEdgePoint[2].y==0)){BtmEdgePoint[2].x = OrgC3CirOutPoint[k].x; BtmEdgePoint[2].y = OrgC3CirOutPoint[k].y;}
											 if(k==(OrgC3CirOutEdgeCount-1))                           {BtmEdgePoint[4].x = OrgC3CirOutPoint[k].x; BtmEdgePoint[4].y = OrgC3CirOutPoint[k].y;}
											 if(OrgC3CirOutPoint[k].x==0.0f && OrgC3CirOutPoint[k].y==0.0f) C3CirOutEdgeCount++;
										 }
									 }

									 // Circle In Data목적 다시 검사  
									 // Cell외곽에서 안쪽으로 들어가면서 Circle 찾을경우 오버킬 발생빈도 높음
									 if(CirGrindInThresHold==0) Circle->GImage = &RotateImg             ; //Org Image 넘겨줌 
									 else                       Circle->GImage = &RotateGrindInBinaryImg; //Binary Image 넘겨줌 
									 // 									if(BtmEdgeThresHold==0) Circle->GImage = &RotateImg      ; //Org Image 넘겨줌 
									 // 									else                    Circle->GImage = &RotateBinaryImg; //Binary Image 넘겨줌 

									 if(IsMarkBtm) Circle->SetTolerance(60.0f);
									 else          Circle->SetTolerance(80.0f);
									 // 									Circle->SetTolerance(60.0f )      ; // Circle Tolerance 
									 Circle->SetDiameter (C3Diameter)  ; // Circle Diameter 
									 Circle->SetCircleChoice(0)        ; // 0:From Begin, 1:From End, 2:Largest Amplitude 
									 Circle->SetCircleIndex (0)        ; // Circle EdgePoint Index 
									 Circle->SetCircleType(0)          ; // 0:Black to White, 1:White to Black 2: Both Black, White 
									 Circle->OnExecute()               ;

									 // Circle In Data 기준 새로운 Circle Center 좌표 받아옴 
									 RealC3CirCenter.x = Circle->FCP.x;
									 RealC3CirCenter.y = Circle->FCP.y;
									 CirDiameter3      = (Circle->Diameter)/2.0;

									 // Circle In Data취합 
									 OrgC3CirInEdgeCount = Circle->FCirclePointCount;
									 if(OrgC3CirInEdgeCount>0){
										 if(OrgC3CirInPoint!=NULL) delete[] OrgC3CirInPoint;
										 OrgC3CirInPoint = new TFPoint[OrgC3CirInEdgeCount];

										 for(int k=0; k<OrgC3CirInEdgeCount; k++){
											 if(k>MAX_CIRCLE_EDGEPOINT) break;
											 OrgC3CirInPoint[k].x = Circle->FCirclePoint[k].x;
											 OrgC3CirInPoint[k].y = Circle->FCirclePoint[k].y;
											 if(OrgC3CirInPoint[k].x==0.0f && OrgC3CirInPoint[k].y==0.0f) C3CirInEdgeCount++;
										 }
									 }

									 // C3Circle Grind_Width, Grind_Measure 
									 // C3Circle 연마량 가공량 검사 시퀀스 시작(TrackMode VS MarkMode)
									 if(FInspectMode==Insp_Track){
										 if(OrgC3CirInEdgeCount==OrgC3CirOutEdgeCount){// 연마량 계산
											 double OutDis=0.0f, InDis=0.0f, TotalGrindWidth=0.0f, AvgGrindWidth=0.0f;C3GrindWidthCount=0;
											 for(int k=0; k<OrgC3CirInEdgeCount; k++){
												 if(OrgC3CirOutPoint[k].x==0.0f && OrgC3CirOutPoint[k].y==0.0f){
													 OutDis =0.0f;
												 }
												 else {
													 OutDis = Math.GetLengthFrPointToPoint(C3CirCenter,OrgC3CirOutPoint[k]);
												 }

												 if(OrgC3CirInPoint[k].x==0.0f && OrgC3CirInPoint[k].y==0.0f){
													 InDis =0.0f;
												 }
												 else {
													 InDis = Math.GetLengthFrPointToPoint(C3CirCenter,OrgC3CirInPoint[k]);
												 }

												 if(OutDis!=0.0f && InDis!=0.0f){
													 TotalGrindWidth+=(InDis - OutDis);
													 C3GrindWidthCount++;
												 }
											 }
											 if(C3GrindWidthCount!=0){
												 AvgGrindWidth = (TotalGrindWidth/C3GrindWidthCount);
												 C3CirGrindWd = AvgGrindWidth;
											 }
										 }
										 if(IsMarkBtm){ // LTPS일경우만 가공량 계산 
											 if(CirGrindMeaThresHold!=0){
												 Circle->GImage = &RotateGrindBinaryImg; //Binary Image 넘겨줌 
												 Circle->SetTolerance(40.0f )          ; // Circle Tolerance 
												 Circle->SetDiameter (C3Diameter)      ; // Circle Diameter 
												 Circle->SetCircleType(1)              ; // 0:Black to White, 1:White to Black 2: Both Black, White 
												 Circle->OnExecute()                   ;

												 // Circle In Data 기준 새로운 Circle Center 좌표 받아옴 
												 RealC3CirCenter.x = Circle->FCP.x;
												 RealC3CirCenter.y = Circle->FCP.y;

												 OrgC3CirStandEdgeCount = Circle->FCirclePointCount;
												 if(OrgC3CirStandEdgeCount>0){
													 if(OrgC3CirStandPoint!=NULL) delete[] OrgC3CirStandPoint;
													 OrgC3CirStandPoint = new TFPoint[OrgC3CirStandEdgeCount];

													 PreC3CirStandPoint[0].x=0.0f; PreC3CirStandPoint[0].y=0.0f;
													 for(int k=0; k<OrgC3CirStandEdgeCount; k++){
														 if(k>MAX_CIRCLE_EDGEPOINT) break;
														 OrgC3CirStandPoint[k].x = Circle->FCirclePoint[k].x;
														 OrgC3CirStandPoint[k].y = Circle->FCirclePoint[k].y;
														 if(OrgC3CirStandPoint[k].x==0.0f && OrgC3CirStandPoint[k].y==0.0f)C3CirStandEdgeCount++;
														 // TrackLine 자재 상태에 따라서 잘못된 EdgePoint를 찾을경우 대비하여 이전데이터 기준 데이터 복원 
														 if(OrgC3CirStandPoint[k].x!=0.0f && OrgC3CirStandPoint[k].y!=0.0f){
															 // 첫번째는 무조건 데이터 넘겨줌 
															 if(PreC3CirStandPoint[0].x==0.0f && PreC3CirStandPoint[0].y==0.0f){
																 PreC3CirStandPoint[0].x = OrgC3CirStandPoint[k].x; 
																 PreC3CirStandPoint[0].y = OrgC3CirStandPoint[k].y; 
															 }
															 else {
																 if(fabs (OrgC3CirStandPoint[k].x-PreC3CirStandPoint[0].x)>TrackLineMargin ||
																	 fabs(OrgC3CirStandPoint[k].y-PreC3CirStandPoint[0].y)>TrackLineMargin   ){
																		 OrgC3CirStandPoint[k].x = PreC3CirStandPoint[0].x+0.5;
																		 OrgC3CirStandPoint[k].y = PreC3CirStandPoint[0].y-0.5;

																		 PreC3CirStandPoint[0].x = OrgC3CirStandPoint[k].x; 
																		 PreC3CirStandPoint[0].y = OrgC3CirStandPoint[k].y; 
																 }
																 else {
																	 PreC3CirStandPoint[0].x = OrgC3CirStandPoint[k].x; 
																	 PreC3CirStandPoint[0].y = OrgC3CirStandPoint[k].y; 
																 }
															 }
														 }
													 }
													 //C1Circle Grind_Measure Calculate 
													 if(OrgC3CirOutEdgeCount==OrgC3CirStandEdgeCount){
														 double GrindMeaDis=0.0f, TotalGrindMeasure=0.0f, AvgGrindMeasure=0.0f; C3GrindMeasureCount=0;
														 for(int k=0; k<OrgC3CirInEdgeCount; k++){
															 if(OrgC3CirOutPoint[k].x==0.0f || OrgC3CirOutPoint[k].y==0.0f || OrgC3CirStandPoint[k].x==0.0f || OrgC3CirStandPoint[k].y==0.0f){
																 GrindMeaDis =0.0f;
															 }
															 else {
																 GrindMeaDis = Math.GetLengthFrPointToPoint(OrgC3CirStandPoint[k],OrgC3CirOutPoint[k]);
															 }

															 if(GrindMeaDis!=0.0f){
																 TotalGrindMeasure+= GrindMeaDis;
																 C3GrindMeasureCount++;
															 }
														 }
														 if(C3GrindMeasureCount!=0){
															 AvgGrindMeasure = (TotalGrindMeasure/C3GrindMeasureCount);
															 C3CirGrindMea= AvgGrindMeasure;
														 }
													 }
													 else if(OrgC3CirStandEdgeCount>OrgC3CirOutEdgeCount) { // 연마가 적게되어 실제 TrackLine보다 EdgePoint데이터가 적을경우 
														 double GrindMeaDis=0.0f, TotalGrindMeasure=0.0f, AvgGrindMeasure=0.0f;C3GrindMeasureCount=0;
														 for(int k=0; k<OrgC3CirOutEdgeCount; k++){
															 if(OrgC3CirOutPoint[k].x==0.0f || OrgC3CirOutPoint[k].y==0.0f || OrgC3CirStandPoint[k].x==0.0f || OrgC3CirStandPoint[k].y==0.0f ){
																 GrindMeaDis =0.0f;
															 }
															 else {
																 GrindMeaDis = Math.GetLengthFrPointToPoint(OrgC3CirStandPoint[k],OrgC3CirOutPoint[k]);
															 }

															 if(GrindMeaDis!=0.0f){
																 TotalGrindMeasure+= GrindMeaDis;
																 C3GrindMeasureCount++;
															 }
														 }
														 if(C3GrindMeasureCount!=0){
															 AvgGrindMeasure = (TotalGrindMeasure/C3GrindMeasureCount);
															 C3CirGrindMea= AvgGrindMeasure;
														 }
													 }
													 else if(OrgC3CirStandEdgeCount<OrgC3CirOutEdgeCount){
														 double GrindMeaDis=0.0f, TotalGrindMeasure=0.0f, AvgGrindMeasure=0.0f;C3GrindMeasureCount=0;
														 for(int k=0; k<OrgC3CirStandEdgeCount; k++){
															 if(OrgC3CirOutPoint[k].x==0.0f || OrgC3CirOutPoint[k].y==0.0f || OrgC3CirStandPoint[k].x==0.0f || OrgC3CirStandPoint[k].y==0.0f ){
																 GrindMeaDis =0.0f;
															 }
															 else {
																 GrindMeaDis = Math.GetLengthFrPointToPoint(OrgC3CirStandPoint[k],OrgC3CirOutPoint[k]);
															 }

															 if(GrindMeaDis!=0.0f){
																 TotalGrindMeasure+= GrindMeaDis;
																 C3GrindMeasureCount++;
															 }
														 }
														 if(C3GrindMeasureCount!=0){
															 AvgGrindMeasure = (TotalGrindMeasure/C3GrindMeasureCount);
															 C3CirGrindMea= AvgGrindMeasure;
														 }
													 }
												 }
											 }
										 }
									 }
									 else if(FInspectMode==Insp_Mark){ // MarkMode 시퀀스 
										 if(IsMarkBtm){ // LTPS 가공량계산 ==> 연마량 계산 
											 if(OrgC3CirOutEdgeCount!=0 && OrgC3CirInEdgeCount!=0){ // 연마량이 존재할경우 가공량 검사를 진행함 
												 GrindMeaDis =0.0f, MinDis =10000.0f; C3GrindMarkCount=0;
												 if(GrindMarkPoint[7].x!=0.0f && GrindMarkPoint[7].y!=0.0f){
													 for(int k=0; k<OrgC3CirOutEdgeCount; k++){
														 if(OrgC3CirOutPoint[k].x==0.0f || OrgC3CirOutPoint[k].y==0.0f) continue;
														 if(GrindMarkPoint[7].x  ==0.0f || GrindMarkPoint[7].y  ==0.0f) continue;

														 GrindMeaDis = Math.GetLength(GrindMarkPoint[7], OrgC3CirOutPoint[k]);
														 if(GrindMeaDis<MinDis){
															 MinDis = GrindMeaDis;
															 C3GrindMarkCount = k;
														 }
													 }
													 // GrindMark기준 수직 포인트 주변값 Avg산출한다 
													 if(C3GrindMarkCount!=0 && C3GrindMarkCount>5){
														 CircleCount=0,TotalCirDis=0.0f,GrindMeaDis=0.0f;
														 for(int k=C3GrindMarkCount-5; k<C3GrindMarkCount+5; k++){
															 if(OrgC3CirOutPoint[k].x==0.0f || OrgC3CirOutPoint[k].y==0.0f) continue;

															 GrindMeaDis = Math.GetLength(GrindMarkPoint[7], OrgC3CirOutPoint[k]);
															 TotalCirDis+= GrindMeaDis;
															 CircleCount++;
														 }
														 if(TotalCirDis!=0.0f && CircleCount!=0){
															 C3CirGrindMea = TotalCirDis/CircleCount;
														 }
													 }
													 // GrindMark기준 수직 평균값 연마량 측정 
													 if(C3GrindMarkCount!=0 && C3GrindMarkCount>5){
														 CircleCount=0,TotalCirDis=0.0f,GrindWidthDis=0.0f;
														 for(int k=C3GrindMarkCount-5; k<C3GrindMarkCount+5; k++){
															 if(OrgC3CirInPoint [k].x==0.0f && OrgC3CirInPoint [k].y==0.0f) continue;
															 GrindWidthDis = Math.GetLength(OrgC3CirInPoint[k], OrgC3CirOutPoint[k]);
															 TotalCirDis+=   GrindWidthDis;
															 CircleCount++;
														 }
														 if(TotalCirDis!=0.0f && CircleCount!=0){
															 C3CirGrindWd = TotalCirDis/CircleCount;
														 }
													 }
												 }
												 else { // Grind Mark 못 찾았을경우 (가공량 0, 연마량 계산함)
													 for(int k=0; k<OrgC3CirOutEdgeCount; k++){
														 if(OrgC3CirOutPoint[k].x==0.0f || OrgC3CirOutPoint[k].y==0.0f) continue;

														 GrindMarkRectCenter[7].x = GrindMarkRect[7].left + (GrindMarkRect[7].right  - GrindMarkRect[7].left)/2; 
														 GrindMarkRectCenter[7].y = GrindMarkRect[7].top  + (GrindMarkRect[7].bottom - GrindMarkRect[7].top )/2; 

														 GrindMeaDis = Math.GetLength(GrindMarkRectCenter[7], OrgC3CirOutPoint[k]);
														 if(GrindMeaDis<MinDis){
															 MinDis = GrindMeaDis;
															 C3GrindMarkCount = k;
														 }
													 }
													 // GrindMark기준 수직 평균값 연마량 측정 
													 if(C3GrindMarkCount!=0 && C3GrindMarkCount>5){
														 CircleCount=0,TotalCirDis=0.0f,GrindWidthDis=0.0f;
														 for(int k=C3GrindMarkCount-5; k<C3GrindMarkCount+5; k++){
															 if(OrgC3CirOutPoint[k].x==0.0f && OrgC3CirOutPoint[k].y==0.0f) continue;
															 if(OrgC3CirInPoint [k].x==0.0f && OrgC3CirInPoint [k].y==0.0f) continue;
															 GrindWidthDis = Math.GetLength(OrgC3CirInPoint[k], OrgC3CirOutPoint[k]);
															 TotalCirDis+=   GrindWidthDis;
															 CircleCount++;
														 }
														 if(TotalCirDis!=0.0f && CircleCount!=0){
															 C3CirGrindWd = TotalCirDis/CircleCount;
														 }
													 }
												 }
											 }
										 }
										 else         { // EnCAP 연마량만 계산 
											 if(OrgC3CirInEdgeCount==OrgC3CirOutEdgeCount){
												 double OutDis=0.0f, InDis=0.0f, TotalGrindWidth=0.0f, AvgGrindWidth=0.0f;C3GrindWidthCount=0;
												 for(int k=0; k<OrgC3CirInEdgeCount; k++){
													 if(OrgC3CirOutPoint[k].x==0.0f && OrgC3CirOutPoint[k].y==0.0f){
														 OutDis =0.0f;
													 }
													 else {
														 OutDis = Math.GetLengthFrPointToPoint(C3CirCenter,OrgC3CirOutPoint[k]);
													 }

													 if(OrgC3CirInPoint[k].x==0.0f && OrgC3CirInPoint[k].y==0.0f){
														 InDis =0.0f;
													 }
													 else {
														 InDis = Math.GetLengthFrPointToPoint(C3CirCenter,OrgC3CirInPoint[k]);
													 }

													 if(OutDis!=0.0f && InDis!=0.0f){
														 TotalGrindWidth+=(InDis - OutDis);
														 C3GrindWidthCount++;
													 }
												 }
												 if(C3GrindWidthCount!=0){
													 AvgGrindWidth = (TotalGrindWidth/C3GrindWidthCount);
													 C3CirGrindWd = AvgGrindWidth;
												 }
											 }
										 }
									 }
									 // C3Circle 연마량 가공량 검사 시퀀스 종료(TrackMode VS MarkMode)
									 //////////////////////////////////////////////////////////////////////////////////////////////////////


									 // Org Circle데이터중 유호하지 않은 값을 제외한 실제 존재하는 데이터 기준으로 동적 메모리 생성함
									 // Circle Defect검사에 필요한 Edge데이터 값
									 int Count=0;
									 if(OrgC3CirInEdgeCount>0){
										 C3CirInEdgeCount = OrgC3CirInEdgeCount - C3CirInEdgeCount;
										 // 										C3CirInEdgeCount = OrgC3CirInEdgeCount;
										 if(C3CirInEdgeCount>0){
											 if(C3CirInPoint!=NULL) delete[] C3CirInPoint;
											 C3CirInPoint = new TFPoint[C3CirInEdgeCount];

											 for(int k=0; k<OrgC3CirInEdgeCount; k++){
												 if(k>MAX_CIRCLE_EDGEPOINT) break;
												 if(OrgC3CirInPoint[k].x==0.0f && OrgC3CirInPoint[k].y==0.0f) continue;
												 C3CirInPoint[Count].x = OrgC3CirInPoint[k].x;
												 C3CirInPoint[Count].y = OrgC3CirInPoint[k].y;
												 Count++;
											 }
										 }
										 // Circle 원본 데이터 메모리 삭제
										 if(OrgC3CirInPoint!=NULL) delete[] OrgC3CirInPoint;
									 }
									 // Circle Fitting 결과물 
									 SampleSize = C3CirInEdgeCount*0.75; //0.5~0.8이하로 입력할것
									 DistDevRatio = 0.15; //0.1~0.25 이하로 입력할것
									 // 									Radius = 0;
									 CircleFit->OnRansac(C3CirInPoint,C3CirInEdgeCount,SampleSize,DistDevRatio,&CircleFit3Center,&CirFitDiameter3);

									 if(OrgC3CirOutEdgeCount>0){
										 C3CirOutEdgeCount = OrgC3CirOutEdgeCount - C3CirOutEdgeCount;
										 Count =0;
										 if(C3CirOutEdgeCount>0){
											 if(C3CirOutPoint!=NULL) delete[] C3CirOutPoint;
											 C3CirOutPoint = new TFPoint[C3CirOutEdgeCount];

											 for(int k=0; k<OrgC3CirOutEdgeCount; k++){
												 if(k>MAX_CIRCLE_EDGEPOINT) break;
												 if(OrgC3CirOutPoint[k].x==0.0f && OrgC3CirOutPoint[k].y==0.0f) continue;
												 C3CirOutPoint[Count].x = OrgC3CirOutPoint[k].x;
												 C3CirOutPoint[Count].y = OrgC3CirOutPoint[k].y;
												 Count++;
											 }
										 }
										 // Circle 원본 데이터 메모리 삭제
										 if(OrgC3CirOutPoint!=NULL) delete[] OrgC3CirOutPoint;
									 }
									 if(OrgC3CirStandEdgeCount>0){
										 C3CirStandEdgeCount = OrgC3CirStandEdgeCount - C3CirStandEdgeCount;
										 // 										C3CirStandEdgeCount = OrgC3CirStandEdgeCount;
										 Count =0;
										 if(C3CirStandEdgeCount>0){
											 if(C3CirStandPoint!=NULL) delete[] C3CirStandPoint;
											 C3CirStandPoint = new TFPoint[C3CirStandEdgeCount];

											 for(int k=0; k<OrgC3CirStandEdgeCount; k++){
												 if(k>MAX_CIRCLE_EDGEPOINT) break;
												 if(OrgC3CirStandPoint[k].x==0.0f && OrgC3CirStandPoint[k].y==0.0f) continue;
												 C3CirStandPoint[Count].x = OrgC3CirStandPoint[k].x;
												 C3CirStandPoint[Count].y = OrgC3CirStandPoint[k].y;
												 Count++;
											 }
										 }
										 // Circle 원본 데이터 메모리 삭제
										 if(OrgC3CirStandPoint!=NULL) delete[] OrgC3CirStandPoint;
									 }
									 LogUnit.SetLog(L"Circle_3_Insp_End");    
									 // Circle 영역 꽃박리, 원형박리 검출 목적 시퀀스(EnCap)
									 // 정식 명칭은 몰라서.....일단 Crack으로 정함 
									 if(!IsMarkBtm && BrokenThresHold!=0){
										 if(CirFitDiameter3!=0.0f && CircleFit3Center.x!=0.0f && CircleFit3Center.y!=0.0f){ // FAVION Circle Fitting 성공시 박리검사 진행 
											 Circle->GImage = &RotateBrokenImg;                                             //Binary Image 넘겨줌 

											 Circle->SetCenterXY(CircleFit3Center.x,CircleFit3Center.y)      ;
											 Circle->SetTolerance((dEdgeToTrapLineDis/2)-CirOffsetMargin)    ; // Circle Tolerance 
											 Circle->SetDiameter ((CirFitDiameter3+(dEdgeToTrapLineDis/2))*2); // Circle Diameter 
											 Circle->SetCircleChoice(0)                                      ; // 0:From Begin, 1:From End, 2:Largest Amplitude 
											 Circle->SetCircleType  (2)                                      ; // 0:Black to White, 1:White to Black 2: Both Black, White 
											 Circle->SetCircleIndex (0)                                      ; // Circle EdgePoint Index 
											 Circle->OnExecute(true)							                ;
											 CrackCirDiameter3 = (CirFitDiameter3+(dEdgeToTrapLineDis/2)) - (dEdgeToTrapLineDis/2)-CirOffsetMargin;

											 C3CirInCrackCount = Circle->FCirclePointCount;

											 if(C3CirInCrackCount>0){
												 if(C3CirInCrackPoint!=NULL) delete[] C3CirInCrackPoint;
												 C3CirInCrackPoint = new TFPoint[C3CirInCrackCount];

												 for(int k=0; k<C3CirInCrackCount; k++){
													 if(k>MAX_CIRCLE_EDGEPOINT) break;
													 C3CirInCrackPoint[k].x = Circle->FCirclePoint[k].x;
													 C3CirInCrackPoint[k].y = Circle->FCirclePoint[k].y;
												 }
											 }
										 }
									 }
								 }

								 // 네번째 Circle EdgePoint Data 추출 
								 if(C4CirCenter.x!=0 && C4CirCenter.y!=0){
									 LogUnit.SetLog(L"Circle_4_Insp_Start");    

									 if(BtmEdgeThresHold==0) Circle->GImage = &RotateImg      ; //Org Image 넘겨줌 
									 else                    Circle->GImage = &RotateBinaryImg; //Binary Image 넘겨줌 

									 if      (FInspectMode==Insp_Track) Circle->SetCenterXY(TrackC4CirCenter.x , TrackC4CirCenter.y); // TrackLine 교차점 기준 센터 
									 else if (FInspectMode==Insp_Mark ) Circle->SetCenterXY(C4CirCenter.x      , C4CirCenter.y     ); // 외곽라인 교차점 기준 센터 
									 // Diameter 계산함(OutCircle과 TrackCircle 중간값 기준)
									 C4Diameter = ((CenterCircleHeight*2)+((CenterCircleHeight+OutToTrackLineDis)*2))/2;
									 // 									 C4Diameter = (CenterCircleHeight*2);
									 if(IsMarkBtm) Circle->SetTolerance(60.0f);
									 else          Circle->SetTolerance(80.0f);
									 // 									 Circle->SetTolerance(60.0f )              ; // Circle Tolerance 
									 Circle->SetDiameter (C4Diameter)          ; // Circle Diameter 
									 Circle->SetCircleChoice(0)                ; // 0:From Begin, 1:From End, 2:Largest Amplitude 
									 Circle->SetCircleIndex (0)                ; // Circle EdgePoint Index 
									 if(CenterCirDeg>=0){
										 CenterCirDeg = (CenterCirDeg==0)? 90:CenterCirDeg;
										 // 										 Circle->SetAngle(270+CirAngleMargin               );               // Circle Fitting 시작점 각도
										 // 										 Circle->SetAmplitude(CenterCirDeg-2*CirAngleMargin);  // Circle Fitting 시작점 부터 검사 범위 
										 Circle->SetAngle(270             );               // Circle Fitting 시작점 각도
										 Circle->SetAmplitude(CenterCirDeg);  // Circle Fitting 시작점 부터 검사 범위 
									 }

									 Circle->SetCircleType(1)                          ; // 0:Black to White, 1:White to Black 2: Both Black, White 
									 Circle->OnExecute()                               ;

									 // Circle Out Data취합 
									 OrgC4CirOutEdgeCount = Circle->FCirclePointCount;
									 if(OrgC4CirOutEdgeCount>0){
										 if(OrgC4CirOutPoint!=NULL) delete[] OrgC4CirOutPoint;
										 OrgC4CirOutPoint = new TFPoint[OrgC4CirOutEdgeCount];

										 for(int k=0; k<OrgC4CirOutEdgeCount; k++){
											 if(k>MAX_CIRCLE_EDGEPOINT) break;
											 OrgC4CirOutPoint[k].x = Circle->FCirclePoint[k].x;
											 OrgC4CirOutPoint[k].y = Circle->FCirclePoint[k].y;
											 // BTM영역 Circle을 제외한 영역 Defect검사 목적에 좌표계산 
											 if(k==0)                        {BtmEdgePoint[5].x = OrgC4CirOutPoint[k].x; BtmEdgePoint[5].y = OrgC4CirOutPoint[k].y;}
											 if(k==(OrgC4CirOutEdgeCount-1)) {BtmEdgePoint[7].x = OrgC4CirOutPoint[k].x; BtmEdgePoint[7].y = OrgC4CirOutPoint[k].y;}

											 if(OrgC4CirOutPoint[k].x==0.0f && OrgC4CirOutPoint[k].y==0.0f) C4CirOutEdgeCount++;
										 }
									 }

									 // Circle Out Data목적 다시 검사  
									 if(CirGrindInThresHold==0) Circle->GImage = &RotateImg             ; //Org Image 넘겨줌 
									 else                       Circle->GImage = &RotateGrindInBinaryImg; //Binary Image 넘겨줌 
									 // 									 if(BtmEdgeThresHold==0) Circle->GImage = &RotateImg      ; //Org Image 넘겨줌 
									 // 									 else                    Circle->GImage = &RotateBinaryImg; //Binary Image 넘겨줌 

									 if(IsMarkBtm) Circle->SetTolerance(60.0f);
									 else          Circle->SetTolerance(80.0f);
									 // 									 Circle->SetTolerance(60.0f )      ; // Circle Tolerance 
									 Circle->SetDiameter (C4Diameter)  ; // Circle Diameter 
									 Circle->SetCircleChoice(0)        ; // 0:From Begin, 1:From End, 2:Largest Amplitude 
									 Circle->SetCircleIndex (0)        ; // Circle EdgePoint Index 
									 Circle->SetCircleType(0)          ; // 0:Black to White, 1:White to Black 2: Both Black, White 
									 Circle->OnExecute()               ;

									 // Circle In Data 기준 새로운 Circle Center 좌표 받아옴 
									 RealC4CirCenter.x = Circle->FCP.x;
									 RealC4CirCenter.y = Circle->FCP.y;
									 CirDiameter4      = (Circle->Diameter)/2.0;

									 // Circle In Data취합 
									 OrgC4CirInEdgeCount = Circle->FCirclePointCount;
									 if(OrgC4CirInEdgeCount>0){
										 if(OrgC4CirInPoint!=NULL) delete[] OrgC4CirInPoint;
										 OrgC4CirInPoint = new TFPoint[OrgC4CirInEdgeCount];

										 for(int k=0; k<OrgC4CirInEdgeCount; k++){
											 if(k>MAX_CIRCLE_EDGEPOINT) break;
											 OrgC4CirInPoint[k].x = Circle->FCirclePoint[k].x;
											 OrgC4CirInPoint[k].y = Circle->FCirclePoint[k].y;
											 if(OrgC4CirInPoint[k].x==0.0f && OrgC4CirInPoint[k].y==0.0f)C4CirInEdgeCount++;
											 // BTM영역 Circle을 제외한 영역 Defect검사 목적에 좌표계산 
											 // 											 if(k==0) {BtmEdgePoint1.x = C1CirInPoint[k].x; BtmEdgePoint1.y = C1CirInPoint[k].y;}
										 }
									 }

									 // C4Circle Grind_Width, Grind_Measure 
									 // C4Circle 연마량 가공량 검사 시퀀스 시작(TrackMode VS MarkMode)
									 if(FInspectMode==Insp_Track){ // TrackMode 
										 if(OrgC4CirInEdgeCount==OrgC4CirOutEdgeCount){// 가공량 계산
											 double OutDis=0.0f, InDis=0.0f, TotalGrindWidth=0.0f, AvgGrindWidth=0.0f;C4GrindWidthCount=0;
											 for(int k=0; k<OrgC4CirInEdgeCount; k++){
												 if(OrgC4CirOutPoint[k].x==0.0f && OrgC4CirOutPoint[k].y==0.0f){
													 OutDis =0.0f;
												 }
												 else {
													 OutDis = Math.GetLengthFrPointToPoint(C4CirCenter,OrgC4CirOutPoint[k]);
												 }

												 if(OrgC4CirInPoint[k].x==0.0f && OrgC4CirInPoint[k].y==0.0f){
													 InDis =0.0f;
												 }
												 else {
													 InDis = Math.GetLengthFrPointToPoint(C4CirCenter,OrgC4CirInPoint[k]);
												 }

												 if(OutDis!=0.0f && InDis!=0.0f){
													 TotalGrindWidth+=(InDis - OutDis);
													 C4GrindWidthCount++;
												 }
											 }
											 if(C4GrindWidthCount!=0){
												 AvgGrindWidth = (TotalGrindWidth/C4GrindWidthCount);
												 C4CirGrindWd = AvgGrindWidth;
											 }
										 }
										 if(IsMarkBtm){ // LTPS일경만 가공량 계산 
											 if(CirGrindMeaThresHold!=0){
												 Circle->GImage = &RotateGrindBinaryImg; //Binary Image 넘겨줌 
												 Circle->SetTolerance(40.0f )          ; // Circle Tolerance 
												 Circle->SetDiameter (C4Diameter)      ; // Circle Diameter 
												 Circle->SetCircleType(1)              ; // 0:Black to White, 1:White to Black 2: Both Black, White 
												 Circle->OnExecute()                   ;

												 // Circle In Data 기준 새로운 Circle Center 좌표 받아옴 
												 RealC4CirCenter.x = Circle->FCP.x;
												 RealC4CirCenter.y = Circle->FCP.y;

												 OrgC4CirStandEdgeCount = Circle->FCirclePointCount;
												 if(OrgC4CirStandEdgeCount>0){
													 if(OrgC4CirStandPoint!=NULL) delete[] OrgC4CirStandPoint;
													 OrgC4CirStandPoint = new TFPoint[OrgC4CirStandEdgeCount];

													 PreC4CirStandPoint[0].x=0.0f;PreC4CirStandPoint[0].y=0.0f;
													 for(int k=0; k<OrgC4CirStandEdgeCount; k++){
														 if(k>MAX_CIRCLE_EDGEPOINT) break;
														 OrgC4CirStandPoint[k].x = Circle->FCirclePoint[k].x;
														 OrgC4CirStandPoint[k].y = Circle->FCirclePoint[k].y;
														 if(OrgC4CirStandPoint[k].x==0.0f && OrgC4CirStandPoint[k].y==0.0f) C4CirStandEdgeCount++;
														 // TrackLine 자재 상태에 따라서 잘못된 EdgePoint를 찾을경우 대비하여 이전데이터 기준 데이터 복원 
														 if(OrgC4CirStandPoint[k].x!=0.0f && OrgC4CirStandPoint[k].y!=0.0f){
															 // 첫번째는 무조건 데이터 넘겨줌 
															 if(PreC4CirStandPoint[0].x==0.0f && PreC4CirStandPoint[0].y==0.0f){
																 PreC4CirStandPoint[0].x = OrgC4CirStandPoint[k].x; 
																 PreC4CirStandPoint[0].y = OrgC4CirStandPoint[k].y; 
															 }
															 else {
																 if(fabs (OrgC4CirStandPoint[k].x-PreC4CirStandPoint[0].x)>TrackLineMargin ||
																	 fabs(OrgC4CirStandPoint[k].y-PreC4CirStandPoint[0].y)>TrackLineMargin   ){
																		 OrgC4CirStandPoint[k].x = PreC4CirStandPoint[0].x+0.5;
																		 OrgC4CirStandPoint[k].y = PreC4CirStandPoint[0].y+0.5;

																		 PreC4CirStandPoint[0].x = OrgC4CirStandPoint[k].x; 
																		 PreC4CirStandPoint[0].y = OrgC4CirStandPoint[k].y; 
																 }
																 else {
																	 PreC4CirStandPoint[0].x = OrgC4CirStandPoint[k].x; 
																	 PreC4CirStandPoint[0].y = OrgC4CirStandPoint[k].y; 
																 }
															 }
														 }
													 }
													 //C4Circle Grind_Measure Calculate 
													 if(OrgC4CirOutEdgeCount==OrgC4CirStandEdgeCount){
														 double GrindMeaDis=0.0f, TotalGrindMeasure=0.0f, AvgGrindMeasure=0.0f;C4GrindMeasureCount=0;
														 for(int k=0; k<OrgC4CirStandEdgeCount; k++){
															 if(OrgC4CirOutPoint[k].x==0.0f || OrgC4CirOutPoint[k].y==0.0f || OrgC4CirStandPoint[k].x==0.0f || OrgC4CirStandPoint[k].y==0.0f){
																 GrindMeaDis =0.0f;
															 }
															 else {
																 GrindMeaDis = Math.GetLengthFrPointToPoint(OrgC4CirStandPoint[k],OrgC4CirOutPoint[k]);
															 }

															 if(GrindMeaDis!=0.0f){
																 TotalGrindMeasure+= GrindMeaDis;
																 C4GrindMeasureCount++;
															 }
														 }
														 if(C4GrindMeasureCount!=0){
															 AvgGrindMeasure = (TotalGrindMeasure/C4GrindMeasureCount);
															 C4CirGrindMea= AvgGrindMeasure;
														 }
													 }
													 else if(OrgC4CirStandEdgeCount>OrgC4CirOutEdgeCount){ // 연마가 적게되어 실제 TrackLine보다 EdgePoint데이터가 적을경우 
														 double GrindMeaDis=0.0f, TotalGrindMeasure=0.0f, AvgGrindMeasure=0.0f;C4GrindMeasureCount=0;
														 for(int k=0; k<OrgC4CirOutEdgeCount; k++){
															 if(OrgC4CirOutPoint[k].x==0.0f || OrgC4CirOutPoint[k].y==0.0f || OrgC4CirStandPoint[k].x==0.0f || OrgC4CirStandPoint[k].y==0.0f ){
																 GrindMeaDis =0.0f;
															 }
															 else {
																 GrindMeaDis = Math.GetLengthFrPointToPoint(OrgC4CirStandPoint[k],OrgC4CirOutPoint[k]);
															 }

															 if(GrindMeaDis!=0.0f){
																 TotalGrindMeasure+= GrindMeaDis;
																 C4GrindMeasureCount++;
															 }
														 }
														 if(C4GrindMeasureCount!=0){
															 AvgGrindMeasure = (TotalGrindMeasure/C4GrindMeasureCount);
															 C4CirGrindMea= AvgGrindMeasure;
														 }
													 }
													 else if(OrgC4CirStandEdgeCount<OrgC4CirOutEdgeCount){
														 double GrindMeaDis=0.0f, TotalGrindMeasure=0.0f, AvgGrindMeasure=0.0f;C4GrindMeasureCount=0;
														 for(int k=0; k<OrgC4CirStandEdgeCount; k++){
															 if(OrgC4CirOutPoint[k].x==0.0f || OrgC4CirOutPoint[k].y==0.0f || OrgC4CirStandPoint[k].x==0.0f || OrgC4CirStandPoint[k].y==0.0f ){
																 GrindMeaDis =0.0f;
															 }
															 else {
																 GrindMeaDis = Math.GetLengthFrPointToPoint(OrgC4CirStandPoint[k],OrgC4CirOutPoint[k]);
															 }

															 if(GrindMeaDis!=0.0f){
																 TotalGrindMeasure+= GrindMeaDis;
																 C4GrindMeasureCount++;
															 }
														 }
														 if(C4GrindMeasureCount!=0){
															 AvgGrindMeasure = (TotalGrindMeasure/C4GrindMeasureCount);
															 C4CirGrindMea= AvgGrindMeasure;
														 }
													 }
												 }
											 }
										 }
									 }
									 else if(FInspectMode==Insp_Mark){ // MarkMode 
										 if(IsMarkBtm){ //LTPS 가공량 계산 ==> 연마량 계산 
											 if(OrgC4CirOutEdgeCount!=0 && OrgC4CirInEdgeCount!=0){// 연마량이 존재할경우 가공량 검사를 진행함 
												 GrindMeaDis =0.0f, MinDis =10000.0f;C4GrindMarkCount=0;
												 if(GrindMarkPoint[11].x!=0.0f && GrindMarkPoint[11].y!=0.0f){
													 for(int k=0; k<OrgC4CirOutEdgeCount; k++){
														 if(OrgC4CirOutPoint[k].x==0.0f || OrgC4CirOutPoint[k].y==0.0f) continue;
														 if(GrindMarkPoint[11].x  ==0.0f || GrindMarkPoint[11].y  ==0.0f) continue;

														 GrindMeaDis = Math.GetLength(GrindMarkPoint[11], OrgC4CirOutPoint[k]);
														 if(GrindMeaDis<MinDis){
															 MinDis = GrindMeaDis;
															 C4GrindMarkCount = k;
														 }
													 }
													 // GrindMark기준 수직 포인트 주변값 Avg산출한다 
													 if(C4GrindMarkCount!=0 && C4GrindMarkCount>5){
														 CircleCount=0,TotalCirDis=0.0f,GrindMeaDis=0.0f;
														 for(int k=C4GrindMarkCount-5; k<C4GrindMarkCount+5; k++){
															 if(OrgC4CirOutPoint[k].x==0.0f || OrgC4CirOutPoint[k].y==0.0f) continue;

															 GrindMeaDis = Math.GetLength(GrindMarkPoint[11], OrgC4CirOutPoint[k]);
															 TotalCirDis+= GrindMeaDis;
															 CircleCount++;
														 }
														 if(TotalCirDis!=0.0f && CircleCount!=0){
															 C4CirGrindMea = TotalCirDis/CircleCount;
														 }
													 }
													 // GrindMark기준 수직 평균값 연마량 측정 
													 if(C4GrindMarkCount!=0 && C4GrindMarkCount>5){
														 CircleCount=0,TotalCirDis=0.0f,GrindWidthDis=0.0f;
														 for(int k=C4GrindMarkCount-5; k<C4GrindMarkCount+5; k++){
															 if(OrgC4CirOutPoint[k].x==0.0f && OrgC4CirOutPoint[k].y==0.0f) continue;
															 if(OrgC4CirInPoint [k].x==0.0f && OrgC4CirInPoint [k].y==0.0f) continue;
															 GrindWidthDis = Math.GetLength(OrgC4CirInPoint[k], OrgC4CirOutPoint[k]);
															 TotalCirDis+=   GrindWidthDis;
															 CircleCount++;
														 }
														 if(TotalCirDis!=0.0f && CircleCount!=0){
															 C4CirGrindWd = TotalCirDis/CircleCount;
														 }
													 }
												 }
												 else { // Grind Mark 못 찾았을경우 (가공량 0, 연마량 계산함)
													 for(int k=0; k<OrgC4CirOutEdgeCount; k++){
														 if(OrgC4CirOutPoint[k].x==0.0f || OrgC4CirOutPoint[k].y==0.0f) continue;

														 GrindMarkRectCenter[11].x = GrindMarkRect[11].left + (GrindMarkRect[11].right  - GrindMarkRect[11].left)/2; 
														 GrindMarkRectCenter[11].y = GrindMarkRect[11].top  + (GrindMarkRect[11].bottom - GrindMarkRect[11].top )/2; 

														 GrindMeaDis = Math.GetLength(GrindMarkRectCenter[11], OrgC4CirOutPoint[k]);
														 if(GrindMeaDis<MinDis){
															 MinDis = GrindMeaDis;
															 C4GrindMarkCount = k;
														 }
													 }
													 // GrindMark기준 수직 평균값 연마량 측정 
													 if(C4GrindMarkCount!=0 && C4GrindMarkCount>5){
														 CircleCount=0,TotalCirDis=0.0f,GrindWidthDis=0.0f;
														 for(int k=C4GrindMarkCount-5; k<C4GrindMarkCount+5; k++){
															 if(OrgC4CirOutPoint[k].x==0.0f && OrgC4CirOutPoint[k].y==0.0f) continue;
															 if(OrgC4CirInPoint [k].x==0.0f && OrgC4CirInPoint [k].y==0.0f) continue;
															 GrindWidthDis = Math.GetLength(OrgC4CirInPoint[k], OrgC4CirOutPoint[k]);
															 TotalCirDis+=   GrindWidthDis;
															 CircleCount++;
														 }
														 if(TotalCirDis!=0.0f && CircleCount!=0){
															 C4CirGrindWd = TotalCirDis/CircleCount;
														 }
													 }
												 }
											 }
										 }
										 else         { //Encap 연마량 계산 
											 if(OrgC4CirInEdgeCount==OrgC4CirOutEdgeCount){
												 double OutDis=0.0f, InDis=0.0f, TotalGrindWidth=0.0f, AvgGrindWidth=0.0f;C4GrindWidthCount=0;
												 for(int k=0; k<OrgC4CirInEdgeCount; k++){
													 if(OrgC4CirOutPoint[k].x==0.0f && OrgC4CirOutPoint[k].y==0.0f){
														 OutDis =0.0f;
													 }
													 else {
														 OutDis = Math.GetLengthFrPointToPoint(C4CirCenter,OrgC4CirOutPoint[k]);
													 }

													 if(OrgC4CirInPoint[k].x==0.0f && OrgC4CirInPoint[k].y==0.0f){
														 InDis =0.0f;
													 }
													 else {
														 InDis = Math.GetLengthFrPointToPoint(C4CirCenter,OrgC4CirInPoint[k]);
													 }

													 if(OutDis!=0.0f && InDis!=0.0f){
														 TotalGrindWidth+=(InDis - OutDis);
														 C4GrindWidthCount++;
													 }
												 }
												 if(C4GrindWidthCount!=0){
													 AvgGrindWidth = (TotalGrindWidth/C4GrindWidthCount);
													 C4CirGrindWd = AvgGrindWidth;
												 }
											 }
										 }
									 }
									 // C4Circle 연마량 가공량 검사 시퀀스 종료(TrackMode VS MarkMode)
									 //////////////////////////////////////////////////////////////////////////////////////////////////////


									 // Org Circle데이터중 유호하지 않은 값을 제외한 실제 존재하는 데이터 기준으로 동적 메모리 생성함
									 // Circle Defect검사에 필요한 Edge데이터 값
									 int Count=0;
									 if(OrgC4CirInEdgeCount>0){
										 C4CirInEdgeCount = OrgC4CirInEdgeCount - C4CirInEdgeCount;
										 // 										 C4CirInEdgeCount = OrgC4CirInEdgeCount;
										 if(C4CirInEdgeCount>0){
											 if(C4CirInPoint!=NULL) delete[] C4CirInPoint;
											 C4CirInPoint = new TFPoint[C4CirInEdgeCount];

											 for(int k=0; k<OrgC4CirInEdgeCount; k++){
												 if(k>MAX_CIRCLE_EDGEPOINT) break;
												 if(OrgC4CirInPoint[k].x==0.0f && OrgC4CirInPoint[k].y==0.0f) continue;
												 C4CirInPoint[Count].x = OrgC4CirInPoint[k].x;
												 C4CirInPoint[Count].y = OrgC4CirInPoint[k].y;
												 Count++;
											 }
										 }
										 // Circle 원본 데이터 메모리 삭제
										 if(OrgC4CirInPoint!=NULL) delete[] OrgC4CirInPoint;
									 }
									 // Circle Fitting 결과물 
									 SampleSize = C4CirInEdgeCount*0.75; //0.5~0.8이하로 입력할것
									 DistDevRatio = 0.15; //0.1~0.25 이하로 입력할것
									 // 									Radius = 0;
									 CircleFit->OnRansac(C4CirInPoint,C4CirInEdgeCount,SampleSize,DistDevRatio,&CircleFit4Center,&CirFitDiameter4);

									 if(OrgC4CirOutEdgeCount>0){
										 C4CirOutEdgeCount = OrgC4CirOutEdgeCount - C4CirOutEdgeCount;
										 Count =0;
										 if(C4CirOutEdgeCount>0){
											 if(C4CirOutPoint!=NULL) delete[] C4CirOutPoint;
											 C4CirOutPoint = new TFPoint[C4CirOutEdgeCount];

											 for(int k=0; k<OrgC4CirOutEdgeCount; k++){
												 if(k>MAX_CIRCLE_EDGEPOINT) break;
												 if(OrgC4CirOutPoint[k].x==0.0f && OrgC4CirOutPoint[k].y==0.0f) continue;
												 C4CirOutPoint[Count].x = OrgC4CirOutPoint[k].x;
												 C4CirOutPoint[Count].y = OrgC4CirOutPoint[k].y;
												 Count++;
											 }
										 }
										 // Circle 원본 데이터 메모리 삭제
										 if(OrgC4CirOutPoint!=NULL) delete[] OrgC4CirOutPoint;
									 }
									 if(OrgC4CirStandEdgeCount>0){
										 C4CirStandEdgeCount = OrgC4CirStandEdgeCount - C4CirStandEdgeCount;
										 // 										 C4CirStandEdgeCount = OrgC4CirStandEdgeCount;
										 Count =0;
										 if(C4CirStandEdgeCount>0){
											 if(C4CirStandPoint!=NULL) delete[] C4CirStandPoint;
											 C4CirStandPoint = new TFPoint[C4CirStandEdgeCount];

											 for(int k=0; k<OrgC4CirStandEdgeCount; k++){
												 if(k>MAX_CIRCLE_EDGEPOINT) break;
												 if(OrgC4CirStandPoint[k].x==0.0f && OrgC4CirStandPoint[k].y==0.0f) continue;
												 C4CirStandPoint[Count].x = OrgC4CirStandPoint[k].x;
												 C4CirStandPoint[Count].y = OrgC4CirStandPoint[k].y;
												 Count++;
											 }
										 }
										 // Circle 원본 데이터 메모리 삭제
										 if(OrgC4CirStandPoint!=NULL) delete[] OrgC4CirStandPoint;
									 }
									 LogUnit.SetLog(L"Circle_4_Insp_End");    
									 // Circle 영역 꽃박리, 원형박리 검출 목적 시퀀스(EnCap)
									 // 정식 명칭은 몰라서.....일단 Crack으로 정함 
									 if(!IsMarkBtm && BrokenThresHold!=0){
										 if(CirFitDiameter4!=0.0f && CircleFit4Center.x!=0.0f && CircleFit4Center.y!=0.0f){ // FAVION Circle Fitting 성공시 박리검사 진행 
											 Circle->GImage = &RotateBrokenImg;                                             //Binary Image 넘겨줌 

											 Circle->SetCenterXY(CircleFit4Center.x,CircleFit4Center.y)      ;
											 Circle->SetTolerance((dEdgeToTrapLineDis/2)-CirOffsetMargin)    ; // Circle Tolerance 
											 Circle->SetDiameter ((CirFitDiameter4+(dEdgeToTrapLineDis/2))*2); // Circle Diameter 
											 Circle->SetCircleChoice(0)                                      ; // 0:From Begin, 1:From End, 2:Largest Amplitude 
											 Circle->SetCircleType  (2)                                      ; // 0:Black to White, 1:White to Black 2: Both Black, White 
											 Circle->SetCircleIndex (0)                                      ; // Circle EdgePoint Index 
											 Circle->OnExecute(true)                                         ;
											 CrackCirDiameter4 = (CirFitDiameter4+(dEdgeToTrapLineDis/2))-((dEdgeToTrapLineDis/2)-CirOffsetMargin);

											 C4CirInCrackCount = Circle->FCirclePointCount;

											 if(C4CirInCrackCount>0){
												 if(C4CirInCrackPoint!=NULL) delete[] C4CirInCrackPoint;
												 C4CirInCrackPoint = new TFPoint[C4CirInCrackCount];

												 for(int k=0; k<C4CirInCrackCount; k++){
													 if(k>MAX_CIRCLE_EDGEPOINT) break;
													 C4CirInCrackPoint[k].x = Circle->FCirclePoint[k].x;
													 C4CirInCrackPoint[k].y = Circle->FCirclePoint[k].y;
												 }
											 }
										 }
									 }
								 }

								 // 다섯번째 Circle EdgePoint Data 추출 
								 if(C5CirCenter.x!=0 && C5CirCenter.y!=0){
									 LogUnit.SetLog(L"Circle_5_Insp_Start");    

									 // 									 if(BtmEdgeThresHold==0) Circle->GImage = &RotateImg      ; //Org Image 넘겨줌 
									 // 									 else                    Circle->GImage = &RotateBinaryImg; //Binary Image 넘겨줌 

									 if(CirGrindInThresHold==0) Circle->GImage = &RotateImg             ; //Org Image 넘겨줌 
									 else                       Circle->GImage = &RotateGrindInBinaryImg; //Binary Image 넘겨줌 

									 if      (FInspectMode==Insp_Track) Circle->SetCenterXY(TrackC5CirCenter.x , TrackC5CirCenter.y); // TrackLine 교차점 기준 센터 
									 else if (FInspectMode==Insp_Mark ) Circle->SetCenterXY(C5CirCenter.x      , C5CirCenter.y     ); // 외곽라인 교차점 기준 센터 
									 // Diameter 계산함(OutCircle과 TrackCircle 중간값 기준)
									 C5Diameter = ((CenterCircleHeight*2)+((CenterCircleHeight-OutToTrackLineDis)*2))/2;
									 // 									 C5Diameter = (CenterCircleHeight*2);
									 if(IsMarkBtm) Circle->SetTolerance(60.0f);
									 else          Circle->SetTolerance(80.0f);
									 // 									 Circle->SetTolerance(40.0f )                      ; // Circle Tolerance 
									 Circle->SetDiameter (C5Diameter)                  ; // Circle Diameter 
									 // 									 Circle->SetCircleChoice(0)                        ; // 0:From Begin, 1:From End, 2:Largest Amplitude 
									 // 									 Circle->SetCircleIndex (0)                        ; // Circle EdgePoint Index 
									 Circle->SetCircleChoice(1)                        ; // 0:From Begin, 1:From End, 2:Largest Amplitude 
									 Circle->SetCircleType  (2)                        ; // 0:Black to White, 1:White to Black 2: Both Black, White 
									 Circle->SetCircleIndex (1)                        ; // Circle EdgePoint Index 

									 // W1 Cell
									 // 									 Circle->SetAngle(90)                              ; // Cirlce Angle 
									 // 									 Circle->SetAmplitude(46)                          ; // Circle Amplitude
									 // W4 Cell
									 // 									 Circle->SetAngle(90)                              ; // Cirlce Angle 
									 // 									 Circle->SetAmplitude(81)                          ; // Circle Amplitude
									 if(CenterCirDeg>=0){
										 CenterCirDeg = (CenterCirDeg==0)? 90:CenterCirDeg;
										 // 										 Circle->SetAngle(90+CirAngleMargin);               // Circle Fitting 시작점 각도
										 // 										 Circle->SetAmplitude(CenterCirDeg-2*CirAngleMargin);  // Circle Fitting 시작점 부터 검사 범위 
										 Circle->SetAngle    (90          );               // Circle Fitting 시작점 각도
										 Circle->SetAmplitude(CenterCirDeg);  // Circle Fitting 시작점 부터 검사 범위 

									 }
									 Circle->OnExecute()                               ;

									 // Circle In Data 기준 새로운 Circle Center 좌표 받아옴 
									 RealC5CirCenter.x = Circle->FCP.x;
									 RealC5CirCenter.y = Circle->FCP.y;
									 CirDiameter5      = (Circle->Diameter)/2.0;

									 // Circle In Data취합 
									 OrgC5CirInEdgeCount = Circle->FCirclePointCount;
									 if(OrgC5CirInEdgeCount>0){
										 if(OrgC5CirInPoint!=NULL) delete[] OrgC5CirInPoint;
										 OrgC5CirInPoint = new TFPoint[OrgC5CirInEdgeCount];

										 for(int k=0; k<OrgC5CirInEdgeCount; k++){
											 if(k>MAX_CIRCLE_EDGEPOINT) break;
											 OrgC5CirInPoint[k].x = Circle->FCirclePoint[k].x;
											 OrgC5CirInPoint[k].y = Circle->FCirclePoint[k].y;
											 if(OrgC5CirInPoint[k].x==0.0f && OrgC5CirInPoint[k].y==0.0f) C5CirInEdgeCount++;
											 // BTM영역 Circle을 제외한 영역 Defect검사 목적에 좌표계산 
											 // 											 if(k==0) {BtmEdgePoint1.x = C1CirInPoint[k].x; BtmEdgePoint1.y = C1CirInPoint[k].y;}
										 }
									 }

									 // C5Circle 연마량 가공량 검사 시퀀스 시작(TrackMode VS MarkMode)
									 if(BtmEdgeThresHold==0) Circle->GImage = &RotateImg      ; //Org Image 넘겨줌 
									 else                    Circle->GImage = &RotateBinaryImg; //Binary Image 넘겨줌 

									 if(IsMarkBtm) Circle->SetTolerance(60.0f);
									 else          Circle->SetTolerance(80.0f);
									 // 									 Circle->SetTolerance(40.0f )                      ; // Circle Tolerance 
									 Circle->SetDiameter (C5Diameter)                  ; // Circle Diameter 
									 // 									 Circle->SetCircleType(0)                          ; // 0:Black to White, 1:White to Black 2: Both Black, White 
									 Circle->SetCircleChoice(1)                        ; // 0:From Begin, 1:From End, 2:Largest Amplitude 
									 Circle->SetCircleType  (2)                        ; // 0:Black to White, 1:White to Black 2: Both Black, White 
									 Circle->SetCircleIndex (0)                        ; // Circle EdgePoint Index 
									 Circle->OnExecute()                               ;

									 // Circle Out Data취합 
									 OrgC5CirOutEdgeCount = Circle->FCirclePointCount;
									 if(OrgC5CirOutEdgeCount>0){
										 if(OrgC5CirOutPoint!=NULL) delete[] OrgC5CirOutPoint;
										 OrgC5CirOutPoint = new TFPoint[OrgC5CirOutEdgeCount];

										 for(int k=0; k<OrgC5CirOutEdgeCount; k++){
											 if(k>MAX_CIRCLE_EDGEPOINT) break;
											 OrgC5CirOutPoint[k].x = Circle->FCirclePoint[k].x;
											 OrgC5CirOutPoint[k].y = Circle->FCirclePoint[k].y;
											 // BTM영역 Circle을 제외한 영역 Defect검사 목적에 좌표계산 
											 if(k==0                                                                         ){BtmEdgePoint[8].x = OrgC5CirOutPoint[k].x; BtmEdgePoint[8].y = OrgC5CirOutPoint[k].y;}
											 if(k==(OrgC5CirOutEdgeCount-1) && (BtmEdgePoint[7].x==0 || BtmEdgePoint[7].y==0)){BtmEdgePoint[7].x = OrgC5CirOutPoint[k].x; BtmEdgePoint[7].y = OrgC5CirOutPoint[k].y;}
											 if(OrgC5CirOutPoint[k].x==0.0f && OrgC5CirOutPoint[k].y==0.0f) C5CirOutEdgeCount++;
										 }
									 }
									 // C5Circle Grind_Width, Grind_Measure 
									 // C5Circle 연마량 가공량 검사 시퀀스 시작(TrackMode VS MarkMode)
									 if(FInspectMode==Insp_Track){
										 if(OrgC5CirInEdgeCount==OrgC5CirOutEdgeCount){//연마량 계산 
											 double OutDis=0.0f, InDis=0.0f, TotalGrindWidth=0.0f, AvgGrindWidth=0.0f;C5GrindWidthCount=0;
											 for(int k=0; k<OrgC5CirInEdgeCount; k++){
												 if(OrgC5CirOutPoint[k].x==0.0f && OrgC5CirOutPoint[k].y==0.0f){
													 OutDis =0.0f;
												 }
												 else {
													 OutDis = Math.GetLengthFrPointToPoint(C5CirCenter,OrgC5CirOutPoint[k]);
												 }

												 if(OrgC5CirInPoint[k].x==0.0f && OrgC5CirInPoint[k].y==0.0f){
													 InDis =0.0f;
												 }
												 else {
													 InDis = Math.GetLengthFrPointToPoint(C5CirCenter,OrgC5CirInPoint[k]);
												 }

												 if(OutDis!=0.0f && InDis!=0.0f){
													 TotalGrindWidth+=(OutDis - InDis);
													 C5GrindWidthCount++;
												 }
											 }
											 if(C5GrindWidthCount!=0){
												 AvgGrindWidth = (TotalGrindWidth/C5GrindWidthCount);
												 C5CirGrindWd = AvgGrindWidth;
											 }
										 }
										 if(IsMarkBtm){ // LTPS 가공량 계산
											 if(CirGrindMeaThresHold!=0){
												 Circle->GImage = &RotateGrindBinaryImg; //Binary Image 넘겨줌 
												 Circle->SetCircleChoice(1)            ; // 0:From Begin, 1:From End, 2:Largest Amplitude 
												 Circle->SetCircleType(2)              ; // 0:Black to White, 1:White to Black 2: Both Black, White 
												 Circle->SetCircleIndex (1)            ; // Circle EdgePoint Index 
												 Circle->SetTolerance(40.0f )          ; // Circle Tolerance 
												 Circle->SetDiameter (C5Diameter)      ; // Circle Diameter 
												 // 										 Circle->SetCircleType(1)              ; // 0:Black to White, 1:White to Black 2: Both Black, White 
												 Circle->OnExecute()                   ;

												 // Circle In Data 기준 새로운 Circle Center 좌표 받아옴 
												 RealC5CirCenter.x = Circle->FCP.x;
												 RealC5CirCenter.y = Circle->FCP.y;

												 OrgC5CirStandEdgeCount = Circle->FCirclePointCount;
												 if(OrgC5CirStandEdgeCount>0){
													 if(OrgC5CirStandPoint!=NULL) delete[] OrgC5CirStandPoint;
													 OrgC5CirStandPoint = new TFPoint[OrgC5CirStandEdgeCount];

													 PreC5CirStandPoint[0].x=0.0f; PreC5CirStandPoint[0].y=0.0f;
													 for(int k=0; k<OrgC5CirStandEdgeCount; k++){
														 if(k>MAX_CIRCLE_EDGEPOINT) break;
														 OrgC5CirStandPoint[k].x = Circle->FCirclePoint[k].x;
														 OrgC5CirStandPoint[k].y = Circle->FCirclePoint[k].y;
														 if(OrgC5CirStandPoint[k].x==0.0f && OrgC5CirStandPoint[k].y==0.0f) C5CirStandEdgeCount++;
														 // TrackLine 자재 상태에 따라서 잘못된 EdgePoint를 찾을경우 대비하여 이전데이터 기준 데이터 복원 
														 if(OrgC5CirStandPoint[k].x!=0.0f && OrgC5CirStandPoint[k].y!=0.0f){
															 // 첫번째는 무조건 데이터 넘겨줌 
															 if(PreC5CirStandPoint[0].x==0.0f && PreC5CirStandPoint[0].y==0.0f){
																 PreC5CirStandPoint[0].x = OrgC5CirStandPoint[k].x; 
																 PreC5CirStandPoint[0].y = OrgC5CirStandPoint[k].y; 
															 }
															 else {
																 if(fabs (OrgC5CirStandPoint[k].x-PreC5CirStandPoint[0].x)>TrackLineMargin ||
																	 fabs(OrgC5CirStandPoint[k].y-PreC5CirStandPoint[0].y)>TrackLineMargin   ){
																		 OrgC5CirStandPoint[k].x = PreC5CirStandPoint[0].x-0.5;
																		 OrgC5CirStandPoint[k].y = PreC5CirStandPoint[0].y-0.5;

																		 PreC5CirStandPoint[0].x = OrgC5CirStandPoint[k].x; 
																		 PreC5CirStandPoint[0].y = OrgC5CirStandPoint[k].y; 
																 }
																 else {
																	 PreC5CirStandPoint[0].x = OrgC5CirStandPoint[k].x; 
																	 PreC5CirStandPoint[0].y = OrgC5CirStandPoint[k].y; 
																 }
															 }
														 }
													 }
													 //C5Circle Grind_Measure Calculate 
													 if(OrgC5CirOutEdgeCount==OrgC5CirStandEdgeCount){
														 double GrindMeaDis=0.0f, TotalGrindMeasure=0.0f, AvgGrindMeasure=0.0f; C5GrindMeasureCount=0;
														 for(int k=0; k<OrgC5CirInEdgeCount; k++){
															 if(OrgC5CirOutPoint[k].x==0.0f || OrgC5CirOutPoint[k].y==0.0f || OrgC5CirStandPoint[k].x==0.0f || OrgC5CirStandPoint[k].y==0.0f){
																 GrindMeaDis =0.0f;
															 }
															 else {
																 GrindMeaDis = Math.GetLengthFrPointToPoint(OrgC5CirStandPoint[k],OrgC5CirOutPoint[k]);
															 }

															 if(GrindMeaDis!=0.0f){
																 TotalGrindMeasure+= GrindMeaDis;
																 C5GrindMeasureCount++;
															 }
														 }
														 if(C5GrindMeasureCount!=0){
															 AvgGrindMeasure = (TotalGrindMeasure/C5GrindMeasureCount);
															 C5CirGrindMea= AvgGrindMeasure;
														 }
													 }
													 else if(OrgC5CirStandEdgeCount>OrgC5CirOutEdgeCount) { // 연마가 적게되어 실제 TrackLine보다 EdgePoint데이터가 적을경우 
														 double GrindMeaDis=0.0f, TotalGrindMeasure=0.0f, AvgGrindMeasure=0.0f;C5GrindMeasureCount=0;
														 for(int k=0; k<OrgC5CirOutEdgeCount; k++){
															 if(OrgC5CirOutPoint[k].x==0.0f || OrgC5CirOutPoint[k].y==0.0f || OrgC5CirStandPoint[k].x==0.0f || OrgC5CirStandPoint[k].y==0.0f ){
																 GrindMeaDis =0.0f;
															 }
															 else {
																 GrindMeaDis = Math.GetLengthFrPointToPoint(OrgC5CirStandPoint[k],OrgC5CirOutPoint[k]);
															 }

															 if(GrindMeaDis!=0.0f){
																 TotalGrindMeasure+= GrindMeaDis;
																 C5GrindMeasureCount++;
															 }
														 }
														 if(C5GrindMeasureCount!=0){
															 AvgGrindMeasure = (TotalGrindMeasure/C5GrindMeasureCount);
															 C5CirGrindMea= AvgGrindMeasure;
														 }
													 }
													 else if(OrgC5CirStandEdgeCount<OrgC5CirOutEdgeCount){
														 double GrindMeaDis=0.0f, TotalGrindMeasure=0.0f, AvgGrindMeasure=0.0f;C5GrindMeasureCount=0;
														 for(int k=0; k<OrgC5CirStandEdgeCount; k++){
															 if(OrgC5CirOutPoint[k].x==0.0f || OrgC5CirOutPoint[k].y==0.0f || OrgC5CirStandPoint[k].x==0.0f || OrgC5CirStandPoint[k].y==0.0f ){
																 GrindMeaDis =0.0f;
															 }
															 else {
																 GrindMeaDis = Math.GetLengthFrPointToPoint(OrgC5CirStandPoint[k],OrgC5CirOutPoint[k]);
															 }

															 if(GrindMeaDis!=0.0f){
																 TotalGrindMeasure+= GrindMeaDis;
																 C5GrindMeasureCount++;
															 }
														 }
														 if(C5GrindMeasureCount!=0){
															 AvgGrindMeasure = (TotalGrindMeasure/C5GrindMeasureCount);
															 C5CirGrindMea= AvgGrindMeasure;
														 }
													 }
												 }
											 }
										 }
									 }
									 else if(FInspectMode==Insp_Mark){ //MarkMode 
										 if(IsMarkBtm){ // LTPS 가공량 계산 ==> 연마량 계산 
											 if(OrgC5CirOutEdgeCount!=0 && OrgC5CirInEdgeCount!=0){ // 연마량이 존재할경우 가공량 검사를 진행함 
												 // 가공량,연마량 측정 전 데이터 존재시 가상GrindMark 생성한다 
												 if(GrindMarkPoint[13].x!=0.0f && GrindMarkPoint[13].y!=0.0f){
													 GrindMarkPoint[12].x     = GrindMarkPoint[13].x - GrindRectSpec[6].DvX;
													 GrindMarkPoint[12].y     = GrindMarkPoint[13].y - GrindRectSpec[6].DvY;
													 GrindMarkRect [12].left  = GrindMarkPoint[12].x    - GrindMarkRange   ;  
													 GrindMarkRect [12].top   = GrindMarkPoint[12].y    - GrindMarkRange   ;  
													 GrindMarkRect [12].right = GrindMarkRect [12].left + GrindMarkLength  ;  
													 GrindMarkRect [12].bottom= GrindMarkRect [12].top  + GrindMarkLength  ;  
												 }

												 // GrindMarkPoint12 Calc 진행함(연마량,가공량)
												 if(GrindMarkPoint[12].x!=0.0f && GrindMarkPoint[12].y!=0.0f){
													 GrindMeaDis =0.0f, MinDis =10000.0f; C5GrindMarkCount=0;
													 for(int k=0; k<OrgC5CirOutEdgeCount; k++){
														 if(OrgC5CirOutPoint[k].x==0.0f || OrgC5CirOutPoint[k].y==0.0f) continue;
														 if(GrindMarkPoint[12].x  ==0.0f || GrindMarkPoint[12].y  ==0.0f) continue;

														 GrindMeaDis = Math.GetLength(GrindMarkPoint[12], OrgC5CirOutPoint[k]);
														 if(GrindMeaDis<MinDis){
															 MinDis = GrindMeaDis;
															 C5GrindMarkCount = k;
														 }
													 }
													 // GrindMark기준 수직 포인트 주변값 Avg산출한다 
													 if(C5GrindMarkCount!=0 && C5GrindMarkCount>5 && (C5GrindMarkCount+5)<OrgC5CirOutEdgeCount){
														 CircleCount=0,TotalCirDis=0.0f,GrindMeaDis=0.0f;
														 for(int k=C5GrindMarkCount-5; k<C5GrindMarkCount+5; k++){
															 if(OrgC5CirOutPoint[k].x==0.0f || OrgC5CirOutPoint[k].y==0.0f) continue;

															 GrindMeaDis = Math.GetLength(GrindMarkPoint[12], OrgC5CirOutPoint[k]);
															 TotalCirDis+= GrindMeaDis;
															 CircleCount++;
														 }
														 if(TotalCirDis!=0.0f && CircleCount!=0){
															 TrenchRightGrindMea = TotalCirDis/CircleCount;
														 }
													 }
													 // GrindMark기준 수직 평균값 연마량 측정 
													 if(C5GrindMarkCount!=0 && C5GrindMarkCount>5 && (C5GrindMarkCount+5)<OrgC5CirOutEdgeCount){
														 CircleCount=0,TotalCirDis=0.0f,GrindWidthDis=0.0f;
														 for(int k=C5GrindMarkCount-5; k<C5GrindMarkCount+5; k++){
															 if(OrgC5CirOutPoint[k].x==0.0f && OrgC5CirOutPoint[k].y==0.0f) continue;
															 if(OrgC5CirInPoint [k].x==0.0f && OrgC5CirInPoint [k].y==0.0f) continue;
															 GrindWidthDis = Math.GetLength(OrgC5CirInPoint[k], OrgC5CirOutPoint[k]);
															 TotalCirDis+=   GrindWidthDis;
															 CircleCount++;
														 }
														 if(TotalCirDis!=0.0f && CircleCount!=0){
															 TrenchRightGrindWd = TotalCirDis/CircleCount;
														 }
													 }
												 }
												 else { // Grind Mark 못 찾았을경우 (가공량 0, 연마량 계산함)
													 GrindMeaDis =0.0f, MinDis =10000.0f; C5GrindMarkCount=0;
													 for(int k=0; k<OrgC5CirOutEdgeCount; k++){
														 if(OrgC5CirOutPoint[k].x==0.0f || OrgC5CirOutPoint[k].y==0.0f) continue;

														 if(k==0){
															 GrindMarkRectCenter[13].x = GrindMarkRect[13].left + (GrindMarkRect[13].right  - GrindMarkRect[13].left)/2; 
															 GrindMarkRectCenter[13].y = GrindMarkRect[13].top  + (GrindMarkRect[13].bottom - GrindMarkRect[13].top )/2; 

															 GrindMarkRectCenter[12].x = GrindMarkRectCenter[13].x - GrindRectSpec[6].DvX;
															 GrindMarkRectCenter[12].y = GrindMarkRectCenter[13].y - GrindRectSpec[6].DvY;

															 GrindMarkRect [12].left  =  GrindMarkRectCenter[12].x   - GrindMarkRange   ;  
															 GrindMarkRect [12].top   =  GrindMarkRectCenter[12].y   - GrindMarkRange   ;  
															 GrindMarkRect [12].right =  GrindMarkRect [12].left + GrindMarkLength  ;  
															 GrindMarkRect [12].bottom=  GrindMarkRect [12].top  + GrindMarkLength  ;  
														 }

														 // 														 GrindMarkRectPoint5.x = GrindMarkRect[12].left + (GrindMarkRect[12].right  - GrindMarkRect[12].left)/2; 
														 // 														 GrindMarkRectPoint5.y = GrindMarkRect[12].top  + (GrindMarkRect[12].bottom - GrindMarkRect[12].top )/2; 

														 GrindMeaDis = Math.GetLength( GrindMarkRectCenter[12], OrgC5CirOutPoint[k]);
														 if(GrindMeaDis<MinDis){
															 MinDis = GrindMeaDis;
															 C5GrindMarkCount = k;
														 }
													 }
													 // GrindMark기준 수직 평균값 연마량 측정 
													 if(C5GrindMarkCount!=0 && C5GrindMarkCount>5 && (C5GrindMarkCount+5)<OrgC5CirOutEdgeCount){
														 CircleCount=0,TotalCirDis=0.0f,GrindWidthDis=0.0f;
														 for(int k=C5GrindMarkCount-5; k<C5GrindMarkCount+5; k++){
															 if(OrgC5CirOutPoint[k].x==0.0f && OrgC5CirOutPoint[k].y==0.0f) continue;
															 if(OrgC5CirInPoint [k].x==0.0f && OrgC5CirInPoint [k].y==0.0f) continue;
															 GrindWidthDis = Math.GetLength(OrgC5CirInPoint[k], OrgC5CirOutPoint[k]);
															 TotalCirDis+=   GrindWidthDis;
															 CircleCount++;
														 }
														 if(TotalCirDis!=0.0f && CircleCount!=0){
															 TrenchRightGrindWd = TotalCirDis/CircleCount;
														 }
													 }
												 }


												 // GrindMarkPoint13 Calc 진행함(연마량,가공량)
												 if(GrindMarkPoint[13].x!=0.0f && GrindMarkPoint[13].y!=0.0f){
													 GrindMeaDis =0.0f, MinDis =10000.0f; C5GrindMarkCount=0;
													 for(int k=0; k<OrgC5CirOutEdgeCount; k++){
														 if(OrgC5CirOutPoint[k].x==0.0f || OrgC5CirOutPoint[k].y==0.0f) continue;
														 if(GrindMarkPoint[13].x  ==0.0f || GrindMarkPoint[13].y  ==0.0f) continue;

														 GrindMeaDis = Math.GetLength(GrindMarkPoint[13], OrgC5CirOutPoint[k]);
														 if(GrindMeaDis<MinDis){
															 MinDis = GrindMeaDis;
															 C5GrindMarkCount = k;
														 }
													 }
													 // GrindMark기준 수직 포인트 주변값 Avg산출한다 
													 if(C5GrindMarkCount!=0 && C5GrindMarkCount>5){
														 CircleCount=0,TotalCirDis=0.0f,GrindMeaDis=0.0f;
														 for(int k=C5GrindMarkCount-5; k<C5GrindMarkCount+5; k++){
															 if(OrgC5CirOutPoint[k].x==0.0f || OrgC5CirOutPoint[k].y==0.0f) continue;

															 GrindMeaDis = Math.GetLength(GrindMarkPoint[13], OrgC5CirOutPoint[k]);
															 TotalCirDis+= GrindMeaDis;
															 CircleCount++;
														 }
														 if(TotalCirDis!=0.0f && CircleCount!=0){
															 C5CirGrindMea = TotalCirDis/CircleCount;
														 }
													 }
													 // GrindMark기준 수직 평균값 연마량 측정 
													 if(C5GrindMarkCount!=0 && C5GrindMarkCount>5){
														 CircleCount=0,TotalCirDis=0.0f,GrindWidthDis=0.0f;
														 for(int k=C5GrindMarkCount-5; k<C5GrindMarkCount+5; k++){
															 if(OrgC5CirOutPoint[k].x==0.0f && OrgC5CirOutPoint[k].y==0.0f) continue;
															 if(OrgC5CirInPoint [k].x==0.0f && OrgC5CirInPoint [k].y==0.0f) continue;
															 GrindWidthDis = Math.GetLength(OrgC5CirInPoint[k], OrgC5CirOutPoint[k]);
															 TotalCirDis+=   GrindWidthDis;
															 CircleCount++;
														 }
														 if(TotalCirDis!=0.0f && CircleCount!=0){
															 C5CirGrindWd = TotalCirDis/CircleCount;
														 }
													 }
												 }
												 else { // Grind Mark 못 찾았을경우 (가공량 0, 연마량 계산함)
													 GrindMeaDis =0.0f, MinDis =10000.0f; C5GrindMarkCount=0;
													 for(int k=0; k<OrgC5CirOutEdgeCount; k++){
														 if(OrgC5CirOutPoint[k].x==0.0f || OrgC5CirOutPoint[k].y==0.0f) continue;

														 GrindMarkRectCenter[13].x = GrindMarkRect[13].left + (GrindMarkRect[13].right  - GrindMarkRect[13].left)/2; 
														 GrindMarkRectCenter[13].y = GrindMarkRect[13].top  + (GrindMarkRect[13].bottom - GrindMarkRect[13].top )/2; 

														 GrindMeaDis = Math.GetLength( GrindMarkRectCenter[13], OrgC5CirOutPoint[k]);
														 if(GrindMeaDis<MinDis){
															 MinDis = GrindMeaDis;
															 C5GrindMarkCount = k;
														 }
													 }
													 // GrindMark기준 수직 평균값 연마량 측정 
													 if(C5GrindMarkCount!=0 && C5GrindMarkCount>5){
														 CircleCount=0,TotalCirDis=0.0f,GrindWidthDis=0.0f;
														 for(int k=C5GrindMarkCount-5; k<C5GrindMarkCount+5; k++){
															 if(OrgC5CirOutPoint[k].x==0.0f && OrgC5CirOutPoint[k].y==0.0f) continue;
															 if(OrgC5CirInPoint [k].x==0.0f && OrgC5CirInPoint [k].y==0.0f) continue;
															 GrindWidthDis = Math.GetLength(OrgC5CirInPoint[k], OrgC5CirOutPoint[k]);
															 TotalCirDis+=   GrindWidthDis;
															 CircleCount++;
														 }
														 if(TotalCirDis!=0.0f && CircleCount!=0){
															 C5CirGrindWd = TotalCirDis/CircleCount;
														 }
													 }
												 }
											 }
										 }
										 else         {// EnCap 가공량 계산 
											 if(OrgC5CirInEdgeCount==OrgC5CirOutEdgeCount){
												 double OutDis=0.0f, InDis=0.0f, TotalGrindWidth=0.0f, AvgGrindWidth=0.0f;C5GrindWidthCount=0;
												 for(int k=0; k<OrgC5CirInEdgeCount; k++){
													 if(OrgC5CirOutPoint[k].x==0.0f && OrgC5CirOutPoint[k].y==0.0f){
														 OutDis =0.0f;
													 }
													 else {
														 OutDis = Math.GetLengthFrPointToPoint(C5CirCenter,OrgC5CirOutPoint[k]);
													 }

													 if(OrgC5CirInPoint[k].x==0.0f && OrgC5CirInPoint[k].y==0.0f){
														 InDis =0.0f;
													 }
													 else {
														 InDis = Math.GetLengthFrPointToPoint(C5CirCenter,OrgC5CirInPoint[k]);
													 }

													 if(OutDis!=0.0f && InDis!=0.0f){
														 TotalGrindWidth+=(OutDis - InDis);
														 C5GrindWidthCount++;
													 }
												 }
												 if(C5GrindWidthCount!=0){
													 AvgGrindWidth = (TotalGrindWidth/C5GrindWidthCount);
													 C5CirGrindWd = AvgGrindWidth;
												 }
											 }
										 }
									 }
									 // C5Circle 연마량 가공량 검사 시퀀스 종료(TrackMode VS MarkMode)
									 //////////////////////////////////////////////////////////////////////////////////////////////////////

									 // Org Circle데이터중 유호하지 않은 값을 제외한 실제 존재하는 데이터 기준으로 동적 메모리 생성함
									 // Circle Defect검사에 필요한 Edge데이터 값
									 int Count=0;
									 if(OrgC5CirInEdgeCount>0){
										 C5CirInEdgeCount = OrgC5CirInEdgeCount - C5CirInEdgeCount;
										 // 										 C5CirInEdgeCount = OrgC5CirInEdgeCount;
										 if(C5CirInEdgeCount>0){
											 if(C5CirInPoint!=NULL) delete[] C5CirInPoint;
											 C5CirInPoint = new TFPoint[C5CirInEdgeCount];

											 for(int k=0; k<OrgC5CirInEdgeCount; k++){
												 if(k>MAX_CIRCLE_EDGEPOINT) break;
												 if(OrgC5CirInPoint[k].x==0.0f && OrgC5CirInPoint[k].y==0.0f) continue;
												 C5CirInPoint[Count].x = OrgC5CirInPoint[k].x;
												 C5CirInPoint[Count].y = OrgC5CirInPoint[k].y;
												 Count++;
											 }
										 }
										 // Circle 원본 데이터 메모리 삭제
										 if(OrgC5CirInPoint!=NULL) delete[] OrgC5CirInPoint;
									 }
									 // Circle Fitting 결과물 
									 SampleSize = C5CirInEdgeCount*0.75; //0.5~0.8이하로 입력할것
									 DistDevRatio = 0.15; //0.1~0.25 이하로 입력할것
									 // 									Radius = 0;
									 CircleFit->OnRansac(C5CirInPoint,C5CirInEdgeCount,SampleSize,DistDevRatio,&CircleFit5Center,&CirFitDiameter5);

									 if(OrgC5CirOutEdgeCount>0){
										 C5CirOutEdgeCount = OrgC5CirOutEdgeCount - C5CirOutEdgeCount;
										 Count =0;
										 if(C5CirOutEdgeCount>0){
											 if(C5CirOutPoint!=NULL) delete[] C5CirOutPoint;
											 C5CirOutPoint = new TFPoint[C5CirOutEdgeCount];

											 for(int k=0; k<OrgC5CirOutEdgeCount; k++){
												 if(k>MAX_CIRCLE_EDGEPOINT) break;
												 if(OrgC5CirOutPoint[k].x==0.0f && OrgC5CirOutPoint[k].y==0.0f) continue;
												 C5CirOutPoint[Count].x = OrgC5CirOutPoint[k].x;
												 C5CirOutPoint[Count].y = OrgC5CirOutPoint[k].y;
												 Count++;
											 }
										 }
										 // Circle 원본 데이터 메모리 삭제
										 if(OrgC5CirOutPoint!=NULL) delete[] OrgC5CirOutPoint;
									 }
									 if(OrgC5CirStandEdgeCount>0){
										 C5CirStandEdgeCount = OrgC5CirStandEdgeCount - C5CirStandEdgeCount;
										 // 										 C5CirStandEdgeCount = OrgC5CirStandEdgeCount;
										 Count =0;
										 if(C5CirStandEdgeCount>0){
											 if(C5CirStandPoint!=NULL) delete[] C5CirStandPoint;
											 C5CirStandPoint = new TFPoint[C5CirStandEdgeCount];

											 for(int k=0; k<OrgC5CirStandEdgeCount; k++){
												 if(k>MAX_CIRCLE_EDGEPOINT) break;
												 if(OrgC5CirStandPoint[k].x==0.0f && OrgC5CirStandPoint[k].y==0.0f) continue;
												 C5CirStandPoint[Count].x = OrgC5CirStandPoint[k].x;
												 C5CirStandPoint[Count].y = OrgC5CirStandPoint[k].y;
												 Count++;
											 }
										 }
										 // Circle 원본 데이터 메모리 삭제
										 if(OrgC5CirStandPoint!=NULL) delete[] OrgC5CirStandPoint;
									 }
									 LogUnit.SetLog(L"Circle_5_Insp_End");   
									 // Circle 영역 꽃박리, 원형박리 검출 목적 시퀀스(EnCap)
									 // 정식 명칭은 몰라서.....일단 Crack으로 정함 
									 if(!IsMarkBtm && BrokenThresHold!=0){
										 if(CirFitDiameter5!=0.0f && CircleFit5Center.x!=0.0f && CircleFit5Center.y!=0.0f){ // FAVION Circle Fitting 성공시 박리검사 진행 
											 Circle->GImage = &RotateBrokenImg;                                             //Binary Image 넘겨줌 

											 Circle->SetCenterXY(CircleFit5Center.x,CircleFit5Center.y)       ;
											 Circle->SetTolerance((dEdgeToTrapLineDis/2)-CirOffsetMargin)     ; // Circle Tolerance 
											 Circle->SetDiameter ((CirFitDiameter5-(dEdgeToTrapLineDis/2))*2); // Circle Diameter 
											 Circle->SetCircleChoice(0)                                       ; // 0:From Begin, 1:From End, 2:Largest Amplitude 
											 Circle->SetCircleType  (2)                                       ; // 0:Black to White, 1:White to Black 2: Both Black, White 
											 Circle->SetCircleIndex (0)                                       ; // Circle EdgePoint Index 
											 Circle->OnExecute(true)                                          ;
											 CrackCirDiameter5 = (CirFitDiameter5-(dEdgeToTrapLineDis/2))+((dEdgeToTrapLineDis/2)-CirOffsetMargin);

											 C5CirInCrackCount = Circle->FCirclePointCount;

											 if(C5CirInCrackCount>0){
												 if(C5CirInCrackPoint!=NULL) delete[] C5CirInCrackPoint;
												 C5CirInCrackPoint = new TFPoint[C5CirInCrackCount];

												 for(int k=0; k<C5CirInCrackCount; k++){
													 if(k>MAX_CIRCLE_EDGEPOINT) break;
													 C5CirInCrackPoint[k].x = Circle->FCirclePoint[k].x;
													 C5CirInCrackPoint[k].y = Circle->FCirclePoint[k].y;
												 }
											 }
										 }
									 }
								 }

								 // 여섯번째 Circle EdgePoint Data 추출 
								 if(C6CirCenter.x!=0 && C6CirCenter.y!=0){
									 LogUnit.SetLog(L"Circle_6_Insp_Start");    

									 // 									 if(BtmEdgeThresHold==0) Circle->GImage = &RotateImg      ; //Org Image 넘겨줌 
									 // 									 else                    Circle->GImage = &RotateBinaryImg; //Binary Image 넘겨줌 

									 if(CirGrindInThresHold==0) Circle->GImage = &RotateImg             ; //Org Image 넘겨줌 
									 else                       Circle->GImage = &RotateGrindInBinaryImg; //Binary Image 넘겨줌 

									 if      (FInspectMode==Insp_Track) Circle->SetCenterXY(TrackC6CirCenter.x , TrackC6CirCenter.y); // TrackLine 교차점 기준 센터 
									 else if (FInspectMode==Insp_Mark ) Circle->SetCenterXY(C6CirCenter.x      , C6CirCenter.y     ); // 외곽라인 교차점 기준 센터 
									 // Diameter 계산함(OutCircle과 TrackCircle 중간값 기준)
									 // 									 C6Diameter = ((CSideCircleWidth*2)+(TrackCircleWidth*2))/2;
									 C6Diameter = (CSideCircleWidth*2);
									 // 									 C6Diameter = (CSideCircleWidth*2);
									 if(IsMarkBtm) Circle->SetTolerance(60.0f);
									 else          Circle->SetTolerance(80.0f);
									 // 									 Circle->SetTolerance(40.0f )         ; // Circle Tolerance 
									 Circle->SetDiameter (C6Diameter)     ; // Circle Diameter 
									 // 									 Circle->SetCircleChoice(0)           ; // 0:From Begin, 1:From End, 2:Largest Amplitude 
									 // 									 Circle->SetCircleIndex (0)           ; // Circle EdgePoint Index 
									 Circle->SetCircleChoice(1)           ; // 0:From Begin, 1:From End, 2:Largest Amplitude 
									 Circle->SetCircleType  (2)           ; // 0:Black to White, 1:White to Black 2: Both Black, White 
									 Circle->SetCircleIndex (1)           ; // Circle EdgePoint Index 

									 // 									 Circle->SetAngle(0)                  ; // Cirlce Angle 
									 // 									 Circle->SetAmplitude(90)             ; // Circle Amplitude
									 if(SideCirDeg>=0){
										 if(90-SideCirDeg>=0) Circle->SetAngle(90-SideCirDeg+CirAngleMargin   );  // Circle Fitting 시작점 각도
										 Circle->SetAmplitude(SideCirDeg-2*CirAngleMargin);  // Circle Fitting 시작점 부터 검사 범위 
									 }

									 // 									 Circle->SetCircleType(1)             ; // 0:Black to White, 1:White to Black 2: Both Black, White 
									 Circle->OnExecute()                  ;

									 // Circle In Data 기준 새로운 Circle Center 좌표 받아옴 
									 RealC6CirCenter.x = Circle->FCP.x;
									 RealC6CirCenter.y = Circle->FCP.y;
									 CirDiameter6      = (Circle->Diameter)/2.0;

									 // Circle In Data취합 
									 OrgC6CirInEdgeCount = Circle->FCirclePointCount;
									 if(OrgC6CirInEdgeCount>0){
										 if(OrgC6CirInPoint!=NULL) delete[] OrgC6CirInPoint;
										 OrgC6CirInPoint = new TFPoint[OrgC6CirInEdgeCount];

										 for(int k=0; k<OrgC6CirInEdgeCount; k++){
											 if(k>MAX_CIRCLE_EDGEPOINT) break;
											 OrgC6CirInPoint[k].x = Circle->FCirclePoint[k].x;
											 OrgC6CirInPoint[k].y = Circle->FCirclePoint[k].y;
											 if(OrgC6CirInPoint[k].x==0.0f && OrgC6CirInPoint[k].y==0.0f) C6CirInEdgeCount++;
											 // BTM영역 Circle을 제외한 영역 Defect검사 목적에 좌표계산 
											 // 											 if(k==0) {BtmEdgePoint1.x = C1CirInPoint[k].x; BtmEdgePoint1.y = C1CirInPoint[k].y;}
										 }
									 }

									 // Circle Out Data목적 다시 검사  
									 if(BtmEdgeThresHold==0) Circle->GImage = &RotateImg      ; //Org Image 넘겨줌 
									 else                    Circle->GImage = &RotateBinaryImg; //Binary Image 넘겨줌 

									 if(IsMarkBtm) Circle->SetTolerance(60.0f);
									 else          Circle->SetTolerance(80.0f);
									 // 									 Circle->SetTolerance(40.0f )                      ; // Circle Tolerance 
									 Circle->SetDiameter (C6Diameter)                  ; // Circle Diameter 
									 // 									 Circle->SetCircleType(0)                          ; // 0:Black to White, 1:White to Black 2: Both Black, White 
									 Circle->SetCircleChoice(1)                        ; // 0:From Begin, 1:From End, 2:Largest Amplitude 
									 Circle->SetCircleType  (2)                        ; // 0:Black to White, 1:White to Black 2: Both Black, White 
									 Circle->SetCircleIndex (0)                        ; // Circle EdgePoint Index 

									 Circle->OnExecute()                               ;

									 // Circle Out Data취합 
									 OrgC6CirOutEdgeCount = Circle->FCirclePointCount;
									 if(OrgC6CirOutEdgeCount>0){
										 if(OrgC6CirOutPoint!=NULL) delete[] OrgC6CirOutPoint;
										 OrgC6CirOutPoint = new TFPoint[OrgC6CirOutEdgeCount];

										 for(int k=0; k<OrgC6CirOutEdgeCount; k++){
											 if(k>MAX_CIRCLE_EDGEPOINT) break;
											 OrgC6CirOutPoint[k].x = Circle->FCirclePoint[k].x;
											 OrgC6CirOutPoint[k].y = Circle->FCirclePoint[k].y;
											 // BTM영역 Circle을 제외한 영역 Defect검사 목적에 좌표계산 
											 if(k==(OrgC6CirOutEdgeCount-1)) {BtmEdgePoint[9].x = OrgC6CirOutPoint[k].x; BtmEdgePoint[9].y = OrgC6CirOutPoint[k].y;}
											 if(OrgC6CirOutPoint[k].x==0.0f && OrgC6CirOutPoint[k].y==0.0f) C6CirOutEdgeCount++;
										 }
									 }
									 // C6Circle Grind_Width, Grind_Measure 
									 // C6Circle 연마량 가공량 검사 시퀀스 시작(TrackMode VS MarkMode)
									 if(FInspectMode==Insp_Track){
										 if(OrgC6CirInEdgeCount==OrgC6CirOutEdgeCount){//연마량 계산 
											 double OutDis=0.0f, InDis=0.0f, TotalGrindWidth=0.0f, AvgGrindWidth=0.0f; C6GrindWidthCount=0;
											 for(int k=0; k<OrgC6CirInEdgeCount; k++){
												 if(OrgC6CirOutPoint[k].x==0.0f && OrgC6CirOutPoint[k].y==0.0f){
													 OutDis =0.0f;
												 }
												 else {
													 OutDis = Math.GetLengthFrPointToPoint(C6CirCenter,OrgC6CirOutPoint[k]);
												 }

												 if(OrgC6CirInPoint[k].x==0.0f && OrgC6CirInPoint[k].y==0.0f){
													 InDis =0.0f;
												 }
												 else {
													 InDis = Math.GetLengthFrPointToPoint(C6CirCenter,OrgC6CirInPoint[k]);
												 }

												 if(OutDis!=0.0f && InDis!=0.0f){
													 TotalGrindWidth+=(OutDis - InDis);
													 C6GrindWidthCount++;
												 }
											 }
											 if(C6GrindWidthCount!=0){
												 AvgGrindWidth = (TotalGrindWidth/C6GrindWidthCount);
												 C6CirGrindWd = AvgGrindWidth;
											 }
										 }
										 if(IsMarkBtm){ // LTPS 가공량 계산 
											 if(CirGrindMeaThresHold!=0){
												 Circle->GImage = &RotateGrindBinaryImg  ; //Binary Image 넘겨줌 
												 Circle->SetCircleChoice(1)                ; // 0:From Begin, 1:From End, 2:Largest Amplitude 
												 Circle->SetCircleType(2)                  ; // 0:Black to White, 1:White to Black 2: Both Black, White 
												 Circle->SetCircleIndex (1)                ; // Circle EdgePoint Index 

												 Circle->SetTolerance(40.0f )            ; // Circle Tolerance 
												 Circle->SetDiameter (C6Diameter)        ; // Circle Diameter 
												 // 										 Circle->SetCircleType(1)                ; // 0:Black to White, 1:White to Black 2: Both Black, White 
												 Circle->OnExecute()                     ;

												 // Circle In Data 기준 새로운 Circle Center 좌표 받아옴 
												 RealC6CirCenter.x = Circle->FCP.x;
												 RealC6CirCenter.y = Circle->FCP.y;

												 OrgC6CirStandEdgeCount = Circle->FCirclePointCount;
												 if(OrgC6CirStandEdgeCount>0){
													 if(OrgC6CirStandPoint!=NULL) delete[] OrgC6CirStandPoint;
													 OrgC6CirStandPoint = new TFPoint[OrgC6CirStandEdgeCount];

													 PreC6CirStandPoint[0].x=0.0f; PreC6CirStandPoint[0].y=0.0f;
													 for(int k=0; k<OrgC6CirStandEdgeCount; k++){
														 if(k>MAX_CIRCLE_EDGEPOINT) break;
														 OrgC6CirStandPoint[k].x = Circle->FCirclePoint[k].x;
														 OrgC6CirStandPoint[k].y = Circle->FCirclePoint[k].y;
														 if(OrgC6CirStandPoint[k].x==0.0f && OrgC6CirStandPoint[k].y==0.0f) C6CirStandEdgeCount++;
														 // TrackLine 자재 상태에 따라서 잘못된 EdgePoint를 찾을경우 대비하여 이전데이터 기준 데이터 복원 
														 if(OrgC6CirStandPoint[k].x!=0.0f && OrgC6CirStandPoint[k].y!=0.0f){
															 // 첫번째는 무조건 데이터 넘겨줌 
															 if(PreC6CirStandPoint[0].x==0.0f && PreC6CirStandPoint[0].y==0.0f){
																 PreC6CirStandPoint[0].x = OrgC6CirStandPoint[k].x; 
																 PreC6CirStandPoint[0].y = OrgC6CirStandPoint[k].y; 
															 }
															 else {
																 if(fabs (OrgC6CirStandPoint[k].x-PreC6CirStandPoint[0].x)>TrackLineMargin ||
																	 fabs(OrgC6CirStandPoint[k].y-PreC6CirStandPoint[0].y)>TrackLineMargin   ){
																		 OrgC6CirStandPoint[k].x = PreC6CirStandPoint[0].x-0.5;
																		 OrgC6CirStandPoint[k].y = PreC6CirStandPoint[0].y+0.5;

																		 PreC6CirStandPoint[0].x = OrgC6CirStandPoint[k].x; 
																		 PreC6CirStandPoint[0].y = OrgC6CirStandPoint[k].y; 
																 }
																 else {
																	 PreC6CirStandPoint[0].x = OrgC6CirStandPoint[k].x; 
																	 PreC6CirStandPoint[0].y = OrgC6CirStandPoint[k].y; 
																 }
															 }
														 }
													 }
													 //C6Circle Grind_Measure Calculate 
													 if(OrgC6CirOutEdgeCount==OrgC6CirStandEdgeCount){
														 double GrindMeaDis=0.0f, TotalGrindMeasure=0.0f, AvgGrindMeasure=0.0f; C6GrindMeasureCount=0;
														 for(int k=0; k<OrgC6CirInEdgeCount; k++){
															 if(OrgC6CirOutPoint[k].x==0.0f || OrgC6CirOutPoint[k].y==0.0f || OrgC6CirStandPoint[k].x==0.0f || OrgC6CirStandPoint[k].y==0.0f){
																 GrindMeaDis =0.0f;
															 }
															 else {
																 GrindMeaDis = Math.GetLengthFrPointToPoint(OrgC6CirStandPoint[k],OrgC6CirOutPoint[k]);
															 }

															 if(GrindMeaDis!=0.0f){
																 TotalGrindMeasure+= GrindMeaDis;
																 C6GrindMeasureCount++;
															 }
														 }
														 if(C6GrindMeasureCount!=0){
															 AvgGrindMeasure = (TotalGrindMeasure/C6GrindMeasureCount);
															 C6CirGrindMea= AvgGrindMeasure;
														 }
													 }
													 else if(OrgC6CirStandEdgeCount>OrgC6CirOutEdgeCount){ // 연마가 적게되어 실제 TrackLine보다 EdgePoint데이터가 적을경우 
														 double GrindMeaDis=0.0f, TotalGrindMeasure=0.0f, AvgGrindMeasure=0.0f;
														 for(int k=0; k<OrgC6CirStandEdgeCount; k++){
															 if(OrgC6CirOutPoint[k].x==0.0f || OrgC6CirOutPoint[k].y==0.0f || OrgC6CirStandPoint[k].x==0.0f || OrgC6CirStandPoint[k].y==0.0f ){
																 GrindMeaDis =0.0f;
															 }
															 else {
																 GrindMeaDis = Math.GetLengthFrPointToPoint(OrgC6CirStandPoint[k],OrgC6CirOutPoint[k]);
															 }

															 if(GrindMeaDis!=0.0f){
																 TotalGrindMeasure+= GrindMeaDis;
																 C6GrindMeasureCount++;
															 }
														 }
														 if(C6GrindMeasureCount!=0){
															 AvgGrindMeasure = (TotalGrindMeasure/C6GrindMeasureCount);
															 C6CirGrindMea= AvgGrindMeasure;
														 }
													 }
													 else if(OrgC6CirStandEdgeCount<OrgC6CirOutEdgeCount){
														 double GrindMeaDis=0.0f, TotalGrindMeasure=0.0f, AvgGrindMeasure=0.0f;
														 for(int k=0; k<OrgC6CirStandEdgeCount; k++){
															 if(OrgC6CirOutPoint[k].x==0.0f || OrgC6CirOutPoint[k].y==0.0f || OrgC6CirStandPoint[k].x==0.0f || OrgC6CirStandPoint[k].y==0.0f ){
																 GrindMeaDis =0.0f;
															 }
															 else {
																 GrindMeaDis = Math.GetLengthFrPointToPoint(OrgC6CirStandPoint[k],OrgC6CirOutPoint[k]);
															 }

															 if(GrindMeaDis!=0.0f){
																 TotalGrindMeasure+= GrindMeaDis;
																 C6GrindMeasureCount++;
															 }
														 }
														 if(C6GrindMeasureCount!=0){
															 AvgGrindMeasure = (TotalGrindMeasure/C6GrindMeasureCount);
															 C6CirGrindMea= AvgGrindMeasure;
														 }
													 }
												 }
											 }
										 }
									 }
									 else if(FInspectMode==Insp_Mark){ // MarkMode 
										 if(IsMarkBtm){ // LTPS 가공량 계산 ==> 연마량 계산 
											 if(OrgC6CirOutEdgeCount!=0 && OrgC6CirInEdgeCount!=0){// 연마량이 존재할경우 가공량 검사를 진행함 
												 GrindMeaDis =0.0f, MinDis =10000.0f; C6GrindMarkCount=0;
												 if(GrindMarkPoint[17].x!=0.0f && GrindMarkPoint[17].y!=0.0f){
													 for(int k=0; k<OrgC6CirOutEdgeCount; k++){
														 if(OrgC6CirOutPoint[k].x==0.0f || OrgC6CirOutPoint[k].y==0.0f) continue;
														 if(GrindMarkPoint[17].x  ==0.0f || GrindMarkPoint[17].y  ==0.0f) continue;

														 GrindMeaDis = Math.GetLength(GrindMarkPoint[17], OrgC6CirOutPoint[k]);
														 if(GrindMeaDis<MinDis){
															 MinDis = GrindMeaDis;
															 C6GrindMarkCount = k;
														 }
													 }
													 // GrindMark기준 수직 포인트 주변값 Avg산출한다 
													 if(C6GrindMarkCount!=0 && C6GrindMarkCount>5){
														 CircleCount=0,TotalCirDis=0.0f,GrindMeaDis=0.0f;
														 for(int k=C6GrindMarkCount-5; k<C6GrindMarkCount+5; k++){
															 if(OrgC6CirOutPoint[k].x==0.0f || OrgC6CirOutPoint[k].y==0.0f) continue;

															 GrindMeaDis = Math.GetLength(GrindMarkPoint[17], OrgC6CirOutPoint[k]);
															 TotalCirDis+= GrindMeaDis;
															 CircleCount++;
														 }
														 if(TotalCirDis!=0.0f && CircleCount!=0){
															 C6CirGrindMea = TotalCirDis/CircleCount;
														 }
													 }
													 // GrindMark기준 수직 평균값 연마량 측정 
													 if(C6GrindMarkCount!=0 && C6GrindMarkCount>5){
														 CircleCount=0,TotalCirDis=0.0f,GrindWidthDis=0.0f;
														 for(int k=C6GrindMarkCount-5; k<C6GrindMarkCount+5; k++){
															 if(OrgC6CirOutPoint[k].x==0.0f && OrgC6CirOutPoint[k].y==0.0f) continue;
															 if(OrgC6CirInPoint [k].x==0.0f && OrgC6CirInPoint [k].y==0.0f) continue;
															 GrindWidthDis = Math.GetLength(OrgC6CirInPoint[k], OrgC6CirOutPoint[k]);
															 TotalCirDis+=   GrindWidthDis;
															 CircleCount++;
														 }
														 if(TotalCirDis!=0.0f && CircleCount!=0){
															 C6CirGrindWd = TotalCirDis/CircleCount;
														 }
													 }
												 }
												 else { // Grind Mark 못 찾았을경우 (가공량 0, 연마량 계산함)
													 for(int k=0; k<OrgC6CirOutEdgeCount; k++){
														 if(OrgC6CirOutPoint[k].x==0.0f || OrgC6CirOutPoint[k].y==0.0f) continue;

														 GrindMarkRectCenter[17].x = GrindMarkRect[17].left + (GrindMarkRect[17].right  - GrindMarkRect[17].left)/2; 
														 GrindMarkRectCenter[17].y = GrindMarkRect[17].top  + (GrindMarkRect[17].bottom - GrindMarkRect[17].top )/2; 

														 GrindMeaDis = Math.GetLength(GrindMarkRectCenter[17], OrgC6CirOutPoint[k]);
														 if(GrindMeaDis<MinDis){
															 MinDis = GrindMeaDis;
															 C6GrindMarkCount = k;
														 }
													 }
													 // GrindMark기준 수직 평균값 연마량 측정 
													 if(C6GrindMarkCount!=0 && C6GrindMarkCount>5){
														 CircleCount=0,TotalCirDis=0.0f,GrindWidthDis=0.0f;
														 for(int k=C6GrindMarkCount-5; k<C6GrindMarkCount+5; k++){
															 if(OrgC6CirOutPoint[k].x==0.0f && OrgC6CirOutPoint[k].y==0.0f) continue;
															 if(OrgC6CirInPoint [k].x==0.0f && OrgC6CirInPoint [k].y==0.0f) continue;
															 GrindWidthDis = Math.GetLength(OrgC6CirInPoint[k], OrgC6CirOutPoint[k]);
															 TotalCirDis+=   GrindWidthDis;
															 CircleCount++;
														 }
														 if(TotalCirDis!=0.0f && CircleCount!=0){
															 C6CirGrindWd = TotalCirDis/CircleCount;
														 }
													 }
													 // GrindMark기준 수직 평균값 연마량 측정 
													 if(C6GrindMarkCount!=0 && C6GrindMarkCount>5){
														 CircleCount=0,TotalCirDis=0.0f,GrindWidthDis=0.0f;
														 for(int k=C6GrindMarkCount-5; k<C6GrindMarkCount+5; k++){
															 if(OrgC6CirOutPoint[k].x==0.0f && OrgC6CirOutPoint[k].y==0.0f) continue;
															 if(OrgC6CirInPoint [k].x==0.0f && OrgC6CirInPoint [k].y==0.0f) continue;
															 GrindWidthDis = Math.GetLength(OrgC6CirInPoint[k], OrgC6CirOutPoint[k]);
															 TotalCirDis+=   GrindWidthDis;
															 CircleCount++;
														 }
														 if(TotalCirDis!=0.0f && CircleCount!=0){
															 C6CirGrindWd = TotalCirDis/CircleCount;
														 }
													 }
												 }
											 }
										 }
										 else          { // EnCap 연마량 계산 
											 if(OrgC6CirInEdgeCount==OrgC6CirOutEdgeCount){//연마량 계산 
												 double OutDis=0.0f, InDis=0.0f, TotalGrindWidth=0.0f, AvgGrindWidth=0.0f; C6GrindWidthCount=0;
												 for(int k=0; k<OrgC6CirInEdgeCount; k++){
													 if(OrgC6CirOutPoint[k].x==0.0f && OrgC6CirOutPoint[k].y==0.0f){
														 OutDis =0.0f;
													 }
													 else {
														 OutDis = Math.GetLengthFrPointToPoint(C6CirCenter,OrgC6CirOutPoint[k]);
													 }

													 if(OrgC6CirInPoint[k].x==0.0f && OrgC6CirInPoint[k].y==0.0f){
														 InDis =0.0f;
													 }
													 else {
														 InDis = Math.GetLengthFrPointToPoint(C6CirCenter,OrgC6CirInPoint[k]);
													 }

													 if(OutDis!=0.0f && InDis!=0.0f){
														 TotalGrindWidth+=(OutDis - InDis);
														 C6GrindWidthCount++;
													 }
												 }
												 if(C6GrindWidthCount!=0){
													 AvgGrindWidth = (TotalGrindWidth/C6GrindWidthCount);
													 C6CirGrindWd = AvgGrindWidth;
												 }
											 }
										 }
									 }
									 // C6Circle 연마량 가공량 검사 시퀀스 종료(TrackMode VS MarkMode)
									 //////////////////////////////////////////////////////////////////////////////////////////////////////

									 // Org Circle데이터중 유호하지 않은 값을 제외한 실제 존재하는 데이터 기준으로 동적 메모리 생성함
									 // Circle Defect검사에 필요한 Edge데이터 값
									 int Count=0;
									 if(OrgC6CirInEdgeCount>0){
										 C6CirInEdgeCount = OrgC6CirInEdgeCount - C6CirInEdgeCount;
										 // 										 C6CirInEdgeCount = OrgC6CirInEdgeCount;
										 if(C6CirInEdgeCount>0){
											 if(C6CirInPoint!=NULL) delete[] C6CirInPoint;
											 C6CirInPoint = new TFPoint[C6CirInEdgeCount];

											 for(int k=0; k<OrgC6CirInEdgeCount; k++){
												 if(k>MAX_CIRCLE_EDGEPOINT) break;
												 if(OrgC6CirInPoint[k].x==0.0f && OrgC6CirInPoint[k].y==0.0f) continue;
												 C6CirInPoint[Count].x = OrgC6CirInPoint[k].x;
												 C6CirInPoint[Count].y = OrgC6CirInPoint[k].y;
												 Count++;
											 }
										 }
										 // Circle 원본 데이터 메모리 삭제
										 if(OrgC6CirInPoint!=NULL) delete[] OrgC6CirInPoint;
									 }
									 // Circle Fitting 결과물 
									 SampleSize = C6CirInEdgeCount*0.75; //0.5~0.8이하로 입력할것
									 DistDevRatio = 0.15; //0.1~0.25 이하로 입력할것
									 // 									Radius = 0;
									 CircleFit->OnRansac(C6CirInPoint,C6CirInEdgeCount,SampleSize,DistDevRatio,&CircleFit6Center,&CirFitDiameter6);

									 if(OrgC6CirOutEdgeCount>0){
										 C6CirOutEdgeCount = OrgC6CirOutEdgeCount - C6CirOutEdgeCount;
										 Count =0;
										 if(C6CirOutEdgeCount>0){
											 if(C6CirOutPoint!=NULL) delete[] C6CirOutPoint;
											 C6CirOutPoint = new TFPoint[C6CirOutEdgeCount];

											 for(int k=0; k<OrgC6CirOutEdgeCount; k++){
												 if(k>MAX_CIRCLE_EDGEPOINT) break;
												 if(OrgC6CirOutPoint[k].x==0.0f && OrgC6CirOutPoint[k].y==0.0f) continue;
												 C6CirOutPoint[Count].x = OrgC6CirOutPoint[k].x;
												 C6CirOutPoint[Count].y = OrgC6CirOutPoint[k].y;
												 Count++;
											 }
										 }
										 // Circle 원본 데이터 메모리 삭제
										 if(OrgC6CirOutPoint!=NULL) delete[] OrgC6CirOutPoint;
									 }
									 if(OrgC6CirStandEdgeCount>0){
										 C6CirStandEdgeCount = OrgC6CirStandEdgeCount - C6CirStandEdgeCount;
										 // 										 C6CirStandEdgeCount = OrgC6CirStandEdgeCount;
										 Count =0;
										 if(C6CirStandEdgeCount>0){
											 if(C6CirStandPoint!=NULL) delete[] C6CirStandPoint;
											 C6CirStandPoint = new TFPoint[C6CirStandEdgeCount];

											 for(int k=0; k<OrgC6CirStandEdgeCount; k++){
												 if(k>MAX_CIRCLE_EDGEPOINT) break;
												 if(OrgC6CirStandPoint[k].x==0.0f && OrgC6CirStandPoint[k].y==0.0f) continue;
												 C6CirStandPoint[Count].x = OrgC6CirStandPoint[k].x;
												 C6CirStandPoint[Count].y = OrgC6CirStandPoint[k].y;
												 Count++;
											 }
										 }
										 // Circle 원본 데이터 메모리 삭제
										 if(OrgC6CirStandPoint!=NULL) delete[] OrgC6CirStandPoint;
									 }
									 LogUnit.SetLog(L"Circle_6_Insp_End");   
									 // Circle 영역 꽃박리, 원형박리 검출 목적 시퀀스(EnCap)
									 // 정식 명칭은 몰라서.....일단 Crack으로 정함 
									 if(!IsMarkBtm && BrokenThresHold!=0){
										 if(CirFitDiameter6!=0.0f && CircleFit6Center.x!=0.0f && CircleFit6Center.y!=0.0f){ // FAVION Circle Fitting 성공시 박리검사 진행 
											 Circle->GImage = &RotateBrokenImg;                                             //Binary Image 넘겨줌 

											 Circle->SetCenterXY(CircleFit6Center.x,CircleFit6Center.y)      ;
											 Circle->SetTolerance((dEdgeToTrapLineDis/2) -CirOffsetMargin)   ; // Circle Tolerance 
											 Circle->SetDiameter ((CirFitDiameter6-(dEdgeToTrapLineDis/2))*2); // Circle Diameter 
											 Circle->SetCircleChoice(0)                                      ; // 0:From Begin, 1:From End, 2:Largest Amplitude 
											 Circle->SetCircleType  (2)                                      ; // 0:Black to White, 1:White to Black 2: Both Black, White 
											 Circle->SetCircleIndex (0)                                      ; // Circle EdgePoint Index 
											 Circle->OnExecute(true)                                         ;
											 CrackCirDiameter6 = (CirFitDiameter6-(dEdgeToTrapLineDis/2))+((dEdgeToTrapLineDis/2) -CirOffsetMargin);

											 C6CirInCrackCount = Circle->FCirclePointCount;

											 if(C6CirInCrackCount>0){
												 if(C6CirInCrackPoint!=NULL) delete[] C6CirInCrackPoint;
												 C6CirInCrackPoint = new TFPoint[C6CirInCrackCount];

												 for(int k=0; k<C6CirInCrackCount; k++){
													 if(k>MAX_CIRCLE_EDGEPOINT) break;
													 C6CirInCrackPoint[k].x = Circle->FCirclePoint[k].x;
													 C6CirInCrackPoint[k].y = Circle->FCirclePoint[k].y;
												 }
											 }
										 }
									 }
								 }


								 // 개별 Circle Data 교차점 기준 직선영역의 새로운 Btm영역 BtmOutLine, BtmInLine 찾는다 
								 // Circle1과 Circle2 사이의 직선영역 검사
								 const int BtmMargin =50; const int LeftMargin =30; const int RightMargin =30;
								 if(BtmEdgePoint[0].x!=0 && BtmEdgePoint[0].y!=0 && BtmEdgePoint[1].x!=0 && BtmEdgePoint[1].y!=0 ){ // BTM
									 LogUnit.SetLog(L"shRectC_Btm1_Insp_Start");    

									 if(BtmEdgeThresHold==0)    {SingleLine->GImage = &RotateImg      ;  SingleLine->FThreshold =5 ;}
									 else                       {SingleLine->GImage = &RotateBinaryImg;  SingleLine->FThreshold =10;}

									 // BtmOutLine Search 
									 SingleLine->IRoi->SetOrgX  (BtmEdgePoint[0].x+50                       );
									 SingleLine->IRoi->SetOrgY  (BtmEdgePoint[0].y - BtmMargin              );
									 SingleLine->IRoi->SetWidth ((BtmEdgePoint[1].x - BtmEdgePoint[0].x)-100);
									 SingleLine->IRoi->SetHeight(100                                        );
									 if(BtmEdgePoint[0].x+100<=0 || (BtmEdgePoint[0].y-BtmMargin<=0) || ((BtmEdgePoint[1].x-BtmEdgePoint[0].x)-200)<=0 ) return false;

									 SingleLine->SetOrientation(orSouth);
									 // 									 SingleLine->FIncrement =1   ;
									 SingleLine->SetFindLineId(0);
									 SingleLine->FThreshold =5;

									 if(IsMarkBtm) {SingleLine->FIncrement =1 ; SingleLine->SetEdgeType(1);}  //White To Black 
									 else          {SingleLine->FIncrement =10; SingleLine->SetEdgeType(1);}  //White To Black 

									 SingleLine->OnExecute();
									 BtmOutLine[0].FP0 = SingleLine->GetResultP0();
									 BtmOutLine[0].FP1 = SingleLine->GetResultP1();

									 // BtmOutLine Real EdgePoint 추출함 
									 OrgBtm1OutEdgeCount = SingleLine->FEdgePointCount;
									 if(OrgBtm1OutEdgeCount>0){
										 if(OrgBtm1OutPoint!=NULL) delete[] OrgBtm1OutPoint;
										 OrgBtm1OutPoint = new TFPoint[OrgBtm1OutEdgeCount];

										 for(int k=0; k<OrgBtm1OutEdgeCount; k++){
											 if(k>MAX_CIRCLE_EDGEPOINT) break;
											 OrgBtm1OutPoint[k].x = SingleLine->FEdgePoint[k].x;
											 OrgBtm1OutPoint[k].y = SingleLine->FEdgePoint[k].y;
										 }
									 }

									 // BtmInLine Search 
									 if(CirGrindInThresHold==0) {Circle->GImage = &RotateImg             ; SingleLine->FThreshold =5 ;} //Org Image 넘겨줌 
									 else                       {Circle->GImage = &RotateGrindInBinaryImg; SingleLine->FThreshold =10;}//Binary Image 넘겨줌 

									 SingleLine->SetEdgeType(0);  //Black To White  
									 SingleLine->OnExecute();
									 BtmInLine[0].FP0 = SingleLine->GetResultP0();
									 BtmInLine[0].FP1 = SingleLine->GetResultP1();

									 // BtmInLine Real EdgePoint 추출함 
									 OrgBtm1InEdgeCount = SingleLine->FEdgePointCount;
									 if(OrgBtm1InEdgeCount>0){
										 if(OrgBtm1InPoint!=NULL) delete[] OrgBtm1InPoint;
										 OrgBtm1InPoint = new TFPoint[OrgBtm1InEdgeCount];

										 for(int k=0; k<OrgBtm1InEdgeCount; k++){
											 if(k>MAX_CIRCLE_EDGEPOINT) break;
											 OrgBtm1InPoint[k].x = SingleLine->FEdgePoint[k].x;
											 OrgBtm1InPoint[k].y = SingleLine->FEdgePoint[k].y;
										 }
									 }

									 // Grind Mark 기준 연마량 계산 
									 if(IsMarkBtm){ // LT검사시 가공량 측정함 
										 if(FInspectMode==Insp_Track){ // TrackMode TrackLine기준 가공량 측정 
											 if(CirGrindMeaThresHold!=0){
												 // 연마량 계산  
												 if((fabs(BtmOutLine[0].FP0.y - BtmOutLine[0].FP1.y))>1
													 ||(fabs(BtmInLine[0].FP0.y - BtmInLine[0].FP1.y))>1){
														 BtmGrindWidth1 = BtmOutLine[0].FP0.y - BtmInLine[0].FP0.y; 
												 }
												 else{
													 BtmGrindWidth1 = Math.GetLengthFrLineToPoint(BtmOutLine[0].FP0, BtmOutLine[0].FP1, BtmInLine[0].FP0);
												 }

												 SingleLine->GImage = &RotateGrindBinaryImg; //Binary Image 넘겨줌 
												 SingleLine->SetEdgeType(1);  //White To Black 
												 SingleLine->SetFindLineId(0);
												 SingleLine->OnExecute();

												 BtmStandLine[0].FP0 = SingleLine->GetResultP0();
												 BtmStandLine[0].FP1 = SingleLine->GetResultP1();
												 // 가공량 계산 
												 BtmGrindMeasure1 = Math.GetLengthFrLineToPoint(BtmOutLine[0].FP0, BtmOutLine[0].FP1, BtmStandLine[0].FP0);
											 }
										 }
										 else if(FInspectMode==Insp_Mark){
											 // GrindMark 상관없이 연마량 측정
											 if(OrgBtm1InEdgeCount>10 && OrgBtm1OutEdgeCount>10 && (OrgBtm1InEdgeCount==OrgBtm1OutEdgeCount)){
												 // 가공량,연마량 측정 전 데이터 존재시 가상GrindMark 생성한다 
												 if(GrindMarkPoint[2].x!=0.0f && GrindMarkPoint[2].y!=0.0f){
													 GrindMarkPoint[4].x     = OrgBtm1InPoint[OrgBtm1InEdgeCount-10].x ;
													 GrindMarkPoint[4].y     = GrindMarkPoint[2].y                     ;
													 GrindMarkRect [4].left  = GrindMarkPoint[4].x    - GrindMarkRange ;  
													 GrindMarkRect [4].top   = GrindMarkPoint[4].y    - GrindMarkRange ;  
													 GrindMarkRect [4].right = GrindMarkRect [4].left + GrindMarkLength;  
													 GrindMarkRect [4].bottom= GrindMarkRect [4].top  + GrindMarkLength;  
												 }

												 // GrindMark[2] 가공량,연마량 측정 
												 ////////////////////////////////////////////////////////////////////////////////////////////////////
												 if(GrindMarkPoint[2].x!=0.0f && GrindMarkPoint[2].y!=0.0f){ //GrindMark 찾았을경우 검사 시퀀스 가공량 측정 
													 GrindMeaDis =0.0f, MinDis =10000.0f;  Btm1GrindMarkCount=0;
													 for(int k=0; k<OrgBtm1OutEdgeCount; k++){
														 if(OrgBtm1OutPoint[k].x==0.0f || OrgBtm1OutPoint[k].y==0.0f) continue;
														 if(GrindMarkPoint[2].x ==0.0f || GrindMarkPoint[2].y ==0.0f) continue;

														 GrindMeaDis = Math.GetLength(GrindMarkPoint[2], OrgBtm1OutPoint[k]);
														 if(GrindMeaDis<MinDis){
															 MinDis = GrindMeaDis;
															 Btm1GrindMarkCount = k;
														 }
													 }
													 // GrindMark기준 수직 포인트 주변값 Avg산출한다 
													 if(Btm1GrindMarkCount!=0 && Btm1GrindMarkCount>5 && (Btm1GrindMarkCount+5)<OrgBtm1OutEdgeCount){
														 CircleCount=0,TotalCirDis=0.0f,GrindMeaDis=0.0f;
														 for(int k=Btm1GrindMarkCount-5; k<Btm1GrindMarkCount+5; k++){
															 if(OrgBtm1OutPoint[k].x==0.0f || OrgBtm1OutPoint[k].y==0.0f) continue;

															 GrindMeaDis = Math.GetLength(GrindMarkPoint[2], OrgBtm1OutPoint[k]);
															 TotalCirDis+= GrindMeaDis;
															 CircleCount++;
														 }
														 if(TotalCirDis!=0.0f && CircleCount!=0){
															 BtmGrindMeasure1 = TotalCirDis/CircleCount;
														 }
													 }
													 // GrindMark기준 수직 평균값 연마량 측정 
													 if(Btm1GrindMarkCount!=0 && Btm1GrindMarkCount>5 && (Btm1GrindMarkCount+5)<OrgBtm1OutEdgeCount){
														 CircleCount=0,TotalCirDis=0.0f,GrindWidthDis=0.0f;
														 for(int k=Btm1GrindMarkCount-5; k<Btm1GrindMarkCount+5; k++){
															 if(OrgBtm1OutPoint[k].x==0.0f && OrgBtm1OutPoint[k].y==0.0f) continue;
															 if(OrgBtm1InPoint [k].x==0.0f && OrgBtm1InPoint [k].y==0.0f) continue;
															 GrindWidthDis = Math.GetLength(OrgBtm1InPoint[k], OrgBtm1OutPoint[k]);
															 TotalCirDis+=   GrindWidthDis;
															 CircleCount++;
														 }
														 if(TotalCirDis!=0.0f && CircleCount!=0){
															 BtmGrindWidth1 = TotalCirDis/CircleCount;
														 }
													 }
												 }
												 else {  //GrindMark 못 찾았을경우 검사 시퀀스 (가공량: 0, 연마량 측정)
													 GrindMeaDis =0.0f, MinDis =10000.0f;  Btm1GrindMarkCount=0;
													 for(int k=0; k<OrgBtm1OutEdgeCount; k++){
														 if(OrgBtm1OutPoint[k].x==0.0f || OrgBtm1OutPoint[k].y==0.0f) continue;

														 GrindMarkRectCenter[2].x = GrindMarkRect[2].left + (GrindMarkRect[2].right  - GrindMarkRect[2].left)/2; 
														 GrindMarkRectCenter[2].y = GrindMarkRect[2].top  + (GrindMarkRect[2].bottom - GrindMarkRect[2].top )/2; 

														 GrindMeaDis = Math.GetLength(GrindMarkRectCenter[2], OrgBtm1OutPoint[k]);
														 if(GrindMeaDis<MinDis){
															 MinDis = GrindMeaDis;
															 Btm1GrindMarkCount = k;
														 }
													 }
													 // GrindMark기준 수직 평균값 연마량 측정 
													 if(Btm1GrindMarkCount!=0 && Btm1GrindMarkCount>5 &&(Btm1GrindMarkCount+5<OrgBtm1OutEdgeCount)){
														 CircleCount=0,TotalCirDis=0.0f,GrindWidthDis=0.0f;
														 for(int k=Btm1GrindMarkCount-5; k<Btm1GrindMarkCount+5; k++){
															 if(OrgBtm1OutPoint[k].x==0.0f && OrgBtm1OutPoint[k].y==0.0f) continue;
															 if(OrgBtm1InPoint [k].x==0.0f && OrgBtm1InPoint [k].y==0.0f) continue;
															 GrindWidthDis = Math.GetLength(OrgBtm1InPoint[k], OrgBtm1OutPoint[k]);
															 TotalCirDis+=   GrindWidthDis;
															 CircleCount++;
														 }
														 if(TotalCirDis!=0.0f && CircleCount!=0){
															 BtmGrindWidth1 = TotalCirDis/CircleCount;
														 }
													 }
												 }
												 ////////////////////////////////////////////////////////////////////////////////////////////////////

												 // GrindMark[4] 가공량,연마량 측정 
												 ////////////////////////////////////////////////////////////////////////////////////////////////////
												 if(GrindMarkPoint[4].x!=0.0f && GrindMarkPoint[4].y!=0.0f){ //GrindMark 찾았을경우 검사 시퀀스 가공량 측정 
													 GrindMeaDis =0.0f, MinDis =10000.0f;  Btm1GrindMarkCount=0;
													 for(int k=0; k<OrgBtm1OutEdgeCount; k++){
														 if(OrgBtm1OutPoint[k].x==0.0f || OrgBtm1OutPoint[k].y==0.0f) continue;
														 if(GrindMarkPoint[4].x ==0.0f || GrindMarkPoint[4].y ==0.0f) continue;

														 GrindMeaDis = Math.GetLength(GrindMarkPoint[4], OrgBtm1OutPoint[k]);
														 if(GrindMeaDis<MinDis){
															 MinDis = GrindMeaDis;
															 Btm1GrindMarkCount = k;
														 }
													 }
													 // GrindMark기준 수직 포인트 주변값 Avg산출한다 
													 if(Btm1GrindMarkCount!=0 && Btm1GrindMarkCount>5 && (Btm1GrindMarkCount+5)<OrgBtm1OutEdgeCount){
														 CircleCount=0,TotalCirDis=0.0f,GrindMeaDis=0.0f;
														 for(int k=Btm1GrindMarkCount-5; k<Btm1GrindMarkCount+5; k++){
															 if(OrgBtm1OutPoint[k].x==0.0f || OrgBtm1OutPoint[k].y==0.0f) continue;

															 GrindMeaDis = Math.GetLength(GrindMarkPoint[4], OrgBtm1OutPoint[k]);
															 TotalCirDis+= GrindMeaDis;
															 CircleCount++;
														 }
														 if(TotalCirDis!=0.0f && CircleCount!=0){
															 BtmGrindMeasure3 = TotalCirDis/CircleCount;
														 }
													 }
													 // GrindMark기준 수직 평균값 연마량 측정 
													 if(Btm1GrindMarkCount!=0 && Btm1GrindMarkCount>5 && (Btm1GrindMarkCount+5)<OrgBtm1OutEdgeCount){
														 CircleCount=0,TotalCirDis=0.0f,GrindWidthDis=0.0f;
														 for(int k=Btm1GrindMarkCount-5; k<Btm1GrindMarkCount+5; k++){
															 if(OrgBtm1OutPoint[k].x==0.0f && OrgBtm1OutPoint[k].y==0.0f) continue;
															 if(OrgBtm1InPoint [k].x==0.0f && OrgBtm1InPoint [k].y==0.0f) continue;
															 GrindWidthDis = Math.GetLength(OrgBtm1InPoint[k], OrgBtm1OutPoint[k]);
															 TotalCirDis+=   GrindWidthDis;
															 CircleCount++;
														 }
														 if(TotalCirDis!=0.0f && CircleCount!=0){
															 BtmGrindWidth3 = TotalCirDis/CircleCount;
														 }
													 }
												 }
												 else {  //GrindMark 못 찾았을경우 검사 시퀀스 (가공량: 0, 연마량 측정)
													 GrindMeaDis =0.0f, MinDis =10000.0f;  Btm1GrindMarkCount=0;
													 for(int k=0; k<OrgBtm1OutEdgeCount; k++){
														 if(OrgBtm1OutPoint[k].x==0.0f || OrgBtm1OutPoint[k].y==0.0f) continue;

														 if(k==0){ // GrindMark[2] 못찾을 경우 가상으로 데이터 생성해줌 
															 GrindMarkRectCenter[4].x     =  OrgBtm1InPoint[OrgBtm1InEdgeCount-10].x;
															 GrindMarkRectCenter[4].y     =  GrindMarkRectCenter[2].y               ;

															 GrindMarkRect [4].left  = GrindMarkRectCenter[4].x  - GrindMarkRange  ;  
															 GrindMarkRect [4].top   = GrindMarkRectCenter[4].y  - GrindMarkRange  ;  
															 GrindMarkRect [4].right = GrindMarkRect [4].left    + GrindMarkLength ;  
															 GrindMarkRect [4].bottom= GrindMarkRect [4].top     + GrindMarkLength ;  

														 }

														 GrindMeaDis = Math.GetLength(GrindMarkRectCenter[4], OrgBtm1OutPoint[k]);
														 if(GrindMeaDis<MinDis){
															 MinDis = GrindMeaDis;
															 Btm1GrindMarkCount = k;
														 }
													 }
													 // GrindMark기준 수직 평균값 연마량 측정 
													 if(Btm1GrindMarkCount!=0 && Btm1GrindMarkCount>5 &&(Btm1GrindMarkCount+5<OrgBtm1OutEdgeCount)){
														 CircleCount=0,TotalCirDis=0.0f,GrindWidthDis=0.0f;
														 for(int k=Btm1GrindMarkCount-5; k<Btm1GrindMarkCount+5; k++){
															 if(OrgBtm1OutPoint[k].x==0.0f && OrgBtm1OutPoint[k].y==0.0f) continue;
															 if(OrgBtm1InPoint [k].x==0.0f && OrgBtm1InPoint [k].y==0.0f) continue;
															 GrindWidthDis = Math.GetLength(OrgBtm1InPoint[k], OrgBtm1OutPoint[k]);
															 TotalCirDis+=   GrindWidthDis;
															 CircleCount++;
														 }
														 if(TotalCirDis!=0.0f && CircleCount!=0){
															 BtmGrindWidth3 = TotalCirDis/CircleCount;
														 }
													 }
												 }
												 ////////////////////////////////////////////////////////////////////////////////////////////////////
											 }

											 // 가공량 측정 
											 // 											 if(BtmGrindWidth1!=0 && GrindMarkPoint[2].x!=0.0f && GrindMarkPoint[2].y!=0.0f){ // MarkMode GrindMark중심 좌표 기준 가공량 측정 
											 // 												 if(fabs(BtmOutLine[0].FP0.y - BtmOutLine[0].FP1.y)>2){
											 // // 													 BtmGrindWidth1   = (BtmOutLine[0].FP0.y  - GrindMarkPoint[2].y) - (BtmInLine[0].FP0.y - GrindMarkPoint[2].y);
											 // 													 BtmGrindMeasure1 = BtmOutLine[0].FP0.y  - GrindMarkPoint[2].y; 
											 // 												 }
											 // 												 else {
											 // 													 BtmGrindMeasure1 = Math.GetLengthFrLineToPoint(BtmOutLine[0].FP0, BtmOutLine[0].FP1, GrindMarkPoint[2]);
											 // // 													 BtmGrindWidth1   = BtmGrindMeasure1 - Math.GetLengthFrLineToPoint(BtmInLine[0].FP0, BtmInLine[0].FP1, GrindMarkPoint[2]);
											 // 												 }
											 // 											 }
										 }
									 }
									 else { // ENCAP 연마량 데이터만 계측함
										 if(BtmOutLine[0].FP0.x!=0.0f && BtmOutLine[0].FP0.y!=0.0f && BtmOutLine[0].FP1.x!=0.0f && BtmOutLine[0].FP1.y!=0.0f &&
											 BtmInLine [0].FP0.x!=0.0f && BtmInLine [0].FP0.y!=0.0f && BtmInLine [0].FP1.x!=0.0f && BtmInLine [0].FP1.y!=0.0f ){
												 // 연마량 계산  
												 if((fabs(BtmOutLine[0].FP0.y - BtmOutLine[0].FP1.y))>1
													 ||(fabs(BtmInLine[0].FP0.y - BtmInLine[0].FP1.y))>1){
														 BtmGrindWidth1 = BtmOutLine[0].FP0.y - BtmInLine[0].FP0.y; 
												 }
												 else{
													 BtmGrindWidth1 = Math.GetLengthFrLineToPoint(BtmOutLine[0].FP0, BtmOutLine[0].FP1, BtmInLine[0].FP0);
												 }
										 }
									 }
									 // 동적 생성한 데이터를 지운다 
									 if(OrgBtm1InPoint !=NULL) delete[] OrgBtm1InPoint;
									 if(OrgBtm1OutPoint!=NULL) delete[] OrgBtm1OutPoint;
									 LogUnit.SetLog(L"shRectC_Btm1_Insp_End");    
								 }

								 // Circle2과 Circle3 사이의 직선영역 검사 
								 if(BtmEdgePoint[2].x!=0 && BtmEdgePoint[2].y!=0 && BtmEdgePoint[3].x!=0 && BtmEdgePoint[3].y!=0 ){ //RIGHT
									 LogUnit.SetLog(L"shRectC_Btm2_Insp_Start");    

									 if(BtmEdgeThresHold==0)   {SingleLine->GImage = &RotateImg      ;  SingleLine->FThreshold =5 ;}
									 else                      {SingleLine->GImage = &RotateBinaryImg;  SingleLine->FThreshold =10;}

									 SingleLine->IRoi->SetOrgX  (BtmEdgePoint[3].x-RightMargin        ); 
									 SingleLine->IRoi->SetOrgY  (BtmEdgePoint[3].y                    );
									 SingleLine->IRoi->SetWidth (100                                  );
									 SingleLine->IRoi->SetHeight(BtmEdgePoint[2].y - BtmEdgePoint[3].y);

									 SingleLine->SetOrientation(orEast);
									 SingleLine->FIncrement =10;
									 SingleLine->SetFindLineId(0);
									 SingleLine->FThreshold =5;

									 if(IsMarkBtm) SingleLine->SetEdgeType(1);  //White To Black 
									 else          SingleLine->SetEdgeType(1);  //White To Black 

									 SingleLine->OnExecute();

									 BtmOutLine[1].FP0 = SingleLine->GetResultP0();
									 BtmOutLine[1].FP1 = SingleLine->GetResultP1();

									 // BtmInLine Search 
									 SingleLine->SetEdgeType(0);  //Black To White  
									 SingleLine->OnExecute();
									 BtmInLine[1].FP0 = SingleLine->GetResultP0();
									 BtmInLine[1].FP1 = SingleLine->GetResultP1();

									 // 연마폭 계산  
									 BtmGrindWidth2 = Math.GetLengthFrLineToPoint(BtmOutLine[1].FP0, BtmOutLine[1].FP1, BtmInLine[1].FP0);

									 //연마량 계산 
									 if(IsMarkBtm){
										 if(CirGrindMeaThresHold!=0){
											 SingleLine->GImage = &RotateGrindBinaryImg; //Binary Image 넘겨줌 
											 SingleLine->SetEdgeType(1);  //White To Black 
											 SingleLine->SetFindLineId(0);
											 SingleLine->OnExecute();

											 BtmStandLine[1].FP0 = SingleLine->GetResultP0();
											 BtmStandLine[1].FP1 = SingleLine->GetResultP1();
											 //연마량 계산 
											 BtmGrindMeasure2 = Math.GetLengthFrLineToPoint(BtmOutLine[1].FP0, BtmOutLine[1].FP1, BtmStandLine[1].FP0);
										 }
									 }
									 LogUnit.SetLog(L"shRectC_Btm2_Insp_End");    
								 }

								 // Circl31과 Circle4 사이의 직선영역 검사 
								 if(BtmEdgePoint[4].x!=0 && BtmEdgePoint[4].y!=0 && BtmEdgePoint[5].x!=0 && BtmEdgePoint[5].y!=0 ){ //BTM
									 LogUnit.SetLog(L"shRectC_Btm3_Insp_Start");    

									 if(BtmEdgeThresHold==0)    {SingleLine->GImage = &RotateImg      ;  SingleLine->FThreshold =5 ;}
									 else                       {SingleLine->GImage = &RotateBinaryImg;  SingleLine->FThreshold =10;}

									 // Trench Width 길이가 클경우 EdgePoint 간격을 조밀하게 검사진행시 시간 Delay 가능성 발생함 
									 // 연마량 측정 목적이므로 검사 ROI영역을 줄여준다 
									 int TrenchWidth=0;
									 TrenchWidth = (BtmEdgePoint[5].x>BtmEdgePoint[4].x) ? (BtmEdgePoint[5].x - BtmEdgePoint[4].x):(BtmEdgePoint[4].x - BtmEdgePoint[5].x);

									 if(TrenchWidth>TrenchWidthMargin){ // Trench Width 클경우 
										 SingleLine->IRoi->SetOrgX  (BtmEdgePoint[4].x+200                       );
										 SingleLine->IRoi->SetOrgY  (BtmEdgePoint[4].y - BtmMargin               );
										 SingleLine->IRoi->SetWidth ((BtmEdgePoint[5].x - BtmEdgePoint[4].x)-400 );
										 SingleLine->IRoi->SetHeight(100                                         );
										 if(BtmEdgePoint[4].x+500<=0 || (BtmEdgePoint[4].y-BtmMargin<=0) || ((BtmEdgePoint[5].x-BtmEdgePoint[4].x)-1000)<=0 ) return false;
									 }
									 else {                             // Trench Width 작을 경우 
										 SingleLine->IRoi->SetOrgX  (BtmEdgePoint[4].x+100                      );
										 SingleLine->IRoi->SetOrgY  (BtmEdgePoint[4].y - BtmMargin              );
										 SingleLine->IRoi->SetWidth ((BtmEdgePoint[5].x - BtmEdgePoint[4].x)-200);
										 SingleLine->IRoi->SetHeight(100                                        );
										 if(BtmEdgePoint[4].x+100<=0 || (BtmEdgePoint[4].y-BtmMargin<=0) || ((BtmEdgePoint[5].x-BtmEdgePoint[4].x)-200)<=0 ) return false;
									 }

									 SingleLine->SetOrientation(orSouth);
									 SingleLine->SetFindLineId(0);
									 SingleLine->FThreshold =5;

									 if(IsMarkBtm) {
										 SingleLine->SetEdgeType(1);  //White To Black
										 SingleLine->FIncrement =1 ;
									 }
									 else          {
										 SingleLine->SetEdgeType(1);  //White To Black 
										 SingleLine->FIncrement =20;
									 }

									 SingleLine->OnExecute();
									 BtmOutLine[2].FP0 = SingleLine->GetResultP0();
									 BtmOutLine[2].FP1 = SingleLine->GetResultP1();

									 // BtmOutLine Real EdgePoint 추출함 
									 OrgBtm3OutEdgeCount = SingleLine->FEdgePointCount;
									 if(OrgBtm3OutEdgeCount>0){
										 if(OrgBtm3OutPoint!=NULL) delete[] OrgBtm3OutPoint;
										 OrgBtm3OutPoint = new TFPoint[OrgBtm3OutEdgeCount];

										 for(int k=0; k<OrgBtm3OutEdgeCount; k++){
											 if(k>MAX_CIRCLE_EDGEPOINT) break;
											 OrgBtm3OutPoint[k].x = SingleLine->FEdgePoint[k].x;
											 OrgBtm3OutPoint[k].y = SingleLine->FEdgePoint[k].y;
										 }
									 }

									 // BtmInLine Search 

									 if(CirGrindInThresHold==0) {Circle->GImage = &RotateImg             ; SingleLine->FThreshold =5 ;} //Org Image 넘겨줌 
									 else                       {Circle->GImage = &RotateGrindInBinaryImg; SingleLine->FThreshold =10;}//Binary Image 넘겨줌 

									 SingleLine->SetEdgeType(0);  //Black To White  
									 SingleLine->OnExecute();
									 BtmInLine[2].FP0 = SingleLine->GetResultP0();
									 BtmInLine[2].FP1 = SingleLine->GetResultP1();

									 // BtmInLine Real EdgePoint 추출함 
									 OrgBtm3InEdgeCount = SingleLine->FEdgePointCount;
									 if(OrgBtm3InEdgeCount>0){
										 if(OrgBtm3InPoint!=NULL)  delete[] OrgBtm3InPoint;
										 OrgBtm3InPoint = new TFPoint[OrgBtm3InEdgeCount];

										 for(int k=0; k<OrgBtm3InEdgeCount; k++){
											 if(k>MAX_CIRCLE_EDGEPOINT) break;
											 OrgBtm3InPoint[k].x = SingleLine->FEdgePoint[k].x;
											 OrgBtm3InPoint[k].y = SingleLine->FEdgePoint[k].y;
										 }
									 }

									 // Grind Mark 기준 연마량 계산 
									 if(IsMarkBtm){ // LT검사시 가공량 측정함 
										 if(FInspectMode==Insp_Track){ // TrackMode TrackLine기준 가공량 측정 
											 if(CirGrindMeaThresHold!=0){
												 // 연마폭 계산  
												 BtmGrindWidth3 = Math.GetLengthFrLineToPoint(BtmOutLine[2].FP0, BtmOutLine[2].FP1, BtmInLine[2].FP0);

												 SingleLine->GImage = &RotateGrindBinaryImg; //Binary Image 넘겨줌 
												 SingleLine->SetEdgeType(1);  //White To Black 
												 SingleLine->SetFindLineId(0);
												 SingleLine->OnExecute();

												 BtmStandLine[2].FP0 = SingleLine->GetResultP0();
												 BtmStandLine[2].FP1 = SingleLine->GetResultP1();
												 //연마량 계산 
												 BtmGrindMeasure3 = Math.GetLengthFrLineToPoint(BtmOutLine[2].FP0, BtmOutLine[2].FP1, BtmStandLine[2].FP0);
											 }
										 }
										 else if(FInspectMode==Insp_Mark){
											 // GrindMark 상관없이 연마량 측정
											 if(OrgBtm3OutEdgeCount!=0 && OrgBtm3InEdgeCount!=0 && (OrgBtm3OutEdgeCount==OrgBtm3InEdgeCount)){ // 연마량이 존재할경우 가공량 검사를 진행함 
												 // 가공량,연마량 측정 전 데이터 존재시 가상GrindMark 생성한다 
												 if(GrindMarkPoint[9].x!=0.0f && GrindMarkPoint[9].y!=0.0f){
													 // GrindMark 8
													 GrindMarkPoint[8].x     = OrgBtm3InPoint[7].x ;
													 GrindMarkPoint[8].y     = GrindMarkPoint[9].y                     ;
													 GrindMarkRect [8].left  = GrindMarkPoint[8].x    - GrindMarkRange ;  
													 GrindMarkRect [8].top   = GrindMarkPoint[8].y    - GrindMarkRange ;  
													 GrindMarkRect [8].right = GrindMarkRect [8].left + GrindMarkLength;  
													 GrindMarkRect [8].bottom= GrindMarkRect [8].top  + GrindMarkLength;  

													 // GrindMark 9
													 GrindMarkPoint[10].x     = OrgBtm3InPoint[OrgBtm3InEdgeCount-7].x   ;
													 GrindMarkPoint[10].y     = GrindMarkPoint[9 ].y                     ;
													 GrindMarkRect [10].left  = GrindMarkPoint[10].x    - GrindMarkRange ;  
													 GrindMarkRect [10].top   = GrindMarkPoint[10].y    - GrindMarkRange ;  
													 GrindMarkRect [10].right = GrindMarkRect [10].left + GrindMarkLength;  
													 GrindMarkRect [10].bottom= GrindMarkRect [10].top  + GrindMarkLength;  
												 }

												 // GrindMark[8] 가공량,연마량 측정 
												 ////////////////////////////////////////////////////////////////////////////////////////////////////
												 if(GrindMarkPoint[8].x!=0.0f && GrindMarkPoint[8].y!=0.0f){ //GrindMark 찾았을경우 검사 시퀀스 
													 GrindMeaDis =0.0f, MinDis =10000.0f;  Btm3GrindMarkCount=0;

													 for(int k=0; k<OrgBtm3OutEdgeCount; k++){
														 if(OrgBtm3OutPoint[k].x==0.0f || OrgBtm3OutPoint[k].y==0.0f) continue;
														 if(GrindMarkPoint[8].x ==0.0f || GrindMarkPoint[8].y ==0.0f) continue;

														 GrindMeaDis = Math.GetLength(GrindMarkPoint[8], OrgBtm3OutPoint[k]);
														 if(GrindMeaDis<MinDis){
															 MinDis = GrindMeaDis;
															 Btm3GrindMarkCount = k;
														 }
													 }
													 // GrindMark기준 수직 포인트 주변값 Avg산출한다 
													 if(Btm3GrindMarkCount!=0 && Btm3GrindMarkCount>5 && (Btm3GrindMarkCount+5)<OrgBtm3OutEdgeCount){
														 CircleCount=0,TotalCirDis=0.0f,GrindMeaDis=0.0f;
														 for(int k=Btm3GrindMarkCount-5; k<Btm3GrindMarkCount+5; k++){
															 if(OrgBtm3OutPoint[k].x==0.0f || OrgBtm3OutPoint[k].y==0.0f) continue;

															 GrindMeaDis = Math.GetLength(GrindMarkPoint[8], OrgBtm3OutPoint[k]);
															 TotalCirDis+= GrindMeaDis;
															 CircleCount++;
														 }
														 if(TotalCirDis!=0.0f && CircleCount!=0){
															 BtmGrindMeasure4 = TotalCirDis/CircleCount;
														 }
													 }
													 // GrindMark기준 수직 평균값 연마량 측정 
													 if(Btm3GrindMarkCount!=0 && Btm3GrindMarkCount>5 && (Btm3GrindMarkCount+5)<OrgBtm3OutEdgeCount){
														 CircleCount=0,TotalCirDis=0.0f,GrindWidthDis=0.0f;
														 for(int k=Btm3GrindMarkCount-5; k<Btm3GrindMarkCount+5; k++){
															 if(OrgBtm3OutPoint[k].x==0.0f && OrgBtm3OutPoint[k].y==0.0f) continue;
															 if(OrgBtm3InPoint [k].x==0.0f && OrgBtm3InPoint [k].y==0.0f) continue;
															 GrindWidthDis = Math.GetLength(OrgBtm3InPoint[k], OrgBtm3OutPoint[k]);
															 TotalCirDis+=   GrindWidthDis;
															 CircleCount++;
														 }
														 if(TotalCirDis!=0.0f && CircleCount!=0){
															 BtmGrindWidth4 = TotalCirDis/CircleCount;
														 }
													 }
												 }
												 else { //GrindMark 못 찾았을경우 검사 시퀀스 (가공량: 0, 연마량 측정)
													 GrindMeaDis =0.0f, MinDis =10000.0f;  Btm3GrindMarkCount=0;
													 for(int k=0; k<OrgBtm3OutEdgeCount; k++){
														 if(OrgBtm3OutPoint[k].x==0.0f || OrgBtm3OutPoint[k].y==0.0f) continue;

														 if(k==0){ // 순서상 9번이 없는경우 
															 GrindMarkRectCenter[9].x = GrindMarkRect[9].left + (GrindMarkRect[9].right  - GrindMarkRect[9].left)/2; 
															 GrindMarkRectCenter[9].y = GrindMarkRect[9].top  + (GrindMarkRect[9].bottom - GrindMarkRect[9].top )/2; 

															 GrindMarkRectCenter[8].x = OrgBtm3InPoint[7].x     ;
															 GrindMarkRectCenter[8].y = GrindMarkRectCenter[9].y; 

															 GrindMarkRect [8].left  = GrindMarkRectCenter[8].x    - GrindMarkRange ;  
															 GrindMarkRect [8].top   = GrindMarkRectCenter[8].y    - GrindMarkRange ;  
															 GrindMarkRect [8].right = GrindMarkRect [8].left      + GrindMarkLength;  
															 GrindMarkRect [8].bottom= GrindMarkRect [8].top       + GrindMarkLength;  
														 }

														 GrindMeaDis = Math.GetLength(GrindMarkRectCenter[8], OrgBtm3OutPoint[k]);
														 if(GrindMeaDis<MinDis){
															 MinDis = GrindMeaDis;
															 Btm3GrindMarkCount = k;
														 }
													 }
													 // GrindMark기준 수직 평균값 연마량 측정 
													 if(Btm3GrindMarkCount!=0 && Btm3GrindMarkCount>5 &&(Btm3GrindMarkCount+5<OrgBtm3OutEdgeCount)){
														 CircleCount=0,TotalCirDis=0.0f,GrindWidthDis=0.0f;
														 for(int k=Btm3GrindMarkCount-5; k<Btm3GrindMarkCount+5; k++){
															 if(OrgBtm3OutPoint[k].x==0.0f && OrgBtm3OutPoint[k].y==0.0f) continue;
															 if(OrgBtm3InPoint [k].x==0.0f && OrgBtm3InPoint [k].y==0.0f) continue;
															 GrindWidthDis = Math.GetLength(OrgBtm3InPoint[k], OrgBtm3OutPoint[k]);
															 TotalCirDis+=   GrindWidthDis;
															 CircleCount++;
														 }
														 if(TotalCirDis!=0.0f && CircleCount!=0){
															 BtmGrindWidth4 = TotalCirDis/CircleCount;
														 }
													 }
												 }
												 ////////////////////////////////////////////////////////////////////////////////////////////////////

												 // GrindMark[9] 가공량,연마량 측정 
												 ////////////////////////////////////////////////////////////////////////////////////////////////////
												 if(GrindMarkPoint[9].x!=0.0f && GrindMarkPoint[9].y!=0.0f){ //GrindMark 찾았을경우 검사 시퀀스 
													 GrindMeaDis =0.0f, MinDis =10000.0f;  Btm3GrindMarkCount=0;

													 for(int k=0; k<OrgBtm3OutEdgeCount; k++){
														 if(OrgBtm3OutPoint[k].x==0.0f || OrgBtm3OutPoint[k].y==0.0f) continue;
														 if(GrindMarkPoint[9].x  ==0.0f || GrindMarkPoint[9].y  ==0.0f) continue;

														 GrindMeaDis = Math.GetLength(GrindMarkPoint[9], OrgBtm3OutPoint[k]);
														 if(GrindMeaDis<MinDis){
															 MinDis = GrindMeaDis;
															 Btm3GrindMarkCount = k;
														 }
													 }
													 // GrindMark기준 수직 포인트 주변값 Avg산출한다 
													 if(Btm3GrindMarkCount!=0 && Btm3GrindMarkCount>5 && (Btm3GrindMarkCount+5)<OrgBtm3OutEdgeCount){
														 CircleCount=0,TotalCirDis=0.0f,GrindMeaDis=0.0f;
														 for(int k=Btm3GrindMarkCount-5; k<Btm3GrindMarkCount+5; k++){
															 if(OrgBtm3OutPoint[k].x==0.0f || OrgBtm3OutPoint[k].y==0.0f) continue;

															 GrindMeaDis = Math.GetLength(GrindMarkPoint[9], OrgBtm3OutPoint[k]);
															 TotalCirDis+= GrindMeaDis;
															 CircleCount++;
														 }
														 if(TotalCirDis!=0.0f && CircleCount!=0){
															 BtmGrindMeasure5 = TotalCirDis/CircleCount;
														 }
													 }
													 // GrindMark기준 수직 평균값 연마량 측정 
													 if(Btm3GrindMarkCount!=0 && Btm3GrindMarkCount>5 && (Btm3GrindMarkCount+5)<OrgBtm3OutEdgeCount){
														 CircleCount=0,TotalCirDis=0.0f,GrindWidthDis=0.0f;
														 for(int k=Btm3GrindMarkCount-5; k<Btm3GrindMarkCount+5; k++){
															 if(OrgBtm3OutPoint[k].x==0.0f && OrgBtm3OutPoint[k].y==0.0f) continue;
															 if(OrgBtm3InPoint [k].x==0.0f && OrgBtm3InPoint [k].y==0.0f) continue;
															 GrindWidthDis = Math.GetLength(OrgBtm3InPoint[k], OrgBtm3OutPoint[k]);
															 TotalCirDis+=   GrindWidthDis;
															 CircleCount++;
														 }
														 if(TotalCirDis!=0.0f && CircleCount!=0){
															 BtmGrindWidth5 = TotalCirDis/CircleCount;
														 }
													 }
												 }
												 else { //GrindMark 못 찾았을경우 검사 시퀀스 (가공량: 0, 연마량 측정)
													 GrindMeaDis =0.0f, MinDis =10000.0f;  Btm3GrindMarkCount=0;
													 for(int k=0; k<OrgBtm3OutEdgeCount; k++){
														 if(OrgBtm3OutPoint[k].x==0.0f || OrgBtm3OutPoint[k].y==0.0f) continue;

														 GrindMarkRectCenter[9].x = GrindMarkRect[9].left + (GrindMarkRect[9].right  - GrindMarkRect[9].left)/2; 
														 GrindMarkRectCenter[9].y = GrindMarkRect[9].top  + (GrindMarkRect[9].bottom - GrindMarkRect[9].top )/2; 

														 GrindMeaDis = Math.GetLength(GrindMarkRectCenter[9], OrgBtm3OutPoint[k]);
														 if(GrindMeaDis<MinDis){
															 MinDis = GrindMeaDis;
															 Btm3GrindMarkCount = k;
														 }
													 }
													 // GrindMark기준 수직 평균값 연마량 측정 
													 if(Btm3GrindMarkCount!=0 && Btm3GrindMarkCount>5 &&(Btm3GrindMarkCount+5<OrgBtm3OutEdgeCount)){
														 CircleCount=0,TotalCirDis=0.0f,GrindWidthDis=0.0f;
														 for(int k=Btm3GrindMarkCount-5; k<Btm3GrindMarkCount+5; k++){
															 if(OrgBtm3OutPoint[k].x==0.0f && OrgBtm3OutPoint[k].y==0.0f) continue;
															 if(OrgBtm3InPoint [k].x==0.0f && OrgBtm3InPoint [k].y==0.0f) continue;
															 GrindWidthDis = Math.GetLength(OrgBtm3InPoint[k], OrgBtm3OutPoint[k]);
															 TotalCirDis+=   GrindWidthDis;
															 CircleCount++;
														 }
														 if(TotalCirDis!=0.0f && CircleCount!=0){
															 BtmGrindWidth5 = TotalCirDis/CircleCount;
														 }
													 }
												 }
												 ////////////////////////////////////////////////////////////////////////////////////////////////////

												 // GrindMark[10] 가공량,연마량 측정 
												 ////////////////////////////////////////////////////////////////////////////////////////////////////
												 if(GrindMarkPoint[10].x!=0.0f && GrindMarkPoint[10].y!=0.0f){ //GrindMark 찾았을경우 검사 시퀀스 
													 GrindMeaDis =0.0f, MinDis =10000.0f;  Btm3GrindMarkCount=0;

													 for(int k=0; k<OrgBtm3OutEdgeCount; k++){
														 if(OrgBtm3OutPoint[k].x==0.0f || OrgBtm3OutPoint[k].y==0.0f) continue;
														 if(GrindMarkPoint[10].x  ==0.0f || GrindMarkPoint[10].y  ==0.0f) continue;

														 GrindMeaDis = Math.GetLength(GrindMarkPoint[10], OrgBtm3OutPoint[k]);
														 if(GrindMeaDis<MinDis){
															 MinDis = GrindMeaDis;
															 Btm3GrindMarkCount = k;
														 }
													 }
													 // GrindMark기준 수직 포인트 주변값 Avg산출한다 
													 if(Btm3GrindMarkCount!=0 && Btm3GrindMarkCount>5 && (Btm3GrindMarkCount+5)<OrgBtm3OutEdgeCount){
														 CircleCount=0,TotalCirDis=0.0f,GrindMeaDis=0.0f;
														 for(int k=Btm3GrindMarkCount-5; k<Btm3GrindMarkCount+5; k++){
															 if(OrgBtm3OutPoint[k].x==0.0f || OrgBtm3OutPoint[k].y==0.0f) continue;

															 GrindMeaDis = Math.GetLength(GrindMarkPoint[10], OrgBtm3OutPoint[k]);
															 TotalCirDis+= GrindMeaDis;
															 CircleCount++;
														 }
														 if(TotalCirDis!=0.0f && CircleCount!=0){
															 BtmGrindMeasure6 = TotalCirDis/CircleCount;
														 }
													 }
													 // GrindMark기준 수직 평균값 연마량 측정 
													 if(Btm3GrindMarkCount!=0 && Btm3GrindMarkCount>5 && (Btm3GrindMarkCount+5)<OrgBtm3OutEdgeCount){
														 CircleCount=0,TotalCirDis=0.0f,GrindWidthDis=0.0f;
														 for(int k=Btm3GrindMarkCount-5; k<Btm3GrindMarkCount+5; k++){
															 if(OrgBtm3OutPoint[k].x==0.0f && OrgBtm3OutPoint[k].y==0.0f) continue;
															 if(OrgBtm3InPoint [k].x==0.0f && OrgBtm3InPoint [k].y==0.0f) continue;
															 GrindWidthDis = Math.GetLength(OrgBtm3InPoint[k], OrgBtm3OutPoint[k]);
															 TotalCirDis+=   GrindWidthDis;
															 CircleCount++;
														 }
														 if(TotalCirDis!=0.0f && CircleCount!=0){
															 BtmGrindWidth6 = TotalCirDis/CircleCount;
														 }
													 }
												 }
												 else { //GrindMark 못 찾았을경우 검사 시퀀스 (가공량: 0, 연마량 측정)
													 GrindMeaDis =0.0f, MinDis =10000.0f;  Btm3GrindMarkCount=0;
													 for(int k=0; k<OrgBtm3OutEdgeCount; k++){
														 if(OrgBtm3OutPoint[k].x==0.0f || OrgBtm3OutPoint[k].y==0.0f) continue;

														 if(k==0){
															 GrindMarkRectCenter[10].x = OrgBtm3InPoint[OrgBtm3InEdgeCount-7].x ;
															 GrindMarkRectCenter[10].y = GrindMarkRectCenter[9].y               ; 

															 GrindMarkRect [10].left  = GrindMarkRectCenter[10].x - GrindMarkRange ;  
															 GrindMarkRect [10].top   = GrindMarkRectCenter[10].y - GrindMarkRange ;  
															 GrindMarkRect [10].right = GrindMarkRect [10].left   + GrindMarkLength;  
															 GrindMarkRect [10].bottom= GrindMarkRect [10].top    + GrindMarkLength;  
														 }

														 GrindMeaDis = Math.GetLength(GrindMarkRectCenter[10], OrgBtm3OutPoint[k]);
														 if(GrindMeaDis<MinDis){
															 MinDis = GrindMeaDis;
															 Btm3GrindMarkCount = k;
														 }
													 }
													 // GrindMark기준 수직 평균값 연마량 측정 
													 if(Btm3GrindMarkCount!=0 && Btm3GrindMarkCount>5 &&(Btm3GrindMarkCount+5<OrgBtm3OutEdgeCount)){
														 CircleCount=0,TotalCirDis=0.0f,GrindWidthDis=0.0f;
														 for(int k=Btm3GrindMarkCount-5; k<Btm3GrindMarkCount+5; k++){
															 if(OrgBtm3OutPoint[k].x==0.0f && OrgBtm3OutPoint[k].y==0.0f) continue;
															 if(OrgBtm3InPoint [k].x==0.0f && OrgBtm3InPoint [k].y==0.0f) continue;
															 GrindWidthDis = Math.GetLength(OrgBtm3InPoint[k], OrgBtm3OutPoint[k]);
															 TotalCirDis+=   GrindWidthDis;
															 CircleCount++;
														 }
														 if(TotalCirDis!=0.0f && CircleCount!=0){
															 BtmGrindWidth6 = TotalCirDis/CircleCount;
														 }
													 }
												 }
												 ////////////////////////////////////////////////////////////////////////////////////////////////////
											 }
										 }
									 }
									 else { // ENCAP 연마량 데이터만 계측함
										 if(BtmOutLine[2].FP0.x!=0.0f && BtmOutLine[2].FP0.y!=0.0f && BtmOutLine[2].FP1.x!=0.0f && BtmOutLine[2].FP1.y!=0.0f &&
											 BtmInLine [2].FP0.x!=0.0f && BtmInLine [2].FP0.y!=0.0f && BtmInLine [2].FP1.x!=0.0f && BtmInLine [2].FP1.y!=0.0f ) 
										 {
											 // 연마량 계산  
											 if((fabs(BtmOutLine[2].FP0.y - BtmOutLine[2].FP1.y))>1
												 ||(fabs(BtmInLine[2].FP0.y - BtmInLine[2].FP1.y))>1){
													 BtmGrindWidth5 = BtmOutLine[2].FP0.y - BtmInLine[2].FP0.y; 
											 }
											 else{
												 BtmGrindWidth5 = Math.GetLengthFrLineToPoint(BtmOutLine[2].FP0, BtmOutLine[2].FP1, BtmInLine[2].FP0);
											 }
										 }
									 }
									 // 동적 생성한 데이터를 지운다 
									 if(OrgBtm3InPoint !=NULL) delete[] OrgBtm3InPoint;
									 if(OrgBtm3OutPoint!=NULL) delete[] OrgBtm3OutPoint;
									 // 계측목적으로 영역을 줄였던것을  Defect검사 목적으로 다시 넓혀줌 
									 BtmInLine[2].FP0.x = BtmEdgePoint[4].x+100;
									 BtmInLine[2].FP1.x = BtmEdgePoint[5].x-100;
									 LogUnit.SetLog(L"shRectC_Btm3_Insp_End");    
								 }

								 // Circle4과 Circle5 사이의 직선영역 검사 
								 if(BtmEdgePoint[6].x!=0 && BtmEdgePoint[6].y!=0 && BtmEdgePoint[7].x!=0 && BtmEdgePoint[7].y!=0 ){ //LEFT
									 LogUnit.SetLog(L"shRectC_Btm4_Insp_Start");    

									 if(BtmEdgeThresHold==0)  {SingleLine->GImage = &RotateImg      ;  SingleLine->FThreshold =5 ;}
									 else                     {SingleLine->GImage = &RotateBinaryImg;  SingleLine->FThreshold =10;}

									 SingleLine->IRoi->SetOrgX  (BtmEdgePoint[6].x-LeftMargin         ); 
									 SingleLine->IRoi->SetOrgY  (BtmEdgePoint[6].y                    );
									 SingleLine->IRoi->SetWidth (100                                  );
									 SingleLine->IRoi->SetHeight(BtmEdgePoint[7].y - BtmEdgePoint[6].y);

									 SingleLine->SetOrientation(orWest);
									 SingleLine->FIncrement =10;
									 SingleLine->SetFindLineId(0);
									 SingleLine->FThreshold =5;

									 if(IsMarkBtm) SingleLine->SetEdgeType(1);  //White To Black 
									 else          SingleLine->SetEdgeType(1);  //White To Black 

									 SingleLine->OnExecute();

									 BtmOutLine[3].FP0 = SingleLine->GetResultP0();
									 BtmOutLine[3].FP1 = SingleLine->GetResultP1();

									 // BtmInLine Search 
									 SingleLine->SetEdgeType(0);  //Black To White  
									 SingleLine->OnExecute();
									 BtmInLine[3].FP0 = SingleLine->GetResultP0();
									 BtmInLine[3].FP1 = SingleLine->GetResultP1();

									 // 연마폭 계산  
									 BtmGrindWidth4 = Math.GetLengthFrLineToPoint(BtmOutLine[3].FP0, BtmOutLine[3].FP1, BtmInLine[3].FP0);

									 //연마량 계산 
									 if(IsMarkBtm){
										 if(CirGrindMeaThresHold!=0){
											 SingleLine->GImage = &RotateGrindBinaryImg; //Binary Image 넘겨줌 
											 SingleLine->SetEdgeType(1);  //White To Black 
											 SingleLine->SetFindLineId(0);
											 SingleLine->OnExecute();

											 BtmStandLine[3].FP0 = SingleLine->GetResultP0();
											 BtmStandLine[3].FP1 = SingleLine->GetResultP1();
											 //연마량 계산 
											 BtmGrindMeasure4 = Math.GetLengthFrLineToPoint(BtmOutLine[3].FP0, BtmOutLine[3].FP1, BtmStandLine[3].FP0);
										 }
									 }
									 LogUnit.SetLog(L"shRectC_Btm4_Insp_End");    
								 }

								 // Circle5과 Circle6 사이의 직선영역 검사 
								 if(BtmEdgePoint[8].x!=0 && BtmEdgePoint[8].y!=0 && BtmEdgePoint[9].x!=0 && BtmEdgePoint[9].y!=0 ){ //BTM 
									 LogUnit.SetLog(L"shRectC_Btm5_Insp_Start");    

									 if(BtmEdgeThresHold==0)    {SingleLine->GImage = &RotateImg      ;  SingleLine->FThreshold =5 ;}
									 else                       {SingleLine->GImage = &RotateBinaryImg;  SingleLine->FThreshold =10;}

									 SingleLine->IRoi->SetOrgX  (BtmEdgePoint[8].x+50                );
									 SingleLine->IRoi->SetOrgY  (BtmEdgePoint[8].y - BtmMargin        );
									 SingleLine->IRoi->SetWidth ((BtmEdgePoint[9].x - BtmEdgePoint[8].x)-100);
									 SingleLine->IRoi->SetHeight(100                                  );
									 if(BtmEdgePoint[8].x+100<=0 || (BtmEdgePoint[8].y-BtmMargin<=0) || ((BtmEdgePoint[9].x-BtmEdgePoint[8].x)-200)<=0 ) return false;

									 SingleLine->SetOrientation(orSouth);
									 // 									 SingleLine->FIncrement =1   ;
									 SingleLine->SetFindLineId(0);
									 SingleLine->FThreshold =5;

									 if(IsMarkBtm) {SingleLine->FIncrement =1 ; SingleLine->SetEdgeType(1);}  //White To Black 
									 else          {SingleLine->FIncrement =10; SingleLine->SetEdgeType(1);}  //White To Black 

									 SingleLine->OnExecute();
									 BtmOutLine[4].FP0 = SingleLine->GetResultP0();
									 BtmOutLine[4].FP1 = SingleLine->GetResultP1();

									 // BtmOutLine Real EdgePoint 추출함 
									 OrgBtm5OutEdgeCount = SingleLine->FEdgePointCount;
									 if(OrgBtm5OutEdgeCount>0){
										 if(OrgBtm5OutPoint!=NULL) delete[] OrgBtm5OutPoint;
										 OrgBtm5OutPoint = new TFPoint[OrgBtm5OutEdgeCount];

										 for(int k=0; k<OrgBtm5OutEdgeCount; k++){
											 if(k>MAX_CIRCLE_EDGEPOINT) break;
											 OrgBtm5OutPoint[k].x = SingleLine->FEdgePoint[k].x;
											 OrgBtm5OutPoint[k].y = SingleLine->FEdgePoint[k].y;
										 }
									 }


									 // BtmInLine Search 
									 if(CirGrindInThresHold==0) {Circle->GImage = &RotateImg             ; SingleLine->FThreshold =5 ;} //Org Image 넘겨줌 
									 else                       {Circle->GImage = &RotateGrindInBinaryImg; SingleLine->FThreshold =10;}//Binary Image 넘겨줌 

									 SingleLine->SetEdgeType(0);  //Black To White  
									 SingleLine->OnExecute();
									 BtmInLine[4].FP0 = SingleLine->GetResultP0();
									 BtmInLine[4].FP1 = SingleLine->GetResultP1();

									 // BtmInLine Real EdgePoint 추출함 
									 OrgBtm5InEdgeCount = SingleLine->FEdgePointCount;
									 if(OrgBtm5InEdgeCount>0){
										 if(OrgBtm5InPoint!=NULL) delete[] OrgBtm5InPoint;
										 OrgBtm5InPoint = new TFPoint[OrgBtm5InEdgeCount];

										 for(int k=0; k<OrgBtm5InEdgeCount; k++){
											 if(k>MAX_CIRCLE_EDGEPOINT) break;
											 OrgBtm5InPoint[k].x = SingleLine->FEdgePoint[k].x;
											 OrgBtm5InPoint[k].y = SingleLine->FEdgePoint[k].y;
										 }
									 }

									 // Grind Mark 기준 연마량 계산 
									 if(IsMarkBtm){ // LT검사시 가공량 측정함 
										 if(FInspectMode==Insp_Track){ // TrackMode TrackLine기준 가공량 측정 
											 if(CirGrindMeaThresHold!=0){
												 // 연마폭 계산  
												 if((fabs(BtmOutLine[4].FP0.y - BtmOutLine[4].FP1.y))>1
													 ||(fabs(BtmInLine[4].FP0.y - BtmInLine[4].FP1.y))>1){
														 BtmGrindWidth5 = BtmOutLine[4].FP1.y - BtmInLine[4].FP1.y; 
												 }
												 else{
													 BtmGrindWidth5 = Math.GetLengthFrLineToPoint(BtmOutLine[4].FP0, BtmOutLine[4].FP1, BtmInLine[4].FP0);
												 }

												 SingleLine->GImage = &RotateGrindBinaryImg; //Binary Image 넘겨줌 
												 SingleLine->SetEdgeType(1);  //White To Black 
												 SingleLine->SetFindLineId(0);
												 SingleLine->OnExecute();

												 BtmStandLine[4].FP0 = SingleLine->GetResultP0();
												 BtmStandLine[4].FP1 = SingleLine->GetResultP1();
												 //연마량 계산 
												 BtmGrindMeasure5 = Math.GetLengthFrLineToPoint(BtmOutLine[4].FP0, BtmOutLine[4].FP1, BtmStandLine[4].FP0);
											 }
										 }
										 else if(Insp_Mark){
											 // GrindMark 상관없이 연마량 측정
											 if(OrgBtm5InEdgeCount>10 && OrgBtm5OutEdgeCount>10 && (OrgBtm5InEdgeCount==OrgBtm5OutEdgeCount)){
												 // 가공량,연마량 측정 전 데이터 존재시 가상GrindMark 생성한다 
												 if(GrindMarkPoint[16].x!=0.0f && GrindMarkPoint[16].y!=0.0f){
													 GrindMarkPoint[14].x     = OrgBtm5InPoint[7 ].x                     ;
													 GrindMarkPoint[14].y     = GrindMarkPoint[16].y                     ;
													 GrindMarkRect [14].left  = GrindMarkPoint[14].x    - GrindMarkRange ;  
													 GrindMarkRect [14].top   = GrindMarkPoint[14].y    - GrindMarkRange ;  
													 GrindMarkRect [14].right = GrindMarkRect [14].left + GrindMarkLength;  
													 GrindMarkRect [14].bottom= GrindMarkRect [14].top  + GrindMarkLength;  
												 }

												 // GrindMark[14] 가공량,연마량 측정 
												 ////////////////////////////////////////////////////////////////////////////////////////////////////
												 if(GrindMarkPoint[14].x!=0.0f && GrindMarkPoint[14].y!=0.0f){ //GrindMark 찾았을경우 검사 시퀀스 가공량 측정 
													 GrindMeaDis =0.0f, MinDis =10000.0f;  Btm5GrindMarkCount=0;
													 for(int k=0; k<OrgBtm5OutEdgeCount; k++){
														 if(OrgBtm5OutPoint[k].x==0.0f || OrgBtm5OutPoint[k].y==0.0f) continue;
														 if(GrindMarkPoint[14].x ==0.0f || GrindMarkPoint[14].y ==0.0f) continue;

														 GrindMeaDis = Math.GetLength(GrindMarkPoint[14], OrgBtm5OutPoint[k]);
														 if(GrindMeaDis<MinDis){
															 MinDis = GrindMeaDis;
															 Btm5GrindMarkCount = k;
														 }
													 }
													 // GrindMark기준 수직 포인트 주변값 Avg산출한다 
													 if(Btm5GrindMarkCount!=0 && Btm5GrindMarkCount>5 && (Btm5GrindMarkCount+5)<OrgBtm5OutEdgeCount){
														 CircleCount=0,TotalCirDis=0.0f,GrindMeaDis=0.0f;
														 for(int k=Btm5GrindMarkCount-5; k<Btm5GrindMarkCount+5; k++){
															 if(OrgBtm5OutPoint[k].x==0.0f || OrgBtm5OutPoint[k].y==0.0f) continue;

															 GrindMeaDis = Math.GetLength(GrindMarkPoint[14], OrgBtm5OutPoint[k]);
															 TotalCirDis+= GrindMeaDis;
															 CircleCount++;
														 }
														 if(TotalCirDis!=0.0f && CircleCount!=0){
															 BtmGrindMeasure7 = TotalCirDis/CircleCount;
														 }
													 }
													 // GrindMark기준 수직 평균값 연마량 측정 
													 if(Btm5GrindMarkCount!=0 && Btm5GrindMarkCount>5 && (Btm5GrindMarkCount+5)<OrgBtm5OutEdgeCount){
														 CircleCount=0,TotalCirDis=0.0f,GrindWidthDis=0.0f;
														 for(int k=Btm5GrindMarkCount-5; k<Btm5GrindMarkCount+5; k++){
															 if(OrgBtm5OutPoint[k].x==0.0f && OrgBtm5OutPoint[k].y==0.0f) continue;
															 if(OrgBtm5InPoint [k].x==0.0f && OrgBtm5InPoint [k].y==0.0f) continue;
															 GrindWidthDis = Math.GetLength(OrgBtm5InPoint[k], OrgBtm5OutPoint[k]);
															 TotalCirDis+=   GrindWidthDis;
															 CircleCount++;
														 }
														 if(TotalCirDis!=0.0f && CircleCount!=0){
															 BtmGrindWidth7 = TotalCirDis/CircleCount;
														 }
													 }
												 }
												 else {  //GrindMark 못 찾았을경우 검사 시퀀스 (가공량: 0, 연마량 측정)
													 GrindMeaDis =0.0f, MinDis =10000.0f;  Btm5GrindMarkCount=0;
													 for(int k=0; k<OrgBtm5OutEdgeCount; k++){
														 if(OrgBtm5OutPoint[k].x==0.0f || OrgBtm5OutPoint[k].y==0.0f) continue;

														 if(k==0){
															 GrindMarkRectCenter[16].x = GrindMarkRect[16].left + (GrindMarkRect[16].right  - GrindMarkRect[16].left)/2; 
															 GrindMarkRectCenter[16].y = GrindMarkRect[16].top  + (GrindMarkRect[16].bottom - GrindMarkRect[16].top )/2; 

															 GrindMarkRectCenter[14].x     = OrgBtm5InPoint     [7 ].x                     ;
															 GrindMarkRectCenter[14].y     = GrindMarkRectCenter[16].y                     ;
															 GrindMarkRect      [14].left  = GrindMarkRectCenter[14].x    - GrindMarkRange ;  
															 GrindMarkRect      [14].top   = GrindMarkRectCenter[14].y    - GrindMarkRange ;  
															 GrindMarkRect      [14].right = GrindMarkRect      [14].left + GrindMarkLength;  
															 GrindMarkRect      [14].bottom= GrindMarkRect      [14].top  + GrindMarkLength;  
														 }

														 GrindMeaDis = Math.GetLength(GrindMarkRectCenter[14], OrgBtm5OutPoint[k]);
														 if(GrindMeaDis<MinDis){
															 MinDis = GrindMeaDis;
															 Btm5GrindMarkCount = k;
														 }
													 }
													 // GrindMark기준 수직 평균값 연마량 측정 
													 if(Btm5GrindMarkCount!=0 && Btm5GrindMarkCount>5 &&(Btm5GrindMarkCount+5<OrgBtm5OutEdgeCount)){
														 CircleCount=0,TotalCirDis=0.0f,GrindWidthDis=0.0f;
														 for(int k=Btm5GrindMarkCount-5; k<Btm5GrindMarkCount+5; k++){
															 if(OrgBtm5OutPoint[k].x==0.0f && OrgBtm5OutPoint[k].y==0.0f) continue;
															 if(OrgBtm5InPoint [k].x==0.0f && OrgBtm5InPoint [k].y==0.0f) continue;
															 GrindWidthDis = Math.GetLength(OrgBtm5InPoint[k], OrgBtm5OutPoint[k]);
															 TotalCirDis+=   GrindWidthDis;
															 CircleCount++;
														 }
														 if(TotalCirDis!=0.0f && CircleCount!=0){
															 BtmGrindWidth7 = TotalCirDis/CircleCount;
														 }
													 }
												 }
												 ////////////////////////////////////////////////////////////////////////////////////////////////////

												 // GrindMark[14] 가공량,연마량 측정 
												 ////////////////////////////////////////////////////////////////////////////////////////////////////
												 if(GrindMarkPoint[16].x!=0.0f && GrindMarkPoint[16].y!=0.0f){ //GrindMark 찾았을경우 검사 시퀀스 가공량 측정 
													 GrindMeaDis =0.0f, MinDis =10000.0f;  Btm5GrindMarkCount=0;
													 for(int k=0; k<OrgBtm5OutEdgeCount; k++){
														 if(OrgBtm5OutPoint[k].x==0.0f || OrgBtm5OutPoint[k ].y==0.0f) continue;
														 if(GrindMarkPoint[16].x==0.0f || GrindMarkPoint[16].y ==0.0f) continue;

														 GrindMeaDis = Math.GetLength(GrindMarkPoint[16], OrgBtm5OutPoint[k]);
														 if(GrindMeaDis<MinDis){
															 MinDis = GrindMeaDis;
															 Btm5GrindMarkCount = k;
														 }
													 }
													 // GrindMark기준 수직 포인트 주변값 Avg산출한다 
													 if(Btm5GrindMarkCount!=0 && Btm5GrindMarkCount>5 && (Btm5GrindMarkCount+5)<OrgBtm5OutEdgeCount){
														 CircleCount=0,TotalCirDis=0.0f,GrindMeaDis=0.0f;
														 for(int k=Btm5GrindMarkCount-5; k<Btm5GrindMarkCount+5; k++){
															 if(OrgBtm5OutPoint[k].x==0.0f || OrgBtm5OutPoint[k].y==0.0f) continue;

															 GrindMeaDis = Math.GetLength(GrindMarkPoint[16], OrgBtm5OutPoint[k]);
															 TotalCirDis+= GrindMeaDis;
															 CircleCount++;
														 }
														 if(TotalCirDis!=0.0f && CircleCount!=0){
															 BtmGrindMeasure9 = TotalCirDis/CircleCount;
														 }
													 }
													 // GrindMark기준 수직 평균값 연마량 측정 
													 if(Btm5GrindMarkCount!=0 && Btm5GrindMarkCount>5 && (Btm5GrindMarkCount+5)<OrgBtm5OutEdgeCount){
														 CircleCount=0,TotalCirDis=0.0f,GrindWidthDis=0.0f;
														 for(int k=Btm5GrindMarkCount-5; k<Btm5GrindMarkCount+5; k++){
															 if(OrgBtm5OutPoint[k].x==0.0f && OrgBtm5OutPoint[k].y==0.0f) continue;
															 if(OrgBtm5InPoint [k].x==0.0f && OrgBtm5InPoint [k].y==0.0f) continue;
															 GrindWidthDis = Math.GetLength(OrgBtm5InPoint[k], OrgBtm5OutPoint[k]);
															 TotalCirDis+=   GrindWidthDis;
															 CircleCount++;
														 }
														 if(TotalCirDis!=0.0f && CircleCount!=0){
															 BtmGrindWidth9 = TotalCirDis/CircleCount;
														 }
													 }
												 }
												 else {  //GrindMark 못 찾았을경우 검사 시퀀스 (가공량: 0, 연마량 측정)
													 GrindMeaDis =0.0f, MinDis =10000.0f;  Btm5GrindMarkCount=0;
													 for(int k=0; k<OrgBtm5OutEdgeCount; k++){
														 if(OrgBtm5OutPoint[k].x==0.0f || OrgBtm5OutPoint[k].y==0.0f) continue;

														 GrindMarkRectCenter[16].x = GrindMarkRect[16].left + (GrindMarkRect[16].right  - GrindMarkRect[16].left)/2; 
														 GrindMarkRectCenter[16].y = GrindMarkRect[16].top  + (GrindMarkRect[16].bottom - GrindMarkRect[16].top )/2; 

														 GrindMeaDis = Math.GetLength(GrindMarkRectCenter[16], OrgBtm5OutPoint[k]);
														 if(GrindMeaDis<MinDis){
															 MinDis = GrindMeaDis;
															 Btm5GrindMarkCount = k;
														 }
													 }
													 // GrindMark기준 수직 평균값 연마량 측정 
													 if(Btm5GrindMarkCount!=0 && Btm5GrindMarkCount>5 &&(Btm5GrindMarkCount+5<OrgBtm5OutEdgeCount)){
														 CircleCount=0,TotalCirDis=0.0f,GrindWidthDis=0.0f;
														 for(int k=Btm5GrindMarkCount-5; k<Btm5GrindMarkCount+5; k++){
															 if(OrgBtm5OutPoint[k].x==0.0f && OrgBtm5OutPoint[k].y==0.0f) continue;
															 if(OrgBtm5InPoint [k].x==0.0f && OrgBtm5InPoint [k].y==0.0f) continue;
															 GrindWidthDis = Math.GetLength(OrgBtm5InPoint[k], OrgBtm5OutPoint[k]);
															 TotalCirDis+=   GrindWidthDis;
															 CircleCount++;
														 }
														 if(TotalCirDis!=0.0f && CircleCount!=0){
															 BtmGrindWidth9 = TotalCirDis/CircleCount;
														 }
													 }
												 }
												 ///////////////////////////////////////////////////////////////////////////////////////////////////////
											 }

											 // 											 if(BtmGrindWidth5!=0.0f && GrindMarkPoint[16].x!=0.0f && GrindMarkPoint[16].y!=0.0f){ // MarkMode GrindMark중심 좌표 기준 가공량 측정 
											 // 												 if(fabs(BtmOutLine[4].FP0.y - BtmOutLine[4].FP1.y)>2){
											 // // 													 BtmGrindWidth5   = (BtmOutLine[4].FP1.y  - GrindMarkPoint[8].y) - (BtmInLine[4].FP1.y - GrindMarkPoint[8].y);
											 // 													 BtmGrindMeasure5 = BtmOutLine[4].FP1.y - GrindMarkPoint[16].y; 
											 // 												 }
											 // 												 else {
											 // 													 BtmGrindMeasure5 = Math.GetLengthFrLineToPoint(BtmOutLine[4].FP0, BtmOutLine[4].FP1, GrindMarkPoint[16]);
											 // // 													 BtmGrindWidth5   = BtmGrindMeasure5 - Math.GetLengthFrLineToPoint(BtmInLine[4].FP0, BtmInLine[4].FP1, GrindMarkPoint[8]);
											 // 												 }
											 // 											 }
										 }
									 }
									 else { // ENCAP 연마량 데이터만 계측함
										 if(BtmOutLine[4].FP0.x!=0.0f && BtmOutLine[4].FP0.y!=0.0f && BtmOutLine[4].FP1.x!=0.0f && BtmOutLine[4].FP1.y!=0.0f &&
											 BtmInLine [4].FP0.x!=0.0f && BtmInLine [4].FP0.y!=0.0f && BtmInLine [4].FP1.x!=0.0f && BtmInLine [4].FP1.y!=0.0f ) 
										 {
											 // 연마량 계산  
											 if((fabs(BtmOutLine[4].FP0.y - BtmOutLine[4].FP1.y))>1
												 ||(fabs(BtmInLine[4].FP0.y - BtmInLine[4].FP1.y))>1){
													 BtmGrindWidth9 = BtmOutLine[4].FP0.y - BtmInLine[4].FP0.y; 
											 }
											 else{
												 BtmGrindWidth9 = Math.GetLengthFrLineToPoint(BtmOutLine[4].FP0, BtmOutLine[4].FP1, BtmInLine[4].FP0);
											 }
										 }
									 }
									 // 동적 생성한 데이터를 지운다 
									 if(OrgBtm5InPoint !=NULL) delete[] OrgBtm5InPoint;
									 if(OrgBtm5OutPoint!=NULL) delete[] OrgBtm5OutPoint;
									 LogUnit.SetLog(L"shRectC_Btm5_Insp_End");    
								 }

								 //RF_MODEL 정말 소스가 점점...더러워진다...ㅜ.ㅜ;;;
								 //Notch부 Side만 Arc가공이 존재할 경우 
								 if(C2CirCenter.x==0.0f && C2CirCenter.y==0.0f && C3CirCenter.x==0.0f && C3CirCenter.y==0.0f && 
									 C4CirCenter.x==0.0f && C4CirCenter.y==0.0f && C5CirCenter.x==0.0f && C5CirCenter.y==0.0f){
										 // 개별 Circle Data 교차점 기준 직선영역의 새로운 Btm영역 BtmOutLine, BtmInLine 찾는다 
										 // Circle1과 Circle6 사이의 직선영역 검사
								        const int BtmMargin =50; const int LeftMargin =30; const int RightMargin =30;
										if(BtmEdgePoint[0].x!=0 && BtmEdgePoint[0].y!=0 && BtmEdgePoint[9].x!=0 && BtmEdgePoint[9].y!=0 ){ // BTM
											LogUnit.SetLog(L"shRectC_Btm1_RF_Insp_Start");    

											if(BtmEdgeThresHold==0)    {SingleLine->GImage = &RotateImg      ;  SingleLine->FThreshold =5 ;}
											else                       {SingleLine->GImage = &RotateBinaryImg;  SingleLine->FThreshold =10;}

											// BtmOutLine Search 
											SingleLine->IRoi->SetOrgX  (BtmEdgePoint[0].x+100                       );
											SingleLine->IRoi->SetOrgY  (BtmEdgePoint[0].y - BtmMargin              );
											SingleLine->IRoi->SetWidth ((BtmEdgePoint[9].x - BtmEdgePoint[0].x)-200);
											SingleLine->IRoi->SetHeight(100                                        );
											if(BtmEdgePoint[0].x+100<=0 || (BtmEdgePoint[0].y-BtmMargin<=0) || ((BtmEdgePoint[9].x-BtmEdgePoint[0].x)-200)<=0 ) return false;

											SingleLine->SetOrientation(orSouth);
											// 									 SingleLine->FIncrement =1   ;
											SingleLine->SetFindLineId(0);
											SingleLine->FThreshold =5;

											if(IsMarkBtm) {SingleLine->FIncrement =20; SingleLine->SetEdgeType(1);}  //White To Black 
											else          {SingleLine->FIncrement =20; SingleLine->SetEdgeType(1);}  //White To Black 

											SingleLine->OnExecute();
											BtmOutLine[0].FP0 = SingleLine->GetResultP0();
											BtmOutLine[0].FP1 = SingleLine->GetResultP1();

											// BtmInLine Search 
											if(CirGrindInThresHold==0) {Circle->GImage = &RotateImg             ; SingleLine->FThreshold =5 ;} //Org Image 넘겨줌 
											else                       {Circle->GImage = &RotateGrindInBinaryImg; SingleLine->FThreshold =10;}//Binary Image 넘겨줌 

											SingleLine->SetEdgeType(0);  //Black To White  
											SingleLine->OnExecute();
											BtmInLine[0].FP0 = SingleLine->GetResultP0();
											BtmInLine[0].FP1 = SingleLine->GetResultP1();

											// Grind Mark 기준 연마량 계산 
											if(IsMarkBtm){ // LT검사시 가공량 측정함 
												if(FInspectMode==Insp_Track){ // TrackMode TrackLine기준 가공량 측정 
													if(CirGrindMeaThresHold!=0){
														// 연마량 계산  
														if((fabs(BtmOutLine[0].FP0.y - BtmOutLine[0].FP1.y))>1
															||(fabs(BtmInLine[0].FP0.y - BtmInLine[0].FP1.y))>1){
																BtmGrindWidth1 = BtmOutLine[0].FP0.y - BtmInLine[0].FP0.y; 
														}
														else{
															BtmGrindWidth1 = Math.GetLengthFrLineToPoint(BtmOutLine[0].FP0, BtmOutLine[0].FP1, BtmInLine[0].FP0);
														}

														SingleLine->GImage = &RotateGrindBinaryImg; //Binary Image 넘겨줌 
														SingleLine->SetEdgeType(1);  //White To Black 
														SingleLine->SetFindLineId(0);
														SingleLine->OnExecute();

														BtmStandLine[0].FP0 = SingleLine->GetResultP0();
														BtmStandLine[0].FP1 = SingleLine->GetResultP1();
														// 가공량 계산 
														BtmGrindMeasure1 = Math.GetLengthFrLineToPoint(BtmOutLine[0].FP0, BtmOutLine[0].FP1, BtmStandLine[0].FP0);
													}
												}
												else if(FInspectMode==Insp_Mark){ // RF_MODEL GrindMark 기준 특정 Point 개별 EdgePoint 데이터를 산출하여 연마량,가공량 계산
													// GrindMark[2] 시퀀스 시작 
													if(GrindMarkRect[2].left!=0.0f && GrindMarkRect[2].top!=0.0f && GrindMarkRect[2].right!=0.0f && GrindMarkRect[2].bottom!=0.0f){ //GrindMark 찾았을경우 검사 시퀀스 가공량 측정 
														if(BtmEdgeThresHold==0)    {SingleLine->GImage = &RotateImg      ;  SingleLine->FThreshold =5 ;}
														else                       {SingleLine->GImage = &RotateBinaryImg;  SingleLine->FThreshold =10;}

														// Btm1OutLine
														SingleLine->IRoi->SetOrgX  (GrindMarkRect[2].left-50                            );
														SingleLine->IRoi->SetOrgY  (BtmOutLine[0].FP0.y - BtmMargin                     );
														SingleLine->IRoi->SetWidth ((GrindMarkRect[2].right - GrindMarkRect[2].left)+100);
														SingleLine->IRoi->SetHeight(100                                                 );
														if(GrindMarkRect[2].left-50 <=0 || (BtmOutLine[0].FP0.y - BtmMargin<=0) || ((GrindMarkRect[2].right - GrindMarkRect[2].left)+100)<=0 ) return false;

														SingleLine->SetOrientation(orSouth);
														SingleLine->SetFindLineId(0);
														SingleLine->FThreshold =5;

														if(IsMarkBtm) {SingleLine->FIncrement =1; SingleLine->SetEdgeType(1);}  //White To Black 
														else          {SingleLine->FIncrement =1; SingleLine->SetEdgeType(1);}  //White To Black 

														SingleLine->OnExecute();

														// Btm1OutLine Real EdgePoint 추출함 
														OrgBtm1OutEdgeCount = SingleLine->FEdgePointCount;
														if(OrgBtm1OutEdgeCount>0){
															if(OrgBtm1OutPoint!=NULL) delete[] OrgBtm1OutPoint;
															OrgBtm1OutPoint = new TFPoint[OrgBtm1OutEdgeCount];

															for(int k=0; k<OrgBtm1OutEdgeCount; k++){
																if(k>MAX_CIRCLE_EDGEPOINT) break;
																OrgBtm1OutPoint[k].x = SingleLine->FEdgePoint[k].x;
																OrgBtm1OutPoint[k].y = SingleLine->FEdgePoint[k].y;
															}
														}

														// GrindMarkPoint 검출 유무에 따라서 연마량,가공량 측정한다 
														if(GrindMarkPoint[2].x!=0.0f && GrindMarkPoint[2].y!=0.0f){ //GrindMark 찾았을경우 검사 시퀀스 연마량,가공량 측정 
															GrindMeaDis =0.0f, MinDis =10000.0f;  Btm1GrindMarkCount=0;
															for(int k=0; k<OrgBtm1OutEdgeCount; k++){
																if(OrgBtm1OutPoint[k].x==0.0f || OrgBtm1OutPoint[k].y==0.0f) continue;
																if(GrindMarkPoint[2].x ==0.0f || GrindMarkPoint[2].y ==0.0f) continue;

																GrindMeaDis = Math.GetLength(GrindMarkPoint[2], OrgBtm1OutPoint[k]);
																if(GrindMeaDis<MinDis){
																	MinDis = GrindMeaDis;
																	Btm1GrindMarkCount = k;
																}
															}
															// GrindMark기준 수직 포인트 주변값 Avg산출한다 
															if(Btm1GrindMarkCount!=0 && Btm1GrindMarkCount>5 && (Btm1GrindMarkCount+5)<OrgBtm1OutEdgeCount){
																CircleCount=0,TotalCirDis=0.0f,GrindMeaDis=0.0f;
																for(int k=Btm1GrindMarkCount-5; k<Btm1GrindMarkCount+5; k++){
																	if(OrgBtm1OutPoint[k].x==0.0f || OrgBtm1OutPoint[k].y==0.0f) continue;

																	GrindMeaDis = Math.GetLength(GrindMarkPoint[2], OrgBtm1OutPoint[k]);
																	TotalCirDis+= GrindMeaDis;
																	CircleCount++;
																}
																if(TotalCirDis!=0.0f && CircleCount!=0){
																	BtmGrindMeasure1 = TotalCirDis/CircleCount;
																}
															}
														}
													}

													// GrindMark[9] 시퀀스 시작 
													if(GrindMarkRect[9].left!=0.0f && GrindMarkRect[9].top!=0.0f && GrindMarkRect[9].right!=0.0f && GrindMarkRect[9].bottom!=0.0f){ //GrindMark 찾았을경우 검사 시퀀스 가공량 측정 
														if(BtmEdgeThresHold==0)    {SingleLine->GImage = &RotateImg      ;  SingleLine->FThreshold =5 ;}
														else                       {SingleLine->GImage = &RotateBinaryImg;  SingleLine->FThreshold =10;}

														// Btm1OutLine
														SingleLine->IRoi->SetOrgX  (GrindMarkRect[9].left-50                            );
														SingleLine->IRoi->SetOrgY  (BtmOutLine[0].FP0.y - BtmMargin                     );
														SingleLine->IRoi->SetWidth ((GrindMarkRect[9].right - GrindMarkRect[9].left)+100);
														SingleLine->IRoi->SetHeight(100                                                 );
														if(GrindMarkRect[9].left-50 <=0 || (BtmOutLine[0].FP0.y - BtmMargin<=0) || ((GrindMarkRect[9].right - GrindMarkRect[9].left)+100)<=0 ) return false;

														SingleLine->SetOrientation(orSouth);
														SingleLine->SetFindLineId(0);
														SingleLine->FThreshold =5;

														if(IsMarkBtm) {SingleLine->FIncrement =1; SingleLine->SetEdgeType(1);}  //White To Black 
														else          {SingleLine->FIncrement =1; SingleLine->SetEdgeType(1);}  //White To Black 

														SingleLine->OnExecute();

														// Btm1OutLine Real EdgePoint 추출함 
														OrgBtm3OutEdgeCount = SingleLine->FEdgePointCount;
														if(OrgBtm3OutEdgeCount>0){
															if(OrgBtm1OutPoint!=NULL) delete[] OrgBtm3OutPoint;
															OrgBtm3OutPoint = new TFPoint[OrgBtm3OutEdgeCount];

															for(int k=0; k<OrgBtm3OutEdgeCount; k++){
																if(k>MAX_CIRCLE_EDGEPOINT) break;
																OrgBtm3OutPoint[k].x = SingleLine->FEdgePoint[k].x;
																OrgBtm3OutPoint[k].y = SingleLine->FEdgePoint[k].y;
															}
														}

														// GrindMarkPoint 검출 유무에 따라서 연마량,가공량 측정한다 
														if(GrindMarkPoint[9].x!=0.0f && GrindMarkPoint[9].y!=0.0f){ //GrindMark 찾았을경우 검사 시퀀스 연마량,가공량 측정 
															GrindMeaDis =0.0f, MinDis =10000.0f;  Btm3GrindMarkCount=0;
															for(int k=0; k<OrgBtm3OutEdgeCount; k++){
																if(OrgBtm3OutPoint[k].x==0.0f || OrgBtm3OutPoint[k].y==0.0f) continue;
																if(GrindMarkPoint[9].x ==0.0f || GrindMarkPoint[9].y ==0.0f) continue;

																GrindMeaDis = Math.GetLength(GrindMarkPoint[9], OrgBtm3OutPoint[k]);
																if(GrindMeaDis<MinDis){
																	MinDis = GrindMeaDis;
																	Btm3GrindMarkCount = k;
																}
															}
															// GrindMark기준 수직 포인트 주변값 Avg산출한다 
															if(Btm3GrindMarkCount!=0 && Btm3GrindMarkCount>5 && (Btm3GrindMarkCount+5)<OrgBtm3OutEdgeCount){
																CircleCount=0,TotalCirDis=0.0f,GrindMeaDis=0.0f;
																for(int k=Btm3GrindMarkCount-5; k<Btm3GrindMarkCount+5; k++){
																	if(OrgBtm3OutPoint[k].x==0.0f || OrgBtm3OutPoint[k].y==0.0f) continue;

																	GrindMeaDis = Math.GetLength(GrindMarkPoint[9], OrgBtm3OutPoint[k]);
																	TotalCirDis+= GrindMeaDis;
																	CircleCount++;
																}
																if(TotalCirDis!=0.0f && CircleCount!=0){
																	BtmGrindMeasure5 = TotalCirDis/CircleCount;
																}
															}
														}
													}

													// GrindMark[16] 시퀀스 시작 
													if(GrindMarkRect[16].left!=0.0f && GrindMarkRect[16].top!=0.0f && GrindMarkRect[16].right!=0.0f && GrindMarkRect[16].bottom!=0.0f){ //GrindMark 찾았을경우 검사 시퀀스 가공량 측정 
														if(BtmEdgeThresHold==0)    {SingleLine->GImage = &RotateImg      ;  SingleLine->FThreshold =5 ;}
														else                       {SingleLine->GImage = &RotateBinaryImg;  SingleLine->FThreshold =10;}

														// Btm1OutLine
														SingleLine->IRoi->SetOrgX  (GrindMarkRect[16].left-50                           );
														SingleLine->IRoi->SetOrgY  (BtmOutLine[0].FP1.y - BtmMargin                     );
														SingleLine->IRoi->SetWidth ((GrindMarkRect[16].right - GrindMarkRect[16].left)+100);
														SingleLine->IRoi->SetHeight(100                                                 );
														if(GrindMarkRect[16].left-50 <=0 || (BtmOutLine[0].FP1.y - BtmMargin<=0) || ((GrindMarkRect[16].right - GrindMarkRect[16].left)+100)<=0 ) return false;

														SingleLine->SetOrientation(orSouth);
														SingleLine->SetFindLineId(0);
														SingleLine->FThreshold =5;

														if(IsMarkBtm) {SingleLine->FIncrement =1; SingleLine->SetEdgeType(1);}  //White To Black 
														else          {SingleLine->FIncrement =1; SingleLine->SetEdgeType(1);}  //White To Black 

														SingleLine->OnExecute();

														// Btm1OutLine Real EdgePoint 추출함 
														OrgBtm5OutEdgeCount = SingleLine->FEdgePointCount;
														if(OrgBtm5OutEdgeCount>0){
															if(OrgBtm5OutPoint!=NULL) delete[] OrgBtm5OutPoint;
															OrgBtm5OutPoint = new TFPoint[OrgBtm5OutEdgeCount];

															for(int k=0; k<OrgBtm5OutEdgeCount; k++){
																if(k>MAX_CIRCLE_EDGEPOINT) break;
																OrgBtm5OutPoint[k].x = SingleLine->FEdgePoint[k].x;
																OrgBtm5OutPoint[k].y = SingleLine->FEdgePoint[k].y;
															}
														}

														// GrindMarkPoint 검출 유무에 따라서 연마량,가공량 측정한다 
														if(GrindMarkPoint[16].x!=0.0f && GrindMarkPoint[16].y!=0.0f){ //GrindMark 찾았을경우 검사 시퀀스 연마량,가공량 측정 
															GrindMeaDis =0.0f, MinDis =10000.0f;  Btm5GrindMarkCount=0;
															for(int k=0; k<OrgBtm5OutEdgeCount; k++){
																if(OrgBtm5OutPoint[k].x==0.0f || OrgBtm5OutPoint[k].y==0.0f) continue;
																if(GrindMarkPoint[16].x==0.0f || GrindMarkPoint[16].y==0.0f) continue;

																GrindMeaDis = Math.GetLength(GrindMarkPoint[16], OrgBtm5OutPoint[k]);
																if(GrindMeaDis<MinDis){
																	MinDis = GrindMeaDis;
																	Btm5GrindMarkCount = k;
																}
															}
															// GrindMark기준 수직 포인트 주변값 Avg산출한다 
															if(Btm5GrindMarkCount!=0 && Btm5GrindMarkCount>5 && (Btm5GrindMarkCount+5)<OrgBtm5OutEdgeCount){
																CircleCount=0,TotalCirDis=0.0f,GrindMeaDis=0.0f;
																for(int k=Btm5GrindMarkCount-5; k<Btm5GrindMarkCount+5; k++){
																	if(OrgBtm5OutPoint[k].x==0.0f || OrgBtm5OutPoint[k].y==0.0f) continue;

																	GrindMeaDis = Math.GetLength(GrindMarkPoint[16], OrgBtm5OutPoint[k]);
																	TotalCirDis+= GrindMeaDis;
																	CircleCount++;
																}
																if(TotalCirDis!=0.0f && CircleCount!=0){
																	BtmGrindMeasure9 = TotalCirDis/CircleCount;
																}
															}
														}
													}
												}
											}
											else { // ENCAP 연마량 데이터만 계측함
												if(BtmOutLine[0].FP0.x!=0.0f && BtmOutLine[0].FP0.y!=0.0f && BtmOutLine[0].FP1.x!=0.0f && BtmOutLine[0].FP1.y!=0.0f &&
													BtmInLine [0].FP0.x!=0.0f && BtmInLine [0].FP0.y!=0.0f && BtmInLine [0].FP1.x!=0.0f && BtmInLine [0].FP1.y!=0.0f ){
														// 연마량 계산  
														if((fabs(BtmOutLine[0].FP0.y - BtmOutLine[0].FP1.y))>1
															||(fabs(BtmInLine[0].FP0.y - BtmInLine[0].FP1.y))>1){
																BtmGrindWidth1 = BtmOutLine[0].FP0.y - BtmInLine[0].FP0.y; 
																BtmGrindWidth5 = BtmOutLine[0].FP0.y - BtmInLine[0].FP0.y; 
																BtmGrindWidth9 = BtmOutLine[0].FP0.y - BtmInLine[0].FP0.y; 
														}
														else{
															BtmGrindWidth1 = Math.GetLengthFrLineToPoint(BtmOutLine[0].FP0, BtmOutLine[0].FP1, BtmInLine[0].FP0);
															BtmGrindWidth5 = Math.GetLengthFrLineToPoint(BtmOutLine[0].FP0, BtmOutLine[0].FP1, BtmInLine[0].FP0);
															BtmGrindWidth9 = Math.GetLengthFrLineToPoint(BtmOutLine[0].FP0, BtmOutLine[0].FP1, BtmInLine[0].FP0);
														}
												}
											}
											// 동적 생성한 데이터를 지운다 
											if(OrgBtm1OutPoint!=NULL) delete[] OrgBtm1OutPoint;
											if(OrgBtm3OutPoint!=NULL) delete[] OrgBtm3OutPoint;
											if(OrgBtm5OutPoint!=NULL) delete[] OrgBtm5OutPoint;
											LogUnit.SetLog(L"shRectC_Btm1_RF_Insp_End");    
										}
								 }
							 }           
						 }       
					 }
				 }
                 Index++;

        // Find Edge Point - Bevel In Side Only
        //----------------------------------------------------------------------
        case 11 :
			     DefectImg.SetSize(GImage->GetWidth(), GImage->GetHeight());
			     EasyImage::Oper(EArithmeticLogicOperation_Copy,GImage,&DefectImg);
         		 //EasyImage::Threshold(GImage,&DefectImg, DThresHold);

                 if (FProcessMode==pmAutoBevelIn) {
					 //BinaryImg.SetSize(GImage->GetWidth(), GImage->GetHeight());
					 //EasyImage::Oper(EArithmeticLogicOperation_Copy,GImage,&BinaryImg);
					 //EasyImage::Threshold(GImage,&BinaryImg, ThredHold);
					 Edge->GImage = &DefectImg;
                     //Edge->GImage = GImage;
  
                     if(!OnAutoBevelIn()) return false;
                     Index=0;
                     return true;
                 }
                 Index++;

        case 12 :
                 Index=0;
                 break;
    }
    return true;
}
void CFM1xLineDefect::OnLoad(bool IsLoad, CString Folder)
{
    CIFile Ini;

    if (Folder=="") return;
    CString Path = Folder + "\\PLine.ini";
    if (Path=="") return;

    //Ini.Load(IsLoad, Path, "Parameter", "FMaxLines"  , &FMaxLines);
}
//------------------------------------------------------------------------------------
// 사용자 Get함수 
//------------------------------------------------------------------------------------------
CFind* CFM1xLineDefect::GetFindPointer(int n)
{
	if     (n==0) return Find1;
	else if(n==1) return Find2;
	return NULL;
}

//------------------------------------------------------------------------------------
// 사용자 Set함수 
//------------------------------------------------------------------------------------------
void CFM1xLineDefect::SetProcessMode(TProcessMode ProcessMode)
{
	FProcessMode  = ProcessMode;
}
//------------------------------------------------------------------------------------------
void CFM1xLineDefect::SetInspectMode(TInspectMode InspectMode)
{
	FInspectMode  = InspectMode;
}
//------------------------------------------------------------------------------------------
void CFM1xLineDefect::SetCutMode(TCutMode CutMode)
{
	FCutMode  = CutMode;
}
//-------------------------------------------------------------------------------------------
void CFM1xLineDefect::SetCompanyMode(TCompany Company)
{
	FCompanyMode  = Company;
}
//-------------------------------------------------------------------------------------------
void CFM1xLineDefect::SetShape(TShape Shape)
{
	FShape = Shape;
}
//-------------------------------------------------------------------------------------------
void CFM1xLineDefect::SetCrossLeftPoint(int x, int y)
{
    FP0.x = (float)x;
	FP0.y = (float)y;
	AlignMark1.x = FP0.x;
	AlignMark1.y = FP0.y;
}
//------------------------------------------------------------------------------------------
void CFM1xLineDefect::SetCrossRightPoint(int x, int y)
{
    FP1.x =(float)x;
	FP1.y =(float)y;
	AlignMark2.x = FP1.x;
	AlignMark2.y = FP1.y;
}
//------------------------------------------------------------------------------------------
void CFM1xLineDefect::SetSpecWidth(float MinWidth , float MaxWidth)
{
	FMinWidth = MinWidth;
	FMaxWidth = MaxWidth;
}
//------------------------------------------------------------------------------------------
void CFM1xLineDefect::SetSpecHeight(float MinHeight, float MaxHeight)
{
	FMinHeight = MinHeight;
	FMaxHeight = MaxHeight;
}
//------------------------------------------------------------------------------------------
