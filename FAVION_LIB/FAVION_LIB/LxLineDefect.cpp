// LxLineDefect.cpp: implementation of the CLineDefect class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "LxLineDefect.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#define new DEBUG_NEW
#endif

// #if LINESCAN_CAMERA_MODE == 0
// #define IElement(x, y)  *((BYTE *)IAddress + x + 4096 * y)  // 4K  LineScan
// #elif LINESCAN_CAMERA_MODE ==1
// #define IElement(x, y)  *((BYTE *)IAddress + x + 16384 * y) // 16K LineScan
// #elif LINESCAN_CAMERA_MODE ==2
// #define IElement(x, y)  *((BYTE *)IAddress + x + 23552 * y) // 23K LineScan
// #endif

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
///////////////////////////////////////Imag///////////////////////////////

CLineDefect::CLineDefect()
{
    FEdgePoint = NULL;
    FDefectPoint = NULL;

    FEscapeDeviation = 2;
    FThickness    = 1;
    FMinAmplitude = 1;
    FThreshold    = 1;
    FMinArea      = 0;
    FSmoothing    = 0;
    FIncrement    = 1;

//     IRoi = new EROIBW8();
}

CLineDefect::~CLineDefect()
{
}

//------------------------------------------------------------------------------

void CLineDefect::SetRoi(TPoint FP, TPoint SP)
{
    int l = FP.x <= SP.x ? FP.x : SP.x;
    int t = FP.y <= SP.y ? FP.y : SP.y;
    int r = FP.x >= SP.x ? FP.x : SP.x;
    int b = FP.y >= SP.y ? FP.y : SP.y;

    IRoi->SetOrgX(l);
    IRoi->SetOrgY(t);
    IRoi->SetWidth (r-l);
    IRoi->SetHeight(b-t);
}

//------------------------------------------------------------------------------

int CLineDefect::OnExecute()
{
    int szX = IRoi->GetWidth();
    int szY = IRoi->GetHeight();
    int szBuffer = szX > szY ? szX : szY;

    if (szBuffer<10) {
        //ShowMessage("Check Roi Size");
        return false;
    }

    if (FEdgePoint != NULL) delete[] FEdgePoint;
    if (FDefectPoint != NULL) delete[] FDefectPoint;

    FEdgePoint = new TFPoint[szBuffer];
    FDefectPoint = new TFPoint[szBuffer];

    FEdgePointCount = 0;
    FDefectPointCount = 0;

    int Px, Py, Pw, Ph;
    int Index = 0;

    TPoint SP, EP;

    //EWorldShape WorldShape; // EWorldShape instance
    EPointGauge PointGauge; // EPointGauge instance

    bool FFindVerticalLine;
    bool FFwdDirection;

    if (FOrientation==orWest ) { FFindVerticalLine = true ; FFwdDirection = true; }
    if (FOrientation==orEast ) { FFindVerticalLine = true ; FFwdDirection = false; }
    if (FOrientation==orNorth) { FFindVerticalLine = false; FFwdDirection = true; }
    if (FOrientation==orSouth) { FFindVerticalLine = false; FFwdDirection = false; }

    switch (Index) {
        case 0 :
                 //Roi = GetRoi(FFstPoint, FSndPoint);
                 IRoi->Attach(GImage);
                 CSingleLine::OnExecute();
                 Index++;

        case 1 :
                 Px = IRoi->GetOrgX  ();
                 Py = IRoi->GetOrgY  ();
                 Pw = IRoi->GetWidth ();
                 Ph = IRoi->GetHeight();

                 //WorldShape.SetSensorSize(Pw, Ph);
                 //WorldShape.Process(GImage, true);
                 //PointGauge.SetDragable(true);
                 //PointGauge.SetResizable(true);
                 //PointGauge.SetRotatable(true);
                 //PointGauge.Attach(&WorldShape);
                 PointGauge.SetMinAmplitude(FMinAmplitude);
                 PointGauge.SetMinArea     (FMinArea     );
                 PointGauge.SetThreshold   (FThreshold   );
                 PointGauge.SetThickness   (FThickness   );
                 PointGauge.SetSmoothing   (FSmoothing   );

                 PointGauge.SetTransitionType(ETransitionType_Wb);
                 if      (FEdgeType==0) PointGauge.SetTransitionType(ETransitionType_Bw    );
                 else if (FEdgeType==1) PointGauge.SetTransitionType(ETransitionType_Wb    );
                 else if (FEdgeType==2) PointGauge.SetTransitionType(ETransitionType_BwOrWb);
                 else if (FEdgeType==3) PointGauge.SetTransitionType(ETransitionType_Bwb);
                 else if (FEdgeType==4) PointGauge.SetTransitionType(ETransitionType_Wbw);

                 FIncrement = 1;

                 Index++;

        case 2 :
                 FEdgePointCount = 0;
                 FDefectPointCount = 0;

                 if (FFindVerticalLine) {
                     for (int y=Py; y<Py+Ph; y+=FIncrement) {
                         SP.x = Px;
                         EP.x = Px+Pw;
                         SP.y = y;
                         EP.y = y;

                         PointGauge.SetTolerance((float)(Pw/2));
                         PointGauge.SetToleranceAngle(FFwdDirection ? 0.0f : 180.0f);
                         PointGauge.SetCenterXY((float)(SP.x+(EP.x-SP.x)/2), (float)(SP.y+(EP.y-SP.y)/2));
                         PointGauge.Measure(GImage);

                         int n = PointGauge.GetNumMeasuredPoints();

                         if (n) {
                             FEdgePoint[FEdgePointCount].x = PointGauge.GetMeasuredPoint(0).GetX();
                             FEdgePoint[FEdgePointCount].y = PointGauge.GetMeasuredPoint(0).GetY();

                             float dist = Math.GetLengthFrLineToPoint(FP0, FP1, FEdgePoint[FEdgePointCount]);
                             if (dist>FEscapeDeviation) {
                                 FDefectPoint[FDefectPointCount] = FEdgePoint[FEdgePointCount];
                                 FDefectPointCount++;
                             }

                             FEdgePointCount++;
                         }
                     }
                 }

                 else {
                     for (int x=Px; x<Px+Pw; x+=FIncrement) {
                         SP.x = x;
                         EP.x = x;
                         SP.y = Py;
                         EP.y = Py+Ph;

                         PointGauge.SetCenterXY((float)(SP.x+(EP.x-SP.x)/2), (float)(SP.y+(EP.y-SP.y)/2));
                         PointGauge.SetTolerance((float)(Ph/2));
                         PointGauge.SetToleranceAngle(FFwdDirection ? 90.0f : 270.0f);
                         PointGauge.Measure(GImage);

                         int n= PointGauge.GetNumMeasuredPoints();

                         if (n) {
                             FEdgePoint[FEdgePointCount].x = PointGauge.GetMeasuredPoint(0).GetX();
                             FEdgePoint[FEdgePointCount].y = PointGauge.GetMeasuredPoint(0).GetY();
                             float dist = Math.GetLengthFrLineToPoint(FP0, FP1, FEdgePoint[FEdgePointCount]);

                             if (dist>FEscapeDeviation) {
                                 FDefectPoint[FDefectPointCount] = FEdgePoint[FEdgePointCount];
                                 FDefectPointCount++;
                             }

                             FEdgePointCount++;
                         }
                     }
                 }
                 Index++;

        case 3 :
                 Index=0;
                 return true;

    }
    return false;
}
void CLineDefect::OnPaint(TDrawTool Tool)
{
    CSingleLine::OnPaint(Tool);
    OnPaintEdgePoint    (Tool);
    OnPaintEscapePoint  (Tool);
}

void CLineDefect::OnPaintEdgePoint(TDrawTool Tool)
{
	if (Tool.Handle==NULL) return;

    HGdi *Gdi = new HGdi(Tool.Handle);

	Gdi->FVx = Tool.FVx;
	Gdi->FVy = Tool.FVy;
	Gdi->FHs = Tool.FHs;
	Gdi->FVs = Tool.FVs;
	Gdi->CPen.Color = Tool.Color;

    for (int k=0; k<FEdgePointCount; k++) {
        Gdi->OnPixel((int)FEdgePoint[k].x, (int)FEdgePoint[k].y, BLUE_COLOR);
    }

    delete Gdi;
}

void CLineDefect::OnPaintEscapePoint(TDrawTool Tool)
{
    if (Tool.Handle==NULL) return;

    HGdi *Gdi = new HGdi(Tool.Handle);

	Gdi->FVx = Tool.FVx;
	Gdi->FVy = Tool.FVy;
	Gdi->FHs = Tool.FHs;
	Gdi->FVs = Tool.FVs;
	Gdi->CPen.Color = Tool.Color;

    for (int k=0; k<FDefectPointCount; k++) {
        Gdi->OnCircle(false, (int)FDefectPoint[k].x, (int)FDefectPoint[k].y, 5, 5);
    }

    delete Gdi;
}
void CLineDefect::OnLoad(bool IsLoad, CString Folder)
{
	CSingleLine::OnLoad(IsLoad, Folder);

	CIFile Ini;

	if (Folder.Trim()=="") return;
	CString Path = Folder + "\\PLine.ini";
	if (Path=="") return;
}

//------------------------------------------------------------------------------
// Class CPolygoneDefect
CPolygoneDefect::CPolygoneDefect()
{
    RectEdge = new CRectEdge();

    FEscapeDeviation = 2;

    FDefectPoint = new TFPoint[1000];
}

CPolygoneDefect::~CPolygoneDefect()
{
}

float CPolygoneDefect::GetLengthFrLineToPoint(TFPoint P1, TFPoint P2, TFPoint P3)
{
    //--------------------------------------------------------------------------
    // 직선과 한점의 수직한 교차점에 의한 치수 측정
    // 공식 : ax + by + c = 0, (m, n) -> Distance = (ma + nb +c) / sqrt(a*a + b*b)
    //--------------------------------------------------------------------------

    double xDiff = P2.x-P1.x;
    double yDiff = P2.y-P1.y;

    if      (xDiff == 0) return (float)(fabs(P3.x-P1.x));
    else if (yDiff == 0) return (float)(fabs(P3.y-P1.y));

    float m    = (float)(yDiff/xDiff);
    float dist = 0.0f;
	dist = (float)(fabs((-m*P3.x + P3.y + m*P1.x - P1.y)/sqrt(m*m + 1)));

    return (float)dist;
}

int CPolygoneDefect::OnExecute()
{
    bool l  = FLeftWall   ;
    bool t  = FTopWall    ;
    bool r  = FRightWall  ;
    bool b  = FBottomWall ;
    return OnExecute(l, t, r, b);
}

int CPolygoneDefect::OnExecute(bool l, bool t, bool r, bool b)
{
    CPolygoneLine::OnExecute();

    int Index = 10;
	// GOO
	int i;

    switch (Index) {

        case 10 :
                 RectEdge->GImage = GImage;
                 RectEdge->IRoi->SetOrgX  (0);
                 RectEdge->IRoi->SetOrgY  (0);
                 RectEdge->IRoi->SetWidth (RectEdge->GImage->GetWidth ());
                 RectEdge->IRoi->SetHeight(RectEdge->GImage->GetHeight());
                 RectEdge->OnExecute(l, t, r, b);
                 Index++;

        case 11 :
                 FDefectPointCount = 0;
                 for (i=0; i<RectEdge->GetResultEdgePointCount(); i++) {
                      bool IsNormal = false;
                      for (int k=0; k<FMaxLines; k++) {
                          float dt = GetLengthFrLineToPoint(Line[k].FP0, Line[k].FP1, RectEdge->GetResultEdgePoint(i));

                          if (dt<=FEscapeDeviation) IsNormal = true;
                          if (IsNormal) break;
                      }

                      if (!IsNormal) {
                          FDefectPoint[FDefectPointCount] = RectEdge->GetResultEdgePoint(i);
                          FDefectPointCount++;
                      }
                 }
                 Index++;

        case 12 :
                 Index++;

        case 13 :
                 Index=0;
                 break;


    }

    return true;
}

void CPolygoneDefect::OnLoad(bool IsLoad, CString Folder)
{
    CPolygoneLine::OnLoad(IsLoad, Folder);

	CIFile Ini;
	CFileUnit FileUnit;
	CFile File;

    if (Folder=="") return;
    CString Path = Folder + "\\PLine.ini";
    if (Path=="") return;

	if(!FileUnit.FileExist(Path)) 	{
		File.Open(Path,CFile::modeCreate);
	}
    //Ini.Load(IsLoad, Path, "Parameter", "FMaxLines"  , &FMaxLines);
}

void CPolygoneDefect::OnPaint(TDrawTool Tool)
{
    CPolygoneLine::OnPaint(Tool);

    if (Tool.Handle==NULL) return;

    HGdi *Gdi = new HGdi(Tool.Handle);

	Gdi->FVx = Tool.FVx;
	Gdi->FVy = Tool.FVy;
	Gdi->FHs = Tool.FHs;
	Gdi->FVs = Tool.FVs;
	Gdi->CPen.Color = Tool.Color;

    TPoint Point1, Point2;
    Gdi->CText.Color  = YELLOW_COLOR;
    Gdi->CFont.Height = 12;

    TFPoint SP, EP;

    RectEdge->OnPaint(Tool);

    for (int k=0; k<FDefectPointCount; k++) {
        Gdi->OnCircle(false, (int)FDefectPoint[k].x, (int)FDefectPoint[k].y, 5, 5);
        Gdi->OnLinePlus((int)FDefectPoint[k].x, (int)FDefectPoint[k].y, 5);
    }

    delete Gdi;
}

//int CMultiLineDefect::RectHCount=0;
CMultiLineDefect::CMultiLineDefect()
{
    SingleLine  = new CSingleLine();
    RectEdge    = new CRectEdge();
    Edge        = new CEdge();
    Find1       = new CFind();
    Find2       = new CFind();
// 	Trace       = new JTrace();
	Circle      = new CCircle();
// 	Match       = new CMatch();
	Find        = new CFind();
	CircleFit   = new CCircleFit();
	Polygon     = new CPolygon();
// 	Cliper      = new ClipperOffset();

    FLeftWall    = true ; 
    FTopWall     = true ; 
    FRightWall   = true ; 
    FBottomWall  = true ; 
    FLeftTop     = true ; 
    FRightTop    = true ; 
    FRightBottom = true ; 
    FLeftBottom  = true ; 
	IsBmLine     = true ;
	IsMarkLine   = false;
	IsMarkBtm    = false;
	IsLongTop    = false;
	IsShortCell  = false;
	IsAllGrind   = false;

	MarkPos.x    = 0.0f;
	MarkPos.y    = 0.0f;

	MarkEndPos.x = 0.0f;
	MarkEndPos.y = 0.0f;

	MarkStrPos.x = 0.0f;
	MarkStrPos.y = 0.0f;

	MarkAng     = 0.0f;

    FEscapeDeviation = 5;
    FBevelIn = false;

	FProcessMode = pmAutoOutLine;

	FDrawOutLine  = true;
	FDrawBevelIn  = false;
	FDrawRectEdge = false;
	FDrawDefect   = true;

    IRoi = new EROIBW8();

	// Dark Defect 
	DefectPointCount = 0; // 전체 불량 개수 초기화
	ACount           = 0; // 모자모양 불량 개수 초기화
	BCount           = 0; // 젓가락모양 불량 개수 초기화
	CCount           = 0; // 컵모양 불량 개수 초기화
	DCount           = 0;
	C1Count          = 0;
	C2Count          = 0;
	C3Count          = 0;
	C4Count          = 0;
	ABurrCount       = 0;
	BBurrCount       = 0;
	CBurrCount       = 0;
	DBurrCount       = 0;

	// Bridht Defect 
	ACrackCount      = 0;
	BCrackCount      = 0;
	CCrackCount      = 0;
	DCrackCount      = 0;

	// Dark Defect 
	A1CirDeftectCnt  = 0;
	A2CirDeftectCnt  = 0;
    C1CirDeftectCnt  = 0;
	C2CirDeftectCnt  = 0;
	C3CirDeftectCnt  = 0;
	C4CirDeftectCnt  = 0;
	C5CirDeftectCnt  = 0;
	C6CirDeftectCnt  = 0;
	Btm3CirDefectCnt = 0;

	// Bright Defect 
	A1CirCrackCnt    =0;
	A2CirCrackCnt    =0;
	C1CirCrackCnt    =0;
	C2CirCrackCnt    =0;
	C3CirCrackCnt    =0;
	C4CirCrackCnt    =0;
	C5CirCrackCnt    =0;
	C6CirCrackCnt    =0;
	Btm3CirCrackCnt  =0;

	nCell_Count      = 0;

	// Cell 정보 
	CELL_A =0;
	CELL_B =0;
	CELL_C =0;
	CELL_D =0;
	CELL_E =0;
	CELL_F =0;
	CELL_G =0;
	CELL_H =0;

	LTDx=0.0f, RTDx=0.0f, RBDx=0.0f, LBDx=0.0f;
	LTDy=0.0f, RTDy=0.0f, RBDy=0.0f, LBDy=0.0f;

	// Corner Data OutPoint Init
	C1Point = NULL;
	C2Point = NULL;
	C3Point = NULL;
	C4Point = NULL;

	// Corner Data InPoint Init
	C1InPoint = NULL;
	C2InPoint = NULL;
	C3InPoint = NULL;
	C4InPoint = NULL;

	// Corner Grind Meaasure StandPoint
	C1MeaPoint = NULL;
	C2MeaPoint = NULL;
	C3MeaPoint = NULL;
	C4MeaPoint = NULL;

	// Circle Data InPoint Init
	A1CirInPoint   = NULL;
	A2CirInPoint   = NULL;
// 	A1PolyInPoint  = NULL;

	C1CirInPoint   = NULL;
	C2CirInPoint   = NULL;
	C3CirInPoint   = NULL;
	C4CirInPoint   = NULL;
	C5CirInPoint   = NULL;
	C6CirInPoint   = NULL;

	// Circle Data OutPoint Init
	A1CirOutPoint   = NULL;
	A2CirOutPoint   = NULL;

	C1CirOutPoint   = NULL;
	C2CirOutPoint   = NULL;
	C3CirOutPoint   = NULL;
	C4CirOutPoint   = NULL;
	C5CirOutPoint   = NULL;
	C6CirOutPoint   = NULL;

	// Narrow Trench In/Out Data 
	Btm3InPoint     = NULL;
	Btm3OutPoint    = NULL;

	// 박리 Circle 검사 InPoint Init 
	A1CirInCrackPoint = NULL;
	A2CirInCrackPoint = NULL;

	C1CirInCrackPoint = NULL;
	C2CirInCrackPoint = NULL;
	C3CirInCrackPoint = NULL;
	C4CirInCrackPoint = NULL;
	C5CirInCrackPoint = NULL;
	C6CirInCrackPoint = NULL;

	// Circle Data StandPoint Init 
	C1CirStandPoint = NULL;
	C2CirStandPoint = NULL;
	C3CirStandPoint = NULL;
	C4CirStandPoint = NULL;
	C5CirStandPoint = NULL;
	C6CirStandPoint = NULL;

	// MultiThresHold 
	EThresHold        =0;
	ECThresHold       =0;
	LtpsThresHold     =0;
	EnCapTopThresHold =0;
	EnCapMidThresHold =0;
	EnCapBtmThresHold =0;

	
	//Multi ThresHold값 및 Offset Init
	EBMLinThresHold   =0;
	BurrThresHold     =0;
	BrokenThresHold   =0;
	CrackThresHold    =0;
	GrindThresHold    =0;
	BurrOffset        =0;
	IgnoreOffset      =0;
	GrindOutIn        =0;
	GrindCheck        =0;

	//Cell Inspection 
	LeftEdgeThresHold    =0;
	TopEdgeThresHold     =0;
	RightEdgeThresHold   =0;
	BtmEdgeThresHold     =0;
	CirGrindMeaThresHold =0;
	CorGrindMeaThresHold =0;
	CirGrindInThresHold  =0;
	CorGrindInThresHold  =0;

	// Remain(Burr) Parameter 
	LeftOffset          =0;
	TopOffset           =0;
	RightOffset         =0;
	BtmOffset           =0;

    BurrLeftOffset      =0;
    BurrRightOffset     =0;
    BurrTopOffset       =0;
    BurrBtmOffset       =0;

	LeftBmLineThresHold =0;
	RightBmLineThresHold=0;
	BurrFindThresHold   =0;
	BtmBmLineThresHold  =0;

	// 광원 BM Line을 못찾을경우 필요함 
	BMLineDistance      =0;

	//EdgeInspection
	FChippingMinHeight =0.0f;
	FChippingMinWidth  =0.0f;
	FBrokenMinWidth    =0.0f;
	FBrokenMinHeight   =0.0f;
	FBurrMinHeight     =0.0f;
	FBurrMinWidth      =0.0f;

	//프로그램 실행시 한번 초기화  
	// NOTCH CELL INSPECTION LineData Init
	PreLeftOutLine [0].FP0.x = 0.0f;
	PreLeftOutLine [0].FP0.y = 0.0f;
	PreLeftOutLine [0].FP1.x = 0.0f;
	PreLeftOutLine [0].FP1.y = 0.0f;
	PreLeftInLine  [0].FP0.x = 0.0f;
	PreLeftInLine  [0].FP0.y = 0.0f;
	PreLeftInLine  [0].FP1.x = 0.0f;
	PreLeftInLine  [0].FP1.y = 0.0f;
	PreRightOutLine[0].FP0.x = 0.0f;
	PreRightOutLine[0].FP0.y = 0.0f;
	PreRightOutLine[0].FP1.x = 0.0f;
	PreRightOutLine[0].FP1.y = 0.0f;
	PreRightInLine [0].FP0.x = 0.0f;
	PreRightInLine [0].FP0.y = 0.0f;
	PreRightInLine [0].FP1.x = 0.0f;
	PreRightInLine [0].FP1.y = 0.0f;

	// TrackLine Data Init 
	PreLeftTrackLine [0].FP0.x = 0.0f;
	PreLeftTrackLine [0].FP0.y = 0.0f;
	PreLeftTrackLine [0].FP1.x = 0.0f;
	PreLeftTrackLine [0].FP1.y = 0.0f;

	PreRightTrackLine[0].FP0.x = 0.0f;
	PreRightTrackLine[0].FP0.y = 0.0f;
	PreRightTrackLine[0].FP1.x = 0.0f;
	PreRightTrackLine[0].FP1.y = 0.0f;

	// NOTCH CELL Btm Dis 
// 	BtmLeftDis      = 0.0f;
// 	BtmCenterDis    = 0.0f;
// 	BtmRightDis     = 0.0f;
// 	BtmCenterHeight = 0.0f;
// 	RoundHalfDis    = 0.0f;

	//Notch Circle Dx,Dy 
	ASideCircleWidth    =0.0f;
	ASideCircleHeight   =0.0f;

	CSideCircleWidth    =0.0f;
	CSideCircleHeight   =0.0f;
	CenterCircleWidth   =0.0f;
	CenterCircleHeight  =0.0f;

	Center1CircleWidth  =0.0f;
	Center2CircleWidth  =0.0f;

	// Notch Cell Track Width, Height
	TrackCircleWidth   =0.0f;
	TrackCircleHeight  =0.0f;

	// 외곽라인에서 개별 GrindMark까지 Width,Height 거리
	OutToGrindMarkDis1=0.0f;
	OutToGrindMarkDis2=0.0f;

	// 박리 검출 목적으로 EdgeLine에서 Trap까지 거리 
	dEdgeToTrapLineDis=0.0f;

	// Notch Cell Mark Init 
	dCirOffsetX        =0.0f;
	dCirOffsetY        =0.0f;

	IsBMLineData  = false;

	LogUnit.Create(_T("FAVION"));

	FCompanyMode =0; //Customer    Classify Parameter 
	FInspectMode =0; //InspectMode Classify Parameter

	// Find Dir 
	FindDir  ="";
	MatchDir =""; 

	// Grind Mark Find Score 
	GrindMarkMinScore    =0.0f;
	GrindPadMarkMinScore =0.0f;

	// A_Side AlignMark에서 GrindMark까지 거리 편차값 Init
	AMarkToGrindMarkDvX =0.0f;
	AMarkToGrindMarkDvY =0.0f;

	AMarkToGrindMarkDvX2=0.0f;
	AMarkToGrindMarkDvY2=0.0f;

	for(int k=0; k<9; k++){
		GrindRectSpec[k].DvX =0.0f;
		GrindRectSpec[k].DvX =0.0f;
	}

	OnClearData();
}
CMultiLineDefect::~CMultiLineDefect()
{
	delete SingleLine    ;
	delete RectEdge      ;
	delete Edge          ;
    delete Find1         ;
	delete Find2         ;
	delete Circle        ;
// 	delete Match         ;
	delete Find          ;
	delete CircleFit     ;
// 	delete Cliper        ;
	//delete Trace         ;
	//delete []FDefectPoint;
}

float CMultiLineDefect::GetLengthFrLineToPoint(TFPoint P1, TFPoint P2, TFPoint P3)
{
    //--------------------------------------------------------------------------
    // 직선과 한점의 수직한 교차점에 의한 치수 측정
    // 공식 : ax + by + c = 0, (m, n) -> Distance = (ma + nb +c) / sqrt(a*a + b*b)
    //--------------------------------------------------------------------------
    double xDiff = P2.x-P1.x;
    double yDiff = P2.y-P1.y;

    if      (xDiff == 0) return (float)(fabs(P3.x-P1.x));
    else if (yDiff == 0) return (float)(fabs(P3.y-P1.y));

    float m    = (float)(yDiff/xDiff);
    float dist = (float)(fabs((-m*P3.x + P3.y + m*P1.x - P1.y)/sqrt(m*m + 1)));

    return dist;
}
int CMultiLineDefect::OnExecute(TShape Shape)
{
    FShape = Shape;
    return OnExecute();
}
int CMultiLineDefect::OnExecute()
{
    int Index = 0;
	// 개별 LineEdge 검출전 고객사Cell형태 기준으로 영역별 검사유무 결정해야함   
	// 광원 시퀀스 (외관 검사기)
    if (FShape==shRect8   && FCompanyMode==COM_KWON   ) Index = 0 ;
    if (FShape==shRectH   && FCompanyMode==COM_KWON   ) Index = 1 ;
    if (FShape==shRectC   && FCompanyMode==COM_KWON   ) Index = 2 ;
    if (FShape==shRectS   && FCompanyMode==COM_KWON   ) Index = 3 ;
	// TIANM 시퀀스(Short Cell, Long Cell)
	if (FShape==shRectHL  && FCompanyMode==COM_TIANMA ) Index = 4 ; 
	if (FShape==shRectHR  && FCompanyMode==COM_TIANMA ) Index = 5 ;
	if (FShape==shRectCL  && FCompanyMode==COM_TIANMA ) Index = 6 ;
	if (FShape==shRectCR  && FCompanyMode==COM_TIANMA ) Index = 7 ;
	if (FShape==shRectSL  && FCompanyMode==COM_TIANMA ) Index = 8 ;
	if (FShape==shRectSR  && FCompanyMode==COM_TIANMA ) Index = 9 ;
	if (FShape==shRectTOP && FCompanyMode==COM_TIANMA ) Index = 10;
	if (FShape==shRectBTM && FCompanyMode==COM_TIANMA ) Index = 11;
	// BOE 시퀀스(Cell SIDE_L2, CELL_SIDE_L4)
	if (FShape==shRectHL  && FCompanyMode==COM_BOE    ) Index = 12; //Left 모자검사 
	if (FShape==shRectSL  && FCompanyMode==COM_BOE    ) Index = 13; //Left 젓가락검사 
	if (FShape==shRectCL  && FCompanyMode==COM_BOE    ) Index = 14; //Left 컵검사
	// NOTCH CELL 검사 시퀀스 
	if (FShape==shRectH   && FCompanyMode==COM_NOTCH  ) Index = 15;
	if (FShape==shRectC   && FCompanyMode==COM_NOTCH  ) Index = 16;
	if (FShape==shRectS   && FCompanyMode==COM_NOTCH  ) Index = 3 ;
	// BMDT CELL 검사 시퀀스 
	if (FShape==shRectH   && FCompanyMode==COM_BMDT   ) Index = 17;
	if (FShape==shRectC   && FCompanyMode==COM_BMDT   ) Index = 18;
	if (FShape==shRectS   && FCompanyMode==COM_BMDT   ) Index = 3 ;

	// 기존시퀀스랑 Cell형태가 상이할 경우 Company 추가해야함 
    bool l  = false;
    bool t  = false;
    bool r  = false;
    bool b  = false;
    bool lt = false;
    bool rt = false;
    bool rb = false;
    bool lb = false;

    switch (Index) {

        // Rect8 : 정육각형모양
        //----------------------------------------------------------------------
        case 0 :
            l  = FLeftWall    = true;
            t  = FTopWall     = true;
            r  = FRightWall   = true;
            b  = FBottomWall  = true;
            lt = FLeftTop     = true;
            rt = FRightTop    = true;
            rb = FRightBottom = true;
            lb = FLeftBottom  = true;
            break;

        case 1 :
            // RectH : 모자모양
            //------------------------------------------------------------------
			l  = FLeftWall    = true ;
			t  = FTopWall     = true ;
			r  = FRightWall   = true ;
            b  = FBottomWall  = false;
            lt = FLeftTop     = true ;
            rt = FRightTop    = true ;
            rb = FRightBottom = false;
            lb = FLeftBottom  = false;
            break;

        case 2 :
            // RectC : 컵모양
            //------------------------------------------------------------------
            l  = FLeftWall    = true ;
            t  = FTopWall     = false;
            r  = FRightWall   = true ;
            b  = FBottomWall  = true ;
            lt = FLeftTop     = false;
            rt = FRightTop    = false;
            rb = FRightBottom = true ;
            lb = FLeftBottom  = true ;
            break;

        case 3 :
            // RectS : 젓가락 모양
            //------------------------------------------------------------------
            l  = FLeftWall    = true ;
            t  = FTopWall     = false;
            r  = FRightWall   = true ;
            b  = FBottomWall  = false;
            lt = FLeftTop     = false;
            rt = FRightTop    = false;
            rb = FRightBottom = false;
            lb = FLeftBottom  = false;
            break;

        case 4 :
            // RectHL: 모자모양 왼쪽 
            //------------------------------------------------------------------
            l  = FLeftWall    = true;
            t  = FTopWall     = true;
            r  = FRightWall   = false;
            b  = FBottomWall  = false;
            lt = FLeftTop     = false;
            rt = FRightTop    = false;
            rb = FRightBottom = false;
            lb = FLeftBottom  = false;
            break;

        case 5 :
            // RectHL: 모자모양 오른쪽 
            //------------------------------------------------------------------
            l  = FLeftWall    = false;
            t  = FTopWall     = true ;
            r  = FRightWall   = true ;
            b  = FBottomWall  = false;
            lt = FLeftTop     = false;
            rt = FRightTop    = false;
            rb = FRightBottom = false;
            lb = FLeftBottom  = false;
            break;

        case 6 :
            // RectCL : 컵모양 왼쪽 
            //------------------------------------------------------------------
            l  = FLeftWall    = true ;
            t  = FTopWall     = false;
            r  = FRightWall   = false;
            b  = FBottomWall  = true ;
            lt = FLeftTop     = false;
            rt = FRightTop    = false;
            rb = FRightBottom = false;
            lb = FLeftBottom  = false;
            break;

        case 7 :
            // RectCR : 컵모양 오른쪽 
            //------------------------------------------------------------------
            l  = FLeftWall    = false;
            t  = FTopWall     = false;
            r  = FRightWall   = true ;
            b  = FBottomWall  = true ;
            lt = FLeftTop     = false;
            rt = FRightTop    = false;
            rb = FRightBottom = false;
            lb = FLeftBottom  = false;
            break;

        case 8 :
            // RectSL : 젓가락 왼쪽 
            //------------------------------------------------------------------
            l  = FLeftWall    = true ;
            t  = FTopWall     = false;
            r  = FRightWall   = false;
            b  = FBottomWall  = false;
            lt = FLeftTop     = false;
            rt = FRightTop    = false;
            rb = FRightBottom = false;
            lb = FLeftBottom  = false;
            break;

        case 9 :
            // RectSR : 젓가락 오른쪽
            //------------------------------------------------------------------
            l  = FLeftWall    = false;
            t  = FTopWall     = false;
            r  = FRightWall   = true ;
            b  = FBottomWall  = false;
            lt = FLeftTop     = false;
            rt = FRightTop    = false;
            rb = FRightBottom = false;
            lb = FLeftBottom  = false;
            break;

        case 10 :
            // RectTOP: Cell TOP 검사 
            //------------------------------------------------------------------
            l  = FLeftWall    = false;
            t  = FTopWall     = true ;
            r  = FRightWall   = false;
            b  = FBottomWall  = false;
            lt = FLeftTop     = false;
            rt = FRightTop    = false;
            rb = FRightBottom = false;
            lb = FLeftBottom  = false;
            break;

        case 11 :
            // RectBTM: Cell BTM 검사 
            //------------------------------------------------------------------
            l  = FLeftWall    = false;
            t  = FTopWall     = false;
            r  = FRightWall   = false;
            b  = FBottomWall  = true ;
            lt = FLeftTop     = false;
            rt = FRightTop    = false;
            rb = FRightBottom = false;
            lb = FLeftBottom  = false;
            break;

		case 12 :
			// RectHL  
			//------------------------------------------------------------------
			l  = FLeftWall    = true ;
			t  = FTopWall     = true ;
			r  = FRightWall   = false;
			b  = FBottomWall  = false;
			lt = FLeftTop     = true ;
			rt = FRightTop    = false;
			rb = FRightBottom = false;
			lb = FLeftBottom  = false;
			break;

		case 13 :
			// RectSL
			//------------------------------------------------------------------
			l  = FLeftWall    = true ;
			t  = FTopWall     = false;
			r  = FRightWall   = false;
			b  = FBottomWall  = false;
			lt = FLeftTop     = false;
			rt = FRightTop    = false;
			rb = FRightBottom = false;
			lb = FLeftBottom  = false;
			break;

		case 14 :
			// RectCL
			//------------------------------------------------------------------
			l  = FLeftWall    = true ;
			t  = FTopWall     = false;
			r  = FRightWall   = false;
			b  = FBottomWall  = true ;
			lt = FLeftTop     = false;
			rt = FRightTop    = false;
			rb = FRightBottom = false;
			lb = FLeftBottom  = true ;
			break;

		case 15 :
			// RectH
			//------------------------------------------------------------------
			l  = FLeftWall    = true ;
			t  = FTopWall     = true ;
			r  = FRightWall   = true ;
			b  = FBottomWall  = false;
			lt = FLeftTop     = true ;
			rt = FRightTop    = true ;
			rb = FRightBottom = false;
			lb = FLeftBottom  = false;
			break;

		case 16 :
			// RectC
			//------------------------------------------------------------------
			l  = FLeftWall    = true ;
			t  = FTopWall     = false;
			r  = FRightWall   = true ;
			b  = FBottomWall  = true ;
			lt = FLeftTop     = false;
			rt = FRightTop    = false;
			rb = FRightBottom = false;
			lb = FLeftBottom  = false;
			break;

		case 17 :
			// RectH_BMDT 
			//------------------------------------------------------------------
			l  = FLeftWall    = true ;
			t  = FTopWall     = true ;
			r  = FRightWall   = true ;
			b  = FBottomWall  = false;
			lt = FLeftTop     = true ;
			rt = FRightTop    = true ;
			rb = FRightBottom = false;
			lb = FLeftBottom  = false;
			break;

		case 18 :
			// RectC_BMDT 
			//------------------------------------------------------------------
			l  = FLeftWall    = true ;
			t  = FTopWall     = false;
			r  = FRightWall   = true ;
			b  = FBottomWall  = true ;
			lt = FLeftTop     = false;
			rt = FRightTop    = false;
			rb = FRightBottom = false;
			lb = FLeftBottom  = false;
			break;
    }
    if(!OnExecute(l, t, r, b, lt, rt, rb, lb)) return false;
    return true;
}
/* FAVION ORG 
int CMultiLineDefect::OnManualBevelIn()
{

    int ImgW = GImage->GetWidth();
    int ImgH = GImage->GetHeight();

    int Index = 0;
    if (FShape==shRect8) Index = 0;
    if (FShape==shRectH) Index = 1;
    if (FShape==shRectC) Index = 2;
    if (FShape==shRectS) Index = 3;

    bool l  = false; bool lt = false;
    bool t  = false; bool rt = false;
    bool r  = false; bool rb = false;
    bool b  = false; bool lb = false;


    TFPoint LT(0, 0);
    TFPoint RT(ImgW, 0);
    TFPoint RB(ImgW, ImgH);
    TFPoint LB(0, ImgH);
    TFPoint SP, EP, LSP, LEP, RSP, REP;


    int dx=FEscapeDeviation, dy=FEscapeDeviation;
	LeftDistance=20;
	RightDistance=20;
	
    //double degree1 = Math.GetDegree(FP0.x , FP0.y, FP1.x, FP1.y);
    double degree1 =  -Math.GetDegree(FP1.x, FP1.y, FP0.x , FP0.y);
    double degree2 =   Math.GetDegree(Line[waLeftWall ].FP0.x , Line[waLeftWall ].FP0.y, Line[waLeftWall ].FP1.x, Line[waLeftWall ].FP1.y);
    double degree3 =   Math.GetDegree(Line[waRightWall].FP0.x , Line[waRightWall].FP0.y, Line[waRightWall].FP1.x, Line[waRightWall].FP1.y);
	
    if(FShape==shRectH){
        // Left
        LTLPoint.x = FP0.x-LeftDistance; LTLPoint.y =  Line[waLeftWall].FP0.y+FStartLine;
        LBLPoint.x = FP0.x-LeftDistance; LBLPoint.y =  Line[waLeftWall].FP1.y+FStartLine;
        LBLPoint = Math.OnRotate(LTLPoint, LBLPoint, degree1);

        // Top
        LTTPoint.x =Line[waTopWall].FP0.x; LTTPoint.y = FP0.y-TopDistance;
        RTTPoint.x =Line[waTopWall].FP1.x; RTTPoint.y = FP1.y-TopDistance;
        //RTTPoint =Math.OnRotate(LTTPoint, RTTPoint, degree1);
		
        //Right
        RTRPoint.x = FP1.x+RightDistance; RTRPoint.y = Line[waRightWall].FP0.y+FStartLine;
        RBRPoint.x = FP1.x+RightDistance; RBRPoint.y = Line[waRightWall].FP1.y+FStartLine;
        RBRPoint = Math.OnRotate(RTRPoint, RBRPoint, degree1);

		// Mark-a, Mark+c 의 기준좌표 
		MarkPoint1.x = LTLPoint.x;  MarkPoint1.y = LTLPoint.y;
		MarkPoint2.x = RTRPoint.x;  MarkPoint2.y = RTRPoint.y;

		LTLPoint.y = LTLPoint.y - FStartLine;
		LBLPoint.y = LBLPoint.y - FStartLine;
		RTRPoint.y = RTRPoint.y - FStartLine;
		RBRPoint.y = RBRPoint.y - FStartLine;


        // 실측 외곽라인에서 십자가 까지의 거리 
		//LDistance = Math.GetLengthFrPointToPoint(Line[waLeftWall ].FP0, FP0);
		//RDistance = Math.GetLengthFrPointToPoint(Line[waRightWall].FP0, FP1);
		//TDistance = Math.GetLengthFrPointToPoint(Line[waTopWall  ].FP0, FP0);

		LDistance = abs(FP0.x -Line[waLeftWall ].FP0.x);
		RDistance = abs(Line[waRightWall ].FP0.x - FP1.x);
		TDistance = abs(FP0.y - Line[waTopWall  ].FP0.y);

		FP0.y = FP0.y + FStartLine; FP1.y = FP1.y+FStartLine;

    }
    else if(FShape==shRectS) {
        // Left
        LTLPoint.x = FP0.x-LeftDistance; LTLPoint.y =  Line[waLeftWall].FP0.y+FStartLine;
        LBLPoint.x = FP0.x-LeftDistance; LBLPoint.y =  Line[waLeftWall].FP1.y+FStartLine;

        //Right
        RTRPoint.x = FP1.x+RightDistance; RTRPoint.y = Line[waRightWall].FP0.y+FStartLine;
        RBRPoint.x = FP1.x+RightDistance; RBRPoint.y = Line[waRightWall].FP1.y+FStartLine;

		LTLPoint = Math.OnRotate(MarkPoint1, LTLPoint, degree1);
		LBLPoint = Math.OnRotate(MarkPoint1, LBLPoint, degree1);
		RTRPoint = Math.OnRotate(MarkPoint2, RTRPoint, degree1);
		RBRPoint = Math.OnRotate(MarkPoint2, RBRPoint, degree1);

		LTLPoint.y = LTLPoint.y - FStartLine;
		LBLPoint.y = LBLPoint.y - FStartLine;
		RTRPoint.y = RTRPoint.y - FStartLine;
		RBRPoint.y = RBRPoint.y - FStartLine;

		AlignMark1.x = FP0.x;  AlignMark1.y = Line[waLeftWall ].FP0.y+FStartLine;
		AlignMark2.x = FP1.x;  AlignMark2.y = Line[waRightWall].FP0.y+FStartLine;

		AlignMark1 = Math.OnRotate(FP0, AlignMark1, degree1);
		AlignMark2 = Math.OnRotate(FP1, AlignMark2, degree1);

		//LDistance = Math.GetLengthFrPointToPoint(Line[waLeftWall  ].FP0, AlignMark1);
		//RDistance = Math.GetLengthFrPointToPoint(Line[waRightWall ].FP0, AlignMark2);

		LDistance = abs(AlignMark1.x - Line[waLeftWall  ].FP0.x);
		RDistance = abs(Line[waRightWall ].FP0.x - AlignMark2.x);

	}
	else if(FShape==shRectC){
        LTLPoint.x = FP0.x-LeftDistance; LTLPoint.y =  Line[waLeftWall].FP0.y+FStartLine;
        LBLPoint.x = FP0.x-LeftDistance; LBLPoint.y =  Line[waLeftWall].FP1.y+FStartLine;
		
        //Right
        RTRPoint.x = FP1.x+RightDistance; RTRPoint.y = Line[waRightWall].FP0.y+FStartLine;
        RBRPoint.x = FP1.x+RightDistance; RBRPoint.y = Line[waRightWall].FP1.y+FStartLine;
		
		LTLPoint = Math.OnRotate(MarkPoint1, LTLPoint, degree1);
		LBLPoint = Math.OnRotate(MarkPoint1, LBLPoint, degree1);
		RTRPoint = Math.OnRotate(MarkPoint2, RTRPoint, degree1);
		RBRPoint = Math.OnRotate(MarkPoint2, RBRPoint, degree1);

		LTLPoint.y = LTLPoint.y - FStartLine;
		LBLPoint.y = LBLPoint.y - FStartLine;
		RTRPoint.y = RTRPoint.y - FStartLine;
		RBRPoint.y = RBRPoint.y - FStartLine;
		
		AlignMark1.x = FP0.x;  AlignMark1.y = Line[waLeftWall ].FP0.y+FStartLine;
		AlignMark2.x = FP1.x;  AlignMark2.y = Line[waRightWall].FP0.y+FStartLine;
		
		AlignMark1 = Math.OnRotate(FP0, AlignMark1, degree1);
		AlignMark2 = Math.OnRotate(FP1, AlignMark2, degree1);
		
		//LDistance = Math.GetLengthFrPointToPoint(Line[waLeftWall  ].FP0, AlignMark1);
		//RDistance = Math.GetLengthFrPointToPoint(Line[waRightWall ].FP0, AlignMark2);
		//BDistance = TDistance;

		LDistance = abs(AlignMark1.x - Line[waLeftWall  ].FP0.x);
		RDistance = abs(Line[waRightWall ].FP0.x - AlignMark2.x);
		BDistance = TDistance;


        // BTM
        LBBPoint.x =Line[waBottomWall].FP0.x; LBBPoint.y = Line[waBottomWall].FP0.y;
        RBBPoint.x =Line[waBottomWall].FP1.x; RBBPoint.y = Line[waBottomWall].FP1.y;
    }

	
    PLW0.x = LTLPoint.x+dx;   PLW0.y = LTLPoint.y   ;
    PLW1.x = LBLPoint.x+dx;   PLW1.y = LBLPoint.y   ;
    PTW0.x = LTTPoint.x  ;    PTW0.y = LTTPoint.y+dy;
    PTW1.x = RTTPoint.x  ;    PTW1.y = RTTPoint.y+dy;
    PRW0.x = RTRPoint.x-dx;   PRW0.y = RTRPoint.y   ;
    PRW1.x = RBRPoint.x-dx;   PRW1.y = RBRPoint.y   ;
    PBW0.x = LBBPoint.x   ;   PBW0.y = LBBPoint.y-dy;
    PBW1.x = RBBPoint.x   ;   PBW1.y = RBBPoint.y-dy;
	
    //TFPoint InPLW0(PLW0.x+dx, PLW0.y   );
    //TFPoint InPLW1(PLW1.x+dx, PLW1.y   );
    //TFPoint InPTW0(PTW0.x   , PTW0.y+dy);
    //TFPoint InPTW1(PTW1.x   , PTW1.y+dy);
    //TFPoint InPRW0(PRW0.x-dx, PRW0.y   );
    //TFPoint InPRW1(PRW1.x-dx, PRW1.y   );
    //TFPoint InPBW0(PBW0.x+dx, PBW0.y-dy);
    //TFPoint InPBW1(PBW1.x+dx, PBW1.y-dy);
	
    //InLTPoint.x = FDISTANCE_LT_P0.x+FP0.x+dx; InLTPoint.y = FDISTANCE_LT_P0.y+FP0.y+dy;
    //InRTPoint.x = FDISTANCE_RT_P0.x+FP0.x-dx; InRTPoint.y = FDISTANCE_RT_P0.y+FP0.y+dy;
    //InRBPoint.x = FDISTANCE_RB_P1.x+FP1.x-dx; InRBPoint.y = FDISTANCE_RB_P1.y+FP1.y-dy;
    //InLBPoint.x = FDISTANCE_LB_P1.x+FP1.x+dx; InLBPoint.y = FDISTANCE_LB_P1.y+FP1.y-dy;

    InLTLPoint = Math.OnIntersect(PLW0, PLW1, FLTLPoint, Math.OnRotate(FLTLPoint, FLTTPoint, 90));
    InLTTPoint = Math.OnIntersect(PTW0, PTW1, FLTTPoint, Math.OnRotate(FLTTPoint, FLTLPoint, 90));
    InRTRPoint = Math.OnIntersect(PRW0, PRW1, FRTRPoint, Math.OnRotate(FRTRPoint, FRTTPoint, 90));
    InRTTPoint = Math.OnIntersect(PTW0, PTW1, FRTTPoint, Math.OnRotate(FRTTPoint, FRTRPoint, 90));
    InRBRPoint = Math.OnIntersect(PRW0, PRW1, FRBRPoint, Math.OnRotate(FRBRPoint, FRBBPoint, 90));
    InRBBPoint = Math.OnIntersect(PBW0, PBW1, FRBBPoint, Math.OnRotate(FRBBPoint, FRBRPoint, 90));
    InLBLPoint = Math.OnIntersect(PLW0, PLW1, FLBLPoint, Math.OnRotate(FLBLPoint, FLBBPoint, 90));
    InLBBPoint = Math.OnIntersect(PBW0, PBW1, FLBBPoint, Math.OnRotate(FLBBPoint, FLBLPoint, 90));

    // RectH : 모자모양
    //------------------------------------------------------------------
    if (FShape==shRectH) {
        SP = Math.OnIntersect(PLW0, PLW1, LB, RB);
        EP = Math.OnIntersect(PRW0, PRW1, LB, RB);

		DefectPointCount = 0; // 전체 불량 개수 초기화
		ACount           = 0; // A_SIDE  불량 포인트 개수
		BCount           = 0; // B_SIDE  불량 포인트 개수
		CCount           = 0; // C_SIDE  불량 포인트 개수
		DCount           = 0; // D_SIDE  불량 포인트 개수
		C1Count          = 0; // C1_SIDE 불량 포인트 개수
		C2Count          = 0; // C2_SIDE 불량 포인트 개수
		C3Count          = 0; // C3_SIDE 불량 포인트 개수
		C4Count          = 0; // C4_SIDE 불량 포인트 개수
    }
    // RectC : 컵모양
    //------------------------------------------------------------------
    if (FShape==shRectC) {
        SP = Math.OnIntersect(PLW0, PLW1, LT, RT);
        EP = Math.OnIntersect(PRW0, PRW1, LT, RT);

        //SP.x = SP.x+dx; SP.y = SP.y;
        //EP.x = EP.x-dx; EP.y = EP.y;
    }
    // RectS : 젓가락 모양
    //------------------------------------------------------------------
    if (FShape==shRectS) {
        LSP = Math.OnIntersect(PLW0, PLW1, LT, RT);
        LEP = Math.OnIntersect(PLW0, PLW1, LB, RB);

        //LSP.x = LSP.x+dx; LSP.y = LSP.y;
        //LEP.x = LEP.x-dx; LEP.y = LEP.y;

        RSP = Math.OnIntersect(PRW0, PRW1, LT, RT);
        REP = Math.OnIntersect(PRW0, PRW1, LB, RB);

        //RSP.x = RSP.x+dx; RSP.y = RSP.y;
        //REP.x = REP.x-dx; REP.y = REP.y;
    }


    //FDefectPointCount = 0;

    switch (Index) {

        // Rect8 : 정육각형모양
        //----------------------------------------------------------------------
        case 0 :
            if (Edge->OnExecute(InLBLPoint, InLTLPoint)) for (int k=0; k<Edge->GetResultEdgePointCount(); k++) FDefectPoint[DefectPointCount++] = Edge->GetResultEdgePoint(k);
            if (Edge->OnExecute(InLTLPoint, InLTTPoint)) for (int k=0; k<Edge->GetResultEdgePointCount(); k++) FDefectPoint[DefectPointCount++] = Edge->GetResultEdgePoint(k);
            if (Edge->OnExecute(InLTTPoint, InRTTPoint)) for (int k=0; k<Edge->GetResultEdgePointCount(); k++) FDefectPoint[DefectPointCount++] = Edge->GetResultEdgePoint(k);
            if (Edge->OnExecute(InRTTPoint, InRTRPoint)) for (int k=0; k<Edge->GetResultEdgePointCount(); k++) FDefectPoint[DefectPointCount++] = Edge->GetResultEdgePoint(k);
            if (Edge->OnExecute(InRTRPoint, InRBRPoint)) for (int k=0; k<Edge->GetResultEdgePointCount(); k++) FDefectPoint[DefectPointCount++] = Edge->GetResultEdgePoint(k);
            if (Edge->OnExecute(InRBRPoint, InRBBPoint)) for (int k=0; k<Edge->GetResultEdgePointCount(); k++) FDefectPoint[DefectPointCount++] = Edge->GetResultEdgePoint(k);
            if (Edge->OnExecute(InRBBPoint, InLBBPoint)) for (int k=0; k<Edge->GetResultEdgePointCount(); k++) FDefectPoint[DefectPointCount++] = Edge->GetResultEdgePoint(k);
            if (Edge->OnExecute(InLBBPoint, InLBLPoint)) for (int k=0; k<Edge->GetResultEdgePointCount(); k++) FDefectPoint[DefectPointCount++] = Edge->GetResultEdgePoint(k);

            Index = 0;
            return true;

    // RectC : 모자모양
    //------------------------------------------------------------------
        case 1 :

			if (Edge->OnExecute(SP        , InLTLPoint)) for (int k=0; k<Edge->GetResultEdgePointCount(); k++) DDefectPoint [DCount ++] = Edge->GetResultEdgePoint(k);
			if (Edge->OnExecute(InLTLPoint, InLTTPoint)) for (int k=0; k<Edge->GetResultEdgePointCount(); k++) C1DefectPoint[C1Count++] = Edge->GetResultEdgePoint(k);
			if (Edge->OnExecute(InLTTPoint, InRTTPoint)) for (int k=0; k<Edge->GetResultEdgePointCount(); k++) ADefectPoint [ACount ++] = Edge->GetResultEdgePoint(k);
			if (Edge->OnExecute(InRTTPoint, InRTRPoint)) for (int k=0; k<Edge->GetResultEdgePointCount(); k++) C2DefectPoint[C2Count++] = Edge->GetResultEdgePoint(k);
			if (Edge->OnExecute(InRTRPoint, EP        )) for (int k=0; k<Edge->GetResultEdgePointCount(); k++) BDefectPoint [BCount ++] = Edge->GetResultEdgePoint(k);

            Index = 0;
            return true;

    // RectC : 컵모양
    //------------------------------------------------------------------
        case 2 :

			if (Edge->OnExecute(SP        , InLBLPoint)) for (int k=0; k<Edge->GetResultEdgePointCount(); k++) DDefectPoint [DCount ++] = Edge->GetResultEdgePoint(k);
			if (Edge->OnExecute(InLBLPoint, InLBBPoint)) for (int k=0; k<Edge->GetResultEdgePointCount(); k++) C4DefectPoint[C4Count++] = Edge->GetResultEdgePoint(k);
			if (Edge->OnExecute(InLBBPoint, InRBBPoint)) for (int k=0; k<Edge->GetResultEdgePointCount(); k++) CDefectPoint [CCount ++] = Edge->GetResultEdgePoint(k);
			if (Edge->OnExecute(InRBBPoint, InRBRPoint)) for (int k=0; k<Edge->GetResultEdgePointCount(); k++) C3DefectPoint[C3Count++] = Edge->GetResultEdgePoint(k);
			if (Edge->OnExecute(InRBRPoint, EP        )) for (int k=0; k<Edge->GetResultEdgePointCount(); k++) BDefectPoint [BCount ++] = Edge->GetResultEdgePoint(k);
			
			
			DefectPointCount = ACount+BCount+CCount+DCount+C1Count+C2Count+C3Count+C4Count; // 전체 불량개수 계산


            Index = 0;
            return true;

    // RectC : 젓가락 모양
    //------------------------------------------------------------------
        case 3 :

			if (Edge->OnExecute(LSP, LEP)) for (int k=0; k<Edge->GetResultEdgePointCount(); k++)DDefectPoint[DCount++] = Edge->GetResultEdgePoint(k); 
			if (Edge->OnExecute(RSP, REP)) for (int k=0; k<Edge->GetResultEdgePointCount(); k++)BDefectPoint[BCount++] = Edge->GetResultEdgePoint(k); 

            Index = 0;
            return true;

    }
    return true;
}
*/
int CMultiLineDefect::OnManualBevelIn()
{
	/*

    int ImgW = GImage->GetWidth();
    int ImgH = GImage->GetHeight();

    int Index = 0;
    if (FShape==shRect8) Index = 0;
    if (FShape==shRectH) Index = 1;
    if (FShape==shRectC) Index = 2;
    if (FShape==shRectS) Index = 3;

    bool l  = false; bool lt = false;
    bool t  = false; bool rt = false;
    bool r  = false; bool rb = false;
    bool b  = false; bool lb = false;


    TFPoint LT(0, 0);
    TFPoint RT(ImgW, 0);
    TFPoint RB(ImgW, ImgH);
    TFPoint LB(0, ImgH);
    TFPoint SP, EP, LSP, LEP, RSP, REP;


    int dx=FEscapeDeviation, dy=FEscapeDeviation;
	
    double degree1 =  -Math.GetDegree(FP1.x, FP1.y, FP0.x , FP0.y);
    double degree2 =   Math.GetDegree(Line[waLeftWall ].FP0.x , Line[waLeftWall ].FP0.y, Line[waLeftWall ].FP1.x, Line[waLeftWall ].FP1.y);
    double degree3 =   Math.GetDegree(Line[waRightWall].FP0.x , Line[waRightWall].FP0.y, Line[waRightWall].FP1.x, Line[waRightWall].FP1.y);
	
    if(FShape==shRectH){
        // Left
        LTLPoint.x = FP0.x-LeftDistance; LTLPoint.y =  Line[waLeftWall].FP0.y+FStartLine;
        LBLPoint.x = FP0.x-LeftDistance; LBLPoint.y =  Line[waLeftWall].FP1.y+FStartLine;
        LBLPoint = Math.OnRotate(LTLPoint, LBLPoint, degree1);

        // Top
        LTTPoint.x =Line[waTopWall].FP0.x; LTTPoint.y = FP0.y-TopDistance;
        RTTPoint.x =Line[waTopWall].FP1.x; RTTPoint.y = FP1.y-TopDistance;
        //RTTPoint =Math.OnRotate(LTTPoint, RTTPoint, degree1);
		
        //Right
        RTRPoint.x = FP1.x+RightDistance; RTRPoint.y = Line[waRightWall].FP0.y+FStartLine;
        RBRPoint.x = FP1.x+RightDistance; RBRPoint.y = Line[waRightWall].FP1.y+FStartLine;
        RBRPoint = Math.OnRotate(RTRPoint, RBRPoint, degree1);

		// Mark-a, Mark+c 의 기준좌표 
		MarkPoint1.x = LTLPoint.x;  MarkPoint1.y = LTLPoint.y;
		MarkPoint2.x = RTRPoint.x;  MarkPoint2.y = RTRPoint.y;

		LTLPoint.y = LTLPoint.y - FStartLine;
		LBLPoint.y = LBLPoint.y - FStartLine;
		RTRPoint.y = RTRPoint.y - FStartLine;
		RBRPoint.y = RBRPoint.y - FStartLine;


        // 실측 외곽라인에서 십자가 까지의 거리 
		//LDistance = Math.GetLengthFrPointToPoint(Line[waLeftWall ].FP0, FP0);
		//RDistance = Math.GetLengthFrPointToPoint(Line[waRightWall].FP0, FP1);
		//TDistance = Math.GetLengthFrPointToPoint(Line[waTopWall  ].FP0, FP0);

		LDistance = abs(FP0.x -Line[waLeftWall ].FP0.x);
		RDistance = abs(Line[waRightWall ].FP0.x - FP1.x);
		TDistance = abs(FP0.y - Line[waTopWall  ].FP0.y);

		FP0.y = FP0.y + FStartLine; FP1.y = FP1.y+FStartLine;

    }
    else if(FShape==shRectS) {
        // Left
        LTLPoint.x = FP0.x-LeftDistance; LTLPoint.y =  Line[waLeftWall].FP0.y+FStartLine;
        LBLPoint.x = FP0.x-LeftDistance; LBLPoint.y =  Line[waLeftWall].FP1.y+FStartLine;

        //Right
        RTRPoint.x = FP1.x+RightDistance; RTRPoint.y = Line[waRightWall].FP0.y+FStartLine;
        RBRPoint.x = FP1.x+RightDistance; RBRPoint.y = Line[waRightWall].FP1.y+FStartLine;

		LTLPoint = Math.OnRotate(MarkPoint1, LTLPoint, degree1);
		LBLPoint = Math.OnRotate(MarkPoint1, LBLPoint, degree1);
		RTRPoint = Math.OnRotate(MarkPoint2, RTRPoint, degree1);
		RBRPoint = Math.OnRotate(MarkPoint2, RBRPoint, degree1);

		LTLPoint.y = LTLPoint.y - FStartLine;
		LBLPoint.y = LBLPoint.y - FStartLine;
		RTRPoint.y = RTRPoint.y - FStartLine;
		RBRPoint.y = RBRPoint.y - FStartLine;

		AlignMark1.x = FP0.x;  AlignMark1.y = Line[waLeftWall ].FP0.y+FStartLine;
		AlignMark2.x = FP1.x;  AlignMark2.y = Line[waRightWall].FP0.y+FStartLine;

		AlignMark1 = Math.OnRotate(FP0, AlignMark1, degree1);
		AlignMark2 = Math.OnRotate(FP1, AlignMark2, degree1);

		//LDistance = Math.GetLengthFrPointToPoint(Line[waLeftWall  ].FP0, AlignMark1);
		//RDistance = Math.GetLengthFrPointToPoint(Line[waRightWall ].FP0, AlignMark2);

		LDistance = abs(AlignMark1.x - Line[waLeftWall  ].FP0.x);
		RDistance = abs(Line[waRightWall ].FP0.x - AlignMark2.x);

	}
	else if(FShape==shRectC){
        LTLPoint.x = FP0.x-LeftDistance; LTLPoint.y =  Line[waLeftWall].FP0.y+FStartLine;
        LBLPoint.x = FP0.x-LeftDistance; LBLPoint.y =  Line[waLeftWall].FP1.y+FStartLine;
		
        //Right
        RTRPoint.x = FP1.x+RightDistance; RTRPoint.y = Line[waRightWall].FP0.y+FStartLine;
        RBRPoint.x = FP1.x+RightDistance; RBRPoint.y = Line[waRightWall].FP1.y+FStartLine;
		
		LTLPoint = Math.OnRotate(MarkPoint1, LTLPoint, degree1);
		LBLPoint = Math.OnRotate(MarkPoint1, LBLPoint, degree1);
		RTRPoint = Math.OnRotate(MarkPoint2, RTRPoint, degree1);
		RBRPoint = Math.OnRotate(MarkPoint2, RBRPoint, degree1);

		LTLPoint.y = LTLPoint.y - FStartLine;
		LBLPoint.y = LBLPoint.y - FStartLine;
		RTRPoint.y = RTRPoint.y - FStartLine;
		RBRPoint.y = RBRPoint.y - FStartLine;
		
		AlignMark1.x = FP0.x;  AlignMark1.y = Line[waLeftWall ].FP0.y+FStartLine;
		AlignMark2.x = FP1.x;  AlignMark2.y = Line[waRightWall].FP0.y+FStartLine;
		
		AlignMark1 = Math.OnRotate(FP0, AlignMark1, degree1);
		AlignMark2 = Math.OnRotate(FP1, AlignMark2, degree1);
		
		//LDistance = Math.GetLengthFrPointToPoint(Line[waLeftWall  ].FP0, AlignMark1);
		//RDistance = Math.GetLengthFrPointToPoint(Line[waRightWall ].FP0, AlignMark2);
		//BDistance = TDistance;

		LDistance = abs(AlignMark1.x - Line[waLeftWall  ].FP0.x);
		RDistance = abs(Line[waRightWall ].FP0.x - AlignMark2.x);
		BDistance = TDistance;


        // BTM
        LBBPoint.x =Line[waBottomWall].FP0.x; LBBPoint.y = Line[waBottomWall].FP0.y;
        RBBPoint.x =Line[waBottomWall].FP1.x; RBBPoint.y = Line[waBottomWall].FP1.y;
    }

	
    PLW0.x = LTLPoint.x+dx;   PLW0.y = LTLPoint.y   ;
    PLW1.x = LBLPoint.x+dx;   PLW1.y = LBLPoint.y   ;
    PTW0.x = LTTPoint.x  ;    PTW0.y = LTTPoint.y+dy;
    PTW1.x = RTTPoint.x  ;    PTW1.y = RTTPoint.y+dy;
    PRW0.x = RTRPoint.x-dx;   PRW0.y = RTRPoint.y   ;
    PRW1.x = RBRPoint.x-dx;   PRW1.y = RBRPoint.y   ;
    PBW0.x = LBBPoint.x   ;   PBW0.y = LBBPoint.y-dy;
    PBW1.x = RBBPoint.x   ;   PBW1.y = RBBPoint.y-dy;
	
    //TFPoint InPLW0(PLW0.x+dx, PLW0.y   );
    //TFPoint InPLW1(PLW1.x+dx, PLW1.y   );
    //TFPoint InPTW0(PTW0.x   , PTW0.y+dy);
    //TFPoint InPTW1(PTW1.x   , PTW1.y+dy);
    //TFPoint InPRW0(PRW0.x-dx, PRW0.y   );
    //TFPoint InPRW1(PRW1.x-dx, PRW1.y   );
    //TFPoint InPBW0(PBW0.x+dx, PBW0.y-dy);
    //TFPoint InPBW1(PBW1.x+dx, PBW1.y-dy);
	
    //InLTPoint.x = FDISTANCE_LT_P0.x+FP0.x+dx; InLTPoint.y = FDISTANCE_LT_P0.y+FP0.y+dy;
    //InRTPoint.x = FDISTANCE_RT_P0.x+FP0.x-dx; InRTPoint.y = FDISTANCE_RT_P0.y+FP0.y+dy;
    //InRBPoint.x = FDISTANCE_RB_P1.x+FP1.x-dx; InRBPoint.y = FDISTANCE_RB_P1.y+FP1.y-dy;
    //InLBPoint.x = FDISTANCE_LB_P1.x+FP1.x+dx; InLBPoint.y = FDISTANCE_LB_P1.y+FP1.y-dy;

    InLTLPoint = Math.OnIntersect(PLW0, PLW1, FLTLPoint, Math.OnRotate(FLTLPoint, FLTTPoint, 90));
    InLTTPoint = Math.OnIntersect(PTW0, PTW1, FLTTPoint, Math.OnRotate(FLTTPoint, FLTLPoint, 90));
    InRTRPoint = Math.OnIntersect(PRW0, PRW1, FRTRPoint, Math.OnRotate(FRTRPoint, FRTTPoint, 90));
    InRTTPoint = Math.OnIntersect(PTW0, PTW1, FRTTPoint, Math.OnRotate(FRTTPoint, FRTRPoint, 90));
    InRBRPoint = Math.OnIntersect(PRW0, PRW1, FRBRPoint, Math.OnRotate(FRBRPoint, FRBBPoint, 90));
    InRBBPoint = Math.OnIntersect(PBW0, PBW1, FRBBPoint, Math.OnRotate(FRBBPoint, FRBRPoint, 90));
    InLBLPoint = Math.OnIntersect(PLW0, PLW1, FLBLPoint, Math.OnRotate(FLBLPoint, FLBBPoint, 90));
    InLBBPoint = Math.OnIntersect(PBW0, PBW1, FLBBPoint, Math.OnRotate(FLBBPoint, FLBLPoint, 90));

    // RectH : 모자모양
    //------------------------------------------------------------------
    if (FShape==shRectH) {
        SP = Math.OnIntersect(PLW0, PLW1, LB, RB);
        EP = Math.OnIntersect(PRW0, PRW1, LB, RB);

		DefectPointCount = 0; // 전체 불량 개수 초기화
		ACount           = 0; // A_SIDE  불량 포인트 개수
		BCount           = 0; // B_SIDE  불량 포인트 개수
		CCount           = 0; // C_SIDE  불량 포인트 개수
		DCount           = 0; // D_SIDE  불량 포인트 개수
		C1Count          = 0; // C1_SIDE 불량 포인트 개수
		C2Count          = 0; // C2_SIDE 불량 포인트 개수
		C3Count          = 0; // C3_SIDE 불량 포인트 개수
		C4Count          = 0; // C4_SIDE 불량 포인트 개수
    }
    // RectC : 컵모양
    //------------------------------------------------------------------
    if (FShape==shRectC) {
        SP = Math.OnIntersect(PLW0, PLW1, LT, RT);
        EP = Math.OnIntersect(PRW0, PRW1, LT, RT);

        //SP.x = SP.x+dx; SP.y = SP.y;
        //EP.x = EP.x-dx; EP.y = EP.y;
    }
    // RectS : 젓가락 모양
    //------------------------------------------------------------------
    if (FShape==shRectS) {
        LSP = Math.OnIntersect(PLW0, PLW1, LT, RT);
        LEP = Math.OnIntersect(PLW0, PLW1, LB, RB);

        //LSP.x = LSP.x+dx; LSP.y = LSP.y;
        //LEP.x = LEP.x-dx; LEP.y = LEP.y;

        RSP = Math.OnIntersect(PRW0, PRW1, LT, RT);
        REP = Math.OnIntersect(PRW0, PRW1, LB, RB);

        //RSP.x = RSP.x+dx; RSP.y = RSP.y;
        //REP.x = REP.x-dx; REP.y = REP.y;
    }


    //FDefectPointCount = 0;

    switch (Index) {

        // Rect8 : 정육각형모양
        //----------------------------------------------------------------------
        case 0 :
            if (Edge->OnExecute(InLBLPoint, InLTLPoint)) for (int k=0; k<Edge->GetResultEdgePointCount(); k++) FDefectPoint[DefectPointCount++] = Edge->GetResultEdgePoint(k);
            if (Edge->OnExecute(InLTLPoint, InLTTPoint)) for (int k=0; k<Edge->GetResultEdgePointCount(); k++) FDefectPoint[DefectPointCount++] = Edge->GetResultEdgePoint(k);
            if (Edge->OnExecute(InLTTPoint, InRTTPoint)) for (int k=0; k<Edge->GetResultEdgePointCount(); k++) FDefectPoint[DefectPointCount++] = Edge->GetResultEdgePoint(k);
            if (Edge->OnExecute(InRTTPoint, InRTRPoint)) for (int k=0; k<Edge->GetResultEdgePointCount(); k++) FDefectPoint[DefectPointCount++] = Edge->GetResultEdgePoint(k);
            if (Edge->OnExecute(InRTRPoint, InRBRPoint)) for (int k=0; k<Edge->GetResultEdgePointCount(); k++) FDefectPoint[DefectPointCount++] = Edge->GetResultEdgePoint(k);
            if (Edge->OnExecute(InRBRPoint, InRBBPoint)) for (int k=0; k<Edge->GetResultEdgePointCount(); k++) FDefectPoint[DefectPointCount++] = Edge->GetResultEdgePoint(k);
            if (Edge->OnExecute(InRBBPoint, InLBBPoint)) for (int k=0; k<Edge->GetResultEdgePointCount(); k++) FDefectPoint[DefectPointCount++] = Edge->GetResultEdgePoint(k);
            if (Edge->OnExecute(InLBBPoint, InLBLPoint)) for (int k=0; k<Edge->GetResultEdgePointCount(); k++) FDefectPoint[DefectPointCount++] = Edge->GetResultEdgePoint(k);

            Index = 0;
            return true;

    // RectC : 모자모양
    //------------------------------------------------------------------
        case 1 :

			if (Edge->OnExecute(SP        , InLTLPoint)) for (int k=0; k<Edge->GetResultEdgePointCount(); k++) DDefectPoint [DCount ++] = Edge->GetResultEdgePoint(k);
			if (Edge->OnExecute(InLTLPoint, InLTTPoint)) for (int k=0; k<Edge->GetResultEdgePointCount(); k++) C1DefectPoint[C1Count++] = Edge->GetResultEdgePoint(k);
			if (Edge->OnExecute(InLTTPoint, InRTTPoint)) for (int k=0; k<Edge->GetResultEdgePointCount(); k++) ADefectPoint [ACount ++] = Edge->GetResultEdgePoint(k);
			if (Edge->OnExecute(InRTTPoint, InRTRPoint)) for (int k=0; k<Edge->GetResultEdgePointCount(); k++) C2DefectPoint[C2Count++] = Edge->GetResultEdgePoint(k);
			if (Edge->OnExecute(InRTRPoint, EP        )) for (int k=0; k<Edge->GetResultEdgePointCount(); k++) BDefectPoint [BCount ++] = Edge->GetResultEdgePoint(k);

            Index = 0;
            return true;

    // RectC : 컵모양
    //------------------------------------------------------------------
        case 2 :

			if (Edge->OnExecute(SP        , InLBLPoint)) for (int k=0; k<Edge->GetResultEdgePointCount(); k++) DDefectPoint [DCount ++] = Edge->GetResultEdgePoint(k);
			if (Edge->OnExecute(InLBLPoint, InLBBPoint)) for (int k=0; k<Edge->GetResultEdgePointCount(); k++) C4DefectPoint[C4Count++] = Edge->GetResultEdgePoint(k);
			if (Edge->OnExecute(InLBBPoint, InRBBPoint)) for (int k=0; k<Edge->GetResultEdgePointCount(); k++) CDefectPoint [CCount ++] = Edge->GetResultEdgePoint(k);
			if (Edge->OnExecute(InRBBPoint, InRBRPoint)) for (int k=0; k<Edge->GetResultEdgePointCount(); k++) C3DefectPoint[C3Count++] = Edge->GetResultEdgePoint(k);
			if (Edge->OnExecute(InRBRPoint, EP        )) for (int k=0; k<Edge->GetResultEdgePointCount(); k++) BDefectPoint [BCount ++] = Edge->GetResultEdgePoint(k);
			
			
			DefectPointCount = ACount+BCount+CCount+DCount+C1Count+C2Count+C3Count+C4Count; // 전체 불량개수 계산


            Index = 0;
            return true;

    // RectC : 젓가락 모양
    //------------------------------------------------------------------
        case 3 :

			if (Edge->OnExecute(LSP, LEP)) for (int k=0; k<Edge->GetResultEdgePointCount(); k++)DDefectPoint[DCount++] = Edge->GetResultEdgePoint(k); 
			if (Edge->OnExecute(RSP, REP)) for (int k=0; k<Edge->GetResultEdgePointCount(); k++)BDefectPoint[BCount++] = Edge->GetResultEdgePoint(k); 

            Index = 0;
            return true;

    }
	*/
    return true;
}
/////////////////////////////////////////////////////////////////////////////////////
CRect CMultiLineDefect::OnMerge( CRect ar, CRect br)
{
	CRect r;
	r.left   = (ar.left   < br.left  ) ? ar.left   : br.left  ;
	r.top    = (ar.top    < br.top   ) ? ar.top    : br.top   ;
	r.right  = (ar.right  > br.right ) ? ar.right  : br.right ;
	r.bottom = (ar.bottom > br.bottom) ? ar.bottom : br.bottom;

	return r;
}
/////////////////////////////////////////////////////////////////////////////////////
int CMultiLineDefect::GetSize(TCorner *lpCorner,TBlob *lpDefect, int Count, int Dv)
{
	bool IsRoof  = false;
	bool IsStart = false;
	CRect Rect;
	Rect.left   = 0;
	Rect.right  = 0;
	Rect.top    = 0;
	Rect.bottom = 0;
	int DefectCount=0;
	int DefectPoint=0;
	const double MinDv =2;
	int PixelValue  =0;
	int PixelCount  =0;
	int PixelPoint  =0;
	int PixelScore  =0;
	float Score     =0.0f;

	// Defect Data 존재유무 판단함 
	for(int i=0; i<Count; i++){
		if(lpCorner[i].Dv>Dv){
			IsStart = true;
			break;
		}
	}

	if(IsStart){	
		for (register int k=0; k<Count; k++) {
			if ( lpCorner[k].Dv >1               ) { IsRoof = true; }
			if ( IsRoof && lpCorner[k].Dv <=MinDv) { 
				if(DefectPoint>3){
					lpDefect[DefectCount].Height = (Rect.bottom - Rect.top);
					lpDefect[DefectCount].Width  = (Rect.right - Rect.left);

					// 내부 Pixel Data 축출 
					PixelCount =0; PixelPoint=0; 
					for(int n=Rect.top+1 ; n<Rect.bottom-1; n++){
						for(int m=Rect.left+1; m<Rect.right-1 ; m++){
							PixelValue = IElement(m,n);
							if(PixelValue < ECThresHold) PixelCount++;
							PixelPoint++;
						}
					}
					Score  = (((float)PixelCount/(float)PixelPoint)*100);
					if(Score>10){
						lpDefect[DefectCount].P.x    =  (float)Rect.left;
						lpDefect[DefectCount].P.y    =  (float)(Rect.top +ImageHeight);
						lpDefect[DefectCount].Round  =  PixelCount;
						DefectCount++;
					}
				}
				DefectPoint=0;
				IsRoof = false; 
			}
			
			if (IsRoof) {
				Rect.left   = Rect.left  <lpCorner[k].P.x && Rect.left!=0 ? Rect.left   :(long) lpCorner[k].P.x;
				Rect.top    = Rect.top   <lpCorner[k].P.y && Rect.top !=0 ? Rect.top    :(long) lpCorner[k].P.y;
				Rect.right  = Rect.right >lpCorner[k].P.x                 ? Rect.right  :(long) lpCorner[k].P.x;
				Rect.bottom = Rect.bottom>lpCorner[k].P.y                 ? Rect.bottom :(long) lpCorner[k].P.y;
				DefectPoint++;
			}
			else {
				Rect.left   = 0;
				Rect.top    = 0;
				Rect.right  = 0;
				Rect.bottom = 0;
			}
		
		}
	}
	return DefectCount;
}
int CMultiLineDefect::GetCircleCrackSize(TCircle *lpCircle,TBlob *lpDefect, int Count, int Dis, double CirDiameter, TFPoint Center, bool IsInCircle)
{
	bool IsRoof   = false;
	bool IsStart  = false;
	bool IsFlagCh = true ; 
	CRect Rect;
	Rect.left   = 0;
	Rect.right  = 0;
	Rect.top    = 0;
	Rect.bottom = 0;
	int DefectCount=0;
	int DefectPoint=0;
	// 	const double MinDv =0.5;
	int MinDis = Dis;
	int PixelValue  =0;
	int PixelCount  =0;
	int PixelPoint  =0;
	int PixelScore  =0;
	float Score     =0.0f;

	int DefectWidth  =0;
	int DefectHeight =0;
	double MaxDis    =0.0f;

	TFPoint StaPos(0.0f, 0.0f);
	TFPoint EndPos(0.0f, 0.0f);
	TFPoint MaxPos(0.0f, 0.0f);
	int     MaxCount=0;
	float   PointDis =0.0f;

	// 꽃 박리와 반원형 박리 구별 목적 필요한 변수  
	TFPoint LTPoint(0.0f, 0.0f);
	TFPoint RTPoint(0.0f, 0.0f);
	TFPoint LBPoint(0.0f, 0.0f);
	TFPoint RBPoint(0.0f, 0.0f);
	double CenDisLTPos =0.0f;
	double CenDisRTPos =0.0f;
	double CenDisLBPos =0.0f;
	double CenDisRBPos =0.0f;

	// Defect Data 존재유무 판단g 
	if(Count>5) IsStart = true;

	if(IsStart){	
		for (register int k=0; k<Count; k++) {
			if ( lpCircle[k].P.x!=0.0f && lpCircle[k].P.y!=0.0f && IsFlagCh) {   // 1이상 큰 정수부터 가능함 즉....2부터.....
				IsRoof = true;
				IsFlagCh = false ;
				StaPos.x = lpCircle[k].P.x;
				StaPos.y = lpCircle[k].P.y;
				PointDis =0.0f;
			} 
			if(k>1       ) PointDis = Math.GetLength(lpCircle[k-1].P,lpCircle[k].P);
			if(k==Count-1) PointDis = MinDis+1;

			if (IsRoof && PointDis >MinDis) { 
					// 내부 Pixel Data 축출 
				PixelCount =0, PixelPoint=0, PixelScore=5, Score =0.0f;
				for(int n=Rect.top ; n<Rect.bottom; n++){
					for(int m=Rect.left; m<Rect.right; m++){
						PixelValue = IElement(m,n);
						if(PixelValue > BrokenThresHold) PixelCount++;
						PixelPoint++;
					}
				}
				EndPos.x = lpCircle[k].P.x;
				EndPos.y = lpCircle[k].P.y;

				Score  = (((float)PixelCount/(float)PixelPoint)*100);
				// Circle Defect 내부의 PixelCount 수량을 체크한다 => 오버킬 감소 목적 
				if(Score>PixelScore){
// 						MaxPos.x = lpCircle[MaxCount].P.x;
// 						MaxPos.y = lpCircle[MaxCount].P.y;
					// 꽃 박리와 반원형 박리 구별목적
					LTPoint.x = (float)Rect.left ;  LTPoint.y = (float)Rect.top   ;
					RTPoint.x = (float)Rect.right;  RTPoint.y = (float)Rect.top   ;
					LBPoint.x = (float)Rect.left ;  LBPoint.y = (float)Rect.bottom;
					RBPoint.x = (float)Rect.right;  RBPoint.y = (float)Rect.bottom;

					CenDisLTPos =0.0f;
					CenDisRTPos =0.0f;
					CenDisLBPos =0.0f;
					CenDisRBPos =0.0f;

					// 꽃박리(Peeling) vs 반원형박리(Broken)구별 시퀀스 
					if(CirDiameter!=0.0f){
						if(IsInCircle){ // Cir1, Cir2, Cir5, Cir6
							CenDisLTPos = Math.GetLength(Center,LTPoint);
							CenDisRTPos = Math.GetLength(Center,RTPoint);
							CenDisLBPos = Math.GetLength(Center,LBPoint);						
							CenDisRBPos = Math.GetLength(Center,RBPoint);		
							if(CenDisLTPos>=CirDiameter || CenDisRTPos>=CirDiameter || CenDisLBPos>=CirDiameter || CenDisRBPos>=CirDiameter) lpDefect[DefectCount].LineAttach =1;
						}
						else          {// Cir3, Cir4 
							CenDisLTPos = Math.GetLength(Center,LTPoint);
							CenDisRTPos = Math.GetLength(Center,RTPoint);
							CenDisLBPos = Math.GetLength(Center,LBPoint);						
							CenDisRBPos = Math.GetLength(Center,RBPoint);		
							if(CenDisLTPos<=CirDiameter || CenDisRTPos<=CirDiameter || CenDisLBPos<=CirDiameter || CenDisRBPos<=CirDiameter) lpDefect[DefectCount].LineAttach =1;
						}
					}

					lpDefect[DefectCount].Rect.left    = Rect.left  ;
					lpDefect[DefectCount].Rect.top     = Rect.top   ;
					lpDefect[DefectCount].Rect.right   = Rect.right ; 
					lpDefect[DefectCount].Rect.bottom  = Rect.bottom;

					lpDefect[DefectCount].Height       = (Rect.bottom - Rect.top );
					lpDefect[DefectCount].Width        = (Rect.right  - Rect.left);

// 					lpDefect[DefectCount].Ver_Dis      = lpCircle[MaxCount].Dv        ;
// 					lpDefect[DefectCount].Hor_Dis      = Math.GetLength(StaPos,EndPos);

					lpDefect[DefectCount].Ver_Dis      = lpDefect[DefectCount].Height;
					lpDefect[DefectCount].Hor_Dis      = lpDefect[DefectCount].Width ;

					lpDefect[DefectCount].P.x       =  (float) Rect.left;
					lpDefect[DefectCount].P.y       =  (float)(Rect.top +ImageHeight);

					lpDefect[DefectCount].Rect.top     = lpDefect[DefectCount].P.y;
					lpDefect[DefectCount].Rect.bottom  = lpDefect[DefectCount].Rect.top+lpDefect[DefectCount].Height;
					lpDefect[DefectCount].Round        =  PixelCount;
					DefectCount++;
				}
				DefectPoint=0   ;
				IsRoof   = false; 
				IsFlagCh = true ;
				MaxDis   =0.0f  ;
				MaxCount =0     ; 
			}

			if (IsRoof) { // Bright Point 기준 Rect생성 
// 				if(lpCircle[k].Dv>MaxDis){
// 					MaxDis   = lpCircle[k].Dv;
// 					MaxCount = k             ;
// 				}
				Rect.left   = Rect.left  <lpCircle[k].P.x && Rect.left!=0 ? Rect.left   :(long) lpCircle[k].P.x;
				Rect.top    = Rect.top   <lpCircle[k].P.y && Rect.top !=0 ? Rect.top    :(long) lpCircle[k].P.y;
				Rect.right  = Rect.right >lpCircle[k].P.x                 ? Rect.right  :(long) lpCircle[k].P.x;
				Rect.bottom = Rect.bottom>lpCircle[k].P.y                 ? Rect.bottom :(long) lpCircle[k].P.y;
				DefectPoint++;
			}
			else {
				Rect.left   = 0;
				Rect.top    = 0;
				Rect.right  = 0;
				Rect.bottom = 0;
			}

		}
	}
	return DefectCount;
}
/*
int CMultiLineDefect::GetCircleCrackSize(TCircle *lpCircle,TBlob *lpDefect, int Count, int Dis)
{
	bool IsRoof   = false;
	bool IsStart  = false;
	bool IsFlagCh = true ; 
	CRect Rect;
	Rect.left   = 0;
	Rect.right  = 0;
	Rect.top    = 0;
	Rect.bottom = 0;
	int DefectCount=0;
	int DefectPoint=0;
	// 	const double MinDv =0.5;
	int MinDis = Dis;
	int PixelValue  =0;
	int PixelCount  =0;
	int PixelPoint  =0;
	int PixelScore  =0;
	float Score     =0.0f;

	int DefectWidth  =0;
	int DefectHeight =0;
	double MaxDis    =0.0f;

	TFPoint StaPos(0.0f, 0.0f);
	TFPoint EndPos(0.0f, 0.0f);
	TFPoint MaxPos(0.0f, 0.0f);
	// Line 붙은 불량여부 판단 
	TFPoint LTPoint(0.0f, 0.0f);
	TFPoint RTPoint(0.0f, 0.0f);
	TFPoint LBPoint(0.0f, 0.0f);
	TFPoint RBPoint(0.0f, 0.0f);
	int     MaxCount=0;
	float   PointDis =0.0f;

	// Defect Data 존재유무 판단g 
	if(Count>5) IsStart = true;

	if(IsStart){	
		for (register int k=0; k<Count; k++) {
			if ( lpCircle[k].P.x!=0.0f && lpCircle[k].P.y!=0.0f && IsFlagCh) {   // 1이상 큰 정수부터 가능함 즉....2부터.....
				IsRoof = true;
				IsFlagCh = false ;
				StaPos.x = lpCircle[k].P.x;
				StaPos.y = lpCircle[k].P.y;
				PointDis =0.0f;
			} 
			if(k>1       ) PointDis = Math.GetLength(lpCircle[k-1].P,lpCircle[k].P);
			if(k==Count-1) PointDis = MinDis+1;

			if (IsRoof && PointDis >MinDis) { 
				// 내부 Pixel Data 축출 
				PixelCount =0, PixelPoint=0, PixelScore=5, Score =0.0f;
				for(int n=Rect.top ; n<Rect.bottom; n++){
					for(int m=Rect.left; m<Rect.right; m++){
						PixelValue = IElement(m,n);
						if(PixelValue > BrokenThresHold) PixelCount++;
						PixelPoint++;
					}
				}
				EndPos.x = lpCircle[k].P.x;
				EndPos.y = lpCircle[k].P.y;

				Score  = (((float)PixelCount/(float)PixelPoint)*100);
				// Circle Defect 내부의 PixelCount 수량을 체크한다 => 오버킬 감소 목적 
				if(Score>PixelScore){
					// 						MaxPos.x = lpCircle[MaxCount].P.x;
					// 						MaxPos.y = lpCircle[MaxCount].P.y;

					lpDefect[DefectCount].Rect.left    = Rect.left  ;
					lpDefect[DefectCount].Rect.top     = Rect.top   ;
					lpDefect[DefectCount].Rect.right   = Rect.right ; 
					lpDefect[DefectCount].Rect.bottom  = Rect.bottom;

					lpDefect[DefectCount].Height       = (Rect.bottom - Rect.top );
					lpDefect[DefectCount].Width        = (Rect.right  - Rect.left);

					// 					lpDefect[DefectCount].Ver_Dis      = lpCircle[MaxCount].Dv        ;
					// 					lpDefect[DefectCount].Hor_Dis      = Math.GetLength(StaPos,EndPos);

					lpDefect[DefectCount].Ver_Dis      = lpDefect[DefectCount].Height;
					lpDefect[DefectCount].Hor_Dis      = lpDefect[DefectCount].Width ;

					lpDefect[DefectCount].P.x       =  (float) Rect.left;
					lpDefect[DefectCount].P.y       =  (float)(Rect.top +ImageHeight);

					lpDefect[DefectCount].Rect.top     = lpDefect[DefectCount].P.y;
					lpDefect[DefectCount].Rect.bottom  = lpDefect[DefectCount].Rect.top+lpDefect[DefectCount].Height;
					lpDefect[DefectCount].Round        =  PixelCount;
					DefectCount++;
				}
				DefectPoint=0   ;
				IsRoof   = false; 
				IsFlagCh = true ;
				MaxDis   =0.0f  ;
				MaxCount =0     ; 
			}

			if (IsRoof) {
				// 				if(lpCircle[k].Dv>MaxDis){
				// 					MaxDis   = lpCircle[k].Dv;
				// 					MaxCount = k             ;
				// 				}
				Rect.left   = Rect.left  <lpCircle[k].P.x && Rect.left!=0 ? Rect.left   :(long) lpCircle[k].P.x;
				Rect.top    = Rect.top   <lpCircle[k].P.y && Rect.top !=0 ? Rect.top    :(long) lpCircle[k].P.y;
				Rect.right  = Rect.right >lpCircle[k].P.x                 ? Rect.right  :(long) lpCircle[k].P.x;
				Rect.bottom = Rect.bottom>lpCircle[k].P.y                 ? Rect.bottom :(long) lpCircle[k].P.y;
				DefectPoint++;
			}
			else {
				Rect.left   = 0;
				Rect.top    = 0;
				Rect.right  = 0;
				Rect.bottom = 0;
			}

		}
	}
	return DefectCount;
}
*/
int CMultiLineDefect::GetCircleSize(TCircle *lpCircle,TBlob *lpDefect, int Count, int Dv)
{
	bool IsRoof   = false;
	bool IsStart  = false;
	bool IsFlagCh = true ; 
	CRect Rect;
	Rect.left   = 0;
	Rect.right  = 0;
	Rect.top    = 0;
	Rect.bottom = 0;
	int DefectCount=0;
	int DefectPoint=0;
// 	const double MinDv =0.5;
	const double MinDv =Dv/2;
	int PixelValue  =0;
	int PixelCount  =0;
	int PixelPoint  =0;
	int PixelScore  =0;
	float Score     =0.0f;

	int DefectWidth  =0;
	int DefectHeight =0;
	double MaxDis    =0.0f;
     
	TFPoint StaPos(0.0f, 0.0f);
	TFPoint EndPos(0.0f, 0.0f);
	TFPoint MaxPos(0.0f, 0.0f);
	int     MaxCount=0;

	// Defect Data 존재유무 판단함 
	for(int i=0; i<Count; i++){
		if(lpCircle[i].Dv>Dv){
			IsStart = true;
			break;
		}
	}

	if(IsStart){	
		for (register int k=0; k<Count; k++) {
			if ( lpCircle[k].Dv >1 && IsFlagCh) {   // 1이상 큰 정수부터 가능함 즉....2부터.....
				IsRoof = true;
				IsFlagCh = false ;
				StaPos.x = lpCircle[k].P.x;
				StaPos.y = lpCircle[k].P.y;
		    } 

			if ( IsRoof && lpCircle[k].Dv <=1 && DefectPoint>3) { 
				if(DefectPoint>3){
					// 내부 Pixel Data 축출 
					PixelCount =0, PixelPoint=0, PixelScore=45, Score =0.0f;
					for(int n=Rect.top+1 ; n<Rect.bottom-1; n++){
						for(int m=Rect.left+1; m<Rect.right-1 ; m++){
							PixelValue = IElement(m,n);
							if(PixelValue < EnCapBtmThresHold) PixelCount++;
							PixelPoint++;
						}
					}
					EndPos.x = lpCircle[k].P.x;
					EndPos.y = lpCircle[k].P.y;

					Score  = (((float)PixelCount/(float)PixelPoint)*100);
					// Circle Defect 내부의 PixelCount 수량을 체크한다 => 오버킬 감소 목적 
					if(Score>PixelScore){
						MaxPos.x = lpCircle[MaxCount].P.x;
						MaxPos.y = lpCircle[MaxCount].P.y;

						lpDefect[DefectCount].Rect.left    = Rect.left  ;
						lpDefect[DefectCount].Rect.top     = Rect.top   ;
						lpDefect[DefectCount].Rect.right   = Rect.right ; 
						lpDefect[DefectCount].Rect.bottom  = Rect.bottom;

						lpDefect[DefectCount].Height      = (Rect.bottom - Rect.top );
						lpDefect[DefectCount].Width       = (Rect.right  - Rect.left);

						lpDefect[DefectCount].Ver_Dis      = lpCircle[MaxCount].Dv        ;
						lpDefect[DefectCount].Hor_Dis      = Math.GetLength(StaPos,EndPos);

						lpDefect[DefectCount].P.x       =  (float)Rect.left;
						lpDefect[DefectCount].P.y       =  (float)(Rect.top +ImageHeight);

						lpDefect[DefectCount].Rect.top     = lpDefect[DefectCount].P.y;
						lpDefect[DefectCount].Rect.bottom  = lpDefect[DefectCount].Rect.top+lpDefect[DefectCount].Height;

						lpDefect[DefectCount].Round  =  PixelCount;
						DefectCount++;
					}
				}
				DefectPoint=0   ;
				IsRoof   = false; 
				IsFlagCh = true ;
				MaxDis   =0.0f  ;
				MaxCount =0     ; 
			}

			if (IsRoof) {
				if(lpCircle[k].Dv>MaxDis){
					MaxDis   = lpCircle[k].Dv;
					MaxCount = k             ;
				}
				Rect.left   = Rect.left  <lpCircle[k].P.x && Rect.left!=0 ? Rect.left   :(long) lpCircle[k].P.x;
				Rect.top    = Rect.top   <lpCircle[k].P.y && Rect.top !=0 ? Rect.top    :(long) lpCircle[k].P.y;
				Rect.right  = Rect.right >lpCircle[k].P.x                 ? Rect.right  :(long) lpCircle[k].P.x;
				Rect.bottom = Rect.bottom>lpCircle[k].P.y                 ? Rect.bottom :(long) lpCircle[k].P.y;
				DefectPoint++;

// 				if(DefectPoint>10 && IsFlagCh){
// 					PixelCount =0, PixelPoint=0, PixelScore=15, Score =0.0f;
// 					for(int n=Rect.top ; n<Rect.bottom; n++){
// 						for(int m=Rect.left; m<Rect.right ; m++){
// 							PixelValue = IElement(m,n);
// 							if(PixelValue < EnCapBtmThresHold) PixelCount++;
// 							PixelPoint++;
// 						}
// 					}
// 					Score  = (((float)PixelCount/(float)PixelPoint)*100);
// 					if(Score<PixelScore){
// 						Rect.left   = 0;
// 						Rect.top    = 0;
// 						Rect.right  = 0;
// 						Rect.bottom = 0;
// 						DefectPoint = 0;
// 						IsFlagCh    = true;
// 					}
// 					else IsFlagCh = false;
// 				}
			}
			else {
				Rect.left   = 0;
				Rect.top    = 0;
				Rect.right  = 0;
				Rect.bottom = 0;
			}

		}
	}
	return DefectCount;
}
int CMultiLineDefect::GetPolygonSize(TFPoint *PolygonData, TBlob *lpDefect,int TotalCount,int Range, int DefectDv)
{
	bool IsRoof   = false;
	bool IsBadRect= false;
	CRect Rect;
	Rect.left   = 0;
	Rect.right  = 0;
	Rect.top    = 0;
	Rect.bottom = 0;

	int DefectCount=0;
	int DefectPoint=0;

	// Defect 검출시 내부 Quantity Score Calc 
	int PixelValue   =0;
	int PixelCount   =0;
	int PixelPoint   =0;
	int PixelScore   =0;
	float Score      =0.0f;

	int BadRectCount  =0;

	// Defect Merge Value
	const int MgCount=3 ;
	const int xMerge =10;
	const int yMerge =10;

	// 3개의 기준 Point 좌표 
	TFPoint f1(0.0f,0.0f), f2(0.0f, 0.0f), f3(0.0f,0.0f);

	// Polygon Vlaue 
	TFPoint *RangePoint     =NULL;
	float Dv1 =0.0f, Dv2=0.0F, Dv3=0.0f;

	//BadRect Init 
	for(int k=0; k<MAX_POLYGON_DEFECT_COUNT; k++){
		// Polygon Defect Data 
		BadRect[k].Rect.left          =0   ;
		BadRect[k].Rect.top           =0   ;
		BadRect[k].Rect.right         =0   ;
		BadRect[k].Rect.bottom        =0   ;
		BadRect[k].SPoint.x           =0.0f;
		BadRect[k].SPoint.y           =0.0f;
		BadRect[k].EPoint.x           =0.0f;
		BadRect[k].EPoint.y           =0.0f;
		BadRect[k].BadPixelCount      =0   ;

		for(int i=0; i<MAX_POLYGON_DEFECT_POINT; i++){
			BadRect[k].Pixel[i].x =0.0f;
			BadRect[k].Pixel[i].y =0.0f;
		}
	}
	
	// Range범위만큼 Polygon Data Point 분활하여 Defect 유무 Calc
 	for(int k=0; k<TotalCount; k+=Range){
        TFPoint *Q1 = &PolygonData[k];
		int v = (TotalCount-k)/Range;  // Range범위만큼 분활시 나머지 값
		int r = TotalCount%Range    ;  // 전체 픽셀을 Range범위보다 분활시 Range범위보다 작은범위가 남을경우 
		int n = (v>=1)? Range: r    ;  // 전체 픽셀을 Range범위보다 분활시 Range범위보다 작은범위가 남을경우 

		if(v<0) break;

		// Range 범위만큼 분활하여 동적 생성한다 
		if(RangePoint!=NULL) delete [] RangePoint;
		RangePoint = new TFPoint[n];

		// Range범위에서 실제 Polygon Pos 좌표 및 BadPixel Pos좌표 Init 
		for(int z=0; z<n; z++){
			RangePoint[z].x    = Q1[z].x;
			RangePoint[z].y    = Q1[z].y;
		}

		// Find Defct Pixel 
		f1 = RangePoint[0         ]; //Range범위에서 첫번째 Point 좌표
		f2 = RangePoint[(int)(n/2)]; //Range범위에서 가운데 Point 좌표
		f3 = RangePoint[n-1       ]; //Range범위에서 마지막 Point 좌표

		// Rect Data Init 
		Rect.left   =0;
		Rect.top    =0;
		Rect.right  =0;
		Rect.bottom =0;

		IsBadRect  = false;
		PixelCount =0     ;
		for(int i=0; i<n; i++){ // Range영역에서 3개 Point기준 BadRect,BadPixel 정보를 취합한다 
			Dv1 = GetLengthFrLineToPoint(f1, f3, RangePoint[i]);
			Dv2 = GetLengthFrLineToPoint(f1, f2, RangePoint[i]);
			Dv3 = GetLengthFrLineToPoint(f2, f3, RangePoint[i]);

			if(Dv1>DefectDv || Dv2>DefectDv || Dv3>DefectDv){ // Defect Point 존재할경우 
				if(!IsBadRect){ // Defect Point StaPos Data 취합 목적
					IsBadRect = true;
					BadRect[BadRectCount].SPoint.x  = RangePoint[i].x;
					BadRect[BadRectCount].SPoint.y  = RangePoint[i].y;
				}

				if(IsBadRect){
					Rect.left   = Rect.left  <RangePoint[i].x && Rect.left!=0 ? Rect.left   :(long) RangePoint[i].x;
					Rect.top    = Rect.top   <RangePoint[i].y && Rect.top !=0 ? Rect.top    :(long) RangePoint[i].y;
					Rect.right  = Rect.right >RangePoint[i].x                 ? Rect.right  :(long) RangePoint[i].x;
					Rect.bottom = Rect.bottom>RangePoint[i].y                 ? Rect.bottom :(long) RangePoint[i].y;

					BadRect[BadRectCount].Pixel[BadRect[BadRectCount].BadPixelCount] = RangePoint[i]  ;
					BadRect[BadRectCount].EPoint.x                                   = RangePoint[i].x; // End Pos 정보 업데이트 
					BadRect[BadRectCount].EPoint.y                                   = RangePoint[i].y; // End Pos 정보 업데이트 
					BadRect[BadRectCount].BadPixelCount++                                             ;
				}
			}
		}

		if(IsBadRect){
			BadRect[BadRectCount].Rect = Rect;

			float Distance=0.0f;

			if(BadRectCount>0){ // 두번째 BadRect부터 이전 BadRect외 비교하여 거리값 측정 
				Distance = Math.GetLength(BadRect[BadRectCount].SPoint, BadRect[BadRectCount-1].EPoint);
			}

			// 현재 BadRect기준 일정거리 이하이면 이전BadRect데이터와 Merge한다 
			if(((Rect.right - Rect.left)>2) && ((Rect.bottom- Rect.top)>2) && Distance && (Distance<20)){
				BadRect[BadRectCount-1].Rect.left   = BadRect[BadRectCount-1].Rect.left  <Rect.left   ? BadRect[BadRectCount-1].Rect.left   : Rect.left  ;
				BadRect[BadRectCount-1].Rect.top    = BadRect[BadRectCount-1].Rect.top   <Rect.top    ? BadRect[BadRectCount-1].Rect.top    : Rect.top   ;
				BadRect[BadRectCount-1].Rect.right  = BadRect[BadRectCount-1].Rect.right >Rect.right  ? BadRect[BadRectCount-1].Rect.right  : Rect.right ;
				BadRect[BadRectCount-1].Rect.bottom = BadRect[BadRectCount-1].Rect.bottom>Rect.bottom ? BadRect[BadRectCount-1].Rect.bottom : Rect.bottom;

	            BadRect[BadRectCount-1].EPoint = BadRect[BadRectCount].EPoint;

				for(int b=0; b<BadRect[BadRectCount].BadPixelCount; b++){ // 현재 BadPixelData값을 이전 BadRect에 넘겨준다 
					BadRect[BadRectCount-1].Pixel[BadRect[BadRectCount-1].BadPixelCount] = BadRect[BadRectCount].Pixel[b];
                    BadRect[BadRectCount-1].BadPixelCount++;

					// 현재 Data Init 
					BadRect[BadRectCount].Pixel[b].x =0;
					BadRect[BadRectCount].Pixel[b].y =0;
				}
				BadRect[BadRectCount].BadPixelCount =0;
				BadRect[BadRectCount].EPoint.x      =0;
				BadRect[BadRectCount].EPoint.y      =0;
				BadRect[BadRectCount].SPoint.x      =0;
				BadRect[BadRectCount].SPoint.y      =0;
			}
			else  BadRectCount++;
		}
	}

	// Range 범위만큼 분활하여 동적 생성한다 
	// Range 범위기준 마지막 데이터 삭제 
	if(RangePoint!=NULL) delete [] RangePoint;

	// BadRect Data 기준 1차 필터링 및 실제 lpDefect에 데이터 넘겨줌
    if(BadRectCount>0){
		TFPoint Target(0.0f,0.0f);

		for(int k=0; k<BadRectCount; k++){
			IsRoof = false;
			for(int i=0; i<BadRect[k].BadPixelCount; i++){
				f1     = BadRect[k].SPoint  ; // BadRect 시작점 좌표
				f2     = BadRect[k].EPoint  ; // BadRect 종료점 좌표 
				Target = BadRect[k].Pixel[i]; // BddRect 리얼   좌표 
				Dv1    = GetLengthFrLineToPoint(f1, f2, Target);

				if(Dv1>3){
					if(!IsRoof){ // Defect Point StaPos Data 취합 목적
						IsRoof = true;
					}

					if(IsRoof){
						Rect.left   = Rect.left  <Target.x && Rect.left!=0 ? Rect.left   :(long) Target.x;
						Rect.top    = Rect.top   <Target.y && Rect.top !=0 ? Rect.top    :(long) Target.y;
						Rect.right  = Rect.right >Target.x                 ? Rect.right  :(long) Target.x;
						Rect.bottom = Rect.bottom>Target.y                 ? Rect.bottom :(long) Target.y;
						DefectPoint++;
					}
				}
				else                                            { // Defect Point 없을경우 
					if(IsRoof){
						if(DefectPoint>10){
							// 내부 Pixel Data 축출 
							PixelCount =0, PixelPoint=0, PixelScore=5, Score =0.0f;
							for(int n=Rect.top ; n<Rect.bottom; n++){
								for(int m=Rect.left; m<Rect.right; m++){
									PixelValue = IElement(m,n);
									if(PixelValue < EnCapBtmThresHold) PixelCount++;
									PixelPoint++;
								}
							}
							Score  = (((float)PixelCount/(float)PixelPoint)*100);
							// Circle Defect 내부의 PixelCount 수량을 체크한다 => 오버킬 감소 목적 
							if(Score>PixelScore){
								lpDefect[DefectCount].Rect.left    = Rect.left  ;
								lpDefect[DefectCount].Rect.top     = Rect.top   ;
								lpDefect[DefectCount].Rect.right   = Rect.right ; 
								lpDefect[DefectCount].Rect.bottom  = Rect.bottom;

								lpDefect[DefectCount].Height       = (Rect.bottom - Rect.top );
								lpDefect[DefectCount].Width        = (Rect.right  - Rect.left);

								lpDefect[DefectCount].Ver_Dis      = lpDefect[DefectCount].Height;
								lpDefect[DefectCount].Hor_Dis      = lpDefect[DefectCount].Width ;

								lpDefect[DefectCount].P.x          =  (float)(Rect.left            );
								lpDefect[DefectCount].P.y          =  (float)(Rect.top +ImageHeight); // 전체 Frame기준 Real좌표 기준으로 변환 

								lpDefect[DefectCount].Rect.top     = lpDefect[DefectCount].P.y;
								lpDefect[DefectCount].Rect.bottom  = lpDefect[DefectCount].Rect.top+lpDefect[DefectCount].Height;
								lpDefect[DefectCount].Round        =  PixelCount;
								DefectCount++;

								// Data Init 
								DefectPoint = 0;
								Rect.left   = 0;
								Rect.top    = 0;
								Rect.right  = 0;
								Rect.bottom = 0;
								IsRoof      = false; 
							}
							else {
								DefectPoint = 0;
								Rect.left   = 0;
								Rect.top    = 0;
								Rect.right  = 0;
								Rect.bottom = 0;
								IsRoof      = false; 
							}
						}
						else { // Defect Count 작을경우 초기화 
							DefectPoint = 0;
							Rect.left   = 0;
							Rect.top    = 0;
							Rect.right  = 0;
							Rect.bottom = 0;
							IsRoof      = false; 
						}
					}
					else      { // 최소 Defect Distance 작을경우 
						Rect.left   = 0;
						Rect.top    = 0;
						Rect.right  = 0;
						Rect.bottom = 0;
					}
				}
			}
		}
	}

	// Defect Data기준 Merge 진행함 
	if(DefectCount>1){ // Defect정보가 최소 2개이상 존재할경우 Merge 시퀀스 진행함
		bool IsxMg=false, IsyMg=false, IsInMg=false;
		CRect r1, r2;
		int sort =0;
		int tmpDDefectCount = DefectCount;

		for(int k=0; k<tmpDDefectCount; k++){
			if(lpDefect[k].Rect.left==0 && lpDefect[k].Rect.top==0 && lpDefect[k].Rect.right==0 && lpDefect[k].Rect.bottom==0) continue;

			for(int l=k+1; l<k+MgCount; l++ ){
				IsxMg = false; IsyMg = false;
				if(l>(tmpDDefectCount-1)) break;
				if(lpDefect[l].Rect.left==0 && lpDefect[l].Rect.top==0 && lpDefect[k].Rect.right==0 && lpDefect[k].Rect.bottom==0) continue;

				r1 = lpDefect[k].Rect;
				r2 = lpDefect[l].Rect; 

				register int HorDist   = abs((r1.left < r2.left) ?  r2.left - r1.right  : r1.left - r2.right );
				register int VerDist   = abs((r1.top  < r2.top ) ?  r2.top  - r1.bottom : r1.top  - r2.bottom);
				IsInMg    = ((r1.left<=r2.left) && (r1.top<r2.top) && (r1.bottom>r2.bottom) && (r1.right >r2.right))? true: false;

				if(HorDist>xMerge && VerDist>yMerge && !IsInMg ) continue;

				IsxMg = (HorDist<xMerge) ? true: false;
				IsyMg = (VerDist<yMerge) ? true: false;

				if((IsxMg && IsyMg) || IsInMg){
					lpDefect[k].Round    += lpDefect[l].Round;
					lpDefect[k].Rect      = OnMerge(lpDefect[k].Rect, lpDefect[l].Rect);
					lpDefect[k].Width     = lpDefect[k].Rect.right  - lpDefect[k].Rect.left;
					lpDefect[k].Height    = lpDefect[k].Rect.bottom - lpDefect[k].Rect.top ;
					lpDefect[k].Hor_Dis   = lpDefect[k].Width ; 
					lpDefect[k].Ver_Dis   = lpDefect[k].Height;
					lpDefect[k].P.x       = (float)(lpDefect[k].Rect.left);
					lpDefect[k].P.y       = (float)(lpDefect[k].Rect.top ); 
					lpDefect[l].Rect.left = lpDefect[l].Rect.top = lpDefect[l].Rect.right = lpDefect[l].Rect.bottom =0;
					DefectCount--;
					k=-1;
					break;
				}
			}
		}
		for(int j=0; j<tmpDDefectCount; j++){
			if(lpDefect[j].Rect.left==0 && lpDefect[j].Rect.top==0 && lpDefect[j].Rect.right==0 && lpDefect[j].Rect.bottom==0) continue;
			lpDefect[sort] = lpDefect[j];
			sort++;
		}
	}
	return DefectCount;
}
/* Org Source 
int CMultiLineDefect::GetPolygonSize(TFPoint *PolygonData, TBlob *lpDefect,int TotalCount,int Range, int DefectDv)
{
	bool IsRoof   = false;
	CRect Rect;
	Rect.left   = 0;
	Rect.right  = 0;
	Rect.top    = 0;
	Rect.bottom = 0;

	int DefectCount=0;
	int DefectPoint=0;

	// Defect 검출시 내부 Quantity Score Calc 
	int PixelValue   =0;
	int PixelCount   =0;
	int PixelPoint   =0;
	int PixelScore   =0;
	float Score      =0.0f;

	// Defect Merge Value
	const int MgCount=3 ;
	const int xMerge =10;
	const int yMerge =10;

	TFPoint StaPos(0.0f, 0.0f);
	TFPoint EndPos(0.0f, 0.0f);

	// Polygon Vlaue 
	TFPoint *RangePoint=NULL;
	float Dv1 =0.0f, Dv2=0.0F, Dv3=0.0f;

	// Range범위만큼 Polygon Data Point 분활하여 Defect 유무 Calc
	for(int k=0; k<TotalCount; k+=Range){
		TFPoint *Q1 = &PolygonData[k];
		int v = (TotalCount-k)/Range;  // Range범위만큼 분활시 나머지 값
		int r = TotalCount%Range    ;  // 전체 픽셀을 Range범위보다 분활시 Range범위보다 작은범위가 남을경우 
		int n = (v>=1)? Range: r    ;  // 전체 픽셀을 Range범위보다 분활시 Range범위보다 작은범위가 남을경우 

		if(v<0) break;

		// Range 범위만큼 분활하여 동적 생성한다 
		if(RangePoint!=NULL) delete [] RangePoint;
		RangePoint = new TFPoint[n];

		// Range범위에서 실제 Polygon Pos 좌표 
		for(int z=0; z<n; z++){
			RangePoint[z].x = Q1[z].x;
			RangePoint[z].y = Q1[z].y;
		}

		// Find Defct Pixel 
		TFPoint f1 = RangePoint[0         ]; //Range범위에서 첫번째 Point 좌표
		TFPoint f2 = RangePoint[(int)(n/2)]; //Range범위에서 가운데 Point 좌표
		TFPoint f3 = RangePoint[n-1       ]; //Range범위에서 마지막 Point 좌표

		IsRoof = false;
		for(int i=0; i<n; i++){
			Dv1 = GetLengthFrLineToPoint(f1, f3, RangePoint[i]);
			Dv2 = GetLengthFrLineToPoint(f1, f2, RangePoint[i]);
			Dv3 = GetLengthFrLineToPoint(f2, f3, RangePoint[i]);

			if(Dv1>DefectDv || Dv2>DefectDv || Dv3>DefectDv){ // Defect Point 존재할경우 
				if(!IsRoof){ // Defect Point StaPos Data 취합 목적
					IsRoof = true;
					StaPos.x = RangePoint[i].x;
					StaPos.y = RangePoint[i].y;
				}

				if(IsRoof){
					Rect.left   = Rect.left  <RangePoint[i].x && Rect.left!=0 ? Rect.left   :(long) RangePoint[i].x;
					Rect.top    = Rect.top   <RangePoint[i].y && Rect.top !=0 ? Rect.top    :(long) RangePoint[i].y;
					Rect.right  = Rect.right >RangePoint[i].x                 ? Rect.right  :(long) RangePoint[i].x;
					Rect.bottom = Rect.bottom>RangePoint[i].y                 ? Rect.bottom :(long) RangePoint[i].y;
					DefectPoint++;
				}
			}
			else                                            { // Defect Point 없을경우 
				if(IsRoof){
					if(DefectPoint>10){
						// 내부 Pixel Data 축출 
						PixelCount =0, PixelPoint=0, PixelScore=10, Score =0.0f;
						// 						for(int n=Rect.top+1 ; n<Rect.bottom-1; n++){
						// 							for(int m=Rect.left+1; m<Rect.right-1 ; m++){
						for(int n=Rect.top ; n<Rect.bottom; n++){
							for(int m=Rect.left; m<Rect.right; m++){
								PixelValue = IElement(m,n);
								if(PixelValue < EnCapBtmThresHold) PixelCount++;
								PixelPoint++;
							}
						}
						EndPos.x = RangePoint[i].x;
						EndPos.y = RangePoint[i].y;

						Score  = (((float)PixelCount/(float)PixelPoint)*100);
						// Circle Defect 내부의 PixelCount 수량을 체크한다 => 오버킬 감소 목적 
						if(Score>PixelScore){
							lpDefect[DefectCount].Rect.left    = Rect.left  ;
							lpDefect[DefectCount].Rect.top     = Rect.top   ;
							lpDefect[DefectCount].Rect.right   = Rect.right ; 
							lpDefect[DefectCount].Rect.bottom  = Rect.bottom;

							lpDefect[DefectCount].Height      = (Rect.bottom - Rect.top );
							lpDefect[DefectCount].Width       = (Rect.right  - Rect.left);

							// 							lpDefect[DefectCount].Ver_Dis      = lpCircle[MaxCount].Dv        ;
							// 							lpDefect[DefectCount].Hor_Dis      = Math.GetLength(StaPos,EndPos);

							lpDefect[DefectCount].P.x       =  (float)(Rect.left            );
							lpDefect[DefectCount].P.y       =  (float)(Rect.top +ImageHeight); // 전체 Frame기준 Real좌표 기준으로 변환 

							lpDefect[DefectCount].Rect.top     = lpDefect[DefectCount].P.y;
							lpDefect[DefectCount].Rect.bottom  = lpDefect[DefectCount].Rect.top+lpDefect[DefectCount].Height;
							lpDefect[DefectCount].Round        =  PixelCount;
							DefectCount++;
							DefectPoint = 0;
							Rect.left   = 0;
							Rect.top    = 0;
							Rect.right  = 0;
							Rect.bottom = 0;
							IsRoof      = false; 
						}
						else {
							DefectPoint = 0;
							Rect.left   = 0;
							Rect.top    = 0;
							Rect.right  = 0;
							Rect.bottom = 0;
							IsRoof      = false; 
						}
					}
					else { // Defect Count 작을경우 초기화 
						DefectPoint = 0;
						Rect.left   = 0;
						Rect.top    = 0;
						Rect.right  = 0;
						Rect.bottom = 0;
						IsRoof      = false; 
					}
				}
				else      { // 최소 Defect Distance 작을경우 
					Rect.left   = 0;
					Rect.top    = 0;
					Rect.right  = 0;
					Rect.bottom = 0;
				}
			}

			// Range범위에서 마지막 EdgePoint까지 Roof종료가 되자않을경우(Range범위를 벗어나는 큰불량)
			if((i==(n-1)) && IsRoof && DefectPoint>10){
				// 내부 Pixel Data 축출 
				PixelCount =0, PixelPoint=0, PixelScore=10, Score =0.0f;
				// 						for(int n=Rect.top+1 ; n<Rect.bottom-1; n++){
				// 							for(int m=Rect.left+1; m<Rect.right-1 ; m++){
				for(int n=Rect.top ; n<Rect.bottom; n++){
					for(int m=Rect.left; m<Rect.right; m++){
						PixelValue = IElement(m,n);
						if(PixelValue < EnCapBtmThresHold) PixelCount++;
						PixelPoint++;
					}
				}
				EndPos.x = RangePoint[i].x;
				EndPos.y = RangePoint[i].y;

				Score  = (((float)PixelCount/(float)PixelPoint)*100);
				// Circle Defect 내부의 PixelCount 수량을 체크한다 => 오버킬 감소 목적 
				if(Score>PixelScore){
					lpDefect[DefectCount].Rect.left    = Rect.left  ;
					lpDefect[DefectCount].Rect.top     = Rect.top   ;
					lpDefect[DefectCount].Rect.right   = Rect.right ; 
					lpDefect[DefectCount].Rect.bottom  = Rect.bottom;

					lpDefect[DefectCount].Height      = (Rect.bottom - Rect.top );
					lpDefect[DefectCount].Width       = (Rect.right  - Rect.left);

					// 							lpDefect[DefectCount].Ver_Dis      = lpCircle[MaxCount].Dv        ;
					// 							lpDefect[DefectCount].Hor_Dis      = Math.GetLength(StaPos,EndPos);

					lpDefect[DefectCount].P.x       =  (float)(Rect.left            );
					lpDefect[DefectCount].P.y       =  (float)(Rect.top +ImageHeight); // 전체 Frame기준 Real좌표 기준으로 변환 

					lpDefect[DefectCount].Rect.top     = lpDefect[DefectCount].P.y;
					lpDefect[DefectCount].Rect.bottom  = lpDefect[DefectCount].Rect.top+lpDefect[DefectCount].Height;
					lpDefect[DefectCount].Round        =  PixelCount;
					DefectCount++;
					DefectPoint = 0;
					Rect.left   = 0;
					Rect.top    = 0;
					Rect.right  = 0;
					Rect.bottom = 0;
					IsRoof      = false; 
				}
				else {
					DefectPoint = 0;
					Rect.left   = 0;
					Rect.top    = 0;
					Rect.right  = 0;
					Rect.bottom = 0;
					IsRoof      = false; 
				}
			}
		}
	}

	// Defect Data기준 Merge 진행함 
	if(DefectCount>1){ // Defect정보가 최소 2개이상 존재할경우 Merge 시퀀스 진행함
		bool IsxMg=false, IsyMg=false, IsInMg=false;
		CRect r1, r2;
		int sort =0;
		int tmpDDefectCount = DefectCount;

		for(int k=0; k<tmpDDefectCount; k++){
			if(lpDefect[k].Rect.left==0 && lpDefect[k].Rect.top==0 && lpDefect[k].Rect.right==0 && lpDefect[k].Rect.bottom==0) continue;

			for(int l=k+1; l<k+MgCount; l++ ){
				IsxMg = false; IsyMg = false;
				if(l>(tmpDDefectCount-1)) break;
				if(lpDefect[l].Rect.left==0 && lpDefect[l].Rect.top==0 && lpDefect[k].Rect.right==0 && lpDefect[k].Rect.bottom==0) continue;

				r1 = lpDefect[k].Rect;
				r2 = lpDefect[l].Rect; 

				register int HorDist   = abs((r1.left < r2.left) ?  r2.left - r1.right  : r1.left - r2.right );
				register int VerDist   = abs((r1.top  < r2.top ) ?  r2.top  - r1.bottom : r1.top  - r2.bottom);
				IsInMg    = ((r1.left<=r2.left) && (r1.top<r2.top) && (r1.bottom>r2.bottom) && (r1.right >r2.right))? true: false;

				if(HorDist>xMerge && VerDist>yMerge && !IsInMg ) continue;

				IsxMg = (HorDist<xMerge) ? true: false;
				IsyMg = (VerDist<yMerge) ? true: false;

				if((IsxMg && IsyMg) || IsInMg){
					lpDefect[k].Round    += lpDefect[l].Round;
					lpDefect[k].Rect      = OnMerge(lpDefect[k].Rect, lpDefect[l].Rect);
					lpDefect[k].Width     = lpDefect[k].Rect.right  - lpDefect[k].Rect.left;
					lpDefect[k].Height    = lpDefect[k].Rect.bottom - lpDefect[k].Rect.top ;
					lpDefect[k].Hor_Dis   = lpDefect[k].Width ; 
					lpDefect[k].Ver_Dis   = lpDefect[k].Height;
					lpDefect[k].P.x       = (float)(lpDefect[k].Rect.left);
					lpDefect[k].P.y       = (float)(lpDefect[k].Rect.top ); 
					lpDefect[l].Rect.left = lpDefect[l].Rect.top = lpDefect[l].Rect.right = lpDefect[l].Rect.bottom =0;
					DefectCount--;
					k=-1;
					break;
				}
			}
		}
		for(int j=0; j<tmpDDefectCount; j++){
			if(lpDefect[j].Rect.left==0 && lpDefect[j].Rect.top==0 && lpDefect[j].Rect.right==0 && lpDefect[j].Rect.bottom==0) continue;
			lpDefect[sort] = lpDefect[j];
			sort++;
		}
	}

	return DefectCount;
}
*/
// int CMultiLineDefect::GetCircleSize(TCircle *lpCircle,TBlob *lpDefect, int Count, int Dv)
// {
// 	bool IsRoof  = false;
// 	bool IsStart = false;
// 	CRect Rect;
// 	Rect.left   = 0;
// 	Rect.right  = 0;
// 	Rect.top    = 0;
// 	Rect.bottom = 0;
// 	int DefectCount=0;
// 	int DefectPoint=0;
// 	// 	const double MinDv =0.5;
// 	const double MinDv =Dv/2;
// 	int PixelValue  =0;
// 	int PixelCount  =0;
// 	int PixelPoint  =0;
// 	int PixelScore  =0;
// 	float Score     =0.0f;
// 
// 	// Defect Data 존재유무 판단함 
// 	for(int i=0; i<Count; i++){
// 		if(lpCircle[i].Dv>Dv){
// 			IsStart = true;
// 			break;
// 		}
// 	}
// 
// 	if(IsStart){	
// 		for (register int k=0; k<Count; k++) {
// 			// 			if ( lpCircle[k].Dv >2               ) { IsRoof = true; }
// 			// 			if ( lpCircle[k].Dv >Dv/2            ) { IsRoof = true; }
// 			if ( lpCircle[k].Dv >1               ) { IsRoof = true; } // 1이상 큰 정수부터 가능함 즉....2부터.....
// 			// 			if ( lpCircle[k].Dv >Dv              ) { IsRoof = true; }
// 			// 			if ( IsRoof && lpCircle[k].Dv <=MinDv) { 
// 			// 			if ( IsRoof && lpCircle[k].Dv <=3) { 
// 			if ( IsRoof && lpCircle[k].Dv <=1) { 
// 				if(DefectPoint>5){
// 					// 내부 Pixel Data 축출 
// 					PixelCount =0, PixelPoint=0, PixelScore=50, Score =0.0f;
// 					for(int n=Rect.top+1 ; n<Rect.bottom-1; n++){
// 						for(int m=Rect.left+1; m<Rect.right-1 ; m++){
// 							PixelValue = IElement(m,n);
// 							if(PixelValue < EnCapBtmThresHold) PixelCount++;
// 							PixelPoint++;
// 						}
// 					}
// 					Score  = (((float)PixelCount/(float)PixelPoint)*100);
// 					// Circle Defect 내부의 PixelCount 수량을 체크한다 => 오버킬 감소 목적 
// 					if(Score>PixelScore){
// 						lpDefect[DefectCount].Height = (Rect.bottom - Rect.top);
// 						lpDefect[DefectCount].Width  = (Rect.right - Rect.left);
// 						lpDefect[DefectCount].P.x    =  (float)Rect.left;
// 						lpDefect[DefectCount].P.y    =  (float)(Rect.top +ImageHeight);
// 						lpDefect[DefectCount].Round  =  PixelCount;
// 						DefectCount++;
// 					}
// 				}
// 				DefectPoint=0;
// 				IsRoof = false; 
// 			}
// 
// 			if (IsRoof) {
// 				Rect.left   = Rect.left  <lpCircle[k].P.x && Rect.left!=0 ? Rect.left   :(long) lpCircle[k].P.x;
// 				Rect.top    = Rect.top   <lpCircle[k].P.y && Rect.top !=0 ? Rect.top    :(long) lpCircle[k].P.y;
// 				Rect.right  = Rect.right >lpCircle[k].P.x                 ? Rect.right  :(long) lpCircle[k].P.x;
// 				Rect.bottom = Rect.bottom>lpCircle[k].P.y                 ? Rect.bottom :(long) lpCircle[k].P.y;
// 				// 				IsRoof = false;
// 				DefectPoint++;
// 			}
// 			else {
// 				Rect.left   = 0;
// 				Rect.top    = 0;
// 				Rect.right  = 0;
// 				Rect.bottom = 0;
// 			}
// 
// 		}
// 	}
// 	return DefectCount;
// }
int CMultiLineDefect::GetAvgCellSize(int TopCount, int MidCount, int BtmCount, int AvgMode)
{
	if(MarkStrPos.x==0 || MarkStrPos.y==0 || MarkEndPos.x==0 || MarkEndPos.y==0) return false;

	int nTotalCellSize =0;
	int nCellSize      =0;
	int nAvgCellSize   =0;
	int nCellSizeCount =0;

	if     (AvgMode==0){  // TopCellSizeAvg
		for(int k1=0; k1<TopCount; k1++){
			if(FCellPoint[k1].x==0 || FCellPoint[k1].y==0) continue;
			nCellSize = (int)(Math.GetLengthFrLineToPoint(MarkStrPos, MarkEndPos, FCellPoint[k1]));     
			nTotalCellSize +=nCellSize;
			nCellSizeCount++;
		}
		if(nTotalCellSize>0 && nCellSizeCount>0) nAvgCellSize = nTotalCellSize/nCellSizeCount;
	}
	else if(AvgMode==1){  // MidCellSizeAvg
		for(int k2=TopCount; k2<TopCount+MidCount; k2++){
			if(FCellPoint[k2].x==0 || FCellPoint[k2].y==0) continue;
			nCellSize = (int)(Math.GetLengthFrLineToPoint(MarkStrPos, MarkEndPos, FCellPoint[k2]));     
			nTotalCellSize +=nCellSize;
			nCellSizeCount++;
		}
		if(nTotalCellSize>0 && nCellSizeCount>0) nAvgCellSize = nTotalCellSize/nCellSizeCount;

	}
	else if(AvgMode==2){  // BtmCellSizeAvg
		for(int k3=TopCount+MidCount; k3<TopCount+MidCount+BtmCount; k3++){
			if(FCellPoint[k3].x==0 || FCellPoint[k3].y==0) continue;
			nCellSize = (int)(Math.GetLengthFrLineToPoint(MarkStrPos, MarkEndPos, FCellPoint[k3]));     
			nTotalCellSize +=nCellSize;
			nCellSizeCount++;
		}
		if(nTotalCellSize>0 && nCellSizeCount>0) nAvgCellSize = nTotalCellSize/nCellSizeCount;

	}
	else if(AvgMode==3){  // AllCellSizeAvg
		for(int k4=0; k4<TopCount+MidCount+BtmCount; k4++){
			if(FCellPoint[k4].x==0 || FCellPoint[k4].y==0) continue;
			nCellSize = (int)(Math.GetLengthFrLineToPoint(MarkPos, MarkEndPos, FCellPoint[k4]));     
			nTotalCellSize +=nCellSize;
			nCellSizeCount++;
		}
		if(nTotalCellSize>0 && nCellSizeCount>0) nAvgCellSize = nTotalCellSize/nCellSizeCount;
	}
	return  nAvgCellSize;
}
int CMultiLineDefect::GetCellSize(int Count)
{
	if(MarkStrPos.x==0 || MarkStrPos.y==0 || MarkEndPos.x==0 || MarkEndPos.y==0) return false;
	if( FCellPoint[Count].x==0 || FCellPoint[Count].y==0)                        return false;
    if(Count>=MAX_DEFECT_POINT)                                                  return false;

	int nCellSize      =0;
	
	nCellSize = (int)(Math.GetLengthFrLineToPoint(MarkStrPos, MarkEndPos, FCellPoint[Count]));     
	return  nCellSize;
}
void CMultiLineDefect::OnClearData()
{
	for(int k=0; k<MAX_DEFECT_POINT; k++){
		// Cell Inspection Init
		// Dark Defect 
		ADefectPoint[k].Height    =0;
		ADefectPoint[k].Width     =0;
		ADefectPoint[k].Round     =0;
		ADefectPoint[k].P.x       =0;
		ADefectPoint[k].P.y       =0;
		ADefectPoint[k].Ver_Dis   =0;
		ADefectPoint[k].Hor_Dis   =0;
		ADefectPoint[k].LineAttach=0;
		
		BDefectPoint[k].Height    =0;
		BDefectPoint[k].Width     =0;
		BDefectPoint[k].Round     =0;
		BDefectPoint[k].P.x       =0;
		BDefectPoint[k].P.y       =0;
		BDefectPoint[k].Ver_Dis   =0;
		BDefectPoint[k].Hor_Dis   =0;
		BDefectPoint[k].LineAttach=0;
		
		CDefectPoint[k].Height    =0;
		CDefectPoint[k].Width     =0;
		CDefectPoint[k].Round     =0;
		CDefectPoint[k].P.x       =0;
		CDefectPoint[k].P.y       =0;
		CDefectPoint[k].Ver_Dis   =0;
		CDefectPoint[k].Hor_Dis   =0;
		CDefectPoint[k].LineAttach=0;

		
		DDefectPoint[k].Height    =0;
		DDefectPoint[k].Width     =0;
		DDefectPoint[k].Round     =0;
		DDefectPoint[k].P.x       =0;
		DDefectPoint[k].P.y       =0;
		DDefectPoint[k].Ver_Dis   =0;
		DDefectPoint[k].Hor_Dis   =0;
		DDefectPoint[k].LineAttach=0;


		// Bright Defect 
		ACrackPoint[k].Height    =0;
		ACrackPoint[k].Width     =0;
		ACrackPoint[k].Round     =0;
		ACrackPoint[k].P.x       =0;
		ACrackPoint[k].P.y       =0;
		ACrackPoint[k].Ver_Dis   =0;
		ACrackPoint[k].Hor_Dis   =0;
		ACrackPoint[k].LineAttach=0;

		BCrackPoint[k].Height    =0;
		BCrackPoint[k].Width     =0;
		BCrackPoint[k].Round     =0;
		BCrackPoint[k].P.x       =0;
		BCrackPoint[k].P.y       =0;
		BCrackPoint[k].Ver_Dis   =0;
		BCrackPoint[k].Hor_Dis   =0;
		BCrackPoint[k].LineAttach=0;

		CCrackPoint[k].Height    =0;
		CCrackPoint[k].Width     =0;
		CCrackPoint[k].Round     =0;
		CCrackPoint[k].P.x       =0;
		CCrackPoint[k].P.y       =0;
		CCrackPoint[k].Ver_Dis   =0;
		CCrackPoint[k].Hor_Dis   =0;
		CCrackPoint[k].LineAttach=0;

		DCrackPoint[k].Height    =0;
		DCrackPoint[k].Width     =0;
		DCrackPoint[k].Round     =0;
		DCrackPoint[k].P.x       =0;
		DCrackPoint[k].P.y       =0;
		DCrackPoint[k].Ver_Dis   =0;
		DCrackPoint[k].Hor_Dis   =0;
		DCrackPoint[k].LineAttach=0;
		
		C1DefectPoint[k].Height    =0;
		C1DefectPoint[k].Width     =0;
		C1DefectPoint[k].Round     =0;
		C1DefectPoint[k].P.x       =0;
		C1DefectPoint[k].P.y       =0;
		C1DefectPoint[k].Ver_Dis   =0;
		C1DefectPoint[k].Hor_Dis   =0;
		C1DefectPoint[k].LineAttach=0;
		
		C2DefectPoint[k].Height    =0;
		C2DefectPoint[k].Width     =0;
		C2DefectPoint[k].Round     =0;
		C2DefectPoint[k].P.x       =0;
		C2DefectPoint[k].P.y       =0;
		C2DefectPoint[k].Ver_Dis   =0;
		C2DefectPoint[k].Hor_Dis   =0;
		C2DefectPoint[k].LineAttach=0;
		
		C3DefectPoint[k].Height    =0;
		C3DefectPoint[k].Width     =0;
		C3DefectPoint[k].Round     =0;
		C3DefectPoint[k].P.x       =0;
		C3DefectPoint[k].P.y       =0;
		C3DefectPoint[k].Ver_Dis   =0;
		C3DefectPoint[k].Hor_Dis   =0;
		C3DefectPoint[k].LineAttach=0;

		
		C4DefectPoint[k].Height    =0;
		C4DefectPoint[k].Width     =0;
		C4DefectPoint[k].Round     =0;
		C4DefectPoint[k].P.x       =0;
		C4DefectPoint[k].P.y       =0;
		C4DefectPoint[k].Ver_Dis   =0;
		C4DefectPoint[k].Hor_Dis   =0;
		C4DefectPoint[k].LineAttach=0;


		ABurrPoint[k].Height    =0;
		ABurrPoint[k].Width     =0;
		ABurrPoint[k].Round     =0;
		ABurrPoint[k].P.x       =0;
		ABurrPoint[k].P.y       =0;
		ABurrPoint[k].Ver_Dis   =0;
		ABurrPoint[k].Hor_Dis   =0;
		ABurrPoint[k].LineAttach=0;

		BBurrPoint[k].Height    =0;
		BBurrPoint[k].Width     =0;
		BBurrPoint[k].Round     =0;
		BBurrPoint[k].P.x       =0;
		BBurrPoint[k].P.y       =0;
		BBurrPoint[k].Ver_Dis   =0;
		BBurrPoint[k].Hor_Dis   =0;
		BBurrPoint[k].LineAttach=0;

		CBurrPoint[k].Height    =0;
		CBurrPoint[k].Width     =0;
		CBurrPoint[k].Round     =0;
		CBurrPoint[k].P.x       =0;
		CBurrPoint[k].P.y       =0;
		CBurrPoint[k].Ver_Dis   =0;
		CBurrPoint[k].Hor_Dis   =0;
		CBurrPoint[k].LineAttach=0;

		
		DBurrPoint[k].Height    =0;
		DBurrPoint[k].Width     =0;
		DBurrPoint[k].Round     =0;
		DBurrPoint[k].P.x       =0;
		DBurrPoint[k].P.y       =0;
		DBurrPoint[k].Ver_Dis   =0;
		DBurrPoint[k].Hor_Dis   =0;
		DBurrPoint[k].LineAttach=0;


		// Edge Inspection Init
		BurrPoint[k].Height     =0;
		BurrPoint[k].Width      =0;
		BurrPoint[k].Round      =0;
		BurrPoint[k].P.x        =0;
		BurrPoint[k].P.y        =0;
		BurrPoint[k].Ver_Dis    =0;
		BurrPoint[k].Hor_Dis    =0;
		BurrPoint[k].LineAttach =0;
		
		BrokenPoint[k].Height     =0;
		BrokenPoint[k].Width      =0;
		BrokenPoint[k].Round      =0;
		BrokenPoint[k].P.x        =0;
		BrokenPoint[k].P.y        =0;
		BrokenPoint[k].Ver_Dis    =0;
		BrokenPoint[k].Hor_Dis    =0;
		BrokenPoint[k].LineAttach =0;
		
		CrackPoint[k].Height    =0;
		CrackPoint[k].Width     =0;
		CrackPoint[k].Round     =0;
		CrackPoint[k].P.x       =0;
		CrackPoint[k].P.y       =0;
		CrackPoint[k].Ver_Dis   =0;
		CrackPoint[k].Hor_Dis   =0;
		CrackPoint[k].LineAttach=0;

		// Circle Defect Data Init
		// Dark Defect 
		A1CirDefectPoint[k].Height      =0;
		A1CirDefectPoint[k].Width       =0;
		A1CirDefectPoint[k].Round       =0;
		A1CirDefectPoint[k].P.x         =0;
		A1CirDefectPoint[k].P.y         =0;
		A1CirDefectPoint[k].Rect.left   =0;
		A1CirDefectPoint[k].Rect.top    =0;
		A1CirDefectPoint[k].Rect.right  =0;
		A1CirDefectPoint[k].Rect.bottom =0;
		A1CirDefectPoint[k].Ver_Dis     =0;
		A1CirDefectPoint[k].Hor_Dis     =0;
		A1CirDefectPoint[k].LineAttach  =0;

		A2CirDefectPoint[k].Height      =0;
		A2CirDefectPoint[k].Width       =0;
		A2CirDefectPoint[k].Round       =0;
		A2CirDefectPoint[k].P.x         =0;
		A2CirDefectPoint[k].P.y         =0;
		A2CirDefectPoint[k].Rect.left   =0;
		A2CirDefectPoint[k].Rect.top    =0;
		A2CirDefectPoint[k].Rect.right  =0;
		A2CirDefectPoint[k].Rect.bottom =0;
		A2CirDefectPoint[k].Ver_Dis     =0;
		A2CirDefectPoint[k].Hor_Dis     =0;
		A2CirDefectPoint[k].LineAttach  =0;

		C1CirDefectPoint[k].Height      =0;
		C1CirDefectPoint[k].Width       =0;
		C1CirDefectPoint[k].Round       =0;
		C1CirDefectPoint[k].P.x         =0;
		C1CirDefectPoint[k].P.y         =0;
		C1CirDefectPoint[k].Rect.left   =0;
		C1CirDefectPoint[k].Rect.top    =0;
		C1CirDefectPoint[k].Rect.right  =0;
		C1CirDefectPoint[k].Rect.bottom =0;
		C1CirDefectPoint[k].Ver_Dis     =0;
		C1CirDefectPoint[k].Hor_Dis     =0;
		C1CirDefectPoint[k].LineAttach  =0;

		C2CirDefectPoint[k].Height      =0;
		C2CirDefectPoint[k].Width       =0;
		C2CirDefectPoint[k].Round       =0;
		C2CirDefectPoint[k].P.x         =0;
		C2CirDefectPoint[k].P.y         =0;
		C2CirDefectPoint[k].Rect.left   =0;
		C2CirDefectPoint[k].Rect.top    =0;
		C2CirDefectPoint[k].Rect.right  =0;
		C2CirDefectPoint[k].Rect.bottom =0;
		C2CirDefectPoint[k].Ver_Dis     =0;
		C2CirDefectPoint[k].Hor_Dis     =0;
		C2CirDefectPoint[k].LineAttach  =0;

		C3CirDefectPoint[k].Height      =0;
		C3CirDefectPoint[k].Width       =0;
		C3CirDefectPoint[k].Round       =0;
		C3CirDefectPoint[k].P.x         =0;
		C3CirDefectPoint[k].P.y         =0;
		C3CirDefectPoint[k].Rect.left   =0;
		C3CirDefectPoint[k].Rect.top    =0;
		C3CirDefectPoint[k].Rect.right  =0;
		C3CirDefectPoint[k].Rect.bottom =0;
		C3CirDefectPoint[k].Ver_Dis     =0;
		C3CirDefectPoint[k].Hor_Dis     =0;
		C3CirDefectPoint[k].LineAttach  =0;

		C4CirDefectPoint[k].Height      =0;
		C4CirDefectPoint[k].Width       =0;
		C4CirDefectPoint[k].Round       =0;
		C4CirDefectPoint[k].P.x         =0;
		C4CirDefectPoint[k].P.y         =0;
		C4CirDefectPoint[k].Rect.left   =0;
		C4CirDefectPoint[k].Rect.top    =0;
		C4CirDefectPoint[k].Rect.right  =0;
		C4CirDefectPoint[k].Rect.bottom =0;
		C4CirDefectPoint[k].Ver_Dis     =0;
		C4CirDefectPoint[k].Hor_Dis     =0;
		C4CirDefectPoint[k].LineAttach  =0;

		C5CirDefectPoint[k].Height      =0;
		C5CirDefectPoint[k].Width       =0;
		C5CirDefectPoint[k].Round       =0;
		C5CirDefectPoint[k].P.x         =0;
		C5CirDefectPoint[k].P.y         =0;
		C5CirDefectPoint[k].Rect.left   =0;
		C5CirDefectPoint[k].Rect.top    =0;
		C5CirDefectPoint[k].Rect.right  =0;
		C5CirDefectPoint[k].Rect.bottom =0;
		C5CirDefectPoint[k].Ver_Dis     =0;
		C5CirDefectPoint[k].Hor_Dis     =0;
		C5CirDefectPoint[k].LineAttach  =0;

		C6CirDefectPoint[k].Height      =0;
		C6CirDefectPoint[k].Width       =0;
		C6CirDefectPoint[k].Round       =0;
		C6CirDefectPoint[k].P.x         =0;
		C6CirDefectPoint[k].P.y         =0;
		C6CirDefectPoint[k].Rect.left   =0;
		C6CirDefectPoint[k].Rect.top    =0;
		C6CirDefectPoint[k].Rect.right  =0;
		C6CirDefectPoint[k].Rect.bottom =0;
		C6CirDefectPoint[k].Ver_Dis     =0;
		C6CirDefectPoint[k].Hor_Dis     =0;
		C6CirDefectPoint[k].LineAttach  =0;

		Btm3CirDefectPoint[k].Height      =0;
		Btm3CirDefectPoint[k].Width       =0;
		Btm3CirDefectPoint[k].Round       =0;
		Btm3CirDefectPoint[k].P.x         =0;
		Btm3CirDefectPoint[k].P.y         =0;
		Btm3CirDefectPoint[k].Rect.left   =0;
		Btm3CirDefectPoint[k].Rect.top    =0;
		Btm3CirDefectPoint[k].Rect.right  =0;
		Btm3CirDefectPoint[k].Rect.bottom =0;
		Btm3CirDefectPoint[k].Ver_Dis     =0;
		Btm3CirDefectPoint[k].Hor_Dis     =0;
		Btm3CirDefectPoint[k].LineAttach  =0;

		// Bright Defect 
		A1CirCrackPoint[k].Height     =0;
		A1CirCrackPoint[k].Width      =0;
		A1CirCrackPoint[k].Round      =0;
		A1CirCrackPoint[k].P.x        =0;
		A1CirCrackPoint[k].P.y        =0;
		A1CirCrackPoint[k].Rect.left  =0;
		A1CirCrackPoint[k].Rect.top   =0;
		A1CirCrackPoint[k].Rect.right =0;
		A1CirCrackPoint[k].Rect.bottom=0;
		A1CirCrackPoint[k].Ver_Dis    =0;
		A1CirCrackPoint[k].Hor_Dis    =0;
		A1CirCrackPoint[k].LineAttach =0;

		A2CirCrackPoint[k].Height     =0;
		A2CirCrackPoint[k].Width      =0;
		A2CirCrackPoint[k].Round      =0;
		A2CirCrackPoint[k].P.x        =0;
		A2CirCrackPoint[k].P.y        =0;
		A2CirCrackPoint[k].Rect.left  =0;
		A2CirCrackPoint[k].Rect.top   =0;
		A2CirCrackPoint[k].Rect.right =0;
		A2CirCrackPoint[k].Rect.bottom=0;
		A2CirCrackPoint[k].Ver_Dis    =0;
		A2CirCrackPoint[k].Hor_Dis    =0;
		A2CirCrackPoint[k].LineAttach =0;

		C1CirCrackPoint[k].Height     =0;
		C1CirCrackPoint[k].Width      =0;
		C1CirCrackPoint[k].Round      =0;
		C1CirCrackPoint[k].P.x        =0;
		C1CirCrackPoint[k].P.y        =0;
		C1CirCrackPoint[k].Rect.left  =0;
		C1CirCrackPoint[k].Rect.top   =0;
		C1CirCrackPoint[k].Rect.right =0;
		C1CirCrackPoint[k].Rect.bottom=0;
		C1CirCrackPoint[k].Ver_Dis    =0;
		C1CirCrackPoint[k].Hor_Dis    =0;
		C1CirCrackPoint[k].LineAttach =0;

		C2CirCrackPoint[k].Height     =0;
		C2CirCrackPoint[k].Width      =0;
		C2CirCrackPoint[k].Round      =0;
		C2CirCrackPoint[k].P.x        =0;
		C2CirCrackPoint[k].P.y        =0;
		C2CirCrackPoint[k].Rect.left  =0;
		C2CirCrackPoint[k].Rect.top   =0;
		C2CirCrackPoint[k].Rect.right =0;
		C2CirCrackPoint[k].Rect.bottom=0;
		C2CirCrackPoint[k].Ver_Dis    =0;
		C2CirCrackPoint[k].Hor_Dis    =0;
		C2CirCrackPoint[k].LineAttach =0;

		C3CirCrackPoint[k].Height     =0;
		C3CirCrackPoint[k].Width      =0;
		C3CirCrackPoint[k].Round      =0;
		C3CirCrackPoint[k].P.x        =0;
		C3CirCrackPoint[k].P.y        =0;
		C3CirCrackPoint[k].Rect.left  =0;
		C3CirCrackPoint[k].Rect.top   =0;
		C3CirCrackPoint[k].Rect.right =0;
		C3CirCrackPoint[k].Rect.bottom=0;
		C3CirCrackPoint[k].Ver_Dis    =0;
		C3CirCrackPoint[k].Hor_Dis    =0;
		C3CirCrackPoint[k].LineAttach =0;

		C4CirCrackPoint[k].Height     =0;
		C4CirCrackPoint[k].Width      =0;
		C4CirCrackPoint[k].Round      =0;
		C4CirCrackPoint[k].P.x        =0;
		C4CirCrackPoint[k].P.y        =0;
		C4CirCrackPoint[k].Rect.left  =0;
		C4CirCrackPoint[k].Rect.top   =0;
		C4CirCrackPoint[k].Rect.right =0;
		C4CirCrackPoint[k].Rect.bottom=0;
		C4CirCrackPoint[k].Ver_Dis    =0;
		C4CirCrackPoint[k].Hor_Dis    =0;
		C4CirCrackPoint[k].LineAttach =0;

		C5CirCrackPoint[k].Height     =0;
		C5CirCrackPoint[k].Width      =0;
		C5CirCrackPoint[k].Round      =0;
		C5CirCrackPoint[k].P.x        =0;
		C5CirCrackPoint[k].P.y        =0;
		C5CirCrackPoint[k].Rect.left  =0;
		C5CirCrackPoint[k].Rect.top   =0;
		C5CirCrackPoint[k].Rect.right =0;
		C5CirCrackPoint[k].Rect.bottom=0;
		C5CirCrackPoint[k].Ver_Dis    =0;
		C5CirCrackPoint[k].Hor_Dis    =0;
		C5CirCrackPoint[k].LineAttach =0;

		C6CirCrackPoint[k].Height     =0;
		C6CirCrackPoint[k].Width      =0;
		C6CirCrackPoint[k].Round      =0;
		C6CirCrackPoint[k].P.x        =0;
		C6CirCrackPoint[k].P.y        =0;
		C6CirCrackPoint[k].Rect.left  =0;
		C6CirCrackPoint[k].Rect.top   =0;
		C6CirCrackPoint[k].Rect.right =0;
		C6CirCrackPoint[k].Rect.bottom=0;
		C6CirCrackPoint[k].Ver_Dis    =0;
		C6CirCrackPoint[k].Hor_Dis    =0;
		C6CirCrackPoint[k].LineAttach =0;

		Btm3CirCrackPoint[k].Height     =0;
		Btm3CirCrackPoint[k].Width      =0;
		Btm3CirCrackPoint[k].Round      =0;
		Btm3CirCrackPoint[k].P.x        =0;
		Btm3CirCrackPoint[k].P.y        =0;
		Btm3CirCrackPoint[k].Rect.left  =0;
		Btm3CirCrackPoint[k].Rect.top   =0;
		Btm3CirCrackPoint[k].Rect.right =0;
		Btm3CirCrackPoint[k].Rect.bottom=0;
		Btm3CirCrackPoint[k].Ver_Dis    =0;
		Btm3CirCrackPoint[k].Hor_Dis    =0;
		Btm3CirCrackPoint[k].LineAttach =0;
		
		FDefectPoint[k].x       =0.0f;
		FDefectPoint[k].y       =0.0f;
		
		FCellPoint[k].x         =0.0f;
		FCellPoint[k].y         =0.0f;
	}
	// TOP/BTM Broken Inspection StartLine
	nTopBtmStart =0;
	
	// DefectCount Init Data 
	BurrCount   =0;
	CrackCount  =0;
	BrokenCount =0;

	// Line Position
	LinePosition = 0.0f;

	// Line Data 
	LeftLineData  =0.0f;
	RightLineData =0.0f;

	// Remove Blob Init 
	FBrokenMaxWidth   =4096;
	FBrokenMaxHeight  =1000;
	FBurrMaxWidth     =4096;
	FBurrMaxHeight    =1000;
	FChippingMaxWidth =4096;
	FChippingMaxHeight=1000;

	//EdgeInspection LineData Init
	InLine [0].FP0.x = 0.0f;
	InLine [0].FP0.y = 0.0f;
	InLine [0].FP1.x = 0.0f;
	InLine [0].FP1.y = 0.0f;
	OutLine[0].FP0.x = 0.0f;
	OutLine[0].FP0.y = 0.0f;
	OutLine[0].FP1.x = 0.0f;
	OutLine[0].FP1.y = 0.0f;
	BMLine [0].FP0.x = 0.0f;
	BMLine [0].FP0.y = 0.0f;
	BMLine [0].FP1.x = 0.0f;
	BMLine [0].FP1.y = 0.0f;

	//CellInspection LineData Init
	LeftBMLine [0].FP0.x = 0.0f;
	LeftBMLine [0].FP0.y = 0.0f;
	LeftBMLine [0].FP1.x = 0.0f;
	LeftBMLine [0].FP1.y = 0.0f;
	RightBMLine[0].FP0.x = 0.0f;
	RightBMLine[0].FP0.y = 0.0f;
	RightBMLine[0].FP1.x = 0.0f;
	RightBMLine[0].FP1.y = 0.0f;
	TopBMLine  [0].FP0.x = 0.0f;
	TopBMLine  [0].FP0.y = 0.0f;
	TopBMLine  [0].FP1.x = 0.0f;
	TopBMLine  [0].FP1.y = 0.0f;
	BtmBMLine  [0].FP0.x = 0.0f;
	BtmBMLine  [0].FP0.y = 0.0f;
	BtmBMLine  [0].FP1.x = 0.0f;
	BtmBMLine  [0].FP1.y = 0.0f;

	// NOTCH CELL INSPECTION LineData Init
	LeftOutLine [0].FP0.x = 0.0f;
	LeftOutLine [0].FP0.y = 0.0f;
	LeftOutLine [0].FP1.x = 0.0f;
	LeftOutLine [0].FP1.y = 0.0f;
	LeftInLine  [0].FP0.x = 0.0f;
	LeftInLine  [0].FP0.y = 0.0f;
	LeftInLine  [0].FP1.x = 0.0f;
	LeftInLine  [0].FP1.y = 0.0f;

	TopOutLine [0].FP0.x  = 0.0f;
	TopOutLine [0].FP0.y  = 0.0f;
	TopOutLine [0].FP1.x  = 0.0f;
	TopOutLine [0].FP1.y  = 0.0f;
	TopInLine  [0].FP0.x  = 0.0f;
	TopInLine  [0].FP0.y  = 0.0f;
	TopInLine  [0].FP1.x  = 0.0f;
	TopInLine  [0].FP1.y  = 0.0f;

	RightOutLine[0].FP0.x = 0.0f;
	RightOutLine[0].FP0.y = 0.0f;
	RightOutLine[0].FP1.x = 0.0f;
	RightOutLine[0].FP1.y = 0.0f;
	RightInLine [0].FP0.x = 0.0f;
	RightInLine [0].FP0.y = 0.0f;
	RightInLine [0].FP1.x = 0.0f;
	RightInLine [0].FP1.y = 0.0f;
	// Notch Cell Pattern Line 
	LeftTrackLine [0].FP0.x = 0.0f;
	LeftTrackLine [0].FP0.y = 0.0f;
	LeftTrackLine [0].FP1.x = 0.0f;
	LeftTrackLine [0].FP1.y = 0.0f;

	RightTrackLine[0].FP0.x = 0.0f;
	RightTrackLine[0].FP0.y = 0.0f;
	RightTrackLine[0].FP1.x = 0.0f;
	RightTrackLine[0].FP1.y = 0.0f;

	BtmTrackLine  [0].FP0.x = 0.0f;
	BtmTrackLine  [0].FP0.y = 0.0f;
	BtmTrackLine  [0].FP1.x = 0.0f;
	BtmTrackLine  [0].FP1.y = 0.0f;

	for(int k=0; k<MAX_BTM_COUNT; k++){
		BtmOutLine  [k].FP0.x = 0.0f;
		BtmOutLine  [k].FP0.y = 0.0f;
		BtmOutLine  [k].FP1.x = 0.0f;
		BtmOutLine  [k].FP1.y = 0.0f;
		BtmInLine   [k].FP0.x = 0.0f;
		BtmInLine   [k].FP0.y = 0.0f;
		BtmInLine   [k].FP1.x = 0.0f;
		BtmInLine   [k].FP1.y = 0.0f;
		BtmStandLine[k].FP0.x = 0.0f;
		BtmStandLine[k].FP0.y = 0.0f;
		BtmStandLine[k].FP1.x = 0.0f;
		BtmStandLine[k].FP1.y = 0.0f;
	}

	//Line Data Init
	for(int i=0; i<MAX_LINE_POINT; i++){
		Line[i].FP0.x =0.0f;
		Line[i].FP0.y =0.0f;
		Line[i].FP1.x =0.0f;
		Line[i].FP1.y =0.0f;
	}
	// Line Pre Data Init 
	for(int j=0; j<MAX_PRELINE_POINT; j++){
		PreLine[j].FP0.x =0.0f;
		PreLine[j].FP0.y =0.0f;
		PreLine[j].FP1.x =0.0f;
		PreLine[j].FP1.y =0.0f;
	}

	// Grind Rect && Grind Point Init
	for(int k=0; k<MAX_FIND_MARK_COUNT; k++){
		GrindMarkRect      [k].left   =0;
		GrindMarkRect      [k].top    =0;
		GrindMarkRect      [k].right  =0;
		GrindMarkRect      [k].bottom =0;
	    GrindMarkPoint     [k].x      =0.0f;
		GrindMarkPoint     [k].y      =0.0f;
		GrindMarkRectCenter[k].x      =0.0f;
		GrindMarkRectCenter[k].y      =0.0f;
		GrindMarkGradient  [k]        =0.0f;
		GrindMarkScore     [k]        =0.0f;
	}
	// A_Side ROI Init
	for(int k=0; k<2; k++){
		PadPolyRect[k].left  =0;
		PadPolyRect[k].top   =0;
		PadPolyRect[k].right =0;
		PadPolyRect[k].bottom=0;
	}

	// C_Side ROI Init
	for(int k=0; k<6; k++){
		NotchPolyRect[k].left  =0;
		NotchPolyRect[k].top   =0;
		NotchPolyRect[k].right =0;
		NotchPolyRect[k].bottom=0;
	}


	// CornerData Init
    C1EdgeCount =0;
	C2EdgeCount =0;
	C3EdgeCount =0;
	C4EdgeCount =0;

	// Corner InEdge Count
	C1InEdgeCount =0;
	C2InEdgeCount =0;
	C3InEdgeCount =0;
	C4InEdgeCount =0;

	// Corner Grind Measure Stand Edge Count 
	C1MeaEdgeCount =0;
	C2MeaEdgeCount =0;
	C3MeaEdgeCount =0;
	C4MeaEdgeCount =0;

	// BMLine Data Overlap
	InspectCount=0;

	for(int a=0; a<MAX_BMLINE_COUNT; a++){
		BMLineData[a].Dis1  =0;
		BMLineData[a].Dis2  =0;
		BMLineData[a].yPos1 =0;
		BMLineData[a].yPos2 =0;
	}
	BMLineMargin =0;

	// Inspection End
// 	IsInspEnd = false;
	TopLimitLine = 0 ;
	BtmLimitLine = 0 ;

	// Circle Data Init
	//----------------------------------------------------------------
	// Circle Data 
	for(int k=0; k<MAX_CIRCLE_EDGEPOINT; k++){
		A1CircleData[k].Dis = 0.0f;
		A1CircleData[k].Dv  = 0.0f;
		A1CircleData[k].P.x = 0.0f;
		A1CircleData[k].P.y = 0.0f;

		A2CircleData[k].Dis = 0.0f;
		A2CircleData[k].Dv  = 0.0f;
		A2CircleData[k].P.x = 0.0f;
		A2CircleData[k].P.y = 0.0f;

		C1CircleData[k].Dis = 0.0f;
		C1CircleData[k].Dv  = 0.0f;
		C1CircleData[k].P.x = 0.0f;
		C1CircleData[k].P.y = 0.0f;

		C2CircleData[k].Dis = 0.0f;
		C2CircleData[k].Dv  = 0.0f;
		C2CircleData[k].P.x = 0.0f;
		C2CircleData[k].P.y = 0.0f;

		C3CircleData[k].Dis = 0.0f;
		C3CircleData[k].Dv  = 0.0f;
		C3CircleData[k].P.x = 0.0f;
		C3CircleData[k].P.y = 0.0f;

		C4CircleData[k].Dis = 0.0f;
		C4CircleData[k].Dv  = 0.0f;
		C4CircleData[k].P.x = 0.0f;
		C4CircleData[k].P.y = 0.0f;

		C5CircleData[k].Dis = 0.0f;
		C5CircleData[k].Dv  = 0.0f;
		C5CircleData[k].P.x = 0.0f;
		C5CircleData[k].P.y = 0.0f;

		C6CircleData[k].Dis = 0.0f;
		C6CircleData[k].Dv  = 0.0f;
		C6CircleData[k].P.x = 0.0f;
		C6CircleData[k].P.y = 0.0f;

		Btm3CircleData[k].Dis = 0.0f;
		Btm3CircleData[k].Dv  = 0.0f;
		Btm3CircleData[k].P.x = 0.0f;
		Btm3CircleData[k].P.y = 0.0f;
	}
	// Circle InEdge Point Count
	A1CirInEdgeCount = 0;
	A2CirInEdgeCount = 0;

	C1CirInEdgeCount = 0;
	C2CirInEdgeCount = 0;
	C3CirInEdgeCount = 0;
	C4CirInEdgeCount = 0;
	C5CirInEdgeCount = 0;
	C6CirInEdgeCount = 0;

	// Circle InEdge Point Count
	A1CirOutEdgeCount = 0;
	A2CirOutEdgeCount = 0;

	C1CirOutEdgeCount = 0;
	C2CirOutEdgeCount = 0;
	C3CirOutEdgeCount = 0;
	C4CirOutEdgeCount = 0;
	C5CirOutEdgeCount = 0;
	C6CirOutEdgeCount = 0;

	// 박리불량 검출 Point Count
	A1CirInCrackCount = 0;
	A2CirInCrackCount = 0;
					    
	C1CirInCrackCount = 0;
	C2CirInCrackCount = 0;
	C3CirInCrackCount = 0;
	C4CirInCrackCount = 0;
	C5CirInCrackCount = 0;
	C6CirInCrackCount = 0;

	Btm3CirInCrackCount =0;

	// Bridht Defect 
	ACrackCount      = 0;
	BCrackCount      = 0;
	CCrackCount      = 0;
	DCrackCount      = 0;

	// Circle StandEdge Point Count
	C1CirStandEdgeCount = 0;
	C2CirStandEdgeCount = 0;
	C3CirStandEdgeCount = 0;
	C4CirStandEdgeCount = 0;
	C5CirStandEdgeCount = 0;
	C6CirStandEdgeCount = 0;

	Btm3InEdgeCount     = 0;
	Btm3OutEdgeCount    = 0;

	// Circle Calculate Data Init 
	A1CirDx      = 0.0f;
	A1CirDy      = 0.0f;
	A1CirRound   = 0.0f;
	A2CirDx      = 0.0f;
	A2CirDy      = 0.0f;
	A2CirRound   = 0.0f;

	for(int k=0; k<4; k++){
		A1CirGrindWd [k]= 0.0f;
		A1CirGrindMea[k]= 0.0f;
		A2CirGrindWd [k]= 0.0f;
		A2CirGrindMea[k]= 0.0f;
	}

	C0CirGrindWd = 0.0f; 
	C0CirGrindMea= 0.0f; 
	C1CirDx      = 0.0f;
	C1CirDy      = 0.0f;
	C1CirRound   = 0.0f;
	C1CirGrindWd = 0.0f;
	C1CirGrindMea= 0.0f;
	C2CirDx      = 0.0f;
	C2CirDy      = 0.0f;
	C2CirRound   = 0.0f;
	C2CirGrindWd = 0.0f;
	C2CirGrindMea= 0.0f;
	C3CirDx      = 0.0f;
	C3CirDy      = 0.0f;
	C3CirGrindWd = 0.0f;
	C3CirGrindMea= 0.0f;
	C3CirRound   = 0.0f;
	C4CirDx      = 0.0f;
	C4CirDy      = 0.0f;
	C4CirRound   = 0.0f;
	C4CirGrindWd = 0.0f;
	C4CirGrindMea= 0.0f;
	C5CirDx      = 0.0f;
	C5CirDy      = 0.0f;
	C5CirRound   = 0.0f;
	C5CirGrindWd = 0.0f;
	C5CirGrindMea= 0.0f;
	C6CirDx      = 0.0f;
	C6CirDy      = 0.0f;
	C6CirRound   = 0.0f;
	C6CirGrindWd = 0.0f;
	C6CirGrindMea= 0.0f;
	C7CirGrindWd = 0.0f; 
	C7CirGrindMea= 0.0f; 


	// Trench 가상 GrindMark Point
	TrenchLeftGrindWd   = 0.0f;
	TrenchLeftGrindMea  = 0.0f;
	TrenchRightGrindWd  = 0.0f;
	TrenchRightGrindMea = 0.0f;

	// Circle Center Data Init 
	A1CirCenter.x = 0.0f;
	A1CirCenter.y = 0.0f;
	A2CirCenter.x = 0.0f;
	A2CirCenter.y = 0.0f;

	C1CirCenter.x = 0.0f;
	C1CirCenter.y = 0.0f;
	C2CirCenter.x = 0.0f;
	C2CirCenter.y = 0.0f;
	C3CirCenter.x = 0.0f;
	C3CirCenter.y = 0.0f;
	C4CirCenter.x = 0.0f;
	C4CirCenter.y = 0.0f;
	C5CirCenter.x = 0.0f;
	C5CirCenter.y = 0.0f;
	C6CirCenter.x = 0.0f;
	C6CirCenter.y = 0.0f;

	// Real Circle Center Data Init 
	RealA1CirCenter.x = 0.0f;
	RealA1CirCenter.y = 0.0f;
	RealA2CirCenter.x = 0.0f;
	RealA2CirCenter.y = 0.0f;

	RealC1CirCenter.x = 0.0f;
	RealC1CirCenter.y = 0.0f;
	RealC2CirCenter.x = 0.0f;
	RealC2CirCenter.y = 0.0f;
	RealC3CirCenter.x = 0.0f;
	RealC3CirCenter.y = 0.0f;
	RealC4CirCenter.x = 0.0f;
	RealC4CirCenter.y = 0.0f;
	RealC5CirCenter.x = 0.0f;
	RealC5CirCenter.y = 0.0f;
	RealC6CirCenter.x = 0.0f;
	RealC6CirCenter.y = 0.0f;

	ACircleFit1Center.x = 0.0f;
	ACircleFit1Center.y = 0.0f;
	ACircleFit2Center.x = 0.0f;
	ACircleFit2Center.y = 0.0f;

	CircleFit1Center.x = 0.0f;
	CircleFit1Center.y = 0.0f;
	CircleFit2Center.x = 0.0f;
	CircleFit2Center.y = 0.0f;
	CircleFit3Center.x = 0.0f;
	CircleFit3Center.y = 0.0f;
	CircleFit4Center.x = 0.0f;
	CircleFit4Center.y = 0.0f;
	CircleFit5Center.x = 0.0f;
	CircleFit5Center.y = 0.0f;
	CircleFit6Center.x = 0.0f;
	CircleFit6Center.y = 0.0f;

    CircleFitBtm3Center.x =0.0f;
	CircleFitBtm3Center.y =0.0f;

	CrackACirDiameter1 = 0.0f;
	CrackACirDiameter2 = 0.0f;
	CrackCirDiameter1  = 0.0f;
	CrackCirDiameter2  = 0.0f;
	CrackCirDiameter3  = 0.0f;
	CrackCirDiameter4  = 0.0f;
	CrackCirDiameter5  = 0.0f;
	CrackCirDiameter6  = 0.0f;

	ACirDiameter1 = 0.0f;
	ACirDiameter2 = 0.0f;

	CirDiameter1 = 0.0f;
	CirDiameter2 = 0.0f;
	CirDiameter3 = 0.0f;
	CirDiameter4 = 0.0f;
	CirDiameter5 = 0.0f;
	CirDiameter6 = 0.0f;

	ACirFitDiameter1 = 0.0f;
	ACirFitDiameter2 = 0.0f;

	CirFitDiameter1 = 0.0f;
	CirFitDiameter2 = 0.0f;
	CirFitDiameter3 = 0.0f;
	CirFitDiameter4 = 0.0f;
	CirFitDiameter5 = 0.0f;
	CirFitDiameter6 = 0.0f;

	// Narrow Trench 
	CirFitDiameterBtm3 =0.0f;

	// TrackLine Circle Center Data Init 
	TrackC1CirCenter.x = 0.0f;
	TrackC1CirCenter.y = 0.0f;
	TrackC2CirCenter.x = 0.0f;
	TrackC2CirCenter.y = 0.0f;
	TrackC3CirCenter.x = 0.0f;
	TrackC3CirCenter.y = 0.0f;
	TrackC4CirCenter.x = 0.0f;
	TrackC4CirCenter.y = 0.0f;
	TrackC5CirCenter.x = 0.0f;
	TrackC5CirCenter.y = 0.0f;
	TrackC6CirCenter.x = 0.0f;
	TrackC6CirCenter.y = 0.0f;

	// NOTCH CELL Btm EdgePoint Data Init 
	for(int k=0; k<MAX_BTM_LINE_POINT; k++){
		BtmEdgePoint[k].x =0.0f;
		BtmEdgePoint[k].y =0.0f;
	}

	// NOTCH CELL Top EdgePoint Data Init 
	for(int k=0; k<MAX_TOP_LINE_POINT; k++){
		TopEdgePoint[k].x =0.0f;
		TopEdgePoint[k].y =0.0f;
	}

	// NOTCH Corner Data Init 
	C1CorGrindWd  = 0.0f;
	C1CorGrindMea = 0.0f;
	C2CorGrindWd  = 0.0f;
	C2CorGrindMea = 0.0f;
	C3CorGrindWd  = 0.0f;
	C3CorGrindMea = 0.0f;
	C4CorGrindWd  = 0.0f;
	C4CorGrindMea = 0.0f;

	// NOTCH Btm Grind_Width, Grind_Measure Data Init 
	BtmGrindWidth1   = 0.0f;
	BtmGrindWidth2   = 0.0f;
	BtmGrindWidth3   = 0.0f;
	BtmGrindWidth4   = 0.0f;
	BtmGrindWidth5   = 0.0f;
	BtmGrindWidth6   = 0.0f;
	BtmGrindWidth7   = 0.0f;
	BtmGrindWidth8   = 0.0f;
	BtmGrindWidth9   = 0.0f;
	BtmGrindMeasure1 = 0.0f;
	BtmGrindMeasure2 = 0.0f;
	BtmGrindMeasure3 = 0.0f;
	BtmGrindMeasure4 = 0.0f;
	BtmGrindMeasure5 = 0.0f;
	BtmGrindMeasure6 = 0.0f;
	BtmGrindMeasure7 = 0.0f;
	BtmGrindMeasure8 = 0.0f;
	BtmGrindMeasure9 = 0.0f;

	// Notch Cell TrackLine Data Overlap Init 
	AvgLeftTrackLineDis     =0;
	AvgRightTrackLineDis    =0;
	AvgLeftBtmTrackLineDis  =0;
	AvgRightBtmTrackLineDis =0;
	LeftTrackLineCount      =0;
	RightTrackLineCount     =0;
	TotalLeftTrackDis       =0;
	TotalRightTrackDis      =0;

	// NOTCH 
	// Btm Line Search 시간 단축 목적 
	FEndLine =0;

	// Notch Cell Mark Degree 
	MarkDegree =0.0f;

	// 연마 각도 (Circle)
	SideCirDeg   =0;
	CenterCirDeg =0;

// 	Find->OnLoad(true,FindDir);

	// Notch Cell Size Data Init 
	LeftCellSizeHeight  =0.0f;
	CenCellSizeHeight   =0.0f;
	CenCellSizeWidth    =0.0f;
	NotchCellSizeWidth  =0.0f;
	NotchCellSizeHeight =0.0f;

	// MarkToTopSide Height
	LeftMarkToTopHeight  =0.0f;
	CenMarkToTopHeight   =0.0f;
	RightMarkToTopHeight =0.0f;

	// Center Cell Size  측정시 필요한 데이터 
	TotalCellSizeWidth  =0.0f;
	CenterCellSize      =0.0f;
	TotalCellSizeCount  =0   ;

	// Cell Size 측정 기준
	LeftStaPos.x   =0.0f;
	LeftStaPos.y   =0.0f;
	LeftEndPos.x   =0.0f;
	LeftEndPos.y   =0.0f;
	CenterStaPos.x =0.0f;
	CenterStaPos.y =0.0f;
	CenterEndPos.x =0.0f;
	CenterEndPos.y =0.0f;

	// Align 심하게 틀어질경우 발생하는 Defect오버킬 
	int LeftDegMargin =0;
	int RightDegMargin=0;

	AlignMark1.x=0.0f;
	AlignMark1.y=0.0f;
	AlignMark2.x=0.0f;
	AlignMark2.y=0.0f;

	// A_Side Grind 측정 Point Data Init 
	for(int k=0; k<MAX_ASIDE_GRIND_POINT; k++){
		ASideGrindWd [k] =0.0f;
		ASideGrindMea[k] =0.0f;
	}

	// Corner Dx,Dy 설정값 초기화 
	LTCornerWidth    =0;
	LTCornerHeight   =0;
	RTCornerWidth    =0;
	RTCornerHeight   =0;
	LBCornerWidth    =0;
	LBCornerHeight   =0;
	RBCornerWidth    =0;
	RBCornerHeight   =0;

	// TopShape Mode 설정, BtmShape Mode설정 
	// Corner 연마검사 여부 확인 
	IsCornerTop = false;
	IsCornerBtm = false;

	// Rect 검사 여부 확인 
	IsRectTop = false;
	IsRectBtm = false;

	// Cell Circle Grind 검사 유무 결정
	IsCircleTop = false;
	IsCircleBtm = false;

	// Narrow Trench In/Out Data 
	IsNarrowTrench = false;
	//----------------------------------------------------------------
}
int CMultiLineDefect::OnAutoBevelIn()// Line기준 실제 검사 함수 
{
	EImageEncoder CodeImageEncoder     ;
	ECodedImage2  CodeImage            ;
	EObjectSelection CodeImageSelection;
    EROIBW8   DefectROI                ;

	int ROI_X =0;
	int ROI_Y =0;
	int ROI_W =0;
	int ROI_H =0;

	// Circle Dis, Dv TEST 
	double MaxDis =0.0f     ;
	double MinDis =10000.0f ;
	double MaxDv  =0.0f     ;
	double MinDv  =10000.0f ;
	double StdMaxDis =0.0f     ;
	double StdMinDis =10000.0f ;
	int    MinCirCount =0;

	for(int k=0; k<256; k++){
		PixelData[k] =0;
	}

    int Index = 0;
	// 광원 Defect 검사 시퀀스 
	if (FShape==shRect8                                           && FCompanyMode==COM_KWON  ) {Index = 0;                                                            }
	if (FShape==shRectH                                           && FCompanyMode==COM_KWON  ) {
		if(ImgDegree==0.0f) EasyImage::Threshold(GImage    ,&DefectImg, EnCapTopThresHold);
		else                EasyImage::Threshold(&RotateImg,&DefectImg, EnCapTopThresHold); //DefectImg.Save("D:\\ROTATE_IMG\\DefectImg_Binary_HAP.bmp");
		Index = 1; 
	}
	if (FShape==shRectC                                           && FCompanyMode==COM_KWON  ) {
		if(ImgDegree==0.0f) EasyImage::Threshold(GImage    ,&DefectImg, EnCapBtmThresHold);
		else                EasyImage::Threshold(&RotateImg,&DefectImg, EnCapBtmThresHold); //DefectImg.Save("D:\\ROTATE_IMG\\DefectImg_Binary_CUP.bmp");
		Index = 2; 
	}
    if (FShape==shRectS                                           && FCompanyMode==COM_KWON  ) {Index = 3;    
	}
	// TIANMA Defect 검사 시퀀스 
	if((FShape==shRectHL || FShape==shRectSL || FShape==shRectCL) && FCompanyMode==COM_TIANMA) Index =4; // TIANMA Edge Inspection(All Inspection     )  ImageCopy -> ImageConversion -> ROI Attatch 
	if( FShape==shRectTOP                                         && FCompanyMode==COM_TIANMA) Index =5; // TIANMA Edge Inspection(Only Top Inspection)  Short Cell Cam0
	if( FShape==shRectBTM                                         && FCompanyMode==COM_TIANMA) Index =6; // TIANMA Edge Inspection(Only Btm Inspection)  Short Cell Cam1

	// BOE Defect 검사 시퀀스 
	if( FShape==shRectHL                                          && FCompanyMode==COM_BOE   ) Index =7; // BOE Edge Inspection(All Inspection     )  ImageCopy -> ImageConversion -> ROI Attatch 
	if( FShape==shRectSL                                          && FCompanyMode==COM_BOE   ) Index =8; // BOE Edge Inspection(Only Top Inspection)  Short Cell Cam0
	if( FShape==shRectCL                                          && FCompanyMode==COM_BOE   ) Index =9; // BOE Edge Inspection(Only Btm Inspection)  Short Cell Cam1

	// NOTCH Defect 검사 시퀀스 
	if( FShape==shRectH                                           && FCompanyMode==COM_NOTCH ){ // NOTCH Edge Inspection(All Inspection     )  ImageCopy -> ImageConversion -> ROI Attatch 
		if(ImgDegree==0.0f) EasyImage::Threshold(GImage    ,&DefectImg, EnCapTopThresHold);
		else                EasyImage::Threshold(&RotateImg,&DefectImg, EnCapTopThresHold); //DefectImg.Save("D:\\ROTATE_IMG\\DefectImg_Binary_HAP.bmp");
		Index =10;   
	}                                                                                                     
	if( FShape==shRectS                                           && FCompanyMode==COM_NOTCH ){
		                    EasyImage::Threshold(GImage    ,&DefectImg, EnCapMidThresHold);
		Index =11;                                                                              // NOTCH Edge Inspection(Only Top Inspection)  Short Cell Cam0
	}
	if( FShape==shRectC                                          && FCompanyMode==COM_NOTCH ){ // NOTCH Edge Inspection(All Inspection     )  ImageCopy -> ImageConversion -> ROI Attatch 
		if(ImgDegree==0.0f) EasyImage::Threshold(GImage    ,&DefectImg, EnCapBtmThresHold);
		else                EasyImage::Threshold(&RotateImg,&DefectImg, EnCapBtmThresHold); //DefectImg.Save("D:\\ROTATE_IMG\\DefectImg_Binary_HAP.bmp");
		Index =12;   
	}    
	// BMDT Defect 검사 시퀀스 
	if( FShape==shRectH                                           && FCompanyMode==COM_BMDT ){ //ImageCopy -> ImageConversion -> ROI Attatch 
		if(ImgDegree==0.0f) EasyImage::Threshold(GImage    ,&DefectImg, EnCapTopThresHold);
		else                EasyImage::Threshold(&RotateImg,&DefectImg, EnCapTopThresHold); //DefectImg.Save("D:\\ROTATE_IMG\\DefectImg_Binary_HAP.bmp");
		Index =13;   
	}                                                                                                     
	if( FShape==shRectS                                           && FCompanyMode==COM_BMDT ){
		EasyImage::Threshold(GImage    ,&DefectImg, EnCapMidThresHold);
		Index =14;                                                                              // NOTCH Edge Inspection(Only Top Inspection)  Short Cell Cam0
	}
	if( FShape==shRectC                                           && FCompanyMode==COM_BMDT ){ // NOTCH Edge Inspection(All Inspection     )  ImageCopy -> ImageConversion -> ROI Attatch 
		if(ImgDegree==0.0f) EasyImage::Threshold(GImage    ,&DefectImg, EnCapBtmThresHold);
		else                EasyImage::Threshold(&RotateImg,&DefectImg, EnCapBtmThresHold); //DefectImg.Save("D:\\ROTATE_IMG\\DefectImg_Binary_HAP.bmp");
		Index =15;   
	}                                                                                                     


	// Pixel 내부Data 추출 Buffer넘겨줌 
	//IAddress = DefectImg.GetImagePtr();
	int PixelValue;
	int PixelCount;

	// 광원 Btm OverKill방지 목적 
	int BTMLine =0;
	int TotalPixel =0;

	// Frit OverKill Remove Value
	int    MaxPixel   =0;
	int    MaxData    =0;
	int    CurData    =0;
	int    BrokenPixel =0;
	int    CrackPixel  =0;
	const int LongBrokenMargin   =7500;
	const int LongCrackMargin    =10  ;
// 	const int ShortBrokenMargin  =7500;
	const int ShortCrackMargin   =25  ;

	// Burr & Remain
	int BurrWidth =100;

	// Left Line Dv 
	double LeftDv =0.0f;

    bool l  = false; bool lt = false;
    bool t  = false; bool rt = false;
    bool r  = false; bool rb = false;
    bool b  = false; bool lb = false;

	// LeftLimit Remove Blob
	bool IsRemoveBlob = true;
    int dx=FEscapeDeviation, dy=FEscapeDeviation;

    int ImgW   = GImage->GetWidth();
    int ImgH   = GImage->GetHeight();
	ImageWidth = GImage->GetWidth();;

	int Count1=0, Count2=0, Count3=0, Count4=0, Count5=0;

	//Euresys Blob Parameter Setting 
	//////////////////////////////////////////////////
    // KWON,CNC_6HEAD 이미지 변환 후 기본설정 진행 
	if((FShape==shRectH || FShape==shRectS || FShape==shRectC || FShape==shRectTOP || FShape==shRectBTM)){
		DefectROI.Attach(&DefectImg);
		CodeImageSelection.SetFeretAngle(0.00f);
		CodeImageEncoder.GetGrayscaleSingleThresholdSegmenter().SetWhiteLayerEncoded(false);
		CodeImageEncoder.GetGrayscaleSingleThresholdSegmenter().SetBlackLayerEncoded(true );

		IAddress = DefectImg.GetImagePtr();
	}
    //////////////////////////////////////////////////
	// Corner Insp Pixel Value 
	if((FShape==shRectHL || FShape==shRectCL) && (FCompanyMode==COM_BOE)){
		DefectROI.Attach(&DefectImg);
		CodeImageSelection.SetFeretAngle(0.00f);
		CodeImageEncoder.GetGrayscaleSingleThresholdSegmenter().SetWhiteLayerEncoded(false);
		CodeImageEncoder.GetGrayscaleSingleThresholdSegmenter().SetBlackLayerEncoded(true );

		IAddress = DefectImg.GetImagePtr();
	}

    TFPoint LT(0          ,           0);
    TFPoint RT((float)ImgW,           0);
    TFPoint RB((float)ImgW, (float)ImgH);
    TFPoint LB(0          , (float)ImgH);
    TFPoint SP, EP, LSP, LEP, RSP, REP  ;

	// Notch Cell Size 측정 
	TFPoint NotchCenterPos(0.0f, 0.0f);

	// ROI 영역 설정
	int LeftHeight ;
	int RightHeight;
	int TopWidth   ;
	int BtmWidth   ;
	int BlobCount  ;
	const int Margin =15;

	// ImageRotate 불량 발생함 OverKill 감소 목적
	const int TopMargin =10;
	const int BtmMargin =30;

	// 컵영역 직사각형 형태일경우 단차로 인해서 불량이 패턴과 붙어서
	// 검사시 검출 불가함...이로인해서 Offset추가함 
	const int BtmInspOffset = 6;

	// Corner Data 
	int CornerCount  =0;
    int MarktoBmLine =0;

	//Circle Count,Avg Round 
	int CircleCount=0;
	float AvgCirDis   =0.0f;
	float TotalCirDis =0.0f;

	// Merge Margin
	const int xMerge  =30;
	const int yMerge  =30;
    const int MgCount =3;

	//Remain Offset 
	const int RemainMargin = 30;
	const int BmLineMargin = 30;

	// BM Line Check
	float RightBMGab=0;
	float LeftBMGab =0;

	// Side Offset Margin
	int SideMargin =1;

	// Margin Filter
	const int BroMarginWidth  = 200;
	const int BroMarginHeight = 200;

	// GrindMark 각도 적용하여 회전목적(검사화면 디스플레이)
	TFPoint LtPos, RbPos;

    PLW0.x = Line[waLeftWall   ].FP0.x; PLW0.y = Line[waLeftWall   ].FP0.y;
    PLW1.x = Line[waLeftWall   ].FP1.x; PLW1.y = Line[waLeftWall   ].FP1.y;
    PTW0.x = Line[waTopWall    ].FP0.x; PTW0.y = Line[waTopWall    ].FP0.y;
    PTW1.x = Line[waTopWall    ].FP1.x; PTW1.y = Line[waTopWall    ].FP1.y;
    PRW0.x = Line[waRightWall  ].FP0.x; PRW0.y = Line[waRightWall  ].FP0.y;
    PRW1.x = Line[waRightWall  ].FP1.x; PRW1.y = Line[waRightWall  ].FP1.y;
    PBW0.x = Line[waBottomWall ].FP0.x; PBW0.y = Line[waBottomWall ].FP0.y;
    PBW1.x = Line[waBottomWall ].FP1.x; PBW1.y = Line[waBottomWall ].FP1.y;


    InLTPoint.x = FLTPoint.x+dx; InLTPoint.y = FLTPoint.y+dy;
    InRTPoint.x = FRTPoint.x-dx; InRTPoint.y = FRTPoint.y+dy;
    InRBPoint.x = FRBPoint.x-dx; InRBPoint.y = FRBPoint.y-dy;
    InLBPoint.x = FLBPoint.x+dx; InLBPoint.y = FLBPoint.y-dy;

    InLTLPoint = Math.OnIntersect(PLW0, PLW1, FLTLPoint, Math.OnRotate(FLTLPoint, FLTTPoint, 90));
    InLTTPoint = Math.OnIntersect(PTW0, PTW1, FLTTPoint, Math.OnRotate(FLTTPoint, FLTLPoint, 90));
    InRTRPoint = Math.OnIntersect(PRW0, PRW1, FRTRPoint, Math.OnRotate(FRTRPoint, FRTTPoint, 90));
    InRTTPoint = Math.OnIntersect(PTW0, PTW1, FRTTPoint, Math.OnRotate(FRTTPoint, FRTRPoint, 90));
    InRBRPoint = Math.OnIntersect(PRW0, PRW1, FRBRPoint, Math.OnRotate(FRBRPoint, FRBBPoint, 90));
    InRBBPoint = Math.OnIntersect(PBW0, PBW1, FRBBPoint, Math.OnRotate(FRBBPoint, FRBRPoint, 90));
    InLBLPoint = Math.OnIntersect(PLW0, PLW1, FLBLPoint, Math.OnRotate(FLBLPoint, FLBBPoint, 90));
    InLBBPoint = Math.OnIntersect(PBW0, PBW1, FLBBPoint, Math.OnRotate(FLBBPoint, FLBLPoint, 90));


	// 검사 ROI 설정 
    // RectH : 모자모양
	// Defect 검사 전 기준라인 기준 검사영역 재설정
	// 외관검사기 검사 영역 설정 
    //------------------------------------------------------------------
    if (FShape==shRectH && FCompanyMode==COM_KWON) {
        SP = Math.OnIntersect(PLW0, PLW1, LB, RB);
        EP = Math.OnIntersect(PRW0, PRW1, LB, RB);

		if(IsCornerTop){
			FLeftWidth  =(int)(((FRTRPoint.x - FLTLPoint.x)/2) - Margin);
			FRightWidth =(int)(((FRTRPoint.x - FLTLPoint.x)/2) - Margin);
			FTopHeight  =(int)(((FLTLPoint.y - FLTTPoint.y)  ) - Margin);
			LeftHeight  =(int)(SP.y - FLTLPoint.y);
			RightHeight =(int)(EP.y - FRTRPoint.y);
			TopWidth    =(int)(FRTTPoint.x - FLTTPoint.x);
		}
		else {
			FLeftWidth  =(int)(((FRTPoint.x - FLTPoint.x)/2) - Margin);
			FRightWidth =(int)(((FRTPoint.x - FLTPoint.x)/2) - Margin);
 			//FTopHeight  =(int)(((SP.y)      - FLTPoint.y   ) - Margin);
 			FTopHeight  =(int)(((SP.y)      - (((TopBMLine[0].FP0.y+TopBMLine[0].FP1.y)/2)-TopOffset)) - Margin);
			LeftHeight  =(int)(SP.y - FLTPoint.y);
			RightHeight =(int)(EP.y - FRTPoint.y);
			TopWidth    =(int)(FRTPoint.x - FLTPoint.x);
		}


		DefectPointCount = 0; // 전체 불량 개수 초기화
		BCount           = 0; // B_SIDE  불량 포인트 개수
		ACount           = 0; // A_SIDE  불량 포인트 개수
		CCount           = 0; // C_SIDE  불량 포인트 개수
		DCount           = 0; // D_SIDE  불량 포인트 개수
		C1Count          = 0; // C1_SIDE 불량 포인트 개수
		C2Count          = 0; // C2_SIDE 불량 포인트 개수
		C3Count          = 0; // C3_SIDE 불량 포인트 개수
		C4Count          = 0; // C4_SIDE 불량 포인트 개수
		ABurrCount       = 0;
		BBurrCount       = 0;
		CBurrCount       = 0;
		DBurrCount       = 0;

    }
    // RectC : 컵모양
	// Defect 검사 전 기준라인 기준 검사영역 재설정
    //------------------------------------------------------------------
    if (FShape==shRectC && FCompanyMode==COM_KWON) {
        //SP = Math.OnIntersect(PLW0, PLW1, LT, RT);
        //EP = Math.OnIntersect(PRW0, PRW1, LT, RT);

		// BM Line 못찾을경우 
		if(BMLineDistance!=0){
			LeftBMGab   = (LeftBMLine[0].FP0.x + LeftBMLine[0].FP1.x )/2;
			RightBMGab  = (RightBMLine[0].FP0.x+ RightBMLine[0].FP1.x)/2;
			if(fabs(RightBMGab-LeftBMGab) <(BMLineDistance-20)){
				if((LeftBMGab -Line[0].FP0.x) >BmLineMargin){
					LeftBMLine[0].FP0.x = RightBMLine[0].FP0.x - BMLineDistance;
					LeftBMLine[0].FP0.y = RightBMLine[0].FP0.y                 ;
					LeftBMLine[0].FP1.x = RightBMLine[0].FP1.x - BMLineDistance;
					LeftBMLine[0].FP1.y = RightBMLine[0].FP1.y                 ;
				}
				else if((Line[2].FP0.x -RightBMGab)>BmLineMargin){
					RightBMLine[0].FP0.x = LeftBMLine[0].FP0.x + BMLineDistance;
					RightBMLine[0].FP0.y = LeftBMLine[0].FP0.y                 ;
					RightBMLine[0].FP1.x = LeftBMLine[0].FP1.x + BMLineDistance;
					RightBMLine[0].FP1.y = LeftBMLine[0].FP1.y                 ;
				}
			}
		}


		if(InspectMode){ //Size 기준 검사 
			// BMLine기준으로 검사영역 다시 설정함 
			SP = Math.OnIntersect(LeftBMLine[0].FP0 , LeftBMLine[0].FP1 , LT, RT);
			EP = Math.OnIntersect(RightBMLine[0].FP0, RightBMLine[0].FP1, LT, RT);
		}
		else {          // 외곽 기준 검사 
			SP = Math.OnIntersect(PLW0, PLW1, LT, RT);
			EP = Math.OnIntersect(PRW0, PRW1, LT, RT);
		}


		if(IsCornerBtm){
			FLeftWidth   = (int)(((EP.x - SP.x)/2) - Margin);
			FRightWidth  = (int)(((EP.x - SP.x)/2) - Margin);
			//FBtmHeight   = (int)((FLBBPoint.y - FLBLPoint.y) - Margin);
			FBtmHeight   = (int)(((FLBBPoint.y+FRBBPoint.y)/2) -((FLBLPoint.y+FRBRPoint.y)/2) - Margin);
			LeftHeight   = (int)(FLBLPoint.y - SP.y);
			RightHeight  = (int)(FRBRPoint.y - EP.y);
			BtmWidth     = (int)(FRBBPoint.x - FLBBPoint.x);
		}
		else {
			FLeftWidth   = (int)(((EP.x - SP.x)/2) - Margin);
			FRightWidth  = (int)(((EP.x - SP.x)/2) - Margin);
			FBtmHeight   = (int)(((FLBPoint.y+FRBPoint.y)/2) - ((SP.y+EP.y)/2) - Margin);
			LeftHeight   = (int)((FLBPoint.y) - SP.y);
			RightHeight  = (int)((FRBPoint.y) - EP.y);
			BtmWidth     = (int)(FRBPoint.x - FLBPoint.x);
		}

    }
    // RectS : 젓가락 모양
	// Defect 검사 전 기준라인 기준 검사영역 재설정
    //------------------------------------------------------------------
    if (FShape==shRectS && FCompanyMode==COM_KWON) {
        //LSP = Math.OnIntersect(PLW0, PLW1, LT, RT);
        //LEP = Math.OnIntersect(PLW0, PLW1, LB, RB);

        //RSP = Math.OnIntersect(PRW0, PRW1, LT, RT);
        //REP = Math.OnIntersect(PRW0, PRW1, LB, RB);

		// BM Line 못찾을경우 
		if(BMLineDistance!=0){
			LeftBMGab   = (LeftBMLine[0].FP0.x + LeftBMLine[0].FP1.x )/2;
			RightBMGab  = (RightBMLine[0].FP0.x+ RightBMLine[0].FP1.x)/2;
			if(fabs(RightBMGab-LeftBMGab) <(BMLineDistance-20)){
				if((LeftBMGab -Line[0].FP0.x) >BmLineMargin){
					LeftBMLine[0].FP0.x = RightBMLine[0].FP0.x - BMLineDistance;
					LeftBMLine[0].FP0.y = RightBMLine[0].FP0.y                 ;
					LeftBMLine[0].FP1.x = RightBMLine[0].FP1.x - BMLineDistance;
					LeftBMLine[0].FP1.y = RightBMLine[0].FP1.y                 ;
				}
				else if((Line[2].FP0.x -RightBMGab)>BmLineMargin){
					RightBMLine[0].FP0.x = LeftBMLine[0].FP0.x + BMLineDistance;
					RightBMLine[0].FP0.y = LeftBMLine[0].FP0.y                 ;
					RightBMLine[0].FP1.x = LeftBMLine[0].FP1.x + BMLineDistance;
					RightBMLine[0].FP1.y = LeftBMLine[0].FP1.y                 ;
				}
			}
		}

		if(InspectMode){   // Size 기준 검사 
			// BMLine 기준으로 영역을 다시 설정함 
			LSP = Math.OnIntersect(LeftBMLine[0].FP0, LeftBMLine[0].FP1, LT, RT);
			LEP = Math.OnIntersect(LeftBMLine[0].FP0, LeftBMLine[0].FP1, LB, RB);
			
			RSP = Math.OnIntersect(RightBMLine[0].FP0, RightBMLine[0].FP1, LT, RT);
			REP = Math.OnIntersect(RightBMLine[0].FP0, RightBMLine[0].FP1, LB, RB);
		}
		else {             // 외곽 기준 검사 
			LSP = Math.OnIntersect(PLW0, PLW1, LT, RT);
			LEP = Math.OnIntersect(PLW0, PLW1, LB, RB);
			
			RSP = Math.OnIntersect(PRW0, PRW1, LT, RT);
			REP = Math.OnIntersect(PRW0, PRW1, LB, RB);
		}
        
		// Cell 틀어져 있을경우 
// 		if((fabs(LSP.x - LEP.x)>Margin) || (fabs(RSP.x - REP.x)>Margin) ){
//             LSP.x = (LSP.x+LEP.x)/2.0f;
// 			RSP.x = (RSP.x+REP.x)/2.0f;
// 		}

		// 20160511
		if((fabs(LSP.x - LEP.x)>Margin) || (fabs(RSP.x - REP.x)>Margin) ){
            LSP.x = (LSP.x>LEP.x) ? LSP.x : LEP.x;
			RSP.x = (RSP.x>REP.x) ? REP.x : RSP.x;
		}
		// Blob
		FLeftWidth   = (int)(((RSP.x - LSP.x)/2) - Margin);
		FRightWidth  = (int)(((RSP.x - LSP.x)/2) - Margin);
		LeftHeight   = (int)(LEP.y - LSP.y);
		RightHeight  = (int)(REP.y - RSP.y);

    }

	// 검사 ROI 설정 
	// EdgeInspection
	// Crack & Broken InLine기준으로 검사한다 
	// Burr OutLine기준으로 검사한다 
	// Defect 검사 전 기준라인 기준 검사영역 재설정
	//-----------------------------------------------------------------
	if(FShape==shRectHL && FCompanyMode==COM_TIANMA){
		if(IsMarkLine){ // 단축 Cam0, Cam1
			LeftDv = fabs(PLW0.x -PLW1.x);
			if(LeftDv>20){
				LSP.x = StartLeft                         ;
				LSP.y = FLTPoint.y+IgnoreOffset           ;
				LEP = Math.OnIntersect(PLW0, PLW1, LB, RB);
				FLeftWidth = 500;
				LeftHeight = (int)(LEP.y - LSP.y);
				IsRemoveBlob = false;
			}
            else {
				if(IsMarkBtm){
					if(GrindCheck){  // 단축 Cam0
						LSP.x = InLine[0].FP0.x          ;
						LSP.y = FLTPoint.y +IgnoreOffset ;
						LEP = Math.OnIntersect(InLine[0].FP0, InLine[0].FP1, LB, RB);
						FLeftWidth = 500;
						LeftHeight = (int)(LEP.y - LSP.y);
					}
				}
				else {
					if(GrindCheck){
						LSP.x = InLine[0].FP0.x          ;
						LSP.y = FLTPoint.y +IgnoreOffset ;
						LEP = Math.OnIntersect(InLine[0].FP0, InLine[0].FP1, LB, RB);
						FLeftWidth = 500;
						LeftHeight = (int)(LEP.y - LSP.y);
						
					}
					else {
						LSP.x = FLTPoint.x                        ;
						LSP.y = FLTPoint.y+IgnoreOffset           ;
						LEP = Math.OnIntersect(PLW0, PLW1, LB, RB);
						FLeftWidth = 500;
						LeftHeight = (int)(LEP.y - LSP.y);
					}
				}
			}
		}
		else if(IsLongTop){ // 장축 Cam0, Cam1, Cam2, Cam3 
			LeftDv = fabs(PLW0.x -PLW1.x);
			if(LeftDv>20){
				LSP.x = StartLeft                         ;
				LSP.y = FLTPoint.y+IgnoreOffset           ;
				LEP = Math.OnIntersect(PLW0, PLW1, LB, RB);
				FLeftWidth = 500;
				LeftHeight = (int)(LEP.y - LSP.y);
				IsRemoveBlob = false;
			}
            else {
				if(GrindCheck){  
					LSP.x = FLTPoint.x                        ;
					LSP.y = FLTPoint.y+IgnoreOffset           ;
					LEP = Math.OnIntersect(PLW0, PLW1, LB, RB);
					FLeftWidth = 500;
					LeftHeight = (int)(LEP.y - LSP.y);
				}
			}
		}
		else { // 단축 Cam2, Cam3
			if(GrindOutIn){
				LSP.x = InLine[0].FP0.x          ;
				LSP.y = FLTPoint.y +IgnoreOffset ;
				LEP = Math.OnIntersect(InLine[0].FP0, InLine[0].FP1, LB, RB);
				FLeftWidth = 300;
				LeftHeight = (int)(LEP.y - LSP.y);
			}
			else { // BMLine 기준 검사영역 다시 설정
				LSP.x = BMLine[0].FP0.x -LeftOffset;
				LSP.y = FLTPoint.y +IgnoreOffset   ;
				LEP   = Math.OnIntersect(BMLine[0].FP0, BMLine[0].FP1, LB, RB);
				LEP.x = LEP.x - LeftOffset;
				FLeftWidth = 300;
				LeftHeight = (int)(LEP.y - LSP.y);
			}
		}
		// Defect Count IniData
// 		BurrCount   = 0;
// 		CrackCount  = 0;
// 	    BrokenCount = 0;
// 
		//Defect Max Value Spec Init
		FBrokenMaxWidth   =1000;
		FBrokenMaxHeight  =1000;
		FBurrMaxWidth     =1000;
		FBurrMaxHeight    =1000;
		FChippingMaxWidth =1000;
		FChippingMaxHeight=1000;
	}
	// Defect 검사 전 기준라인 기준 검사영역 재설정
	if(FShape==shRectSL && FCompanyMode==COM_TIANMA){
		if(IsMarkLine){ //단축 Cam0, Cam1 
			if(GrindCheck){
				LSP = Math.OnIntersect(InLine[0].FP0, InLine[0].FP1, LT, RT);
				LEP = Math.OnIntersect(InLine[0].FP0, InLine[0].FP1, LB, RB);
				FLeftWidth = 500;
				LeftHeight = (int)(LEP.y - LSP.y);
			}
			else {
				LSP = Math.OnIntersect(PLW0, PLW1, LT, RT);
				LEP = Math.OnIntersect(PLW0, PLW1, LB, RB);
				FLeftWidth = 500;
				LeftHeight = (int)(LEP.y - LSP.y);
			}
		}
		else if(!IsBmLine && IsLongTop){
			LSP = Math.OnIntersect(PLW0, PLW1, LT, RT);
			LEP = Math.OnIntersect(PLW0, PLW1, LB, RB);
			FLeftWidth = 500;
			LeftHeight = (int)(LEP.y - LSP.y);
		}
		else { // 단축 Cam2, Cam3, 장축 Cam0, Cam1, Cam2, Cam3 
			if(GrindOutIn){
				LSP = Math.OnIntersect(InLine[0].FP0, InLine[0].FP1, LT, RT);
				LEP = Math.OnIntersect(InLine[0].FP0, InLine[0].FP1, LB, RB);
				FLeftWidth = 300;
				LeftHeight = (int)(LEP.y - LSP.y);
			}
            else { // BMLine 기준 검사영역 다시 설정
				LSP = Math.OnIntersect(BMLine[0].FP0, BMLine[0].FP1, LT, RT);
				LEP = Math.OnIntersect(BMLine[0].FP0, BMLine[0].FP1, LB, RB);

				// Cell Mis Align => Inspection ROI Avg Change
				if(fabs(LSP.x - LEP.x) >10){
					if(LSP.x>LEP.x){ LSP.x = LEP.x +((LSP.x - LEP.x)/2);}
					if(LSP.x<LEP.x){ LSP.x = LSP.x +((LEP.x - LSP.x)/2);}
				}

				LSP.x = LSP.x - LeftOffset;
				LEP.x = LEP.x - LeftOffset;
				FLeftWidth = 300;
				LeftHeight = (int)(LEP.y - LSP.y);
            }
		}
	}
	// Defect 검사 전 기준라인 기준 검사영역 재설정
	if(FShape==shRectCL && FCompanyMode==COM_TIANMA){
		if(IsMarkLine){
			if(GrindCheck){
				LSP = Math.OnIntersect(InLine[0].FP0, InLine[0].FP1, LT, RT);
				LEP.x = InLine[0].FP1.x          ;
				LEP.y = FLBPoint.y -IgnoreOffset ;
				FLeftWidth = 500;
				LeftHeight = (int)(LEP.y - LSP.y);
			}
			else {
				LSP = Math.OnIntersect(PLW0, PLW1, LT, RT);
				LEP.x = InLine[0].FP1.x          ;
				LEP.y = FLBPoint.y -IgnoreOffset ;
				FLeftWidth = 500;
				LeftHeight = (int)(LEP.y - LSP.y);
			}
		}
		else { //단축 Cam2, Cam3 장축 Cam0, Cam1, Cam2, Cam3 
			if(GrindOutIn){
				LSP = Math.OnIntersect(InLine[0].FP0, InLine[0].FP1, LT, RT);
				LEP.x = InLine[0].FP1.x          ;
				LEP.y = FLBPoint.y -IgnoreOffset ;
				FLeftWidth = 300;
				LeftHeight = (int)(LEP.y - LSP.y);
			}
			else { // BMLine 기준 검사영역 다시 설정
				LSP = Math.OnIntersect(BMLine[0].FP0, BMLine[0].FP1, LT, RT);
				LSP.x = LSP.x           - LeftOffset ;
				LEP.x = BMLine[0].FP1.x - LeftOffset ;
				LEP.y = FLBPoint.y      -IgnoreOffset;
				FLeftWidth = 300;
				LeftHeight = (int)(LEP.y - LSP.y);
				if(LeftHeight>BtmLimitLine) LeftHeight = BtmLimitLine;
			}
		}
	}
	// Defect 검사 전 기준라인 기준 검사영역 재설정
	if(FShape==shRectTOP && FCompanyMode==COM_TIANMA){ // 단축 Cam0, Cam1 모자 
		if(IsMarkBtm){
			LSP.x       = (float)nTopBtmStart                         ;
			LSP.y       = (Line[1].FP0.y+Line[1].FP1.y)/2+IgnoreOffset;
			LEP.x       =  Line[1].FP1.x                              ;
			LEP.y       = (Line[1].FP0.y+Line[1].FP1.y)/2             ;
			FTopHeight  = (int)(ImgH - LSP.y)                         ;
		}
		else {
			LSP.x       = (float)nTopBtmStart                         ;
			LSP.y       = (Line[1].FP0.y+Line[1].FP1.y)/2+IgnoreOffset;
			LEP.x       =  LSP.x +150                                 ;
			LEP.y       = (Line[1].FP0.y+Line[1].FP1.y)/2             ;
			FTopHeight  = (int)(ImgH - LSP.y)                         ;
		}
    }
	// Defect 검사 전 기준라인 기준 검사영역 재설정
	if(FShape==shRectBTM && FCompanyMode==COM_TIANMA){ // 단축 Cam0, Cam1 컵  
		if(IsMarkBtm){
			LSP.x       = (float)nTopBtmStart            ;
			LSP.y       = (Line[3].FP0.y+Line[3].FP1.y)/2;
			LEP.x       =  Line[3].FP1.x                 ;
			LEP.y       = (Line[3].FP0.y+Line[3].FP1.y)/2;
			FTopHeight  = (int)(LSP.y -10);
		}
		else {
			LSP.x       = (float)nTopBtmStart            ;
			LSP.y       = (Line[3].FP0.y+Line[3].FP1.y)/2;
			LEP.x       =  LSP.x +150                    ;
			LEP.y       = (Line[3].FP0.y+Line[3].FP1.y)/2;
			FTopHeight  = (int)(LSP.y -10);
		}
	}

	// BOE 검사 시퀀스 영역 재설정 
	// Defect 검사 전 기준라인 기준 검사영역 재설정
	if(FShape==shRectHL && FCompanyMode==COM_BOE){
		if(IsCornerTop){
			LSP.x = InLine[0].FP0.x +InspOffset;
			LSP.y = FLTLPoint.y +IgnoreOffset  ;
			LEP   = Math.OnIntersect(InLine[0].FP0, InLine[0].FP1, LB, RB);

			//ROI영역의 Width, Height 크기설정
			FLeftWidth = 500;
			LeftHeight = (int)(LEP.y - LSP.y);
		}
		else           {
			LSP.x = InLine[0].FP0.x +InspOffset;
			LSP.y = FLTPoint.y +IgnoreOffset  ;
			LEP   = Math.OnIntersect(InLine[0].FP0, InLine[0].FP1, LB, RB);

			//ROI영역의 Width, Height 크기설정
			FLeftWidth = 500;
			LeftHeight = (int)(LEP.y - LSP.y);
		}
		// Top Inspection
		FTopHeight = (int)(((FLTLPoint.y - FLTTPoint.y)) - Margin);
		TopWidth   = 300;

		//Defect Max Value Spec Init
		FBrokenMaxWidth   =1000;
		FBrokenMaxHeight  =1000;
		FBurrMaxWidth     =1000;
		FBurrMaxHeight    =1000;
		FChippingMaxWidth =1000;
		FChippingMaxHeight=1000;
		C1Count           = 0;
		C3Count           = 0;
	}
	// Defect 검사 전 기준라인 기준 검사영역 재설정
	if(FShape==shRectSL && FCompanyMode==COM_BOE){
		LSP = Math.OnIntersect(InLine[0].FP0, InLine[0].FP1, LT, RT);
		LEP = Math.OnIntersect(InLine[0].FP0, InLine[0].FP1, LB, RB);

		// Inspect Roi Offset 
		LSP.x = LSP.x+InspOffset;

		//ROI영역의 Width, Height 크기설정
		FLeftWidth = 500;
		LeftHeight = (int)(LEP.y - LSP.y);
	}
	// Defect 검사 전 기준라인 기준 검사영역 재설정
	if(FShape==shRectCL && FCompanyMode==COM_BOE){
		if(IsCornerBtm){
			LSP   = Math.OnIntersect(InLine[0].FP0, InLine[0].FP1, LT, RT);
			// Inspect Roi Offset 
			LSP.x = LSP.x+InspOffset;

			LEP.x = InLine[0].FP1.x          ;
			LEP.y = FLBLPoint.y -IgnoreOffset;
		}
		else           {
			LSP   = Math.OnIntersect(InLine[0].FP0, InLine[0].FP1, LT, RT);
			// Inspect Roi Offset 
			LSP.x = LSP.x+InspOffset;

			LEP.x = InLine[0].FP1.x          ;
			LEP.y = FLBPoint.y -IgnoreOffset;
		}
		//ROI영역의 Width, Height 크기설정
		FLeftWidth = 500                 ;
		LeftHeight = (int)(LEP.y - LSP.y);

		FBtmHeight   = (int)((FLBBPoint.y -FLBLPoint.y) - IgnoreOffset);
		BtmWidth     = 300;
	}

	// Notch Cell 모자 검사 
	if(FShape==shRectH && FCompanyMode==COM_NOTCH){
		SP = Math.OnIntersect(LeftOutLine [0].FP0, LeftOutLine [0].FP1, LB, RB);
		EP = Math.OnIntersect(RightOutLine[0].FP0, RightOutLine[0].FP1, LB, RB);

		FLeftWidth  =200;
		FRightWidth =200;
		FTopHeight  =200;

		if(IsCornerTop)     { //Corner Cutting일경우 Defect검사 영역 설정 
			TopWidth    =(int)(FRTTInPoint.x - FLTTInPoint.x); // TOP검사 진행시 양쪽 끝에 오버킬 감소 목적 
			LeftHeight  =(int)(SP.y - FLTLInPoint.y);
			RightHeight =(int)(EP.y - FRTRInPoint.y);
		}
		else if(IsRectTop)  {//Corner Cutting 없을경우 Defect검사 영역 설정 
			TopWidth    =(int)(FRTPoint.x - FLTPoint.x); // TOP검사 진행시 양쪽 끝에 오버킬 감소 목적 
			LeftHeight  =(int)(SP.y - FLTPoint.y);
			RightHeight =(int)(EP.y - FRTPoint.y);
		}
		else if(IsCircleTop){//Circle Cutting일경우 Defect 검사 영역 설정 
			if(TopEdgePoint[0].x==0 || TopEdgePoint[0].y==0) {
				TopEdgePoint[0].x = (int)FLTPoint.x                     ; 
				TopEdgePoint[0].y = (int)FLTPoint.y+ASideCircleHeight+10;
			}
			if(TopEdgePoint[1].x==0 || TopEdgePoint[1].y==0) {
				TopEdgePoint[1].x = (int)FLTPoint.x+ASideCircleWidth+10; 
				TopEdgePoint[1].y = (int)FLTPoint.y                    ;
			}
			if(TopEdgePoint[2].x==0 || TopEdgePoint[2].y==0) {
				TopEdgePoint[2].x = (int)FRTPoint.x -ASideCircleWidth-10; 
				TopEdgePoint[2].y = (int)FRTPoint.y                     ;
			}
			if(TopEdgePoint[3].x==0 || TopEdgePoint[3].y==0) {
				TopEdgePoint[3].x = (int)FRTPoint.x                     ; 
				TopEdgePoint[3].y = (int)FRTPoint.y+ASideCircleHeight+10;
			}
			TopWidth    =(int)(TopEdgePoint[2].x - TopEdgePoint[1].x); // TOP검사 진행시 양쪽 끝에 오버킬 감소 목적   
			LeftHeight  =(int)(SP.y - TopEdgePoint[0].y);                                                             
			RightHeight =(int)(EP.y - TopEdgePoint[3].y);
		}

		// Defect Data Init 
		DefectPointCount = 0; // 전체 불량 개수 초기화
		BCount           = 0; // B_SIDE  불량 포인트 개수
		ACount           = 0; // A_SIDE  불량 포인트 개수
		CCount           = 0; // C_SIDE  불량 포인트 개수
		DCount           = 0; // D_SIDE  불량 포인트 개수
// 		C1CirDeftectCnt  = 0;
		C2CirDeftectCnt  = 0;
		C3CirDeftectCnt  = 0;
		C4CirDeftectCnt  = 0;
		C5CirDeftectCnt  = 0;
		C6CirDeftectCnt  = 0;
		ABurrCount       = 0;
		BBurrCount       = 0;
		CBurrCount       = 0;
		DBurrCount       = 0;

		// BSide, DSide Defect 검사시 Margin값 설정 
		if(AlignMark1.y!=0.0f && AlignMark2.y!=0.0f){
			if(AlignMark1.y>AlignMark2.y){
				LeftDegMargin  = (int)((AlignMark1.y - AlignMark2.y)+5);
				RightDegMargin = 5;
			}
			else if(AlignMark1.y<AlignMark2.y) {
				LeftDegMargin  = 5;
				RightDegMargin = (int)((AlignMark2.y - AlignMark1.y)+5);
			}
			else if(AlignMark1.y==AlignMark2.y) {
				LeftDegMargin  = 5;
				RightDegMargin = 5;
			}
		}
	}
	// Notch Cell 스틱 검사 
	if(FShape==shRectS && FCompanyMode==COM_NOTCH){
		LSP = Math.OnIntersect(LeftOutLine[0].FP0, LeftOutLine[0].FP1, LT, RT);
		LEP = Math.OnIntersect(LeftOutLine[0].FP0, LeftOutLine[0].FP1, LB, RB);

		RSP = Math.OnIntersect(RightOutLine[0].FP0, RightOutLine[0].FP1, LT, RT);
		REP = Math.OnIntersect(RightOutLine[0].FP0, RightOutLine[0].FP1, LB, RB);

		// 오버킬 방지목적으로 무조건 안쪽 라인 기준 검사 
		if((fabs(LSP.x - LEP.x)>Margin) || (fabs(RSP.x - REP.x)>Margin) ){
			LSP.x = (LSP.x>LEP.x) ? LSP.x : LEP.x;
			RSP.x = (RSP.x>REP.x) ? REP.x : RSP.x;
		}
		// Blob
		FLeftWidth   = 200;
		FRightWidth  = 200;
		LeftHeight   = (int)(LEP.y - LSP.y);
		RightHeight  = (int)(REP.y - RSP.y);
	}
	// Notch Cell 컵 검사 
	if(FShape==shRectC && FCompanyMode==COM_NOTCH){

		SP = Math.OnIntersect(LeftOutLine [0].FP0, LeftOutLine [0].FP1, LT, RT);
		EP = Math.OnIntersect(RightOutLine[0].FP0, RightOutLine[0].FP1, LT, RT);

		// BtmWidth 설정값은 Circle계산 이 후에 개별 적용함
		FLeftWidth  = 200;
		FRightWidth = 200;
		FBtmHeight  = 50;

		if(IsCornerBtm)     {//Corner Cutting일경우 Defect검사 영역 설정 
			LeftHeight  = (int)((FLBLInPoint.y - SP.y));
			RightHeight = (int)((FRBRInPoint.y - EP.y));
			BtmWidth    = (int)((FRBBInPoint.x - FLBBInPoint.x));
		}				    
		else if(IsRectBtm)  {//Corner Cutting 없을경우 Defect검사 영역 설정 
			LeftHeight  = (int)((FLBPoint.y - SP.y      ));
			RightHeight = (int)((FRBPoint.y - EP.y      ));
			BtmWidth    = (int)((FRBPoint.x - FLBPoint.x));
		}
		else if(IsCircleBtm){//Circle Cutting일경우 Defect 검사 영역 설정 
			LeftHeight  = (int)((FLBPoint.y - SP.y) - CSideCircleHeight - dCirOffsetY);
			RightHeight = (int)((FRBPoint.y - EP.y) - CSideCircleHeight - dCirOffsetY);
		}

		// BSide, DSide Defect 검사시 Margin값 설정 
		if(AlignMark1.y!=0.0f && AlignMark2.y!=0.0f){
			if(AlignMark1.y>AlignMark2.y){
				LeftDegMargin  = 5                                     ;
				RightDegMargin = (int)((AlignMark1.y - AlignMark2.y)+5);
			}
			else if(AlignMark1.y<AlignMark2.y) {
				LeftDegMargin  = (int)((AlignMark2.y - AlignMark1.y)+5);
				RightDegMargin = 5                                     ;
			}
			else if(AlignMark1.y==AlignMark2.y) {
				LeftDegMargin  = 5;
				RightDegMargin = 5;
			}
		}
	}

	// BMDT Cell 모자 검사 
	if(FShape==shRectH && FCompanyMode==COM_BMDT){
		SP = Math.OnIntersect(LeftOutLine [0].FP0, LeftOutLine [0].FP1, LB, RB);
		EP = Math.OnIntersect(RightOutLine[0].FP0, RightOutLine[0].FP1, LB, RB);

		// BSide, DSide Defect 검사시 Margin값 설정 
		// Align 많이 틀어질 경우 이미지 회전시 공백발생하여 OverKill발생함 
		if(AlignMark1.y!=0.0f && AlignMark2.y!=0.0f){
			if(AlignMark1.y>AlignMark2.y){
				LeftDegMargin  = (int)((AlignMark1.y - AlignMark2.y)+5);
				RightDegMargin = 5;
			}
			else if(AlignMark1.y<AlignMark2.y) {
				LeftDegMargin  = 5;
				RightDegMargin = (int)((AlignMark2.y - AlignMark1.y)+5);
			}
			else if(AlignMark1.y==AlignMark2.y) {
				LeftDegMargin  = 5;
				RightDegMargin = 5;
			}
		}


		if(FInspectMode==Insp_Surface){ //표면검사 (영역 구분없이 A_Side한가지 영역으로 검사한다)
			TopWidth    =(int)(FRTPoint.x - FLTPoint.x); // TOP검사 진행시 양쪽 끝에 오버킬 감소 목적 
			FTopHeight  =(LeftDegMargin >RightDegMargin)? (int)(((SP.y - (FLTPoint.y+FRTPoint.y)/2))-LeftDegMargin):(int)(((SP.y - (FLTPoint.y+FRTPoint.y)/2))-RightDegMargin);
		}
		else             { //외관검사 
			FLeftWidth  =200;
			FRightWidth =200;
			FTopHeight  =200;

			if(IsCornerTop)     { //Corner Cutting일경우 Defect검사 영역 설정 
				TopWidth    =(int)(FRTTInPoint.x - FLTTInPoint.x); // TOP검사 진행시 양쪽 끝에 오버킬 감소 목적 
				LeftHeight  =(int)(SP.y - FLTLInPoint.y);
				RightHeight =(int)(EP.y - FRTRInPoint.y);
			}
			else if(IsRectTop)  {//Corner Cutting 없을경우 Defect검사 영역 설정 
				TopWidth    =(int)(FRTPoint.x - FLTPoint.x); // TOP검사 진행시 양쪽 끝에 오버킬 감소 목적 
				LeftHeight  =(int)(SP.y - FLTPoint.y);
				RightHeight =(int)(EP.y - FRTPoint.y);
			}
			else if(IsCircleTop){//Circle Cutting일경우 Defect 검사 영역 설정 
				if(TopEdgePoint[0].x==0 || TopEdgePoint[0].y==0) {
					TopEdgePoint[0].x = (int)FLTPoint.x                     ; 
					TopEdgePoint[0].y = (int)FLTPoint.y+ASideCircleHeight+10;
				}
				if(TopEdgePoint[1].x==0 || TopEdgePoint[1].y==0) {
					TopEdgePoint[1].x = (int)FLTPoint.x+ASideCircleWidth+10; 
					TopEdgePoint[1].y = (int)FLTPoint.y                    ;
				}
				if(TopEdgePoint[2].x==0 || TopEdgePoint[2].y==0) {
					TopEdgePoint[2].x = (int)FRTPoint.x -ASideCircleWidth-10; 
					TopEdgePoint[2].y = (int)FRTPoint.y                     ;
				}
				if(TopEdgePoint[3].x==0 || TopEdgePoint[3].y==0) {
					TopEdgePoint[3].x = (int)FRTPoint.x                     ; 
					TopEdgePoint[3].y = (int)FRTPoint.y+ASideCircleHeight+10;
				}
				TopWidth    =(int)(TopEdgePoint[2].x - TopEdgePoint[1].x); // TOP검사 진행시 양쪽 끝에 오버킬 감소 목적   
				LeftHeight  =(int)(SP.y - TopEdgePoint[0].y);                                                             
				RightHeight =(int)(EP.y - TopEdgePoint[3].y);
			}
		}

		// Defect Data Init 
		DefectPointCount = 0; // 전체 불량 개수 초기화
		BCount           = 0; // B_SIDE  불량 포인트 개수
		ACount           = 0; // A_SIDE  불량 포인트 개수
		CCount           = 0; // C_SIDE  불량 포인트 개수
		DCount           = 0; // D_SIDE  불량 포인트 개수
		C1CirDeftectCnt  = 0;
		C2CirDeftectCnt  = 0;
		C3CirDeftectCnt  = 0;
		C4CirDeftectCnt  = 0;
		C5CirDeftectCnt  = 0;
		C6CirDeftectCnt  = 0;
		ABurrCount       = 0;
		BBurrCount       = 0;
		CBurrCount       = 0;
		DBurrCount       = 0;
	}

	// BMDT Cell 스틱 검사 
	if(FShape==shRectS && FCompanyMode==COM_BMDT){
		if(FInspectMode==Insp_Surface){ //표면검사 (영역 구분없이 C_Side한가지 영역으로 검사한다)
			LSP = Math.OnIntersect(LeftOutLine[0].FP0, LeftOutLine[0].FP1, LT, RT);
			LEP = Math.OnIntersect(LeftOutLine[0].FP0, LeftOutLine[0].FP1, LB, RB);

			RSP = Math.OnIntersect(RightOutLine[0].FP0, RightOutLine[0].FP1, LT, RT);
			REP = Math.OnIntersect(RightOutLine[0].FP0, RightOutLine[0].FP1, LB, RB);

			// 오버킬 방지목적으로 무조건 안쪽 라인 기준 검사 
			if((fabs(LSP.x - LEP.x)>Margin) || (fabs(RSP.x - REP.x)>Margin) ){
				LSP.x = (LSP.x>LEP.x) ? LSP.x : LEP.x;
				RSP.x = (RSP.x>REP.x) ? REP.x : RSP.x;
			}

			FLeftWidth  = (int)((RSP.x - LSP.x)/2);
			FRightWidth = (int)((RSP.x - LSP.x)/2);
			LeftHeight   = (int)(LEP.y - LSP.y)   ;
			RightHeight  = (int)(REP.y - RSP.y)   ;
		}
		else             { //외관검사 시퀀스//
			LSP = Math.OnIntersect(LeftOutLine[0].FP0, LeftOutLine[0].FP1, LT, RT);
			LEP = Math.OnIntersect(LeftOutLine[0].FP0, LeftOutLine[0].FP1, LB, RB);

			RSP = Math.OnIntersect(RightOutLine[0].FP0, RightOutLine[0].FP1, LT, RT);
			REP = Math.OnIntersect(RightOutLine[0].FP0, RightOutLine[0].FP1, LB, RB);

			// 오버킬 방지목적으로 무조건 안쪽 라인 기준 검사 
			if((fabs(LSP.x - LEP.x)>Margin) || (fabs(RSP.x - REP.x)>Margin) ){
				LSP.x = (LSP.x>LEP.x) ? LSP.x : LEP.x;
				RSP.x = (RSP.x>REP.x) ? REP.x : RSP.x;
			}
			// Blob
			FLeftWidth   = 200;
			FRightWidth  = 200;
			LeftHeight   = (int)(LEP.y - LSP.y);
			RightHeight  = (int)(REP.y - RSP.y);
		}
	}
	// BMDT Cell 컵 검사 
	if(FShape==shRectC && FCompanyMode==COM_BMDT){
		SP = Math.OnIntersect(LeftOutLine [0].FP0, LeftOutLine [0].FP1, LT, RT);
		EP = Math.OnIntersect(RightOutLine[0].FP0, RightOutLine[0].FP1, LT, RT);

		// BSide, DSide Defect 검사시 Margin값 설정 
		if(AlignMark1.y!=0.0f && AlignMark2.y!=0.0f){
			if(AlignMark1.y>AlignMark2.y){
				LeftDegMargin  = 5                                     ;
				RightDegMargin = (int)((AlignMark1.y - AlignMark2.y)+5);
			}
			else if(AlignMark1.y<AlignMark2.y) {
				LeftDegMargin  = (int)((AlignMark2.y - AlignMark1.y)+5);
				RightDegMargin = 5                                     ;
			}
			else if(AlignMark1.y==AlignMark2.y) {
				LeftDegMargin  = 5;
				RightDegMargin = 5;
			}
		}

		BTMLine = (FLBPoint.y > FRBPoint.y) ?(int)FRBPoint.y : (int)FLBPoint.y ;

		if(FInspectMode==Insp_Surface){ //표면검사 시퀀스//
			FBtmHeight = (LeftDegMargin >RightDegMargin)? (int)((BTMLine - SP.y)-LeftDegMargin):(int)((BTMLine - SP.y)- RightDegMargin);
			BtmWidth   = (int)(FRBPoint.x - FLBPoint.x); // BTM검사 진행시 양쪽 끝에 오버킬 감소 목적 
		}
		else             { //외관검사 시퀀스//
			SP = Math.OnIntersect(LeftOutLine [0].FP0, LeftOutLine [0].FP1, LT, RT);
			EP = Math.OnIntersect(RightOutLine[0].FP0, RightOutLine[0].FP1, LT, RT);

			// BtmWidth 설정값은 Circle계산 이 후에 개별 적용함
			FLeftWidth  = 200;
			FRightWidth = 200;
			FBtmHeight  = 50;

			if(IsCornerBtm)     {//Corner Cutting일경우 Defect검사 영역 설정 
				LeftHeight  = (int)((FLBLInPoint.y - SP.y));
				RightHeight = (int)((FRBRInPoint.y - EP.y));
				BtmWidth    = (int)((FRBBInPoint.x - FLBBInPoint.x));
			}				    
			else if(IsRectBtm)  {//Corner Cutting 없을경우 Defect검사 영역 설정 
				LeftHeight  = (int)((FLBPoint.y - SP.y      ));
				RightHeight = (int)((FRBPoint.y - EP.y      ));
				BtmWidth    = (int)((FRBPoint.x - FLBPoint.x));
			}
			else if(IsCircleBtm){//Circle Cutting일경우 Defect 검사 영역 설정 
				LeftHeight  = (int)((FLBPoint.y - SP.y) - CSideCircleHeight - dCirOffsetY);
				RightHeight = (int)((FRBPoint.y - EP.y) - CSideCircleHeight - dCirOffsetY);
			}
		}
	}

	float Dis =0.0f;
	float StdDis =0.0f;

	// Side Offset TEST 
	double  Width   =0.0f;
	long    Left    =0;
	float   CenterX =0.0F;


    switch (Index) {
		
        // Rect8 : 정육각형모양
        //----------------------------------------------------------------------
	case 0 :
		if (Edge->OnExecute(InLBLPoint, InLTLPoint)) for (int k=0; k<Edge->GetResultEdgePointCount(); k++) FDefectPoint[DefectPointCount++] = Edge->GetResultEdgePoint(k);
		if (Edge->OnExecute(InLTLPoint, InLTTPoint)) for (int k=0; k<Edge->GetResultEdgePointCount(); k++) FDefectPoint[DefectPointCount++] = Edge->GetResultEdgePoint(k);
		if (Edge->OnExecute(InLTTPoint, InRTTPoint)) for (int k=0; k<Edge->GetResultEdgePointCount(); k++) FDefectPoint[DefectPointCount++] = Edge->GetResultEdgePoint(k);
		if (Edge->OnExecute(InRTTPoint, InRTRPoint)) for (int k=0; k<Edge->GetResultEdgePointCount(); k++) FDefectPoint[DefectPointCount++] = Edge->GetResultEdgePoint(k);
		if (Edge->OnExecute(InRTRPoint, InRBRPoint)) for (int k=0; k<Edge->GetResultEdgePointCount(); k++) FDefectPoint[DefectPointCount++] = Edge->GetResultEdgePoint(k);
		if (Edge->OnExecute(InRBRPoint, InRBBPoint)) for (int k=0; k<Edge->GetResultEdgePointCount(); k++) FDefectPoint[DefectPointCount++] = Edge->GetResultEdgePoint(k);
		if (Edge->OnExecute(InRBBPoint, InLBBPoint)) for (int k=0; k<Edge->GetResultEdgePointCount(); k++) FDefectPoint[DefectPointCount++] = Edge->GetResultEdgePoint(k);
		if (Edge->OnExecute(InLBBPoint, InLBLPoint)) for (int k=0; k<Edge->GetResultEdgePointCount(); k++) FDefectPoint[DefectPointCount++] = Edge->GetResultEdgePoint(k);
		
		Index = 0;
		return true;
		
		// RectC : 모자모양
		//------------------------------------------------------------------
	case 1 :
		if(IsCornerTop){
			if(LTDx!=0 && LTDy!=0 && RTDx!=0 && RTDy!=0) {
				// Corner 1 
				if(C1EdgeCount!=0){
					CornerCount=0;
					for(int k=0; k<C1EdgeCount; k++){
						if(C1Point[k].y>FLTLPoint.y-1) continue;
						Dis = Math.GetLengthFrLineToPoint(FLTLPoint, FLTTPoint, C1Point[k]);
						C1Corner[CornerCount].Dv   = Dis         ;
						C1Corner[CornerCount].P.x  = C1Point[k].x;
						C1Corner[CornerCount].P.y  = C1Point[k].y;
						CornerCount++;
					}
					C1Count = GetSize(C1Corner, C1DefectPoint, CornerCount, 5);
				}

				// Corner 2 
				if(C2EdgeCount!=0){
					CornerCount=0;
					for(int k=0; k<C2EdgeCount; k++){
						if(C2Point[k].y>FRTRPoint.y-1) continue;
						Dis = Math.GetLengthFrLineToPoint(FRTTPoint, FRTRPoint, C2Point[k]);
						C2Corner[CornerCount].Dv   = Dis         ;
						C2Corner[CornerCount].P.x  = C2Point[k].x;
						C2Corner[CornerCount].P.y  = C2Point[k].y;
						CornerCount++;
					}
					C2Count = GetSize(C2Corner, C2DefectPoint, CornerCount, 5);
				}

				if(FMinWidth==0 || FMinHeight==0){ FMinWidth=1; FMinHeight=1;}

				// Side D	
				////////////////////////////////////////////////////////////////////////////////////////////////
//  				LogUnit.SetLog("CAP_Side_D_Start_CamId: %d, ImageHeight: %d ",CamId,ImageHeight);     
				DefectROI.SetPlacement((int)(FLTPoint.x+SideMargin), (int)FLTPoint.y+Margin, FLeftWidth, (LeftHeight-(2*TopMargin))-5);
				if((FLTLPoint.x+SideMargin) <=0          || FLTLPoint.y+TopMargin<=0           || FLeftWidth<=0          || (LeftHeight-(2*TopMargin))-5<=0          ) return false;
				if((FLTLPoint.x+SideMargin) >=ImageWidth || FLTLPoint.y+TopMargin>TopLimitLine || FLeftWidth>=ImageWidth || (LeftHeight-(2*TopMargin))-5>TopLimitLine) return false;

				CodeImageSelection.Clear();
				CodeImageEncoder.Encode(DefectROI,CodeImage);
				CodeImageSelection.Clear();
				CodeImageSelection.AddObjects(CodeImage);

				// Blob 필터링 
				CodeImageSelection.RemoveUsingFloatFeature  (EFeature_BoundingBoxWidth ,FMinWidth , FMaxWidth  , EDoubleThresholdMode_Outside);
				CodeImageSelection.RemoveUsingFloatFeature  (EFeature_BoundingBoxHeight,FMinHeight, FMaxHeight , EDoubleThresholdMode_Outside);
// 				CodeImageSelection.RemoveUsingIntegerFeature(EFeature_LeftLimit        ,0         , 3          , EDoubleThresholdMode_Outside);
				CodeImageSelection.RemoveUsingIntegerFeature(EFeature_LeftLimit        ,0         , 1          , EDoubleThresholdMode_Outside);

				BlobCount = CodeImageSelection.GetElementCount();
				CodeImageSelection.Sort(EFeature_TopLimit,ESortDirection_Ascending);

				if(BlobCount!=0){
					for(int k=0; k<BlobCount; k++){
						if(DCount>=MAX_DEFECT_POINT) break;
						DDefectPoint[DCount].Width     =  CodeImageSelection.GetElement(k).GetBoundingBoxWidth() ;
						DDefectPoint[DCount].Height    =  CodeImageSelection.GetElement(k).GetBoundingBoxHeight();

						DDefectPoint[DCount].Rect.left   = (long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterX() - DDefectPoint[DCount].Width/2 ) +FLTLPoint.x);
						DDefectPoint[DCount].Rect.top    = (long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - DDefectPoint[DCount].Height/2) +FLTLPoint.y);
						DDefectPoint[DCount].Rect.right  = (long)(DDefectPoint[DCount].Rect.left+ DDefectPoint[DCount].Width );
						DDefectPoint[DCount].Rect.bottom = (long)(DDefectPoint[DCount].Rect.top + DDefectPoint[DCount].Height);

						PixelCount = 0;
						PixelValue = 0;
						// 내부 Pixel Data 축출 
						for(int n=DDefectPoint[DCount].Rect.top+1 ; n<DDefectPoint[DCount].Rect.bottom-1; n++){
							for(int m=DDefectPoint[DCount].Rect.left+1; m<DDefectPoint[DCount].Rect.right-1 ; m++){
								PixelValue = IElement(m,n);
								if(PixelValue < EnCapTopThresHold) PixelCount++;
							}
						}
						// Display 데이터 필요함 
						DDefectPoint[DCount].Round = PixelCount;
						DDefectPoint[DCount].P.x       = (float)(DDefectPoint[DCount].Rect.left);
						DDefectPoint[DCount].P.y       = (float)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - DDefectPoint[DCount].Height/2)+FLTLPoint.y+ImageHeight );
                        DDefectPoint[DCount].Width     = DDefectPoint[DCount].Width+SideMargin; 

						// Merge 위해서 데이터 필요함 
						DDefectPoint[DCount].Rect.top    =(long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - DDefectPoint[DCount].Height/2) +FLTLPoint.y+ImageHeight);
						DDefectPoint[DCount].Rect.bottom =(long)(DDefectPoint[DCount].Rect.top + DDefectPoint[DCount].Height);
						DCount++;
					}
				}
				BlobCount =0;

				// 외곽라인에서 Mark까지의 거리 산출 
				if     (Line[waLeftWall].FP0.x >Line[waLeftWall].FP1.x) LDistance = (FP0.x - (Line[waLeftWall].FP1.x+(Line[waLeftWall].FP0.x - Line[waLeftWall].FP1.x)/2));
				else if(Line[waLeftWall].FP0.x==Line[waLeftWall].FP1.x) LDistance = (FP0.x -  Line[waLeftWall].FP0.x)                                                     ;
				else                                                    LDistance = (FP0.x - (Line[waLeftWall].FP0.x+(Line[waLeftWall].FP1.x - Line[waLeftWall].FP0.x)/2)); 

				MarktoBmLine = (IsMarkBtm) ? 5: 50;  
				if(IsMarkBtm) LDistance = LDistance-MarktoBmLine;
				else          LDistance = LDistance+MarktoBmLine;
//  				LogUnit.SetLog("CAP_Side_D_End_CamId: %d, ImageHeight: %d ",CamId,ImageHeight);     
				////////////////////////////////////////////////////////////////////////////////////////////////



				//Side B
				////////////////////////////////////////////////////////////////////////////////////////////////
//  				LogUnit.SetLog("CAP_Side_B_Start_CamId: %d, ImageHeight: %d ",CamId,ImageHeight);     
				DefectROI.SetPlacement((int)(FRTRPoint.x-FRightWidth-SideMargin), (int)FRTRPoint.y+TopMargin, FRightWidth, RightHeight-(2*TopMargin)-5);
				if((FRTRPoint.x-FRightWidth-SideMargin) <=0          || FRTRPoint.y+TopMargin<=0 || FRightWidth<=0          || RightHeight-(2*TopMargin)-5<=0)           return false;
				if((FRTRPoint.x-FRightWidth-SideMargin) >=ImageWidth || FRTRPoint.y>TopLimitLine || FRightWidth>=ImageWidth || RightHeight-(2*TopMargin)-5>TopLimitLine) return false;

				CodeImageSelection.Clear();
				CodeImageEncoder.Encode(DefectROI,CodeImage);
				CodeImageSelection.Clear();
				CodeImageSelection.AddObjects(CodeImage);
				// Blob 필터링 
				CodeImageSelection.RemoveUsingFloatFeature(EFeature_BoundingBoxWidth ,FMinWidth     , FMaxWidth    , EDoubleThresholdMode_Outside);
				CodeImageSelection.RemoveUsingFloatFeature(EFeature_BoundingBoxHeight,FMinHeight    , FMaxHeight   , EDoubleThresholdMode_Outside);
// 				CodeImageSelection.RemoveUsingIntegerFeature(EFeature_RightLimit     ,FRightWidth-2 , FRightWidth+1, EDoubleThresholdMode_Outside);
				CodeImageSelection.RemoveUsingIntegerFeature(EFeature_RightLimit     ,FRightWidth-1 , FRightWidth+1, EDoubleThresholdMode_Outside);

				BlobCount = CodeImageSelection.GetElementCount();
				CodeImageSelection.Sort(EFeature_TopLimit,ESortDirection_Ascending);

				if(BlobCount!=0){
					for(int k=0; k<BlobCount; k++){
						if(BCount>=MAX_DEFECT_POINT) break;
						BDefectPoint[BCount].Width  = CodeImageSelection.GetElement(k).GetBoundingBoxWidth() ;
						BDefectPoint[BCount].Height = CodeImageSelection.GetElement(k).GetBoundingBoxHeight();

						BDefectPoint[BCount].Rect.left   = (long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterX() - BDefectPoint[BCount].Width/2 ) +(FRTRPoint.x-FRightWidth-SideMargin));
						BDefectPoint[BCount].Rect.top    = (long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - BDefectPoint[BCount].Height/2) + FRTRPoint.y                        );
						BDefectPoint[BCount].Rect.right  = (long)(BDefectPoint[BCount].Rect.left+ BDefectPoint[BCount].Width );
						BDefectPoint[BCount].Rect.bottom = (long)(BDefectPoint[BCount].Rect.top + BDefectPoint[BCount].Height);
						PixelCount = 0;
						PixelValue = 0;
						
						// 내부 Pixel Data 축출 
						for(int n=BDefectPoint[BCount].Rect.top+1 ; n<BDefectPoint[BCount].Rect.bottom-1; n++){
							for(int m=BDefectPoint[BCount].Rect.left+1; m<BDefectPoint[BCount].Rect.right-1 ; m++){
								PixelValue = IElement(m,n);
								if(PixelValue < EnCapTopThresHold) PixelCount++;
							}
						}
						BDefectPoint[BCount].Round  = PixelCount;
						BDefectPoint[BCount].P.x    = (float)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterX() - BDefectPoint[BCount].Width/2 ) +(FRTRPoint.x-FRightWidth+SideMargin));
						BDefectPoint[BCount].P.y    = (float)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - BDefectPoint[BCount].Height/2) +FRTRPoint.y+ImageHeight);
						BDefectPoint[BCount].Width  = BDefectPoint[BCount].Width+SideMargin; 

						// Merge 위해서 데이터 필요함 
						BDefectPoint[BCount].Rect.top    =(long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - BDefectPoint[BCount].Height/2) + FRTRPoint.y+ImageHeight);
						BDefectPoint[BCount].Rect.bottom =(long)(BDefectPoint[BCount].Rect.top + BDefectPoint[BCount].Height);
						BCount++;
					}
				}
				BlobCount =0;

				// 외곽라인에서 Mark까지의 거리 산출 
				if     (Line[waRightWall].FP0.x >Line[waRightWall].FP1.x) RDistance = ((Line[waRightWall].FP1.x+(Line[waRightWall].FP0.x - Line[waRightWall].FP1.x)/2) - FP1.x);
				else if(Line[waRightWall].FP0.x==Line[waRightWall].FP1.x) RDistance = (Line[waRightWall].FP0.x - FP1.x);
				else                                                      RDistance = ((Line[waRightWall].FP0.x+(Line[waRightWall].FP1.x - Line[waRightWall].FP0.x)/2) - FP1.x);

				MarktoBmLine = (IsMarkBtm) ? 5: 50;  
				if(IsMarkBtm) RDistance = RDistance-MarktoBmLine;
				else          RDistance = RDistance+MarktoBmLine;
//  				LogUnit.SetLog("CAP_Side_B_End_CamId: %d, ImageHeight: %d ",CamId,ImageHeight);     
				////////////////////////////////////////////////////////////////////////////////////////////////

				//Side A
				////////////////////////////////////////////////////////////////////////////////////////////////
//  				LogUnit.SetLog("CAP_Side_A_Start_CamId: %d, ImageHeight: %d ",CamId,ImageHeight);     
				DefectROI.SetPlacement((int)FLTTPoint.x, (int)(((TopBMLine[0].FP0.y+TopBMLine[0].FP1.y)/2)-TopOffset), TopWidth, FTopHeight);
				// Line Scan 16k
				//DefectROI.SetPlacement((int)FLTTPoint.x, (int)(((Line[1].FP0.y+Line[1].FP1.y)/2)+2), TopWidth, FTopHeight);
				if((FLTTPoint.x) <=0 || (((TopBMLine[0].FP0.y+TopBMLine[0].FP1.y)/2)-TopOffset)<=0 || TopWidth<=0 || FTopHeight<=0)return false;
				if((FLTTPoint.x) >=ImageWidth || (((TopBMLine[0].FP0.y+TopBMLine[0].FP1.y)/2)-TopOffset)>TopLimitLine || TopWidth>=ImageWidth || FTopHeight>TopLimitLine) return false;

				CodeImageSelection.Clear();
				CodeImageEncoder.Encode(DefectROI,CodeImage);
				CodeImageSelection.Clear();
				CodeImageSelection.AddObjects(CodeImage);
				// Blob 필터링 
				CodeImageSelection.RemoveUsingFloatFeature(EFeature_BoundingBoxWidth ,FMinWidth , FMaxWidth  , EDoubleThresholdMode_Outside);
				CodeImageSelection.RemoveUsingFloatFeature(EFeature_BoundingBoxHeight,FMinHeight, FMaxHeight , EDoubleThresholdMode_Outside);
				CodeImageSelection.RemoveUsingIntegerFeature(EFeature_TopLimit       ,0         , 3          , EDoubleThresholdMode_Outside);

				
				BlobCount = CodeImageSelection.GetElementCount();
				CodeImageSelection.Sort(EFeature_LeftLimit ,ESortDirection_Ascending);

				if(BlobCount!=0){
					for(int k=0; k<BlobCount; k++){
						if(ACount>=MAX_DEFECT_POINT) break;
						ADefectPoint[ACount].Width  = CodeImageSelection.GetElement(k).GetBoundingBoxWidth() ;
						ADefectPoint[ACount].Height = CodeImageSelection.GetElement(k).GetBoundingBoxHeight();

						ADefectPoint[ACount].Rect.left   =(long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterX() - ADefectPoint[ACount].Width/2 ) +FLTTPoint.x                    );
						ADefectPoint[ACount].Rect.top    =(long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - ADefectPoint[ACount].Height/2) +((TopBMLine[0].FP0.y+TopBMLine[0].FP1.y)/2)-TopOffset);
						ADefectPoint[ACount].Rect.right  =(long)(ADefectPoint[ACount].Rect.left+ ADefectPoint[ACount].Width );
						ADefectPoint[ACount].Rect.bottom =(long)(ADefectPoint[ACount].Rect.top + ADefectPoint[ACount].Height);
						PixelCount = 0;
						PixelValue = 0;

						// 내부 Pixel Data 축출 
						for(int n=ADefectPoint[ACount].Rect.top+1 ; n<ADefectPoint[ACount].Rect.bottom-1; n++){
							for(int m=ADefectPoint[ACount].Rect.left+1; m<ADefectPoint[ACount].Rect.right-1 ; m++){
								PixelValue = IElement(m,n);
								if(PixelValue < EnCapTopThresHold) PixelCount++;
							}
						}

						ADefectPoint[ACount].Round  = PixelCount;
						ADefectPoint[ACount].P.x    =(float)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterX() - ADefectPoint[ACount].Width/2 )+FLTTPoint.x);
						ADefectPoint[ACount].P.y    =(float)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - ADefectPoint[ACount].Height/2)+((TopBMLine[0].FP0.y+TopBMLine[0].FP1.y)/2)-TopOffset+ImageHeight);

						// Image Rotate 기준 좌표를 다시 Rotate한다 _ Display 목적 
						if(ImgDegree!=0.0f){
							CenterPoint.x = FLTPoint.x +(FRTPoint.x - FLTPoint.x)/2;
							CenterPoint.y = FLTPoint.y+ImageHeight;
							ADefectPoint[ACount].P = Math.OnRotate(CenterPoint,ADefectPoint[ACount].P, ImgDegree);
						}

						//Merget위해서 필요함 
						ADefectPoint[ACount].Rect.top    =(long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - ADefectPoint[ACount].Height/2) +((TopBMLine[0].FP0.y+TopBMLine[0].FP1.y)/2)-TopOffset+ImageHeight);
						ADefectPoint[ACount].Rect.bottom =(long)(ADefectPoint[ACount].Rect.top + ADefectPoint[ACount].Height);
						ACount++;
					}
				}
//  				LogUnit.SetLog("CAP_Side_A_End_CamId: %d, ImageHeight: %d ",CamId,ImageHeight); 
				
				// SIDE A Remain & Burr 
				if(TopOffset!=0 && BurrTopOffset!=0){
//  				    LogUnit.SetLog("CAP_Side_A_BURR_Start_CamId: %d, ImageHeight: %d ",CamId,ImageHeight);     
					EasyImage::Threshold(GImage,&DefectImg, BurrFindThresHold);
					DefectROI.Attach(&DefectImg);
					CodeImageSelection.SetFeretAngle(0.00f);
					CodeImageEncoder.GetGrayscaleSingleThresholdSegmenter().SetWhiteLayerEncoded(true );
					CodeImageEncoder.GetGrayscaleSingleThresholdSegmenter().SetBlackLayerEncoded(false);
					
					IAddress = DefectImg.GetImagePtr();
					
					DefectROI.SetPlacement((int)FLTTPoint.x, (int)(((TopBMLine[0].FP0.y+TopBMLine[0].FP1.y)/2)-TopOffset -BurrTopOffset-RemainMargin), TopWidth, RemainMargin);
					// Line Scan 16k
					//DefectROI.SetPlacement((int)FLTTPoint.x, (int)(((Line[1].FP0.y+Line[1].FP1.y)/2)-BurrTopOffset-RemainMargin), TopWidth, RemainMargin);
					if((FLTTPoint.x) <=0 ||(((TopBMLine[0].FP0.y+TopBMLine[0].FP1.y)/2)-TopOffset -BurrTopOffset-RemainMargin)<=0 || TopWidth<=0 ||RemainMargin<=0   )return false;
				    if((FLTTPoint.x) >=ImageWidth || (((TopBMLine[0].FP0.y+TopBMLine[0].FP1.y)/2)-TopOffset -BurrTopOffset-RemainMargin)>TopLimitLine || TopWidth>=ImageWidth || RemainMargin>TopLimitLine) return false;

					
					CodeImageSelection.Clear();
					CodeImageEncoder.Encode(DefectROI,CodeImage);
					CodeImageSelection.Clear();
					CodeImageSelection.AddObjects(CodeImage);
					// Blob 필터링 
					CodeImageSelection.RemoveUsingFloatFeature(EFeature_BoundingBoxWidth ,FMinWidth , FMaxWidth  , EDoubleThresholdMode_Outside);
					CodeImageSelection.RemoveUsingFloatFeature(EFeature_BoundingBoxHeight,FMinHeight, FMaxHeight , EDoubleThresholdMode_Outside);
					//CodeImageSelection.RemoveUsingIntegerFeature(EFeature_LeftLimit        ,0       , 3          , EDoubleThresholdMode_Outside);
					
					BlobCount = CodeImageSelection.GetElementCount();
					CodeImageSelection.Sort(EFeature_LeftLimit ,ESortDirection_Ascending);
					
					if(BlobCount!=0){
						for(int k=0; k<BlobCount; k++){
							if(ABurrCount>=MAX_DEFECT_POINT) break;
							ABurrPoint[ABurrCount].Width  = CodeImageSelection.GetElement(k).GetBoundingBoxWidth() ;
							ABurrPoint[ABurrCount].Height = CodeImageSelection.GetElement(k).GetBoundingBoxHeight();
							
							ABurrPoint[ABurrCount].Rect.left   =(long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterX() - ABurrPoint[ABurrCount].Width/2 ) +FLTTPoint.x);
							ABurrPoint[ABurrCount].Rect.top    =(long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - ABurrPoint[ABurrCount].Height/2) +(((TopBMLine[0].FP0.y+TopBMLine[0].FP1.y)/2)-TopOffset -BurrTopOffset-RemainMargin));
							ABurrPoint[ABurrCount].Rect.right  =(long)(ABurrPoint[ABurrCount].Rect.left+ ABurrPoint[ABurrCount].Width );
							ABurrPoint[ABurrCount].Rect.bottom =(long)(ABurrPoint[ABurrCount].Rect.top + ABurrPoint[ABurrCount].Height);
							PixelCount =0;
							PixelValue =0;
							
							// 내부 Pixel Data 축출 
							for(int n=ABurrPoint[ABurrCount].Rect.top+1 ; n<ABurrPoint[ABurrCount].Rect.bottom-1; n++){
								for(int m=ABurrPoint[ABurrCount].Rect.left+1; m<ABurrPoint[ABurrCount].Rect.right-1 ; m++){
									PixelValue = IElement(m,n);
									if(PixelValue > BurrFindThresHold) PixelCount++;
								}
							}
							
							ABurrPoint[ABurrCount].Round = PixelCount;
							ABurrPoint[ABurrCount].P.x    =(float)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterX() - ABurrPoint[ABurrCount].Width/2 )+FLTTPoint.x);
							ABurrPoint[ABurrCount].P.y    =(float)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - ABurrPoint[ABurrCount].Height/2)+(((TopBMLine[0].FP0.y+TopBMLine[0].FP1.y)/2)-TopOffset -BurrTopOffset-RemainMargin)+ImageHeight);
							
							// Merge 위해서 데이터 필요함 
							ABurrPoint[ABurrCount].Rect.top    =(long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - ABurrPoint[ABurrCount].Height/2)+(((TopBMLine[0].FP0.y+TopBMLine[0].FP1.y)/2)-TopOffset -BurrTopOffset-RemainMargin)+ImageHeight);
							ABurrPoint[ABurrCount].Rect.bottom =(long)(ABurrPoint[ABurrCount].Rect.top + ABurrPoint[ABurrCount].Height);
							ABurrCount++;
						}
					}
				}
				BlobCount =0;
//  				LogUnit.SetLog("CAP_Side_A_BURR_End_CamId: %d, ImageHeight: %d ",CamId,ImageHeight);     
				////////////////////////////////////////////////////////////////////////////////////////////////
				// 원본 이미지 회전하여 검사 이후 화면에 디스플레이 목적으로 좌표값을 다시 계사한다 
				////////////////////////////////////////////////////////////////////////////////////////////////
				if(ImgDegree!=0.0f){
					CenterPoint.x = FLTPoint.x +(FRTPoint.x - FLTPoint.x)/2;
					CenterPoint.y = FLTPoint.y;

					FRTPoint = Math.OnRotate(CenterPoint, FRTPoint, (ImgDegree));

					CenterPoint.y = FRTPoint.y;
					FLTPoint = Math.OnRotate(CenterPoint, FLTPoint, (ImgDegree));
				}
			}
		}
		else {
			if(FMinWidth==0 || FMinHeight==0){ FMinWidth=1; FMinHeight=1;}

			// Side D	
			////////////////////////////////////////////////////////////////////////////////////////////////
			DefectROI.SetPlacement((int)(FLTPoint.x+SideMargin),(int)FLTPoint.y+TopMargin, FLeftWidth, LeftHeight-(2*TopMargin)-5);
			if((FLTPoint.x+SideMargin) <=0          || FLTPoint.y+TopMargin<=0           || FLeftWidth<=0          || LeftHeight-(2*TopMargin)-5<=0          )return false;
			if((FLTPoint.x+SideMargin) >=ImageWidth || FLTPoint.y+TopMargin>TopLimitLine || FLeftWidth>=ImageWidth || LeftHeight-(2*TopMargin)-5>TopLimitLine) return false;

			CodeImageSelection.Clear();
			CodeImageEncoder.Encode(DefectROI,CodeImage);
			CodeImageSelection.Clear();
			CodeImageSelection.AddObjects(CodeImage);

			// Blob 필터링 
			CodeImageSelection.RemoveUsingFloatFeature  (EFeature_BoundingBoxWidth ,FMinWidth , FMaxWidth  , EDoubleThresholdMode_Outside);
			CodeImageSelection.RemoveUsingFloatFeature  (EFeature_BoundingBoxHeight,FMinHeight, FMaxHeight , EDoubleThresholdMode_Outside);
// 			CodeImageSelection.RemoveUsingIntegerFeature(EFeature_LeftLimit        ,0         , 3          , EDoubleThresholdMode_Outside);
			CodeImageSelection.RemoveUsingIntegerFeature(EFeature_LeftLimit        ,0         , 1          , EDoubleThresholdMode_Outside);

			BlobCount = CodeImageSelection.GetElementCount();
			CodeImageSelection.Sort(EFeature_TopLimit,ESortDirection_Ascending);

			if(BlobCount!=0){
				for(int k=0; k<BlobCount; k++){
					if(DCount>=MAX_DEFECT_POINT) break;
					DDefectPoint[DCount].Width     =  CodeImageSelection.GetElement(k).GetBoundingBoxWidth() ;
					DDefectPoint[DCount].Height    =  CodeImageSelection.GetElement(k).GetBoundingBoxHeight();

					DDefectPoint[DCount].Rect.left   = (long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterX() - DDefectPoint[DCount].Width/2 ) +FLTPoint.x+SideMargin);
					DDefectPoint[DCount].Rect.top    = (long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - DDefectPoint[DCount].Height/2) +FLTPoint.y);
					DDefectPoint[DCount].Rect.right  = (long)(DDefectPoint[DCount].Rect.left+ DDefectPoint[DCount].Width );
					DDefectPoint[DCount].Rect.bottom = (long)(DDefectPoint[DCount].Rect.top + DDefectPoint[DCount].Height);
					PixelCount = 0;
					PixelValue = 0;

					// 내부 Pixel Data 축출 
					for(int n=DDefectPoint[DCount].Rect.top+1 ; n<DDefectPoint[DCount].Rect.bottom-1; n++){
						for(int m=DDefectPoint[DCount].Rect.left+1; m<DDefectPoint[DCount].Rect.right-1 ; m++){
							PixelValue = IElement(m,n);
							if(PixelValue < EnCapTopThresHold) PixelCount++;
						}
					}
					DDefectPoint[DCount].Round = PixelCount;
					DDefectPoint[DCount].P.x       = (float)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterX() - DDefectPoint[DCount].Width/2) +FLTPoint.x+SideMargin);
					DDefectPoint[DCount].P.y       = (float)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - DDefectPoint[DCount].Height/2)+FLTPoint.y+ImageHeight);

					// Merge 위해서 데이터 필요함 
					DDefectPoint[DCount].Rect.top    =(long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - DDefectPoint[DCount].Height/2) +FLTPoint.y+ImageHeight);
					DDefectPoint[DCount].Rect.bottom =(long)(DDefectPoint[DCount].Rect.top + DDefectPoint[DCount].Height);
					DCount++;
				}
			}
			BlobCount =0;

			// 외곽라인에서 Mark까지의 거리 산출 
			if     (Line[waLeftWall].FP0.x >Line[waLeftWall].FP1.x) LDistance = (FP0.x - (Line[waLeftWall].FP1.x+(Line[waLeftWall].FP0.x - Line[waLeftWall].FP1.x)/2));
			else if(Line[waLeftWall].FP0.x==Line[waLeftWall].FP1.x) LDistance = (FP0.x -  Line[waLeftWall].FP0.x)                                                     ;
			else                                                    LDistance = (FP0.x - (Line[waLeftWall].FP0.x+(Line[waLeftWall].FP1.x - Line[waLeftWall].FP0.x)/2)); 
			
			MarktoBmLine = (IsMarkBtm) ? 5: 50;  
			if(IsMarkBtm) LDistance = LDistance-MarktoBmLine;
			else          LDistance = LDistance+MarktoBmLine;
			////////////////////////////////////////////////////////////////////////////////////////////////



			//Side B
			////////////////////////////////////////////////////////////////////////////////////////////////
			DefectROI.SetPlacement((int)(FRTPoint.x-FRightWidth-SideMargin), (int)FRTPoint.y+TopMargin, FRightWidth, RightHeight-(2*TopMargin)-5);
			if((FRTPoint.x-FRightWidth-SideMargin) <=0          || FRTPoint.y+TopMargin<=0           || FRightWidth<=0          || RightHeight-(2*TopMargin)-5<=0          ) return false;
			if((FRTPoint.x-FRightWidth-SideMargin) >=ImageWidth || FRTPoint.y+TopMargin>TopLimitLine || FRightWidth>=ImageWidth || RightHeight-(2*TopMargin)-5>TopLimitLine) return false;

			CodeImageSelection.Clear();
			CodeImageEncoder.Encode(DefectROI,CodeImage);
			CodeImageSelection.Clear();
			CodeImageSelection.AddObjects(CodeImage);
			// Blob 필터링 
			CodeImageSelection.RemoveUsingFloatFeature(EFeature_BoundingBoxWidth ,FMinWidth     , FMaxWidth    , EDoubleThresholdMode_Outside);
			CodeImageSelection.RemoveUsingFloatFeature(EFeature_BoundingBoxHeight,FMinHeight    , FMaxHeight   , EDoubleThresholdMode_Outside);
			CodeImageSelection.RemoveUsingIntegerFeature(EFeature_RightLimit     ,FRightWidth-2 , FRightWidth+1, EDoubleThresholdMode_Outside);

			BlobCount = CodeImageSelection.GetElementCount();
			CodeImageSelection.Sort(EFeature_TopLimit,ESortDirection_Ascending);

			if(BlobCount!=0){
				for(int k=0; k<BlobCount; k++){
					if(BCount>=MAX_DEFECT_POINT) break;
					BDefectPoint[BCount].Width  = CodeImageSelection.GetElement(k).GetBoundingBoxWidth() ;
					BDefectPoint[BCount].Height = CodeImageSelection.GetElement(k).GetBoundingBoxHeight();

					BDefectPoint[BCount].Rect.left   =(long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterX() - BDefectPoint[BCount].Width/2 ) +(FRTPoint.x-FRightWidth-2));
					BDefectPoint[BCount].Rect.top    =(long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - BDefectPoint[BCount].Height/2) + FRTPoint.y               );
					BDefectPoint[BCount].Rect.right  =(long)(BDefectPoint[BCount].Rect.left+ BDefectPoint[BCount].Width );
					BDefectPoint[BCount].Rect.bottom =(long)(BDefectPoint[BCount].Rect.top + BDefectPoint[BCount].Height);
					PixelCount = 0;
					PixelValue = 0;
					
					// 내부 Pixel Data 축출 
					for(int n=BDefectPoint[BCount].Rect.top+1 ; n<BDefectPoint[BCount].Rect.bottom-1; n++){
						for(int m=BDefectPoint[BCount].Rect.left+1; m<BDefectPoint[BCount].Rect.right-1 ; m++){
							PixelValue = IElement(m,n);
							if(PixelValue < EnCapTopThresHold) PixelCount++;
						}
					}
					BDefectPoint[BCount].Round  = PixelCount;
					BDefectPoint[BCount].P.x    =(float)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterX() - BDefectPoint[BCount].Width/2 ) +(FRTPoint.x-FRightWidth-2));
					BDefectPoint[BCount].P.y    =(float)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - BDefectPoint[BCount].Height/2) + FRTPoint.y+ImageHeight);

					// Merge 위해서 데이터 필요함 
					BDefectPoint[BCount].Rect.top    =(long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - BDefectPoint[BCount].Height/2) + FRTPoint.y+ImageHeight);
					BDefectPoint[BCount].Rect.bottom =(long)(BDefectPoint[BCount].Rect.top + BDefectPoint[BCount].Height);
					BCount++;
				}
			}
			BlobCount =0;

			// 외곽라인에서 Mark까지의 거리 산출 
			if     (Line[waRightWall].FP0.x >Line[waRightWall].FP1.x) RDistance = ((Line[waRightWall].FP1.x+(Line[waRightWall].FP0.x - Line[waRightWall].FP1.x)/2) - FP1.x);
			else if(Line[waRightWall].FP0.x==Line[waRightWall].FP1.x) RDistance = ( Line[waRightWall].FP0.x - FP1.x);
			else                                                      RDistance = ((Line[waRightWall].FP0.x+(Line[waRightWall].FP1.x - Line[waRightWall].FP0.x)/2) - FP1.x);
			
			MarktoBmLine = (IsMarkBtm) ? 5: 50;  
			if(IsMarkBtm) RDistance = RDistance-MarktoBmLine;
			else          RDistance = RDistance+MarktoBmLine;
			////////////////////////////////////////////////////////////////////////////////////////////////



			//Side A
			////////////////////////////////////////////////////////////////////////////////////////////////
			DefectROI.SetPlacement((int)(FLTPoint.x+1), (int)(((TopBMLine[0].FP0.y+TopBMLine[0].FP1.y)/2)-TopOffset), TopWidth-1, FTopHeight);
			if((FLTPoint.x+1)<=0 || TopWidth-1<=0 || FTopHeight<=0 || ((TopBMLine[0].FP0.y+TopBMLine[0].FP1.y)/2)-TopOffset<=0 ) return false;
			if((FLTPoint.x+1) >=ImageWidth || ((TopBMLine[0].FP0.y+TopBMLine[0].FP1.y)/2)-TopOffset>TopLimitLine || TopWidth-1>=ImageWidth || FTopHeight>TopLimitLine) return false;

			CodeImageSelection.Clear();
			CodeImageEncoder.Encode(DefectROI,CodeImage);
			CodeImageSelection.Clear();
			CodeImageSelection.AddObjects(CodeImage);
			// Blob 필터링 
			CodeImageSelection.RemoveUsingFloatFeature(EFeature_BoundingBoxWidth ,FMinWidth , FMaxWidth  , EDoubleThresholdMode_Outside);
			CodeImageSelection.RemoveUsingFloatFeature(EFeature_BoundingBoxHeight,FMinHeight, FMaxHeight , EDoubleThresholdMode_Outside);
// 			CodeImageSelection.RemoveUsingIntegerFeature(EFeature_TopLimit       ,0         , 3          , EDoubleThresholdMode_Outside);
			CodeImageSelection.RemoveUsingIntegerFeature(EFeature_TopLimit       ,0         , 1          , EDoubleThresholdMode_Outside);
			
			
			BlobCount = CodeImageSelection.GetElementCount();
			CodeImageSelection.Sort(EFeature_LeftLimit,ESortDirection_Ascending);

			if(BlobCount!=0){
				for(int k=0; k<BlobCount; k++){
					if(ACount>=MAX_DEFECT_POINT) break;
					ADefectPoint[ACount].Width  = CodeImageSelection.GetElement(k).GetBoundingBoxWidth() ;
					ADefectPoint[ACount].Height = CodeImageSelection.GetElement(k).GetBoundingBoxHeight();

					ADefectPoint[ACount].Rect.left   =(long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterX() - ADefectPoint[ACount].Width/2 ) +FLTPoint.x);
					ADefectPoint[ACount].Rect.top    =(long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - ADefectPoint[ACount].Height/2) +((TopBMLine[0].FP0.y+TopBMLine[0].FP1.y)/2)-TopOffset);
					ADefectPoint[ACount].Rect.right  =(long)(ADefectPoint[ACount].Rect.left+ ADefectPoint[ACount].Width );
					ADefectPoint[ACount].Rect.bottom =(long)(ADefectPoint[ACount].Rect.top + ADefectPoint[ACount].Height);
					PixelCount = 0;
					PixelValue = 0;

					// 내부 Pixel Data 축출 
					for(int n=ADefectPoint[ACount].Rect.top+1 ; n<ADefectPoint[ACount].Rect.bottom-1; n++){
						for(int m=ADefectPoint[ACount].Rect.left+1; m<ADefectPoint[ACount].Rect.right-1 ; m++){
							PixelValue = IElement(m,n);
							if(PixelValue < EnCapTopThresHold) PixelCount++;
						}
					}

					ADefectPoint[ACount].Round  = PixelCount;
					ADefectPoint[ACount].P.x    =(float)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterX() - ADefectPoint[ACount].Width/2 )+FLTPoint.x) ;
					ADefectPoint[ACount].P.y    =(float)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - ADefectPoint[ACount].Height/2)+((TopBMLine[0].FP0.y+TopBMLine[0].FP1.y)/2)-TopOffset+ImageHeight);

					// Image Rotate 기준 좌표를 다시 Rotate한다 _ Display 목적 
					if(ImgDegree!=0.0f){
						CenterPoint.x = FLTPoint.x +(FRTPoint.x - FLTPoint.x)/2;
						CenterPoint.y = FLTPoint.y+ImageHeight;
						ADefectPoint[ACount].P = Math.OnRotate(CenterPoint,ADefectPoint[ACount].P, ImgDegree);
					}

					// Merge 위해서 데이터 필요함 
					ADefectPoint[ACount].Rect.top    =(long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - ADefectPoint[ACount].Height/2) +((TopBMLine[0].FP0.y+TopBMLine[0].FP1.y)/2)-TopOffset+ImageHeight);
					ADefectPoint[ACount].Rect.bottom =(long)(ADefectPoint[ACount].Rect.top + ADefectPoint[ACount].Height);
					ACount++;
				}
			}

			// SIDE A Remain & Burr 
			if(TopOffset!=0 && BurrTopOffset!=0){
				EasyImage::Threshold(GImage,&DefectImg, BurrFindThresHold);
				DefectROI.Attach(&DefectImg);
				CodeImageSelection.SetFeretAngle(0.00f);
				CodeImageEncoder.GetGrayscaleSingleThresholdSegmenter().SetWhiteLayerEncoded(true );
				CodeImageEncoder.GetGrayscaleSingleThresholdSegmenter().SetBlackLayerEncoded(false);
				
				IAddress = DefectImg.GetImagePtr();
				
				DefectROI.SetPlacement((int)FLTPoint.x, (int)(((TopBMLine[0].FP0.y+TopBMLine[0].FP1.y)/2)-TopOffset -BurrTopOffset-RemainMargin), TopWidth, RemainMargin);
				if((FLTPoint.x) <=0 || FLTPoint.y<=0 || (((TopBMLine[0].FP0.y+TopBMLine[0].FP1.y)/2)-TopOffset -BurrTopOffset-RemainMargin)<=0 || TopWidth<=0 || RemainMargin<=0)return false;
				if((FLTPoint.x) >=ImageWidth || (((TopBMLine[0].FP0.y+TopBMLine[0].FP1.y)/2)-TopOffset -BurrTopOffset-RemainMargin)>TopLimitLine || TopWidth>=ImageWidth || RemainMargin>TopLimitLine) return false;
				
				
				CodeImageSelection.Clear();
				CodeImageEncoder.Encode(DefectROI,CodeImage);
				CodeImageSelection.Clear();
				CodeImageSelection.AddObjects(CodeImage);
				// Blob 필터링 
				CodeImageSelection.RemoveUsingFloatFeature(EFeature_BoundingBoxWidth ,FMinWidth , FMaxWidth  , EDoubleThresholdMode_Outside);
				CodeImageSelection.RemoveUsingFloatFeature(EFeature_BoundingBoxHeight,FMinHeight, FMaxHeight , EDoubleThresholdMode_Outside);
				//CodeImageSelection.RemoveUsingIntegerFeature(EFeature_LeftLimit        ,0       , 3          , EDoubleThresholdMode_Outside);
				
				BlobCount = CodeImageSelection.GetElementCount();
				CodeImageSelection.Sort(EFeature_LeftLimit,ESortDirection_Ascending);
				
				if(BlobCount!=0){
					for(int k=0; k<BlobCount; k++){
						if(ABurrCount>=MAX_DEFECT_POINT) break;
						ABurrPoint[ABurrCount].Width  = CodeImageSelection.GetElement(k).GetBoundingBoxWidth() ;
						ABurrPoint[ABurrCount].Height = CodeImageSelection.GetElement(k).GetBoundingBoxHeight();
						
						ABurrPoint[ABurrCount].Rect.left   =(long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterX() - ABurrPoint[ABurrCount].Width/2 ) +FLTPoint.x);
						ABurrPoint[ABurrCount].Rect.top    =(long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - ABurrPoint[ABurrCount].Height/2) +(((TopBMLine[0].FP0.y+TopBMLine[0].FP1.y)/2)-TopOffset -BurrTopOffset-RemainMargin));
						ABurrPoint[ABurrCount].Rect.right  =(long)(ABurrPoint[ABurrCount].Rect.left+ ABurrPoint[ABurrCount].Width );
						ABurrPoint[ABurrCount].Rect.bottom =(long)(ABurrPoint[ABurrCount].Rect.top + ABurrPoint[ABurrCount].Height);
						PixelCount =0;
						PixelValue =0;
						
						// 내부 Pixel Data 축출 
						for(int n=ABurrPoint[ABurrCount].Rect.top+1 ; n<ABurrPoint[ABurrCount].Rect.bottom-1; n++){
							for(int m=ABurrPoint[ABurrCount].Rect.left+1; m<ABurrPoint[ABurrCount].Rect.right-1 ; m++){
								PixelValue = IElement(m,n);
								if(PixelValue > BurrFindThresHold) PixelCount++;
							}
						}
						
						ABurrPoint[ABurrCount].Round = PixelCount;
						ABurrPoint[ABurrCount].P.x    =(float)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterX() - ABurrPoint[ABurrCount].Width/2 )+FLTPoint.x);
						ABurrPoint[ABurrCount].P.y    =(float)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - ABurrPoint[ABurrCount].Height/2)+(((TopBMLine[0].FP0.y+TopBMLine[0].FP1.y)/2)-TopOffset -BurrTopOffset -RemainMargin)+ImageHeight);
						
						// Merge 위해서 데이터 필요함 
						ABurrPoint[ABurrCount].Rect.top    =(long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - ABurrPoint[ABurrCount].Height/2)+(((TopBMLine[0].FP0.y+TopBMLine[0].FP1.y)/2)-TopOffset -BurrTopOffset-RemainMargin)+ImageHeight);
						ABurrPoint[ABurrCount].Rect.bottom =(long)(ABurrPoint[ABurrCount].Rect.top + ABurrPoint[ABurrCount].Height);
						ABurrCount++;
					}
				}
			}
			////////////////////////////////////////////////////////////////////////////////////////////////
			// 원본 이미지 회전하여 검사 이후 화면에 디스플레이 목적으로 좌표값을 다시 계사한다 
			////////////////////////////////////////////////////////////////////////////////////////////////
			if(ImgDegree!=0.0f){
				CenterPoint.x = FLTPoint.x +(FRTPoint.x - FLTPoint.x)/2;
				CenterPoint.y = FLTPoint.y;

				FRTPoint = Math.OnRotate(CenterPoint, FRTPoint, (ImgDegree));

				CenterPoint.y = FRTPoint.y;
				FLTPoint = Math.OnRotate(CenterPoint, FLTPoint, (ImgDegree));
			}
		}
		BlobCount=0;
		// 외곽라인에서 Mark까지의 거리 산출 
		TDistance = ((FP0.y - Line[waTopWall].FP0.y) +(FP1.y - Line[waTopWall].FP1.y))/2;
		// 전체 이미지 기준 실제 y좌표 
		Mark1YLength =(int)(FP0.y + ImageHeight);
		Mark2YLength =(int)(FP1.y + ImageHeight);

		////////////////////////////////////////////////////////////////////////////////////////////////

		Index = 0;
		return true;
			
		// RectC : 컵모양
		//------------------------------------------------------------------
	case 2 :

		if(IsCornerBtm){
			if(LBDx!=0 && LBDy!=0 && RBDx!=0 && RBDy!=0) {
				// Corner 3
				if(C3EdgeCount!=0){
					CornerCount=0;
					for(int k=0; k<C3EdgeCount; k++){
						if(C3Point[k].y <FLBLPoint.y+1) continue;
						Dis = Math.GetLengthFrLineToPoint(FLBLPoint, FLBBPoint, C3Point[k]);
						C3Corner[CornerCount].Dv   = Dis         ;
						C3Corner[CornerCount].P.x  = C3Point[k].x;
						C3Corner[CornerCount].P.y  = C3Point[k].y;
						CornerCount++;
					}
					C3Count = GetSize(C3Corner, C3DefectPoint, CornerCount, 5);
				}

				// Corner 4
				if(C4EdgeCount!=0){
					CornerCount=0;
					for(int k=0; k<C4EdgeCount; k++){
						if(C4Point[k].y <FRBRPoint.y+1) continue;
						Dis = Math.GetLengthFrLineToPoint(FRBRPoint, FRBBPoint, C4Point[k]);
						C4Corner[CornerCount].Dv   = Dis         ;
						C4Corner[CornerCount].P.x  = C4Point[k].x;
						C4Corner[CornerCount].P.y  = C4Point[k].y;
						CornerCount++;
					}
					C4Count = GetSize(C4Corner, C4DefectPoint, CornerCount, 5);       
				}

				if(FMinWidth==0 || FMinHeight==0){ FMinWidth=1; FMinHeight=1;}



				// Side D 
				///////////////////////////////////////////////////////////////////////////////////////////////////////////////
//  				LogUnit.SetLog("CUP_Side_D_Start_CamId: %d, ImageHeight: %d ",CamId,ImageHeight);     
				if(InspectMode){
					DefectROI.SetPlacement((int)(SP.x-LeftOffset),(int)(SP.y), FLeftWidth, LeftHeight);
					if((SP.x-LeftOffset) <=0 || SP.y<0 || FLeftWidth<=0 || LeftHeight<=0) return false;
			        if((SP.x-LeftOffset) >=ImageWidth || SP.y>BtmLimitLine|| FLeftWidth>=ImageWidth || LeftHeight>BtmLimitLine) return false;

					// Line Position 
					LinePosition = SP.x-LeftOffset;
				}
				else {
					DefectROI.SetPlacement((int)(SP.x+SideMargin),(int)(SP.y+BtmMargin), FLeftWidth, LeftHeight-(2*BtmMargin));
					if((SP.x+SideMargin) <=0          || SP.y+BtmMargin<0            || FLeftWidth<=0          || LeftHeight-(2*BtmMargin)<=0          ) return false;
			        if((SP.x+SideMargin) >=ImageWidth || SP.y+BtmMargin>BtmLimitLine || FLeftWidth>=ImageWidth || LeftHeight-(2*BtmMargin)>BtmLimitLine) return false;
					// Line Position 
					LinePosition = SP.x;
				}
				ROI_X = (int)(SP.x+SideMargin);
				ROI_Y = (int)(SP.y           );
				ROI_W = (int)(FLeftWidth     );
				ROI_H = (int)(LeftHeight     );
				
//  				LogUnit.SetLog("CUP_Side_D_CamId: %d, X: %d, Y: %d, W: %d, H: %d, Limit: %d, ImageHeight: %d ",CamId,ROI_X, ROI_Y,ROI_W,ROI_H, BtmLimitLine, ImageHeight);     

				CodeImageSelection.Clear();
				CodeImageEncoder.Encode(DefectROI,CodeImage);
				CodeImageSelection.Clear();
				CodeImageSelection.AddObjects(CodeImage);
				// Blob 필터링 
				CodeImageSelection.RemoveUsingFloatFeature(EFeature_BoundingBoxWidth ,FMinWidth , FMaxWidth  , EDoubleThresholdMode_Outside);
				CodeImageSelection.RemoveUsingFloatFeature(EFeature_BoundingBoxHeight,FMinHeight, FMaxHeight , EDoubleThresholdMode_Outside);
// 				CodeImageSelection.RemoveUsingIntegerFeature(EFeature_LeftLimit        ,0       , 3          , EDoubleThresholdMode_Outside);
				CodeImageSelection.RemoveUsingIntegerFeature(EFeature_LeftLimit        ,0       , 1          , EDoubleThresholdMode_Outside);
				
				BlobCount = CodeImageSelection.GetElementCount();
				CodeImageSelection.Sort(EFeature_TopLimit,ESortDirection_Ascending);
				
				if(BlobCount!=0){
					for(int k=0; k<BlobCount; k++){
						if(DCount>=MAX_DEFECT_POINT) break;
						DDefectPoint[DCount].Width  =  CodeImageSelection.GetElement(k).GetBoundingBoxWidth() ;
						DDefectPoint[DCount].Height =  CodeImageSelection.GetElement(k).GetBoundingBoxHeight();

						DDefectPoint[DCount].Rect.left   =(long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterX() - DDefectPoint[DCount].Width/2 ) +LinePosition );
						DDefectPoint[DCount].Rect.top    =(long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - DDefectPoint[DCount].Height/2)               );
						DDefectPoint[DCount].Rect.right  =(long)(DDefectPoint[DCount].Rect.left+ DDefectPoint[DCount].Width );
						DDefectPoint[DCount].Rect.bottom =(long)(DDefectPoint[DCount].Rect.top + DDefectPoint[DCount].Height);
						PixelCount =0;
						PixelValue =0;

						// 내부 Pixel Data 축출 
						for(int n=DDefectPoint[DCount].Rect.top+1 ; n<DDefectPoint[DCount].Rect.bottom-1; n++){
							for(int m=DDefectPoint[DCount].Rect.left+1; m<DDefectPoint[DCount].Rect.right-1 ; m++){
								PixelValue = IElement(m,n);
								if(PixelValue < EnCapBtmThresHold) PixelCount++;
							}
						}

						DDefectPoint[DCount].Round = PixelCount;
						DDefectPoint[DCount].P.x    =(float)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterX() - DDefectPoint[DCount].Width/2 ) +LinePosition);
						DDefectPoint[DCount].P.y    =(float)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - DDefectPoint[DCount].Height/2)+ImageHeight);
						DDefectPoint[DCount].Width  = (InspectMode)?DDefectPoint[DCount].Width: DDefectPoint[DCount].Width+SideMargin;

						// Merge 위해서 데이터 필요함 
						DDefectPoint[DCount].Rect.top    =(long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - DDefectPoint[DCount].Height/2) +ImageHeight);
						DDefectPoint[DCount].Rect.bottom =(long)(DDefectPoint[DCount].Rect.top + DDefectPoint[DCount].Height);
						DCount++;
					}
				}
				BlobCount=0;
				// 외곽라인에서 Mark까지의 거리 산출 
				//if     (Line[waLeftWall].FP0.x >Line[waLeftWall].FP1.x) LDistance = FP0.x - (Line[waLeftWall].FP1.x+(Line[waLeftWall].FP0.x - Line[waLeftWall].FP1.x)/2);
				//else if(Line[waLeftWall].FP0.x==Line[waLeftWall].FP1.x) LDistance = FP0.x -  Line[waLeftWall].FP0.x;
				//else                                                    LDistance = FP0.x - (Line[waLeftWall].FP0.x+(Line[waLeftWall].FP1.x - Line[waLeftWall].FP0.x)/2); 

				if     (Line[waLeftWall].FP0.x >Line[waLeftWall].FP1.x) LDistance = ((LeftBMLine[0].FP0.x+ LeftBMLine[0].FP1.x)/2) - (Line[waLeftWall].FP1.x+(Line[waLeftWall].FP0.x - Line[waLeftWall].FP1.x)/2);
				else if(Line[waLeftWall].FP0.x==Line[waLeftWall].FP1.x) LDistance = ((LeftBMLine[0].FP0.x+ LeftBMLine[0].FP1.x)/2) -  Line[waLeftWall].FP0.x;
				else                                                    LDistance = ((LeftBMLine[0].FP0.x+ LeftBMLine[0].FP1.x)/2) - (Line[waLeftWall].FP0.x+(Line[waLeftWall].FP1.x - Line[waLeftWall].FP0.x)/2); 

//  				LogUnit.SetLog("CUP_Side_D_END_CamId: %d, ImageHeight: %d ",CamId,ImageHeight);     

				////////////////////////////////////////////////////////////////////////////////////////////////



				// Side B
				////////////////////////////////////////////////////////////////////////////////////////////////
//  				LogUnit.SetLog("CUP_Side_B_Start_CamId: %d, ImageHeight: %d ",CamId,ImageHeight);     

				if(InspectMode){
					DefectROI.SetPlacement((int)(EP.x-FRightWidth),(int)EP.y, FRightWidth+RightOffset, RightHeight);
					if((EP.x-FRightWidth) <=0 || EP.y<0 || FRightWidth+RightOffset<=0 || RightHeight<=0 ) return false;
			        if((EP.x-FRightWidth) >=ImageWidth || EP.y>BtmLimitLine ||  FRightWidth+RightOffset>=ImageWidth || RightHeight>BtmLimitLine) return false;

					// Line Position 
					LinePosition = EP.x - FRightWidth;
				}
				else{
					DefectROI.SetPlacement((int)(EP.x-FRightWidth-SideMargin),(int)(EP.y+BtmMargin), FRightWidth,  RightHeight-(2*BtmMargin));
					if((EP.x-FRightWidth-SideMargin) <=0          || (EP.y+BtmMargin)<0            || FRightWidth<=0           || RightHeight-(2*BtmMargin)<=0          ) return false;
			        if((EP.x-FRightWidth-SideMargin) >=ImageWidth || (EP.y+BtmMargin)>BtmLimitLine ||  FRightWidth>=ImageWidth || RightHeight-(2*BtmMargin)>BtmLimitLine) return false;

					// Line Position 
					LinePosition = EP.x - FRightWidth- SideMargin;
				}

				ROI_X = (int)(EP.x-FRightWidth-SideMargin);
				ROI_Y = (int)(EP.y           );
				ROI_W = (int)(FRightWidth    );
				ROI_H = (int)(RightHeight    );
				
//  				LogUnit.SetLog("CUP_Side_B_CamId: %d, X: %d, Y: %d, W: %d, H: %d, Limit: %d,  ImageHeight: %d ",CamId,ROI_X, ROI_Y,ROI_W,ROI_H,BtmLimitLine,ImageHeight);     


				CodeImageSelection.Clear();
				CodeImageEncoder.Encode(DefectROI,CodeImage);
				CodeImageSelection.Clear();
				CodeImageSelection.AddObjects(CodeImage);
				// Blob 필터링 
				CodeImageSelection.RemoveUsingFloatFeature  (EFeature_BoundingBoxWidth ,FMinWidth               , FMaxWidth                , EDoubleThresholdMode_Outside);
				CodeImageSelection.RemoveUsingFloatFeature  (EFeature_BoundingBoxHeight,FMinHeight              , FMaxHeight               , EDoubleThresholdMode_Outside);
				if(InspectMode){
					CodeImageSelection.RemoveUsingIntegerFeature(EFeature_RightLimit     ,FRightWidth+RightOffset-2 , FRightWidth+RightOffset+1, EDoubleThresholdMode_Outside);
				}
				else {
// 					CodeImageSelection.RemoveUsingIntegerFeature(EFeature_RightLimit     ,FRightWidth -2            , FRightWidth+1            , EDoubleThresholdMode_Outside);
					CodeImageSelection.RemoveUsingIntegerFeature(EFeature_RightLimit     ,FRightWidth -1            , FRightWidth+1            , EDoubleThresholdMode_Outside);
				}
				
				BlobCount = CodeImageSelection.GetElementCount();
				CodeImageSelection.Sort(EFeature_TopLimit,ESortDirection_Ascending);
				
				if(BlobCount!=0){
					for(int k=0; k<BlobCount; k++){
						if(BCount>=MAX_DEFECT_POINT) break;
						BDefectPoint[BCount].Width  = CodeImageSelection.GetElement(k).GetBoundingBoxWidth() ; 
						BDefectPoint[BCount].Height = CodeImageSelection.GetElement(k).GetBoundingBoxHeight();

						BDefectPoint[BCount].Rect.left   =(long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterX() - BDefectPoint[BCount].Width/2 ) +(LinePosition));
						BDefectPoint[BCount].Rect.top    =(long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - BDefectPoint[BCount].Height/2)                );
						BDefectPoint[BCount].Rect.right  =(long)(BDefectPoint[BCount].Rect.left+ BDefectPoint[BCount].Width );
						BDefectPoint[BCount].Rect.bottom =(long)(BDefectPoint[BCount].Rect.top + BDefectPoint[BCount].Height);
						PixelCount = 0;
						PixelValue = 0;
						
						// 내부 Pixel Data 축출 
						for(int n=BDefectPoint[BCount].Rect.top+1 ; n<BDefectPoint[BCount].Rect.bottom-1; n++){
							for(int m=BDefectPoint[BCount].Rect.left+1; m<BDefectPoint[BCount].Rect.right-1 ; m++){
								PixelValue = IElement(m,n);
								if(PixelValue < EnCapBtmThresHold) PixelCount++;
							}
						}
						BDefectPoint[BCount].Round  = PixelCount;
						BDefectPoint[BCount].P.x    =(float)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterX() - BDefectPoint[BCount].Width/2 )+(LinePosition));
						BDefectPoint[BCount].P.y    =(float)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - BDefectPoint[BCount].Height/2)+ImageHeight   );
                        BDefectPoint[BCount].Width  =(InspectMode)? BDefectPoint[BCount].Width: BDefectPoint[BCount].Width+SideMargin;

						// Merge 위해서 데이터 필요함 
						BDefectPoint[BCount].Rect.top    =(long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - BDefectPoint[BCount].Height/2) +ImageHeight);
						BDefectPoint[BCount].Rect.bottom =(long)(BDefectPoint[BCount].Rect.top + BDefectPoint[BCount].Height);
						BCount++;
					}
				}
				BlobCount =0;
				// 외곽라인에서 Mark까지의 거리 산출 
				//if     (Line[waRightWall].FP0.x >Line[waRightWall].FP1.x) RDistance = (Line[waRightWall].FP1.x+(Line[waRightWall].FP0.x - Line[waRightWall].FP1.x)/2) - FP1.x;
				//else if(Line[waRightWall].FP0.x==Line[waRightWall].FP1.x) RDistance =  Line[waRightWall].FP0.x - FP1.x;
				//else                                                      RDistance = (Line[waRightWall].FP0.x+(Line[waRightWall].FP1.x - Line[waRightWall].FP0.x)/2) - FP1.x;

				if     (Line[waRightWall].FP0.x >Line[waRightWall].FP1.x) RDistance = (Line[waRightWall].FP1.x+(Line[waRightWall].FP0.x - Line[waRightWall].FP1.x)/2) - ((RightBMLine[0].FP0.x+ RightBMLine[0].FP1.x)/2);
				else if(Line[waRightWall].FP0.x==Line[waRightWall].FP1.x) RDistance =  Line[waRightWall].FP0.x                                                        - ((RightBMLine[0].FP0.x+ RightBMLine[0].FP1.x)/2);
				else                                                      RDistance = (Line[waRightWall].FP0.x+(Line[waRightWall].FP1.x - Line[waRightWall].FP0.x)/2) - ((RightBMLine[0].FP0.x+ RightBMLine[0].FP1.x)/2);

//  				LogUnit.SetLog("CUP_Side_B_END_CamId: %d, ImageHeight: %d ",CamId,ImageHeight);     

				////////////////////////////////////////////////////////////////////////////////////////////////


				// Side C 
				///////////////////////////////////////////////////////////////////////////////////////////////
				// BtmBMLine 기준 시퀀스 OverKill다량 발생함 
				//DefectROI.SetPlacement((int)FLBBPoint.x, (int)((BtmBMLine[0].FP0.y+BtmBMLine[0].FP1.y)/2), BtmWidth, BtmOffset);
				//if((FLBBPoint.x) <=0 ||((BtmBMLine[0].FP0.y+BtmBMLine[0].FP1.y)/2)<=0 || BtmWidth<=0 || FBtmHeight<=0  ) return false;
// 				DefectROI.SetPlacement((int)FLBBPoint.x, (int)(((FLBBPoint.y+FRBBPoint.y)/2-FBtmHeight-1)), BtmWidth, FBtmHeight);
// 				if((FLBBPoint.x) <=0 ||((FLBBPoint.y+FRBBPoint.y)/2)-FBtmHeight-1<=0 || BtmWidth<=0 || FBtmHeight<=0  ) return false;
//  				LogUnit.SetLog("CUP_Side_C_Start_CamId: %d, ImageHeight: %d ",CamId,ImageHeight);     

				// Btm검사시 오버킬을 줄위기 위해서 
				if(fabs(FLBBPoint.y - FRBBPoint.y)>3) BTMLine = (FLBBPoint.y > FRBBPoint.y) ?(int)FRBBPoint.y : (int)FLBBPoint.y ;
				else                                  BTMLine = (FLBBPoint.y > FRBBPoint.y) ?(int)FLBBPoint.y : (int)FRBBPoint.y ;

				DefectROI.SetPlacement((int)FLBBPoint.x, (int)(BTMLine-FBtmHeight), BtmWidth, FBtmHeight);
				if((FLBBPoint.x) <=0 ||(BTMLine-FBtmHeight)<=0 || BtmWidth<=0 || FBtmHeight<=0  ) return false;
			    if((FLBBPoint.x) >=ImageWidth ||(BTMLine-FBtmHeight)>BtmLimitLine ||  BtmWidth>=ImageWidth || FBtmHeight>BtmLimitLine) return false;

				//if(BtmLimitLine!=0){
				//	if(((BtmBMLine[0].FP0.y+BtmBMLine[0].FP1.y)/2+BtmOffset)>BtmLimitLine) return false;
				//}

				CodeImageSelection.Clear();
				CodeImageEncoder.Encode(DefectROI,CodeImage);
				CodeImageSelection.Clear();
				CodeImageSelection.AddObjects(CodeImage);
				// Blob 필터링 
				CodeImageSelection.RemoveUsingFloatFeature  (EFeature_BoundingBoxWidth ,FMinWidth      , FMaxWidth   , EDoubleThresholdMode_Outside);
				CodeImageSelection.RemoveUsingFloatFeature  (EFeature_BoundingBoxHeight,FMinHeight     , FMaxHeight  , EDoubleThresholdMode_Outside);
				CodeImageSelection.RemoveUsingIntegerFeature(EFeature_BottomLimit      ,FBtmHeight-1   , FBtmHeight+1, EDoubleThresholdMode_Outside);

				
				BlobCount = CodeImageSelection.GetElementCount();
				CodeImageSelection.Sort(EFeature_LeftLimit ,ESortDirection_Ascending);
				
				if(BlobCount!=0){
					for(int k=0; k<BlobCount; k++){
						if(CCount>=MAX_DEFECT_POINT) break; 
						CDefectPoint[CCount].Width  =  CodeImageSelection.GetElement(k).GetBoundingBoxWidth() ;
						CDefectPoint[CCount].Height =  CodeImageSelection.GetElement(k).GetBoundingBoxHeight();

						CDefectPoint[CCount].Rect.left   =(long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterX() - CDefectPoint[CCount].Width/2 ) +FLBBPoint.x);
// 						CDefectPoint[CCount].Rect.top    =(long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - CDefectPoint[CCount].Height/2) +((FLBBPoint.y+FRBBPoint.y)/2-FBtmHeight-1));
						CDefectPoint[CCount].Rect.top    =(long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - CDefectPoint[CCount].Height/2) +(BTMLine-FBtmHeight));
						CDefectPoint[CCount].Rect.right  =(long)(CDefectPoint[CCount].Rect.left+ CDefectPoint[CCount].Width );
						CDefectPoint[CCount].Rect.bottom =(long)(CDefectPoint[CCount].Rect.top + CDefectPoint[CCount].Height);
						PixelCount = 0;
						PixelValue = 0;
						
						// 내부 Pixel Data 축출 
						for(int n=CDefectPoint[CCount].Rect.top+1 ; n<CDefectPoint[CCount].Rect.bottom-1; n++){
							for(int m=CDefectPoint[CCount].Rect.left+1; m<CDefectPoint[CCount].Rect.right-1 ; m++){
								PixelValue = IElement(m,n);
								if(PixelValue < EnCapBtmThresHold) PixelCount++;
							}
						}
						CDefectPoint[CCount].Round  =  PixelCount;
						CDefectPoint[CCount].P.x    = (float)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterX() - CDefectPoint[CCount].Width/2 )+FLBBPoint.x);
// 						CDefectPoint[CCount].P.y    = (float)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - CDefectPoint[CCount].Height/2)+((FLBBPoint.y+FRBBPoint.y)/2-FBtmHeight-1)+ImageHeight);
						CDefectPoint[CCount].P.y    = (float)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - CDefectPoint[CCount].Height/2)+(BTMLine-FBtmHeight)+ImageHeight);

						if(ImgDegree!=0.0f){
							CenterPoint.x = FLBPoint.x +(FRBPoint.x - FLBPoint.x)/2;
							CenterPoint.y = FLBPoint.y+ImageHeight;
							CDefectPoint[CCount].P = Math.OnRotate(CenterPoint,CDefectPoint[CCount].P, ImgDegree);
						}

						// Merge 위해서 데이터 필요함 
// 						CDefectPoint[CCount].Rect.top    =(long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - CDefectPoint[CCount].Height/2) +((FLBBPoint.y+FRBBPoint.y)/2-FBtmHeight-1)+ImageHeight);
						CDefectPoint[CCount].Rect.top    =(long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - CDefectPoint[CCount].Height/2) +(BTMLine-FBtmHeight)+ImageHeight);
						CDefectPoint[CCount].Rect.bottom =(long)(CDefectPoint[CCount].Rect.top + CDefectPoint[CCount].Height);
						CCount++;
					}
				}
				BlobCount =0;
//  				LogUnit.SetLog("CUP_Side_C_END_CamId: %d, ImageHeight: %d ",CamId,ImageHeight);     



                // SIDE D Remain & Burr 
				if(LeftOffset!=0 && BurrLeftOffset!=0){
//  				    LogUnit.SetLog("CUP_Side_D_BURR_START_CamId: %d, ImageHeight: %d ",CamId,ImageHeight);     
					EasyImage::Threshold(GImage,&DefectImg, BurrFindThresHold);
					DefectROI.Attach(&DefectImg);
					CodeImageSelection.SetFeretAngle(0.00f);
					CodeImageEncoder.GetGrayscaleSingleThresholdSegmenter().SetWhiteLayerEncoded(true );
					CodeImageEncoder.GetGrayscaleSingleThresholdSegmenter().SetBlackLayerEncoded(false);
					
					IAddress = DefectImg.GetImagePtr();
					
					DefectROI.SetPlacement((int)(LeftBMLine[0].FP0.x - LeftOffset-BurrLeftOffset-RemainMargin),(int)SP.y, RemainMargin, LeftHeight);
					if((LeftBMLine[0].FP0.x - LeftOffset-BurrLeftOffset-RemainMargin) <=0 || (SP.y)<0 || BurrLeftOffset<0 || LeftHeight<=0) return false;
			        if((LeftBMLine[0].FP0.x - LeftOffset-BurrLeftOffset-RemainMargin) >=ImageWidth ||SP.y>BtmLimitLine ||  RemainMargin>=ImageWidth || LeftHeight>BtmLimitLine) return false;
					
					CodeImageSelection.Clear();
					CodeImageEncoder.Encode(DefectROI,CodeImage);
					CodeImageSelection.Clear();
					CodeImageSelection.AddObjects(CodeImage);
					// Blob 필터링 
					CodeImageSelection.RemoveUsingFloatFeature(EFeature_BoundingBoxWidth ,FMinWidth , FMaxWidth  , EDoubleThresholdMode_Outside);
					CodeImageSelection.RemoveUsingFloatFeature(EFeature_BoundingBoxHeight,FMinHeight, FMaxHeight , EDoubleThresholdMode_Outside);
					//CodeImageSelection.RemoveUsingIntegerFeature(EFeature_LeftLimit        ,0       , 3          , EDoubleThresholdMode_Outside);
					
					BlobCount = CodeImageSelection.GetElementCount();
					CodeImageSelection.Sort(EFeature_TopLimit,ESortDirection_Ascending);
					
					if(BlobCount!=0){
						for(int k=0; k<BlobCount; k++){
							if(DBurrCount>=MAX_DEFECT_POINT) break; 
							DBurrPoint[DBurrCount].Width  = CodeImageSelection.GetElement(k).GetBoundingBoxWidth() ;
							DBurrPoint[DBurrCount].Height = CodeImageSelection.GetElement(k).GetBoundingBoxHeight();
							
							DBurrPoint[DBurrCount].Rect.left   =(long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterX() - DBurrPoint[DBurrCount].Width/2 ) +(LeftBMLine[0].FP0.x - LeftOffset-BurrLeftOffset-RemainMargin));
							DBurrPoint[DBurrCount].Rect.top    =(long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - DBurrPoint[DBurrCount].Height/2)                                                                );
							DBurrPoint[DBurrCount].Rect.right  =(long)(DBurrPoint[DBurrCount].Rect.left+ DBurrPoint[DBurrCount].Width );
							DBurrPoint[DBurrCount].Rect.bottom =(long)(DBurrPoint[DBurrCount].Rect.top + DBurrPoint[DBurrCount].Height);
							PixelCount =0;
							PixelValue =0;
							
							// 내부 Pixel Data 축출 
							for(int n=DBurrPoint[DBurrCount].Rect.top+1 ; n<DBurrPoint[DBurrCount].Rect.bottom-1; n++){
								for(int m=DBurrPoint[DBurrCount].Rect.left+1; m<DBurrPoint[DBurrCount].Rect.right-1 ; m++){
									PixelValue = IElement(m,n);
									if(PixelValue > BurrFindThresHold) PixelCount++;
								}
							}
							
							DBurrPoint[DBurrCount].Round = PixelCount;
							DBurrPoint[DBurrCount].P.x    =(float)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterX() - DBurrPoint[DBurrCount].Width/2 )+(LeftBMLine[0].FP0.x - LeftOffset-BurrLeftOffset-RemainMargin));
							DBurrPoint[DBurrCount].P.y    =(float)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - DBurrPoint[DBurrCount].Height/2)+ImageHeight);
							
							// Merge 위해서 데이터 필요함 
							DBurrPoint[DBurrCount].Rect.top    =(long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - DBurrPoint[DBurrCount].Height/2)+ImageHeight);
							DBurrPoint[DBurrCount].Rect.bottom =(long)(DBurrPoint[DBurrCount].Rect.top + DBurrPoint[DBurrCount].Height);
							DBurrCount++;
						}
					}
				}
//  				LogUnit.SetLog("CUP_Side_D_BURR_END_CamId: %d, ImageHeight: %d ",CamId,ImageHeight);     
				BlobCount =0;

                // SIDE B Remain & Burr 
				if(RightOffset!=0 && BurrRightOffset!=0){
//  				    LogUnit.SetLog("CUP_Side_B_BURR_START_CamId: %d, ImageHeight: %d ",CamId,ImageHeight);     
					EasyImage::Threshold(GImage,&DefectImg, BurrFindThresHold);
					DefectROI.Attach(&DefectImg);
					CodeImageSelection.SetFeretAngle(0.00f);
					CodeImageEncoder.GetGrayscaleSingleThresholdSegmenter().SetWhiteLayerEncoded(true );
					CodeImageEncoder.GetGrayscaleSingleThresholdSegmenter().SetBlackLayerEncoded(false);
					
					IAddress = DefectImg.GetImagePtr();
					
					DefectROI.SetPlacement((int)(RightBMLine[0].FP0.x + RightOffset+BurrRightOffset),(int)EP.y, RemainMargin, RightHeight);
					if((RightBMLine[0].FP0.x + RightOffset+BurrRightOffset) <=0 ||(EP.y)<0 || RemainMargin<0 || RightHeight<=0) return false;
			        if((RightBMLine[0].FP0.x + RightOffset+BurrRightOffset) >=ImageWidth ||EP.y>BtmLimitLine ||  RemainMargin>=ImageWidth || RightHeight>BtmLimitLine) return false;

					CodeImageSelection.Clear();
					CodeImageEncoder.Encode(DefectROI,CodeImage);
					CodeImageSelection.Clear();
					CodeImageSelection.AddObjects(CodeImage);
					// Blob 필터링 
					CodeImageSelection.RemoveUsingFloatFeature(EFeature_BoundingBoxWidth ,FMinWidth , FMaxWidth  , EDoubleThresholdMode_Outside);
					CodeImageSelection.RemoveUsingFloatFeature(EFeature_BoundingBoxHeight,FMinHeight, FMaxHeight , EDoubleThresholdMode_Outside);
					//CodeImageSelection.RemoveUsingIntegerFeature(EFeature_LeftLimit        ,0       , 3          , EDoubleThresholdMode_Outside);
					
					BlobCount = CodeImageSelection.GetElementCount();
					CodeImageSelection.Sort(EFeature_TopLimit,ESortDirection_Ascending);
					
					if(BlobCount!=0){
						for(int k=0; k<BlobCount; k++){
							if(BBurrCount>=MAX_DEFECT_POINT) break; 
							BBurrPoint[BBurrCount].Width  = CodeImageSelection.GetElement(k).GetBoundingBoxWidth() ;
							BBurrPoint[BBurrCount].Height = CodeImageSelection.GetElement(k).GetBoundingBoxHeight();
							
							BBurrPoint[BBurrCount].Rect.left   =(long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterX() - BBurrPoint[BBurrCount].Width/2 ) +(RightBMLine[0].FP0.x + RightOffset+BurrRightOffset));
							BBurrPoint[BBurrCount].Rect.top    =(long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - BBurrPoint[BBurrCount].Height/2)                                                      );
							BBurrPoint[BBurrCount].Rect.right  =(long)(BBurrPoint[BBurrCount].Rect.left+ BBurrPoint[BBurrCount].Width );
							BBurrPoint[BBurrCount].Rect.bottom =(long)(BBurrPoint[BBurrCount].Rect.top + BBurrPoint[BBurrCount].Height);
							PixelCount =0;
							PixelValue =0;
							
							// 내부 Pixel Data 축출 
							for(int n=BBurrPoint[BBurrCount].Rect.top+1 ; n<BBurrPoint[BBurrCount].Rect.bottom-1; n++){
								for(int m=BBurrPoint[BBurrCount].Rect.left+1; m<BBurrPoint[BBurrCount].Rect.right-1; m++){
									PixelValue = IElement(m,n);
									if(PixelValue > BurrFindThresHold) PixelCount++;
								}
							}
							
							BBurrPoint[BBurrCount].Round = PixelCount;
							BBurrPoint[BBurrCount].P.x    =(float)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterX() - BBurrPoint[BBurrCount].Width/2 )+(RightBMLine[0].FP0.x + RightOffset+BurrRightOffset));
							BBurrPoint[BBurrCount].P.y    =(float)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - BBurrPoint[BBurrCount].Height/2)+ImageHeight);
							
							// Merge 위해서 데이터 필요함 
							BBurrPoint[BBurrCount].Rect.top    =(long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - BBurrPoint[BBurrCount].Height/2)+ImageHeight);
							BBurrPoint[BBurrCount].Rect.bottom =(long)(BBurrPoint[BBurrCount].Rect.top + BBurrPoint[BBurrCount].Height);
							BBurrCount++;
						}
					}
				}
//  				LogUnit.SetLog("CUP_Side_B_BURR_END_CamId: %d, ImageHeight: %d ",CamId,ImageHeight);     
				BlobCount =0;


				// SIDE C Remain & Burr 
				if(BtmOffset!=0 && BurrBtmOffset!=0){
//  				    LogUnit.SetLog("CUP_Side_C_BURR_START_CamId: %d, ImageHeight: %d ",CamId,ImageHeight);     

					EasyImage::Threshold(GImage,&DefectImg, BurrFindThresHold);
					DefectROI.Attach(&DefectImg);
					CodeImageSelection.SetFeretAngle(0.00f);
					CodeImageEncoder.GetGrayscaleSingleThresholdSegmenter().SetWhiteLayerEncoded(true );
					CodeImageEncoder.GetGrayscaleSingleThresholdSegmenter().SetBlackLayerEncoded(false);
					
					IAddress = DefectImg.GetImagePtr();

					DefectROI.SetPlacement((int)FLBBPoint.x, (int)((BtmBMLine[0].FP0.y+BtmBMLine[0].FP1.y)/2 +BtmOffset+BurrBtmOffset), BtmWidth, RemainMargin);
					if((FLBBPoint.x) <=0 ||((BtmBMLine[0].FP0.y+BtmBMLine[0].FP1.y)/2 +BtmOffset+BurrBtmOffset)<=0 || BtmWidth<=0 || RemainMargin<=0  ) return false;
			        if((FLBBPoint.x) >=ImageWidth ||((BtmBMLine[0].FP0.y+BtmBMLine[0].FP1.y)/2 +BtmOffset+BurrBtmOffset)>BtmLimitLine ||  BtmWidth>=ImageWidth || RemainMargin>BtmLimitLine) return false;

					// 프레임 Buffer Over해서 검사시 리턴한다 
					if(BtmLimitLine!=0){
						if(((BtmBMLine[0].FP0.y+BtmBMLine[0].FP1.y)/2+BurrBtmOffset+BtmOffset+RemainMargin)>BtmLimitLine) return false;
					}
					
					CodeImageSelection.Clear();
					CodeImageEncoder.Encode(DefectROI,CodeImage);
					CodeImageSelection.Clear();
					CodeImageSelection.AddObjects(CodeImage);
					// Blob 필터링 
					CodeImageSelection.RemoveUsingFloatFeature(EFeature_BoundingBoxWidth ,FMinWidth    , FMaxWidth   , EDoubleThresholdMode_Outside);
					CodeImageSelection.RemoveUsingFloatFeature(EFeature_BoundingBoxHeight,FMinHeight   , FMaxHeight  , EDoubleThresholdMode_Outside);
					//CodeImageSelection.RemoveUsingIntegerFeature(EFeature_BottomLimit    ,FBtmHeight-1 , FBtmHeight+1, EDoubleThresholdMode_Outside);
					
					
					BlobCount = CodeImageSelection.GetElementCount();
					CodeImageSelection.Sort(EFeature_LeftLimit,ESortDirection_Ascending);
					
					if(BlobCount!=0){
						for(int k=0; k<BlobCount; k++){
							if(CBurrCount>=MAX_DEFECT_POINT) break; 
							CBurrPoint[CBurrCount].Width  =  CodeImageSelection.GetElement(k).GetBoundingBoxWidth() ;
							CBurrPoint[CBurrCount].Height =  CodeImageSelection.GetElement(k).GetBoundingBoxHeight();
							
							CBurrPoint[CBurrCount].Rect.left   =(long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterX() - CBurrPoint[CBurrCount].Width/2 ) +FLBBPoint.x);
							CBurrPoint[CBurrCount].Rect.top    =(long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - CBurrPoint[CBurrCount].Height/2) +(BtmBMLine[0].FP0.y+BtmBMLine[0].FP1.y)/2 +BtmOffset+BurrBtmOffset);
							CBurrPoint[CBurrCount].Rect.right  =(long)(CBurrPoint[CBurrCount].Rect.left+ CBurrPoint[CBurrCount].Width );
							CBurrPoint[CBurrCount].Rect.bottom =(long)(CBurrPoint[CBurrCount].Rect.top + CBurrPoint[CBurrCount].Height);
							PixelCount = 0;
							PixelValue = 0;
							
							// 내부 Pixel Data 축출 
							for(int n=CBurrPoint[CBurrCount].Rect.top+1 ; n<CBurrPoint[CBurrCount].Rect.bottom-1; n++){
								for(int m=CBurrPoint[CBurrCount].Rect.left+1; m<CBurrPoint[CBurrCount].Rect.right-1 ; m++){
									PixelValue = IElement(m,n);
									if(PixelValue < EnCapBtmThresHold) PixelCount++;
								}
							}
							CBurrPoint[CBurrCount].Round  =  PixelCount;
							CBurrPoint[CBurrCount].P.x    = (float)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterX() - CBurrPoint[CBurrCount].Width/2 )+FLBBPoint.x);
							CBurrPoint[CBurrCount].P.y    = (float)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - CBurrPoint[CBurrCount].Height/2)+((BtmBMLine[0].FP0.y+BtmBMLine[0].FP1.y)/2 +BtmOffset+BurrBtmOffset)+ImageHeight);
							
							// Merge 위해서 데이터 필요함 
							CBurrPoint[CBurrCount].Rect.top    =(long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - CBurrPoint[CBurrCount].Height/2) +(BtmBMLine[0].FP0.y+BtmBMLine[0].FP1.y)/2 +BtmOffset+BurrBtmOffset+ImageHeight);
							CBurrPoint[CBurrCount].Rect.bottom =(long)(CBurrPoint[CBurrCount].Rect.top + CBurrPoint[CBurrCount].Height);
							CBurrCount++;
							
						}
					}
					BlobCount =0;
//  				    LogUnit.SetLog("CUP_Side_C_BURR_END_CamId: %d, ImageHeight: %d ",CamId,ImageHeight);     
				}
				// 외곽라인에서 Mark까지의 거리 산출 
				//BDistance  = (((Line[waBottomWall].FP0.y+ImageHeight) - Mark1YLength) +((Line[waBottomWall].FP1.y+ImageHeight) - Mark2YLength))/2;
				//BDistance  = TDistance;
				BDistance  = ((Line[waBottomWall].FP0.y-BtmBMLine[0].FP0.y)+(Line[waBottomWall].FP1.y-BtmBMLine[0].FP1.y))/2;
				////////////////////////////////////////////////////////////////////////////////////////////////
				// 원본 이미지 회전하여 검사 이후 화면에 디스플레이 목적으로 좌표값을 다시 계사한다 
				////////////////////////////////////////////////////////////////////////////////////////////////
				if(ImgDegree!=0.0f){
					CenterPoint.x = FLBPoint.x +(FRBPoint.x - FLBPoint.x)/2;
					CenterPoint.y = FLBPoint.y;

					FRBPoint         = Math.OnRotate(CenterPoint, FRBPoint        , (ImgDegree));
					BtmBMLine[0].FP1 = Math.OnRotate(CenterPoint, BtmBMLine[0].FP1, (ImgDegree));

					CenterPoint.y = FRBPoint.y;
					FLBPoint         = Math.OnRotate(CenterPoint, FLBPoint, (ImgDegree));
					BtmBMLine[0].FP0 = Math.OnRotate(CenterPoint, BtmBMLine[0].FP0, (ImgDegree));
				}
			}
		}
		else {
			if(FMinWidth==0 || FMinHeight==0){ FMinWidth=1; FMinHeight=1;}

			// Side D 
			////////////////////////////////////////////////////////////////////////////////////////
			if(InspectMode){
				DefectROI.SetPlacement((int)(SP.x-LeftOffset),(int)SP.y, FLeftWidth, LeftHeight);
				if((SP.x-LeftOffset) <=0 || SP.y<0 || FLeftWidth<=0 || LeftHeight<=0 ) return false;
			    if((SP.x-LeftOffset) >=ImageWidth || SP.y>BtmLimitLine ||  FLeftWidth>=ImageWidth || LeftHeight>BtmLimitLine) return false;

				// Line Position
				LinePosition = SP.x-LeftOffset;
			}
			else {
				DefectROI.SetPlacement((int)(SP.x),(int)(SP.y+BtmMargin), FLeftWidth, LeftHeight-(2*BtmMargin));
				if((SP.x) <=0          || (SP.y+BtmMargin)<0            || FLeftWidth<=0           || LeftHeight-(2*BtmMargin)<=0          ) return false;
			    if((SP.x) >=ImageWidth || (SP.y+BtmMargin)>BtmLimitLine ||  FLeftWidth>=ImageWidth || LeftHeight-(2*BtmMargin)>BtmLimitLine) return false;
				// Line Position
				LinePosition = SP.x;
			}

			CodeImageSelection.Clear();
			CodeImageEncoder.Encode(DefectROI,CodeImage);
			CodeImageSelection.Clear();
			CodeImageSelection.AddObjects(CodeImage);
			// Blob 필터링 
			CodeImageSelection.RemoveUsingFloatFeature(EFeature_BoundingBoxWidth ,FMinWidth , FMaxWidth  , EDoubleThresholdMode_Outside);
			CodeImageSelection.RemoveUsingFloatFeature(EFeature_BoundingBoxHeight,FMinHeight, FMaxHeight , EDoubleThresholdMode_Outside);
// 			CodeImageSelection.RemoveUsingIntegerFeature(EFeature_LeftLimit        ,0       , 3          , EDoubleThresholdMode_Outside);
			CodeImageSelection.RemoveUsingIntegerFeature(EFeature_LeftLimit        ,0       , 2          , EDoubleThresholdMode_Outside);
			
			BlobCount = CodeImageSelection.GetElementCount();
			CodeImageSelection.Sort(EFeature_TopLimit,ESortDirection_Ascending);
			
			if(BlobCount!=0){
				for(int k=0; k<BlobCount; k++){
					if(DCount>=MAX_DEFECT_POINT) break; 
					DDefectPoint[DCount].Width  =  CodeImageSelection.GetElement(k).GetBoundingBoxWidth() ;
					DDefectPoint[DCount].Height =  CodeImageSelection.GetElement(k).GetBoundingBoxHeight();

					DDefectPoint[DCount].Rect.left   =(long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterX() - DDefectPoint[DCount].Width/2 ) +LinePosition);
					DDefectPoint[DCount].Rect.top    =(long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - DDefectPoint[DCount].Height/2)              );
					DDefectPoint[DCount].Rect.right  =(long)(DDefectPoint[DCount].Rect.left+ DDefectPoint[DCount].Width );
					DDefectPoint[DCount].Rect.bottom =(long)(DDefectPoint[DCount].Rect.top + DDefectPoint[DCount].Height);
					PixelCount =0;
					PixelValue =0;

					// 내부 Pixel Data 축출 
					for(int n=DDefectPoint[DCount].Rect.top+1 ; n<DDefectPoint[DCount].Rect.bottom-1; n++){
						for(int m=DDefectPoint[DCount].Rect.left+1; m<DDefectPoint[DCount].Rect.right-1 ; m++){
							PixelValue = IElement(m,n);
							if(PixelValue < EnCapBtmThresHold) PixelCount++;
						}
					}

					DDefectPoint[DCount].Round = PixelCount;
					DDefectPoint[DCount].P.x    =(float)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterX() - DDefectPoint[DCount].Width/2 ) +LinePosition   );
					DDefectPoint[DCount].P.y    =(float)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - DDefectPoint[DCount].Height/2)+ImageHeight     );

					// Merge 위해서 데이터 필요함 
					DDefectPoint[DCount].Rect.top    =(long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - DDefectPoint[DCount].Height/2) +ImageHeight);
					DDefectPoint[DCount].Rect.bottom =(long)(DDefectPoint[DCount].Rect.top + DDefectPoint[DCount].Height);
					DCount++;
				}
			}
			BlobCount=0;
			// 외곽라인에서 Mark까지의 거리 산출 
			//if     (Line[waLeftWall].FP0.x >Line[waLeftWall].FP1.x) LDistance = FP0.x - (Line[waLeftWall].FP1.x+(Line[waLeftWall].FP0.x - Line[waLeftWall].FP1.x)/2);
			//else if(Line[waLeftWall].FP0.x==Line[waLeftWall].FP1.x) LDistance = FP0.x -  Line[waLeftWall].FP0.x;
			//else                                                    LDistance = FP0.x - (Line[waLeftWall].FP0.x+(Line[waLeftWall].FP1.x - Line[waLeftWall].FP0.x)/2); 

			if     (Line[waLeftWall].FP0.x >Line[waLeftWall].FP1.x) LDistance = ((LeftBMLine[0].FP0.x+ LeftBMLine[0].FP1.x)/2) - (Line[waLeftWall].FP1.x+(Line[waLeftWall].FP0.x - Line[waLeftWall].FP1.x)/2);
			else if(Line[waLeftWall].FP0.x==Line[waLeftWall].FP1.x) LDistance = ((LeftBMLine[0].FP0.x+ LeftBMLine[0].FP1.x)/2) -  Line[waLeftWall].FP0.x;
			else                                                    LDistance = ((LeftBMLine[0].FP0.x+ LeftBMLine[0].FP1.x)/2) - (Line[waLeftWall].FP0.x+(Line[waLeftWall].FP1.x - Line[waLeftWall].FP0.x)/2); 
			////////////////////////////////////////////////////////////////////////////////////////////////



			// Side B
			////////////////////////////////////////////////////////////////////////////////////////////////
			if(InspectMode){
				DefectROI.SetPlacement((int)(EP.x-FRightWidth),(int)EP.y, FRightWidth+RightOffset, RightHeight);
				if((EP.x-FRightWidth) <=0 || EP.y<0 || FRightWidth+RightOffset<=0 || RightHeight<=0 ) return false;
			    if((EP.x-FRightWidth) >=ImageWidth || EP.y>BtmLimitLine ||  FRightWidth+RightOffset>=ImageWidth || RightHeight>BtmLimitLine) return false;

				// Line Position
				LinePosition = EP.x-FRightWidth;
			}
			else {
				DefectROI.SetPlacement((int)(EP.x-FRightWidth),(int)(EP.y+BtmMargin), FRightWidth, RightHeight-(2*BtmMargin));
				if((EP.x-FRightWidth) <=0          || (EP.y+BtmMargin)<0            || FRightWidth<=0           || RightHeight-(2*BtmMargin)<=0          ) return false;
			    if((EP.x-FRightWidth) >=ImageWidth || (EP.y+BtmMargin)>BtmLimitLine ||  FRightWidth>=ImageWidth || RightHeight-(2*BtmMargin)>BtmLimitLine) return false;
				
				// Line Position
				LinePosition = EP.x-FRightWidth;
			}

			CodeImageSelection.Clear();
			CodeImageEncoder.Encode(DefectROI,CodeImage);
			CodeImageSelection.Clear();
			CodeImageSelection.AddObjects(CodeImage);
			// Blob 필터링 
			CodeImageSelection.RemoveUsingFloatFeature(EFeature_BoundingBoxWidth ,FMinWidth     , FMaxWidth    , EDoubleThresholdMode_Outside);
			CodeImageSelection.RemoveUsingFloatFeature(EFeature_BoundingBoxHeight,FMinHeight    , FMaxHeight   , EDoubleThresholdMode_Outside);
			if(InspectMode){
				CodeImageSelection.RemoveUsingIntegerFeature(EFeature_RightLimit     ,FRightWidth+RightOffset-2 , FRightWidth+RightOffset+1, EDoubleThresholdMode_Outside);
			}
			else {
// 				CodeImageSelection.RemoveUsingIntegerFeature(EFeature_RightLimit     ,FRightWidth-2             , FRightWidth+1            , EDoubleThresholdMode_Outside);
				CodeImageSelection.RemoveUsingIntegerFeature(EFeature_RightLimit     ,FRightWidth-1             , FRightWidth+1            , EDoubleThresholdMode_Outside);
			}
			
			BlobCount = CodeImageSelection.GetElementCount();
			CodeImageSelection.Sort(EFeature_TopLimit,ESortDirection_Ascending);
			
			if(BlobCount!=0){
				for(int k=0; k<BlobCount; k++){
					if(BCount>=MAX_DEFECT_POINT) break; 
					BDefectPoint[BCount].Width  = CodeImageSelection.GetElement(k).GetBoundingBoxWidth() ;
					BDefectPoint[BCount].Height = CodeImageSelection.GetElement(k).GetBoundingBoxHeight();

					BDefectPoint[BCount].Rect.left   =(long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterX() - BDefectPoint[BCount].Width/2 ) +(LinePosition));
					BDefectPoint[BCount].Rect.top    =(long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - BDefectPoint[BCount].Height/2)                );
					BDefectPoint[BCount].Rect.right  =(long)(BDefectPoint[BCount].Rect.left+ BDefectPoint[BCount].Width );
					BDefectPoint[BCount].Rect.bottom =(long)(BDefectPoint[BCount].Rect.top + BDefectPoint[BCount].Height);
					PixelCount = 0;
					PixelValue = 0;
					
					// 내부 Pixel Data 축출 
					for(int n=BDefectPoint[BCount].Rect.top+1 ; n<BDefectPoint[BCount].Rect.bottom-1; n++){
						for(int m=BDefectPoint[BCount].Rect.left+1; m<BDefectPoint[BCount].Rect.right-1 ; m++){
							PixelValue = IElement(m,n);
							if(PixelValue < EnCapBtmThresHold) PixelCount++;
						}
					}
					BDefectPoint[BCount].Round  = PixelCount;
					BDefectPoint[BCount].P.x    =(float)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterX() - BDefectPoint[BCount].Width/2 )+(LinePosition));
					BDefectPoint[BCount].P.y    =(float)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - BDefectPoint[BCount].Height/2)+ImageHeight   );

					// Merge 위해서 데이터 필요함 
					BDefectPoint[BCount].Rect.top    =(long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - BDefectPoint[BCount].Height/2) +ImageHeight);
					BDefectPoint[BCount].Rect.bottom =(long)(BDefectPoint[BCount].Rect.top + BDefectPoint[BCount].Height);
					BCount++;
				}
			}
		
			BlobCount =0;
			// 외곽라인에서 Mark까지의 거리 산출 
			//if     (Line[waRightWall].FP0.x >Line[waRightWall].FP1.x) RDistance = (Line[waRightWall].FP1.x+(Line[waRightWall].FP0.x - Line[waRightWall].FP1.x)/2) - FP1.x;
			//else if(Line[waRightWall].FP0.x==Line[waRightWall].FP1.x) RDistance =  Line[waRightWall].FP0.x - FP1.x;
			//else                                                      RDistance = (Line[waRightWall].FP0.x+(Line[waRightWall].FP1.x - Line[waRightWall].FP0.x)/2) - FP1.x;

			if     (Line[waRightWall].FP0.x >Line[waRightWall].FP1.x) RDistance = (Line[waRightWall].FP1.x+(Line[waRightWall].FP0.x - Line[waRightWall].FP1.x)/2) - ((RightBMLine[0].FP0.x+ RightBMLine[0].FP1.x)/2);
			else if(Line[waRightWall].FP0.x==Line[waRightWall].FP1.x) RDistance =  Line[waRightWall].FP0.x                                                        - ((RightBMLine[0].FP0.x+ RightBMLine[0].FP1.x)/2);
			else                                                      RDistance = (Line[waRightWall].FP0.x+(Line[waRightWall].FP1.x - Line[waRightWall].FP0.x)/2) - ((RightBMLine[0].FP0.x+ RightBMLine[0].FP1.x)/2);

			////////////////////////////////////////////////////////////////////////////////////////////////



			// Side C 
			///////////////////////////////////////////////////////////////////////////////////////////////
			DefectROI.SetPlacement((int)(FLBPoint.x+1),(int)((BtmBMLine[0].FP0.y+BtmBMLine[0].FP1.y)/2), BtmWidth-1, BtmOffset);
			if((FLBPoint.x+1) <=0 ||((BtmBMLine[0].FP0.y+BtmBMLine[0].FP1.y)/2)<=0 || BtmWidth-1<=0 || BtmOffset<=0  ) return false;
			if((FLBPoint.x+1) >=ImageWidth || ((BtmBMLine[0].FP0.y+BtmBMLine[0].FP1.y)/2)>BtmLimitLine ||  BtmWidth-1>=ImageWidth || BtmOffset>BtmLimitLine) return false;


			CodeImageSelection.Clear();
			CodeImageEncoder.Encode(DefectROI,CodeImage);
			CodeImageSelection.Clear();
			CodeImageSelection.AddObjects(CodeImage);
			// Blob 필터링 
			CodeImageSelection.RemoveUsingFloatFeature(EFeature_BoundingBoxWidth ,FMinWidth    , FMaxWidth   , EDoubleThresholdMode_Outside);
			CodeImageSelection.RemoveUsingFloatFeature(EFeature_BoundingBoxHeight,FMinHeight   , FMaxHeight  , EDoubleThresholdMode_Outside);
			CodeImageSelection.RemoveUsingIntegerFeature(EFeature_BottomLimit    ,BtmOffset-1  , BtmOffset+1 , EDoubleThresholdMode_Outside);

			
			BlobCount = CodeImageSelection.GetElementCount();
			CodeImageSelection.Sort(EFeature_LeftLimit,ESortDirection_Ascending);
			
			if(BlobCount!=0){
				for(int k=0; k<BlobCount; k++){
					if(CCount>=MAX_DEFECT_POINT) break; 
					CDefectPoint[CCount].Width  =  CodeImageSelection.GetElement(k).GetBoundingBoxWidth() ;
					CDefectPoint[CCount].Height =  CodeImageSelection.GetElement(k).GetBoundingBoxHeight();

					CDefectPoint[CCount].Rect.left   =(long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterX() - CDefectPoint[CCount].Width/2 ) +FLBPoint.x);
					CDefectPoint[CCount].Rect.top    =(long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - CDefectPoint[CCount].Height/2)+((BtmBMLine[0].FP0.y+BtmBMLine[0].FP1.y)/2));
					CDefectPoint[CCount].Rect.right  =(long)(CDefectPoint[CCount].Rect.left+ CDefectPoint[CCount].Width );
					CDefectPoint[CCount].Rect.bottom =(long)(CDefectPoint[CCount].Rect.top + CDefectPoint[CCount].Height);
					PixelCount = 0;
					PixelValue = 0;
					
					// 내부 Pixel Data 축출 
					for(int n=CDefectPoint[CCount].Rect.top+1 ; n<CDefectPoint[CCount].Rect.bottom-1; n++){
						for(int m=CDefectPoint[CCount].Rect.left+1; m<CDefectPoint[CCount].Rect.right-1 ; m++){
							PixelValue = IElement(m,n);
							if(PixelValue < EnCapBtmThresHold) PixelCount++;
						}
					}
					CDefectPoint[CCount].Round  =  PixelCount;
					CDefectPoint[CCount].P.x    = (float)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterX() - CDefectPoint[CCount].Width/2 )+FLBPoint.x);
					CDefectPoint[CCount].P.y    = (float)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - CDefectPoint[CCount].Height/2)+((BtmBMLine[0].FP0.y+BtmBMLine[0].FP1.y)/2)+ImageHeight);

					if(ImgDegree!=0.0f){
						CenterPoint.x = FLBPoint.x +(FRBPoint.x - FLBPoint.x)/2;
						CenterPoint.y = FLBPoint.y+ImageHeight;
						CDefectPoint[CCount].P = Math.OnRotate(CenterPoint,CDefectPoint[CCount].P, ImgDegree);
					}

					// Merge 위해서 데이터 필요함 
					CDefectPoint[CCount].Rect.top    =(long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - CDefectPoint[CCount].Height/2) +((BtmBMLine[0].FP0.y+BtmBMLine[0].FP1.y)/2)+ImageHeight);
					CDefectPoint[CCount].Rect.bottom =(long)(CDefectPoint[CCount].Rect.top + CDefectPoint[CCount].Height);
					CCount++;
				}
			}

			// SIDE C Remain & Burr 
			if(BtmOffset!=0 && BurrBtmOffset!=0){
				EasyImage::Threshold(GImage,&DefectImg, BurrFindThresHold);
				DefectROI.Attach(&DefectImg);
				CodeImageSelection.SetFeretAngle(0.00f);
				CodeImageEncoder.GetGrayscaleSingleThresholdSegmenter().SetWhiteLayerEncoded(true );
				CodeImageEncoder.GetGrayscaleSingleThresholdSegmenter().SetBlackLayerEncoded(false);
				
				IAddress = DefectImg.GetImagePtr();

				DefectROI.SetPlacement((int)(FLBPoint.x+1), (int)((BtmBMLine[0].FP0.y+BtmBMLine[0].FP1.y)/2 +BtmOffset+BurrBtmOffset), BtmWidth, RemainMargin);
				if((FLBBPoint.x+1) <=0 ||((BtmBMLine[0].FP0.y+BtmBMLine[0].FP1.y)/2 +BtmOffset+BurrBtmOffset)<=0 || BtmWidth<=0 || RemainMargin<=0  ) return false;
			    if((FLBBPoint.x+1) >=ImageWidth || ((BtmBMLine[0].FP0.y+BtmBMLine[0].FP1.y)/2 +BtmOffset+BurrBtmOffset)>BtmLimitLine ||  BtmWidth>=ImageWidth || RemainMargin>BtmLimitLine) return false;

				// 프레임 Buffer Over해서 검사시 리턴한다 
				if(BtmLimitLine!=0){
					if(((BtmBMLine[0].FP0.y+BtmBMLine[0].FP1.y)/2+BurrBtmOffset+BtmOffset+RemainMargin)>BtmLimitLine) return false;
				}

				CodeImageSelection.Clear();
				CodeImageEncoder.Encode(DefectROI,CodeImage);
				CodeImageSelection.Clear();
				CodeImageSelection.AddObjects(CodeImage);
				// Blob 필터링 
				CodeImageSelection.RemoveUsingFloatFeature(EFeature_BoundingBoxWidth ,FMinWidth    , FMaxWidth   , EDoubleThresholdMode_Outside);
				CodeImageSelection.RemoveUsingFloatFeature(EFeature_BoundingBoxHeight,FMinHeight   , FMaxHeight  , EDoubleThresholdMode_Outside);
				//CodeImageSelection.RemoveUsingIntegerFeature(EFeature_BottomLimit    ,FBtmHeight-1 , FBtmHeight+1, EDoubleThresholdMode_Outside);
				
				
				BlobCount = CodeImageSelection.GetElementCount();
				CodeImageSelection.Sort(EFeature_LeftLimit,ESortDirection_Ascending);
				
				if(BlobCount!=0){
					for(int k=0; k<BlobCount; k++){
						if(CBurrCount>=MAX_DEFECT_POINT) break; 
						CBurrPoint[CBurrCount].Width  =  CodeImageSelection.GetElement(k).GetBoundingBoxWidth() ;
						CBurrPoint[CBurrCount].Height =  CodeImageSelection.GetElement(k).GetBoundingBoxHeight();
						
						CBurrPoint[CBurrCount].Rect.left   =(long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterX() - CBurrPoint[CBurrCount].Width/2 ) +FLBPoint.x);
						CBurrPoint[CBurrCount].Rect.top    =(long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - CBurrPoint[CBurrCount].Height/2) +(BtmBMLine[0].FP0.y+BtmBMLine[0].FP1.y)/2 +BtmOffset+BurrBtmOffset);
						CBurrPoint[CBurrCount].Rect.right  =(long)(CBurrPoint[CBurrCount].Rect.left+ CBurrPoint[CBurrCount].Width );
						CBurrPoint[CBurrCount].Rect.bottom =(long)(CBurrPoint[CBurrCount].Rect.top + CBurrPoint[CBurrCount].Height);
						PixelCount = 0;
						PixelValue = 0;
						
						// 내부 Pixel Data 축출 
						for(int n=CBurrPoint[CBurrCount].Rect.top+1 ; n<CBurrPoint[CBurrCount].Rect.bottom-1; n++){
							for(int m=CBurrPoint[CBurrCount].Rect.left+1; m<CBurrPoint[CBurrCount].Rect.right-1 ; m++){
								PixelValue = IElement(m,n);
								if(PixelValue < EnCapBtmThresHold) PixelCount++;
							}
						}
						CBurrPoint[CBurrCount].Round  =  PixelCount;
						CBurrPoint[CBurrCount].P.x    = (float)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterX() - CBurrPoint[CBurrCount].Width/2 )+FLBPoint.x);
						CBurrPoint[CBurrCount].P.y    = (float)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - CBurrPoint[CBurrCount].Height/2)+((BtmBMLine[0].FP0.y+BtmBMLine[0].FP1.y)/2 +BtmOffset+BurrBtmOffset)+ImageHeight);
						
						// Merge 위해서 데이터 필요함 
						CBurrPoint[CBurrCount].Rect.top    =(long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - CBurrPoint[CBurrCount].Height/2) +(BtmBMLine[0].FP0.y+BtmBMLine[0].FP1.y)/2 +BtmOffset+BurrBtmOffset+ImageHeight);
						CBurrPoint[CBurrCount].Rect.bottom =(long)(CBurrPoint[CBurrCount].Rect.top + CBurrPoint[CBurrCount].Height);
						CBurrCount++;
						
					}
				}
			}
			BlobCount =0;
			// 외곽라인에서 Mark까지의 거리 산출 
			//BDistance  = (((Line[waBottomWall].FP0.y+ImageHeight) - Mark1YLength) +((Line[waBottomWall].FP1.y+ImageHeight) - Mark2YLength))/2;
		    BDistance  = ((Line[waBottomWall].FP0.y-BtmBMLine[0].FP0.y)+(Line[waBottomWall].FP1.y-BtmBMLine[0].FP1.y))/2;
			//BDistance  = TDistance;
			////////////////////////////////////////////////////////////////////////////////////////////////
			// 원본 이미지 회전하여 검사 이후 화면에 디스플레이 목적으로 좌표값을 다시 계사한다 
			////////////////////////////////////////////////////////////////////////////////////////////////
			if(ImgDegree!=0.0f){
				CenterPoint.x = FLBPoint.x +(FRBPoint.x - FLBPoint.x)/2;
				CenterPoint.y = FLBPoint.y;

				FRBPoint = Math.OnRotate(CenterPoint, FRBPoint, (ImgDegree));
				BtmBMLine[0].FP1 = Math.OnRotate(CenterPoint, BtmBMLine[0].FP1, (ImgDegree));

				CenterPoint.y = FRBPoint.y;
				FLBPoint = Math.OnRotate(CenterPoint, FLBPoint, (ImgDegree));
				BtmBMLine[0].FP0 = Math.OnRotate(CenterPoint, BtmBMLine[0].FP0, (ImgDegree));
			}
		}
	
		////////////////////////////////////////////////////////////////////////////////////////////////


		DefectPointCount = ACount+BCount+CCount+DCount+C1Count+C2Count+C3Count+C4Count+ABurrCount+BBurrCount+CBurrCount+DBurrCount; // 전체 불량개수 계산

		// Defect Blob Merge
		///////////////////////////////////////////////////////////////////////////////////////////////
		// Side D Merge (Crack & Chipping)
		if(DCount!=0){
			bool IsxMg=false, IsyMg=false, IsInMg=false;
			CRect r1, r2;
			int sort =0;
			int tmpDDefectCount = DCount;

			for(int k=0; k<tmpDDefectCount; k++){
                if(DDefectPoint[k].Rect.left==0 && DDefectPoint[k].Rect.top==0 && DDefectPoint[k].Rect.right==0 && DDefectPoint[k].Rect.bottom==0) continue;

				for(int l=k+1; l<k+MgCount; l++ ){
                    IsxMg = false; IsyMg = false;
					if(l>(tmpDDefectCount-1)) break;
					if(DDefectPoint[l].Rect.left==0 && DDefectPoint[l].Rect.top==0 && DDefectPoint[k].Rect.right==0 && DDefectPoint[k].Rect.bottom==0) continue;

					r1 = DDefectPoint[k].Rect;
					r2 = DDefectPoint[l].Rect; 

                    register int HorDist   = abs((r1.left < r2.left) ?  r2.left - r1.right  : r1.left - r2.right );
                    register int VerDist   = abs((r1.top  < r2.top ) ?  r2.top  - r1.bottom : r1.top  - r2.bottom);
					IsInMg    = ((r1.left<=r2.left) && (r1.top<r2.top) && (r1.bottom>r2.bottom) && (r1.right >r2.right))? true: false;

					if(HorDist>xMerge && VerDist>yMerge && !IsInMg ) continue;

					IsxMg = (HorDist<xMerge) ? true: false;
					IsyMg = (VerDist<yMerge) ? true: false;

					if((IsxMg && IsyMg) || IsInMg){
                        DDefectPoint[k].Round    += DDefectPoint[l].Round;
						DDefectPoint[k].Rect      = OnMerge(DDefectPoint[k].Rect, DDefectPoint[l].Rect);
						DDefectPoint[k].Width     = DDefectPoint[k].Rect.right  - DDefectPoint[k].Rect.left;
						DDefectPoint[k].Height    = DDefectPoint[k].Rect.bottom - DDefectPoint[k].Rect.top ;
						DDefectPoint[k].P.x       = (float)(DDefectPoint[k].Rect.left);
						DDefectPoint[k].P.y       = (float)(DDefectPoint[k].Rect.top ); 
						DDefectPoint[l].Rect.left = DDefectPoint[l].Rect.top = DDefectPoint[l].Rect.right = DDefectPoint[l].Rect.bottom =0;
						DCount--;
						k=-1;
						break;
					}

				}

			}
			for(int j=0; j<tmpDDefectCount; j++){
				if(DDefectPoint[j].Rect.left==0 && DDefectPoint[j].Rect.top==0 && DDefectPoint[j].Rect.right==0 && DDefectPoint[j].Rect.bottom==0) continue;
				DDefectPoint[sort] = DDefectPoint[j];
				sort++;
			}
		}

		// Side D Merge(Burr & Remain)
		if(DBurrCount!=0){
			bool IsxMg=false, IsyMg=false, IsInMg=false;
			CRect r1, r2;
			int sort =0;
			int tmpDDefectCount = DBurrCount;
			
			for(int k=0; k<tmpDDefectCount; k++){
                if(DBurrPoint[k].Rect.left==0 && DBurrPoint[k].Rect.top==0 && DBurrPoint[k].Rect.right==0 && DBurrPoint[k].Rect.bottom==0) continue;
				
				for(int l=k+1; l<k+MgCount; l++ ){
                    IsxMg = false; IsyMg = false;
					if(l>(tmpDDefectCount-1)) break;
					if(DBurrPoint[l].Rect.left==0 && DBurrPoint[l].Rect.top==0 && DBurrPoint[k].Rect.right==0 && DBurrPoint[k].Rect.bottom==0) continue;
					
					r1 = DBurrPoint[k].Rect;
					r2 = DBurrPoint[l].Rect; 
					
                    register int HorDist   =abs((r1.left < r2.left) ?  r2.left - r1.right  : r1.left - r2.right );
                    register int VerDist   =abs((r1.top  < r2.top ) ?  r2.top  - r1.bottom : r1.top  - r2.bottom);
					IsInMg    = ((r1.left<=r2.left) && (r1.top<r2.top) && (r1.bottom>r2.bottom) && (r1.right >r2.right))? true: false;
					
					if(HorDist>xMerge && VerDist>yMerge && !IsInMg ) continue;
					
					IsxMg = (HorDist<xMerge) ? true: false;
					IsyMg = (VerDist<yMerge) ? true: false;
					
					if((IsxMg && IsyMg) || IsInMg){
                        DBurrPoint[k].Round    += DBurrPoint[l].Round;
						DBurrPoint[k].Rect      = OnMerge(DBurrPoint[k].Rect, DBurrPoint[l].Rect);
						DBurrPoint[k].Width     = DBurrPoint[k].Rect.right  - DBurrPoint[k].Rect.left;
						DBurrPoint[k].Height    = DBurrPoint[k].Rect.bottom - DBurrPoint[k].Rect.top ;
						DBurrPoint[k].P.x       = (float)(DBurrPoint[k].Rect.left);
						DBurrPoint[k].P.y       = (float)(DBurrPoint[k].Rect.top ); 
						DBurrPoint[l].Rect.left = DBurrPoint[l].Rect.top = DBurrPoint[l].Rect.right = DBurrPoint[l].Rect.bottom =0;
						DBurrCount--;
						k=-1;
						break;
					}
					
				}
				
			}
			for(int j=0; j<tmpDDefectCount; j++){
				if(DBurrPoint[j].Rect.left==0 && DBurrPoint[j].Rect.top==0 && DBurrPoint[j].Rect.right==0 && DBurrPoint[j].Rect.bottom==0) continue;
				DBurrPoint[sort] = DBurrPoint[j];
				sort++;
			}
		}


        // Side B Merge (Crack & Chipping)
		if(BCount!=0){
			bool IsxMg=false, IsyMg=false, IsInMg=false;
			CRect r1, r2;
			int sort =0;
			int tmpBDefectCount = BCount;

			for(int k=0; k<tmpBDefectCount; k++){
                if(BDefectPoint[k].Rect.left==0 && BDefectPoint[k].Rect.top==0 && BDefectPoint[k].Rect.right==0 && BDefectPoint[k].Rect.bottom==0) continue;
				
				for(int l=k+1; l<k+MgCount; l++ ){
                    IsxMg = false; IsyMg = false;
					if(l>(tmpBDefectCount-1)) break;
					if(BDefectPoint[l].Rect.left==0 && BDefectPoint[l].Rect.top==0 && BDefectPoint[k].Rect.right==0 && BDefectPoint[k].Rect.bottom==0) continue;
					
					r1 = BDefectPoint[k].Rect;
					r2 = BDefectPoint[l].Rect; 
					
                    register int HorDist   = abs((r1.left < r2.left) ?  r2.left - r1.right  : r1.left - r2.right );
                    register int VerDist   = abs((r1.top  < r2.top ) ?  r2.top  - r1.bottom : r1.top  - r2.bottom);
					IsInMg    = ((r1.left<r2.left) && (r1.top<r2.top) && (r1.bottom>r2.bottom) && (r1.right >=r2.right))? true: false;
					
					if(HorDist>xMerge && VerDist>yMerge && !IsInMg ) continue;
					
					IsxMg = (HorDist<xMerge) ? true: false;
					IsyMg = (VerDist<yMerge) ? true: false;
					
					if((IsxMg && IsyMg) || IsInMg){
                        BDefectPoint[k].Round    += BDefectPoint[l].Round;
						BDefectPoint[k].Rect      = OnMerge(BDefectPoint[k].Rect, BDefectPoint[l].Rect);
						BDefectPoint[k].Width     = BDefectPoint[k].Rect.right  - BDefectPoint[k].Rect.left;
						BDefectPoint[k].Height    = BDefectPoint[k].Rect.bottom - BDefectPoint[k].Rect.top ;
						BDefectPoint[k].P.x       = (float)(BDefectPoint[k].Rect.left);
						BDefectPoint[k].P.y       = (float)(BDefectPoint[k].Rect.top ); 
						BDefectPoint[l].Rect.left = BDefectPoint[l].Rect.top = BDefectPoint[l].Rect.right = BDefectPoint[l].Rect.bottom =0;
						BCount--;
						k=-1;
						break;
					}
					
				}
				
			}
			for(int j=0; j<tmpBDefectCount; j++){
				if(BDefectPoint[j].Rect.left==0 && BDefectPoint[j].Rect.top==0 && BDefectPoint[j].Rect.right==0 && BDefectPoint[j].Rect.bottom==0) continue;
				BDefectPoint[sort] = BDefectPoint[j];
				sort++;
			}
		}


        // Side B Merge (Burr & Remain)
		if(BBurrCount!=0){
			bool IsxMg=false, IsyMg=false, IsInMg=false;
			CRect r1, r2;
			int sort =0;
			int tmpBDefectCount = BBurrCount;
			
			for(int k=0; k<tmpBDefectCount; k++){
                if(BBurrPoint[k].Rect.left==0 && BBurrPoint[k].Rect.top==0 && BBurrPoint[k].Rect.right==0 && BBurrPoint[k].Rect.bottom==0) continue;
				
				for(int l=k+1; l<k+MgCount; l++ ){
                    IsxMg = false; IsyMg = false;
					if(l>(tmpBDefectCount-1)) break;
					if(BBurrPoint[l].Rect.left==0 && BBurrPoint[l].Rect.top==0 && BBurrPoint[k].Rect.right==0 && BBurrPoint[k].Rect.bottom==0) continue;
					
					r1 = BBurrPoint[k].Rect;
					r2 = BBurrPoint[l].Rect; 
					
                    register int HorDist   = abs((r1.left < r2.left) ?  r2.left - r1.right  : r1.left - r2.right );
                    register int VerDist   = abs((r1.top  < r2.top ) ?  r2.top  - r1.bottom : r1.top  - r2.bottom);
					IsInMg    = ((r1.left<r2.left) && (r1.top<r2.top) && (r1.bottom>r2.bottom) && (r1.right >=r2.right))? true: false;
					
					if(HorDist>xMerge && VerDist>yMerge && !IsInMg ) continue;
					
					IsxMg = (HorDist<xMerge) ? true: false;
					IsyMg = (VerDist<yMerge) ? true: false;
					
					if((IsxMg && IsyMg) || IsInMg){
                        BBurrPoint[k].Round    += BBurrPoint[l].Round;
						BBurrPoint[k].Rect      = OnMerge(BBurrPoint[k].Rect, BBurrPoint[l].Rect);
						BBurrPoint[k].Width     = BBurrPoint[k].Rect.right  - BBurrPoint[k].Rect.left;
						BBurrPoint[k].Height    = BBurrPoint[k].Rect.bottom - BBurrPoint[k].Rect.top ;
						BBurrPoint[k].P.x       = (float)(BBurrPoint[k].Rect.left);
						BBurrPoint[k].P.y       = (float)(BBurrPoint[k].Rect.top ); 
						BBurrPoint[l].Rect.left = BBurrPoint[l].Rect.top = BBurrPoint[l].Rect.right = BBurrPoint[l].Rect.bottom =0;
						BBurrCount--;
						k=-1;
						break;
					}
					
				}
				
			}
			for(int j=0; j<tmpBDefectCount; j++){
				if(BBurrPoint[j].Rect.left==0 && BBurrPoint[j].Rect.top==0 && BBurrPoint[j].Rect.right==0 && BBurrPoint[j].Rect.bottom==0) continue;
				BBurrPoint[sort] = BBurrPoint[j];
				sort++;
			}
			
		}

		if(!IsCornerTop){
			if(ACount!=0){ // Left 
				bool IsxMg, IsyMg;
				CRect r1, r2;
				int sort =0;
				int tmpBDefectCount = ACount;
				
				// SIDE A + SIDE D Merge 
				for(int k=0; k<tmpBDefectCount; k++){
					if(ADefectPoint[k].Rect.left==0 && ADefectPoint[k].Rect.top==0 && ADefectPoint[k].Rect.right==0 && ADefectPoint[k].Rect.bottom==0) continue;
					IsxMg = false; IsyMg = false;
					r1 = ADefectPoint[k].Rect;
					r2 = DDefectPoint[0].Rect; 
						
					register int HorDist   = abs((r1.left < r2.left) ?  r2.left - r1.right  : r1.left - r2.right );
					register int VerDist   = abs((r1.top  < r2.top ) ?  r2.top  - r1.bottom : r1.top  - r2.bottom);
					
					if(HorDist>xMerge && VerDist>yMerge) continue;
					
					IsxMg = (HorDist<xMerge) ? true: false;
					IsyMg = (VerDist<yMerge) ? true: false;
						
					if(IsxMg && IsyMg){
						DDefectPoint[0].Round     = (ADefectPoint[k].Round>DDefectPoint[0].Round) ? ADefectPoint[k].Round :DDefectPoint[0].Round; 
						DDefectPoint[0].Rect      = OnMerge(ADefectPoint[k].Rect, DDefectPoint[0].Rect);
						DDefectPoint[0].Width     = DDefectPoint[0].Rect.right  - DDefectPoint[0].Rect.left;
						DDefectPoint[0].Height    = DDefectPoint[0].Rect.bottom - DDefectPoint[0].Rect.top ;
						ADefectPoint[k].Rect.left = ADefectPoint[k].Rect.top = ADefectPoint[k].Rect.right = ADefectPoint[k].Rect.bottom =0;
						ACount--;
						k=-1;
						//break;
					}
				}

				for(int j=0; j<tmpBDefectCount; j++){
					if(ADefectPoint[j].Rect.left==0 && ADefectPoint[j].Rect.top==0 && ADefectPoint[j].Rect.right==0 && ADefectPoint[j].Rect.bottom==0) continue;
					ADefectPoint[sort] = ADefectPoint[j];
					sort++;
				}
			}

			if(ACount!=0){ // Right 
				bool IsxMg, IsyMg;
				CRect r1, r2;
				int sort =0;
				int tmpBDefectCount = ACount;
				
				// SIDE A + SIDE B Merge 
				for(int k=0; k<tmpBDefectCount; k++){
					if(ADefectPoint[k].Rect.left==0 && ADefectPoint[k].Rect.top==0 && ADefectPoint[k].Rect.right==0 && ADefectPoint[k].Rect.bottom==0) continue;
					IsxMg = false; IsyMg = false;
					r1 = ADefectPoint[k].Rect;
					r2 = BDefectPoint[0].Rect; 
					
					register int HorDist   = abs((r1.left < r2.left) ?  r2.left - r1.right  : r1.left - r2.right );
					register int VerDist   = abs((r1.top  < r2.top ) ?  r2.top  - r1.bottom : r1.top  - r2.bottom);
					
					if(HorDist>xMerge && VerDist>yMerge) continue;
					
					IsxMg = (HorDist<xMerge) ? true: false;
					IsyMg = (VerDist<yMerge) ? true: false;
					
					if(IsxMg && IsyMg){
						BDefectPoint[0].Round     = (ADefectPoint[k].Round>BDefectPoint[0].Round) ? ADefectPoint[k].Round :BDefectPoint[0].Round; 
						BDefectPoint[0].Rect      = OnMerge(ADefectPoint[k].Rect, BDefectPoint[0].Rect);
						BDefectPoint[0].Width     = BDefectPoint[0].Rect.right  - BDefectPoint[0].Rect.left;
						BDefectPoint[0].Height    = BDefectPoint[0].Rect.bottom - BDefectPoint[0].Rect.top ;
						ADefectPoint[k].Rect.left = ADefectPoint[k].Rect.top = ADefectPoint[k].Rect.right = ADefectPoint[k].Rect.bottom =0;
						ACount--;
						k=-1;
						//break;
					}
				}
				
				for(int j=0; j<tmpBDefectCount; j++){
					if(ADefectPoint[j].Rect.left==0 && ADefectPoint[j].Rect.top==0 && ADefectPoint[j].Rect.right==0 && ADefectPoint[j].Rect.bottom==0) continue;
					ADefectPoint[sort] = ADefectPoint[j];
					sort++;
				}
			}
		}


		if(!IsCornerBtm){
			if(CCount!=0){ // Left 
				bool IsxMg, IsyMg;
				CRect r1, r2;
				int sort =0;
				int tmpBDefectCount = CCount;
				
				// SIDE C + SIDE D Merge 
				for(int k=0; k<tmpBDefectCount; k++){
					if(CDefectPoint[k].Rect.left==0 && CDefectPoint[k].Rect.top==0 && CDefectPoint[k].Rect.right==0 && CDefectPoint[k].Rect.bottom==0) continue;
					IsxMg = false; IsyMg = false;
					r1 = CDefectPoint[k].Rect;
					r2 = DDefectPoint[DCount-1].Rect; 
					
					register int HorDist   = abs((r1.left < r2.left) ?  r2.left - r1.right  : r1.left - r2.right );
					register int VerDist   = abs((r1.top  < r2.top ) ?  r2.top  - r1.bottom : r1.top  - r2.bottom);
					
					if(HorDist>xMerge && VerDist>yMerge) continue;
					
					IsxMg = (HorDist<xMerge) ? true: false;
					IsyMg = (VerDist<yMerge) ? true: false;
					
					if(IsxMg && IsyMg){
						DDefectPoint[DCount-1].Round     = (CDefectPoint[k].Round>DDefectPoint[DCount-1].Round) ? CDefectPoint[k].Round :DDefectPoint[DCount-1].Round; 
						DDefectPoint[DCount-1].Rect      = OnMerge(CDefectPoint[k].Rect, DDefectPoint[DCount-1].Rect);
						DDefectPoint[DCount-1].Width     = DDefectPoint[DCount-1].Rect.right  - DDefectPoint[DCount-1].Rect.left;
						DDefectPoint[DCount-1].Height    = DDefectPoint[DCount-1].Rect.bottom - DDefectPoint[DCount-1].Rect.top ;
						CDefectPoint[k].Rect.left = CDefectPoint[k].Rect.top = CDefectPoint[k].Rect.right = CDefectPoint[k].Rect.bottom =0;
						CCount--;
						k=-1;
						//break;
					}
				}
				
				for(int j=0; j<tmpBDefectCount; j++){
					if(CDefectPoint[j].Rect.left==0 && CDefectPoint[j].Rect.top==0 && CDefectPoint[j].Rect.right==0 && CDefectPoint[j].Rect.bottom==0) continue;
					CDefectPoint[sort] = CDefectPoint[j];
					sort++;
				}
			}
			
			if(CCount!=0){ // Right 
				bool IsxMg, IsyMg;
				CRect r1, r2;
				int sort =0;
				int tmpBDefectCount = CCount;
				
				// SIDE C + SIDE B Merge 
				for(int k=0; k<tmpBDefectCount; k++){
					if(CDefectPoint[k].Rect.left==0 && CDefectPoint[k].Rect.top==0 && CDefectPoint[k].Rect.right==0 && CDefectPoint[k].Rect.bottom==0) continue;
					IsxMg = false; IsyMg = false;
					r1 = CDefectPoint[k].Rect;
					r2 = BDefectPoint[BCount-1].Rect; 
					
					register int HorDist   = abs((r1.left < r2.left) ?  r2.left - r1.right  : r1.left - r2.right );
					register int VerDist   = abs((r1.top  < r2.top ) ?  r2.top  - r1.bottom : r1.top  - r2.bottom);
					
					if(HorDist>xMerge && VerDist>yMerge) continue;
					
					IsxMg = (HorDist<xMerge) ? true: false;
					IsyMg = (VerDist<yMerge) ? true: false;
					
					if(IsxMg && IsyMg){
						BDefectPoint[BCount-1].Round     = (CDefectPoint[k].Round>BDefectPoint[BCount-1].Round) ? CDefectPoint[k].Round :BDefectPoint[BCount-1].Round; 
						BDefectPoint[BCount-1].Rect      = OnMerge(CDefectPoint[k].Rect, BDefectPoint[BCount-1].Rect);
						BDefectPoint[BCount-1].Width     = BDefectPoint[BCount-1].Rect.right  - BDefectPoint[BCount-1].Rect.left;
						BDefectPoint[BCount-1].Height    = BDefectPoint[BCount-1].Rect.bottom - BDefectPoint[BCount-1].Rect.top ;
						CDefectPoint[k].Rect.left = CDefectPoint[k].Rect.top = CDefectPoint[k].Rect.right = CDefectPoint[k].Rect.bottom =0;
						CCount--;
						k=-1;
						//break;
					}
				}
				
				for(int j=0; j<tmpBDefectCount; j++){
					if(CDefectPoint[j].Rect.left==0 && CDefectPoint[j].Rect.top==0 && CDefectPoint[j].Rect.right==0 && CDefectPoint[j].Rect.bottom==0) continue;
					CDefectPoint[sort] = CDefectPoint[j];
					sort++;
				}
			}

		}
		//////////////////////////////////////////////////////////////////////////////////////////////
		// Blob Merge End

		Index = 0;
		return true;
		
		// RectC : 젓가락 모양
		//------------------------------------------------------------------
	case 3 :

		if(FMinWidth==0 || FMinHeight==0){ FMinWidth=1; FMinHeight=1;}

		// Side D Crack & Chipping 
//  		LogUnit.SetLog("STATIC_Side_D_START_CamId: %d, ImageHeight: %d ",CamId,ImageHeight);     

		/////////////////////////////////////////////////////////////////////////////////////////
		if(InspectMode){
			DefectROI.SetPlacement((int)(LSP.x-LeftOffset),(int)LSP.y, FLeftWidth, LeftHeight);
			if((LSP.x-LeftOffset) <=0 ||(LSP.y)<0 || FLeftWidth<=0 || LeftHeight<=0) return false;
			if((LSP.x-LeftOffset) >=ImageWidth || (LSP.y)>400 ||  FLeftWidth>=ImageWidth || LeftHeight>400) return false;
			
			// Line Position
			LinePosition = LSP.x-LeftOffset;
		}
		else {
			DefectROI.SetPlacement((int)(LSP.x+SideMargin),(int)LSP.y, FLeftWidth, LeftHeight);
			if((LSP.x+SideMargin) <=0 ||(LSP.y)<0 || FLeftWidth<=0 || LeftHeight<=0) return false;
			if((LSP.x+SideMargin) >=ImageWidth || (LSP.y)>400 ||  FLeftWidth>=ImageWidth || LeftHeight>400) return false;
			
			// Line Position
			LinePosition = LSP.x;
		}


        // 외곽기준 Data 산출하여 밝기차이 Check 
		if((LSP.x+SideMargin)!=0 && LeftHeight!=0){
			IAddress = GImage->GetImagePtr();
			PixelValue=0; PixelCount=0; TotalPixel=0;
			
			for(int n=(int)LSP.y ; n<LeftHeight; n++){
				for(int m=(int)(LSP.x+SideMargin); m<(LSP.x+SideMargin)+5; m++){
					PixelValue  = IElement(m,n) ;
					TotalPixel += PixelValue    ;
					PixelCount++                ;
				}
			}
			if(PixelCount!=0) TotalPixel  = (int)(TotalPixel/PixelCount);
// 			LogUnit.SetLog("LEFT_TOTAL_PIXEL : %d, Image_Height: %d", TotalPixel, ImageHeight);
		}

		// Side영역 Contrast Level 낮을 경우 AutoThresHold값 적용함 
		// 20160511
		// Image Conversion 
		if(TotalPixel<50) {
			EasyImage::Threshold(GImage,&DefectImg, (EnCapMidThresHold-5));
		}
		else              {
			EasyImage::Threshold(GImage,&DefectImg,  EnCapMidThresHold   );
		}

		// ROI Attatch
		DefectROI.Attach(&DefectImg);
		CodeImageSelection.SetFeretAngle(0.00f);
		CodeImageEncoder.GetGrayscaleSingleThresholdSegmenter().SetWhiteLayerEncoded(false);
		CodeImageEncoder.GetGrayscaleSingleThresholdSegmenter().SetBlackLayerEncoded(true );
		
		IAddress = DefectImg.GetImagePtr();

        // TOP영역 검사시 Contrast Level 줄이기 위해서 Median필터 적용함 
		// 		EasyImage::Median(&DefectImg, &DefectImg);
		EasyImage::Median(&DefectROI, &DefectROI);

		CodeImageSelection.Clear();
		CodeImageEncoder.Encode(DefectROI,CodeImage);
		CodeImageSelection.Clear();
		CodeImageSelection.AddObjects(CodeImage);
		// Blob 필터링 
		CodeImageSelection.RemoveUsingFloatFeature(EFeature_BoundingBoxWidth ,FMinWidth , FMaxWidth  , EDoubleThresholdMode_Outside);
		CodeImageSelection.RemoveUsingFloatFeature(EFeature_BoundingBoxHeight,FMinHeight, FMaxHeight , EDoubleThresholdMode_Outside);
		CodeImageSelection.RemoveUsingIntegerFeature(EFeature_LeftLimit        ,0       , 1          , EDoubleThresholdMode_Outside);
		
		BlobCount = CodeImageSelection.GetElementCount();
		CodeImageSelection.Sort(EFeature_TopLimit,ESortDirection_Ascending);
		
		if(BlobCount!=0){
			for(int k=0; k<BlobCount; k++){
				if(DCount>=MAX_DEFECT_POINT) break; 
				DDefectPoint[DCount].Width  = CodeImageSelection.GetElement(k).GetBoundingBoxWidth() ;
				DDefectPoint[DCount].Height = CodeImageSelection.GetElement(k).GetBoundingBoxHeight();

				DDefectPoint[DCount].Rect.left   =(long)(((CodeImageSelection.GetElement(k).GetBoundingBoxCenterX() - DDefectPoint[DCount].Width/2 ) +LinePosition));
                DDefectPoint[DCount].Rect.top    =(long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - DDefectPoint[DCount].Height/2)                );
				DDefectPoint[DCount].Rect.right  =(long)(DDefectPoint[DCount].Rect.left+ DDefectPoint[DCount].Width) ; 
				DDefectPoint[DCount].Rect.bottom =(long)(DDefectPoint[DCount].Rect.top + DDefectPoint[DCount].Height);

				PixelCount =0;
				PixelValue =0;

				// 내부 Pixel Data 축출 
				for(int n=DDefectPoint[DCount].Rect.top+1 ; n<DDefectPoint[DCount].Rect.bottom-1; n++){
					for(int m=DDefectPoint[DCount].Rect.left+1; m<DDefectPoint[DCount].Rect.right-1 ; m++){
						PixelValue = IElement(m,n);
						if(PixelValue < EnCapMidThresHold) PixelCount++;
					}
				}

				DDefectPoint[DCount].Round = PixelCount;
				DDefectPoint[DCount].P.x    =(float)(DDefectPoint[DCount].Rect.left); 
				DDefectPoint[DCount].P.y    =(float)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - DDefectPoint[DCount].Height/2)+ImageHeight  );
				DDefectPoint[DCount].Width  = (InspectMode)? DDefectPoint[DCount].Width :DDefectPoint[DCount].Width+SideMargin; 

				// Merge 위해서 데이터 필요함 
                DDefectPoint[DCount].Rect.top    =(long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - DDefectPoint[DCount].Height/2)+ImageHeight);
				DDefectPoint[DCount].Rect.bottom =(long)(DDefectPoint[DCount].Rect.top + DDefectPoint[DCount].Height);
				DCount++;
			}
        }
		BlobCount =0;
//  		LogUnit.SetLog("STATIC_Side_D_END_CamId: %d, ImageHeight: %d ",CamId,ImageHeight);     


		// 외곽라인에서 Mark까지의 거리 산출 
		// CellSize 
		//if     (Line[waLeftWall].FP0.x >Line[waLeftWall].FP1.x) LDistance = FP0.x - (Line[waLeftWall].FP1.x+(Line[waLeftWall].FP0.x - Line[waLeftWall].FP1.x)/2);
		//else if(Line[waLeftWall].FP0.x==Line[waLeftWall].FP1.x) LDistance = FP0.x -  Line[waLeftWall].FP0.x;
		//else                                                    LDistance = FP0.x - (Line[waLeftWall].FP0.x+(Line[waLeftWall].FP1.x - Line[waLeftWall].FP0.x)/2); 

		if     (Line[waLeftWall].FP0.x >Line[waLeftWall].FP1.x) LDistance = ((LeftBMLine[0].FP0.x+ LeftBMLine[0].FP1.x)/2) - (Line[waLeftWall].FP1.x+(Line[waLeftWall].FP0.x - Line[waLeftWall].FP1.x)/2);
		else if(Line[waLeftWall].FP0.x==Line[waLeftWall].FP1.x) LDistance = ((LeftBMLine[0].FP0.x+ LeftBMLine[0].FP1.x)/2) -  Line[waLeftWall].FP0.x;
		else                                                    LDistance = ((LeftBMLine[0].FP0.x+ LeftBMLine[0].FP1.x)/2) - (Line[waLeftWall].FP0.x+(Line[waLeftWall].FP1.x - Line[waLeftWall].FP0.x)/2); 

		////////////////////////////////////////////////////////////////////////////////////////////////



        // Side B
		/////////////////////////////////////////////////////////////////////////////////////////////////
//  		LogUnit.SetLog("STATIC_Side_B_START_CamId: %d, ImageHeight: %d ",CamId,ImageHeight);     
		if(InspectMode){
			DefectROI.SetPlacement((int)(RSP.x-FRightWidth), (int)RSP.y, FRightWidth+RightOffset, RightHeight);
			if((RSP.x-FRightWidth) <=0 ||(RSP.y)<0  || FRightWidth+RightOffset<=0 || RightHeight<=0)return false;
			if((RSP.x-FRightWidth) >=ImageWidth || (RSP.y)>400 ||   FRightWidth+RightOffset>=ImageWidth || RightHeight>400) return false;

			//Line Position
			LinePosition = RSP.x-FRightWidth;
		}
		else {
			DefectROI.SetPlacement((int)(RSP.x-FRightWidth-SideMargin), (int)RSP.y, FRightWidth, RightHeight);
			if((RSP.x-FRightWidth-SideMargin) <=0 ||(RSP.y)<0  || FRightWidth<=0 || RightHeight<=0)return false;
			if((RSP.x-FRightWidth-SideMargin) >=ImageWidth || (RSP.y)>400 ||  FRightWidth>=ImageWidth || RightHeight>400) return false;
			
			//Line Position
			LinePosition = RSP.x-FRightWidth-SideMargin;
		}

        // 외곽기준 Data 산출하여 밝기차이 Check 
		if((RSP.x-SideMargin-5)!=0 ){
			IAddress = GImage->GetImagePtr();
			PixelValue=0; PixelCount=0; TotalPixel=0;
			
			for(int n=(int)RSP.y ; n<RightHeight; n++){
				for(int m=(int)(RSP.x-SideMargin-5); m<(RSP.x-SideMargin-5)+5; m++){
					PixelValue  = IElement(m,n) ;
					TotalPixel += PixelValue    ;
					PixelCount++                ;
				}
			}
			if(PixelCount!=0) TotalPixel  = (int)(TotalPixel/PixelCount);
// 			LogUnit.SetLog("RIGHT_TOTAL_PIXEL : %d, Image_Height: %d", TotalPixel, ImageHeight);
		}

		// Side영역 Contrast Level 낮을 경우 AutoThresHold값 적용함 
		// 20160511
		// Image Conversion 
		if(TotalPixel<50) {
			EasyImage::Threshold(GImage,&DefectImg, (EnCapMidThresHold-5));
		}
		else              {
			EasyImage::Threshold(GImage,&DefectImg,  EnCapMidThresHold   );
		}
		
		// ROI Attatch
		DefectROI.Attach(&DefectImg);
		CodeImageSelection.SetFeretAngle(0.00f);
		CodeImageEncoder.GetGrayscaleSingleThresholdSegmenter().SetWhiteLayerEncoded(false);
		CodeImageEncoder.GetGrayscaleSingleThresholdSegmenter().SetBlackLayerEncoded(true );
		
		IAddress = DefectImg.GetImagePtr();

        // TOP영역 검사시 Contrast Level 줄이기 위해서 Median필터 적용함 
		// 		EasyImage::Median(&DefectImg, &DefectImg);
		EasyImage::Median(&DefectROI, &DefectROI);

		CodeImageSelection.Clear();
		CodeImageEncoder.Encode(DefectROI,CodeImage);
		CodeImageSelection.Clear();
		CodeImageSelection.AddObjects(CodeImage);
		// Blob 필터링 
		CodeImageSelection.RemoveUsingFloatFeature(EFeature_BoundingBoxWidth ,FMinWidth , FMaxWidth  , EDoubleThresholdMode_Outside);
		CodeImageSelection.RemoveUsingFloatFeature(EFeature_BoundingBoxHeight,FMinHeight, FMaxHeight , EDoubleThresholdMode_Outside);
		if(InspectMode){
			CodeImageSelection.RemoveUsingIntegerFeature(EFeature_RightLimit     ,FRightWidth+RightOffset-1 , FRightWidth+RightOffset+1, EDoubleThresholdMode_Outside);
		}
		else {
			CodeImageSelection.RemoveUsingIntegerFeature(EFeature_RightLimit     ,FRightWidth-1             , FRightWidth+1            , EDoubleThresholdMode_Outside);
		}
		
		BlobCount = CodeImageSelection.GetElementCount();
		CodeImageSelection.Sort(EFeature_TopLimit,ESortDirection_Ascending);
		
		if(BlobCount!=0){
			for(int k=0; k<BlobCount; k++){
				if(BCount>=MAX_DEFECT_POINT) break; 
				BDefectPoint[BCount].Width  = CodeImageSelection.GetElement(k).GetBoundingBoxWidth();
				BDefectPoint[BCount].Height = CodeImageSelection.GetElement(k).GetBoundingBoxHeight();

				BDefectPoint[BCount].Rect.left   =(long)(((CodeImageSelection.GetElement(k).GetBoundingBoxCenterX() - BDefectPoint[BCount].Width/2) +LinePosition));
                BDefectPoint[BCount].Rect.top    =(long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - BDefectPoint[BCount].Height/2)               );
				BDefectPoint[BCount].Rect.right  =(long)(BDefectPoint[BCount].Rect.left+ BDefectPoint[BCount].Width );
				BDefectPoint[BCount].Rect.bottom =(long)(BDefectPoint[BCount].Rect.top + BDefectPoint[BCount].Height);

				PixelCount = 0;
				PixelValue = 0;

				// 내부 Pixel Data 축출 
				for(int n=BDefectPoint[BCount].Rect.top+1 ; n<BDefectPoint[BCount].Rect.bottom-1; n++){
					for(int m=BDefectPoint[BCount].Rect.left+1; m<BDefectPoint[BCount].Rect.right-1 ; m++){
						PixelValue = IElement(m,n);
						if(PixelValue < EnCapMidThresHold) PixelCount++;
					}
				}

				BDefectPoint[BCount].Round  = PixelCount;
				BDefectPoint[BCount].P.x    =(float)(BDefectPoint[BCount].Rect.left);
				BDefectPoint[BCount].P.y    =(float)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - BDefectPoint[BCount].Height/2) +ImageHeight );
				BDefectPoint[BCount].Width  = (InspectMode)? BDefectPoint[BCount].Width :BDefectPoint[BCount].Width+SideMargin; 

				// Merge 위해서 데이터 필요함 
                BDefectPoint[BCount].Rect.top    =(long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - BDefectPoint[BCount].Height/2) +ImageHeight);
				BDefectPoint[BCount].Rect.bottom =(long)(BDefectPoint[BCount].Rect.top + BDefectPoint[BCount].Height);
				BCount++;
			}
        }
		BlobCount =0;
//  		LogUnit.SetLog("STATIC_Side_B_END_CamId: %d, ImageHeight: %d ",CamId,ImageHeight);     
		// 외곽라인에서 Mark까지의 거리 산출 
		// CellSize 
		//if     (Line[waRightWall].FP0.x >Line[waRightWall].FP1.x) RDistance = (Line[waRightWall].FP1.x+(Line[waRightWall].FP0.x - Line[waRightWall].FP1.x)/2) - FP1.x;
		//else if(Line[waRightWall].FP0.x==Line[waRightWall].FP1.x) RDistance =  Line[waRightWall].FP0.x - FP1.x;
		//else                                                      RDistance = (Line[waRightWall].FP0.x+(Line[waRightWall].FP1.x - Line[waRightWall].FP0.x)/2) - FP1.x;

		if     (Line[waRightWall].FP0.x >Line[waRightWall].FP1.x) RDistance = (Line[waRightWall].FP1.x+(Line[waRightWall].FP0.x - Line[waRightWall].FP1.x)/2) - ((RightBMLine[0].FP0.x+ RightBMLine[0].FP1.x)/2);
		else if(Line[waRightWall].FP0.x==Line[waRightWall].FP1.x) RDistance =  Line[waRightWall].FP0.x                                                        - ((RightBMLine[0].FP0.x+ RightBMLine[0].FP1.x)/2);
		else                                                      RDistance = (Line[waRightWall].FP0.x+(Line[waRightWall].FP1.x - Line[waRightWall].FP0.x)/2) - ((RightBMLine[0].FP0.x+ RightBMLine[0].FP1.x)/2);

		////////////////////////////////////////////////////////////////////////////////////////////////

		// Side D Burr(Remain)  
// 		if(LeftOffset!=0 && BurrLeftOffset!=0){
		if(LeftOffset!=0 ){
//  			LogUnit.SetLog("STATIC_Side_D_BURR_START_CamId: %d, ImageHeight: %d ",CamId,ImageHeight);     

			EasyImage::Threshold(GImage,&DefectImg, BurrFindThresHold);
			DefectROI.Attach(&DefectImg);
			CodeImageSelection.SetFeretAngle(0.00f);
			CodeImageEncoder.GetGrayscaleSingleThresholdSegmenter().SetWhiteLayerEncoded(true );
			CodeImageEncoder.GetGrayscaleSingleThresholdSegmenter().SetBlackLayerEncoded(false);
			IAddress = DefectImg.GetImagePtr();
			
			DefectROI.SetPlacement((int)(LeftBMLine[0].FP0.x - LeftOffset-BurrLeftOffset -RemainMargin),(int)LSP.y, RemainMargin, LeftHeight);
			if((LeftBMLine[0].FP0.x - LeftOffset-BurrLeftOffset -RemainMargin) <=0 || (LeftBMLine[0].FP0.x - LeftOffset-BurrLeftOffset -RemainMargin)>=ImgW ||(LSP.y)<0 || RemainMargin<=0 || LeftHeight<=0) return false;
			if((LeftBMLine[0].FP0.x - LeftOffset-BurrLeftOffset -RemainMargin) >=ImageWidth || (LSP.y)>400 ||  RemainMargin>=ImageWidth || LeftHeight>400) return false;
			
			CodeImageSelection.Clear();
			CodeImageEncoder.Encode(DefectROI,CodeImage);
			CodeImageSelection.Clear();
			CodeImageSelection.AddObjects(CodeImage);
			// Blob 필터링 
			CodeImageSelection.RemoveUsingFloatFeature(EFeature_BoundingBoxWidth ,FMinWidth , FMaxWidth  , EDoubleThresholdMode_Outside);
			CodeImageSelection.RemoveUsingFloatFeature(EFeature_BoundingBoxHeight,FMinHeight, FMaxHeight , EDoubleThresholdMode_Outside);
			//CodeImageSelection.RemoveUsingIntegerFeature(EFeature_LeftLimit        ,0       , 3          , EDoubleThresholdMode_Outside);
			
			BlobCount = CodeImageSelection.GetElementCount();
			CodeImageSelection.Sort(EFeature_TopLimit,ESortDirection_Ascending);
			
			if(BlobCount!=0){
				for(int k=0; k<BlobCount; k++){
					if(DBurrCount>=MAX_DEFECT_POINT) break; 
					DBurrPoint[DBurrCount].Width  = CodeImageSelection.GetElement(k).GetBoundingBoxWidth() ;
					DBurrPoint[DBurrCount].Height = CodeImageSelection.GetElement(k).GetBoundingBoxHeight();
					
					DBurrPoint[DBurrCount].Rect.left   =(long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterX() - DBurrPoint[DBurrCount].Width/2 ) +(LeftBMLine[0].FP0.x - LeftOffset-BurrLeftOffset -RemainMargin));
					DBurrPoint[DBurrCount].Rect.top    =(long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - DBurrPoint[DBurrCount].Height/2)                                              );
					DBurrPoint[DBurrCount].Rect.right  =(long)(DBurrPoint[DBurrCount].Rect.left+ DBurrPoint[DBurrCount].Width );
					DBurrPoint[DBurrCount].Rect.bottom =(long)(DBurrPoint[DBurrCount].Rect.top + DBurrPoint[DBurrCount].Height);
					PixelCount =0;
					PixelValue =0;
					
					// 내부 Pixel Data 축출 
					for(int n=DBurrPoint[DBurrCount].Rect.top+1 ; n<DBurrPoint[DBurrCount].Rect.bottom-1; n++){
						for(int m=DBurrPoint[DBurrCount].Rect.left+1; m<DBurrPoint[DBurrCount].Rect.right-1 ; m++){
							PixelValue = IElement(m,n);
							if(PixelValue > BurrFindThresHold) PixelCount++;
						}
					}
					
					DBurrPoint[DBurrCount].Round = PixelCount;
					DBurrPoint[DBurrCount].P.x    =(float)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterX() - DBurrPoint[DBurrCount].Width/2 )+(LeftBMLine[0].FP0.x - LeftOffset-BurrLeftOffset -RemainMargin));
					DBurrPoint[DBurrCount].P.y    =(float)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - DBurrPoint[DBurrCount].Height/2)+ImageHeight);
					
					// Merge 위해서 데이터 필요함 
					DBurrPoint[DBurrCount].Rect.top    =(long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - DBurrPoint[DBurrCount].Height/2)+ImageHeight);
					DBurrPoint[DBurrCount].Rect.bottom =(long)(DBurrPoint[DBurrCount].Rect.top + DBurrPoint[DBurrCount].Height);
					DBurrCount++;
				}
			}
		}
		BlobCount =0;
//  		LogUnit.SetLog("STATIC_Side_D_BURR_END_CamId: %d, ImageHeight: %d ",CamId,ImageHeight);     

		// Side B Burr(Remain)  
// 		if(RightOffset!=0 && BurrRightOffset!=0){
		if(RightOffset!=0 ){
//  			LogUnit.SetLog("STATIC_Side_B_BURR_START_CamId: %d, ImageHeight: %d ",CamId,ImageHeight);     
			EasyImage::Threshold(GImage,&DefectImg, BurrFindThresHold);
			DefectROI.Attach(&DefectImg);
			CodeImageSelection.SetFeretAngle(0.00f);
			CodeImageEncoder.GetGrayscaleSingleThresholdSegmenter().SetWhiteLayerEncoded(true );
			CodeImageEncoder.GetGrayscaleSingleThresholdSegmenter().SetBlackLayerEncoded(false);
			
			IAddress = DefectImg.GetImagePtr();
			
			DefectROI.SetPlacement((int)(RightBMLine[0].FP0.x + RightOffset+BurrRightOffset),(int)LSP.y, RemainMargin, LeftHeight);
			if((RightBMLine[0].FP0.x + RightOffset+BurrRightOffset) <=0 || (RightBMLine[0].FP0.x + RightOffset+BurrRightOffset)>=ImgW ||(LSP.y)<0 || RemainMargin<=0 || LeftHeight<=0) return false;
			if((RightBMLine[0].FP0.x + RightOffset+BurrRightOffset) >=ImageWidth || (LSP.y)>400 ||  RemainMargin>=ImageWidth || LeftHeight>400) return false;
			
			CodeImageSelection.Clear();
			CodeImageEncoder.Encode(DefectROI,CodeImage);
			CodeImageSelection.Clear();
			CodeImageSelection.AddObjects(CodeImage);
			// Blob 필터링 
			CodeImageSelection.RemoveUsingFloatFeature(EFeature_BoundingBoxWidth ,FMinWidth , FMaxWidth  , EDoubleThresholdMode_Outside);
			CodeImageSelection.RemoveUsingFloatFeature(EFeature_BoundingBoxHeight,FMinHeight, FMaxHeight , EDoubleThresholdMode_Outside);
			//CodeImageSelection.RemoveUsingIntegerFeature(EFeature_LeftLimit        ,0       , 3          , EDoubleThresholdMode_Outside);
			
			BlobCount = CodeImageSelection.GetElementCount();
			CodeImageSelection.Sort(EFeature_TopLimit,ESortDirection_Ascending);
			
			if(BlobCount!=0){
				for(int k=0; k<BlobCount; k++){
					if(BBurrCount>=MAX_DEFECT_POINT) break; 
					BBurrPoint[BBurrCount].Width  = CodeImageSelection.GetElement(k).GetBoundingBoxWidth() ;
					BBurrPoint[BBurrCount].Height = CodeImageSelection.GetElement(k).GetBoundingBoxHeight();
					
					BBurrPoint[BBurrCount].Rect.left   =(long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterX() - BBurrPoint[BBurrCount].Width/2 ) +(RightBMLine[0].FP0.x + RightOffset+BurrRightOffset));
					BBurrPoint[BBurrCount].Rect.top    =(long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - BBurrPoint[BBurrCount].Height/2)                                                      );
					BBurrPoint[BBurrCount].Rect.right  =(long)(BBurrPoint[BBurrCount].Rect.left+ BBurrPoint[BBurrCount].Width );
					BBurrPoint[BBurrCount].Rect.bottom =(long)(BBurrPoint[BBurrCount].Rect.top + BBurrPoint[BBurrCount].Height);
					PixelCount =0;
					PixelValue =0;
					
					// 내부 Pixel Data 축출 
					for(int n=BBurrPoint[BBurrCount].Rect.top+1 ; n<BBurrPoint[BBurrCount].Rect.bottom-1; n++){
						for(int m=BBurrPoint[BBurrCount].Rect.left+1; m<BBurrPoint[BBurrCount].Rect.right-1 ; m++){
							PixelValue = IElement(m,n);
							if(PixelValue > BurrFindThresHold) PixelCount++;
						}
					}
					
					BBurrPoint[BBurrCount].Round = PixelCount;
					BBurrPoint[BBurrCount].P.x    =(float)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterX() - BBurrPoint[BBurrCount].Width/2 )+(RightBMLine[0].FP0.x + RightOffset+BurrRightOffset));
					BBurrPoint[BBurrCount].P.y    =(float)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - BBurrPoint[BBurrCount].Height/2)+ImageHeight);
					
					// Merge 위해서 데이터 필요함 
					BBurrPoint[BBurrCount].Rect.top    =(long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - BBurrPoint[BBurrCount].Height/2)+ImageHeight);
					BBurrPoint[BBurrCount].Rect.bottom =(long)(BBurrPoint[BBurrCount].Rect.top + BBurrPoint[BBurrCount].Height);
					BBurrCount++;
				}
			}
		}
//  		LogUnit.SetLog("STATIC_Side_B_BURR_END_CamId: %d, ImageHeight: %d ",CamId,ImageHeight);     
		BlobCount =0;
		Index = 0;
		return true;

		// EdgeInspection(천마) : 왼쪽 모자 모양+왼쪽 젓가락+왼쪽 컵모양
		//------------------------------------------------------------------
	case 4 :

		// 연마량 안쪽라인 기준으로 검사하기 때문에
	    if(!IsMarkLine && !GrindCheck) return true;
        
		//if(FMinWidth==0 || FMinHeight==0){ FMinWidth=1; FMinHeight=1;}
		BlobCount =0;

		// Chipping Inspection
        EasyImage::Threshold(GImage,&DefectImg, CrackThresHold);
		DefectROI.Attach(&DefectImg);
		CodeImageSelection.SetFeretAngle(0.00f);
		CodeImageEncoder.GetGrayscaleSingleThresholdSegmenter().SetWhiteLayerEncoded(false);
		CodeImageEncoder.GetGrayscaleSingleThresholdSegmenter().SetBlackLayerEncoded(true );
		IAddress = DefectImg.GetImagePtr();

		DefectROI.SetPlacement((int)(LSP.x+3),(int)(LSP.y), FLeftWidth, LeftHeight);
		if((LSP.x+3) <=0          || LSP.y<0 || FLeftWidth<=0          || LeftHeight<=0          ) return false; // ROI 영역 설정시 0        작을경우 
		if((LSP.x+3) >=ImageWidth || LSP.y<0 || FLeftWidth>=ImageWidth || LeftHeight> ImageHeight) return false; // ROI 영역 설정시 ImageWidth 클경우 

		if(FChippingMinWidth==0 || FChippingMinHeight==0){ FChippingMinWidth=2; FChippingMinHeight=2;}

		// Euresys 검사 진행
		CodeImageSelection.Clear();
		CodeImageEncoder.Encode(DefectROI,CodeImage);
		CodeImageSelection.Clear();
		CodeImageSelection.AddObjects(CodeImage);

		// Blob 필터링 
		CodeImageSelection.RemoveUsingFloatFeature(EFeature_BoundingBoxWidth ,FChippingMinWidth , FChippingMaxWidth  , EDoubleThresholdMode_Outside);
		CodeImageSelection.RemoveUsingFloatFeature(EFeature_BoundingBoxHeight,FChippingMinHeight, FChippingMaxHeight , EDoubleThresholdMode_Outside);
		if(IsRemoveBlob) CodeImageSelection.RemoveUsingIntegerFeature(EFeature_LeftLimit        ,0       , 3         , EDoubleThresholdMode_Outside);
		
		BlobCount = CodeImageSelection.GetElementCount();
		CodeImageSelection.Sort(EFeature_TopLimit,ESortDirection_Ascending);
		
		if(BlobCount!=0){
			for(int k=0; k<BlobCount; k++){
				if(CrackCount>=MAX_DEFECT_POINT) break; 
				CrackPoint[CrackCount].Width  =  CodeImageSelection.GetElement(k).GetBoundingBoxWidth() ;
				CrackPoint[CrackCount].Height =  CodeImageSelection.GetElement(k).GetBoundingBoxHeight();

				CrackPoint[CrackCount].Rect.left   =(long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterX() - CrackPoint[CrackCount].Width/2 ) +LSP.x+3);
				CrackPoint[CrackCount].Rect.top    =(long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - CrackPoint[CrackCount].Height/2) +LSP.y  );
				CrackPoint[CrackCount].Rect.right  =(long)(CrackPoint[CrackCount].Rect.left+ CrackPoint[CrackCount].Width );
				CrackPoint[CrackCount].Rect.bottom =(long)(CrackPoint[CrackCount].Rect.top + CrackPoint[CrackCount].Height);
				PixelCount =0;
				PixelValue =0;

				// 내부 Pixel Data 축출 
				for(int n=CrackPoint[CrackCount].Rect.top ; n<CrackPoint[CrackCount].Rect.bottom; n++){
					for(int m=CrackPoint[CrackCount].Rect.left; m<CrackPoint[CrackCount].Rect.right; m++){
						PixelValue = IElement(m,n);
						if(PixelValue < CrackThresHold) PixelCount++;
					}
				}

				CrackPoint[CrackCount].Round = PixelCount;
				CrackPoint[CrackCount].P.x    =(float)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterX() - CrackPoint[CrackCount].Width/2 ) +LSP.x+3   );
				CrackPoint[CrackCount].P.y    =(float)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - CrackPoint[CrackCount].Height/2)+ImageHeight+LSP.y);

				// Merge 위해서 데이터 필요함 
				CrackPoint[CrackCount].Rect.top    =(long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - CrackPoint[CrackCount].Height/2) +ImageHeight+LSP.y);
				CrackPoint[CrackCount].Rect.bottom =(long)(CrackPoint[CrackCount].Rect.top + CrackPoint[CrackCount].Height);
				CrackCount++;
			}
		}
		BlobCount =0;
        
		// 단축 Cam1은 GrindCheck 1이면 검사를 외곽라인기준과 연마라인 2가지 영역을 검사해야 한다 
		if(IsMarkLine && !IsMarkBtm && GrindCheck){

			EasyImage::Threshold(GImage,&DefectImg, CrackThresHold);
			DefectROI.Attach(&DefectImg);
			CodeImageSelection.SetFeretAngle(0.00f);
			CodeImageEncoder.GetGrayscaleSingleThresholdSegmenter().SetWhiteLayerEncoded(false);
			CodeImageEncoder.GetGrayscaleSingleThresholdSegmenter().SetBlackLayerEncoded(true );
			IAddress = DefectImg.GetImagePtr();

			DefectROI.SetPlacement((int)(Line[0].FP0.x+3),(int)(LSP.y), FLeftWidth, LeftHeight);
			if((LSP.x+3) <=0          || LSP.y<0 || FLeftWidth<=0          || LeftHeight<=0          ) return false;
			if((LSP.x+3) >=ImageWidth || LSP.y<0 || FLeftWidth>=ImageWidth || LeftHeight> ImageHeight) return false; // ROI 영역 설정시 ImageWidth 클경우 

			
			if(FChippingMinWidth==0 || FChippingMinHeight==0){ FChippingMinWidth=2; FChippingMinHeight=2;}
			
			CodeImageSelection.Clear();
			CodeImageEncoder.Encode(DefectROI,CodeImage);
			CodeImageSelection.Clear();
			CodeImageSelection.AddObjects(CodeImage);
			// Blob 필터링 
			CodeImageSelection.RemoveUsingFloatFeature(EFeature_BoundingBoxWidth ,FChippingMinWidth , FChippingMaxWidth  , EDoubleThresholdMode_Outside);
			CodeImageSelection.RemoveUsingFloatFeature(EFeature_BoundingBoxHeight,FChippingMinHeight, FChippingMaxHeight , EDoubleThresholdMode_Outside);
			if(IsRemoveBlob) CodeImageSelection.RemoveUsingIntegerFeature(EFeature_LeftLimit        ,0       , 3         , EDoubleThresholdMode_Outside);
			
			BlobCount = CodeImageSelection.GetElementCount();
			CodeImageSelection.Sort(EFeature_TopLimit,ESortDirection_Ascending);
			
			if(BlobCount!=0){
				for(int k=0; k<BlobCount; k++){
					if(CrackCount>=MAX_DEFECT_POINT) break; 
					CrackPoint[CrackCount].Width  =  CodeImageSelection.GetElement(k).GetBoundingBoxWidth() ;
					CrackPoint[CrackCount].Height =  CodeImageSelection.GetElement(k).GetBoundingBoxHeight();
					
					CrackPoint[CrackCount].Rect.left   =(long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterX() - CrackPoint[CrackCount].Width/2 ) +Line[0].FP0.x+3);
					CrackPoint[CrackCount].Rect.top    =(long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - CrackPoint[CrackCount].Height/2) +LSP.y          );
					CrackPoint[CrackCount].Rect.right  =(long)(CrackPoint[CrackCount].Rect.left+ CrackPoint[CrackCount].Width );
					CrackPoint[CrackCount].Rect.bottom =(long)(CrackPoint[CrackCount].Rect.top + CrackPoint[CrackCount].Height);
					PixelCount =0;
					PixelValue =0;
					
					// 내부 Pixel Data 축출 
					for(int n=CrackPoint[CrackCount].Rect.top ; n<CrackPoint[CrackCount].Rect.bottom; n++){
						for(int m=CrackPoint[CrackCount].Rect.left; m<CrackPoint[CrackCount].Rect.right ; m++){
							PixelValue = IElement(m,n);
							if(PixelValue < CrackThresHold) PixelCount++;
						}
					}
					
					CrackPoint[CrackCount].Round = PixelCount;
					CrackPoint[CrackCount].P.x    =(float)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterX() - CrackPoint[CrackCount].Width/2 ) +Line[0].FP0.x+3   );
					CrackPoint[CrackCount].P.y    =(float)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - CrackPoint[CrackCount].Height/2)+ImageHeight+LSP.y  );
					
					// Merge 위해서 데이터 필요함 
					CrackPoint[CrackCount].Rect.top    =(long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - CrackPoint[CrackCount].Height/2) +ImageHeight+LSP.y);
					CrackPoint[CrackCount].Rect.bottom =(long)(CrackPoint[CrackCount].Rect.top + CrackPoint[CrackCount].Height);
					CrackCount++;
				}
			}
		    BlobCount =0;
		}

		// Broken Inspection
        EasyImage::Threshold(GImage,&DefectImg, BrokenThresHold);
		DefectROI.Attach(&DefectImg);
		CodeImageSelection.SetFeretAngle(0.00f);

		CodeImageEncoder.GetGrayscaleSingleThresholdSegmenter().SetWhiteLayerEncoded(false);
		CodeImageEncoder.GetGrayscaleSingleThresholdSegmenter().SetBlackLayerEncoded(true );

// 		if(!IsShortCell && !IsBMLineData) IAddress = GImage->GetImagePtr();
		if(!IsMarkLine && !IsBMLineData) IAddress = GImage->GetImagePtr();
		else                             IAddress = DefectImg.GetImagePtr();

// 		IAddress = DefectImg.GetImagePtr();
		
		DefectROI.SetPlacement((int)(LSP.x+10),(int)(LSP.y), FLeftWidth, LeftHeight);
		if((LSP.x+10) <=0          || LSP.y<0 || FLeftWidth<=0          || LeftHeight<=0          ) return false;
		if((LSP.x+10) >=ImageWidth || LSP.y<0 || FLeftWidth>=ImageWidth || LeftHeight> ImageHeight) return false; // ROI 영역 설정시 ImageWidth 클경우 

		if(FBrokenMinWidth==0 || FBrokenMinHeight==0){ FBrokenMinWidth=2; FBrokenMinHeight=2;}
		
		CodeImageSelection.Clear();
		CodeImageEncoder.Encode(DefectROI,CodeImage);
		CodeImageSelection.Clear();
		CodeImageSelection.AddObjects(CodeImage);
		// Blob 필터링 
		CodeImageSelection.RemoveUsingFloatFeature(EFeature_BoundingBoxWidth ,FBrokenMinWidth , FBrokenMaxWidth  , EDoubleThresholdMode_Outside);
		CodeImageSelection.RemoveUsingFloatFeature(EFeature_BoundingBoxHeight,FBrokenMinHeight, FBrokenMaxHeight , EDoubleThresholdMode_Outside);
// 		CodeImageSelection.RemoveUsingFloatFeature(EFeature_BoundingBoxWidth ,180 , FBrokenMaxWidth    , EDoubleThresholdMode_Outside);
// 		CodeImageSelection.RemoveUsingFloatFeature(EFeature_BoundingBoxHeight,40  , FBrokenMaxHeight   , EDoubleThresholdMode_Outside);
		CodeImageSelection.RemoveUsingIntegerFeature(EFeature_LeftLimit      ,0   , 3                  , EDoubleThresholdMode_Outside);
		
		BlobCount = CodeImageSelection.GetElementCount();
		CodeImageSelection.Sort(EFeature_TopLimit,ESortDirection_Ascending);
		
		if(BlobCount!=0){
			for(int k=0; k<BlobCount; k++){
				if(BrokenCount>=MAX_DEFECT_POINT) break; 

				// Frit에 붙어 있는 불량을 제거하는 시퀀스 
// 				if(!IsShortCell && !IsBMLineData){

				if(!IsMarkLine && !IsBMLineData){ //단축 Cam3  장축 Cam1,Cam3
					if((CodeImageSelection.GetElement(k).GetBoundingBoxWidth()>BroMarginWidth) && (CodeImageSelection.GetElement(k).GetBoundingBoxHeight()>BroMarginHeight)){
						MaxData =0; CurData =0; MaxPixel=0; BrokenPixel =0; CrackPixel=0; 
						BrokenRect.left   = (long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterX() - CodeImageSelection.GetElement(k).GetBoundingBoxWidth()/2 )+LSP.x+10);
						BrokenRect.top    = (long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - CodeImageSelection.GetElement(k).GetBoundingBoxHeight()/2)+LSP.y   );
						BrokenRect.right  = (long)( BrokenRect.left                                          + CodeImageSelection.GetElement(k).GetBoundingBoxWidth()             );
						BrokenRect.bottom = (long)( BrokenRect.top                                           + CodeImageSelection.GetElement(k).GetBoundingBoxHeight()            );
						
						// Org Data Count Check 
						for(int n=BrokenRect.top+1 ; n<BrokenRect.bottom-1; n++){
							for(int m=BrokenRect.left+1; m<BrokenRect.right-1 ; m++){
								PixelValue = IElement(m,n);
								PixelData[PixelValue]++;
							}
						}
						// Org Data Max Check 
						for(int k1=0; k1<256; k1++){
							CurData = PixelData[k1];
							if(CurData>MaxData) {MaxData = CurData; MaxPixel =k1;}
						}
						
						for(int n1=BrokenRect.top+1 ; n1<BrokenRect.bottom-1; n1++){
							for(int m1=BrokenRect.left+1; m1<BrokenRect.right-1 ; m1++){
								PixelValue = IElement(m1,n1);
								if(!IsShortCell){
									if(PixelValue > (MaxPixel+20 ) && PixelValue<BrokenThresHold) BrokenPixel++;
									if(PixelValue < (MaxPixel-15 )                              ) CrackPixel++ ;
								}
								else {
									if(PixelValue > (MaxPixel+30 ) && PixelValue<BrokenThresHold) BrokenPixel++;
									if(PixelValue < (MaxPixel-5  )                              ) CrackPixel++ ;
								}
							}
						}
						if(!IsShortCell){
							if((BrokenPixel < LongBrokenMargin) && (CrackPixel<LongCrackMargin)){
// 								LogUnit.SetLog("Long_OverKill:%s , CellId: %d, CamId: %d, ImageHeight: %d, MaxPixel: %d, BCount: %d , CCount: %d",CellName, CellId,CamId,ImageHeight,MaxPixel,BrokenPixel,CrackPixel);     
								continue;
							}
// 							LogUnit.SetLog("Long_RealFail:%s , CellId: %d, CamId: %d, ImageHeight: %d, MaxPixel: %d, BCount: %d , CCount: %d",CellName,CellId,CamId,ImageHeight,MaxPixel,BrokenPixel,CrackPixel);     
						}
						else {
							if((CrackPixel<ShortCrackMargin)){
// 								LogUnit.SetLog("Short_OverKill:%s , CellId: %d, CamId: %d, ImageHeight: %d, MaxPixel: %d, BCount: %d , CCount: %d",CellName, CellId,CamId,ImageHeight,MaxPixel,BrokenPixel,CrackPixel);     
								continue;
							}
// 							LogUnit.SetLog("Short_RealFail:%s , CellId: %d, CamId: %d, ImageHeight: %d, MaxPixel: %d, BCount: %d , CCount: %d",CellName, CellId,CamId,ImageHeight,MaxPixel,BrokenPixel,CrackPixel);     
						}
					}
				}

				BrokenPoint[BrokenCount].Width  =  CodeImageSelection.GetElement(k).GetBoundingBoxWidth() ;
				BrokenPoint[BrokenCount].Height =  CodeImageSelection.GetElement(k).GetBoundingBoxHeight();
				
				BrokenPoint[BrokenCount].Rect.left   =(long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterX() - BrokenPoint[BrokenCount].Width/2 ) +LSP.x+10);
				BrokenPoint[BrokenCount].Rect.top    =(long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - BrokenPoint[BrokenCount].Height/2) +LSP.y   );
				BrokenPoint[BrokenCount].Rect.right  =(long)(BrokenPoint[BrokenCount].Rect.left+ BrokenPoint[BrokenCount].Width );
				BrokenPoint[BrokenCount].Rect.bottom =(long)(BrokenPoint[BrokenCount].Rect.top + BrokenPoint[BrokenCount].Height);

				PixelCount =0;
				PixelValue =0;
				
				// 내부 Pixel Data 축출 
				for(int n1=BrokenPoint[BrokenCount].Rect.top+1 ; n1<BrokenPoint[BrokenCount].Rect.bottom-1; n1++){
					for(int m1=BrokenPoint[BrokenCount].Rect.left+1; m1<BrokenPoint[BrokenCount].Rect.right-1 ; m1++){
						PixelValue = IElement(m1,n1);
						if(PixelValue < BrokenThresHold) PixelCount++ ;
					}
				}

//                 OnWriteLogFile();
				
				BrokenPoint[BrokenCount].Round = PixelCount;
				BrokenPoint[BrokenCount].P.x    =(float)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterX() - BrokenPoint[BrokenCount].Width/2 ) +LSP.x+10        );
				BrokenPoint[BrokenCount].P.y    =(float)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - BrokenPoint[BrokenCount].Height/2)+ImageHeight+LSP.y);
				
				// Merge 위해서 데이터 필요함 
				BrokenPoint[BrokenCount].Rect.top    =(long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - BrokenPoint[BrokenCount].Height/2) +ImageHeight+LSP.y);
				BrokenPoint[BrokenCount].Rect.bottom =(long)(BrokenPoint[BrokenCount].Rect.top + BrokenPoint[BrokenCount].Height);
				BrokenCount++;
			}
		}
		BlobCount =0;

		/*
		// Burr Inspection
		if(IsMarkLine && !IsMarkBtm){
			BurrOffset   =  5;
			BurrROIWidth = (int)((LSP.x - Line[0].FP0.x) +100);
		}
		else {
			BurrOffset   =  5;
			BurrROIWidth =100;
		}
        EasyImage::Threshold(GImage,&DefectImg, BurrThresHold);
		DefectROI.Attach(&DefectImg);
		CodeImageSelection.SetFeretAngle(0.00f);
		CodeImageEncoder.GetGrayscaleSingleThresholdSegmenter().SetWhiteLayerEncoded(true );
		CodeImageEncoder.GetGrayscaleSingleThresholdSegmenter().SetBlackLayerEncoded(false);
		IAddress = DefectImg.GetImagePtr();

		// InLine->OutLine으로 검사영역 기준 변경해야함 
		LSP.x = LSP.x - GrindSize;
		if(LSP.x<=0) return false;
		
		DefectROI.SetPlacement((int)(LSP.x - (BurrOffset+BurrROIWidth)),(int)(LSP.y), 100, LeftHeight);
		if((LSP.x - (BurrOffset+BurrROIWidth)) <=0          || LSP.y<0 || BurrROIWidth<=0          || LeftHeight<=0          ) return false;
		if((LSP.x - (BurrOffset+BurrROIWidth)) >=ImageWidth || LSP.y<0 || BurrROIWidth>=ImageWidth || LeftHeight> ImageHeight) return false; // ROI 영역 설정시 ImageWidth 클경우 

		if(FBurrMinWidth==0 || FBurrMinHeight==0){ FBurrMinWidth=2; FBurrMinHeight=2;}

		//DefectROI.SetPlacement((int)(LSP.x+1),(int)(LSP.y), FLeftWidth, LeftHeight);
		//if((LSP.x+1) <=0 || LSP.y<0 || FLeftWidth<=0 || LeftHeight<=0) return false;
		
		CodeImageSelection.Clear();
		CodeImageEncoder.Encode(DefectROI,CodeImage);
		CodeImageSelection.Clear();
		CodeImageSelection.AddObjects(CodeImage);

		BlobCount = CodeImageSelection.GetElementCount();

		// Blob 필터링 
		CodeImageSelection.RemoveUsingFloatFeature(EFeature_BoundingBoxWidth ,FBurrMinWidth , FBurrMaxWidth  , EDoubleThresholdMode_Outside);
		CodeImageSelection.RemoveUsingFloatFeature(EFeature_BoundingBoxHeight,FBurrMinHeight, FBurrMaxHeight , EDoubleThresholdMode_Outside);
		//CodeImageSelection.RemoveUsingIntegerFeature(EFeature_LeftLimit        ,0       , 3          , EDoubleThresholdMode_Outside);
		
		BlobCount = CodeImageSelection.GetElementCount();
		CodeImageSelection.Sort(EFeature_TopLimit,ESortDirection_Ascending);
		
		if(BlobCount!=0){
			for(int k=0; k<BlobCount; k++){
				if(BurrCount>=MAX_DEFECT_POINT) break; 
				BurrPoint[BurrCount].Width  =  CodeImageSelection.GetElement(k).GetBoundingBoxWidth() ;
				BurrPoint[BurrCount].Height =  CodeImageSelection.GetElement(k).GetBoundingBoxHeight();
				
				BurrPoint[BurrCount].Rect.left   =(long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterX() - BurrPoint[BurrCount].Width/2 ) +(LSP.x - (BurrOffset+BurrROIWidth)));
				BurrPoint[BurrCount].Rect.top    =(long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - BurrPoint[BurrCount].Height/2) +LSP.y                              );
				BurrPoint[BurrCount].Rect.right  =(long)(BurrPoint[BurrCount].Rect.left+ BurrPoint[BurrCount].Width );
				BurrPoint[BurrCount].Rect.bottom =(long)(BurrPoint[BurrCount].Rect.top + BurrPoint[BurrCount].Height);
				PixelCount =0;
				PixelValue =0;
				
				// 내부 Pixel Data 축출 
				for(int n=BurrPoint[BurrCount].Rect.top+1 ; n<BurrPoint[BurrCount].Rect.bottom-1; n++){
					for(int m=BurrPoint[BurrCount].Rect.left+1; m<BurrPoint[BurrCount].Rect.right-1 ; m++){
						PixelValue = IElement(m,n);
						if(PixelValue < BurrThresHold) PixelCount++;
					}
				}
				
				BurrPoint[BurrCount].Round = PixelCount;
				BurrPoint[BurrCount].P.x    =(float)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterX() - BurrPoint[BurrCount].Width/2 ) +(LSP.x - (BurrOffset+BurrROIWidth)));
				BurrPoint[BurrCount].P.y    =(float)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - BurrPoint[BurrCount].Height/2) +ImageHeight+LSP.y                  );
				
				// Merge 위해서 데이터 필요함 
				BurrPoint[BurrCount].Rect.top    =(long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - BurrPoint[BurrCount].Height/2) +ImageHeight+LSP.y);
				BurrPoint[BurrCount].Rect.bottom =(long)(BurrPoint[BurrCount].Rect.top + BurrPoint[BurrCount].Height);
				BurrCount++;
			}
		}
		BlobCount =0;

	    DefectPointCount = CrackCount+BrokenCount+BurrCount; // 전체 불량개수 계산
		*/


		// Defect Blob Merge
		///////////////////////////////////////////////////////////////////////////////////////////////
		if(FShape==shRectCL || IsMarkLine){
			// Inspection End 
			IsInspEnd = true;
			// Crack Defect Merge  
			if(CrackCount!=0){
				bool IsxMg=false, IsyMg=false, IsInMg=false;
				CRect r1, r2;
				int sort =0;
				int tmpDDefectCount = CrackCount;

				for(int k=0; k<tmpDDefectCount; k++){
					if(CrackPoint[k].Rect.left==0 && CrackPoint[k].Rect.top==0 && CrackPoint[k].Rect.right==0 && CrackPoint[k].Rect.bottom==0) continue;

					for(int l=k+1; l<k+MgCount; l++ ){
						IsxMg = false; IsyMg = false;
						if(l>(tmpDDefectCount-1)) break;
						if(CrackPoint[l].Rect.left==0 && CrackPoint[l].Rect.top==0 && CrackPoint[k].Rect.right==0 && CrackPoint[k].Rect.bottom==0) continue;

						r1 = CrackPoint[k].Rect;
						r2 = CrackPoint[l].Rect; 

						register int HorDist   = (r1.left < r2.left) ?  r2.left - r1.right  : r1.left - r2.right ;
						register int VerDist   = (r1.top  < r2.top ) ?  r2.top  - r1.bottom : r1.top  - r2.bottom;
						IsInMg    = ((r1.left<=r2.left) && (r1.top<r2.top) && (r1.bottom>r2.bottom) && (r1.right >r2.right))? true: false;
						
						if(HorDist>xMerge && VerDist>yMerge && !IsInMg ) continue;
						
						IsxMg = (HorDist<xMerge) ? true: false;
						IsyMg = (VerDist<yMerge) ? true: false;
						
						if((IsxMg && IsyMg) || IsInMg){
							CrackPoint[k].Round    += CrackPoint[l].Round;
							CrackPoint[k].Rect      = OnMerge(CrackPoint[k].Rect, CrackPoint[l].Rect);
							CrackPoint[k].Width     = CrackPoint[k].Rect.right  - CrackPoint[k].Rect.left;
							CrackPoint[k].Height    = CrackPoint[k].Rect.bottom - CrackPoint[k].Rect.top ;
							CrackPoint[k].P.x       = (float)(CrackPoint[k].Rect.left); 
							CrackPoint[k].P.y       = (float)(CrackPoint[k].Rect.top ); 
							CrackPoint[l].Rect.left = CrackPoint[l].Rect.top = CrackPoint[l].Rect.right = CrackPoint[l].Rect.bottom =0;
							CrackCount--;
							k=-1;
							break;
						}
					}
				}
				for(int j=0; j<tmpDDefectCount; j++){
					if(CrackPoint[j].Rect.left==0 && CrackPoint[j].Rect.top==0 && CrackPoint[j].Rect.right==0 && CrackPoint[j].Rect.bottom==0) continue;
					CrackPoint[sort] = CrackPoint[j];
					sort++;
				}
			}

			// Broken Defect Merge  
			if(BrokenCount!=0){
				bool IsxMg=false, IsyMg=false, IsInMg=false;
				CRect r1, r2;
				int sort =0;
				int tmpBDefectCount = BrokenCount;
				
				for(int k=0; k<tmpBDefectCount; k++){
					if(BrokenPoint[k].Rect.left==0 && BrokenPoint[k].Rect.top==0 && BrokenPoint[k].Rect.right==0 && BrokenPoint[k].Rect.bottom==0) continue;
					
					for(int l=k+1; l<k+MgCount; l++ ){
						IsxMg = false; IsyMg = false;
						if(l>(tmpBDefectCount-1)) break;
						if(BrokenPoint[l].Rect.left==0 && BrokenPoint[l].Rect.top==0 && BrokenPoint[k].Rect.right==0 && BrokenPoint[k].Rect.bottom==0) continue;
						
						r1 = BrokenPoint[k].Rect;
						r2 = BrokenPoint[l].Rect; 
						
						register int HorDist   = (r1.left < r2.left) ?  r2.left - r1.right  : r1.left - r2.right ;
						register int VerDist   = (r1.top  < r2.top ) ?  r2.top  - r1.bottom : r1.top  - r2.bottom;
						IsInMg    = ((r1.left<=r2.left) && (r1.top<r2.top) && (r1.bottom>r2.bottom) && (r1.right >r2.right))? true: false;
						
						if(HorDist>xMerge && VerDist>yMerge && !IsInMg ) continue;
						
						IsxMg = (HorDist<xMerge) ? true: false;
						IsyMg = (VerDist<yMerge) ? true: false;
						
						if((IsxMg && IsyMg) || IsInMg){
							BrokenPoint[k].Round    += BrokenPoint[l].Round;
							BrokenPoint[k].Rect      = OnMerge(BrokenPoint[k].Rect, BrokenPoint[l].Rect);
							BrokenPoint[k].Width     = BrokenPoint[k].Rect.right  - BrokenPoint[k].Rect.left;
							BrokenPoint[k].Height    = BrokenPoint[k].Rect.bottom - BrokenPoint[k].Rect.top ;
							BrokenPoint[k].P.x       = (float)(BrokenPoint[k].Rect.left); 
							BrokenPoint[k].P.y       = (float)(BrokenPoint[k].Rect.top ); 
							BrokenPoint[l].Rect.left = BrokenPoint[l].Rect.top = BrokenPoint[l].Rect.right = BrokenPoint[l].Rect.bottom =0;
							BrokenCount--;
							k=-1;
							break;
						}
					}
				}
				for(int j=0; j<tmpBDefectCount; j++){
					if(BrokenPoint[j].Rect.left==0 && BrokenPoint[j].Rect.top==0 && BrokenPoint[j].Rect.right==0 && BrokenPoint[j].Rect.bottom==0) continue;
					BrokenPoint[sort] = BrokenPoint[j];
					sort++;
				}
			}

			// Burr Defect Merge  
			if(BurrCount!=0){
				bool IsxMg=false, IsyMg=false, IsInMg=false;
				CRect r1, r2;
				int sort =0;
				int tmpBDefectCount = BurrCount;
				
				for(int k=0; k<tmpBDefectCount; k++){
					if(BurrPoint[k].Rect.left==0 && BurrPoint[k].Rect.top==0 && BurrPoint[k].Rect.right==0 && BurrPoint[k].Rect.bottom==0) continue;
					
					for(int l=k+1; l<k+MgCount; l++ ){
						IsxMg = false; IsyMg = false;
						if(l>(tmpBDefectCount-1)) break;
						if(BurrPoint[l].Rect.left==0 && BurrPoint[l].Rect.top==0 && BurrPoint[k].Rect.right==0 && BurrPoint[k].Rect.bottom==0) continue;
						
						r1 = BurrPoint[k].Rect;
						r2 = BurrPoint[l].Rect; 
						
						register int HorDist   = (r1.left < r2.left) ?  r2.left - r1.right  : r1.left - r2.right ;
						register int VerDist   = (r1.top  < r2.top ) ?  r2.top  - r1.bottom : r1.top  - r2.bottom;
						IsInMg    = ((r1.left<=r2.left) && (r1.top<r2.top) && (r1.bottom>r2.bottom) && (r1.right >r2.right))? true: false;
						
						if(HorDist>xMerge && VerDist>yMerge && !IsInMg ) continue;
						
						IsxMg = (HorDist<xMerge) ? true: false;
						IsyMg = (VerDist<yMerge) ? true: false;
						
						if((IsxMg && IsyMg) || IsInMg){
							BurrPoint[k].Round    += BurrPoint[l].Round;
							BurrPoint[k].Rect      = OnMerge(BurrPoint[k].Rect, BurrPoint[l].Rect);
							BurrPoint[k].Width     = BurrPoint[k].Rect.right  - BurrPoint[k].Rect.left;
							BurrPoint[k].Height    = BurrPoint[k].Rect.bottom - BurrPoint[k].Rect.top ;
							BurrPoint[k].P.x       = (float)(BurrPoint[k].Rect.left); 
							BurrPoint[k].P.y       = (float)(BurrPoint[k].Rect.top ); 
							BurrPoint[l].Rect.left = BurrPoint[l].Rect.top = BurrPoint[l].Rect.right = BurrPoint[l].Rect.bottom =0;
							BurrCount--;
							k=-1;
							break;
						}
					}
				}
				for(int j=0; j<tmpBDefectCount; j++){
					if(BurrPoint[j].Rect.left==0 && BurrPoint[j].Rect.top==0 && BurrPoint[j].Rect.right==0 && BurrPoint[j].Rect.bottom==0) continue;
					BurrPoint[sort] = BurrPoint[j];
					sort++;
				}
				
			}
		}
		//////////////////////////////////////////////////////////////////////////////////////////////
		// Blob Merge End
		Index = 0;
		return true;

		// EdgeInspection(천마) : 단축 TOP Broken Inspection Sequence 
		//------------------------------------------------------------------
	case 5 :

	    BlobCount =0;

		// Broken Inspection
        EasyImage::Threshold(GImage,&DefectImg, BrokenThresHold);
		DefectROI.Attach(&DefectImg);
		CodeImageSelection.SetFeretAngle(0.00f);

		CodeImageEncoder.GetGrayscaleSingleThresholdSegmenter().SetWhiteLayerEncoded(false);
		CodeImageEncoder.GetGrayscaleSingleThresholdSegmenter().SetBlackLayerEncoded(true );

		IAddress = DefectImg.GetImagePtr();
		
		
	    DefectROI.SetPlacement((int)(LSP.x+10),(int)(LSP.y), (int)(LEP.x -LSP.x), FTopHeight);
		if((LSP.x+10) <=0          || LSP.y<0 || (LEP.x -LSP.x)<=0          || FTopHeight<=0          ) return false;
		if((LSP.x+10) >=ImageWidth || LSP.y<0 || (LEP.x -LSP.x)>=ImageWidth || FTopHeight> ImageHeight) return false; // ROI 영역 설정시 ImageWidth 클경우 

		if(FBrokenMinWidth==0 || FBrokenMinHeight==0){ FBrokenMinWidth=10; FBrokenMinHeight=10;}
		
		CodeImageSelection.Clear();
		CodeImageEncoder.Encode(DefectROI,CodeImage);
		CodeImageSelection.Clear();
		CodeImageSelection.AddObjects(CodeImage);

		// Blob 필터링 
		CodeImageSelection.RemoveUsingFloatFeature  (EFeature_BoundingBoxWidth ,FBrokenMinWidth , FBrokenMaxWidth  , EDoubleThresholdMode_Outside);
		CodeImageSelection.RemoveUsingFloatFeature  (EFeature_BoundingBoxHeight,FBrokenMinHeight, FBrokenMaxHeight , EDoubleThresholdMode_Outside);
		CodeImageSelection.RemoveUsingIntegerFeature(EFeature_TopLimit         ,0               , 3                , EDoubleThresholdMode_Outside);
		
		BlobCount = CodeImageSelection.GetElementCount();
		CodeImageSelection.Sort(EFeature_LeftLimit,ESortDirection_Ascending);
		
		if(BlobCount!=0){
			for(int k=0; k<BlobCount; k++){
				if(BrokenCount>=MAX_DEFECT_POINT) break; 
				BrokenPoint[BrokenCount].Width  =  CodeImageSelection.GetElement(k).GetBoundingBoxWidth() ;
				BrokenPoint[BrokenCount].Height =  CodeImageSelection.GetElement(k).GetBoundingBoxHeight();
				
				BrokenPoint[BrokenCount].Rect.left   =(long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterX() - BrokenPoint[BrokenCount].Width/2 ) +LSP.x+10);
				BrokenPoint[BrokenCount].Rect.top    =(long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - BrokenPoint[BrokenCount].Height/2) +LSP.y   );
				BrokenPoint[BrokenCount].Rect.right  =(long)(BrokenPoint[BrokenCount].Rect.left+ BrokenPoint[BrokenCount].Width );
				BrokenPoint[BrokenCount].Rect.bottom =(long)(BrokenPoint[BrokenCount].Rect.top + BrokenPoint[BrokenCount].Height);
				PixelCount =0;
				PixelValue =0;
				
				// 내부 Pixel Data 축출 
				for(int n=BrokenPoint[BrokenCount].Rect.top+1 ; n<BrokenPoint[BrokenCount].Rect.bottom-1; n++){
					for(int m=BrokenPoint[BrokenCount].Rect.left+1; m<BrokenPoint[BrokenCount].Rect.right-1 ; m++){
						PixelValue = IElement(m,n);
						if(PixelValue < BrokenThresHold) PixelCount++;
					}
				}
				
				BrokenPoint[BrokenCount].Round = PixelCount;
				BrokenPoint[BrokenCount].P.x    =(float)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterX() - BrokenPoint[BrokenCount].Width/2 ) +LSP.x+10           );
				BrokenPoint[BrokenCount].P.y    =(float)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - BrokenPoint[BrokenCount].Height/2)+ImageHeight+LSP.y   );
				
				// Merge 위해서 데이터 필요함 
				BrokenPoint[BrokenCount].Rect.top    =(long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - BrokenPoint[BrokenCount].Height/2) +ImageHeight+LSP.y  );
				BrokenPoint[BrokenCount].Rect.bottom =(long)(BrokenPoint[BrokenCount].Rect.top + BrokenPoint[BrokenCount].Height);
				BrokenCount++;
			}
		}
		BlobCount =0;

	    DefectPointCount = CrackCount+BrokenCount+BurrCount; // 전체 불량개수 계산

		Index = 0;
		return true;

		// EdgeInspection(천마) : 단축 TOP Broken Inspection Sequence 
		//------------------------------------------------------------------
	case 6 :

	    BlobCount =0;

		// Broken Inspection
        EasyImage::Threshold(GImage,&DefectImg, BrokenThresHold);
		DefectROI.Attach(&DefectImg);
		CodeImageSelection.SetFeretAngle(0.00f);

		CodeImageEncoder.GetGrayscaleSingleThresholdSegmenter().SetWhiteLayerEncoded(false);
		CodeImageEncoder.GetGrayscaleSingleThresholdSegmenter().SetBlackLayerEncoded(true );

		IAddress = DefectImg.GetImagePtr();
		
		DefectROI.SetPlacement((int)(LSP.x+10),(int)((LSP.y+LEP.y)/2 - FTopHeight), (int)(LEP.x -LSP.x), FTopHeight-IgnoreOffset);
		if((LSP.x+10) <=0          || ((LSP.y+LEP.y)/2 - FTopHeight)<0 || (LEP.x -LSP.x)<=0          || (FTopHeight-IgnoreOffset)<=0          ) return false;
		if((LSP.x+10) >=ImageWidth || ((LSP.y+LEP.y)/2 - FTopHeight)<0 || (LEP.x -LSP.x)>=ImageWidth || (FTopHeight-IgnoreOffset)> ImageHeight) return false; // ROI 영역 설정시 ImageWidth 클경우 


		if(FBrokenMinWidth==0 || FBrokenMinHeight==0){ FBrokenMinWidth=10; FBrokenMinHeight=10;}
		
		CodeImageSelection.Clear();
		CodeImageEncoder.Encode(DefectROI,CodeImage);
		CodeImageSelection.Clear();
		CodeImageSelection.AddObjects(CodeImage);
		// Blob 필터링 
		CodeImageSelection.RemoveUsingFloatFeature  (EFeature_BoundingBoxWidth ,FBrokenMinWidth , FBrokenMaxWidth  , EDoubleThresholdMode_Outside);
		CodeImageSelection.RemoveUsingFloatFeature  (EFeature_BoundingBoxHeight,FBrokenMinHeight, FBrokenMaxHeight , EDoubleThresholdMode_Outside);
		CodeImageSelection.RemoveUsingIntegerFeature(EFeature_BottomLimit      ,(FTopHeight-IgnoreOffset)-1        , (FTopHeight-IgnoreOffset)+1 , EDoubleThresholdMode_Outside);
		
		BlobCount = CodeImageSelection.GetElementCount();
		CodeImageSelection.Sort(EFeature_LeftLimit,ESortDirection_Ascending);
		
		if(BlobCount!=0){
			for(int k=0; k<BlobCount; k++){
				if(BrokenCount>=MAX_DEFECT_POINT) break; 
				BrokenPoint[BrokenCount].Width  =  CodeImageSelection.GetElement(k).GetBoundingBoxWidth() ;
				BrokenPoint[BrokenCount].Height =  CodeImageSelection.GetElement(k).GetBoundingBoxHeight();
				
				BrokenPoint[BrokenCount].Rect.left   =(long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterX() - BrokenPoint[BrokenCount].Width/2 ) +LSP.x+10);
				BrokenPoint[BrokenCount].Rect.top    =(long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - BrokenPoint[BrokenCount].Height/2) +((LSP.y+LEP.y)/2 - FTopHeight));
				BrokenPoint[BrokenCount].Rect.right  =(long)(BrokenPoint[BrokenCount].Rect.left+ BrokenPoint[BrokenCount].Width );
				BrokenPoint[BrokenCount].Rect.bottom =(long)(BrokenPoint[BrokenCount].Rect.top + BrokenPoint[BrokenCount].Height);
				PixelCount =0;
				PixelValue =0;
				
				// 내부 Pixel Data 축출 
				for(int n=BrokenPoint[BrokenCount].Rect.top+1 ; n<BrokenPoint[BrokenCount].Rect.bottom-1; n++){
					for(int m=BrokenPoint[BrokenCount].Rect.left+1; m<BrokenPoint[BrokenCount].Rect.right-1 ; m++){
						PixelValue = IElement(m,n);
						if(PixelValue < BrokenThresHold) PixelCount++;
					}
				}
				
				BrokenPoint[BrokenCount].Round = PixelCount;
				BrokenPoint[BrokenCount].P.x    =(float)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterX() - BrokenPoint[BrokenCount].Width/2 ) +LSP.x+10        );
				BrokenPoint[BrokenCount].P.y    =(float)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - BrokenPoint[BrokenCount].Height/2)+((LSP.y+LEP.y)/2 - FTopHeight)+ImageHeight);
				
				// Merge 위해서 데이터 필요함 
				BrokenPoint[BrokenCount].Rect.top    =(long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - BrokenPoint[BrokenCount].Height/2) +((LSP.y+LEP.y)/2 - FTopHeight)+ImageHeight);
				BrokenPoint[BrokenCount].Rect.bottom =(long)(BrokenPoint[BrokenCount].Rect.top + BrokenPoint[BrokenCount].Height);
				BrokenCount++;
			}
		}
		BlobCount =0;

	    DefectPointCount = CrackCount+BrokenCount+BurrCount; // 전체 불량개수 계산


		// Defect Blob Merge
		///////////////////////////////////////////////////////////////////////////////////////////////
		if(FShape==shRectBTM){
			// Broken Defect Merge  
			if(BrokenCount!=0){
				bool IsxMg=false, IsyMg=false, IsInMg=false;
				CRect r1, r2;
				int sort =0;
				int tmpBDefectCount = BrokenCount;
				
				for(int k=0; k<tmpBDefectCount; k++){
					if(BrokenPoint[k].Rect.left==0 && BrokenPoint[k].Rect.top==0 && BrokenPoint[k].Rect.right==0 && BrokenPoint[k].Rect.bottom==0) continue;
					
					for(int l=k+1; l<k+MgCount; l++ ){
						IsxMg = false; IsyMg = false;
						if(l>(tmpBDefectCount-1)) break;
						if(BrokenPoint[l].Rect.left==0 && BrokenPoint[l].Rect.top==0 && BrokenPoint[k].Rect.right==0 && BrokenPoint[k].Rect.bottom==0) continue;
						
						r1 = BrokenPoint[k].Rect;
						r2 = BrokenPoint[l].Rect; 
						
						register int HorDist   = (r1.left < r2.left) ?  r2.left - r1.right  : r1.left - r2.right ;
						register int VerDist   = (r1.top  < r2.top ) ?  r2.top  - r1.bottom : r1.top  - r2.bottom;
						IsInMg    = ((r1.left<=r2.left) && (r1.top<r2.top) && (r1.bottom>r2.bottom) && (r1.right >r2.right))? true: false;
						
						if(HorDist>xMerge && VerDist>yMerge && !IsInMg ) continue;
						
						IsxMg = (HorDist<xMerge) ? true: false;
						IsyMg = (VerDist<yMerge) ? true: false;
						
						if((IsxMg && IsyMg) || IsInMg){
							BrokenPoint[k].Round    += BrokenPoint[l].Round;
							BrokenPoint[k].Rect      = OnMerge(BrokenPoint[k].Rect, BrokenPoint[l].Rect);
							BrokenPoint[k].Width     = BrokenPoint[k].Rect.right  - BrokenPoint[k].Rect.left;
							BrokenPoint[k].Height    = BrokenPoint[k].Rect.bottom - BrokenPoint[k].Rect.top ;
							BrokenPoint[k].P.x       = (float)(BrokenPoint[k].Rect.left);
							BrokenPoint[k].P.y       = (float)(BrokenPoint[k].Rect.top );
							BrokenPoint[l].Rect.left = BrokenPoint[l].Rect.top = BrokenPoint[l].Rect.right = BrokenPoint[l].Rect.bottom =0;
							BrokenCount--;
							k=-1;
							break;
						}
						
					}
					
				}
				for(int j=0; j<tmpBDefectCount; j++){
					if(BrokenPoint[j].Rect.left==0 && BrokenPoint[j].Rect.top==0 && BrokenPoint[j].Rect.right==0 && BrokenPoint[j].Rect.bottom==0) continue;
					BrokenPoint[sort] = BrokenPoint[j];
					sort++;
				}
			}
			//////////////////////////////////////////////////////////////////////////////////////////////
			// Blob Merge End
			Index = 0;
			return true;
		}
		// BOE shRectHL 검사 시퀀스 
	case 7 :
		if(IsCornerTop){
			if(LTDx!=0 && LTDy!=0 ) { //Corner Defect 검사 
				// Corner 1 
				if(C1EdgeCount!=0){
					CornerCount=0;
					for(int k=0; k<C1EdgeCount; k++){
						if(C1Point[k].y>FLTLPoint.y-1) continue;
						Dis = Math.GetLengthFrLineToPoint(FLTLPoint, FLTTPoint, C1Point[k]);
						C1Corner[CornerCount].Dv   = Dis         ;
						C1Corner[CornerCount].P.x  = C1Point[k].x;
						C1Corner[CornerCount].P.y  = C1Point[k].y;
						CornerCount++;
					}
					C1Count = GetSize(C1Corner, C1DefectPoint, CornerCount, 5);
				}
			}
			// Left Inspection
			// Chipping Inspection
			if(CrackThresHold!=0){
				BlobCount =0;
				EasyImage::Threshold(GImage,&DefectImg, CrackThresHold);
				DefectROI.Attach(&DefectImg);
				CodeImageSelection.SetFeretAngle(0.00f);
				CodeImageEncoder.GetGrayscaleSingleThresholdSegmenter().SetWhiteLayerEncoded(false);
				CodeImageEncoder.GetGrayscaleSingleThresholdSegmenter().SetBlackLayerEncoded(true );
				IAddress = DefectImg.GetImagePtr(); // 내부 Pixel Data 추출 목적으로 필요함 

// 				DefectROI.SetPlacement(-100,-100, -100, -100);
				DefectROI.SetPlacement((int)(LSP.x+2),(int)(LSP.y), FLeftWidth, LeftHeight);
				if((LSP.x+2) <=0          || LSP.y<0     || FLeftWidth<=0          || LeftHeight<=0   ) return false; // ROI 영역 설정시 0        작을경우 
				if((LSP.x+2) >=ImageWidth || LSP.y> ImgH || FLeftWidth>=ImageWidth || LeftHeight> ImgH) return false; // ROI 영역 설정시 ImageWidth 클경우 

				if(FChippingMinWidth==0 || FChippingMinHeight==0){ FChippingMinWidth=2; FChippingMinHeight=2;}

				// Euresys 검사 진행
				CodeImageSelection.Clear();
				CodeImageEncoder.Encode(DefectROI,CodeImage);
				CodeImageSelection.Clear();
				CodeImageSelection.AddObjects(CodeImage);

				// Blob 필터링 
				CodeImageSelection.RemoveUsingFloatFeature(EFeature_BoundingBoxWidth ,FChippingMinWidth , FChippingMaxWidth  , EDoubleThresholdMode_Outside);
				CodeImageSelection.RemoveUsingFloatFeature(EFeature_BoundingBoxHeight,FChippingMinHeight, FChippingMaxHeight , EDoubleThresholdMode_Outside);
				if(IsRemoveBlob) CodeImageSelection.RemoveUsingIntegerFeature(EFeature_LeftLimit        ,0       , 3         , EDoubleThresholdMode_Outside);

				BlobCount = CodeImageSelection.GetElementCount();
				CodeImageSelection.Sort(EFeature_TopLimit,ESortDirection_Ascending);

				if(BlobCount!=0){
					for(int k=0; k<BlobCount; k++){
						if(CrackCount>=MAX_DEFECT_POINT) break; 
						CrackPoint[CrackCount].Width  =  CodeImageSelection.GetElement(k).GetBoundingBoxWidth() ;
						CrackPoint[CrackCount].Height =  CodeImageSelection.GetElement(k).GetBoundingBoxHeight();

						CrackPoint[CrackCount].Rect.left   =(long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterX() - CrackPoint[CrackCount].Width/2 ) +LSP.x+2);
						CrackPoint[CrackCount].Rect.top    =(long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - CrackPoint[CrackCount].Height/2) +LSP.y  );
						CrackPoint[CrackCount].Rect.right  =(long)(CrackPoint[CrackCount].Rect.left+ CrackPoint[CrackCount].Width );
						CrackPoint[CrackCount].Rect.bottom =(long)(CrackPoint[CrackCount].Rect.top + CrackPoint[CrackCount].Height);
						PixelCount =0;
						PixelValue =0;

						// 내부 Pixel Data 축출 
// 						for(int n=CrackPoint[CrackCount].Rect.top ; n<CrackPoint[CrackCount].Rect.bottom; n++){
// 							for(int m=CrackPoint[CrackCount].Rect.left; m<CrackPoint[CrackCount].Rect.right; m++){
// 								PixelValue = IElement(m,n);
// 								if(PixelValue < CrackThresHold) PixelCount++;
// 							}
// 						}

						CrackPoint[CrackCount].Round = PixelCount;
						CrackPoint[CrackCount].P.x    =(float)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterX() - CrackPoint[CrackCount].Width/2 ) +LSP.x+2   );
						CrackPoint[CrackCount].P.y    =(float)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - CrackPoint[CrackCount].Height/2)+ImageHeight+LSP.y);

						// Merge 위해서 데이터 필요함 
						CrackPoint[CrackCount].Rect.top    =(long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - CrackPoint[CrackCount].Height/2) +ImageHeight+LSP.y);
						CrackPoint[CrackCount].Rect.bottom =(long)(CrackPoint[CrackCount].Rect.top + CrackPoint[CrackCount].Height);
						CrackCount++;
					}
				}
			}
			// Top Inspection
			// Chipping Inspection
// 			if(CrackThresHold!=0){
// 				BlobCount =0;
// 				EasyImage::Threshold(GImage,&DefectImg, CrackThresHold);
// 				DefectROI.Attach(&DefectImg);
// 				CodeImageSelection.SetFeretAngle(0.00f);
// 				CodeImageEncoder.GetGrayscaleSingleThresholdSegmenter().SetWhiteLayerEncoded(false);
// 				CodeImageEncoder.GetGrayscaleSingleThresholdSegmenter().SetBlackLayerEncoded(true );
// 				IAddress = DefectImg.GetImagePtr(); // 내부 Pixel Data 추출 목적으로 필요함 
// 
// 				//TOP 검사시 검정색 연마라인으로 인해서 오버킬 발생함 TopBtmOffset값을 추가로 적용함 
// 				DefectROI.SetPlacement((int)(FLTTPoint.x+2),(int)(FLTTPoint.y+IgnoreOffset),TopWidth , FTopHeight);
// 				if((FLTTPoint.x+2) <=0          || (FLTTPoint.y+IgnoreOffset)<0           || TopWidth<=0          || FTopHeight<=0   ) return false; // ROI 영역 설정시 0        작을경우 
// 				if((FLTTPoint.x+2) >=ImageWidth || (FLTTPoint.y+IgnoreOffset)>ImgH        || TopWidth>=ImageWidth || FTopHeight> ImgH) return false; // ROI 영역 설정시 ImageWidth 클경우 
// 
// 				if(FChippingMinWidth==0 || FChippingMinHeight==0){ FChippingMinWidth=2; FChippingMinHeight=2;}
// 
// 				// Euresys 검사 진행
// 				CodeImageSelection.Clear();
// 				CodeImageEncoder.Encode(DefectROI,CodeImage);
// 				CodeImageSelection.Clear();
// 				CodeImageSelection.AddObjects(CodeImage);
// 
// 				// Blob 필터링 
// 				CodeImageSelection.RemoveUsingFloatFeature(EFeature_BoundingBoxWidth ,FChippingMinWidth , FChippingMaxWidth  , EDoubleThresholdMode_Outside);
// 				CodeImageSelection.RemoveUsingFloatFeature(EFeature_BoundingBoxHeight,FChippingMinHeight, FChippingMaxHeight , EDoubleThresholdMode_Outside);
// 				if(IsRemoveBlob) CodeImageSelection.RemoveUsingIntegerFeature(EFeature_LeftLimit        ,0       , 3         , EDoubleThresholdMode_Outside);
// 
// 				BlobCount = CodeImageSelection.GetElementCount();
// 				CodeImageSelection.Sort(EFeature_TopLimit,ESortDirection_Ascending);
// 
// 				if(BlobCount!=0){
// 					for(int k=0; k<BlobCount; k++){
// 						if(CrackCount>=MAX_DEFECT_POINT) break; 
// 						CrackPoint[CrackCount].Width  =  CodeImageSelection.GetElement(k).GetBoundingBoxWidth() ;
// 						CrackPoint[CrackCount].Height =  CodeImageSelection.GetElement(k).GetBoundingBoxHeight();
// 
// 						CrackPoint[CrackCount].Rect.left   =(long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterX() - CrackPoint[CrackCount].Width/2 ) +FLTTPoint.x+2);
// 						CrackPoint[CrackCount].Rect.top    =(long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - CrackPoint[CrackCount].Height/2) +FLTTPoint.y+IgnoreOffset);
// 						CrackPoint[CrackCount].Rect.right  =(long)(CrackPoint[CrackCount].Rect.left+ CrackPoint[CrackCount].Width );
// 						CrackPoint[CrackCount].Rect.bottom =(long)(CrackPoint[CrackCount].Rect.top + CrackPoint[CrackCount].Height);
// 						PixelCount =0;
// 						PixelValue =0;
// 
// 						// 내부 Pixel Data 축출 
// // 						for(int n=CrackPoint[CrackCount].Rect.top ; n<CrackPoint[CrackCount].Rect.bottom; n++){
// // 							for(int m=CrackPoint[CrackCount].Rect.left; m<CrackPoint[CrackCount].Rect.right; m++){
// // 								PixelValue = IElement(m,n);
// // 								if(PixelValue < CrackThresHold) PixelCount++;
// // 							}
// // 						}
// 
// 						CrackPoint[CrackCount].Round = PixelCount;
// 						CrackPoint[CrackCount].P.x    =(float)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterX() - CrackPoint[CrackCount].Width/2 ) +FLTTPoint.x+2   );
// 						CrackPoint[CrackCount].P.y    =(float)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - CrackPoint[CrackCount].Height/2)+ImageHeight+FLTTPoint.y+2);
// 
// 						// Merge 위해서 데이터 필요함 
// 						CrackPoint[CrackCount].Rect.top    =(long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - CrackPoint[CrackCount].Height/2) +ImageHeight+FLTTPoint.y+2);
// 						CrackPoint[CrackCount].Rect.bottom =(long)(CrackPoint[CrackCount].Rect.top + CrackPoint[CrackCount].Height);
// 						CrackCount++;
// 					}
// 				}
// 			}
			// 외곽라인에서 Mark까지의 거리 산출 
			if     (Line[waLeftWall].FP0.x >Line[waLeftWall].FP1.x) LDistance = (MarkStrPos.x - (Line[waLeftWall].FP1.x+(Line[waLeftWall].FP0.x - Line[waLeftWall].FP1.x)/2));
			else if(Line[waLeftWall].FP0.x==Line[waLeftWall].FP1.x) LDistance = (MarkStrPos.x -  Line[waLeftWall].FP0.x)                                                     ;
			else                                                    LDistance = (MarkStrPos.x - (Line[waLeftWall].FP0.x+(Line[waLeftWall].FP1.x - Line[waLeftWall].FP0.x)/2)); 
		}
		else {
			// Left Inspection
			// Chipping Inspection
			if(CrackThresHold!=0){
				BlobCount =0;
				EasyImage::Threshold(GImage,&DefectImg, CrackThresHold);
				DefectROI.Attach(&DefectImg);
				CodeImageSelection.SetFeretAngle(0.00f);
				CodeImageEncoder.GetGrayscaleSingleThresholdSegmenter().SetWhiteLayerEncoded(false);
				CodeImageEncoder.GetGrayscaleSingleThresholdSegmenter().SetBlackLayerEncoded(true );
				IAddress = DefectImg.GetImagePtr(); // 내부 Pixel Data 추출 목적으로 필요함 

				// 				DefectROI.SetPlacement(-100,-100, -100, -100);
				DefectROI.SetPlacement((int)(LSP.x+2),(int)(LSP.y), FLeftWidth, LeftHeight);
				if((LSP.x+2) <=0          || LSP.y<0     || FLeftWidth<=0          || LeftHeight<=0   ) return false; // ROI 영역 설정시 0        작을경우 
				if((LSP.x+2) >=ImageWidth || LSP.y> ImgH || FLeftWidth>=ImageWidth || LeftHeight> ImgH) return false; // ROI 영역 설정시 ImageWidth 클경우 

				if(FChippingMinWidth==0 || FChippingMinHeight==0){ FChippingMinWidth=2; FChippingMinHeight=2;}

				// Euresys 검사 진행
				CodeImageSelection.Clear();
				CodeImageEncoder.Encode(DefectROI,CodeImage);
				CodeImageSelection.Clear();
				CodeImageSelection.AddObjects(CodeImage);

				// Blob 필터링 
				CodeImageSelection.RemoveUsingFloatFeature(EFeature_BoundingBoxWidth ,FChippingMinWidth , FChippingMaxWidth  , EDoubleThresholdMode_Outside);
				CodeImageSelection.RemoveUsingFloatFeature(EFeature_BoundingBoxHeight,FChippingMinHeight, FChippingMaxHeight , EDoubleThresholdMode_Outside);
				if(IsRemoveBlob) CodeImageSelection.RemoveUsingIntegerFeature(EFeature_LeftLimit        ,0       , 3         , EDoubleThresholdMode_Outside);

				BlobCount = CodeImageSelection.GetElementCount();
				CodeImageSelection.Sort(EFeature_TopLimit,ESortDirection_Ascending);

				if(BlobCount!=0){
					for(int k=0; k<BlobCount; k++){
						if(CrackCount>=MAX_DEFECT_POINT) break; 
						CrackPoint[CrackCount].Width  =  CodeImageSelection.GetElement(k).GetBoundingBoxWidth() ;
						CrackPoint[CrackCount].Height =  CodeImageSelection.GetElement(k).GetBoundingBoxHeight();

						CrackPoint[CrackCount].Rect.left   =(long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterX() - CrackPoint[CrackCount].Width/2 ) +LSP.x+2);
						CrackPoint[CrackCount].Rect.top    =(long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - CrackPoint[CrackCount].Height/2) +LSP.y  );
						CrackPoint[CrackCount].Rect.right  =(long)(CrackPoint[CrackCount].Rect.left+ CrackPoint[CrackCount].Width );
						CrackPoint[CrackCount].Rect.bottom =(long)(CrackPoint[CrackCount].Rect.top + CrackPoint[CrackCount].Height);
						PixelCount =0;
						PixelValue =0;

						// 내부 Pixel Data 축출 
						// 						for(int n=CrackPoint[CrackCount].Rect.top ; n<CrackPoint[CrackCount].Rect.bottom; n++){
						// 							for(int m=CrackPoint[CrackCount].Rect.left; m<CrackPoint[CrackCount].Rect.right; m++){
						// 								PixelValue = IElement(m,n);
						// 								if(PixelValue < CrackThresHold) PixelCount++;
						// 							}
						// 						}

						CrackPoint[CrackCount].Round = PixelCount;
						CrackPoint[CrackCount].P.x    =(float)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterX() - CrackPoint[CrackCount].Width/2 ) +LSP.x+2   );
						CrackPoint[CrackCount].P.y    =(float)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - CrackPoint[CrackCount].Height/2)+ImageHeight+LSP.y);

						// Merge 위해서 데이터 필요함 
						CrackPoint[CrackCount].Rect.top    =(long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - CrackPoint[CrackCount].Height/2) +ImageHeight+LSP.y);
						CrackPoint[CrackCount].Rect.bottom =(long)(CrackPoint[CrackCount].Rect.top + CrackPoint[CrackCount].Height);
						CrackCount++;
					}
				}
			}
			// Top Inspection
			// Chipping Inspection
			// 			if(CrackThresHold!=0){
			// 				BlobCount =0;
			// 				EasyImage::Threshold(GImage,&DefectImg, CrackThresHold);
			// 				DefectROI.Attach(&DefectImg);
			// 				CodeImageSelection.SetFeretAngle(0.00f);
			// 				CodeImageEncoder.GetGrayscaleSingleThresholdSegmenter().SetWhiteLayerEncoded(false);
			// 				CodeImageEncoder.GetGrayscaleSingleThresholdSegmenter().SetBlackLayerEncoded(true );
			// 				IAddress = DefectImg.GetImagePtr(); // 내부 Pixel Data 추출 목적으로 필요함 
			// 
			// 				//TOP 검사시 검정색 연마라인으로 인해서 오버킬 발생함 TopBtmOffset값을 추가로 적용함 
			// 				DefectROI.SetPlacement((int)(FLTTPoint.x+2),(int)(FLTTPoint.y+IgnoreOffset),TopWidth , FTopHeight);
			// 				if((FLTTPoint.x+2) <=0          || (FLTTPoint.y+IgnoreOffset)<0           || TopWidth<=0          || FTopHeight<=0   ) return false; // ROI 영역 설정시 0        작을경우 
			// 				if((FLTTPoint.x+2) >=ImageWidth || (FLTTPoint.y+IgnoreOffset)>ImgH        || TopWidth>=ImageWidth || FTopHeight> ImgH) return false; // ROI 영역 설정시 ImageWidth 클경우 
			// 
			// 				if(FChippingMinWidth==0 || FChippingMinHeight==0){ FChippingMinWidth=2; FChippingMinHeight=2;}
			// 
			// 				// Euresys 검사 진행
			// 				CodeImageSelection.Clear();
			// 				CodeImageEncoder.Encode(DefectROI,CodeImage);
			// 				CodeImageSelection.Clear();
			// 				CodeImageSelection.AddObjects(CodeImage);
			// 
			// 				// Blob 필터링 
			// 				CodeImageSelection.RemoveUsingFloatFeature(EFeature_BoundingBoxWidth ,FChippingMinWidth , FChippingMaxWidth  , EDoubleThresholdMode_Outside);
			// 				CodeImageSelection.RemoveUsingFloatFeature(EFeature_BoundingBoxHeight,FChippingMinHeight, FChippingMaxHeight , EDoubleThresholdMode_Outside);
			// 				if(IsRemoveBlob) CodeImageSelection.RemoveUsingIntegerFeature(EFeature_LeftLimit        ,0       , 3         , EDoubleThresholdMode_Outside);
			// 
			// 				BlobCount = CodeImageSelection.GetElementCount();
			// 				CodeImageSelection.Sort(EFeature_TopLimit,ESortDirection_Ascending);
			// 
			// 				if(BlobCount!=0){
			// 					for(int k=0; k<BlobCount; k++){
			// 						if(CrackCount>=MAX_DEFECT_POINT) break; 
			// 						CrackPoint[CrackCount].Width  =  CodeImageSelection.GetElement(k).GetBoundingBoxWidth() ;
			// 						CrackPoint[CrackCount].Height =  CodeImageSelection.GetElement(k).GetBoundingBoxHeight();
			// 
			// 						CrackPoint[CrackCount].Rect.left   =(long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterX() - CrackPoint[CrackCount].Width/2 ) +FLTTPoint.x+2);
			// 						CrackPoint[CrackCount].Rect.top    =(long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - CrackPoint[CrackCount].Height/2) +FLTTPoint.y+IgnoreOffset);
			// 						CrackPoint[CrackCount].Rect.right  =(long)(CrackPoint[CrackCount].Rect.left+ CrackPoint[CrackCount].Width );
			// 						CrackPoint[CrackCount].Rect.bottom =(long)(CrackPoint[CrackCount].Rect.top + CrackPoint[CrackCount].Height);
			// 						PixelCount =0;
			// 						PixelValue =0;
			// 
			// 						// 내부 Pixel Data 축출 
			// // 						for(int n=CrackPoint[CrackCount].Rect.top ; n<CrackPoint[CrackCount].Rect.bottom; n++){
			// // 							for(int m=CrackPoint[CrackCount].Rect.left; m<CrackPoint[CrackCount].Rect.right; m++){
			// // 								PixelValue = IElement(m,n);
			// // 								if(PixelValue < CrackThresHold) PixelCount++;
			// // 							}
			// // 						}
			// 
			// 						CrackPoint[CrackCount].Round = PixelCount;
			// 						CrackPoint[CrackCount].P.x    =(float)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterX() - CrackPoint[CrackCount].Width/2 ) +FLTTPoint.x+2   );
			// 						CrackPoint[CrackCount].P.y    =(float)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - CrackPoint[CrackCount].Height/2)+ImageHeight+FLTTPoint.y+2);
			// 
			// 						// Merge 위해서 데이터 필요함 
			// 						CrackPoint[CrackCount].Rect.top    =(long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - CrackPoint[CrackCount].Height/2) +ImageHeight+FLTTPoint.y+2);
			// 						CrackPoint[CrackCount].Rect.bottom =(long)(CrackPoint[CrackCount].Rect.top + CrackPoint[CrackCount].Height);
			// 						CrackCount++;
			// 					}
			// 				}
			// 			}
			// 외곽라인에서 Mark까지의 거리 산출 
			if     (Line[waLeftWall].FP0.x >Line[waLeftWall].FP1.x) LDistance = (MarkStrPos.x - (Line[waLeftWall].FP1.x+(Line[waLeftWall].FP0.x - Line[waLeftWall].FP1.x)/2));
			else if(Line[waLeftWall].FP0.x==Line[waLeftWall].FP1.x) LDistance = (MarkStrPos.x -  Line[waLeftWall].FP0.x)                                                     ;
			else                                                    LDistance = (MarkStrPos.x - (Line[waLeftWall].FP0.x+(Line[waLeftWall].FP1.x - Line[waLeftWall].FP0.x)/2)); 
		}
		Index = 0;
		return true;

			// BOE shRectSL 검사 시퀀스 
	case 8 :

		// Left Inspection
		// Chipping Inspection
		if(CrackThresHold!=0){
			BlobCount =0;
			EasyImage::Threshold(GImage,&DefectImg, CrackThresHold);
			DefectROI.Attach(&DefectImg);
			CodeImageSelection.SetFeretAngle(0.00f);
			CodeImageEncoder.GetGrayscaleSingleThresholdSegmenter().SetWhiteLayerEncoded(false);
			CodeImageEncoder.GetGrayscaleSingleThresholdSegmenter().SetBlackLayerEncoded(true );
			IAddress = DefectImg.GetImagePtr();

			DefectROI.SetPlacement((int)(LSP.x+2),(int)(LSP.y), FLeftWidth, LeftHeight);
			if((LSP.x+2) <=0          || LSP.y<0     || FLeftWidth<=0          || LeftHeight<=0   ) return false; // ROI 영역 설정시 0        작을경우 
			if((LSP.x+2) >=ImageWidth || LSP.y> ImgH || FLeftWidth>=ImageWidth || LeftHeight> ImgH) return false; // ROI 영역 설정시 ImageWidth 클경우 

			if(FChippingMinWidth==0 || FChippingMinHeight==0){ FChippingMinWidth=2; FChippingMinHeight=2;}

			// Euresys 검사 진행
			CodeImageSelection.Clear();
			CodeImageEncoder.Encode(DefectROI,CodeImage);
			CodeImageSelection.Clear();
			CodeImageSelection.AddObjects(CodeImage);

			BlobCount = CodeImageSelection.GetElementCount();

			// Blob 필터링 
			CodeImageSelection.RemoveUsingFloatFeature(EFeature_BoundingBoxWidth ,FChippingMinWidth , FChippingMaxWidth  , EDoubleThresholdMode_Outside);
			CodeImageSelection.RemoveUsingFloatFeature(EFeature_BoundingBoxHeight,FChippingMinHeight, FChippingMaxHeight , EDoubleThresholdMode_Outside);
			if(IsRemoveBlob) CodeImageSelection.RemoveUsingIntegerFeature(EFeature_LeftLimit        ,0       , 3         , EDoubleThresholdMode_Outside);

			BlobCount = CodeImageSelection.GetElementCount();
			CodeImageSelection.Sort(EFeature_TopLimit,ESortDirection_Ascending);

			if(BlobCount!=0){
				for(int k=0; k<BlobCount; k++){
					if(CrackCount>=MAX_DEFECT_POINT) break; 
					CrackPoint[CrackCount].Width  =  CodeImageSelection.GetElement(k).GetBoundingBoxWidth() ;
					CrackPoint[CrackCount].Height =  CodeImageSelection.GetElement(k).GetBoundingBoxHeight();

					CrackPoint[CrackCount].Rect.left   =(long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterX() - CrackPoint[CrackCount].Width/2 ) +LSP.x+2);
					CrackPoint[CrackCount].Rect.top    =(long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - CrackPoint[CrackCount].Height/2) +LSP.y  );
					CrackPoint[CrackCount].Rect.right  =(long)(CrackPoint[CrackCount].Rect.left+ CrackPoint[CrackCount].Width );
					CrackPoint[CrackCount].Rect.bottom =(long)(CrackPoint[CrackCount].Rect.top + CrackPoint[CrackCount].Height);
					PixelCount =0;
					PixelValue =0;

					// 내부 Pixel Data 축출 
// 					for(int n=CrackPoint[CrackCount].Rect.top ; n<CrackPoint[CrackCount].Rect.bottom; n++){
// 						for(int m=CrackPoint[CrackCount].Rect.left; m<CrackPoint[CrackCount].Rect.right; m++){
// 							PixelValue = IElement(m,n);
// 							if(PixelValue < CrackThresHold) PixelCount++;
// 						}
// 					}

					CrackPoint[CrackCount].Round = PixelCount;
					CrackPoint[CrackCount].P.x    =(float)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterX() - CrackPoint[CrackCount].Width/2 ) +LSP.x+2   );
					CrackPoint[CrackCount].P.y    =(float)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - CrackPoint[CrackCount].Height/2)+ImageHeight+LSP.y);

					// Merge 위해서 데이터 필요함 
					CrackPoint[CrackCount].Rect.top    =(long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - CrackPoint[CrackCount].Height/2) +ImageHeight+LSP.y);
					CrackPoint[CrackCount].Rect.bottom =(long)(CrackPoint[CrackCount].Rect.top + CrackPoint[CrackCount].Height);
					CrackCount++;
				}
			}
		}
		// Left Inspection
		// Broken Inspection
		if(BrokenThresHold!=0){
			BlobCount =0;
			EasyImage::Threshold(GImage,&DefectImg, BrokenThresHold);
			DefectROI.Attach(&DefectImg);
			CodeImageSelection.SetFeretAngle(0.00f);
			CodeImageEncoder.GetGrayscaleSingleThresholdSegmenter().SetWhiteLayerEncoded(false);
			CodeImageEncoder.GetGrayscaleSingleThresholdSegmenter().SetBlackLayerEncoded(true );
			IAddress = DefectImg.GetImagePtr();

			DefectROI.SetPlacement((int)(LSP.x+2),(int)(LSP.y), FLeftWidth, LeftHeight);
			if((LSP.x+2) <=0          || LSP.y<0     || FLeftWidth<=0          || LeftHeight<=0   ) return false; // ROI 영역 설정시 0        작을경우 
			if((LSP.x+2) >=ImageWidth || LSP.y> ImgH || FLeftWidth>=ImageWidth || LeftHeight> ImgH) return false; // ROI 영역 설정시 ImageWidth 클경우 

			if(FBrokenMinWidth==0 || FBrokenMinHeight==0){ FBrokenMinWidth=2; FBrokenMinHeight=2;}

			// Euresys 검사 진행
			CodeImageSelection.Clear();
			CodeImageEncoder.Encode(DefectROI,CodeImage);
			CodeImageSelection.Clear();
			CodeImageSelection.AddObjects(CodeImage);

			// Blob 필터링 
			CodeImageSelection.RemoveUsingFloatFeature(EFeature_BoundingBoxWidth ,FBrokenMinWidth , FBrokenMaxWidth  , EDoubleThresholdMode_Outside);
			CodeImageSelection.RemoveUsingFloatFeature(EFeature_BoundingBoxHeight,FBrokenMinHeight, FBrokenMaxHeight , EDoubleThresholdMode_Outside);
			if(IsRemoveBlob) CodeImageSelection.RemoveUsingIntegerFeature(EFeature_LeftLimit        ,0       , 3     , EDoubleThresholdMode_Outside);

			BlobCount = CodeImageSelection.GetElementCount();
			CodeImageSelection.Sort(EFeature_TopLimit,ESortDirection_Ascending);

			if(BlobCount!=0){
				for(int k=0; k<BlobCount; k++){
					if(CrackCount>=MAX_DEFECT_POINT) break; 
					BrokenPoint[BrokenCount].Width  =  CodeImageSelection.GetElement(k).GetBoundingBoxWidth() ;
					BrokenPoint[BrokenCount].Height =  CodeImageSelection.GetElement(k).GetBoundingBoxHeight();

					BrokenPoint[BrokenCount].Rect.left   =(long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterX() - BrokenPoint[BrokenCount].Width/2 ) +LSP.x+2);
					BrokenPoint[BrokenCount].Rect.top    =(long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - BrokenPoint[BrokenCount].Height/2) +LSP.y  );
					BrokenPoint[BrokenCount].Rect.right  =(long)(BrokenPoint[BrokenCount].Rect.left+ BrokenPoint[BrokenCount].Width );
					BrokenPoint[BrokenCount].Rect.bottom =(long)(BrokenPoint[BrokenCount].Rect.top + BrokenPoint[BrokenCount].Height);
					PixelCount =0;
					PixelValue =0;

					// 내부 Pixel Data 축출 
// 					for(int n=BrokenPoint[BrokenCount].Rect.top ; n<BrokenPoint[BrokenCount].Rect.bottom; n++){
// 						for(int m=BrokenPoint[BrokenCount].Rect.left; m<BrokenPoint[BrokenCount].Rect.right; m++){
// 							PixelValue = IElement(m,n);
// 							if(PixelValue < BrokenThresHold) PixelCount++;
// 						}
// 					}

					BrokenPoint[BrokenCount].Round = PixelCount;
					BrokenPoint[BrokenCount].P.x    =(float)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterX() - BrokenPoint[BrokenCount].Width/2 ) +LSP.x+2   );
					BrokenPoint[BrokenCount].P.y    =(float)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - BrokenPoint[BrokenCount].Height/2)+ImageHeight+LSP.y);

					// Merge 위해서 데이터 필요함 
					BrokenPoint[BrokenCount].Rect.top    =(long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - BrokenPoint[BrokenCount].Height/2) +ImageHeight+LSP.y);
					BrokenPoint[BrokenCount].Rect.bottom =(long)(BrokenPoint[BrokenCount].Rect.top + BrokenPoint[BrokenCount].Height);
					BrokenCount++;
				}
			}
		}
		// 외곽라인에서 Mark까지의 거리 산출 
		if     (Line[waLeftWall].FP0.x >Line[waLeftWall].FP1.x) LDistance = (MarkStrPos.x - (Line[waLeftWall].FP1.x+(Line[waLeftWall].FP0.x - Line[waLeftWall].FP1.x)/2));
		else if(Line[waLeftWall].FP0.x==Line[waLeftWall].FP1.x) LDistance = (MarkStrPos.x -  Line[waLeftWall].FP0.x)                                                     ;
		else                                                    LDistance = (MarkStrPos.x - (Line[waLeftWall].FP0.x+(Line[waLeftWall].FP1.x - Line[waLeftWall].FP0.x)/2)); 

		Index = 0;
		return true;

		// BOE shRectCL 검사 시퀀스 
	case 9 :
		if(IsCornerBtm){
			if(LBDx!=0 && LBDy!=0) {
				// Corner 3
				if(C3EdgeCount!=0){
					CornerCount=0;
					for(int k=0; k<C3EdgeCount; k++){
						if(C3Point[k].y <FLBLPoint.y+1) continue;
						Dis = Math.GetLengthFrLineToPoint(FLBLPoint, FLBBPoint, C3Point[k]);
						C3Corner[CornerCount].Dv   = Dis         ;
						C3Corner[CornerCount].P.x  = C3Point[k].x;
						C3Corner[CornerCount].P.y  = C3Point[k].y;
						CornerCount++;
					}
					C3Count = GetSize(C3Corner, C3DefectPoint, CornerCount, 5);
				}
			}
			// Left Inspection
			// Chipping Inspection
			if(CrackThresHold!=0){
				BlobCount =0;
				EasyImage::Threshold(GImage,&DefectImg, CrackThresHold);
				DefectROI.Attach(&DefectImg);
				CodeImageSelection.SetFeretAngle(0.00f);
				CodeImageEncoder.GetGrayscaleSingleThresholdSegmenter().SetWhiteLayerEncoded(false);
				CodeImageEncoder.GetGrayscaleSingleThresholdSegmenter().SetBlackLayerEncoded(true );
				IAddress = DefectImg.GetImagePtr(); // 내부 Pixel Data 추출 목적으로 필요함 

				DefectROI.SetPlacement((int)(LSP.x+2),(int)(LSP.y), FLeftWidth, LeftHeight);
				if((LSP.x+2) <=0          || LSP.y<0    || FLeftWidth<=0          || LeftHeight<=0   ) return false; // ROI 영역 설정시 0        작을경우 
				if((LSP.x+2) >=ImageWidth || LSP.y>ImgH || FLeftWidth>=ImageWidth || LeftHeight> ImgH) return false; // ROI 영역 설정시 ImageWidth 클경우 

				if(FChippingMinWidth==0 || FChippingMinHeight==0){ FChippingMinWidth=2; FChippingMinHeight=2;}

				// Euresys 검사 진행
				CodeImageSelection.Clear();
				CodeImageEncoder.Encode(DefectROI,CodeImage);
				CodeImageSelection.Clear();
				CodeImageSelection.AddObjects(CodeImage);

				// Blob 필터링 
				CodeImageSelection.RemoveUsingFloatFeature(EFeature_BoundingBoxWidth ,FChippingMinWidth , FChippingMaxWidth  , EDoubleThresholdMode_Outside);
				CodeImageSelection.RemoveUsingFloatFeature(EFeature_BoundingBoxHeight,FChippingMinHeight, FChippingMaxHeight , EDoubleThresholdMode_Outside);
				if(IsRemoveBlob) CodeImageSelection.RemoveUsingIntegerFeature(EFeature_LeftLimit        ,0       , 3         , EDoubleThresholdMode_Outside);

				BlobCount = CodeImageSelection.GetElementCount();
				CodeImageSelection.Sort(EFeature_TopLimit,ESortDirection_Ascending);

				if(BlobCount!=0){
					for(int k=0; k<BlobCount; k++){
						if(CrackCount>=MAX_DEFECT_POINT) break; 
						CrackPoint[CrackCount].Width  =  CodeImageSelection.GetElement(k).GetBoundingBoxWidth() ;
						CrackPoint[CrackCount].Height =  CodeImageSelection.GetElement(k).GetBoundingBoxHeight();

						CrackPoint[CrackCount].Rect.left   =(long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterX() - CrackPoint[CrackCount].Width/2 ) +LSP.x+2);
						CrackPoint[CrackCount].Rect.top    =(long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - CrackPoint[CrackCount].Height/2) +LSP.y  );
						CrackPoint[CrackCount].Rect.right  =(long)(CrackPoint[CrackCount].Rect.left+ CrackPoint[CrackCount].Width );
						CrackPoint[CrackCount].Rect.bottom =(long)(CrackPoint[CrackCount].Rect.top + CrackPoint[CrackCount].Height);
						PixelCount =0;
						PixelValue =0;

						// 내부 Pixel Data 축출 
// 						for(int n=CrackPoint[CrackCount].Rect.top ; n<CrackPoint[CrackCount].Rect.bottom; n++){
// 							for(int m=CrackPoint[CrackCount].Rect.left; m<CrackPoint[CrackCount].Rect.right; m++){
// 								PixelValue = IElement(m,n);
// 								if(PixelValue < CrackThresHold) PixelCount++;
// 							}
// 						}

						CrackPoint[CrackCount].Round = PixelCount;
						CrackPoint[CrackCount].P.x    =(float)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterX() - CrackPoint[CrackCount].Width/2 ) +LSP.x+2   );
						CrackPoint[CrackCount].P.y    =(float)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - CrackPoint[CrackCount].Height/2)+ImageHeight+LSP.y);

						// Merge 위해서 데이터 필요함 
						CrackPoint[CrackCount].Rect.top    =(long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - CrackPoint[CrackCount].Height/2) +ImageHeight+LSP.y);
						CrackPoint[CrackCount].Rect.bottom =(long)(CrackPoint[CrackCount].Rect.top + CrackPoint[CrackCount].Height);
						CrackCount++;
					}
				}
			}

			// Btm Inspection
			// Chipping Inspection
// 			if(CrackThresHold!=0){
// 				BlobCount =0;
// 				EasyImage::Threshold(GImage,&DefectImg, CrackThresHold);
// 				DefectROI.Attach(&DefectImg);
// 				CodeImageSelection.SetFeretAngle(0.00f);
// 				CodeImageEncoder.GetGrayscaleSingleThresholdSegmenter().SetWhiteLayerEncoded(false);
// 				CodeImageEncoder.GetGrayscaleSingleThresholdSegmenter().SetBlackLayerEncoded(true );
// 				IAddress = DefectImg.GetImagePtr(); // 내부 Pixel Data 추출 목적으로 필요함 
// 
// 				DefectROI.SetPlacement((int)(FLBBPoint.x+2),(int)(FLBBPoint.y -FLBLPoint.y),BtmWidth , FBtmHeight);
// 				if((FLBBPoint.x+2) <=0          || (FLBBPoint.y -FLBLPoint.y)<0    || BtmWidth<=0          || FBtmHeight<=0   ) return false; // ROI 영역 설정시 0        작을경우 
// 				if((FLBBPoint.x+2) >=ImageWidth || (FLBBPoint.y -FLBLPoint.y)>ImgH || BtmWidth>=ImageWidth || FBtmHeight> ImgH) return false; // ROI 영역 설정시 ImageWidth 클경우 
// 
// 				if(FChippingMinWidth==0 || FChippingMinHeight==0){ FChippingMinWidth=2; FChippingMinHeight=2;}
// 
// 				// Euresys 검사 진행
// 				CodeImageSelection.Clear();
// 				CodeImageEncoder.Encode(DefectROI,CodeImage);
// 				CodeImageSelection.Clear();
// 				CodeImageSelection.AddObjects(CodeImage);
// 
// 				// Blob 필터링 
// 				CodeImageSelection.RemoveUsingFloatFeature(EFeature_BoundingBoxWidth ,FChippingMinWidth , FChippingMaxWidth  , EDoubleThresholdMode_Outside);
// 				CodeImageSelection.RemoveUsingFloatFeature(EFeature_BoundingBoxHeight,FChippingMinHeight, FChippingMaxHeight , EDoubleThresholdMode_Outside);
// 				if(IsRemoveBlob) CodeImageSelection.RemoveUsingIntegerFeature(EFeature_LeftLimit        ,0       , 3         , EDoubleThresholdMode_Outside);
// 
// 				BlobCount = CodeImageSelection.GetElementCount();
// 				CodeImageSelection.Sort(EFeature_TopLimit,ESortDirection_Ascending);
// 
// 				if(BlobCount!=0){
// 					for(int k=0; k<BlobCount; k++){
// 						if(CrackCount>=MAX_DEFECT_POINT) break; 
// 						CrackPoint[CrackCount].Width  =  CodeImageSelection.GetElement(k).GetBoundingBoxWidth() ;
// 						CrackPoint[CrackCount].Height =  CodeImageSelection.GetElement(k).GetBoundingBoxHeight();
// 
// 						CrackPoint[CrackCount].Rect.left   =(long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterX() - CrackPoint[CrackCount].Width/2 ) +FLBBPoint.x+2);
// 						CrackPoint[CrackCount].Rect.top    =(long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - CrackPoint[CrackCount].Height/2) +(FLBBPoint.y -FLBLPoint.y)  );
// 						CrackPoint[CrackCount].Rect.right  =(long)(CrackPoint[CrackCount].Rect.left+ CrackPoint[CrackCount].Width );
// 						CrackPoint[CrackCount].Rect.bottom =(long)(CrackPoint[CrackCount].Rect.top + CrackPoint[CrackCount].Height);
// 						PixelCount =0;
// 						PixelValue =0;
// 
// 						// 내부 Pixel Data 축출 
// // 						for(int n=CrackPoint[CrackCount].Rect.top ; n<CrackPoint[CrackCount].Rect.bottom; n++){
// // 							for(int m=CrackPoint[CrackCount].Rect.left; m<CrackPoint[CrackCount].Rect.right; m++){
// // 								PixelValue = IElement(m,n);
// // 								if(PixelValue < CrackThresHold) PixelCount++;
// // 							}
// // 						}
// 
// 						CrackPoint[CrackCount].Round = PixelCount;
// 						CrackPoint[CrackCount].P.x    =(float)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterX() - CrackPoint[CrackCount].Width/2 ) +FLBBPoint.x+2   );
// 						CrackPoint[CrackCount].P.y    =(float)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - CrackPoint[CrackCount].Height/2)+ImageHeight+(FLBBPoint.y -FLBLPoint.y));
// 
// 						// Merge 위해서 데이터 필요함 
// 						CrackPoint[CrackCount].Rect.top    =(long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - CrackPoint[CrackCount].Height/2) +ImageHeight+(FLBBPoint.y -FLBLPoint.y));
// 						CrackPoint[CrackCount].Rect.bottom =(long)(CrackPoint[CrackCount].Rect.top + CrackPoint[CrackCount].Height);
// 						CrackCount++;
// 					}
// 				}
// 			}
			// 외곽라인에서 Mark까지의 거리 산출 
			if     (Line[waLeftWall].FP0.x >Line[waLeftWall].FP1.x) LDistance = (MarkEndPos.x - (Line[waLeftWall].FP1.x+(Line[waLeftWall].FP0.x - Line[waLeftWall].FP1.x)/2));
			else if(Line[waLeftWall].FP0.x==Line[waLeftWall].FP1.x) LDistance = (MarkEndPos.x -  Line[waLeftWall].FP0.x)                                                     ;
			else                                                    LDistance = (MarkEndPos.x - (Line[waLeftWall].FP0.x+(Line[waLeftWall].FP1.x - Line[waLeftWall].FP0.x)/2)); 
		}
		else {
			// Left Inspection
			// Chipping Inspection
			if(CrackThresHold!=0){
				BlobCount =0;
				EasyImage::Threshold(GImage,&DefectImg, CrackThresHold);
				DefectROI.Attach(&DefectImg);
				CodeImageSelection.SetFeretAngle(0.00f);
				CodeImageEncoder.GetGrayscaleSingleThresholdSegmenter().SetWhiteLayerEncoded(false);
				CodeImageEncoder.GetGrayscaleSingleThresholdSegmenter().SetBlackLayerEncoded(true );
				IAddress = DefectImg.GetImagePtr(); // 내부 Pixel Data 추출 목적으로 필요함 

				DefectROI.SetPlacement((int)(LSP.x+2),(int)(LSP.y), FLeftWidth, LeftHeight);
				if((LSP.x+2) <=0          || LSP.y<0    || FLeftWidth<=0          || LeftHeight<=0   ) return false; // ROI 영역 설정시 0        작을경우 
				if((LSP.x+2) >=ImageWidth || LSP.y>ImgH || FLeftWidth>=ImageWidth || LeftHeight> ImgH) return false; // ROI 영역 설정시 ImageWidth 클경우 

				if(FChippingMinWidth==0 || FChippingMinHeight==0){ FChippingMinWidth=2; FChippingMinHeight=2;}

				// Euresys 검사 진행
				CodeImageSelection.Clear();
				CodeImageEncoder.Encode(DefectROI,CodeImage);
				CodeImageSelection.Clear();
				CodeImageSelection.AddObjects(CodeImage);

				// Blob 필터링 
				CodeImageSelection.RemoveUsingFloatFeature(EFeature_BoundingBoxWidth ,FChippingMinWidth , FChippingMaxWidth  , EDoubleThresholdMode_Outside);
				CodeImageSelection.RemoveUsingFloatFeature(EFeature_BoundingBoxHeight,FChippingMinHeight, FChippingMaxHeight , EDoubleThresholdMode_Outside);
				if(IsRemoveBlob) CodeImageSelection.RemoveUsingIntegerFeature(EFeature_LeftLimit        ,0       , 3         , EDoubleThresholdMode_Outside);

				BlobCount = CodeImageSelection.GetElementCount();
				CodeImageSelection.Sort(EFeature_TopLimit,ESortDirection_Ascending);

				if(BlobCount!=0){
					for(int k=0; k<BlobCount; k++){
						if(CrackCount>=MAX_DEFECT_POINT) break; 
						CrackPoint[CrackCount].Width  =  CodeImageSelection.GetElement(k).GetBoundingBoxWidth() ;
						CrackPoint[CrackCount].Height =  CodeImageSelection.GetElement(k).GetBoundingBoxHeight();

						CrackPoint[CrackCount].Rect.left   =(long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterX() - CrackPoint[CrackCount].Width/2 ) +LSP.x+2);
						CrackPoint[CrackCount].Rect.top    =(long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - CrackPoint[CrackCount].Height/2) +LSP.y  );
						CrackPoint[CrackCount].Rect.right  =(long)(CrackPoint[CrackCount].Rect.left+ CrackPoint[CrackCount].Width );
						CrackPoint[CrackCount].Rect.bottom =(long)(CrackPoint[CrackCount].Rect.top + CrackPoint[CrackCount].Height);
						PixelCount =0;
						PixelValue =0;

						// 내부 Pixel Data 축출 
						// 						for(int n=CrackPoint[CrackCount].Rect.top ; n<CrackPoint[CrackCount].Rect.bottom; n++){
						// 							for(int m=CrackPoint[CrackCount].Rect.left; m<CrackPoint[CrackCount].Rect.right; m++){
						// 								PixelValue = IElement(m,n);
						// 								if(PixelValue < CrackThresHold) PixelCount++;
						// 							}
						// 						}

						CrackPoint[CrackCount].Round = PixelCount;
						CrackPoint[CrackCount].P.x    =(float)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterX() - CrackPoint[CrackCount].Width/2 ) +LSP.x+2   );
						CrackPoint[CrackCount].P.y    =(float)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - CrackPoint[CrackCount].Height/2)+ImageHeight+LSP.y);

						// Merge 위해서 데이터 필요함 
						CrackPoint[CrackCount].Rect.top    =(long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - CrackPoint[CrackCount].Height/2) +ImageHeight+LSP.y);
						CrackPoint[CrackCount].Rect.bottom =(long)(CrackPoint[CrackCount].Rect.top + CrackPoint[CrackCount].Height);
						CrackCount++;
					}
				}
			}

			// Btm Inspection
			// Chipping Inspection
			// 			if(CrackThresHold!=0){
			// 				BlobCount =0;
			// 				EasyImage::Threshold(GImage,&DefectImg, CrackThresHold);
			// 				DefectROI.Attach(&DefectImg);
			// 				CodeImageSelection.SetFeretAngle(0.00f);
			// 				CodeImageEncoder.GetGrayscaleSingleThresholdSegmenter().SetWhiteLayerEncoded(false);
			// 				CodeImageEncoder.GetGrayscaleSingleThresholdSegmenter().SetBlackLayerEncoded(true );
			// 				IAddress = DefectImg.GetImagePtr(); // 내부 Pixel Data 추출 목적으로 필요함 
			// 
			// 				DefectROI.SetPlacement((int)(FLBBPoint.x+2),(int)(FLBBPoint.y -FLBLPoint.y),BtmWidth , FBtmHeight);
			// 				if((FLBBPoint.x+2) <=0          || (FLBBPoint.y -FLBLPoint.y)<0    || BtmWidth<=0          || FBtmHeight<=0   ) return false; // ROI 영역 설정시 0        작을경우 
			// 				if((FLBBPoint.x+2) >=ImageWidth || (FLBBPoint.y -FLBLPoint.y)>ImgH || BtmWidth>=ImageWidth || FBtmHeight> ImgH) return false; // ROI 영역 설정시 ImageWidth 클경우 
			// 
			// 				if(FChippingMinWidth==0 || FChippingMinHeight==0){ FChippingMinWidth=2; FChippingMinHeight=2;}
			// 
			// 				// Euresys 검사 진행
			// 				CodeImageSelection.Clear();
			// 				CodeImageEncoder.Encode(DefectROI,CodeImage);
			// 				CodeImageSelection.Clear();
			// 				CodeImageSelection.AddObjects(CodeImage);
			// 
			// 				// Blob 필터링 
			// 				CodeImageSelection.RemoveUsingFloatFeature(EFeature_BoundingBoxWidth ,FChippingMinWidth , FChippingMaxWidth  , EDoubleThresholdMode_Outside);
			// 				CodeImageSelection.RemoveUsingFloatFeature(EFeature_BoundingBoxHeight,FChippingMinHeight, FChippingMaxHeight , EDoubleThresholdMode_Outside);
			// 				if(IsRemoveBlob) CodeImageSelection.RemoveUsingIntegerFeature(EFeature_LeftLimit        ,0       , 3         , EDoubleThresholdMode_Outside);
			// 
			// 				BlobCount = CodeImageSelection.GetElementCount();
			// 				CodeImageSelection.Sort(EFeature_TopLimit,ESortDirection_Ascending);
			// 
			// 				if(BlobCount!=0){
			// 					for(int k=0; k<BlobCount; k++){
			// 						if(CrackCount>=MAX_DEFECT_POINT) break; 
			// 						CrackPoint[CrackCount].Width  =  CodeImageSelection.GetElement(k).GetBoundingBoxWidth() ;
			// 						CrackPoint[CrackCount].Height =  CodeImageSelection.GetElement(k).GetBoundingBoxHeight();
			// 
			// 						CrackPoint[CrackCount].Rect.left   =(long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterX() - CrackPoint[CrackCount].Width/2 ) +FLBBPoint.x+2);
			// 						CrackPoint[CrackCount].Rect.top    =(long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - CrackPoint[CrackCount].Height/2) +(FLBBPoint.y -FLBLPoint.y)  );
			// 						CrackPoint[CrackCount].Rect.right  =(long)(CrackPoint[CrackCount].Rect.left+ CrackPoint[CrackCount].Width );
			// 						CrackPoint[CrackCount].Rect.bottom =(long)(CrackPoint[CrackCount].Rect.top + CrackPoint[CrackCount].Height);
			// 						PixelCount =0;
			// 						PixelValue =0;
			// 
			// 						// 내부 Pixel Data 축출 
			// // 						for(int n=CrackPoint[CrackCount].Rect.top ; n<CrackPoint[CrackCount].Rect.bottom; n++){
			// // 							for(int m=CrackPoint[CrackCount].Rect.left; m<CrackPoint[CrackCount].Rect.right; m++){
			// // 								PixelValue = IElement(m,n);
			// // 								if(PixelValue < CrackThresHold) PixelCount++;
			// // 							}
			// // 						}
			// 
			// 						CrackPoint[CrackCount].Round = PixelCount;
			// 						CrackPoint[CrackCount].P.x    =(float)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterX() - CrackPoint[CrackCount].Width/2 ) +FLBBPoint.x+2   );
			// 						CrackPoint[CrackCount].P.y    =(float)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - CrackPoint[CrackCount].Height/2)+ImageHeight+(FLBBPoint.y -FLBLPoint.y));
			// 
			// 						// Merge 위해서 데이터 필요함 
			// 						CrackPoint[CrackCount].Rect.top    =(long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - CrackPoint[CrackCount].Height/2) +ImageHeight+(FLBBPoint.y -FLBLPoint.y));
			// 						CrackPoint[CrackCount].Rect.bottom =(long)(CrackPoint[CrackCount].Rect.top + CrackPoint[CrackCount].Height);
			// 						CrackCount++;
			// 					}
			// 				}
			// 			}
			// 외곽라인에서 Mark까지의 거리 산출 
			if     (Line[waLeftWall].FP0.x >Line[waLeftWall].FP1.x) LDistance = (MarkEndPos.x - (Line[waLeftWall].FP1.x+(Line[waLeftWall].FP0.x - Line[waLeftWall].FP1.x)/2));
			else if(Line[waLeftWall].FP0.x==Line[waLeftWall].FP1.x) LDistance = (MarkEndPos.x -  Line[waLeftWall].FP0.x)                                                     ;
			else                                                    LDistance = (MarkEndPos.x - (Line[waLeftWall].FP0.x+(Line[waLeftWall].FP1.x - Line[waLeftWall].FP0.x)/2)); 
		}
		// Mark1 to Mark2 Degree 산출 
		if(MarkStrPos.x!=0 && MarkStrPos.y!=0 && MarkEndPos.x!=0 && MarkEndPos.x!=0){
			MarkAng  = Math.GetDegree(MarkStrPos, MarkEndPos);
		}

		// Defect Merge 
		// Crack
		if(CrackCount!=0){
			bool IsxMg=false, IsyMg=false, IsInMg=false;
			CRect r1, r2;
			int sort =0;
			int tmpDDefectCount = CrackCount;

			for(int k=0; k<tmpDDefectCount; k++){
				if(CrackPoint[k].Rect.left==0 && CrackPoint[k].Rect.top==0 && CrackPoint[k].Rect.right==0 && CrackPoint[k].Rect.bottom==0) continue;

				for(int l=k+1; l<k+MgCount; l++ ){
					IsxMg = false; IsyMg = false;
					if(l>(tmpDDefectCount-1)) break;
					if(CrackPoint[l].Rect.left==0 && CrackPoint[l].Rect.top==0 && CrackPoint[k].Rect.right==0 && CrackPoint[k].Rect.bottom==0) continue;

					r1 = CrackPoint[k].Rect;
					r2 = CrackPoint[l].Rect; 

					register int HorDist   = (r1.left < r2.left) ?  r2.left - r1.right  : r1.left - r2.right ;
					register int VerDist   = (r1.top  < r2.top ) ?  r2.top  - r1.bottom : r1.top  - r2.bottom;
					IsInMg    = ((r1.left<=r2.left) && (r1.top<r2.top) && (r1.bottom>r2.bottom) && (r1.right >r2.right))? true: false;

					if(HorDist>xMerge && VerDist>yMerge && !IsInMg ) continue;

					IsxMg = (HorDist<xMerge) ? true: false;
					IsyMg = (VerDist<yMerge) ? true: false;

					if((IsxMg && IsyMg) || IsInMg){
						CrackPoint[k].Round    += CrackPoint[l].Round;
						CrackPoint[k].Rect      = OnMerge(CrackPoint[k].Rect, CrackPoint[l].Rect);
						CrackPoint[k].Width     = CrackPoint[k].Rect.right  - CrackPoint[k].Rect.left;
						CrackPoint[k].Height    = CrackPoint[k].Rect.bottom - CrackPoint[k].Rect.top ;
						CrackPoint[k].P.x       = (float)(CrackPoint[k].Rect.left); 
						CrackPoint[k].P.y       = (float)(CrackPoint[k].Rect.top ); 
						CrackPoint[l].Rect.left = CrackPoint[l].Rect.top = CrackPoint[l].Rect.right = CrackPoint[l].Rect.bottom =0;
						CrackCount--;
						k=-1;
						break;
					}
				}
			}
			for(int j=0; j<tmpDDefectCount; j++){
				if(CrackPoint[j].Rect.left==0 && CrackPoint[j].Rect.top==0 && CrackPoint[j].Rect.right==0 && CrackPoint[j].Rect.bottom==0) continue;
				CrackPoint[sort] = CrackPoint[j];
				sort++;
			}
		}

		// Defect Merge 
		// Burr or Remain
		if(BurrCount!=0){ 
			bool IsxMg=false, IsyMg=false, IsInMg=false;
			CRect r1, r2;
			int sort =0;
			int tmpBDefectCount = BurrCount;

			for(int k=0; k<tmpBDefectCount; k++){
				if(BurrPoint[k].Rect.left==0 && BurrPoint[k].Rect.top==0 && BurrPoint[k].Rect.right==0 && BurrPoint[k].Rect.bottom==0) continue;

				for(int l=k+1; l<k+MgCount; l++ ){
					IsxMg = false; IsyMg = false;
					if(l>(tmpBDefectCount-1)) break;
					if(BurrPoint[l].Rect.left==0 && BurrPoint[l].Rect.top==0 && BurrPoint[k].Rect.right==0 && BurrPoint[k].Rect.bottom==0) continue;

					r1 = BurrPoint[k].Rect;
					r2 = BurrPoint[l].Rect; 

					register int HorDist   = (r1.left < r2.left) ?  r2.left - r1.right  : r1.left - r2.right ;
					register int VerDist   = (r1.top  < r2.top ) ?  r2.top  - r1.bottom : r1.top  - r2.bottom;
					IsInMg    = ((r1.left<=r2.left) && (r1.top<r2.top) && (r1.bottom>r2.bottom) && (r1.right >r2.right))? true: false;

					if(HorDist>xMerge && VerDist>yMerge && !IsInMg ) continue;

					IsxMg = (HorDist<xMerge) ? true: false;
					IsyMg = (VerDist<yMerge) ? true: false;

					if((IsxMg && IsyMg) || IsInMg){
						BurrPoint[k].Round    += BurrPoint[l].Round;
						BurrPoint[k].Rect      = OnMerge(BurrPoint[k].Rect, BurrPoint[l].Rect);
						BurrPoint[k].Width     = BurrPoint[k].Rect.right  - BurrPoint[k].Rect.left;
						BurrPoint[k].Height    = BurrPoint[k].Rect.bottom - BurrPoint[k].Rect.top ;
						BurrPoint[k].P.x       = (float)(BurrPoint[k].Rect.left); 
						BurrPoint[k].P.y       = (float)(BurrPoint[k].Rect.top ); 
						BurrPoint[l].Rect.left = BurrPoint[l].Rect.top = BurrPoint[l].Rect.right = BurrPoint[l].Rect.bottom =0;
						BurrCount--;
						k=-1;
						break;
					}
				}
			}
			for(int j=0; j<tmpBDefectCount; j++){
				if(BurrPoint[j].Rect.left==0 && BurrPoint[j].Rect.top==0 && BurrPoint[j].Rect.right==0 && BurrPoint[j].Rect.bottom==0) continue;
				BurrPoint[sort] = BurrPoint[j];
				sort++;
			}
		}

		// Defect Merge 
		// Broken
		if(BrokenCount!=0){
			bool IsxMg=false, IsyMg=false, IsInMg=false;
			CRect r1, r2;
			int sort =0;
			int tmpBDefectCount = BrokenCount;

			for(int k=0; k<tmpBDefectCount; k++){
				if(BrokenPoint[k].Rect.left==0 && BrokenPoint[k].Rect.top==0 && BrokenPoint[k].Rect.right==0 && BrokenPoint[k].Rect.bottom==0) continue;

				for(int l=k+1; l<k+MgCount; l++ ){
					IsxMg = false; IsyMg = false;
					if(l>(tmpBDefectCount-1)) break;
					if(BrokenPoint[l].Rect.left==0 && BrokenPoint[l].Rect.top==0 && BrokenPoint[k].Rect.right==0 && BrokenPoint[k].Rect.bottom==0) continue;

					r1 = BrokenPoint[k].Rect;
					r2 = BrokenPoint[l].Rect; 

					register int HorDist   = (r1.left < r2.left) ?  r2.left - r1.right  : r1.left - r2.right ;
					register int VerDist   = (r1.top  < r2.top ) ?  r2.top  - r1.bottom : r1.top  - r2.bottom;
					IsInMg    = ((r1.left<=r2.left) && (r1.top<r2.top) && (r1.bottom>r2.bottom) && (r1.right >r2.right))? true: false;

					if(HorDist>xMerge && VerDist>yMerge && !IsInMg ) continue;

					IsxMg = (HorDist<xMerge) ? true: false;
					IsyMg = (VerDist<yMerge) ? true: false;

					if((IsxMg && IsyMg) || IsInMg){
						BrokenPoint[k].Round    += BrokenPoint[l].Round;
						BrokenPoint[k].Rect      = OnMerge(BrokenPoint[k].Rect, BrokenPoint[l].Rect);
						BrokenPoint[k].Width     = BrokenPoint[k].Rect.right  - BrokenPoint[k].Rect.left;
						BrokenPoint[k].Height    = BrokenPoint[k].Rect.bottom - BrokenPoint[k].Rect.top ;
						BrokenPoint[k].P.x       = (float)(BrokenPoint[k].Rect.left); 
						BrokenPoint[k].P.y       = (float)(BrokenPoint[k].Rect.top ); 
						BrokenPoint[l].Rect.left = BrokenPoint[l].Rect.top = BrokenPoint[l].Rect.right = BrokenPoint[l].Rect.bottom =0;
						BrokenCount--;
						k=-1;
						break;
					}
				}
			}
			for(int j=0; j<tmpBDefectCount; j++){
				if(BrokenPoint[j].Rect.left==0 && BrokenPoint[j].Rect.top==0 && BrokenPoint[j].Rect.right==0 && BrokenPoint[j].Rect.bottom==0) continue;
				BrokenPoint[sort] = BrokenPoint[j];
				sort++;
			}
		}
		Index = 0;
		return true;

		//NOTCH RectH : 모자모양 
		//------------------------------------------------------------------
	case 10 :

		// Corner Defect 검사 
		if(IsCornerTop){
			if(C1InEdgeCount!=0){
				CornerCount=0;
				for(int k=0; k<C1InEdgeCount; k++){
					if(C1InPoint[k].y>FLTLPoint.y-1) continue;
					Dis = Math.GetLengthFrLineToPoint(FLTLInPoint, FLTTInPoint, C1InPoint[k]);
					C1Corner[CornerCount].Dv   = Dis         ;
					C1Corner[CornerCount].P.x  = C1InPoint[k].x;
					C1Corner[CornerCount].P.y  = C1InPoint[k].y;
					CornerCount++;
					if(Dis>MaxDv) MaxDv = Dis;
					if(Dis<MinDv) MinDv = Dis;
				}
				if(LTCornerWidth>(LTCornerHeight*2)) C1Count = GetSize(C1Corner, C1DefectPoint, CornerCount, 10);
				else                                 C1Count = GetSize(C1Corner, C1DefectPoint, CornerCount, 5 );
			}

			MaxDv =0.0f;
			MinDv =10000.0f;

			// Corner 2 
			if(C2InEdgeCount!=0){
				CornerCount=0;
				for(int k=0; k<C2InEdgeCount; k++){
					if(C2InPoint[k].y>FRTRPoint.y-1) continue;
					Dis = Math.GetLengthFrLineToPoint(FRTTInPoint, FRTRInPoint, C2InPoint[k]);
					C2Corner[CornerCount].Dv   = Dis         ;
					C2Corner[CornerCount].P.x  = C2InPoint[k].x;
					C2Corner[CornerCount].P.y  = C2InPoint[k].y;
					CornerCount++;
					if(Dis>MaxDv) MaxDv = Dis;
					if(Dis<MinDv) MinDv = Dis;
				}
				if(RTCornerWidth >(RTCornerHeight*1.5)) C2Count = GetSize(C2Corner, C2DefectPoint, CornerCount, 10);
				else                                    C2Count = GetSize(C2Corner, C2DefectPoint, CornerCount, 5 );
				
			}
			//Side A
			////////////////////////////////////////////////////////////////////////////////////////////////
			// 			LogUnit.SetLog("CAP_Side_A_Start_CamId: %d, ImageHeight: %d ",CamId,ImageHeight);     
			// 		DefectROI.SetPlacement((int)(FLTTPoint.x+SideMargin), (int)((FLTTPoint.y+FRTTPoint.y)/2), TopWidth-(2*SideMargin), FTopHeight);
			DefectROI.SetPlacement((int)(FLTTInPoint.x+SideMargin), (int)((FLTTInPoint.y+FRTTInPoint.y)/2), TopWidth-(2*SideMargin), FTopHeight);
			if((FLTTInPoint.x+SideMargin) <=0          || ((FLTTInPoint.y+FRTTInPoint.y)/2)<=0           || TopWidth-(2*SideMargin)<=0          || FTopHeight<=0          )return false;
			if((FLTTInPoint.x+SideMargin) >=ImageWidth || ((FLTTInPoint.y+FRTTInPoint.y)/2)>TopLimitLine || TopWidth-(2*SideMargin)>=ImageWidth || FTopHeight>TopLimitLine) return false;
			if((FLTTInPoint.x+SideMargin)+(TopWidth-(2*SideMargin)) >=ImageWidth || ((FRTTInPoint.y+FRTTPoint.y)/2)+ FTopHeight>TopLimitLine) return false;
			// Blob 검사 
			CodeImageSelection.Clear();
			CodeImageEncoder.Encode(DefectROI,CodeImage);
			CodeImageSelection.Clear();
			CodeImageSelection.AddObjects(CodeImage);
			// Blob 필터링 
			CodeImageSelection.RemoveUsingFloatFeature  (EFeature_BoundingBoxWidth ,FMinWidth , FMaxWidth  , EDoubleThresholdMode_Outside);
			CodeImageSelection.RemoveUsingFloatFeature  (EFeature_BoundingBoxHeight,FMinHeight, FMaxHeight , EDoubleThresholdMode_Outside);
			CodeImageSelection.RemoveUsingIntegerFeature(EFeature_TopLimit         ,0         , 3          , EDoubleThresholdMode_Outside);

			BlobCount = CodeImageSelection.GetElementCount();
			CodeImageSelection.Sort(EFeature_LeftLimit ,ESortDirection_Ascending);

			if(BlobCount!=0){
				for(int k=0; k<BlobCount; k++){
					if(ACount>=MAX_DEFECT_POINT) break;
					ADefectPoint[ACount].Width  = CodeImageSelection.GetElement(k).GetBoundingBoxWidth() ;
					ADefectPoint[ACount].Height = CodeImageSelection.GetElement(k).GetBoundingBoxHeight();

					ADefectPoint[ACount].Rect.left   =(long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterX() - ADefectPoint[ACount].Width/2 ) +FLTTInPoint.x+SideMargin      );
					ADefectPoint[ACount].Rect.top    =(long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - ADefectPoint[ACount].Height/2) +((FLTTInPoint.y+FRTTInPoint.y)/2));
					ADefectPoint[ACount].Rect.right  =(long)(ADefectPoint[ACount].Rect.left+ ADefectPoint[ACount].Width );
					ADefectPoint[ACount].Rect.bottom =(long)(ADefectPoint[ACount].Rect.top + ADefectPoint[ACount].Height);
					PixelCount = 0;
					PixelValue = 0;

					// 내부 Pixel Data 축출 
					for(int n=ADefectPoint[ACount].Rect.top+1 ; n<ADefectPoint[ACount].Rect.bottom-1; n++){
						for(int m=ADefectPoint[ACount].Rect.left+1; m<ADefectPoint[ACount].Rect.right-1 ; m++){
							PixelValue = IElement(m,n);
							if(PixelValue < EnCapTopThresHold) PixelCount++;
						}
					}

					ADefectPoint[ACount].Round  = PixelCount;
					ADefectPoint[ACount].P.x    =(float)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterX() - ADefectPoint[ACount].Width/2 )+FLTTInPoint.x+SideMargin       );
					ADefectPoint[ACount].P.y    =(float)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - ADefectPoint[ACount].Height/2)+((FLTTInPoint.y+FRTTInPoint.y)/2));

					// Image Rotate 기준 좌표를 다시 Rotate한다 _ Display 목적 
					if(ImgDegree!=0.0f){
						ADefectPoint[ACount].P = Math.OnRotate(CenterPoint, ADefectPoint[ACount].P, (ImgDegree));
					}
					// Image Rotate 기준 좌표를 회전 이후에 ImageHeight값을 더하여 실제 좌표를 산출한다 
					ADefectPoint[ACount].P.y    =(float)(ADefectPoint[ACount].P.y+ImageHeight);

					//Merget위해서 필요함 
					ADefectPoint[ACount].Rect.top    =(long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - ADefectPoint[ACount].Height/2) +((FLTTInPoint.y+FRTTInPoint.y)/2)+ImageHeight);
					ADefectPoint[ACount].Rect.bottom =(long)(ADefectPoint[ACount].Rect.top + ADefectPoint[ACount].Height);
					ACount++;
				}
			}

			//Side B
			////////////////////////////////////////////////////////////////////////////////////////////////
			// 			LogUnit.SetLog("CAP_Side_B_Start_CamId: %d, ImageHeight: %d ",CamId,ImageHeight);     
// 			DefectROI.SetPlacement((int)(FRTRInPoint.x-FRightWidth-SideMargin), (int)(FRTRInPoint.y+Margin), FRightWidth, (RightHeight-(2*Margin)-TopMargin));
// 			DefectROI.SetPlacement((int)(FRTRInPoint.x-FRightWidth-SideMargin), (int)(FRTRInPoint.y+Margin), FRightWidth, (RightHeight-(2*Margin)-TopMargin));
			DefectROI.SetPlacement((int)(FRTRInPoint.x-FRightWidth-SideMargin), (int)(FRTRInPoint.y+Margin), FRightWidth, (RightHeight-(2*Margin)-RightDegMargin));
			if((FRTRInPoint.x-FRightWidth-SideMargin) <=0          ||(FRTRInPoint.y+Margin)<=0           || FRightWidth<=0          || (RightHeight-(2*Margin)-RightDegMargin)<=0)           return false;
			if((FRTRInPoint.x-FRightWidth-SideMargin) >=ImageWidth ||(FRTRInPoint.y+Margin)>TopLimitLine || FRightWidth>=ImageWidth || (RightHeight-(2*Margin)-RightDegMargin)>TopLimitLine) return false;
			if((FRTRInPoint.x-FRightWidth-SideMargin)+FRightWidth >=ImageWidth ||((FRTRInPoint.y+Margin)+(RightHeight-(2*Margin)-RightDegMargin))>TopLimitLine) return false;
			//  Blob 검사 진행 
			CodeImageSelection.Clear();
			CodeImageEncoder.Encode(DefectROI,CodeImage);
			CodeImageSelection.Clear();
			CodeImageSelection.AddObjects(CodeImage);
			// Blob 필터링 
			CodeImageSelection.RemoveUsingFloatFeature(EFeature_BoundingBoxWidth ,FMinWidth     , FMaxWidth    , EDoubleThresholdMode_Outside);
			CodeImageSelection.RemoveUsingFloatFeature(EFeature_BoundingBoxHeight,FMinHeight    , FMaxHeight   , EDoubleThresholdMode_Outside);
			// 				CodeImageSelection.RemoveUsingIntegerFeature(EFeature_RightLimit     ,FRightWidth-2 , FRightWidth+1, EDoubleThresholdMode_Outside);
			CodeImageSelection.RemoveUsingIntegerFeature(EFeature_RightLimit     ,FRightWidth-1 , FRightWidth+1, EDoubleThresholdMode_Outside);

			BlobCount = CodeImageSelection.GetElementCount();
			CodeImageSelection.Sort(EFeature_TopLimit,ESortDirection_Ascending);

			if(BlobCount!=0){
				for(int k=0; k<BlobCount; k++){
					if(BCount>=MAX_DEFECT_POINT) break;
					BDefectPoint[BCount].Width  = CodeImageSelection.GetElement(k).GetBoundingBoxWidth() ;
					BDefectPoint[BCount].Height = CodeImageSelection.GetElement(k).GetBoundingBoxHeight();

					BDefectPoint[BCount].Rect.left   = (long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterX() - BDefectPoint[BCount].Width/2 ) +(FRTRInPoint.x-FRightWidth-SideMargin));
					BDefectPoint[BCount].Rect.top    = (long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - BDefectPoint[BCount].Height/2) +(FRTRInPoint.y+Margin)                );
					BDefectPoint[BCount].Rect.right  = (long)(BDefectPoint[BCount].Rect.left+ BDefectPoint[BCount].Width );
					BDefectPoint[BCount].Rect.bottom = (long)(BDefectPoint[BCount].Rect.top + BDefectPoint[BCount].Height);
					PixelCount = 0;
					PixelValue = 0;

					// 내부 Pixel Data 축출 
					for(int n=BDefectPoint[BCount].Rect.top+1 ; n<BDefectPoint[BCount].Rect.bottom-1; n++){
						for(int m=BDefectPoint[BCount].Rect.left+1; m<BDefectPoint[BCount].Rect.right-1 ; m++){
							PixelValue = IElement(m,n);
							if(PixelValue < EnCapTopThresHold) PixelCount++;
						}
					}
					BDefectPoint[BCount].Round  = PixelCount;
					BDefectPoint[BCount].P.x    = (float)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterX() - BDefectPoint[BCount].Width/2 ) +(FRTRInPoint.x-FRightWidth-SideMargin));
					BDefectPoint[BCount].P.y    = (float)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - BDefectPoint[BCount].Height/2) +(FRTRInPoint.y+Margin)+ImageHeight    );
					BDefectPoint[BCount].Width  = BDefectPoint[BCount].Width+SideMargin; 

					// Merge 위해서 데이터 필요함 
					BDefectPoint[BCount].Rect.top    =(long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - BDefectPoint[BCount].Height/2) + FRTRInPoint.y+Margin+ImageHeight);
					BDefectPoint[BCount].Rect.bottom =(long)(BDefectPoint[BCount].Rect.top + BDefectPoint[BCount].Height);
					BCount++;
				}
			}
			BlobCount =0;

			// 외곽라인에서 Mark까지의 거리 산출 
			if     (Line[waRightWall].FP0.x >Line[waRightWall].FP1.x) RDistance = ((Line[waRightWall].FP1.x+(Line[waRightWall].FP0.x - Line[waRightWall].FP1.x)/2) - FP1.x);
			else if(Line[waRightWall].FP0.x==Line[waRightWall].FP1.x) RDistance = (Line[waRightWall].FP0.x - FP1.x);
			else                                                      RDistance = ((Line[waRightWall].FP0.x+(Line[waRightWall].FP1.x - Line[waRightWall].FP0.x)/2) - FP1.x);

			MarktoBmLine = (IsMarkBtm) ? 5: 50;  
			if(IsMarkBtm) RDistance = RDistance-MarktoBmLine;
			else          RDistance = RDistance+MarktoBmLine;

			// Side D	
			////////////////////////////////////////////////////////////////////////////////////////////////
			// 			LogUnit.SetLog("CAP_Side_D_Start_CamId: %d, ImageHeight: %d ",CamId,ImageHeight);     
// 			DefectROI.SetPlacement((int)(FLTLInPoint.x+SideMargin), (int)(FLTLInPoint.y+Margin), FLeftWidth, (LeftHeight-(2*Margin)-TopMargin));
// 			if((FLTLInPoint.x+SideMargin) <=0          ||(FLTLInPoint.y+Margin)<=0           || FLeftWidth<=0          || (LeftHeight-(2*Margin)-TopMargin)<=0          ) return false;
// 			if((FLTLInPoint.x+SideMargin) >=ImageWidth ||(FLTLInPoint.y+Margin)>TopLimitLine || FLeftWidth>=ImageWidth || (LeftHeight-(2*Margin)-TopMargin)>TopLimitLine) return false;
// 			if((FLTLInPoint.x+SideMargin)+FLeftWidth >=ImageWidth ||(FLTLInPoint.y+Margin)+(LeftHeight-(2*Margin)-TopMargin)>TopLimitLine) return false;

			DefectROI.SetPlacement((int)(FLTLInPoint.x+SideMargin), (int)(FLTLInPoint.y+Margin), FLeftWidth, (LeftHeight-(2*Margin)-LeftDegMargin));
			if((FLTLInPoint.x+SideMargin) <=0          ||(FLTLInPoint.y+Margin)<=0           || FLeftWidth<=0          || (LeftHeight-(2*Margin)-LeftDegMargin)<=0          ) return false;
			if((FLTLInPoint.x+SideMargin) >=ImageWidth ||(FLTLInPoint.y+Margin)>TopLimitLine || FLeftWidth>=ImageWidth || (LeftHeight-(2*Margin)-LeftDegMargin)>TopLimitLine) return false;
			if((FLTLInPoint.x+SideMargin)+FLeftWidth >=ImageWidth ||(FLTLInPoint.y+Margin)+(LeftHeight-(2*Margin)-LeftDegMargin)>TopLimitLine) return false;

			// Blob 검사 진행 
			CodeImageSelection.Clear();
			CodeImageEncoder.Encode(DefectROI,CodeImage);
			CodeImageSelection.Clear();
			CodeImageSelection.AddObjects(CodeImage);

			// Blob 필터링 
			CodeImageSelection.RemoveUsingFloatFeature  (EFeature_BoundingBoxWidth ,FMinWidth , FMaxWidth  , EDoubleThresholdMode_Outside);
			CodeImageSelection.RemoveUsingFloatFeature  (EFeature_BoundingBoxHeight,FMinHeight, FMaxHeight , EDoubleThresholdMode_Outside);
			// 				CodeImageSelection.RemoveUsingIntegerFeature(EFeature_LeftLimit        ,0         , 3          , EDoubleThresholdMode_Outside);
			CodeImageSelection.RemoveUsingIntegerFeature(EFeature_LeftLimit        ,0         , 1          , EDoubleThresholdMode_Outside);

			BlobCount = CodeImageSelection.GetElementCount();
			CodeImageSelection.Sort(EFeature_TopLimit,ESortDirection_Ascending);

			if(BlobCount!=0){
				for(int k=0; k<BlobCount; k++){
					if(DCount>=MAX_DEFECT_POINT) break;
					DDefectPoint[DCount].Width     =  CodeImageSelection.GetElement(k).GetBoundingBoxWidth() ;
					DDefectPoint[DCount].Height    =  CodeImageSelection.GetElement(k).GetBoundingBoxHeight();

					DDefectPoint[DCount].Rect.left   = (long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterX() - DDefectPoint[DCount].Width/2 ) +(FLTLInPoint.x+SideMargin));
					DDefectPoint[DCount].Rect.top    = (long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - DDefectPoint[DCount].Height/2) +(FLTLInPoint.y+Margin)    );
					DDefectPoint[DCount].Rect.right  = (long)(DDefectPoint[DCount].Rect.left+ DDefectPoint[DCount].Width );
					DDefectPoint[DCount].Rect.bottom = (long)(DDefectPoint[DCount].Rect.top + DDefectPoint[DCount].Height);

					PixelCount = 0;
					PixelValue = 0;
					// 내부 Pixel Data 축출 
					for(int n=DDefectPoint[DCount].Rect.top+1 ; n<DDefectPoint[DCount].Rect.bottom-1; n++){
						for(int m=DDefectPoint[DCount].Rect.left+1; m<DDefectPoint[DCount].Rect.right-1 ; m++){
							PixelValue = IElement(m,n);
							if(PixelValue < EnCapTopThresHold) PixelCount++;
						}
					}
					// Display 데이터 필요함 
					DDefectPoint[DCount].Round = PixelCount;
					DDefectPoint[DCount].P.x       = (float)(DDefectPoint[DCount].Rect.left);
					DDefectPoint[DCount].P.y       = (float)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - DDefectPoint[DCount].Height/2)+(FLTLInPoint.y+Margin)+ImageHeight );
					DDefectPoint[DCount].Width     = DDefectPoint[DCount].Width+SideMargin; 

					// Merge 위해서 데이터 필요함 
					DDefectPoint[DCount].Rect.top    =(long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - DDefectPoint[DCount].Height/2) +(FLTLInPoint.y+Margin)+ImageHeight);
					DDefectPoint[DCount].Rect.bottom =(long)(DDefectPoint[DCount].Rect.top + DDefectPoint[DCount].Height);
					DCount++;
				}
			}
			BlobCount =0;

			// 외곽라인에서 Mark까지의 거리 산출 
			if     (Line[waLeftWall].FP0.x >Line[waLeftWall].FP1.x) LDistance = (FP0.x - (Line[waLeftWall].FP1.x+(Line[waLeftWall].FP0.x - Line[waLeftWall].FP1.x)/2));
			else if(Line[waLeftWall].FP0.x==Line[waLeftWall].FP1.x) LDistance = (FP0.x -  Line[waLeftWall].FP0.x)                                                     ;
			else                                                    LDistance = (FP0.x - (Line[waLeftWall].FP0.x+(Line[waLeftWall].FP1.x - Line[waLeftWall].FP0.x)/2)); 
		}
		else if(IsRectTop) {  // Corner Cutting이 없을경우 
			//Side A
			////////////////////////////////////////////////////////////////////////////////////////////////
			DefectROI.SetPlacement((int)(FLTPoint.x+SideMargin), (int)((FLTPoint.y+FRTPoint.y)/2), TopWidth-(2*SideMargin), FTopHeight);
			if((FLTPoint.x+SideMargin) <=0          || ((FLTPoint.y+FRTPoint.y)/2)<=0           || TopWidth-(2*SideMargin)<=0          || FTopHeight<=0          )return false;
			if((FLTPoint.x+SideMargin) >=ImageWidth || ((FLTPoint.y+FRTPoint.y)/2)>TopLimitLine || TopWidth-(2*SideMargin)>=ImageWidth || FTopHeight>TopLimitLine) return false;
			if((FLTPoint.x+SideMargin)+(TopWidth-(2*SideMargin)) >=ImageWidth || ((FLTPoint.y+FRTPoint.y)/2)+ FTopHeight>TopLimitLine) return false;
			// Blob 검사 
			CodeImageSelection.Clear();
			CodeImageEncoder.Encode(DefectROI,CodeImage);
			CodeImageSelection.Clear();
			CodeImageSelection.AddObjects(CodeImage);
			// Blob 필터링 
			CodeImageSelection.RemoveUsingFloatFeature  (EFeature_BoundingBoxWidth ,FMinWidth , FMaxWidth  , EDoubleThresholdMode_Outside);
			CodeImageSelection.RemoveUsingFloatFeature  (EFeature_BoundingBoxHeight,FMinHeight, FMaxHeight , EDoubleThresholdMode_Outside);
			CodeImageSelection.RemoveUsingIntegerFeature(EFeature_TopLimit         ,0         , 3          , EDoubleThresholdMode_Outside);

			BlobCount = CodeImageSelection.GetElementCount();
			CodeImageSelection.Sort(EFeature_LeftLimit ,ESortDirection_Ascending);

			if(BlobCount!=0){
				for(int k=0; k<BlobCount; k++){
					if(ACount>=MAX_DEFECT_POINT) break;
					ADefectPoint[ACount].Width  = CodeImageSelection.GetElement(k).GetBoundingBoxWidth() ;
					ADefectPoint[ACount].Height = CodeImageSelection.GetElement(k).GetBoundingBoxHeight();

					ADefectPoint[ACount].Rect.left   =(long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterX() - ADefectPoint[ACount].Width/2 ) +FLTPoint.x+SideMargin      );
					ADefectPoint[ACount].Rect.top    =(long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - ADefectPoint[ACount].Height/2) +((FLTPoint.y+FRTPoint.y)/2));
					ADefectPoint[ACount].Rect.right  =(long)(ADefectPoint[ACount].Rect.left+ ADefectPoint[ACount].Width );
					ADefectPoint[ACount].Rect.bottom =(long)(ADefectPoint[ACount].Rect.top + ADefectPoint[ACount].Height);
					PixelCount = 0;
					PixelValue = 0;

					// 내부 Pixel Data 축출 
					for(int n=ADefectPoint[ACount].Rect.top+1 ; n<ADefectPoint[ACount].Rect.bottom-1; n++){
						for(int m=ADefectPoint[ACount].Rect.left+1; m<ADefectPoint[ACount].Rect.right-1 ; m++){
							PixelValue = IElement(m,n);
							if(PixelValue < EnCapTopThresHold) PixelCount++;
						}
					}

					ADefectPoint[ACount].Round  = PixelCount;
					ADefectPoint[ACount].P.x    =(float)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterX() - ADefectPoint[ACount].Width/2 )+FLTPoint.x+SideMargin      );
					ADefectPoint[ACount].P.y    =(float)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - ADefectPoint[ACount].Height/2)+((FLTPoint.y+FRTPoint.y)/2));

					// Image Rotate 기준 좌표를 다시 Rotate한다 _ Display 목적 
					if(ImgDegree!=0.0f){
						ADefectPoint[ACount].P = Math.OnRotate(CenterPoint, ADefectPoint[ACount].P, (ImgDegree));
					}
					// Image Rotate 기준 좌표를 회전 이후에 ImageHeight값을 더하여 실제 좌표를 산출한다 
					ADefectPoint[ACount].P.y    =(float)(ADefectPoint[ACount].P.y+ImageHeight);

					//Merget위해서 필요함 
					ADefectPoint[ACount].Rect.top    =(long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - ADefectPoint[ACount].Height/2) +((FLTPoint.y+FRTPoint.y)/2)+ImageHeight);
					ADefectPoint[ACount].Rect.bottom =(long)(ADefectPoint[ACount].Rect.top + ADefectPoint[ACount].Height);
					ACount++;
				}
			}
			BlobCount =0;

			//Side B
			////////////////////////////////////////////////////////////////////////////////////////////////
			// 			LogUnit.SetLog("CAP_Side_B_Start_CamId: %d, ImageHeight: %d ",CamId,ImageHeight);     
// 			DefectROI.SetPlacement((int)(FRTPoint.x-FRightWidth-SideMargin), (int)(FRTPoint.y+Margin), FRightWidth, (RightHeight-(2*Margin)-TopMargin));
// 			if((FRTPoint.x-FRightWidth-SideMargin) <=0          ||(FRTPoint.y+Margin)<=0           || FRightWidth<=0          || (RightHeight-(2*Margin)-TopMargin)<=0)           return false;
// 			if((FRTPoint.x-FRightWidth-SideMargin) >=ImageWidth ||(FRTPoint.y+Margin)>TopLimitLine || FRightWidth>=ImageWidth || (RightHeight-(2*Margin)-TopMargin)>TopLimitLine) return false;
// 			if((FRTPoint.x-FRightWidth-SideMargin)+FRightWidth >=ImageWidth ||((FRTPoint.y+Margin)+(RightHeight-(2*Margin)-TopMargin))>TopLimitLine) return false;

			DefectROI.SetPlacement((int)(FRTPoint.x-FRightWidth-SideMargin), (int)(FRTPoint.y+Margin), FRightWidth, (RightHeight-(2*Margin)-RightDegMargin));
			if((FRTPoint.x-FRightWidth-SideMargin) <=0          ||(FRTPoint.y+Margin)<=0           || FRightWidth<=0          || (RightHeight-(2*Margin)-RightDegMargin)<=0)           return false;
			if((FRTPoint.x-FRightWidth-SideMargin) >=ImageWidth ||(FRTPoint.y+Margin)>TopLimitLine || FRightWidth>=ImageWidth || (RightHeight-(2*Margin)-RightDegMargin)>TopLimitLine) return false;
			if((FRTPoint.x-FRightWidth-SideMargin)+FRightWidth >=ImageWidth ||((FRTPoint.y+Margin)+(RightHeight-(2*Margin)-RightDegMargin))>TopLimitLine) return false;

			//  Blob 검사 진행 
			CodeImageSelection.Clear();
			CodeImageEncoder.Encode(DefectROI,CodeImage);
			CodeImageSelection.Clear();
			CodeImageSelection.AddObjects(CodeImage);
			// Blob 필터링 
			CodeImageSelection.RemoveUsingFloatFeature(EFeature_BoundingBoxWidth ,FMinWidth     , FMaxWidth    , EDoubleThresholdMode_Outside);
			CodeImageSelection.RemoveUsingFloatFeature(EFeature_BoundingBoxHeight,FMinHeight    , FMaxHeight   , EDoubleThresholdMode_Outside);
			// 				CodeImageSelection.RemoveUsingIntegerFeature(EFeature_RightLimit     ,FRightWidth-2 , FRightWidth+1, EDoubleThresholdMode_Outside);
			CodeImageSelection.RemoveUsingIntegerFeature(EFeature_RightLimit     ,FRightWidth-1 , FRightWidth+1, EDoubleThresholdMode_Outside);

			BlobCount = CodeImageSelection.GetElementCount();
			CodeImageSelection.Sort(EFeature_TopLimit,ESortDirection_Ascending);

			if(BlobCount!=0){
				for(int k=0; k<BlobCount; k++){
					if(BCount>=MAX_DEFECT_POINT) break;
					BDefectPoint[BCount].Width  = CodeImageSelection.GetElement(k).GetBoundingBoxWidth() ;
					BDefectPoint[BCount].Height = CodeImageSelection.GetElement(k).GetBoundingBoxHeight();

					BDefectPoint[BCount].Rect.left   = (long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterX() - BDefectPoint[BCount].Width/2 ) +(FRTPoint.x-FRightWidth-SideMargin));
					BDefectPoint[BCount].Rect.top    = (long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - BDefectPoint[BCount].Height/2) +(FRTPoint.y+Margin)                );
					BDefectPoint[BCount].Rect.right  = (long)(BDefectPoint[BCount].Rect.left+ BDefectPoint[BCount].Width );
					BDefectPoint[BCount].Rect.bottom = (long)(BDefectPoint[BCount].Rect.top + BDefectPoint[BCount].Height);
					PixelCount = 0;
					PixelValue = 0;

					// 내부 Pixel Data 축출 
					for(int n=BDefectPoint[BCount].Rect.top+1 ; n<BDefectPoint[BCount].Rect.bottom-1; n++){
						for(int m=BDefectPoint[BCount].Rect.left+1; m<BDefectPoint[BCount].Rect.right-1 ; m++){
							PixelValue = IElement(m,n);
							if(PixelValue < EnCapTopThresHold) PixelCount++;
						}
					}
					BDefectPoint[BCount].Round  = PixelCount;
					BDefectPoint[BCount].P.x    = (float)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterX() - BDefectPoint[BCount].Width/2 ) +(FRTPoint.x-FRightWidth-SideMargin));
					BDefectPoint[BCount].P.y    = (float)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - BDefectPoint[BCount].Height/2) +(FRTPoint.y+Margin)+ImageHeight    );
					BDefectPoint[BCount].Width  = BDefectPoint[BCount].Width+SideMargin; 

					// Merge 위해서 데이터 필요함 
					BDefectPoint[BCount].Rect.top    =(long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - BDefectPoint[BCount].Height/2) + FRTPoint.y+Margin+ImageHeight);
					BDefectPoint[BCount].Rect.bottom =(long)(BDefectPoint[BCount].Rect.top + BDefectPoint[BCount].Height);
					BCount++;
				}
			}
			BlobCount =0;

			// 외곽라인에서 Mark까지의 거리 산출 
			if     (Line[waRightWall].FP0.x >Line[waRightWall].FP1.x) RDistance = ((Line[waRightWall].FP1.x+(Line[waRightWall].FP0.x - Line[waRightWall].FP1.x)/2) - FP1.x);
			else if(Line[waRightWall].FP0.x==Line[waRightWall].FP1.x) RDistance = (Line[waRightWall].FP0.x - FP1.x);
			else                                                      RDistance = ((Line[waRightWall].FP0.x+(Line[waRightWall].FP1.x - Line[waRightWall].FP0.x)/2) - FP1.x);

// 			MarktoBmLine = (IsMarkBtm) ? 5: 50;  
// 			if(IsMarkBtm) RDistance = RDistance-MarktoBmLine;
// 			else          RDistance = RDistance+MarktoBmLine;

			// Side D	
			////////////////////////////////////////////////////////////////////////////////////////////////
			// 			LogUnit.SetLog("CAP_Side_D_Start_CamId: %d, ImageHeight: %d ",CamId,ImageHeight);     
// 			DefectROI.SetPlacement((int)(FLTPoint.x+SideMargin), (int)(FLTPoint.y+Margin), FLeftWidth, (LeftHeight-(2*Margin)-TopMargin));
// 			if((FLTPoint.x+SideMargin) <=0          ||(FLTPoint.y+Margin)<=0           || FLeftWidth<=0          || (LeftHeight-(2*Margin)-TopMargin)<=0          ) return false;
// 			if((FLTPoint.x+SideMargin) >=ImageWidth ||(FLTPoint.y+Margin)>TopLimitLine || FLeftWidth>=ImageWidth || (LeftHeight-(2*Margin)-TopMargin)>TopLimitLine) return false;
// 			if((FLTPoint.x+SideMargin)+FLeftWidth >=ImageWidth ||(FLTPoint.y+Margin)+(LeftHeight-(2*Margin)-TopMargin)>TopLimitLine) return false;

			DefectROI.SetPlacement((int)(FLTPoint.x+SideMargin), (int)(FLTPoint.y+Margin), FLeftWidth, (LeftHeight-(2*Margin)-LeftDegMargin));
			if((FLTPoint.x+SideMargin) <=0          ||(FLTPoint.y+Margin)<=0           || FLeftWidth<=0          || (LeftHeight-(2*Margin)-LeftDegMargin)<=0          ) return false;
			if((FLTPoint.x+SideMargin) >=ImageWidth ||(FLTPoint.y+Margin)>TopLimitLine || FLeftWidth>=ImageWidth || (LeftHeight-(2*Margin)-LeftDegMargin)>TopLimitLine) return false;
			if((FLTPoint.x+SideMargin)+FLeftWidth >=ImageWidth ||(FLTPoint.y+Margin)+(LeftHeight-(2*Margin)-LeftDegMargin)>TopLimitLine) return false;

			// Blob 검사 진행 
			CodeImageSelection.Clear();
			CodeImageEncoder.Encode(DefectROI,CodeImage);
			CodeImageSelection.Clear();
			CodeImageSelection.AddObjects(CodeImage);

			// Blob 필터링 
			CodeImageSelection.RemoveUsingFloatFeature  (EFeature_BoundingBoxWidth ,FMinWidth , FMaxWidth  , EDoubleThresholdMode_Outside);
			CodeImageSelection.RemoveUsingFloatFeature  (EFeature_BoundingBoxHeight,FMinHeight, FMaxHeight , EDoubleThresholdMode_Outside);
			// 				CodeImageSelection.RemoveUsingIntegerFeature(EFeature_LeftLimit        ,0         , 3          , EDoubleThresholdMode_Outside);
			CodeImageSelection.RemoveUsingIntegerFeature(EFeature_LeftLimit        ,0         , 1          , EDoubleThresholdMode_Outside);

			BlobCount = CodeImageSelection.GetElementCount();
			CodeImageSelection.Sort(EFeature_TopLimit,ESortDirection_Ascending);

			if(BlobCount!=0){
				for(int k=0; k<BlobCount; k++){
					if(DCount>=MAX_DEFECT_POINT) break;
					DDefectPoint[DCount].Width     =  CodeImageSelection.GetElement(k).GetBoundingBoxWidth() ;
					DDefectPoint[DCount].Height    =  CodeImageSelection.GetElement(k).GetBoundingBoxHeight();

					DDefectPoint[DCount].Rect.left   = (long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterX() - DDefectPoint[DCount].Width/2 ) +(FLTPoint.x+SideMargin));
					DDefectPoint[DCount].Rect.top    = (long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - DDefectPoint[DCount].Height/2) +(FLTPoint.y+Margin)    );
					DDefectPoint[DCount].Rect.right  = (long)(DDefectPoint[DCount].Rect.left+ DDefectPoint[DCount].Width );
					DDefectPoint[DCount].Rect.bottom = (long)(DDefectPoint[DCount].Rect.top + DDefectPoint[DCount].Height);

					PixelCount = 0;
					PixelValue = 0;
					// 내부 Pixel Data 축출 
					for(int n=DDefectPoint[DCount].Rect.top+1 ; n<DDefectPoint[DCount].Rect.bottom-1; n++){
						for(int m=DDefectPoint[DCount].Rect.left+1; m<DDefectPoint[DCount].Rect.right-1 ; m++){
							PixelValue = IElement(m,n);
							if(PixelValue < EnCapTopThresHold) PixelCount++;
						}
					}
					// Display 데이터 필요함 
					DDefectPoint[DCount].Round = PixelCount;
					DDefectPoint[DCount].P.x       = (float)(DDefectPoint[DCount].Rect.left);
					DDefectPoint[DCount].P.y       = (float)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - DDefectPoint[DCount].Height/2)+(FLTPoint.y+Margin)+ImageHeight );
					DDefectPoint[DCount].Width     = DDefectPoint[DCount].Width+SideMargin; 

					// Merge 위해서 데이터 필요함 
					DDefectPoint[DCount].Rect.top    =(long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - DDefectPoint[DCount].Height/2) +(FLTPoint.y+Margin)+ImageHeight);
					DDefectPoint[DCount].Rect.bottom =(long)(DDefectPoint[DCount].Rect.top + DDefectPoint[DCount].Height);
					DCount++;
				}
			}
			BlobCount =0;

			// 외곽라인에서 Mark까지의 거리 산출 
			if     (Line[waLeftWall].FP0.x >Line[waLeftWall].FP1.x) LDistance = (FP0.x - (Line[waLeftWall].FP1.x+(Line[waLeftWall].FP0.x - Line[waLeftWall].FP1.x)/2));
			else if(Line[waLeftWall].FP0.x==Line[waLeftWall].FP1.x) LDistance = (FP0.x -  Line[waLeftWall].FP0.x)                                                     ;
			else                                                    LDistance = (FP0.x - (Line[waLeftWall].FP0.x+(Line[waLeftWall].FP1.x - Line[waLeftWall].FP0.x)/2)); 
		}
		else if(IsCircleTop){ // Circle Cutting일경우 Defect검사 진행 
			if(FInspectMode==Insp_Polygon){ // A_Side 영역 Arc Polygon Mode 검사 시퀀스 
				LogUnit.SetLog(L"Polygon_Defect_START");     
				if(A1CirInEdgeCount!=0){    // Polygon Mode 검사에서는 Dx,Dy,R,박리불량 미검사 
					IAddress = DefectImg.GetImagePtr(); // Pixel 정보 추출 목적 

					A1CirDeftectCnt  = GetPolygonSize(A1CirInPoint, A1CirDefectPoint, A1CirInEdgeCount, 50, 5); // Dark Defect 
					// 박리 불량 검사 
					if(!IsMarkBtm && A1CirInCrackCount>0 && BrokenThresHold!=0){
						IAddress = RotateBrokenImg.GetImagePtr(); // Pixel 정보 추출 목적 
						A1CirCrackCnt  = GetCircleCrackSize(A1CircleData, A1CirCrackPoint, A1CirInCrackCount, 30,ACirFitDiameter1,ACircleFit1Center); //Bright Defect 
					}
				}

				if(A2CirInEdgeCount!=0){
					IAddress = DefectImg.GetImagePtr(); // Pixel 정보 추출 목적 
					A2CirDeftectCnt  = GetPolygonSize(A2CirInPoint, A2CirDefectPoint, A2CirInEdgeCount, 50, 5); // Dark Defect 

					// 박리 불량 검사 
					if(!IsMarkBtm && A2CirInCrackCount>0 && BrokenThresHold!=0){
						IAddress = RotateBrokenImg.GetImagePtr(); // Pixel 정보 추출 목적 
						A2CirCrackCnt  = GetCircleCrackSize(A2CircleData, A2CirCrackPoint, A2CirInCrackCount, 30,ACirFitDiameter2,ACircleFit2Center); // Bright Defect 
					}
				}
				LogUnit.SetLog(L"Polygon_Defect_END");     
			}
			else                          { // A_Side 영역 Arc Mark Mode 검사 시퀀스 (A_Side영역은 Only MarkMode만 존재함)
				LogUnit.SetLog(L"Mark_Defect_START");     
				if(A1CirInEdgeCount!=0){
					IAddress = DefectImg.GetImagePtr(); // Pixel 정보 추출 목적 
					MaxDis =0.0f     ;
					MinDis =10000.0f ;
					MaxDv  =0.0f     ;
					MinDv  =10000.0f ;

					CircleCount=0;TotalCirDis=0.0f; AvgCirDis=0.0f;
					for(int k=0; k<A1CirInEdgeCount; k++){
						if(A1CirInPoint[k].x==0 || A1CirInPoint[k].y==0 || k>=MAX_CIRCLE_EDGEPOINT) continue;

						// 					Dis    = Math.GetLengthFrPointToPoint(A1CirCenter,A1CirInPoint[k]);
						Dis    = Math.GetLengthFrPointToPoint(ACircleFit1Center,A1CirInPoint[k]);

						if(Dis>MaxDis) MaxDis = Dis;
						if(Dis<MinDis) MinDis = Dis;

						if(k==0){ // BTM Defect 검사를 위한 좌표값 및 Dx,Dy 산출 
							A1CirDx = Math.GetLengthFrPointToPoint(ACircleFit1Center,A1CirInPoint[k]);
						} 
						if(k==(A1CirInEdgeCount-1)){
							A1CirDy = Math.GetLengthFrPointToPoint(ACircleFit1Center,A1CirInPoint[k]);
						}

						A1CircleData[CircleCount].Dis  = Dis              ;
						A1CircleData[CircleCount].P.x  = A1CirInPoint[k].x;
						A1CircleData[CircleCount].P.y  = A1CirInPoint[k].y;
						CircleCount++   ;
						TotalCirDis+=Dis;
					}
					if(CircleCount!=0 || TotalCirDis!=0){ // Circle AvgRound Cal
						AvgCirDis = (TotalCirDis/CircleCount);
						A1CirRound = AvgCirDis;
					}

					for(int i=0; i<CircleCount; i++){
						// 					A1CircleData[i].Dv = fabs(AvgCirDis - A1CircleData[i].Dis);
						A1CircleData[i].Dv = (ACirFitDiameter1 - A1CircleData[i].Dis) >0 ?(ACirFitDiameter1 - A1CircleData[i].Dis):0;
						if(A1CircleData[i].Dv>MaxDv) MaxDv = A1CircleData[i].Dv;
						if(A1CircleData[i].Dv<MinDv) MinDv = A1CircleData[i].Dv;

					}
					A1CirDeftectCnt  = GetCircleSize(A1CircleData, A1CirDefectPoint, CircleCount, 5); // Dark Defect 

					// 박리불량 검사 시퀀스 
					if(!IsMarkBtm && A1CirInCrackCount>0 && BrokenThresHold!=0){
						for(int i=0; i<A1CirInCrackCount; i++){
							A1CircleData[i].Dv  =0.0f;
							A1CircleData[i].Dis =0.0f;
							A1CircleData[i].P.x  = A1CirInCrackPoint[i].x;
							A1CircleData[i].P.y  = A1CirInCrackPoint[i].y;
						}
						IAddress = RotateBrokenImg.GetImagePtr(); // Pixel 정보 추출 목적 
						A1CirCrackCnt  = GetCircleCrackSize(A1CircleData, A1CirCrackPoint, A1CirInCrackCount, 30,CrackACirDiameter1,ACircleFit1Center);
					}
				}

				if(A2CirInEdgeCount!=0){
					IAddress = DefectImg.GetImagePtr(); // Pixel 정보 추출 목적 
					MaxDis =0.0f     ;
					MinDis =10000.0f ;
					MaxDv  =0.0f     ;
					MinDv  =10000.0f ;

					CircleCount=0;TotalCirDis=0.0f; AvgCirDis=0.0f;
					for(int k=0; k<A2CirInEdgeCount; k++){
						if(A2CirInPoint[k].x==0 || A2CirInPoint[k].y==0 || k>=MAX_CIRCLE_EDGEPOINT) continue;

						// 					Dis    = Math.GetLengthFrPointToPoint(A2CirCenter,A2CirInPoint[k]);
						Dis    = Math.GetLengthFrPointToPoint(ACircleFit2Center,A2CirInPoint[k]);

						if(Dis>MaxDis) MaxDis = Dis;
						if(Dis<MinDis) MinDis = Dis;

						if(k==0){ // BTM Defect 검사를 위한 좌표값 및 Dx,Dy 산출 
							A2CirDy = Math.GetLengthFrPointToPoint(ACircleFit2Center,A2CirInPoint[k]);
						} 
						if(k==(A2CirInEdgeCount-1)){
							A2CirDx = Math.GetLengthFrPointToPoint(ACircleFit2Center,A2CirInPoint[k]);
						}

						A2CircleData[CircleCount].Dis  = Dis              ;
						A2CircleData[CircleCount].P.x  = A2CirInPoint[k].x;
						A2CircleData[CircleCount].P.y  = A2CirInPoint[k].y;
						CircleCount++   ;
						TotalCirDis+=Dis;
					}
					if(CircleCount!=0 || TotalCirDis!=0){ // Circle AvgRound Cal
						AvgCirDis = (TotalCirDis/CircleCount);
						A2CirRound = AvgCirDis;
					}

					for(int i=0; i<CircleCount; i++){
						// 					A2CircleData[i].Dv = fabs(AvgCirDis - A2CircleData[i].Dis);
						A2CircleData[i].Dv = (ACirFitDiameter2 - A2CircleData[i].Dis) >0 ?(ACirFitDiameter2 - A2CircleData[i].Dis):0;
						if(A2CircleData[i].Dv>MaxDv) MaxDv = A2CircleData[i].Dv;
						if(A2CircleData[i].Dv<MinDv) MinDv = A2CircleData[i].Dv;
					}
					A2CirDeftectCnt  = GetCircleSize(A2CircleData, A2CirDefectPoint, CircleCount, 5);

					// 박리불량 검사 시퀀스 
					if(!IsMarkBtm && A2CirInCrackCount>0 && BrokenThresHold!=0){
						for(int i=0; i<A2CirInCrackCount; i++){
							A2CircleData[i].Dv  =0.0f;
							A2CircleData[i].Dis =0.0f;
							A2CircleData[i].P.x  = A2CirInCrackPoint[i].x;
							A2CircleData[i].P.y  = A2CirInCrackPoint[i].y;
						}
						IAddress = RotateBrokenImg.GetImagePtr(); // Pixel 정보 추출 목적 
						A2CirCrackCnt  = GetCircleCrackSize(A2CircleData, A2CirCrackPoint, A2CirInCrackCount, 20,CrackACirDiameter2,ACircleFit2Center);
					}
				}
				LogUnit.SetLog(L"Mark_Defect_END");     
			}

			// SIDE A 검사 
			////////////////////////////////////////////////////////////////////////////////////////////////
			DefectROI.SetPlacement((int)(TopEdgePoint[1].x+SideMargin), (int)((TopEdgePoint[1].y+TopEdgePoint[2].y)/2), TopWidth-(2*SideMargin), FTopHeight);
			if((TopEdgePoint[1].x+SideMargin) <=0          || ((TopEdgePoint[1].y+TopEdgePoint[2].y)/2)<=0           || TopWidth-(2*SideMargin)<=0          || FTopHeight<=0          ) return false;
			if((TopEdgePoint[1].x+SideMargin) >=ImageWidth || ((TopEdgePoint[1].y+TopEdgePoint[2].y)/2)>TopLimitLine || TopWidth-(2*SideMargin)>=ImageWidth || FTopHeight>TopLimitLine) return false;
			if((TopEdgePoint[1].x+SideMargin)+(TopWidth-(2*SideMargin)) >=ImageWidth || ((TopEdgePoint[1].y+TopEdgePoint[2].y)/2)+ FTopHeight>TopLimitLine                            ) return false;
			// Blob 검사 
			CodeImageSelection.Clear();
			CodeImageEncoder.Encode(DefectROI,CodeImage);
			CodeImageSelection.Clear();
			CodeImageSelection.AddObjects(CodeImage);
			// Blob 필터링 
			CodeImageSelection.RemoveUsingFloatFeature  (EFeature_BoundingBoxWidth ,FMinWidth , FMaxWidth  , EDoubleThresholdMode_Outside);
			CodeImageSelection.RemoveUsingFloatFeature  (EFeature_BoundingBoxHeight,FMinHeight, FMaxHeight , EDoubleThresholdMode_Outside);
			CodeImageSelection.RemoveUsingIntegerFeature(EFeature_TopLimit         ,0         , 3          , EDoubleThresholdMode_Outside);

			BlobCount = CodeImageSelection.GetElementCount();
			CodeImageSelection.Sort(EFeature_LeftLimit ,ESortDirection_Ascending);

			if(BlobCount!=0){
				for(int k=0; k<BlobCount; k++){
					if(ACount>=MAX_DEFECT_POINT) break;
					ADefectPoint[ACount].Width  = CodeImageSelection.GetElement(k).GetBoundingBoxWidth() ;
					ADefectPoint[ACount].Height = CodeImageSelection.GetElement(k).GetBoundingBoxHeight();

					ADefectPoint[ACount].Rect.left   =(long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterX() - ADefectPoint[ACount].Width/2 ) +(TopEdgePoint[1].x+SideMargin));
					ADefectPoint[ACount].Rect.top    =(long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - ADefectPoint[ACount].Height/2) +((TopEdgePoint[1].y+TopEdgePoint[2].y)/2));
					ADefectPoint[ACount].Rect.right  =(long)(ADefectPoint[ACount].Rect.left+ ADefectPoint[ACount].Width );
					ADefectPoint[ACount].Rect.bottom =(long)(ADefectPoint[ACount].Rect.top + ADefectPoint[ACount].Height);
					PixelCount = 0;
					PixelValue = 0;

					// 내부 Pixel Data 축출 
					for(int n=ADefectPoint[ACount].Rect.top+1 ; n<ADefectPoint[ACount].Rect.bottom-1; n++){
						for(int m=ADefectPoint[ACount].Rect.left+1; m<ADefectPoint[ACount].Rect.right-1 ; m++){
							PixelValue = IElement(m,n);
							if(PixelValue < EnCapTopThresHold) PixelCount++;
						}
					}

					ADefectPoint[ACount].Round  = PixelCount;
					ADefectPoint[ACount].P.x    =(float)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterX() - ADefectPoint[ACount].Width/2 )+(TopEdgePoint[1].x+SideMargin));
					ADefectPoint[ACount].P.y    =(float)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - ADefectPoint[ACount].Height/2)+((TopEdgePoint[1].y+TopEdgePoint[2].y)/2));


					// Image Rotate 기준 좌표를 다시 Rotate한다 _ Display 목적 
					if(ImgDegree!=0.0f){
						ADefectPoint[ACount].P = Math.OnRotate(CenterPoint, ADefectPoint[ACount].P, (ImgDegree));
					}
					// Image Rotate 기준 좌표를 회전 이후에 ImageHeight값을 더하여 실제 좌표를 산출한다 
					ADefectPoint[ACount].P.y    =(float)(ADefectPoint[ACount].P.y+ImageHeight);

					//Merget위해서 필요함 
					ADefectPoint[ACount].Rect.top    =(long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - ADefectPoint[ACount].Height/2) +((TopEdgePoint[1].y+TopEdgePoint[2].y)/2)+ImageHeight);
					ADefectPoint[ACount].Rect.bottom =(long)(ADefectPoint[ACount].Rect.top + ADefectPoint[ACount].Height);
					ACount++;
				}
			}
			BlobCount =0;

			// SIDE B 검사 
			//Side B
			////////////////////////////////////////////////////////////////////////////////////////////////
			// 			LogUnit.SetLog("CAP_Side_B_Start_CamId: %d, ImageHeight: %d ",CamId,ImageHeight);     
// 			DefectROI.SetPlacement((int)(TopEdgePoint[3].x-FRightWidth-SideMargin), (int)(TopEdgePoint[3].y+Margin), FRightWidth, (RightHeight-(2*Margin)-TopMargin));
// 			if((TopEdgePoint[3].x-FRightWidth-SideMargin) <=0          ||(TopEdgePoint[3].y+Margin)<=0           || FRightWidth<=0          || (RightHeight-(2*Margin)-TopMargin)<=0)           return false;
// 			if((TopEdgePoint[3].x-FRightWidth-SideMargin) >=ImageWidth ||(TopEdgePoint[3].y+Margin)>TopLimitLine || FRightWidth>=ImageWidth || (RightHeight-(2*Margin)-TopMargin)>TopLimitLine) return false;
// 			if((TopEdgePoint[3].x-FRightWidth-SideMargin)+FRightWidth >=ImageWidth ||((TopEdgePoint[3].y+Margin)+(RightHeight-(2*Margin)-TopMargin))>TopLimitLine) return false;

			DefectROI.SetPlacement((int)(TopEdgePoint[3].x-FRightWidth-SideMargin), (int)(TopEdgePoint[3].y+Margin), FRightWidth, (RightHeight-(2*Margin)-RightDegMargin));
			if((TopEdgePoint[3].x-FRightWidth-SideMargin) <=0          ||(TopEdgePoint[3].y+Margin)<=0           || FRightWidth<=0          || (RightHeight-(2*Margin)-RightDegMargin)<=0)           return false;
			if((TopEdgePoint[3].x-FRightWidth-SideMargin) >=ImageWidth ||(TopEdgePoint[3].y+Margin)>TopLimitLine || FRightWidth>=ImageWidth || (RightHeight-(2*Margin)-RightDegMargin)>TopLimitLine) return false;
			if((TopEdgePoint[3].x-FRightWidth-SideMargin)+FRightWidth >=ImageWidth ||((TopEdgePoint[3].y+Margin)+(RightHeight-(2*Margin)-RightDegMargin))>TopLimitLine) return false;

			//  Blob 검사 진행 
			CodeImageSelection.Clear();
			CodeImageEncoder.Encode(DefectROI,CodeImage);
			CodeImageSelection.Clear();
			CodeImageSelection.AddObjects(CodeImage);
			// Blob 필터링 
			CodeImageSelection.RemoveUsingFloatFeature(EFeature_BoundingBoxWidth ,FMinWidth     , FMaxWidth    , EDoubleThresholdMode_Outside);
			CodeImageSelection.RemoveUsingFloatFeature(EFeature_BoundingBoxHeight,FMinHeight    , FMaxHeight   , EDoubleThresholdMode_Outside);
			// 				CodeImageSelection.RemoveUsingIntegerFeature(EFeature_RightLimit     ,FRightWidth-2 , FRightWidth+1, EDoubleThresholdMode_Outside);
			CodeImageSelection.RemoveUsingIntegerFeature(EFeature_RightLimit     ,FRightWidth-1 , FRightWidth+1, EDoubleThresholdMode_Outside);

			BlobCount = CodeImageSelection.GetElementCount();
			CodeImageSelection.Sort(EFeature_TopLimit,ESortDirection_Ascending);

			if(BlobCount!=0){
				for(int k=0; k<BlobCount; k++){
					if(BCount>=MAX_DEFECT_POINT) break;
					BDefectPoint[BCount].Width  = CodeImageSelection.GetElement(k).GetBoundingBoxWidth() ;
					BDefectPoint[BCount].Height = CodeImageSelection.GetElement(k).GetBoundingBoxHeight();

					BDefectPoint[BCount].Rect.left   = (long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterX() - BDefectPoint[BCount].Width/2 ) +(TopEdgePoint[3].x-FRightWidth-SideMargin));
					BDefectPoint[BCount].Rect.top    = (long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - BDefectPoint[BCount].Height/2) +(TopEdgePoint[3].y+Margin)                );
					BDefectPoint[BCount].Rect.right  = (long)(BDefectPoint[BCount].Rect.left+ BDefectPoint[BCount].Width );
					BDefectPoint[BCount].Rect.bottom = (long)(BDefectPoint[BCount].Rect.top + BDefectPoint[BCount].Height);
					PixelCount = 0;
					PixelValue = 0;

					// 내부 Pixel Data 축출 
					for(int n=BDefectPoint[BCount].Rect.top+1 ; n<BDefectPoint[BCount].Rect.bottom-1; n++){
						for(int m=BDefectPoint[BCount].Rect.left+1; m<BDefectPoint[BCount].Rect.right-1 ; m++){
							PixelValue = IElement(m,n);
							if(PixelValue < EnCapTopThresHold) PixelCount++;
						}
					}
					BDefectPoint[BCount].Round  = PixelCount;
					BDefectPoint[BCount].P.x    = (float)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterX() - BDefectPoint[BCount].Width/2 ) +(TopEdgePoint[3].x-FRightWidth-SideMargin));
					BDefectPoint[BCount].P.y    = (float)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - BDefectPoint[BCount].Height/2) +(TopEdgePoint[3].y+Margin)+ImageHeight    );
					BDefectPoint[BCount].Width  = BDefectPoint[BCount].Width+SideMargin; 

					// Merge 위해서 데이터 필요함 
					BDefectPoint[BCount].Rect.top    =(long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - BDefectPoint[BCount].Height/2) + (TopEdgePoint[3].y+Margin)+ImageHeight);
					BDefectPoint[BCount].Rect.bottom =(long)(BDefectPoint[BCount].Rect.top + BDefectPoint[BCount].Height);
					BCount++;
				}
			}
			BlobCount =0;

			// 외곽라인에서 Mark까지의 거리 산출 
			if     (Line[waRightWall].FP0.x >Line[waRightWall].FP1.x) RDistance = ((Line[waRightWall].FP1.x+(Line[waRightWall].FP0.x - Line[waRightWall].FP1.x)/2) - FP1.x);
			else if(Line[waRightWall].FP0.x==Line[waRightWall].FP1.x) RDistance = (Line[waRightWall].FP0.x - FP1.x);
			else                                                      RDistance = ((Line[waRightWall].FP0.x+(Line[waRightWall].FP1.x - Line[waRightWall].FP0.x)/2) - FP1.x);

			// SIDE D 검사 
			////////////////////////////////////////////////////////////////////////////////////////////////
			// 			LogUnit.SetLog("CAP_Side_D_Start_CamId: %d, ImageHeight: %d ",CamId,ImageHeight);     
// 			DefectROI.SetPlacement((int)(TopEdgePoint[0].x+SideMargin), (int)(TopEdgePoint[0].y+Margin), FLeftWidth, (LeftHeight-(2*Margin)-TopMargin));
// 			if((TopEdgePoint[0].x+SideMargin) <=0          ||(TopEdgePoint[0].y+Margin)<=0           || FLeftWidth<=0          || (LeftHeight-(2*Margin)-TopMargin)<=0          ) return false;
// 			if((TopEdgePoint[0].x+SideMargin) >=ImageWidth ||(TopEdgePoint[0].y+Margin)>TopLimitLine || FLeftWidth>=ImageWidth || (LeftHeight-(2*Margin)-TopMargin)>TopLimitLine) return false;
// 			if((TopEdgePoint[0].x+SideMargin)+FLeftWidth >=ImageWidth ||(TopEdgePoint[0].y+Margin)+(LeftHeight-(2*Margin)-TopMargin)>TopLimitLine) return false;

			DefectROI.SetPlacement((int)(TopEdgePoint[0].x+SideMargin), (int)(TopEdgePoint[0].y+Margin), FLeftWidth, (LeftHeight-(2*Margin)-LeftDegMargin));
			if((TopEdgePoint[0].x+SideMargin) <=0          ||(TopEdgePoint[0].y+Margin)<=0           || FLeftWidth<=0          || (LeftHeight-(2*Margin)-LeftDegMargin)<=0          ) return false;
			if((TopEdgePoint[0].x+SideMargin) >=ImageWidth ||(TopEdgePoint[0].y+Margin)>TopLimitLine || FLeftWidth>=ImageWidth || (LeftHeight-(2*Margin)-LeftDegMargin)>TopLimitLine) return false;
			if((TopEdgePoint[0].x+SideMargin)+FLeftWidth >=ImageWidth ||(TopEdgePoint[0].y+Margin)+(LeftHeight-(2*Margin)-LeftDegMargin)>TopLimitLine) return false;

			// Blob 검사 진행 
			CodeImageSelection.Clear();
			CodeImageEncoder.Encode(DefectROI,CodeImage);
			CodeImageSelection.Clear();
			CodeImageSelection.AddObjects(CodeImage);

			// Blob 필터링 
			CodeImageSelection.RemoveUsingFloatFeature  (EFeature_BoundingBoxWidth ,FMinWidth , FMaxWidth  , EDoubleThresholdMode_Outside);
			CodeImageSelection.RemoveUsingFloatFeature  (EFeature_BoundingBoxHeight,FMinHeight, FMaxHeight , EDoubleThresholdMode_Outside);
			// 				CodeImageSelection.RemoveUsingIntegerFeature(EFeature_LeftLimit        ,0         , 3          , EDoubleThresholdMode_Outside);
			CodeImageSelection.RemoveUsingIntegerFeature(EFeature_LeftLimit        ,0         , 1          , EDoubleThresholdMode_Outside);

			BlobCount = CodeImageSelection.GetElementCount();
			CodeImageSelection.Sort(EFeature_TopLimit,ESortDirection_Ascending);

			if(BlobCount!=0){
				for(int k=0; k<BlobCount; k++){
					if(DCount>=MAX_DEFECT_POINT) break;
					DDefectPoint[DCount].Width     =  CodeImageSelection.GetElement(k).GetBoundingBoxWidth() ;
					DDefectPoint[DCount].Height    =  CodeImageSelection.GetElement(k).GetBoundingBoxHeight();

					DDefectPoint[DCount].Rect.left   = (long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterX() - DDefectPoint[DCount].Width/2 ) +(TopEdgePoint[0].x+SideMargin));
					DDefectPoint[DCount].Rect.top    = (long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - DDefectPoint[DCount].Height/2) +(TopEdgePoint[0].y+Margin)    );
					DDefectPoint[DCount].Rect.right  = (long)(DDefectPoint[DCount].Rect.left+ DDefectPoint[DCount].Width );
					DDefectPoint[DCount].Rect.bottom = (long)(DDefectPoint[DCount].Rect.top + DDefectPoint[DCount].Height);

					PixelCount = 0;
					PixelValue = 0;
					// 내부 Pixel Data 축출 
					for(int n=DDefectPoint[DCount].Rect.top+1 ; n<DDefectPoint[DCount].Rect.bottom-1; n++){
						for(int m=DDefectPoint[DCount].Rect.left+1; m<DDefectPoint[DCount].Rect.right-1 ; m++){
							PixelValue = IElement(m,n);
							if(PixelValue < EnCapTopThresHold) PixelCount++;
						}
					}
					// Display 데이터 필요함 
					DDefectPoint[DCount].Round = PixelCount;
					DDefectPoint[DCount].P.x       = (float)(DDefectPoint[DCount].Rect.left);
					DDefectPoint[DCount].P.y       = (float)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - DDefectPoint[DCount].Height/2)+(TopEdgePoint[0].y+Margin)+ImageHeight );
					DDefectPoint[DCount].Width     = DDefectPoint[DCount].Width+SideMargin; 

					// Merge 위해서 데이터 필요함 
					DDefectPoint[DCount].Rect.top    =(long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - DDefectPoint[DCount].Height/2) +(TopEdgePoint[0].y+Margin)+ImageHeight);
					DDefectPoint[DCount].Rect.bottom =(long)(DDefectPoint[DCount].Rect.top + DDefectPoint[DCount].Height);
					DCount++;
				}
			}
			BlobCount =0;

			// 외곽라인에서 Mark까지의 거리 산출 
			if     (Line[waLeftWall].FP0.x >Line[waLeftWall].FP1.x) LDistance = (FP0.x - (Line[waLeftWall].FP1.x+(Line[waLeftWall].FP0.x - Line[waLeftWall].FP1.x)/2));
			else if(Line[waLeftWall].FP0.x==Line[waLeftWall].FP1.x) LDistance = (FP0.x -  Line[waLeftWall].FP0.x)                                                     ;
			else                                                    LDistance = (FP0.x - (Line[waLeftWall].FP0.x+(Line[waLeftWall].FP1.x - Line[waLeftWall].FP0.x)/2)); 
		}


		// Cell Size 측정 데이터 넘겨줌(Image 회전 없을경우)
		LeftStaPos.x   =  FLTPoint.x            ;
		LeftStaPos.y   =  FLTPoint.y+ImageHeight;
		CenterStaPos.x =  FLTPoint.x + (FRTPoint.x - FLTPoint.x)/2            ; 
		CenterStaPos.y = (FLTPoint.y + FRTPoint.y)              /2+ImageHeight; 

		// FLTPoint,FRTPoint 기준 Image Rotate 적용하여 Display 목적으로 원본이미지 기준 좌표값 복원시킨
		if(ImgDegree!=0.0f){
			// 검사영역 분리과 상관없이 무조건 각도 적용하여 다시 계산해야 하는 좌표값들 
			// TopLine 
			Line[1].FP0 = Math.OnRotate(CenterPoint, Line[1].FP0  , (ImgDegree));
			Line[1].FP1 = Math.OnRotate(CenterPoint, Line[1].FP1  , (ImgDegree));

			// LeftOutLIne 
			LeftOutLine[0].FP0 = Math.OnRotate(CenterPoint, LeftOutLine[0].FP0  , (ImgDegree));
			LeftOutLine[0].FP1 = Math.OnRotate(CenterPoint, LeftOutLine[0].FP1  , (ImgDegree));

			// RightOutLIne 
			RightOutLine[0].FP0 = Math.OnRotate(CenterPoint, RightOutLine[0].FP0  , (ImgDegree));
			RightOutLine[0].FP1 = Math.OnRotate(CenterPoint, RightOutLine[0].FP1  , (ImgDegree));

			FRTPoint    = Math.OnRotate(CenterPoint, FRTPoint     , (ImgDegree));
			FLTPoint    = Math.OnRotate(CenterPoint, FLTPoint     , (ImgDegree));

			// Cell Size 측정 데이터 넘겨줌(Image  회전)
			LeftStaPos.x   =  FLTPoint.x            ;
			LeftStaPos.y   =  FLTPoint.y+ImageHeight;
			CenterStaPos.x =  FLTPoint.x + (FRTPoint.x - FLTPoint.x)/2            ; 
			CenterStaPos.y = (FLTPoint.y + FRTPoint.y)              /2+ImageHeight; 

			if(FCutMode==1){ // CAI_CUT 
				TopOutLine[0].FP0 = Math.OnRotate(CenterPoint, TopOutLine[0].FP0  , (ImgDegree));
				TopOutLine[0].FP1 = Math.OnRotate(CenterPoint, TopOutLine[0].FP1  , (ImgDegree));
				TopInLine [0].FP0 = Math.OnRotate(CenterPoint, TopInLine [0].FP0  , (ImgDegree));
				TopInLine [0].FP1 = Math.OnRotate(CenterPoint, TopInLine [0].FP1  , (ImgDegree));
			}

			if(IsCornerTop){
				FLTTPoint   = Math.OnRotate(CenterPoint, FLTTPoint    , (ImgDegree));
				FLTLPoint   = Math.OnRotate(CenterPoint, FLTLPoint    , (ImgDegree));
				FLTTInPoint = Math.OnRotate(CenterPoint, FLTTInPoint  , (ImgDegree));
				FLTLInPoint = Math.OnRotate(CenterPoint, FLTLInPoint  , (ImgDegree));
				FLTTMeaPoint= Math.OnRotate(CenterPoint, FLTTMeaPoint , (ImgDegree));
				FLTLMeaPoint= Math.OnRotate(CenterPoint, FLTLMeaPoint , (ImgDegree));

				FRTTPoint   = Math.OnRotate(CenterPoint, FRTTPoint    , (ImgDegree));
				FRTRPoint   = Math.OnRotate(CenterPoint, FRTRPoint    , (ImgDegree));
				FRTTInPoint = Math.OnRotate(CenterPoint, FRTTInPoint  , (ImgDegree));
				FRTRInPoint = Math.OnRotate(CenterPoint, FRTRInPoint  , (ImgDegree));
				FRTTMeaPoint= Math.OnRotate(CenterPoint, FRTTMeaPoint , (ImgDegree));
				FRTRMeaPoint= Math.OnRotate(CenterPoint, FRTRMeaPoint , (ImgDegree));

				// Corner Defect 좌표도 각도 적용하여 변경해야함 
				if(C1Count!=0){
					for(int k=0; k<C1Count; k++){
						// Fram기준 Y좌표값으로 원복한다 
						C1DefectPoint[k].P.y = C1DefectPoint[k].P.y - ImageHeight;
						if(C1DefectPoint[k].P.y>0) {
							C1DefectPoint[k].P   = Math.OnRotate(CenterPoint,C1DefectPoint[k].P,(ImgDegree)); 
							C1DefectPoint[k].P.y = C1DefectPoint[k].P.y + ImageHeight;
						}
						else {
							C1DefectPoint[k].P.y = C1DefectPoint[k].P.y + ImageHeight;
						}
					}
				}

				if(C2Count!=0){
					for(int k=0; k<C2Count; k++){
						// Fram기준 Y좌표값으로 원복한다 
						C2DefectPoint[k].P.y = C2DefectPoint[k].P.y - ImageHeight;
						if(C2DefectPoint[k].P.y>0) {
							C2DefectPoint[k].P   = Math.OnRotate(CenterPoint,C2DefectPoint[k].P,(ImgDegree)); 
							C2DefectPoint[k].P.y = C2DefectPoint[k].P.y + ImageHeight;
						}
						else {
							C2DefectPoint[k].P.y = C2DefectPoint[k].P.y + ImageHeight;
						}
					}
				}

				// GrindMarkPoint Rotate 
				if(IsMarkBtm){
					for(int k=19; k<27; k++){
						LtPos.x =0.0f, LtPos.y=0.0f,RbPos.x=0.0f,RbPos.y=0.0f;
						if(GrindMarkRect[k].left==0 || GrindMarkRect[k].top==0 || GrindMarkRect[k].right==0 || GrindMarkRect[k].bottom==0 ) continue;

						LtPos.x = (float)GrindMarkRect[k].left  ;
						LtPos.y = (float)GrindMarkRect[k].top   ;
						RbPos.x = (float)GrindMarkRect[k].right ;
						RbPos.y = (float)GrindMarkRect[k].bottom;
						LtPos = Math.OnRotate(CenterPoint, LtPos,ImgDegree);
						RbPos = Math.OnRotate(CenterPoint, RbPos,ImgDegree);

						GrindMarkRect[k].left   = (long)LtPos.x;
						GrindMarkRect[k].top    = (long)LtPos.y;
						GrindMarkRect[k].right  = (long)RbPos.x;
						GrindMarkRect[k].bottom = (long)RbPos.y;
						if(GrindMarkPoint[k].x!=0.0f && GrindMarkPoint[k].y!=0.0f) {
							GrindMarkPoint[k] = Math.OnRotate(CenterPoint, GrindMarkPoint[k],ImgDegree);
						}
					}
				}
			}
			else if(IsCircleTop) { // Display 목적으로 월래 각도 기준으로 좌표값을 다시 회전 시켜야 한다   
				// A영역 Circle_Defect 좌표 이미지 기준 회전함
				if(A1CirDeftectCnt!=0){
					for(int k=0; k<A1CirDeftectCnt; k++){
						A1CirDefectPoint[k].P.y = A1CirDefectPoint[k].P.y - ImageHeight;
						if(A1CirDefectPoint[k].P.y>0) {
							A1CirDefectPoint[k].P   = Math.OnRotate(CenterPoint,A1CirDefectPoint[k].P,(ImgDegree)); 
							A1CirDefectPoint[k].P.y = A1CirDefectPoint[k].P.y + ImageHeight;
						}
						else {
							A1CirDefectPoint[k].P.y = A1CirDefectPoint[k].P.y + ImageHeight;
						}
					}
				}

				if(A2CirDeftectCnt!=0){
					// A영역 Circle_Defect 좌표 이미지 기준 회전함
					for(int k=0; k<A2CirDeftectCnt; k++){
						A2CirDefectPoint[k].P.y = A2CirDefectPoint[k].P.y - ImageHeight;
						if(A2CirDefectPoint[k].P.y>0) {
							A2CirDefectPoint[k].P   = Math.OnRotate(CenterPoint,A2CirDefectPoint[k].P,(ImgDegree)); 
							A2CirDefectPoint[k].P.y = A2CirDefectPoint[k].P.y + ImageHeight;
						}
						else {
							A2CirDefectPoint[k].P.y = A2CirDefectPoint[k].P.y + ImageHeight;
						}
					}
				}

				// Circle Defect Data 
				// Bright Defect Data 
				////////////////////////////////////////////////////////////////////////////////////////////////
				if(A1CirCrackCnt!=0){
					for(int k=0; k<A1CirCrackCnt; k++){
						A1CirCrackPoint[k].P.y = A1CirCrackPoint[k].P.y - ImageHeight;
						if(A1CirCrackPoint[k].P.y>0) {
							A1CirCrackPoint[k].P   = Math.OnRotate(CenterPoint,A1CirCrackPoint[k].P,(ImgDegree)); 
							A1CirCrackPoint[k].P.y = A1CirCrackPoint[k].P.y + ImageHeight;
						}
						else {
							A1CirCrackPoint[k].P.y = A1CirCrackPoint[k].P.y + ImageHeight;
						}
					}
				}

				if(A2CirCrackCnt!=0){
					for(int k=0; k<A2CirCrackCnt; k++){
						A2CirCrackPoint[k].P.y = A2CirCrackPoint[k].P.y - ImageHeight;
						if(A2CirCrackPoint[k].P.y>0) {
							A2CirCrackPoint[k].P   = Math.OnRotate(CenterPoint,A2CirCrackPoint[k].P,(ImgDegree)); 
							A2CirCrackPoint[k].P.y = A2CirCrackPoint[k].P.y + ImageHeight;
						}
						else {
							A2CirCrackPoint[k].P.y = A2CirCrackPoint[k].P.y + ImageHeight;
						}
					}
				}
				//////////////////////////////////////////////////////////////////////////////////////

				if(A1CirInEdgeCount!=0){
					for(int k=0; k<A1CirInEdgeCount; k++){
						if(A1CirInPoint[k].x==0.0f || A1CirInPoint[k].y==0.0f) continue;
						A1CirInPoint[k] = Math.OnRotate(CenterPoint, A1CirInPoint[k], ImgDegree);
					}
				}
				if(A1CirOutEdgeCount!=0){
					for(int k=0; k<A1CirOutEdgeCount; k++){
						if(A1CirOutPoint[k].x==0.0f || A1CirOutPoint[k].y==0.0f) continue;
						A1CirOutPoint[k] = Math.OnRotate(CenterPoint, A1CirOutPoint[k], ImgDegree);
					}
				}
// 				if(A1PolyInEdgeCount!=0){
// 					for(int k=0; k<A1PolyInEdgeCount; k++){
// 						if(A1PolyInPoint[k].x==0.0f || A1PolyInPoint[k].y==0.0f) continue;
// 						A1PolyInPoint[k] = Math.OnRotate(CenterPoint, A1PolyInPoint[k], ImgDegree);
// 					}
// 				}


				if(A1CirCenter      .x!=0.0f && A1CirCenter      .y!=0.0f) A1CirCenter        = Math.OnRotate(CenterPoint, A1CirCenter       , (ImgDegree)); // 외곽 교차점 기준  
				if(RealA1CirCenter  .x!=0.0f && RealA1CirCenter  .y!=0.0f) RealA1CirCenter    = Math.OnRotate(CenterPoint, RealA1CirCenter   , (ImgDegree)); // Euresys 
				if(ACircleFit1Center.x!=0.0f && ACircleFit1Center.y!=0.0f) ACircleFit1Center  = Math.OnRotate(CenterPoint, ACircleFit1Center , (ImgDegree)); // FAVION

				if(A2CirInEdgeCount!=0){
					for(int k=0; k<A2CirInEdgeCount; k++){
						if(A2CirInPoint[k].x==0.0f || A2CirInPoint[k].y==0.0f) continue;
						A2CirInPoint[k] = Math.OnRotate(CenterPoint, A2CirInPoint[k], ImgDegree);
					}
				}
				if(A2CirOutEdgeCount!=0){
					for(int k=0; k<A2CirOutEdgeCount; k++){
						if(A2CirOutPoint[k].x==0.0f || A2CirOutPoint[k].y==0.0f) continue;
						A2CirOutPoint[k] = Math.OnRotate(CenterPoint, A2CirOutPoint[k], ImgDegree);
					}
				}

				if(A2CirCenter      .x!=0.0f && A2CirCenter      .y!=0.0f) A2CirCenter        = Math.OnRotate(CenterPoint, A2CirCenter       , (ImgDegree)); // 외곽 교차점 기준  
				if(RealA2CirCenter  .x!=0.0f && RealA2CirCenter  .y!=0.0f) RealA2CirCenter    = Math.OnRotate(CenterPoint, RealA2CirCenter   , (ImgDegree)); // Euresys 
				if(ACircleFit2Center.x!=0.0f && ACircleFit2Center.y!=0.0f) ACircleFit2Center  = Math.OnRotate(CenterPoint, ACircleFit2Center , (ImgDegree)); // FAVION

				// GrindMarkPoint Rotate 
				if(IsMarkBtm){
					for(int k=19; k<27; k++){
						LtPos.x =0.0f, LtPos.y=0.0f,RbPos.x=0.0f,RbPos.y=0.0f;
						if(GrindMarkRect[k].left==0 || GrindMarkRect[k].top==0 || GrindMarkRect[k].right==0 || GrindMarkRect[k].bottom==0 ) continue;

						LtPos.x = (float)GrindMarkRect[k].left  ;
						LtPos.y = (float)GrindMarkRect[k].top   ;
						RbPos.x = (float)GrindMarkRect[k].right ;
						RbPos.y = (float)GrindMarkRect[k].bottom;
						LtPos = Math.OnRotate(CenterPoint, LtPos,ImgDegree);
						RbPos = Math.OnRotate(CenterPoint, RbPos,ImgDegree);

						GrindMarkRect[k].left   = (long)LtPos.x;
						GrindMarkRect[k].top    = (long)LtPos.y;
						GrindMarkRect[k].right  = (long)RbPos.x;
						GrindMarkRect[k].bottom = (long)RbPos.y;
						if(GrindMarkPoint[k].x!=0.0f && GrindMarkPoint[k].y!=0.0f) {
							GrindMarkPoint[k] = Math.OnRotate(CenterPoint, GrindMarkPoint[k],ImgDegree);
						}
					}
				}
			}
		}
		////////////////////////////////////////////////////////////////////////////////////////////////
		Index = 0;
		return true;

		// NOTCH RectC : 젓가락 모양
		//------------------------------------------------------------------
	case 11 :
		// Side B
		/////////////////////////////////////////////////////////////////////////////////////////////////
		//LogUnit.SetLog("STATIC_Side_B_START_CamId: %d, ImageHeight: %d ",CamId,ImageHeight);     
		DefectROI.SetPlacement((int)(RSP.x-FRightWidth-SideMargin), (int)RSP.y, FRightWidth, RightHeight);
		if((RSP.x-FRightWidth-SideMargin) <=0          ||(RSP.y)<0           || FRightWidth<=0          || RightHeight<0         )return false;
		if((RSP.x-FRightWidth-SideMargin) >=ImageWidth ||(RSP.y)>ImageHeight || FRightWidth>=ImageWidth || RightHeight>ImageHeight)return false;
		if((RSP.x-FRightWidth-SideMargin)+FRightWidth >=ImageWidth ||(RSP.y)+RightHeight>ImageHeight                             )return false;
		//Line Position
		LinePosition = RSP.x-FRightWidth-SideMargin;
		// Blob 검사 진행함 
		CodeImageSelection.Clear();
		CodeImageEncoder.Encode(DefectROI,CodeImage);
		CodeImageSelection.Clear();
		CodeImageSelection.AddObjects(CodeImage);
		// Blob 필터링 
		CodeImageSelection.RemoveUsingFloatFeature  (EFeature_BoundingBoxWidth ,FMinWidth    , FMaxWidth     , EDoubleThresholdMode_Outside);
		CodeImageSelection.RemoveUsingFloatFeature  (EFeature_BoundingBoxHeight,FMinHeight   , FMaxHeight    , EDoubleThresholdMode_Outside);
		CodeImageSelection.RemoveUsingIntegerFeature(EFeature_RightLimit       ,FRightWidth-1, FRightWidth+1 , EDoubleThresholdMode_Outside);

		BlobCount = CodeImageSelection.GetElementCount();
		CodeImageSelection.Sort(EFeature_TopLimit,ESortDirection_Ascending);

		if(BlobCount!=0){
			for(int k=0; k<BlobCount; k++){
				if(BCount>=MAX_DEFECT_POINT) break; 
				BDefectPoint[BCount].Width  = CodeImageSelection.GetElement(k).GetBoundingBoxWidth();
				BDefectPoint[BCount].Height = CodeImageSelection.GetElement(k).GetBoundingBoxHeight();

				BDefectPoint[BCount].Rect.left   =(long)(((CodeImageSelection.GetElement(k).GetBoundingBoxCenterX() - BDefectPoint[BCount].Width/2) +LinePosition));
				BDefectPoint[BCount].Rect.top    =(long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - BDefectPoint[BCount].Height/2)               );
				BDefectPoint[BCount].Rect.right  =(long)(BDefectPoint[BCount].Rect.left+ BDefectPoint[BCount].Width );
				BDefectPoint[BCount].Rect.bottom =(long)(BDefectPoint[BCount].Rect.top + BDefectPoint[BCount].Height);

				PixelCount = 0;
				PixelValue = 0;

				// 내부 Pixel Data 축출 
				for(int n=BDefectPoint[BCount].Rect.top+1 ; n<BDefectPoint[BCount].Rect.bottom-1; n++){
					for(int m=BDefectPoint[BCount].Rect.left+1; m<BDefectPoint[BCount].Rect.right-1 ; m++){
						PixelValue = IElement(m,n);
						if(PixelValue < EnCapMidThresHold) PixelCount++;
					}
				}

				BDefectPoint[BCount].Round  = PixelCount;
				BDefectPoint[BCount].P.x    =(float)(BDefectPoint[BCount].Rect.left);
				BDefectPoint[BCount].P.y    =(float)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - BDefectPoint[BCount].Height/2) +ImageHeight );
				BDefectPoint[BCount].Width  = (InspectMode)? BDefectPoint[BCount].Width :BDefectPoint[BCount].Width+SideMargin; 

				// Merge 위해서 데이터 필요함 
				BDefectPoint[BCount].Rect.top    =(long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - BDefectPoint[BCount].Height/2) +ImageHeight);
				BDefectPoint[BCount].Rect.bottom =(long)(BDefectPoint[BCount].Rect.top + BDefectPoint[BCount].Height);
				BCount++;
			}
		}
		BlobCount =0;
		//  		LogUnit.SetLog("STATIC_Side_B_END_CamId: %d, ImageHeight: %d ",CamId,ImageHeight);     
		// 외곽라인에서 Mark까지의 거리 산출 
		// CellSize 
		if     (Line[waRightWall].FP0.x >Line[waRightWall].FP1.x) RDistance = (Line[waRightWall].FP1.x+(Line[waRightWall].FP0.x - Line[waRightWall].FP1.x)/2) - FP1.x;
		else if(Line[waRightWall].FP0.x==Line[waRightWall].FP1.x) RDistance =  Line[waRightWall].FP0.x - FP1.x;
		else                                                      RDistance = (Line[waRightWall].FP0.x+(Line[waRightWall].FP1.x - Line[waRightWall].FP0.x)/2) - FP1.x;

		// SIDE-D
		DefectROI.SetPlacement((int)(LSP.x+SideMargin),(int)LSP.y, FLeftWidth, LeftHeight);
		if((LSP.x+SideMargin) <=0          || (LSP.y)<0           || FLeftWidth<=0          || LeftHeight<0          ) return false;
		if((LSP.x+SideMargin) >=ImageWidth || (LSP.y)>ImageHeight || FLeftWidth>=ImageWidth || LeftHeight>ImageHeight) return false;
		if((LSP.x+SideMargin)+FLeftWidth >=ImageWidth || (LSP.y)+LeftHeight>ImageHeight                              ) return false;
			// Line Position
		LinePosition = LSP.x+SideMargin;
		// Blob 검사 진행 
		CodeImageSelection.Clear();
		CodeImageEncoder.Encode(DefectROI,CodeImage);
		CodeImageSelection.Clear();
		CodeImageSelection.AddObjects(CodeImage);
		// Blob 필터링 
		CodeImageSelection.RemoveUsingFloatFeature(EFeature_BoundingBoxWidth ,FMinWidth , FMaxWidth  , EDoubleThresholdMode_Outside);
		CodeImageSelection.RemoveUsingFloatFeature(EFeature_BoundingBoxHeight,FMinHeight, FMaxHeight , EDoubleThresholdMode_Outside);
		CodeImageSelection.RemoveUsingIntegerFeature(EFeature_LeftLimit        ,0       , 1          , EDoubleThresholdMode_Outside);

		BlobCount = CodeImageSelection.GetElementCount();
		CodeImageSelection.Sort(EFeature_TopLimit,ESortDirection_Ascending);

		if(BlobCount!=0){
			for(int k=0; k<BlobCount; k++){
				if(DCount>=MAX_DEFECT_POINT) break; 
				DDefectPoint[DCount].Width  = CodeImageSelection.GetElement(k).GetBoundingBoxWidth() ;
				DDefectPoint[DCount].Height = CodeImageSelection.GetElement(k).GetBoundingBoxHeight();

				DDefectPoint[DCount].Rect.left   =(long)(((CodeImageSelection.GetElement(k).GetBoundingBoxCenterX() - DDefectPoint[DCount].Width/2 ) +LinePosition));
				DDefectPoint[DCount].Rect.top    =(long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - DDefectPoint[DCount].Height/2)                );
				DDefectPoint[DCount].Rect.right  =(long)(DDefectPoint[DCount].Rect.left+ DDefectPoint[DCount].Width) ; 
				DDefectPoint[DCount].Rect.bottom =(long)(DDefectPoint[DCount].Rect.top + DDefectPoint[DCount].Height);

				PixelCount =0;
				PixelValue =0;

				// 내부 Pixel Data 축출 
				for(int n=DDefectPoint[DCount].Rect.top+1 ; n<DDefectPoint[DCount].Rect.bottom-1; n++){
					for(int m=DDefectPoint[DCount].Rect.left+1; m<DDefectPoint[DCount].Rect.right-1 ; m++){
						PixelValue = IElement(m,n);
						if(PixelValue < EnCapMidThresHold) PixelCount++;
					}
				}

				DDefectPoint[DCount].Round = PixelCount;
				DDefectPoint[DCount].P.x    =(float)(DDefectPoint[DCount].Rect.left); 
				DDefectPoint[DCount].P.y    =(float)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - DDefectPoint[DCount].Height/2)+ImageHeight  );
				DDefectPoint[DCount].Width  = (InspectMode)? DDefectPoint[DCount].Width :DDefectPoint[DCount].Width+SideMargin; 

				// Merge 위해서 데이터 필요함 
				DDefectPoint[DCount].Rect.top    =(long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - DDefectPoint[DCount].Height/2)+ImageHeight);
				DDefectPoint[DCount].Rect.bottom =(long)(DDefectPoint[DCount].Rect.top + DDefectPoint[DCount].Height);
				DCount++;
			}
		}
		BlobCount =0;
		//  		LogUnit.SetLog("STATIC_Side_D_END_CamId: %d, ImageHeight: %d ",CamId,ImageHeight);     
		// Notch Cell Size Calc
		if(LSP.x!=0.0f  && RSP.x!=0.0f ){
            CenterCellSize = Math.GetLengthFrPointToPoint(LSP,RSP);
		    TotalCellSizeWidth+=CenterCellSize;
			TotalCellSizeCount++;
		}
		// 외곽라인에서 Mark까지의 거리 산출 
		// CellSize 
		if     (Line[waLeftWall].FP0.x >Line[waLeftWall].FP1.x) LDistance = FP0.x - (Line[waLeftWall].FP1.x+(Line[waLeftWall].FP0.x - Line[waLeftWall].FP1.x)/2);
		else if(Line[waLeftWall].FP0.x==Line[waLeftWall].FP1.x) LDistance = FP0.x -  Line[waLeftWall].FP0.x;
		else                                                    LDistance = FP0.x - (Line[waLeftWall].FP0.x+(Line[waLeftWall].FP1.x - Line[waLeftWall].FP0.x)/2); 
		////////////////////////////////////////////////////////////////////////////////////////////////

		// Broken 및 박리 불량 검사 시퀀스(EnCap만 진행함)
		if(!IsMarkBtm && BrokenThresHold!=0){
			RotateBrokenImg.SetSize(GImage->GetWidth(), GImage->GetHeight())       ;
			EasyImage::Oper(EArithmeticLogicOperation_Copy,GImage,&RotateBrokenImg);
			EasyImage::Threshold(GImage    ,&RotateBrokenImg, BrokenThresHold)     ;

			DefectROI.Attach(&RotateBrokenImg);
			CodeImageSelection.SetFeretAngle(0.00f);
			CodeImageEncoder.GetGrayscaleSingleThresholdSegmenter().SetWhiteLayerEncoded(true );
			CodeImageEncoder.GetGrayscaleSingleThresholdSegmenter().SetBlackLayerEncoded(false);
			IAddress = RotateBrokenImg.GetImagePtr();

			FRightWidth = 60; // 테스트 목적
			FLeftWidth  = 60; // 테스트 목적

			// Side_B Bright Defect 검출 및 분류(Broken,반원형 박리___꽃박리)
			/////////////////////////////////////////////////////////////////////////////////////////////////
			DefectROI.SetPlacement((int)(RSP.x-FRightWidth-SideMargin), (int)RSP.y, FRightWidth, RightHeight);
			if((RSP.x-FRightWidth-SideMargin) <=0          ||(RSP.y)<0           || FRightWidth<=0          || RightHeight<0          )return false;
			if((RSP.x-FRightWidth-SideMargin) >=ImageWidth ||(RSP.y)>ImageHeight || FRightWidth>=ImageWidth || RightHeight>ImageHeight)return false;
			if((RSP.x-FRightWidth-SideMargin)+FRightWidth >=ImageWidth ||(RSP.y)+RightHeight>ImageHeight                              )return false;
			//Line Position
			LinePosition = RSP.x-FRightWidth-SideMargin;
			// Blob 검사 진행함 
			CodeImageSelection.Clear();
			CodeImageEncoder.Encode(DefectROI,CodeImage);
			CodeImageSelection.Clear();
			CodeImageSelection.AddObjects(CodeImage);
			// Blob 필터링 
			CodeImageSelection.RemoveUsingFloatFeature  (EFeature_BoundingBoxWidth ,FMinWidth    , FMaxWidth     , EDoubleThresholdMode_Outside);
			CodeImageSelection.RemoveUsingFloatFeature  (EFeature_BoundingBoxHeight,FMinHeight   , FMaxHeight    , EDoubleThresholdMode_Outside);
// 			CodeImageSelection.RemoveUsingIntegerFeature(EFeature_RightLimit       ,FRightWidth-1, FRightWidth+1 , EDoubleThresholdMode_Outside);

			BlobCount = CodeImageSelection.GetElementCount();
			CodeImageSelection.Sort(EFeature_TopLimit,ESortDirection_Ascending);

			if(BlobCount!=0){
				for(int k=0; k<BlobCount; k++){
					if(BCount>=MAX_DEFECT_POINT) break; 
					BCrackPoint[BCrackCount].Width  = CodeImageSelection.GetElement(k).GetBoundingBoxWidth();
					BCrackPoint[BCrackCount].Height = CodeImageSelection.GetElement(k).GetBoundingBoxHeight();

					BCrackPoint[BCrackCount].Rect.left   =(long)(((CodeImageSelection.GetElement(k).GetBoundingBoxCenterX() - BCrackPoint[BCrackCount].Width/2) +LinePosition));
					BCrackPoint[BCrackCount].Rect.top    =(long)(( CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - BCrackPoint[BCrackCount].Height/2)              );
					BCrackPoint[BCrackCount].Rect.right  =(long)(BCrackPoint[BCrackCount].Rect.left+ BCrackPoint[BCrackCount].Width );
					BCrackPoint[BCrackCount].Rect.bottom =(long)(BCrackPoint[BCrackCount].Rect.top + BCrackPoint[BCrackCount].Height);
					BCrackPoint[BCrackCount].LineAttach  =((CodeImageSelection.GetElement(k).GetRightLimit() > (FRightWidth-5))>0)? 1:0; //LineAttach:1 반원형 박리, 0: 꽃박리 

					PixelCount = 0;
					PixelValue = 0;

					// 내부 Pixel Data 축출 
					for(int n=BCrackPoint[BCrackCount].Rect.top+1 ; n<BCrackPoint[BCrackCount].Rect.bottom-1; n++){
						for(int m=BCrackPoint[BCrackCount].Rect.left+1; m<BCrackPoint[BCrackCount].Rect.right-1 ; m++){
							PixelValue = IElement(m,n);
							if(PixelValue > BrokenThresHold) PixelCount++;
						}
					}

					BCrackPoint[BCrackCount].Round  = PixelCount;
					BCrackPoint[BCrackCount].P.x    =(float)(BCrackPoint[BCrackCount].Rect.left);
					BCrackPoint[BCrackCount].P.y    =(float)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - BCrackPoint[BCrackCount].Height/2) +ImageHeight );
					BCrackPoint[BCrackCount].Width  = (InspectMode)? BCrackPoint[BCrackCount].Width :BCrackPoint[BCrackCount].Width+SideMargin; 

					// Merge 위해서 데이터 필요함 
					BCrackPoint[BCrackCount].Rect.top    =(long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - BCrackPoint[BCrackCount].Height/2) +ImageHeight);
					BCrackPoint[BCrackCount].Rect.bottom =(long)(BCrackPoint[BCrackCount].Rect.top + BCrackPoint[BCrackCount].Height);
					BCrackCount++;
				}
			}
			BlobCount =0;

			// Side_D Bright Defect 검출 및 분류(Broken,반원형 박리___꽃박리)
			/////////////////////////////////////////////////////////////////////////////////////////////////
			DefectROI.SetPlacement((int)(LSP.x+SideMargin),(int)LSP.y, FLeftWidth, LeftHeight);
			if((LSP.x+SideMargin) <=0          || (LSP.y)<0           || FLeftWidth<=0          || LeftHeight<0          ) return false;
			if((LSP.x+SideMargin) >=ImageWidth || (LSP.y)>ImageHeight || FLeftWidth>=ImageWidth || LeftHeight>ImageHeight) return false;
			if((LSP.x+SideMargin)+FLeftWidth >=ImageWidth || (LSP.y)+LeftHeight>ImageHeight                              ) return false;
			// Line Position
			LinePosition = LSP.x+SideMargin;
			// Blob 검사 진행 
			CodeImageSelection.Clear();
			CodeImageEncoder.Encode(DefectROI,CodeImage);
			CodeImageSelection.Clear();
			CodeImageSelection.AddObjects(CodeImage);
			// Blob 필터링 
			CodeImageSelection.RemoveUsingFloatFeature(EFeature_BoundingBoxWidth ,FMinWidth , FMaxWidth  , EDoubleThresholdMode_Outside);
			CodeImageSelection.RemoveUsingFloatFeature(EFeature_BoundingBoxHeight,FMinHeight, FMaxHeight , EDoubleThresholdMode_Outside);
// 			CodeImageSelection.RemoveUsingIntegerFeature(EFeature_LeftLimit        ,0       , 1          , EDoubleThresholdMode_Outside);

			BlobCount = CodeImageSelection.GetElementCount();
			CodeImageSelection.Sort(EFeature_TopLimit,ESortDirection_Ascending);

			if(BlobCount!=0){
				for(int k=0; k<BlobCount; k++){
					if(BCount>=MAX_DEFECT_POINT) break; 
					DCrackPoint[DCrackCount].Width  = CodeImageSelection.GetElement(k).GetBoundingBoxWidth();
					DCrackPoint[DCrackCount].Height = CodeImageSelection.GetElement(k).GetBoundingBoxHeight();

					DCrackPoint[DCrackCount].Rect.left   =(long)(((CodeImageSelection.GetElement(k).GetBoundingBoxCenterX() - DCrackPoint[DCrackCount].Width/2) +LinePosition));
					DCrackPoint[DCrackCount].Rect.top    =(long)(( CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - DCrackPoint[DCrackCount].Height/2)              );
					DCrackPoint[DCrackCount].Rect.right  =(long)(DCrackPoint[DCrackCount].Rect.left+ DCrackPoint[DCrackCount].Width );
					DCrackPoint[DCrackCount].Rect.bottom =(long)(DCrackPoint[DCrackCount].Rect.top + DCrackPoint[DCrackCount].Height);
					DCrackPoint[DCrackCount].LineAttach  =(CodeImageSelection.GetElement(k).GetLeftLimit() < 5)? 1:0; //LineAttach:1 반원형 박리, 0: 꽃박리 

					PixelCount = 0;
					PixelValue = 0;

					// 내부 Pixel Data 축출 
					for(int n=DCrackPoint[DCrackCount].Rect.top+1 ; n<DCrackPoint[DCrackCount].Rect.bottom-1; n++){
						for(int m=DCrackPoint[DCrackCount].Rect.left+1; m<DCrackPoint[DCrackCount].Rect.right-1 ; m++){
							PixelValue = IElement(m,n);
							if(PixelValue > BrokenThresHold) PixelCount++;
						}
					}

					DCrackPoint[DCrackCount].Round  = PixelCount;
					DCrackPoint[DCrackCount].P.x    =(float)(DCrackPoint[DCrackCount].Rect.left);
					DCrackPoint[DCrackCount].P.y    =(float)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - DCrackPoint[DCrackCount].Height/2) +ImageHeight );
					DCrackPoint[DCrackCount].Width  = (InspectMode)? DCrackPoint[DCrackCount].Width :DCrackPoint[DCrackCount].Width+SideMargin; 

					// Merge 위해서 데이터 필요함 
					DCrackPoint[DCrackCount].Rect.top    =(long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - DCrackPoint[DCrackCount].Height/2) +ImageHeight);
					DCrackPoint[DCrackCount].Rect.bottom =(long)(DCrackPoint[DCrackCount].Rect.top + DCrackPoint[DCrackCount].Height);
					DCrackCount++;
				}
			}
			BlobCount =0;
		}
		Index = 0;
		return true;

		// NOTCH RectC : 컵모양
		//------------------------------------------------------------------
	case 12 :

		if(IsCornerBtm)     { //Corner Cutting 일경우 Defect 검사 시퀀스 
			if(C3InEdgeCount!=0){
				CornerCount=0;
				for(int k=0; k<C3InEdgeCount; k++){
					if(C3InPoint[k].y<FLBLPoint.y-1) continue;
					Dis = Math.GetLengthFrLineToPoint(FLBLInPoint, FLBBInPoint, C3InPoint[k]);
					C3Corner[CornerCount].Dv   = Dis         ;
					C3Corner[CornerCount].P.x  = C3InPoint[k].x;
					C3Corner[CornerCount].P.y  = C3InPoint[k].y;
					CornerCount++;
				}
				C3Count = GetSize(C3Corner, C3DefectPoint, CornerCount, 5);
			}

			if(C4InEdgeCount!=0){
				CornerCount=0;
				for(int k=0; k<C4InEdgeCount; k++){
					if(C4InPoint[k].y<FRBRPoint.y-1) continue;
					Dis = Math.GetLengthFrLineToPoint(FRBRInPoint, FRBBInPoint, C4InPoint[k]);
					C4Corner[CornerCount].Dv   = Dis         ;
					C4Corner[CornerCount].P.x  = C4InPoint[k].x;
					C4Corner[CornerCount].P.y  = C4InPoint[k].y;
					CornerCount++;
				}
				C4Count = GetSize(C4Corner, C4DefectPoint, CornerCount, 5);
			}
			// Side D 
			///////////////////////////////////////////////////////////////////////////////////////////////////////////////
			//LogUnit.SetLog("CUP_Side_D_Start_CamId: %d, ImageHeight: %d ",CamId,ImageHeight);     
			DefectROI.SetPlacement((int)(SP.x+SideMargin),(int)(SP.y+BtmMargin), FLeftWidth, LeftHeight-(2*BtmMargin));
			if((SP.x+SideMargin) <=0          || SP.y+BtmMargin< 0            || FLeftWidth<=0          || LeftHeight-(2*BtmMargin)< 0           ) return false;
			if((SP.x+SideMargin) >=ImageWidth || SP.y+BtmMargin> BtmLimitLine || FLeftWidth>=ImageWidth || LeftHeight-(2*BtmMargin)> BtmLimitLine) return false;
			if((SP.x+SideMargin)+FLeftWidth >=ImageWidth || (SP.y+BtmMargin)+(LeftHeight-(2*BtmMargin))> BtmLimitLine                            ) return false;

			// Line Position 
			LinePosition = SP.x+SideMargin;
			// Blob 검사 진행 
			CodeImageSelection.Clear();
			CodeImageEncoder.Encode(DefectROI,CodeImage);
			CodeImageSelection.Clear();
			CodeImageSelection.AddObjects(CodeImage);
			// Blob 필터링 
			CodeImageSelection.RemoveUsingFloatFeature(EFeature_BoundingBoxWidth ,FMinWidth , FMaxWidth  , EDoubleThresholdMode_Outside);
			CodeImageSelection.RemoveUsingFloatFeature(EFeature_BoundingBoxHeight,FMinHeight, FMaxHeight , EDoubleThresholdMode_Outside);
			// 				CodeImageSelection.RemoveUsingIntegerFeature(EFeature_LeftLimit        ,0       , 3          , EDoubleThresholdMode_Outside);
			CodeImageSelection.RemoveUsingIntegerFeature(EFeature_LeftLimit        ,0       , 1          , EDoubleThresholdMode_Outside);

			BlobCount = CodeImageSelection.GetElementCount();
			CodeImageSelection.Sort(EFeature_TopLimit,ESortDirection_Ascending);

			if(BlobCount!=0){
				for(int k=0; k<BlobCount; k++){
					if(DCount>=MAX_DEFECT_POINT) break;
					DDefectPoint[DCount].Width  =  CodeImageSelection.GetElement(k).GetBoundingBoxWidth() ;
					DDefectPoint[DCount].Height =  CodeImageSelection.GetElement(k).GetBoundingBoxHeight();

					DDefectPoint[DCount].Rect.left   =(long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterX() - DDefectPoint[DCount].Width/2 ) +LinePosition );
					DDefectPoint[DCount].Rect.top    =(long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - DDefectPoint[DCount].Height/2)+(SP.y+BtmMargin));
					DDefectPoint[DCount].Rect.right  =(long)(DDefectPoint[DCount].Rect.left+ DDefectPoint[DCount].Width );
					DDefectPoint[DCount].Rect.bottom =(long)(DDefectPoint[DCount].Rect.top + DDefectPoint[DCount].Height);
					PixelCount =0;
					PixelValue =0;

					// 내부 Pixel Data 축출 
					for(int n=DDefectPoint[DCount].Rect.top+1 ; n<DDefectPoint[DCount].Rect.bottom-1; n++){
						for(int m=DDefectPoint[DCount].Rect.left+1; m<DDefectPoint[DCount].Rect.right-1 ; m++){
							PixelValue = IElement(m,n);
							if(PixelValue < EnCapBtmThresHold) PixelCount++;
						}
					}

					DDefectPoint[DCount].Round = PixelCount;
					DDefectPoint[DCount].P.x    =(float)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterX() - DDefectPoint[DCount].Width/2 ) +LinePosition);
					DDefectPoint[DCount].P.y    =(float)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - DDefectPoint[DCount].Height/2)+(SP.y+BtmMargin)+ImageHeight);
					DDefectPoint[DCount].Width  = (InspectMode)?DDefectPoint[DCount].Width: DDefectPoint[DCount].Width+SideMargin;

					// Merge 위해서 데이터 필요함 
					DDefectPoint[DCount].Rect.top    =(long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - DDefectPoint[DCount].Height/2) +(SP.y+BtmMargin)+ImageHeight);
					DDefectPoint[DCount].Rect.bottom =(long)(DDefectPoint[DCount].Rect.top + DDefectPoint[DCount].Height);
					DCount++;
				}
			}
			BlobCount=0;
			// 외곽라인에서 Mark까지의 거리 산출 
			if     (Line[waLeftWall].FP0.x >Line[waLeftWall].FP1.x) LDistance = FP0.x - (Line[waLeftWall].FP1.x+(Line[waLeftWall].FP0.x - Line[waLeftWall].FP1.x)/2);
			else if(Line[waLeftWall].FP0.x==Line[waLeftWall].FP1.x) LDistance = FP0.x -  Line[waLeftWall].FP0.x;
			else                                                    LDistance = FP0.x - (Line[waLeftWall].FP0.x+(Line[waLeftWall].FP1.x - Line[waLeftWall].FP0.x)/2); 
			////////////////////////////////////////////////////////////////////////////////////////////////


			// Side B
			////////////////////////////////////////////////////////////////////////////////////////////////
			DefectROI.SetPlacement((int)(EP.x-FRightWidth-SideMargin),(int)(EP.y+BtmMargin), FRightWidth,  RightHeight-(2*BtmMargin));
			if((EP.x-FRightWidth-SideMargin) <=0          || (EP.y+BtmMargin)< 0            || FRightWidth<=0           || RightHeight-(2*BtmMargin)< 0           ) return false;
			if((EP.x-FRightWidth-SideMargin) >=ImageWidth || (EP.y+BtmMargin)> BtmLimitLine || FRightWidth>=ImageWidth  || RightHeight-(2*BtmMargin)> BtmLimitLine) return false;
			if((EP.x-FRightWidth-SideMargin)+FRightWidth >=ImageWidth || (EP.y+BtmMargin)+(RightHeight-(2*BtmMargin))> BtmLimitLine                               ) return false;

			// Line Position 
			LinePosition = EP.x - FRightWidth- SideMargin;
			// Blob 검사 진행 
			CodeImageSelection.Clear();
			CodeImageEncoder.Encode(DefectROI,CodeImage);
			CodeImageSelection.Clear();
			CodeImageSelection.AddObjects(CodeImage);
			// Blob 필터링 
			CodeImageSelection.RemoveUsingFloatFeature  (EFeature_BoundingBoxWidth ,FMinWidth               , FMaxWidth                , EDoubleThresholdMode_Outside);
			CodeImageSelection.RemoveUsingFloatFeature  (EFeature_BoundingBoxHeight,FMinHeight              , FMaxHeight               , EDoubleThresholdMode_Outside);
			CodeImageSelection.RemoveUsingIntegerFeature(EFeature_RightLimit     ,FRightWidth -1            , FRightWidth+1            , EDoubleThresholdMode_Outside);

			BlobCount = CodeImageSelection.GetElementCount();
			CodeImageSelection.Sort(EFeature_TopLimit,ESortDirection_Ascending);

			if(BlobCount!=0){
				for(int k=0; k<BlobCount; k++){
					if(BCount>=MAX_DEFECT_POINT) break;
					BDefectPoint[BCount].Width  = CodeImageSelection.GetElement(k).GetBoundingBoxWidth() ; 
					BDefectPoint[BCount].Height = CodeImageSelection.GetElement(k).GetBoundingBoxHeight();

					BDefectPoint[BCount].Rect.left   =(long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterX() - BDefectPoint[BCount].Width/2 ) +(LinePosition)  );
					BDefectPoint[BCount].Rect.top    =(long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - BDefectPoint[BCount].Height/2) +(EP.y+BtmMargin));
					BDefectPoint[BCount].Rect.right  =(long)(BDefectPoint[BCount].Rect.left+ BDefectPoint[BCount].Width );
					BDefectPoint[BCount].Rect.bottom =(long)(BDefectPoint[BCount].Rect.top + BDefectPoint[BCount].Height);
					PixelCount = 0;
					PixelValue = 0;

					// 내부 Pixel Data 축출 
					for(int n=BDefectPoint[BCount].Rect.top+1 ; n<BDefectPoint[BCount].Rect.bottom-1; n++){
						for(int m=BDefectPoint[BCount].Rect.left+1; m<BDefectPoint[BCount].Rect.right-1 ; m++){
							PixelValue = IElement(m,n);
							if(PixelValue < EnCapBtmThresHold) PixelCount++;
						}
					}
					BDefectPoint[BCount].Round  = PixelCount;
					BDefectPoint[BCount].P.x    =(float)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterX() - BDefectPoint[BCount].Width/2 )+(LinePosition));
					BDefectPoint[BCount].P.y    =(float)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - BDefectPoint[BCount].Height/2)+(EP.y+BtmMargin)+ImageHeight   );
					BDefectPoint[BCount].Width  =(InspectMode)? BDefectPoint[BCount].Width: BDefectPoint[BCount].Width+SideMargin;

					// Merge 위해서 데이터 필요함 
					BDefectPoint[BCount].Rect.top    =(long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - BDefectPoint[BCount].Height/2) +(EP.y+BtmMargin)+ImageHeight);
					BDefectPoint[BCount].Rect.bottom =(long)(BDefectPoint[BCount].Rect.top + BDefectPoint[BCount].Height);
					BCount++;
				}
			}
			BlobCount =0;
			// 외곽라인에서 Mark까지의 거리 산출 
			if     (Line[waRightWall].FP0.x >Line[waRightWall].FP1.x) RDistance = (Line[waRightWall].FP1.x+(Line[waRightWall].FP0.x - Line[waRightWall].FP1.x)/2) - FP1.x;
			else if(Line[waRightWall].FP0.x==Line[waRightWall].FP1.x) RDistance =  Line[waRightWall].FP0.x - FP1.x;
			else                                                      RDistance = (Line[waRightWall].FP0.x+(Line[waRightWall].FP1.x - Line[waRightWall].FP0.x)/2) - FP1.x;
			////////////////////////////////////////////////////////////////////////////////////////////////
            // SIDE C 
			// Btm검사시 오버킬을 줄위기 위해서 
			if(fabs(FLBBPoint.y - FRBBPoint.y)>3) BTMLine = (FLBBPoint.y > FRBBPoint.y) ?(int)FRBBPoint.y : (int)FLBBPoint.y ;
			else                                  BTMLine = (FLBBPoint.y > FRBBPoint.y) ?(int)FLBBPoint.y : (int)FRBBPoint.y ;

			DefectROI.SetPlacement((int)FLBBPoint.x+SideMargin, (int)(BTMLine-FBtmHeight), BtmWidth -(2*SideMargin), FBtmHeight);
			if((FLBBPoint.x+SideMargin) <=0          ||(BTMLine-FBtmHeight)< 0            || BtmWidth -(2*SideMargin)<=0          || FBtmHeight< 0           ) return false;
			if((FLBBPoint.x+SideMargin) >=ImageWidth ||(BTMLine-FBtmHeight)> BtmLimitLine || BtmWidth -(2*SideMargin)>=ImageWidth || FBtmHeight> BtmLimitLine) return false;
			if((FLBBPoint.x+SideMargin)+(BtmWidth -(2*SideMargin)) >=ImageWidth ||(BTMLine-FBtmHeight)+FBtmHeight> BtmLimitLine                              ) return false;

			//if(BtmLimitLine!=0){
			//	if(((BtmBMLine[0].FP0.y+BtmBMLine[0].FP1.y)/2+BtmOffset)>BtmLimitLine) return false;
			//}

			CodeImageSelection.Clear();
			CodeImageEncoder.Encode(DefectROI,CodeImage);
			CodeImageSelection.Clear();
			CodeImageSelection.AddObjects(CodeImage);
			// Blob 필터링 
			CodeImageSelection.RemoveUsingFloatFeature  (EFeature_BoundingBoxWidth ,FMinWidth      , FMaxWidth   , EDoubleThresholdMode_Outside);
			CodeImageSelection.RemoveUsingFloatFeature  (EFeature_BoundingBoxHeight,FMinHeight     , FMaxHeight  , EDoubleThresholdMode_Outside);
			CodeImageSelection.RemoveUsingIntegerFeature(EFeature_BottomLimit      ,FBtmHeight-1   , FBtmHeight+1, EDoubleThresholdMode_Outside);


			BlobCount = CodeImageSelection.GetElementCount();
			CodeImageSelection.Sort(EFeature_LeftLimit ,ESortDirection_Ascending);

			if(BlobCount!=0){
				for(int k=0; k<BlobCount; k++){
					if(CCount>=MAX_DEFECT_POINT) break; 
					CDefectPoint[CCount].Width  =  CodeImageSelection.GetElement(k).GetBoundingBoxWidth() ;
					CDefectPoint[CCount].Height =  CodeImageSelection.GetElement(k).GetBoundingBoxHeight();

					CDefectPoint[CCount].Rect.left   =(long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterX() - CDefectPoint[CCount].Width/2 ) +FLBBPoint.x+SideMargin);
					// 						CDefectPoint[CCount].Rect.top    =(long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - CDefectPoint[CCount].Height/2) +((FLBBPoint.y+FRBBPoint.y)/2-FBtmHeight-1));
					CDefectPoint[CCount].Rect.top    =(long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - CDefectPoint[CCount].Height/2) +(BTMLine-FBtmHeight));
					CDefectPoint[CCount].Rect.right  =(long)(CDefectPoint[CCount].Rect.left+ CDefectPoint[CCount].Width );
					CDefectPoint[CCount].Rect.bottom =(long)(CDefectPoint[CCount].Rect.top + CDefectPoint[CCount].Height);
					PixelCount = 0;
					PixelValue = 0;

					// 내부 Pixel Data 축출 
					for(int n=CDefectPoint[CCount].Rect.top+1 ; n<CDefectPoint[CCount].Rect.bottom-1; n++){
						for(int m=CDefectPoint[CCount].Rect.left+1; m<CDefectPoint[CCount].Rect.right-1 ; m++){
							PixelValue = IElement(m,n);
							if(PixelValue < EnCapBtmThresHold) PixelCount++;
						}
					}
					CDefectPoint[CCount].Round  =  PixelCount;
					CDefectPoint[CCount].P.x    = (float)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterX() - CDefectPoint[CCount].Width/2 )+FLBBPoint.x+SideMargin);
					CDefectPoint[CCount].P.y    = (float)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - CDefectPoint[CCount].Height/2)+(BTMLine-FBtmHeight)  );

					if(ImgDegree!=0.0f){
						CDefectPoint[CCount].P = Math.OnRotate(CenterPoint,CDefectPoint[CCount].P, ImgDegree);
					}
					CDefectPoint[CCount].P.y    = (float)(CDefectPoint[CCount].P.y +ImageHeight);

					// Merge 위해서 데이터 필요함 
					// 						CDefectPoint[CCount].Rect.top    =(long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - CDefectPoint[CCount].Height/2) +((FLBBPoint.y+FRBBPoint.y)/2-FBtmHeight-1)+ImageHeight);
					CDefectPoint[CCount].Rect.top    =(long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - CDefectPoint[CCount].Height/2) +(BTMLine-FBtmHeight)+ImageHeight);
					CDefectPoint[CCount].Rect.bottom =(long)(CDefectPoint[CCount].Rect.top + CDefectPoint[CCount].Height);
					CCount++;
				}
			}
			BlobCount =0;
		}
		else if(IsRectBtm)  { //직사각형 경우 Defect 검사 시퀀스 
			// SIDE D 
            ////////////////////////////////////////////////////////////////////////////////////////////////
			DefectROI.SetPlacement((int)(SP.x+SideMargin),(int)(SP.y+BtmMargin), FLeftWidth, LeftHeight-(2*BtmMargin));
			if((SP.x+SideMargin) <=0          || (SP.y+BtmMargin)<0            || FLeftWidth<=0          || LeftHeight-(2*BtmMargin)<  0           ) return false;
			if((SP.x+SideMargin) >=ImageWidth || (SP.y+BtmMargin)>BtmLimitLine || FLeftWidth>=ImageWidth || LeftHeight-(2*BtmMargin)>  BtmLimitLine) return false;
			if((SP.x+SideMargin)+FLeftWidth >=ImageWidth || (SP.y+BtmMargin)+(LeftHeight-(2*BtmMargin))> BtmLimitLine                              ) return false;
			// Line Position
			LinePosition = SP.x+SideMargin;

			CodeImageSelection.Clear();
			CodeImageEncoder.Encode(DefectROI,CodeImage);
			CodeImageSelection.Clear();
			CodeImageSelection.AddObjects(CodeImage);
			// Blob 필터링 
			CodeImageSelection.RemoveUsingFloatFeature(EFeature_BoundingBoxWidth ,FMinWidth , FMaxWidth  , EDoubleThresholdMode_Outside);
			CodeImageSelection.RemoveUsingFloatFeature(EFeature_BoundingBoxHeight,FMinHeight, FMaxHeight , EDoubleThresholdMode_Outside);
			// 			CodeImageSelection.RemoveUsingIntegerFeature(EFeature_LeftLimit        ,0       , 3          , EDoubleThresholdMode_Outside);
			CodeImageSelection.RemoveUsingIntegerFeature(EFeature_LeftLimit        ,0       , 2          , EDoubleThresholdMode_Outside);

			BlobCount = CodeImageSelection.GetElementCount();
			CodeImageSelection.Sort(EFeature_TopLimit,ESortDirection_Ascending);

			if(BlobCount!=0){
				for(int k=0; k<BlobCount; k++){
					if(DCount>=MAX_DEFECT_POINT) break; 
					DDefectPoint[DCount].Width  =  CodeImageSelection.GetElement(k).GetBoundingBoxWidth() ;
					DDefectPoint[DCount].Height =  CodeImageSelection.GetElement(k).GetBoundingBoxHeight();

					DDefectPoint[DCount].Rect.left   =(long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterX() - DDefectPoint[DCount].Width/2 ) +LinePosition);
					DDefectPoint[DCount].Rect.top    =(long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - DDefectPoint[DCount].Height/2) +(SP.y+BtmMargin));
					DDefectPoint[DCount].Rect.right  =(long)(DDefectPoint[DCount].Rect.left+ DDefectPoint[DCount].Width );
					DDefectPoint[DCount].Rect.bottom =(long)(DDefectPoint[DCount].Rect.top + DDefectPoint[DCount].Height);
					PixelCount =0;
					PixelValue =0;

					// 내부 Pixel Data 축출 
					for(int n=DDefectPoint[DCount].Rect.top+1 ; n<DDefectPoint[DCount].Rect.bottom-1; n++){
						for(int m=DDefectPoint[DCount].Rect.left+1; m<DDefectPoint[DCount].Rect.right-1 ; m++){
							PixelValue = IElement(m,n);
							if(PixelValue < EnCapBtmThresHold) PixelCount++;
						}
					}

					DDefectPoint[DCount].Round = PixelCount;
					DDefectPoint[DCount].P.x    =(float)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterX() - DDefectPoint[DCount].Width/2 ) +LinePosition   );
					DDefectPoint[DCount].P.y    =(float)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - DDefectPoint[DCount].Height/2)+(SP.y+BtmMargin)+ImageHeight     );

					// Merge 위해서 데이터 필요함 
					DDefectPoint[DCount].Rect.top    =(long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - DDefectPoint[DCount].Height/2) +(SP.y+BtmMargin)+ImageHeight);
					DDefectPoint[DCount].Rect.bottom =(long)(DDefectPoint[DCount].Rect.top + DDefectPoint[DCount].Height);
					DCount++;
				}
			}
			BlobCount=0;
			// 외곽라인에서 Mark까지의 거리 산출 
			//if     (Line[waLeftWall].FP0.x >Line[waLeftWall].FP1.x) LDistance = FP0.x - (Line[waLeftWall].FP1.x+(Line[waLeftWall].FP0.x - Line[waLeftWall].FP1.x)/2);
			//else if(Line[waLeftWall].FP0.x==Line[waLeftWall].FP1.x) LDistance = FP0.x -  Line[waLeftWall].FP0.x;
			//else                                                    LDistance = FP0.x - (Line[waLeftWall].FP0.x+(Line[waLeftWall].FP1.x - Line[waLeftWall].FP0.x)/2); 

			if     (Line[waLeftWall].FP0.x >Line[waLeftWall].FP1.x) LDistance = ((LeftBMLine[0].FP0.x+ LeftBMLine[0].FP1.x)/2) - (Line[waLeftWall].FP1.x+(Line[waLeftWall].FP0.x - Line[waLeftWall].FP1.x)/2);
			else if(Line[waLeftWall].FP0.x==Line[waLeftWall].FP1.x) LDistance = ((LeftBMLine[0].FP0.x+ LeftBMLine[0].FP1.x)/2) -  Line[waLeftWall].FP0.x;
			else                                                    LDistance = ((LeftBMLine[0].FP0.x+ LeftBMLine[0].FP1.x)/2) - (Line[waLeftWall].FP0.x+(Line[waLeftWall].FP1.x - Line[waLeftWall].FP0.x)/2); 
			////////////////////////////////////////////////////////////////////////////////////////////////

			// SIDE B
			////////////////////////////////////////////////////////////////////////////////////////////////
			DefectROI.SetPlacement((int)(EP.x-FRightWidth-SideMargin),(int)(EP.y+BtmMargin), FRightWidth, RightHeight-(2*BtmMargin));
			if((EP.x-FRightWidth-SideMargin) <=0          || (EP.y+BtmMargin)<0            || FRightWidth<=0          || RightHeight-(2*BtmMargin)< 0           ) return false;
			if((EP.x-FRightWidth-SideMargin) >=ImageWidth || (EP.y+BtmMargin)>BtmLimitLine || FRightWidth>=ImageWidth || RightHeight-(2*BtmMargin)> BtmLimitLine) return false;
			if((EP.x-FRightWidth-SideMargin)+FRightWidth >=ImageWidth || (EP.y+BtmMargin)+(RightHeight-(2*BtmMargin))>BtmLimitLine                              ) return false;

			// Line Position
			LinePosition = EP.x-FRightWidth;

			CodeImageSelection.Clear();
			CodeImageEncoder.Encode(DefectROI,CodeImage);
			CodeImageSelection.Clear();
			CodeImageSelection.AddObjects(CodeImage);
			// Blob 필터링 
			CodeImageSelection.RemoveUsingFloatFeature(EFeature_BoundingBoxWidth ,FMinWidth     , FMaxWidth    , EDoubleThresholdMode_Outside);
			CodeImageSelection.RemoveUsingFloatFeature(EFeature_BoundingBoxHeight,FMinHeight    , FMaxHeight   , EDoubleThresholdMode_Outside);
				// 				CodeImageSelection.RemoveUsingIntegerFeature(EFeature_RightLimit     ,FRightWidth-2             , FRightWidth+1            , EDoubleThresholdMode_Outside);
			CodeImageSelection.RemoveUsingIntegerFeature(EFeature_RightLimit     ,FRightWidth-1             , FRightWidth+1            , EDoubleThresholdMode_Outside);

			BlobCount = CodeImageSelection.GetElementCount();
			CodeImageSelection.Sort(EFeature_TopLimit,ESortDirection_Ascending);

			if(BlobCount!=0){
				for(int k=0; k<BlobCount; k++){
					if(BCount>=MAX_DEFECT_POINT) break; 
					BDefectPoint[BCount].Width  = CodeImageSelection.GetElement(k).GetBoundingBoxWidth() ;
					BDefectPoint[BCount].Height = CodeImageSelection.GetElement(k).GetBoundingBoxHeight();

					BDefectPoint[BCount].Rect.left   =(long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterX() - BDefectPoint[BCount].Width/2 ) +(LinePosition));
					BDefectPoint[BCount].Rect.top    =(long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - BDefectPoint[BCount].Height/2) +(EP.y+BtmMargin));
					BDefectPoint[BCount].Rect.right  =(long)(BDefectPoint[BCount].Rect.left+ BDefectPoint[BCount].Width );
					BDefectPoint[BCount].Rect.bottom =(long)(BDefectPoint[BCount].Rect.top + BDefectPoint[BCount].Height);
					PixelCount = 0;
					PixelValue = 0;

					// 내부 Pixel Data 축출 
					for(int n=BDefectPoint[BCount].Rect.top+1 ; n<BDefectPoint[BCount].Rect.bottom-1; n++){
						for(int m=BDefectPoint[BCount].Rect.left+1; m<BDefectPoint[BCount].Rect.right-1 ; m++){
							PixelValue = IElement(m,n);
							if(PixelValue < EnCapBtmThresHold) PixelCount++;
						}
					}
					BDefectPoint[BCount].Round  = PixelCount;
					BDefectPoint[BCount].P.x    =(float)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterX() - BDefectPoint[BCount].Width/2 )+(LinePosition));
					BDefectPoint[BCount].P.y    =(float)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - BDefectPoint[BCount].Height/2)+(EP.y+BtmMargin)+ImageHeight   );

					// Merge 위해서 데이터 필요함 
					BDefectPoint[BCount].Rect.top    =(long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - BDefectPoint[BCount].Height/2) +(EP.y+BtmMargin)+ImageHeight);
					BDefectPoint[BCount].Rect.bottom =(long)(BDefectPoint[BCount].Rect.top + BDefectPoint[BCount].Height);
					BCount++;
				}
			}

			BlobCount =0;
			// 외곽라인에서 Mark까지의 거리 산출 
			//if     (Line[waRightWall].FP0.x >Line[waRightWall].FP1.x) RDistance = (Line[waRightWall].FP1.x+(Line[waRightWall].FP0.x - Line[waRightWall].FP1.x)/2) - FP1.x;
			//else if(Line[waRightWall].FP0.x==Line[waRightWall].FP1.x) RDistance =  Line[waRightWall].FP0.x - FP1.x;
			//else                                                      RDistance = (Line[waRightWall].FP0.x+(Line[waRightWall].FP1.x - Line[waRightWall].FP0.x)/2) - FP1.x;

			if     (Line[waRightWall].FP0.x >Line[waRightWall].FP1.x) RDistance = (Line[waRightWall].FP1.x+(Line[waRightWall].FP0.x - Line[waRightWall].FP1.x)/2) - ((RightBMLine[0].FP0.x+ RightBMLine[0].FP1.x)/2);
			else if(Line[waRightWall].FP0.x==Line[waRightWall].FP1.x) RDistance =  Line[waRightWall].FP0.x                                                        - ((RightBMLine[0].FP0.x+ RightBMLine[0].FP1.x)/2);
			else                                                      RDistance = (Line[waRightWall].FP0.x+(Line[waRightWall].FP1.x - Line[waRightWall].FP0.x)/2) - ((RightBMLine[0].FP0.x+ RightBMLine[0].FP1.x)/2);
			////////////////////////////////////////////////////////////////////////////////////////////////

			//SIDE C
			////////////////////////////////////////////////////////////////////////////////////////////////
			// Btm검사시 오버킬을 줄위기 위해서 
			if(fabs(FLBPoint.y - FRBPoint.y)>3) BTMLine = (FLBPoint.y > FRBPoint.y) ?(int)FRBPoint.y : (int)FLBPoint.y ;
			else                                BTMLine = (FLBPoint.y > FRBPoint.y) ?(int)FLBPoint.y : (int)FRBPoint.y ;
			
			if(IsMarkBtm){
				DefectROI.SetPlacement((int)FLBPoint.x+SideMargin, (int)(BTMLine-FBtmHeight), BtmWidth-(2*SideMargin), FBtmHeight);
				if((FLBPoint.x+SideMargin) <=0          ||(BTMLine-FBtmHeight)<0            || BtmWidth-(2*SideMargin)<=0          || FBtmHeight<0           ) return false;
				if((FLBPoint.x+SideMargin) >=ImageWidth ||(BTMLine-FBtmHeight)>BtmLimitLine || BtmWidth-(2*SideMargin)>=ImageWidth || FBtmHeight>BtmLimitLine) return false;
				if((FLBPoint.x+SideMargin)+(BtmWidth-(2*SideMargin))>=ImageWidth ||(BTMLine-FBtmHeight)+FBtmHeight>BtmLimitLine                              ) return false;
			}
			else         {
				DefectROI.SetPlacement((int)FLBPoint.x+SideMargin, (int)(BTMLine-FBtmHeight), BtmWidth-(2*SideMargin), FBtmHeight-BtmInspOffset);
				if((FLBPoint.x+SideMargin) <=0          ||(BTMLine-FBtmHeight)<0            || BtmWidth-(2*SideMargin)<=0          || FBtmHeight-BtmInspOffset<0           ) return false;
				if((FLBPoint.x+SideMargin) >=ImageWidth ||(BTMLine-FBtmHeight)>BtmLimitLine || BtmWidth-(2*SideMargin)>=ImageWidth || FBtmHeight-BtmInspOffset>BtmLimitLine) return false;
				if((FLBPoint.x+SideMargin)+(BtmWidth-(2*SideMargin))>=ImageWidth ||(BTMLine-FBtmHeight)+FBtmHeight-BtmInspOffset>BtmLimitLine                              ) return false;
			}

			CodeImageSelection.Clear();
			CodeImageEncoder.Encode(DefectROI,CodeImage);
			CodeImageSelection.Clear();
			CodeImageSelection.AddObjects(CodeImage);
			// Blob 필터링 
			CodeImageSelection.RemoveUsingFloatFeature  (EFeature_BoundingBoxWidth ,FMinWidth      , FMaxWidth   , EDoubleThresholdMode_Outside);
			CodeImageSelection.RemoveUsingFloatFeature  (EFeature_BoundingBoxHeight,FMinHeight     , FMaxHeight  , EDoubleThresholdMode_Outside);
			if(IsMarkBtm) CodeImageSelection.RemoveUsingIntegerFeature(EFeature_BottomLimit      ,FBtmHeight-1                 , FBtmHeight+1              , EDoubleThresholdMode_Outside);
			else          CodeImageSelection.RemoveUsingIntegerFeature(EFeature_BottomLimit      ,FBtmHeight-BtmInspOffset-1   , FBtmHeight-BtmInspOffset+1, EDoubleThresholdMode_Outside);


			BlobCount = CodeImageSelection.GetElementCount();
			CodeImageSelection.Sort(EFeature_LeftLimit ,ESortDirection_Ascending);

			if(BlobCount!=0){
				for(int k=0; k<BlobCount; k++){
					if(CCount>=MAX_DEFECT_POINT) break; 
					CDefectPoint[CCount].Width  =  CodeImageSelection.GetElement(k).GetBoundingBoxWidth() ;
					CDefectPoint[CCount].Height =  CodeImageSelection.GetElement(k).GetBoundingBoxHeight();

					CDefectPoint[CCount].Rect.left   =(long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterX() - CDefectPoint[CCount].Width/2 ) +FLBPoint.x+SideMargin);
					// 						CDefectPoint[CCount].Rect.top    =(long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - CDefectPoint[CCount].Height/2) +((FLBBPoint.y+FRBBPoint.y)/2-FBtmHeight-1));
					CDefectPoint[CCount].Rect.top    =(long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - CDefectPoint[CCount].Height/2) +(BTMLine-FBtmHeight));
					CDefectPoint[CCount].Rect.right  =(long)(CDefectPoint[CCount].Rect.left+ CDefectPoint[CCount].Width );
					CDefectPoint[CCount].Rect.bottom =(long)(CDefectPoint[CCount].Rect.top + CDefectPoint[CCount].Height);
					PixelCount = 0;
					PixelValue = 0;

					// 내부 Pixel Data 축출 
					for(int n=CDefectPoint[CCount].Rect.top+1 ; n<CDefectPoint[CCount].Rect.bottom-1; n++){
						for(int m=CDefectPoint[CCount].Rect.left+1; m<CDefectPoint[CCount].Rect.right-1 ; m++){
							PixelValue = IElement(m,n);
							if(PixelValue < EnCapBtmThresHold) PixelCount++;
						}
					}
					CDefectPoint[CCount].Round  =  PixelCount;
					CDefectPoint[CCount].P.x    = (float)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterX() - CDefectPoint[CCount].Width/2 )+FLBPoint.x+SideMargin);
					CDefectPoint[CCount].P.y    = (float)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - CDefectPoint[CCount].Height/2)+(BTMLine-FBtmHeight) );

					if(ImgDegree!=0.0f){
						CDefectPoint[CCount].P = Math.OnRotate(CenterPoint,CDefectPoint[CCount].P, ImgDegree);
					}
					CDefectPoint[CCount].P.y    = (float)(CDefectPoint[CCount].P.y+ImageHeight);

					// Merge 위해서 데이터 필요함 
					// 						CDefectPoint[CCount].Rect.top    =(long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - CDefectPoint[CCount].Height/2) +((FLBBPoint.y+FRBBPoint.y)/2-FBtmHeight-1)+ImageHeight);
					CDefectPoint[CCount].Rect.top    =(long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - CDefectPoint[CCount].Height/2) +(BTMLine-FBtmHeight)+ImageHeight);
					CDefectPoint[CCount].Rect.bottom =(long)(CDefectPoint[CCount].Rect.top + CDefectPoint[CCount].Height);
					CCount++;
				}
			}
			BlobCount =0;
			////////////////////////////////////////////////////////////////////////////////////////////////
		}
		else if(IsCircleBtm){ //Circle Cutting일경우 Defect 검사 시퀀스 
			if(FInspectMode==Insp_Polygon){ // 비선형 검사에서는 Dx,Dy,R 미검사 
				if(C1CirInEdgeCount!=0){
					IAddress = DefectImg.GetImagePtr(); // Pixel 정보 추출 목적 
					C1CirDeftectCnt  = GetPolygonSize(C1CirInPoint, C1CirDefectPoint, C1CirInEdgeCount, 50, 5); // Dark Defect 

					if(!IsMarkBtm && C1CirInCrackCount>0 && BrokenThresHold!=0){
						IAddress = RotateBrokenImg.GetImagePtr(); // Pixel 정보 추출 목적 
						C1CirCrackCnt  = GetCircleCrackSize(C1CircleData, C1CirCrackPoint, C1CirInCrackCount, 30,CirFitDiameter1,CircleFit1Center); // Bright Defect 
					}
				}

				if(C2CirInEdgeCount!=0){
					IAddress = DefectImg.GetImagePtr(); // Pixel 정보 추출 목적 
					C2CirDeftectCnt  = GetPolygonSize(C2CirInPoint, C2CirDefectPoint, C2CirInEdgeCount, 50, 5); // Dark Defect 

					if(!IsMarkBtm && C2CirInCrackCount>0 && BrokenThresHold!=0){
						IAddress = RotateBrokenImg.GetImagePtr(); // Pixel 정보 추출 목적 
						C2CirCrackCnt  = GetCircleCrackSize(C2CircleData, C2CirCrackPoint, C2CirInCrackCount, 30,CirFitDiameter2,CircleFit2Center); // Bright Defect 
					}
				}

				if(C3CirInEdgeCount!=0){
					IAddress = DefectImg.GetImagePtr(); // Pixel 정보 추출 목적 
					C3CirDeftectCnt  = GetPolygonSize(C3CirInPoint, C3CirDefectPoint, C3CirInEdgeCount, 50, 5); // Dark Defect 

					if(!IsMarkBtm && C3CirInCrackCount>0 && BrokenThresHold!=0){
						IAddress = RotateBrokenImg.GetImagePtr(); // Pixel 정보 추출 목적 
						C3CirCrackCnt  = GetCircleCrackSize(C3CircleData, C3CirCrackPoint, C3CirInCrackCount, 30,CirFitDiameter3,CircleFit3Center); // Bright Defect 
					}
				}

				if(C4CirInEdgeCount!=0){
					IAddress = DefectImg.GetImagePtr(); // Pixel 정보 추출 목적 
					C4CirDeftectCnt  = GetPolygonSize(C4CirInPoint, C4CirDefectPoint, C4CirInEdgeCount, 50, 5); // Dark Defect 

					if(!IsMarkBtm && C4CirInCrackCount>0 && BrokenThresHold!=0){
						IAddress = RotateBrokenImg.GetImagePtr(); // Pixel 정보 추출 목적 
						C4CirCrackCnt  = GetCircleCrackSize(C4CircleData, C4CirCrackPoint, C4CirInCrackCount, 30,CirFitDiameter4,CircleFit4Center); // Bright Defect 
					}
				}

				if(C5CirInEdgeCount!=0){
					IAddress = DefectImg.GetImagePtr(); // Pixel 정보 추출 목적 
					C5CirDeftectCnt  = GetPolygonSize(C5CirInPoint, C5CirDefectPoint, C5CirInEdgeCount, 50, 5); // Dark Defect 

					if(!IsMarkBtm && C5CirInCrackCount>0 && BrokenThresHold!=0){
						IAddress = RotateBrokenImg.GetImagePtr(); // Pixel 정보 추출 목적 
						C5CirCrackCnt  = GetCircleCrackSize(C5CircleData, C5CirCrackPoint, C5CirInCrackCount, 30,CirFitDiameter5,CircleFit5Center); // Bright Defect 
					}
				}

				if(C6CirInEdgeCount!=0){
					IAddress = DefectImg.GetImagePtr(); // Pixel 정보 추출 목적 
					C6CirDeftectCnt  = GetPolygonSize(C6CirInPoint, C6CirDefectPoint, C6CirInEdgeCount, 50, 5); // Dark Defect 

					if(!IsMarkBtm && C6CirInCrackCount>0 && BrokenThresHold!=0){
						IAddress = RotateBrokenImg.GetImagePtr(); // Pixel 정보 추출 목적 
						C6CirCrackCnt  = GetCircleCrackSize(C6CircleData, C6CirCrackPoint, C6CirInCrackCount, 30,CirFitDiameter6,CircleFit6Center); // Bright Defect 
					}
				}
				if(Btm3InEdgeCount!=0){
					IAddress = DefectImg.GetImagePtr(); // Pixel 정보 추출 목적 
					Btm3CirDefectCnt  = GetPolygonSize(Btm3InPoint, Btm3CirDefectPoint, Btm3InEdgeCount, 50, 5); // Dark Defect 

					if(!IsMarkBtm && Btm3CirInCrackCount>0 && BrokenThresHold!=0){
						IAddress = RotateBrokenImg.GetImagePtr(); // Pixel 정보 추출 목적 
						Btm3CirCrackCnt  = GetCircleCrackSize(Btm3CircleData, Btm3CirCrackPoint, Btm3CirInCrackCount, 30,CirFitDiameterBtm3,CircleFitBtm3Center); // Bright Defect 
					}
				}
			}
			else { // MarkMode, TrackMode 
				if(C1CirInEdgeCount!=0){
					IAddress = DefectImg.GetImagePtr(); // Pixel 정보 추출 목적 
					MaxDis =0.0f        ;
					MinDis =10000.0f    ;
					MaxDv  =0.0f        ;
					MinDv  =10000.0f    ;
					StdMaxDis =0.0f     ;
					StdMinDis =10000.0f ;
					MinCirCount =0      ;
					// 삼항 연산자 최소값 구하기  
					if      (FInspectMode==Insp_Track) MinCirCount = (C1CirInEdgeCount<C1CirOutEdgeCount)?(C1CirInEdgeCount<C1CirStandEdgeCount)?C1CirInEdgeCount:C1CirStandEdgeCount:(C1CirOutEdgeCount<C1CirStandEdgeCount)?C1CirOutEdgeCount:C1CirStandEdgeCount;
					else if (FInspectMode==Insp_Mark ) MinCirCount = C1CirInEdgeCount;

					CircleCount=0;TotalCirDis=0.0f; AvgCirDis=0.0f;
					for(int k=0; k<MinCirCount; k++){
						if(FInspectMode==Insp_Track){ // TrackMode 
							if(C1CirInPoint[k].x==0    || C1CirInPoint[k].y==0    || k>=MAX_CIRCLE_EDGEPOINT) continue;
							if(C1CirStandPoint[k].x==0 || C1CirStandPoint[k].y==0 || k>=MAX_CIRCLE_EDGEPOINT) continue;

							if(IsMarkBtm){ // RealC1CirCneter값은 TrackLine EdgePoint기준 Circle_Fitting 결과물 
								Dis    = Math.GetLengthFrPointToPoint(RealC1CirCenter,C1CirInPoint[k]   );
								StdDis = Math.GetLengthFrPointToPoint(RealC1CirCenter,C1CirStandPoint[k]);
							}
							else {        // TrackLine 교차점 기준 센터 
								Dis    = Math.GetLengthFrPointToPoint(TrackC1CirCenter,C1CirInPoint[k]   );
							}

							if(Dis>MaxDis) MaxDis = Dis;
							if(Dis<MinDis) MinDis = Dis;

							if(StdDis>StdMaxDis) StdMaxDis = StdDis;
							if(StdDis<StdMinDis) StdMinDis = StdDis;

							if(k==0){ // BTM Defect 검사를 위한 좌표값 및 Dx,Dy 산출 
								if(IsMarkBtm){ 					
									C1CirDy = Math.GetLengthFrPointToPoint(TrackC1CirCenter,C1CirInPoint[k]);
								}
								else {
									C1CirDy = Math.GetLengthFrPointToPoint(TrackC1CirCenter,C1CirInPoint[k]);
								}
							} 
							if(k==(C1CirInEdgeCount-1)){
								if(IsMarkBtm){ 					
									C1CirDx = Math.GetLengthFrPointToPoint(TrackC1CirCenter,C1CirInPoint[k]);
								}
								else {
									C1CirDx = Math.GetLengthFrPointToPoint(TrackC1CirCenter,C1CirInPoint[k]);
								}
							}
						}
						else if(FInspectMode==Insp_Mark){ // MarkMode 
							if(C1CirInPoint[k].x==0    || C1CirInPoint[k].y==0    || k>=MAX_CIRCLE_EDGEPOINT) continue;

							if(IsMarkBtm){ // RealC1CirCneter값은 연마안쪽 EdgePoint기준 Circle_Fitting 결과물 
								// 							Dis    = Math.GetLengthFrPointToPoint(RealC1CirCenter,C1CirInPoint[k] ); // Euresys Circle Fitting
								Dis = Math.GetLengthFrPointToPoint(CircleFit1Center,C1CirInPoint[k]   ); // FAVION  Circle Fitting 
							}
							else {
								Dis    = Math.GetLengthFrPointToPoint(CircleFit1Center,C1CirInPoint[k]   );
							}

							if(Dis>MaxDis) MaxDis = Dis;
							if(Dis<MinDis) MinDis = Dis;

							if(k==0){ // BTM Defect 검사를 위한 좌표값 및 Dx,Dy 산출 
								// 						    C1CirDy = Math.GetLengthFrPointToPoint(RealC1CirCenter,C1CirInPoint[k]);
								C1CirDy = Math.GetLengthFrPointToPoint(CircleFit1Center,C1CirInPoint[k]);
							} 
							if(k==(C1CirInEdgeCount-1)){
								// 						    C1CirDx = Math.GetLengthFrPointToPoint(RealC1CirCenter,C1CirInPoint[k]);
								C1CirDx = Math.GetLengthFrPointToPoint(CircleFit1Center,C1CirInPoint[k]);
							}
						}
						//Data 취합 
						C1CircleData[CircleCount].Dis  = Dis              ; 
						C1CircleData[CircleCount].P.x  = C1CirInPoint[k].x;
						C1CircleData[CircleCount].P.y  = C1CirInPoint[k].y;
						CircleCount++   ;
						TotalCirDis+=Dis;
					}

					if(CircleCount!=0 || TotalCirDis!=0){ // Circle AvgRound Cal
						AvgCirDis = (TotalCirDis/CircleCount);
						C1CirRound = AvgCirDis;
					}

					for(int i=0; i<CircleCount; i++){
						// 					C1CircleData[i].Dv = fabs(AvgCirDis - C1CircleData[i].Dis); // Avg EdgePoint 기준 편차값 
						C1CircleData[i].Dv = (CirFitDiameter1 - C1CircleData[i].Dis) >0 ?(CirFitDiameter1 - C1CircleData[i].Dis):0;
						if(C1CircleData[i].Dv>MaxDv) MaxDv = C1CircleData[i].Dv;
						if(C1CircleData[i].Dv<MinDv) MinDv = C1CircleData[i].Dv;
					}
					C1CirDeftectCnt  = GetCircleSize(C1CircleData, C1CirDefectPoint, CircleCount, 5); // Dark Defect 

					// 박리불량 검사 시퀀스 
					if(!IsMarkBtm && C1CirInCrackCount>0 && BrokenThresHold!=0){
						for(int i=0; i<C1CirInCrackCount; i++){
							C1CircleData[i].Dv  =0.0f;
							C1CircleData[i].Dis =0.0f;
							C1CircleData[i].P.x  = C1CirInCrackPoint[i].x;
							C1CircleData[i].P.y  = C1CirInCrackPoint[i].y;
						}
						IAddress = RotateBrokenImg.GetImagePtr(); // Pixel 정보 추출 목적 
						C1CirCrackCnt  = GetCircleCrackSize(C1CircleData, C1CirCrackPoint, C1CirInCrackCount, 30, CrackCirDiameter1,CircleFit1Center); // Bright Defect 
					}
				}

				// C2Circle Calculate 
				if(C2CirInEdgeCount!=0){
					IAddress = DefectImg.GetImagePtr(); // Pixel 정보 추출 목적 
					MaxDis =0.0f     ;
					MinDis =10000.0f ;
					MaxDv  =0.0f     ;
					MinDv  =10000.0f ;
					StdMaxDis =0.0f     ;
					StdMinDis =10000.0f ;
					MinCirCount =0      ;
					// 삼항 연산자 최소값 구하기  

					if      (FInspectMode==Insp_Track) MinCirCount = (C2CirInEdgeCount<C2CirOutEdgeCount)?(C2CirInEdgeCount<C2CirStandEdgeCount)?C2CirInEdgeCount:C2CirStandEdgeCount:(C2CirOutEdgeCount<C2CirStandEdgeCount)?C2CirOutEdgeCount:C2CirStandEdgeCount;
					else if (FInspectMode==Insp_Mark ) MinCirCount =  C2CirInEdgeCount;

					CircleCount=0;TotalCirDis=0.0f; AvgCirDis=0.0f;
					for(int k=0; k<MinCirCount; k++){
						if(FInspectMode==Insp_Track){ // TrackMode 
							if(C2CirInPoint[k].x==0    || C2CirInPoint[k].y==0    || k>=MAX_CIRCLE_EDGEPOINT) continue;
							if(C2CirStandPoint[k].x==0 || C2CirStandPoint[k].y==0 || k>=MAX_CIRCLE_EDGEPOINT) continue;

							if(IsMarkBtm){ // RealC2CirCneter값은 TrackLine EdgePoint기준 Circle_Fitting 결과물 
								Dis    = Math.GetLengthFrPointToPoint(RealC2CirCenter,C2CirInPoint[k]   );
								StdDis = Math.GetLengthFrPointToPoint(RealC2CirCenter,C2CirStandPoint[k]);
							}
							else {         // TrackLine 교차점 기준 센터 
								Dis    = Math.GetLengthFrPointToPoint(TrackC2CirCenter,C2CirInPoint[k]   );
							}

							if(Dis>MaxDis) MaxDis = Dis;
							if(Dis<MinDis) MinDis = Dis;
							if(StdDis>StdMaxDis) StdMaxDis = StdDis;
							if(StdDis<StdMinDis) StdMinDis = StdDis;

							if(k==0){ // BTM Defect 검사를 위한 좌표값 및 Dx,Dy 산출 
								if(IsMarkBtm){ 					
									C2CirDx = Math.GetLengthFrPointToPoint(TrackC2CirCenter,C2CirInPoint[k]);
								}
								else {
									C2CirDx = Math.GetLengthFrPointToPoint(TrackC2CirCenter,C2CirInPoint[k]);
								}
							} 
							if(k==(C2CirInEdgeCount-1)) {
								if(IsMarkBtm){ 					
									C2CirDy = Math.GetLengthFrPointToPoint(TrackC2CirCenter,C2CirInPoint[k]);
								}
								else {
									C2CirDy = Math.GetLengthFrPointToPoint(TrackC2CirCenter,C2CirInPoint[k]);
								}
							}
						}
						else if(FInspectMode==Insp_Mark){ // MarkMode 
							if(C2CirInPoint[k].x==0    || C2CirInPoint[k].y==0    || k>=MAX_CIRCLE_EDGEPOINT) continue;

							if(IsMarkBtm){ // RealC2CirCneter값은 연마안쪽 EdgePoint기준 Circle_Fitting 결과물 
								// 							Dis    = Math.GetLengthFrPointToPoint(RealC2CirCenter,C2CirInPoint[k]   );
								Dis = Math.GetLengthFrPointToPoint(CircleFit2Center,C2CirInPoint[k]     );
								// 							Dis    = Math.GetLengthFrPointToPoint(C2CirCenter,C2CirInPoint[k]   );
							}
							else {         // RealC2CirCneter값은 연마안쪽 EdgePoint기준 Circle_Fitting 결과물 
								Dis    = Math.GetLengthFrPointToPoint(CircleFit2Center,C2CirInPoint[k]   );
							}

							if(Dis>MaxDis) MaxDis = Dis;
							if(Dis<MinDis) MinDis = Dis;

							if(k==0){ // BTM Defect 검사를 위한 좌표값 및 Dx,Dy 산출 
								// 						    C2CirDx = Math.GetLengthFrPointToPoint(RealC2CirCenter,C2CirInPoint[k]);
								C2CirDx = Math.GetLengthFrPointToPoint(CircleFit2Center,C2CirInPoint[k]);
							} 
							if(k==(C2CirInEdgeCount-1)) {
								// 							C2CirDy = Math.GetLengthFrPointToPoint(RealC2CirCenter,C2CirInPoint[k]);
								C2CirDy = Math.GetLengthFrPointToPoint(CircleFit2Center,C2CirInPoint[k]);
							}
						}

						C2CircleData[CircleCount].Dis  = Dis              ; // FAVION  Circle Fitting 
						C2CircleData[CircleCount].P.x  = C2CirInPoint[k].x;
						C2CircleData[CircleCount].P.y  = C2CirInPoint[k].y;
						CircleCount++   ;
						TotalCirDis+=Dis;
					}
					if(CircleCount!=0 || TotalCirDis!=0){ // Circle AvgRound Cal
						AvgCirDis = (TotalCirDis/CircleCount);
						C2CirRound = AvgCirDis;
					}

					for(int i=0; i<CircleCount; i++){
						// 					C2CircleData[i].Dv = fabs(AvgCirDis - C2CircleData[i].Dis);      // Euresys Circle Fitting 
						C2CircleData[i].Dv = (CirFitDiameter2 - C2CircleData[i].Dis) >0 ?(CirFitDiameter2 - C2CircleData[i].Dis):0;
						if(C2CircleData[i].Dv>MaxDv) MaxDv = C2CircleData[i].Dv;
						if(C2CircleData[i].Dv<MinDv) MinDv = C2CircleData[i].Dv;
					}
					C2CirDeftectCnt  = GetCircleSize(C2CircleData, C2CirDefectPoint, CircleCount, 5);

					if(!IsMarkBtm && C2CirInCrackCount>0 && BrokenThresHold!=0){
						for(int i=0; i<C2CirInCrackCount; i++){
							C2CircleData[i].Dv  =0.0f;
							C2CircleData[i].Dis =0.0f;
							C2CircleData[i].P.x  = C2CirInCrackPoint[i].x;
							C2CircleData[i].P.y  = C2CirInCrackPoint[i].y;
						}
						IAddress = RotateBrokenImg.GetImagePtr(); // Pixel 정보 추출 목적 
						C2CirCrackCnt  = GetCircleCrackSize(C2CircleData, C2CirCrackPoint, C2CirInCrackCount, 30, CrackCirDiameter2,CircleFit2Center);
					}
				}

				// C3Circle Calculate 
				if(C3CirInEdgeCount!=0){
					IAddress = DefectImg.GetImagePtr(); // Pixel 정보 추출 목적 
					MaxDis =0.0f     ;
					MinDis =10000.0f ;
					MaxDv  =0.0f     ;
					MinDv  =10000.0f ;
					StdMaxDis =0.0f     ;
					StdMinDis =10000.0f ;
					MinCirCount =0      ;
					// 삼항 연산자 최소값 구하기  
					if      (FInspectMode==Insp_Track) MinCirCount = (C3CirInEdgeCount<C3CirOutEdgeCount)?(C3CirInEdgeCount<C3CirStandEdgeCount)?C3CirInEdgeCount:C3CirStandEdgeCount:(C3CirOutEdgeCount<C3CirStandEdgeCount)?C3CirOutEdgeCount:C3CirStandEdgeCount;
					else if (FInspectMode==Insp_Mark ) MinCirCount =  C3CirInEdgeCount; 

					CircleCount=0;TotalCirDis=0.0f; AvgCirDis=0.0f;
					for(int k=0; k<MinCirCount; k++){
						if(FInspectMode==Insp_Track){ // TrackMode
							if(C3CirInPoint[k].x==0    || C3CirInPoint[k].y==0    || k>=MAX_CIRCLE_EDGEPOINT) continue;
							if(C3CirStandPoint[k].x==0 || C3CirStandPoint[k].y==0 || k>=MAX_CIRCLE_EDGEPOINT) continue;

							if(IsMarkBtm){ // RealC3CirCneter값은 TrackLine EdgePoint기준 Circle_Fitting 결과물 
								Dis    = Math.GetLengthFrPointToPoint(RealC3CirCenter,C3CirInPoint[k]   );
								StdDis = Math.GetLengthFrPointToPoint(RealC3CirCenter,C3CirStandPoint[k]);
							}
							else {         // TrackLine 교차점 기준 센터 
								Dis    = Math.GetLengthFrPointToPoint(TrackC3CirCenter,C3CirInPoint[k]   );
							}

							if(Dis>MaxDis) MaxDis = Dis;
							if(Dis<MinDis) MinDis = Dis;

							if(StdDis>StdMaxDis) StdMaxDis = StdDis;
							if(StdDis<StdMinDis) StdMinDis = StdDis;

							if(k==0){ // BTM Defect 검사를 위한 좌표값 및 Dx,Dy 산출 
								if(IsMarkBtm){ 					
									C3CirDx = Math.GetLengthFrPointToPoint(TrackC3CirCenter,C3CirInPoint[k]);
								}
								else {
									C3CirDx = Math.GetLengthFrPointToPoint(TrackC3CirCenter,C3CirInPoint[k]);
								}
							} 
							if(k==(C3CirInEdgeCount-1)) {
								if(IsMarkBtm){ 					
									C3CirDy = Math.GetLengthFrPointToPoint(TrackC3CirCenter,C3CirInPoint[k]);
								}
								else {
									C3CirDy = Math.GetLengthFrPointToPoint(TrackC3CirCenter,C3CirInPoint[k]);
								}
							}
						}
						else if(FInspectMode==Insp_Mark){ // MarkMode 
							if(C3CirInPoint[k].x==0    || C3CirInPoint[k].y==0    || k>=MAX_CIRCLE_EDGEPOINT) continue;

							if(IsMarkBtm){ // RealC3CirCneter값은 연마안쪽 EdgePoint기준 Circle_Fitting 결과물 
								// 							Dis    = Math.GetLengthFrPointToPoint(RealC3CirCenter,C3CirInPoint[k]   );
								Dis = Math.GetLengthFrPointToPoint(CircleFit3Center,C3CirInPoint[k]  );
								// 							Dis    = Math.GetLengthFrPointToPoint(C3CirCenter,C3CirInPoint[k]   );
							}
							else {         // RealC1CirCneter값은 연마안쪽 EdgePoint기준 Circle_Fitting 결과물 
								Dis    = Math.GetLengthFrPointToPoint(CircleFit3Center,C3CirInPoint[k]   );
							}

							if(Dis>MaxDis) MaxDis = Dis;
							if(Dis<MinDis) MinDis = Dis;

							if(k==0){ // BTM Defect 검사를 위한 좌표값 및 Dx,Dy 산출 
								C3CirDx = Math.GetLengthFrPointToPoint(CircleFit3Center,C3CirInPoint[k]);
								// 							C3CirDx = Math.GetLengthFrPointToPoint(RealC3CirCenter,C3CirInPoint[k]);
							} 
							if(k==(C3CirInEdgeCount-1)) {
								// 							C3CirDy = Math.GetLengthFrPointToPoint(RealC3CirCenter,C3CirInPoint[k]);
								C3CirDy = Math.GetLengthFrPointToPoint(CircleFit3Center,C3CirInPoint[k]);
							}
						}

						C3CircleData[CircleCount].Dis  = Dis              ;  // FAVION Circle Fitting 
						C3CircleData[CircleCount].P.x  = C3CirInPoint[k].x;
						C3CircleData[CircleCount].P.y  = C3CirInPoint[k].y;
						CircleCount++   ;
						TotalCirDis+=Dis;
					}
					if(CircleCount!=0 || TotalCirDis!=0){ // Circle AvgRound Cal
						AvgCirDis = (TotalCirDis/CircleCount);
						C3CirRound = AvgCirDis;
					}

					for(int i=0; i<CircleCount; i++){
						// 					C3CircleData[i].Dv = fabs(AvgCirDis - C3CircleData[i].Dis);          // Euresys Circle Fitting 
						C3CircleData[i].Dv = (CirFitDiameter3 - C3CircleData[i].Dis) <0 ?fabs(CirFitDiameter3 - C3CircleData[i].Dis):0;
						if(C3CircleData[i].Dv>MaxDv) MaxDv = C3CircleData[i].Dv;
						if(C3CircleData[i].Dv<MinDv) MinDv = C3CircleData[i].Dv;
					}
					C3CirDeftectCnt  = GetCircleSize(C3CircleData, C3CirDefectPoint, CircleCount, 5);

					if(!IsMarkBtm && C3CirInCrackCount>0 && BrokenThresHold!=0){
						for(int i=0; i<C3CirInCrackCount; i++){
							C3CircleData[i].Dv  =0.0f;
							C3CircleData[i].Dis =0.0f;
							C3CircleData[i].P.x  = C3CirInCrackPoint[i].x;
							C3CircleData[i].P.y  = C3CirInCrackPoint[i].y;
						}
						IAddress = RotateBrokenImg.GetImagePtr(); // Pixel 정보 추출 목적 

						C3CirCrackCnt  = GetCircleCrackSize(C3CircleData, C3CirCrackPoint, C3CirInCrackCount, 30, CrackCirDiameter3,CircleFit3Center,false);
					}
				}

				// C4Circle Calculate 
				if(C4CirInEdgeCount!=0){
					IAddress = DefectImg.GetImagePtr(); // Pixel 정보 추출 목적 
					MaxDis =0.0f     ;
					MinDis =10000.0f ;
					MaxDv  =0.0f     ;
					MinDv  =10000.0f ;
					StdMaxDis =0.0f     ;
					StdMinDis =10000.0f ;
					MinCirCount =0      ;
					// 삼항 연산자 최소값 구하기  
					if      (FInspectMode==Insp_Track) MinCirCount = (C4CirInEdgeCount<C4CirOutEdgeCount)?(C4CirInEdgeCount<C4CirStandEdgeCount)?C4CirInEdgeCount:C4CirStandEdgeCount:(C4CirOutEdgeCount<C4CirStandEdgeCount)?C4CirOutEdgeCount:C4CirStandEdgeCount;
					else if (FInspectMode==Insp_Mark ) MinCirCount =  C4CirInEdgeCount;     

					CircleCount=0;TotalCirDis=0.0f; AvgCirDis=0.0f;
					for(int k=0; k<MinCirCount; k++){
						if(FInspectMode==Insp_Track){ // TrackMode 
							if(C4CirInPoint[k].x==0    || C4CirInPoint[k].y==0    || k>=MAX_CIRCLE_EDGEPOINT) continue;
							if(C4CirStandPoint[k].x==0 || C4CirStandPoint[k].y==0 || k>=MAX_CIRCLE_EDGEPOINT) continue;

							if(IsMarkBtm){  // RealC4CirCneter값은 TrackLine EdgePoint기준 Circle_Fitting 결과물 
								Dis    = Math.GetLengthFrPointToPoint(RealC4CirCenter,C4CirInPoint[k]   );
								StdDis = Math.GetLengthFrPointToPoint(RealC4CirCenter,C4CirStandPoint[k]);
							}
							else {          // TrackLine 교차점 기준 센터 
								Dis    = Math.GetLengthFrPointToPoint(TrackC4CirCenter,C4CirInPoint[k]   );
							}

							if(Dis>MaxDis) MaxDis = Dis;
							if(Dis<MinDis) MinDis = Dis;

							if(StdDis>StdMaxDis) StdMaxDis = StdDis;
							if(StdDis<StdMinDis) StdMinDis = StdDis;


							if(k==0){ // BTM Defect 검사를 위한 좌표값 및 Dx,Dy 산출 
								if(IsMarkBtm){ 					
									C4CirDy = Math.GetLengthFrPointToPoint(TrackC4CirCenter,C4CirInPoint[k]);
								}
								else {
									C4CirDy = Math.GetLengthFrPointToPoint(TrackC4CirCenter,C4CirInPoint[k]);
								}
							} 
							if(k==(C4CirInEdgeCount-1)) {
								if(IsMarkBtm){ 					
									C4CirDx = Math.GetLengthFrPointToPoint(TrackC4CirCenter,C4CirInPoint[k]);
								}
								else {
									C4CirDx = Math.GetLengthFrPointToPoint(TrackC4CirCenter,C4CirInPoint[k]);
								}
							}
						}
						else if(FInspectMode==Insp_Mark){ // MarkMode 
							if(C4CirInPoint[k].x==0    || C4CirInPoint[k].y==0    || k>=MAX_CIRCLE_EDGEPOINT) continue;

							if(IsMarkBtm){  // RealC4CirCneter값은 연마안쪽 EdgePoint기준 Circle_Fitting 결과물 
								// 							Dis    = Math.GetLengthFrPointToPoint(RealC4CirCenter,C4CirInPoint[k]   );
								Dis = Math.GetLengthFrPointToPoint(CircleFit4Center,C4CirInPoint[k]  );
								// 							Dis    = Math.GetLengthFrPointToPoint(C4CirCenter,C4CirInPoint[k]   );
							}
							else {          // RealC4CirCneter값은 연마안쪽 EdgePoint기준 Circle_Fitting 결과물 
								Dis    = Math.GetLengthFrPointToPoint(CircleFit4Center,C4CirInPoint[k]   );
							}

							if(Dis>MaxDis) MaxDis = Dis;
							if(Dis<MinDis) MinDis = Dis;

							if(k==0){ // BTM Defect 검사를 위한 좌표값 및 Dx,Dy 산출 
								// 							C4CirDy = Math.GetLengthFrPointToPoint(RealC4CirCenter,C4CirInPoint[k]);
								C4CirDy = Math.GetLengthFrPointToPoint(CircleFit4Center,C4CirInPoint[k]);
							} 
							if(k==(C4CirInEdgeCount-1)) {
								// 							C4CirDx = Math.GetLengthFrPointToPoint(RealC4CirCenter,C4CirInPoint[k]);
								C4CirDx = Math.GetLengthFrPointToPoint(CircleFit4Center,C4CirInPoint[k]);
							}
						}

						C4CircleData[CircleCount].Dis  = Dis              ;  // FAVION Circle Fitting
						C4CircleData[CircleCount].P.x  = C4CirInPoint[k].x;
						C4CircleData[CircleCount].P.y  = C4CirInPoint[k].y;
						CircleCount++   ;
						TotalCirDis+=Dis;
					}
					if(CircleCount!=0 || TotalCirDis!=0){ // Circle AvgRound Cal
						AvgCirDis = (TotalCirDis/CircleCount);
						C4CirRound = AvgCirDis;
					}

					for(int i=0; i<CircleCount; i++){
						// 					C4CircleData[i].Dv = fabs(AvgCirDis - C4CircleData[i].Dis);       // Euresys Circle Fitting 
						C4CircleData[i].Dv = (CirFitDiameter4 - C4CircleData[i].Dis) <0 ?fabs(CirFitDiameter4 - C4CircleData[i].Dis):0;
						if(C4CircleData[i].Dv>MaxDv) MaxDv = C4CircleData[i].Dv;
						if(C4CircleData[i].Dv<MinDv) MinDv = C4CircleData[i].Dv;
					}
					C4CirDeftectCnt  = GetCircleSize(C4CircleData, C4CirDefectPoint, CircleCount, 5);

					if(!IsMarkBtm && C4CirInCrackCount>0 && BrokenThresHold!=0){
						for(int i=0; i<C4CirInCrackCount; i++){
							C4CircleData[i].Dv  =0.0f;
							C4CircleData[i].Dis =0.0f;
							C4CircleData[i].P.x  = C4CirInCrackPoint[i].x;
							C4CircleData[i].P.y  = C4CirInCrackPoint[i].y;
						}
						IAddress = RotateBrokenImg.GetImagePtr(); // Pixel 정보 추출 목적 
						C4CirCrackCnt  = GetCircleCrackSize(C4CircleData, C4CirCrackPoint, C4CirInCrackCount, 30, CrackCirDiameter4,CircleFit4Center,false);
					}
				}

				// C5Circle Calculate 
				if(C5CirInEdgeCount!=0){
					IAddress = DefectImg.GetImagePtr(); // Pixel 정보 추출 목적 

					MaxDis =0.0f     ;
					MinDis =10000.0f ;
					MaxDv  =0.0f     ;
					MinDv  =10000.0f ;
					StdMaxDis =0.0f     ;
					StdMinDis =10000.0f ;
					MinCirCount =0      ;
					// 삼항 연산자 최소값 구하기  
					if      (FInspectMode==Insp_Track) MinCirCount = (C5CirInEdgeCount<C5CirOutEdgeCount)?(C5CirInEdgeCount<C5CirStandEdgeCount)?C5CirInEdgeCount:C5CirStandEdgeCount:(C5CirOutEdgeCount<C5CirStandEdgeCount)?C5CirOutEdgeCount:C5CirStandEdgeCount;
					else if (FInspectMode==Insp_Mark ) MinCirCount =  C5CirInEdgeCount;

					CircleCount=0;TotalCirDis=0.0f; AvgCirDis=0.0f;
					for(int k=0; k<MinCirCount; k++){
						if(FInspectMode==Insp_Track){ // TrackMode 
							if(C5CirInPoint[k].x==0    || C5CirInPoint[k].y==0    || k>=MAX_CIRCLE_EDGEPOINT) continue;
							if(C5CirStandPoint[k].x==0 || C5CirStandPoint[k].y==0 || k>=MAX_CIRCLE_EDGEPOINT) continue;

							if(IsMarkBtm){  // RealC5CirCneter값은 TrackLine EdgePoint기준 Circle_Fitting 결과물 
								Dis    = Math.GetLengthFrPointToPoint(RealC5CirCenter,C5CirInPoint[k]   );
								StdDis = Math.GetLengthFrPointToPoint(RealC5CirCenter,C5CirStandPoint[k]);
							}
							else {          // TrackLine 교차점 기준 센터 
								Dis    = Math.GetLengthFrPointToPoint(TrackC5CirCenter,C5CirInPoint[k]   );
							}

							if(Dis>MaxDis) MaxDis = Dis;
							if(Dis<MinDis) MinDis = Dis;

							if(StdDis>StdMaxDis) StdMaxDis = StdDis;
							if(StdDis<StdMinDis) StdMinDis = StdDis;

							if(k==0){ // BTM Defect 검사를 위한 좌표값 및 Dx,Dy 산출 
								if(IsMarkBtm){ 					
									C5CirDy = Math.GetLengthFrPointToPoint(TrackC5CirCenter,C5CirInPoint[k]);
								}
								else {
									C5CirDy = Math.GetLengthFrPointToPoint(TrackC5CirCenter,C5CirInPoint[k]);
								}
							} 
							if(k==(C5CirInEdgeCount-1)) {
								if(IsMarkBtm){ 					
									C5CirDx = Math.GetLengthFrPointToPoint(TrackC5CirCenter,C5CirInPoint[k]);
								}
								else {
									C5CirDx = Math.GetLengthFrPointToPoint(TrackC5CirCenter,C5CirInPoint[k]);
								}
							}
						}
						else if(FInspectMode==Insp_Mark){ // MarkMode 
							if(C5CirInPoint[k].x==0    || C5CirInPoint[k].y==0    || k>=MAX_CIRCLE_EDGEPOINT) continue;

							if(IsMarkBtm){  // RealC5CirCneter값은 연마안쪽 EdgePoint기준 Circle_Fitting 결과물 
								// 							Dis    = Math.GetLengthFrPointToPoint(RealC5CirCenter,C5CirInPoint[k]   );
								Dis = Math.GetLengthFrPointToPoint(CircleFit5Center,C5CirInPoint[k]  );
								// 							Dis    = Math.GetLengthFrPointToPoint(C5CirCenter,C5CirInPoint[k]   );
							}
							else {          // RealC5CirCneter값은 연마안쪽 EdgePoint기준 Circle_Fitting 결과물 
								Dis    = Math.GetLengthFrPointToPoint(CircleFit5Center,C5CirInPoint[k]   );
							}

							if(Dis>MaxDis) MaxDis = Dis;
							if(Dis<MinDis) MinDis = Dis;

							if(k==0){ // BTM Defect 검사를 위한 좌표값 및 Dx,Dy 산출 
								// 							C5CirDy = Math.GetLengthFrPointToPoint(RealC5CirCenter,C5CirInPoint[k]);
								C5CirDy = Math.GetLengthFrPointToPoint(CircleFit5Center,C5CirInPoint[k]);
							} 
							if(k==(C5CirInEdgeCount-1)) {
								// 							C5CirDx = Math.GetLengthFrPointToPoint(RealC5CirCenter,C5CirInPoint[k]);
								C5CirDx = Math.GetLengthFrPointToPoint(CircleFit5Center,C5CirInPoint[k]);
							}
						}

						C5CircleData[CircleCount].Dis  = Dis            ;  // FAVION  Circle Fitting 
						C5CircleData[CircleCount].P.x  = C5CirInPoint[k].x;
						C5CircleData[CircleCount].P.y  = C5CirInPoint[k].y;
						CircleCount++   ;
						TotalCirDis+=Dis;
					}
					if(CircleCount!=0 || TotalCirDis!=0){ // Circle AvgRound Cal
						AvgCirDis = (TotalCirDis/CircleCount);
						C5CirRound = AvgCirDis;
					}

					for(int i=0; i<CircleCount; i++){
						// 					C5CircleData[i].Dv = fabs(AvgCirDis - C5CircleData[i].Dis);       // Euresys Circle Fitting  
						C5CircleData[i].Dv = (CirFitDiameter5 - C5CircleData[i].Dis) >0 ?(CirFitDiameter5 - C5CircleData[i].Dis):0;
						if(C5CircleData[i].Dv>MaxDv) MaxDv = C5CircleData[i].Dv;
						if(C5CircleData[i].Dv<MinDv) MinDv = C5CircleData[i].Dv;
					}
					C5CirDeftectCnt  = GetCircleSize(C5CircleData, C5CirDefectPoint, CircleCount, 5);

					if(!IsMarkBtm && C5CirInCrackCount>0 && BrokenThresHold!=0){
						for(int i=0; i<C5CirInCrackCount; i++){
							C5CircleData[i].Dv  =0.0f;
							C5CircleData[i].Dis =0.0f;
							C5CircleData[i].P.x  = C5CirInCrackPoint[i].x;
							C5CircleData[i].P.y  = C5CirInCrackPoint[i].y;
						}
						IAddress = RotateBrokenImg.GetImagePtr(); // Pixel 정보 추출 목적 
						C5CirCrackCnt  = GetCircleCrackSize(C5CircleData, C5CirCrackPoint, C5CirInCrackCount, 30, CrackCirDiameter5,CircleFit5Center);
					}
				}

				// C6Circle Calculate 
				if(C6CirInEdgeCount!=0){
					IAddress = DefectImg.GetImagePtr(); // Pixel 정보 추출 목적 

					MaxDis =0.0f     ;
					MinDis =10000.0f ;
					MaxDv  =0.0f     ;
					MinDv  =10000.0f ;
					StdMaxDis =0.0f     ;
					StdMinDis =10000.0f ;
					MinCirCount =0      ;
					// 삼항 연산자 최소값 구하기  
					if      (FInspectMode==Insp_Track) MinCirCount = (C6CirInEdgeCount<C6CirOutEdgeCount)?(C6CirInEdgeCount<C6CirStandEdgeCount)?C6CirInEdgeCount:C6CirStandEdgeCount:(C6CirOutEdgeCount<C6CirStandEdgeCount)?C6CirOutEdgeCount:C6CirStandEdgeCount;
					else if (FInspectMode==Insp_Mark ) MinCirCount =  C6CirInEdgeCount;  

					CircleCount=0;TotalCirDis=0.0f; AvgCirDis=0.0f;
					for(int k=0; k<MinCirCount; k++){
						if(FInspectMode==Insp_Track){ // TrackMode 
							if(C6CirInPoint[k].x==0    || C6CirInPoint[k].y==0    || k>=MAX_CIRCLE_EDGEPOINT) continue;
							if(C6CirStandPoint[k].x==0 || C6CirStandPoint[k].y==0 || k>=MAX_CIRCLE_EDGEPOINT) continue;

							if(IsMarkBtm){  // RealC6CirCneter값은 TrackLine EdgePoint기준 Circle_Fitting 결과물 
								Dis    = Math.GetLengthFrPointToPoint(RealC6CirCenter,C6CirInPoint[k]   );
								StdDis = Math.GetLengthFrPointToPoint(RealC6CirCenter,C6CirStandPoint[k]);
							}
							else {          // TrackLine 교차점 기준 센터 
								Dis    = Math.GetLengthFrPointToPoint(TrackC6CirCenter,C6CirInPoint[k]   );
							}

							if(Dis>MaxDis) MaxDis = Dis;
							if(Dis<MinDis) MinDis = Dis;

							if(StdDis>StdMaxDis) StdMaxDis = StdDis;
							if(StdDis<StdMinDis) StdMinDis = StdDis;


							if(k==0){ // BTM Defect 검사를 위한 좌표값 및 Dx,Dy 산출 
								if(IsMarkBtm){ 					
									C6CirDx = Math.GetLengthFrPointToPoint(TrackC6CirCenter,C6CirInPoint[k]);
								}
								else {
									C6CirDx = Math.GetLengthFrPointToPoint(TrackC6CirCenter,C6CirInPoint[k]);
								}
							} 
							if(k==(C6CirInEdgeCount-1)) {
								if(IsMarkBtm){ 					
									C6CirDy = Math.GetLengthFrPointToPoint(TrackC6CirCenter,C6CirInPoint[k]);
								}
								else {
									C6CirDy = Math.GetLengthFrPointToPoint(TrackC6CirCenter,C6CirInPoint[k]);
								}
							}
						}
						else if(FInspectMode==Insp_Mark){ // MarkMode 
							if(C6CirInPoint[k].x==0    || C6CirInPoint[k].y==0    || k>=MAX_CIRCLE_EDGEPOINT) continue;

							if(IsMarkBtm){  // RealC6CirCneter값은 연마안쪽 EdgePoint기준 Circle_Fitting 결과물 
								// 							Dis    = Math.GetLengthFrPointToPoint(RealC6CirCenter,C6CirInPoint[k]   );
								Dis = Math.GetLengthFrPointToPoint(CircleFit6Center,C6CirInPoint[k]  );
								// 							Dis    = Math.GetLengthFrPointToPoint(C6CirCenter,C6CirInPoint[k]   );
							}
							else {          // RealC6CirCneter값은 연마안쪽 EdgePoint기준 Circle_Fitting 결과물 
								Dis    = Math.GetLengthFrPointToPoint(CircleFit6Center,C6CirInPoint[k]   );
							}

							if(Dis>MaxDis) MaxDis = Dis;
							if(Dis<MinDis) MinDis = Dis;

							if(k==0){ // BTM Defect 검사를 위한 좌표값 및 Dx,Dy 산출 
								C6CirDx = Math.GetLengthFrPointToPoint(CircleFit6Center,C6CirInPoint[k]);
								// 							C6CirDx = Math.GetLengthFrPointToPoint(RealC6CirCenter,C6CirInPoint[k]);
							} 
							if(k==(C6CirInEdgeCount-1)) {
								C6CirDy = Math.GetLengthFrPointToPoint(CircleFit6Center,C6CirInPoint[k]);
								// 							C6CirDy = Math.GetLengthFrPointToPoint(RealC6CirCenter,C6CirInPoint[k]);
							}
						}

						C6CircleData[CircleCount].Dis  = Dis            ; // FAVION Circle Fitting 
						C6CircleData[CircleCount].P.x  = C6CirInPoint[k].x;
						C6CircleData[CircleCount].P.y  = C6CirInPoint[k].y;
						CircleCount++   ;
						TotalCirDis+=Dis;
					}
					if(CircleCount!=0 || TotalCirDis!=0){ // Circle AvgRound Cal
						AvgCirDis = (TotalCirDis/CircleCount);
						C6CirRound = AvgCirDis;
					}

					for(int i=0; i<CircleCount; i++){
						// 					C6CircleData[i].Dv = fabs(AvgCirDis - C6CircleData[i].Dis);       // Euresys Circle Fitting 
						C6CircleData[i].Dv = (CirFitDiameter6 - C6CircleData[i].Dis) >0 ?(CirFitDiameter6 - C6CircleData[i].Dis):0;
						if(C6CircleData[i].Dv>MaxDv) MaxDv = C6CircleData[i].Dv;
						if(C6CircleData[i].Dv<MinDv) MinDv = C6CircleData[i].Dv;
					}
					C6CirDeftectCnt  = GetCircleSize(C6CircleData, C6CirDefectPoint, CircleCount, 5);

					if(!IsMarkBtm && C6CirInCrackCount>0 && BrokenThresHold!=0){
						for(int i=0; i<C6CirInCrackCount; i++){
							C6CircleData[i].Dv  =0.0f;
							C6CircleData[i].Dis =0.0f;
							C6CircleData[i].P.x  = C6CirInCrackPoint[i].x;
							C6CircleData[i].P.y  = C6CirInCrackPoint[i].y;
						}
						IAddress = RotateBrokenImg.GetImagePtr(); // Pixel 정보 추출 목적 
						C6CirCrackCnt  = GetCircleCrackSize(C6CircleData, C6CirCrackPoint, C6CirInCrackCount, 30, CrackCirDiameter6,CircleFit6Center);
					}
				}
			}


			// Side D 
			///////////////////////////////////////////////////////////////////////////////////////////////////////////////
			//LogUnit.SetLog("CUP_Side_D_Start_CamId: %d, ImageHeight: %d ",CamId,ImageHeight);     
// 			DefectROI.SetPlacement((int)(SP.x+SideMargin),(int)(SP.y+BtmMargin), FLeftWidth, LeftHeight-(2*BtmMargin));
// 			if((SP.x+SideMargin) <=0          || SP.y+BtmMargin<0            || FLeftWidth<=0          || LeftHeight-(2*BtmMargin)< 0          ) return false;
// 			if((SP.x+SideMargin) >=ImageWidth || SP.y+BtmMargin>BtmLimitLine || FLeftWidth>=ImageWidth || LeftHeight-(2*BtmMargin)>BtmLimitLine) return false;
// 			if((SP.x+SideMargin)+FLeftWidth >=ImageWidth || (SP.y+BtmMargin)+(LeftHeight-(2*BtmMargin))>BtmLimitLine                           ) return false;

			IAddress = DefectImg.GetImagePtr(); // Pixel 정보 추출 목적 
			DefectROI.SetPlacement((int)(SP.x+SideMargin),(int)(SP.y+LeftDegMargin), FLeftWidth, LeftHeight-(2*LeftDegMargin));
			if((SP.x+SideMargin) <=0          || SP.y+LeftDegMargin<0            || FLeftWidth<=0          || LeftHeight-(2*LeftDegMargin)< 0          ) return false;
			if((SP.x+SideMargin) >=ImageWidth || SP.y+LeftDegMargin>BtmLimitLine || FLeftWidth>=ImageWidth || LeftHeight-(2*LeftDegMargin)>BtmLimitLine) return false;
			if((SP.x+SideMargin)+FLeftWidth >=ImageWidth || (SP.y+LeftDegMargin)+(LeftHeight-(2*LeftDegMargin))>BtmLimitLine                           ) return false;

			// Line Position 
			LinePosition = SP.x+SideMargin;
			// Blob 검사 진행 
			CodeImageSelection.Clear();
			CodeImageEncoder.Encode(DefectROI,CodeImage);
			CodeImageSelection.Clear();
			CodeImageSelection.AddObjects(CodeImage);
			// Blob 필터링 
			CodeImageSelection.RemoveUsingFloatFeature(EFeature_BoundingBoxWidth ,FMinWidth , FMaxWidth  , EDoubleThresholdMode_Outside);
			CodeImageSelection.RemoveUsingFloatFeature(EFeature_BoundingBoxHeight,FMinHeight, FMaxHeight , EDoubleThresholdMode_Outside);
			// 				CodeImageSelection.RemoveUsingIntegerFeature(EFeature_LeftLimit        ,0       , 3          , EDoubleThresholdMode_Outside);
			CodeImageSelection.RemoveUsingIntegerFeature(EFeature_LeftLimit        ,0       , 1          , EDoubleThresholdMode_Outside);

			BlobCount = CodeImageSelection.GetElementCount();
			CodeImageSelection.Sort(EFeature_TopLimit,ESortDirection_Ascending);

			if(BlobCount!=0){
				for(int k=0; k<BlobCount; k++){
					if(DCount>=MAX_DEFECT_POINT) break;
					DDefectPoint[DCount].Width  =  CodeImageSelection.GetElement(k).GetBoundingBoxWidth() ;
					DDefectPoint[DCount].Height =  CodeImageSelection.GetElement(k).GetBoundingBoxHeight();

					DDefectPoint[DCount].Rect.left   =(long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterX() - DDefectPoint[DCount].Width/2 ) +LinePosition );
					DDefectPoint[DCount].Rect.top    =(long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - DDefectPoint[DCount].Height/2)+(SP.y+LeftDegMargin));
					DDefectPoint[DCount].Rect.right  =(long)(DDefectPoint[DCount].Rect.left+ DDefectPoint[DCount].Width );
					DDefectPoint[DCount].Rect.bottom =(long)(DDefectPoint[DCount].Rect.top + DDefectPoint[DCount].Height);
					PixelCount =0;
					PixelValue =0;

					// 내부 Pixel Data 축출 
					for(int n=DDefectPoint[DCount].Rect.top+1 ; n<DDefectPoint[DCount].Rect.bottom-1; n++){
						for(int m=DDefectPoint[DCount].Rect.left+1; m<DDefectPoint[DCount].Rect.right-1 ; m++){
							PixelValue = IElement(m,n);
							if(PixelValue < EnCapBtmThresHold) PixelCount++;
						}
					}

					DDefectPoint[DCount].Round = PixelCount;
					DDefectPoint[DCount].P.x    =(float)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterX() - DDefectPoint[DCount].Width/2 ) +LinePosition);
					DDefectPoint[DCount].P.y    =(float)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - DDefectPoint[DCount].Height/2)+(SP.y+LeftDegMargin)+ImageHeight);
					DDefectPoint[DCount].Width  = (InspectMode)?DDefectPoint[DCount].Width: DDefectPoint[DCount].Width+SideMargin;

					// Merge 위해서 데이터 필요함 
					DDefectPoint[DCount].Rect.top    =(long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - DDefectPoint[DCount].Height/2) +(SP.y+LeftDegMargin)+ImageHeight);
					DDefectPoint[DCount].Rect.bottom =(long)(DDefectPoint[DCount].Rect.top + DDefectPoint[DCount].Height);
					DCount++;
				}
			}
			BlobCount=0;
			// 외곽라인에서 Mark까지의 거리 산출 
			if     (Line[waLeftWall].FP0.x >Line[waLeftWall].FP1.x) LDistance = FP0.x - (Line[waLeftWall].FP1.x+(Line[waLeftWall].FP0.x - Line[waLeftWall].FP1.x)/2);
			else if(Line[waLeftWall].FP0.x==Line[waLeftWall].FP1.x) LDistance = FP0.x -  Line[waLeftWall].FP0.x;
			else                                                    LDistance = FP0.x - (Line[waLeftWall].FP0.x+(Line[waLeftWall].FP1.x - Line[waLeftWall].FP0.x)/2); 
			////////////////////////////////////////////////////////////////////////////////////////////////


			// Side B
			////////////////////////////////////////////////////////////////////////////////////////////////
			DefectROI.SetPlacement((int)(EP.x-FRightWidth-SideMargin),(int)(EP.y+RightDegMargin), FRightWidth,  RightHeight-(2*RightDegMargin));
			if((EP.x-FRightWidth-SideMargin) <=0          || (EP.y+RightDegMargin)<0            || FRightWidth<=0          || RightHeight-(2*RightDegMargin)<0           ) return false;
			if((EP.x-FRightWidth-SideMargin) >=ImageWidth || (EP.y+RightDegMargin)>BtmLimitLine || FRightWidth>=ImageWidth || RightHeight-(2*RightDegMargin)>BtmLimitLine) return false;
			if((EP.x-FRightWidth-SideMargin)+FRightWidth >=ImageWidth || (EP.y+RightDegMargin)+(RightHeight-(2*RightDegMargin))>BtmLimitLine                             ) return false;

// 			DefectROI.SetPlacement((int)(EP.x-FRightWidth-SideMargin),(int)(EP.y+BtmMargin), FRightWidth,  RightHeight-(2*BtmMargin));
// 			if((EP.x-FRightWidth-SideMargin) <=0          || (EP.y+BtmMargin)<0            || FRightWidth<=0          || RightHeight-(2*BtmMargin)<0           ) return false;
// 			if((EP.x-FRightWidth-SideMargin) >=ImageWidth || (EP.y+BtmMargin)>BtmLimitLine || FRightWidth>=ImageWidth || RightHeight-(2*BtmMargin)>BtmLimitLine) return false;
// 			if((EP.x-FRightWidth-SideMargin)+FRightWidth >=ImageWidth || (EP.y+BtmMargin)+(RightHeight-(2*BtmMargin))>BtmLimitLine                             ) return false;

			// Line Position 
			LinePosition = EP.x - FRightWidth- SideMargin;
			// Blob 검사 진행 
			CodeImageSelection.Clear();
			CodeImageEncoder.Encode(DefectROI,CodeImage);
			CodeImageSelection.Clear();
			CodeImageSelection.AddObjects(CodeImage);
			// Blob 필터링 
			CodeImageSelection.RemoveUsingFloatFeature  (EFeature_BoundingBoxWidth ,FMinWidth               , FMaxWidth                , EDoubleThresholdMode_Outside);
			CodeImageSelection.RemoveUsingFloatFeature  (EFeature_BoundingBoxHeight,FMinHeight              , FMaxHeight               , EDoubleThresholdMode_Outside);
			CodeImageSelection.RemoveUsingIntegerFeature(EFeature_RightLimit       ,FRightWidth -1          , FRightWidth+1            , EDoubleThresholdMode_Outside);

			BlobCount = CodeImageSelection.GetElementCount();
			CodeImageSelection.Sort(EFeature_TopLimit,ESortDirection_Ascending);

			if(BlobCount!=0){
				for(int k=0; k<BlobCount; k++){
					if(BCount>=MAX_DEFECT_POINT) break;
					BDefectPoint[BCount].Width  = CodeImageSelection.GetElement(k).GetBoundingBoxWidth() ; 
					BDefectPoint[BCount].Height = CodeImageSelection.GetElement(k).GetBoundingBoxHeight();

					BDefectPoint[BCount].Rect.left   =(long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterX() - BDefectPoint[BCount].Width/2 ) +(LinePosition)  );
					BDefectPoint[BCount].Rect.top    =(long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - BDefectPoint[BCount].Height/2) +(EP.y+RightDegMargin));
					BDefectPoint[BCount].Rect.right  =(long)(BDefectPoint[BCount].Rect.left+ BDefectPoint[BCount].Width );
					BDefectPoint[BCount].Rect.bottom =(long)(BDefectPoint[BCount].Rect.top + BDefectPoint[BCount].Height);
					PixelCount = 0;
					PixelValue = 0;

					// 내부 Pixel Data 축출 
					for(int n=BDefectPoint[BCount].Rect.top+1 ; n<BDefectPoint[BCount].Rect.bottom-1; n++){
						for(int m=BDefectPoint[BCount].Rect.left+1; m<BDefectPoint[BCount].Rect.right-1 ; m++){
							PixelValue = IElement(m,n);
							if(PixelValue < EnCapBtmThresHold) PixelCount++;
						}
					}
					BDefectPoint[BCount].Round  = PixelCount;
					BDefectPoint[BCount].P.x    =(float)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterX() - BDefectPoint[BCount].Width/2 )+(LinePosition));
					BDefectPoint[BCount].P.y    =(float)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - BDefectPoint[BCount].Height/2)+(EP.y+RightDegMargin)+ImageHeight   );
					BDefectPoint[BCount].Width  =(InspectMode)? BDefectPoint[BCount].Width: BDefectPoint[BCount].Width+SideMargin;

					// Merge 위해서 데이터 필요함 
					BDefectPoint[BCount].Rect.top    =(long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - BDefectPoint[BCount].Height/2) +(EP.y+RightDegMargin)+ImageHeight);
					BDefectPoint[BCount].Rect.bottom =(long)(BDefectPoint[BCount].Rect.top + BDefectPoint[BCount].Height);
					BCount++;
				}
			}
			BlobCount =0;
			// 외곽라인에서 Mark까지의 거리 산출 
			if     (Line[waRightWall].FP0.x >Line[waRightWall].FP1.x) RDistance = (Line[waRightWall].FP1.x+(Line[waRightWall].FP0.x - Line[waRightWall].FP1.x)/2) - FP1.x;
			else if(Line[waRightWall].FP0.x==Line[waRightWall].FP1.x) RDistance =  Line[waRightWall].FP0.x - FP1.x;
			else                                                      RDistance = (Line[waRightWall].FP0.x+(Line[waRightWall].FP1.x - Line[waRightWall].FP0.x)/2) - FP1.x;
			////////////////////////////////////////////////////////////////////////////////////////////////

			// Side C 
			// Circle 검사 후 6개의 좌표기준으로 5개의 영역 검사 진행함 
			///////////////////////////////////////////////////////////////////////////////////////////////
			// Notch부 직선영역 Dark Defect 검사 시퀀스 시작 
			//첫번째 Btm영역의 직선라인 기준 검사 
			if(BtmInLine[0].FP0.x!=0 && BtmInLine[0].FP0.y!=0 && BtmInLine[0].FP1.x!=0 && BtmInLine[0].FP1.y!=0){
				DefectROI.SetPlacement((int)(BtmInLine[0].FP0.x+SideMargin), (int)(BtmInLine[0].FP0.y-FBtmHeight), (BtmInLine[0].FP1.x - BtmInLine[0].FP0.x)-(2*SideMargin), FBtmHeight);
				if((BtmInLine[0].FP0.x+SideMargin) <=0          ||(BtmInLine[0].FP0.y-FBtmHeight)< 0           || (BtmInLine[0].FP1.x - BtmInLine[0].FP0.x)-(2*SideMargin)<=0          || FBtmHeight< 0          ) return false;
				if((BtmInLine[0].FP0.x+SideMargin) >=ImageWidth ||(BtmInLine[0].FP0.y-FBtmHeight)>BtmLimitLine || (BtmInLine[0].FP1.x - BtmInLine[0].FP0.x)-(2*SideMargin)>=ImageWidth || FBtmHeight>BtmLimitLine) return false;
				if((BtmInLine[0].FP0.x+SideMargin)+((BtmInLine[0].FP1.x - BtmInLine[0].FP0.x)-(2*SideMargin)) >=ImageWidth ||(BtmInLine[0].FP0.y-FBtmHeight)+FBtmHeight>BtmLimitLine                             ) return false;
				//Blob 검사 진행함 
				CodeImageSelection.Clear();
				CodeImageEncoder.Encode(DefectROI,CodeImage);
				CodeImageSelection.Clear();
				CodeImageSelection.AddObjects(CodeImage);
				// Blob 필터링 
				CodeImageSelection.RemoveUsingFloatFeature  (EFeature_BoundingBoxWidth ,FMinWidth      , FMaxWidth   , EDoubleThresholdMode_Outside);
				CodeImageSelection.RemoveUsingFloatFeature  (EFeature_BoundingBoxHeight,FMinHeight     , FMaxHeight  , EDoubleThresholdMode_Outside);
				CodeImageSelection.RemoveUsingIntegerFeature(EFeature_BottomLimit      ,FBtmHeight-1   , FBtmHeight+1, EDoubleThresholdMode_Outside);

				BlobCount = CodeImageSelection.GetElementCount();
				CodeImageSelection.Sort(EFeature_LeftLimit ,ESortDirection_Ascending);

				if(BlobCount!=0){
					for(int k=0; k<BlobCount; k++){
						if(CCount>=MAX_DEFECT_POINT) break; 
						CDefectPoint[CCount].Width  =  CodeImageSelection.GetElement(k).GetBoundingBoxWidth() ;
						CDefectPoint[CCount].Height =  CodeImageSelection.GetElement(k).GetBoundingBoxHeight();

						CDefectPoint[CCount].Rect.left   =(long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterX() - CDefectPoint[CCount].Width/2 ) +(BtmInLine[0].FP0.x+SideMargin));
						CDefectPoint[CCount].Rect.top    =(long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - CDefectPoint[CCount].Height/2) +(BtmInLine[0].FP0.y-FBtmHeight));
						CDefectPoint[CCount].Rect.right  =(long)(CDefectPoint[CCount].Rect.left+ CDefectPoint[CCount].Width );
						CDefectPoint[CCount].Rect.bottom =(long)(CDefectPoint[CCount].Rect.top + CDefectPoint[CCount].Height);
						PixelCount = 0;
						PixelValue = 0;

						// 내부 Pixel Data 축출 
						for(int n=CDefectPoint[CCount].Rect.top+1 ; n<CDefectPoint[CCount].Rect.bottom-1; n++){
							for(int m=CDefectPoint[CCount].Rect.left+1; m<CDefectPoint[CCount].Rect.right-1 ; m++){
								PixelValue = IElement(m,n);
								if(PixelValue < EnCapBtmThresHold) PixelCount++;
							}
						}
						CDefectPoint[CCount].Round  =  PixelCount;
						CDefectPoint[CCount].P.x    = (float)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterX() - CDefectPoint[CCount].Width/2 ) +(BtmInLine[0].FP0.x+SideMargin));
						CDefectPoint[CCount].P.y    = (float)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - CDefectPoint[CCount].Height/2) +(BtmInLine[0].FP0.y-FBtmHeight));

						// Image Rotate 기준 좌표를 다시 Rotate한다 _ Display 목적 
						if(ImgDegree!=0.0f){
							CDefectPoint[CCount].P = Math.OnRotate(CenterPoint, CDefectPoint[CCount].P, (ImgDegree));
						}
						// Image Rotate 기준 좌표를 회전 이후에 ImageHeight값을 더하여 실제 좌표를 산출한다 
						CDefectPoint[CCount].P.y    =(float)(CDefectPoint[CCount].P.y+ImageHeight);

						// Merge 위해서 데이터 필요함 
						CDefectPoint[CCount].Rect.top    =(long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - CDefectPoint[CCount].Height/2) +(BtmInLine[0].FP0.y-FBtmHeight)+ImageHeight);
						CDefectPoint[CCount].Rect.bottom =(long)(CDefectPoint[CCount].Rect.top + CDefectPoint[CCount].Height);
						CCount++;
					}
				}
			}
			BlobCount =0;

			///////////////////////////////////////////////////////////////////////////////////////////////
			//두번째 Btm영역의 직선라인 기준 검사 
			if(BtmInLine[1].FP0.x!=0 && BtmInLine[1].FP0.y!=0 && BtmInLine[1].FP1.x!=0 && BtmInLine[1].FP1.y!=0){
				DefectROI.SetPlacement((int)(BtmInLine[1].FP0.x-FRightWidth-SideMargin),(int)(BtmInLine[1].FP0.y), FRightWidth,  (BtmInLine[1].FP1.y - BtmInLine[1].FP0.y));
				if((BtmInLine[1].FP0.x-FRightWidth-SideMargin) <=0          || (BtmInLine[1].FP0.y)<0            || FRightWidth<=0          || (BtmInLine[1].FP1.y - BtmInLine[1].FP0.y)<=0          ) return false;
				if((BtmInLine[1].FP0.x-FRightWidth-SideMargin) >=ImageWidth || (BtmInLine[1].FP0.y)>BtmLimitLine || FRightWidth>=ImageWidth || (BtmInLine[1].FP1.y - BtmInLine[1].FP0.y)>BtmLimitLine) return false;
				if((BtmInLine[1].FP0.x-FRightWidth-SideMargin)+ FRightWidth >=ImageWidth ||(BtmInLine[1].FP0.y)+(BtmInLine[1].FP1.y - BtmInLine[1].FP0.y)>BtmLimitLine                               ) return false;

				// Line Position 
				LinePosition = BtmInLine[1].FP0.x-FRightWidth-SideMargin;
				// Blob 검사 진행 
				CodeImageSelection.Clear();
				CodeImageEncoder.Encode(DefectROI,CodeImage);
				CodeImageSelection.Clear();
				CodeImageSelection.AddObjects(CodeImage);
				// Blob 필터링 
				CodeImageSelection.RemoveUsingFloatFeature  (EFeature_BoundingBoxWidth ,FMinWidth               , FMaxWidth                , EDoubleThresholdMode_Outside);
				CodeImageSelection.RemoveUsingFloatFeature  (EFeature_BoundingBoxHeight,FMinHeight              , FMaxHeight               , EDoubleThresholdMode_Outside);
				CodeImageSelection.RemoveUsingIntegerFeature(EFeature_RightLimit     ,FRightWidth -1            , FRightWidth+1            , EDoubleThresholdMode_Outside);

				BlobCount = CodeImageSelection.GetElementCount();
				CodeImageSelection.Sort(EFeature_TopLimit,ESortDirection_Ascending);

				if(BlobCount!=0){
					for(int k=0; k<BlobCount; k++){
						if(BCount>=MAX_DEFECT_POINT) break;
						BDefectPoint[BCount].Width  = CodeImageSelection.GetElement(k).GetBoundingBoxWidth() ; 
						BDefectPoint[BCount].Height = CodeImageSelection.GetElement(k).GetBoundingBoxHeight();

						BDefectPoint[BCount].Rect.left   =(long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterX() - BDefectPoint[BCount].Width/2 ) +(LinePosition)      );
						BDefectPoint[BCount].Rect.top    =(long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - BDefectPoint[BCount].Height/2) +(BtmInLine[1].FP0.y));
						BDefectPoint[BCount].Rect.right  =(long)(BDefectPoint[BCount].Rect.left+ BDefectPoint[BCount].Width );
						BDefectPoint[BCount].Rect.bottom =(long)(BDefectPoint[BCount].Rect.top + BDefectPoint[BCount].Height);
						PixelCount = 0;
						PixelValue = 0;

						// 내부 Pixel Data 축출 
						for(int n=BDefectPoint[BCount].Rect.top+1 ; n<BDefectPoint[BCount].Rect.bottom-1; n++){
							for(int m=BDefectPoint[BCount].Rect.left+1; m<BDefectPoint[BCount].Rect.right-1 ; m++){
								PixelValue = IElement(m,n);
								if(PixelValue < EnCapBtmThresHold) PixelCount++;
							}
						}
						BDefectPoint[BCount].Round  = PixelCount;
						BDefectPoint[BCount].P.x    =(float)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterX() - BDefectPoint[BCount].Width/2 )+(LinePosition));
						BDefectPoint[BCount].P.y    =(float)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - BDefectPoint[BCount].Height/2)+(BtmInLine[1].FP0.y)+ImageHeight);
						BDefectPoint[BCount].Width  =(InspectMode)? BDefectPoint[BCount].Width: BDefectPoint[BCount].Width+SideMargin;

						// Merge 위해서 데이터 필요함 
						BDefectPoint[BCount].Rect.top    =(long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - BDefectPoint[BCount].Height/2) +(BtmInLine[1].FP0.y)+ImageHeight);
						BDefectPoint[BCount].Rect.bottom =(long)(BDefectPoint[BCount].Rect.top + BDefectPoint[BCount].Height);
						BCount++;
					}
				}
			}
			BlobCount =0;

			///////////////////////////////////////////////////////////////////////////////////////////////
			//세번째 Btm영역의 직선라인 기준 검사 
			//Dark Defect 
			if(BtmInLine[2].FP0.x!=0 && BtmInLine[2].FP0.y!=0 && BtmInLine[2].FP1.x!=0 && BtmInLine[2].FP1.y!=0){
// 				DefectROI.SetPlacement((int)(BtmInLine[2].FP0.x+SideMargin), (int)(BtmInLine[2].FP0.y-50),(BtmInLine[2].FP1.x - BtmInLine[2].FP0.x)-(2*SideMargin), 50);
				DefectROI.SetPlacement((int)(BtmInLine[2].FP0.x+SideMargin), (int)(BtmInLine[2].FP0.y-FBtmHeight),(BtmInLine[2].FP1.x - BtmInLine[2].FP0.x)-(2*SideMargin), FBtmHeight);
				if((BtmInLine[2].FP0.x+SideMargin) <=0          ||(BtmInLine[2].FP0.y-FBtmHeight)< 0           || (BtmInLine[2].FP1.x - BtmInLine[2].FP0.x)-(2*SideMargin)<=0          || FBtmHeight<0           ) return false;
				if((BtmInLine[2].FP0.x+SideMargin) >=ImageWidth ||(BtmInLine[2].FP0.y-FBtmHeight)>BtmLimitLine || (BtmInLine[2].FP1.x - BtmInLine[2].FP0.x)-(2*SideMargin)>=ImageWidth || FBtmHeight>BtmLimitLine) return false;
// 				if((BtmInLine[2].FP0.x+SideMargin) <=0          ||(BtmInLine[2].FP0.y-50)< 0           || (BtmInLine[2].FP1.x - BtmInLine[2].FP0.x)-(2*SideMargin)<=0          || FBtmHeight<0           ) return false;
// 				if((BtmInLine[2].FP0.x+SideMargin) >=ImageWidth ||(BtmInLine[2].FP0.y-50)>BtmLimitLine || (BtmInLine[2].FP1.x - BtmInLine[2].FP0.x)-(2*SideMargin)>=ImageWidth || FBtmHeight>BtmLimitLine) return false;
				if((BtmInLine[2].FP0.x+SideMargin) +(BtmInLine[2].FP1.x - BtmInLine[2].FP0.x)-(2*SideMargin)>=ImageWidth ||(BtmInLine[2].FP0.y-FBtmHeight)+FBtmHeight>BtmLimitLine                               ) return false;
				//Blob 검사 진행함 
				CodeImageSelection.Clear();
				CodeImageEncoder.Encode(DefectROI,CodeImage);
				CodeImageSelection.Clear();
				CodeImageSelection.AddObjects(CodeImage);
				// Blob 필터링 
				CodeImageSelection.RemoveUsingFloatFeature  (EFeature_BoundingBoxWidth ,FMinWidth      , FMaxWidth   , EDoubleThresholdMode_Outside);
				CodeImageSelection.RemoveUsingFloatFeature  (EFeature_BoundingBoxHeight,FMinHeight     , FMaxHeight  , EDoubleThresholdMode_Outside);
				CodeImageSelection.RemoveUsingIntegerFeature(EFeature_BottomLimit      ,FBtmHeight-1   , FBtmHeight+1, EDoubleThresholdMode_Outside);

				BlobCount = CodeImageSelection.GetElementCount();
				CodeImageSelection.Sort(EFeature_LeftLimit ,ESortDirection_Ascending);

				if(BlobCount!=0){
					for(int k=0; k<BlobCount; k++){
						if(CCount>=MAX_DEFECT_POINT) break; 
						CDefectPoint[CCount].Width  =  CodeImageSelection.GetElement(k).GetBoundingBoxWidth() ;
						CDefectPoint[CCount].Height =  CodeImageSelection.GetElement(k).GetBoundingBoxHeight();

						CDefectPoint[CCount].Rect.left   =(long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterX() - CDefectPoint[CCount].Width/2 ) +(BtmInLine[2].FP0.x+SideMargin));
						CDefectPoint[CCount].Rect.top    =(long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - CDefectPoint[CCount].Height/2) +(BtmInLine[2].FP0.y-FBtmHeight));
						CDefectPoint[CCount].Rect.right  =(long)(CDefectPoint[CCount].Rect.left+ CDefectPoint[CCount].Width );
						CDefectPoint[CCount].Rect.bottom =(long)(CDefectPoint[CCount].Rect.top + CDefectPoint[CCount].Height);
						PixelCount = 0;
						PixelValue = 0;

						// 내부 Pixel Data 축출 
						for(int n=CDefectPoint[CCount].Rect.top+1 ; n<CDefectPoint[CCount].Rect.bottom-1; n++){
							for(int m=CDefectPoint[CCount].Rect.left+1; m<CDefectPoint[CCount].Rect.right-1 ; m++){
								PixelValue = IElement(m,n);
								if(PixelValue < EnCapBtmThresHold) PixelCount++;
							}
						}
						CDefectPoint[CCount].Round  =  PixelCount;
						CDefectPoint[CCount].P.x    = (float)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterX() - CDefectPoint[CCount].Width/2 ) +(BtmInLine[2].FP0.x+SideMargin));
						CDefectPoint[CCount].P.y    = (float)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - CDefectPoint[CCount].Height/2) +(BtmInLine[2].FP0.y-FBtmHeight));

						// Image Rotate 기준 좌표를 다시 Rotate한다 _ Display 목적 
						if(ImgDegree!=0.0f){
							CDefectPoint[CCount].P = Math.OnRotate(CenterPoint, CDefectPoint[CCount].P, (ImgDegree));
						}
						// Image Rotate 기준 좌표를 회전 이후에 ImageHeight값을 더하여 실제 좌표를 산출한다 
						CDefectPoint[CCount].P.y    =(float)(CDefectPoint[CCount].P.y+ImageHeight);

						// Merge 위해서 데이터 필요함 
						CDefectPoint[CCount].Rect.top    =(long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - CDefectPoint[CCount].Height/2) +(BtmInLine[2].FP0.y-FBtmHeight)+ImageHeight);
						CDefectPoint[CCount].Rect.bottom =(long)(CDefectPoint[CCount].Rect.top + CDefectPoint[CCount].Height);
						CCount++;
					}
				}
			}
			BlobCount =0;

			///////////////////////////////////////////////////////////////////////////////////////////////
			//네번째 Btm영역의 직선라인 기준 검사 
			if(BtmInLine[3].FP0.x!=0 && BtmInLine[3].FP0.y!=0 && BtmInLine[3].FP1.x!=0 && BtmInLine[3].FP1.y!=0){
				DefectROI.SetPlacement((int)(BtmInLine[3].FP0.x+SideMargin),(int)(BtmInLine[3].FP0.y), FLeftWidth, (BtmInLine[3].FP1.y - BtmInLine[3].FP0.y));
				if((BtmInLine[3].FP0.x+SideMargin) <=0          || BtmInLine[3].FP0.y<0            || FLeftWidth<=0          || (BtmInLine[3].FP1.y - BtmInLine[3].FP0.y)< 0          ) return false;
				if((BtmInLine[3].FP0.x+SideMargin) >=ImageWidth || BtmInLine[3].FP0.y>BtmLimitLine || FLeftWidth>=ImageWidth || (BtmInLine[3].FP1.y - BtmInLine[3].FP0.y)>BtmLimitLine) return false;
				if((BtmInLine[3].FP0.x+SideMargin)+FLeftWidth >=ImageWidth || BtmInLine[3].FP0.y+(BtmInLine[3].FP1.y - BtmInLine[3].FP0.y)>BtmLimitLine                               ) return false;
				// Line Position 
				LinePosition = BtmInLine[3].FP0.x+SideMargin;
				// Blob 검사 진행 
				CodeImageSelection.Clear();
				CodeImageEncoder.Encode(DefectROI,CodeImage);
				CodeImageSelection.Clear();
				CodeImageSelection.AddObjects(CodeImage);
				// Blob 필터링 
				CodeImageSelection.RemoveUsingFloatFeature(EFeature_BoundingBoxWidth ,FMinWidth , FMaxWidth  , EDoubleThresholdMode_Outside);
				CodeImageSelection.RemoveUsingFloatFeature(EFeature_BoundingBoxHeight,FMinHeight, FMaxHeight , EDoubleThresholdMode_Outside);
				// 				CodeImageSelection.RemoveUsingIntegerFeature(EFeature_LeftLimit        ,0       , 3          , EDoubleThresholdMode_Outside);
				CodeImageSelection.RemoveUsingIntegerFeature(EFeature_LeftLimit        ,0       , 1          , EDoubleThresholdMode_Outside);

				BlobCount = CodeImageSelection.GetElementCount();
				CodeImageSelection.Sort(EFeature_TopLimit,ESortDirection_Ascending);

				if(BlobCount!=0){
					for(int k=0; k<BlobCount; k++){
						if(DCount>=MAX_DEFECT_POINT) break;
						DDefectPoint[DCount].Width  =  CodeImageSelection.GetElement(k).GetBoundingBoxWidth() ;
						DDefectPoint[DCount].Height =  CodeImageSelection.GetElement(k).GetBoundingBoxHeight();

						DDefectPoint[DCount].Rect.left   =(long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterX() - DDefectPoint[DCount].Width/2 ) +LinePosition );
						DDefectPoint[DCount].Rect.top    =(long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - DDefectPoint[DCount].Height/2)+(BtmInLine[3].FP0.y));
						DDefectPoint[DCount].Rect.right  =(long)(DDefectPoint[DCount].Rect.left+ DDefectPoint[DCount].Width );
						DDefectPoint[DCount].Rect.bottom =(long)(DDefectPoint[DCount].Rect.top + DDefectPoint[DCount].Height);
						PixelCount =0;
						PixelValue =0;

						// 내부 Pixel Data 축출 
						for(int n=DDefectPoint[DCount].Rect.top+1 ; n<DDefectPoint[DCount].Rect.bottom-1; n++){
							for(int m=DDefectPoint[DCount].Rect.left+1; m<DDefectPoint[DCount].Rect.right-1 ; m++){
								PixelValue = IElement(m,n);
								if(PixelValue < EnCapBtmThresHold) PixelCount++;
							}
						}

						DDefectPoint[DCount].Round = PixelCount;
						DDefectPoint[DCount].P.x    =(float)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterX() - DDefectPoint[DCount].Width/2 ) +LinePosition);
						DDefectPoint[DCount].P.y    =(float)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - DDefectPoint[DCount].Height/2)+(BtmInLine[3].FP0.y)+ImageHeight);
						DDefectPoint[DCount].Width  = (InspectMode)?DDefectPoint[DCount].Width: DDefectPoint[DCount].Width+SideMargin;

						// Merge 위해서 데이터 필요함 
						DDefectPoint[DCount].Rect.top    =(long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - DDefectPoint[DCount].Height/2) +(BtmInLine[3].FP0.y)+ImageHeight);
						DDefectPoint[DCount].Rect.bottom =(long)(DDefectPoint[DCount].Rect.top + DDefectPoint[DCount].Height);
						DCount++;
					}
				}
			}
			BlobCount =0;

			///////////////////////////////////////////////////////////////////////////////////////////////
			//다섯번째 Btm영역의 직선라인 기준 검사 
			if(BtmInLine[4].FP0.x!=0 && BtmInLine[4].FP0.y!=0 && BtmInLine[4].FP1.x!=0 && BtmInLine[4].FP1.y!=0){
				DefectROI.SetPlacement((int)(BtmInLine[4].FP0.x+SideMargin), (int)(BtmInLine[4].FP0.y-FBtmHeight),(BtmInLine[4].FP1.x - BtmInLine[4].FP0.x)-(2*SideMargin), FBtmHeight);
				if((BtmInLine[4].FP0.x+SideMargin) <=0          ||(BtmInLine[4].FP0.y-FBtmHeight)<0            || (BtmInLine[4].FP1.x - BtmInLine[4].FP0.x)-(2*SideMargin)<=0          || FBtmHeight< 0          ) return false;
				if((BtmInLine[4].FP0.x+SideMargin) >=ImageWidth ||(BtmInLine[4].FP0.y-FBtmHeight)>BtmLimitLine || (BtmInLine[4].FP1.x - BtmInLine[4].FP0.x)-(2*SideMargin)>=ImageWidth || FBtmHeight>BtmLimitLine) return false;
				if((BtmInLine[4].FP0.x+SideMargin) + (BtmInLine[4].FP1.x - BtmInLine[4].FP0.x)-(2*SideMargin) >=ImageWidth ||(BtmInLine[4].FP0.y-FBtmHeight)+FBtmHeight>BtmLimitLine                             ) return false;
				//Blob 검사 진행함 
				CodeImageSelection.Clear();
				CodeImageEncoder.Encode(DefectROI,CodeImage);
				CodeImageSelection.Clear();
				CodeImageSelection.AddObjects(CodeImage);
				// Blob 필터링 
				CodeImageSelection.RemoveUsingFloatFeature  (EFeature_BoundingBoxWidth ,FMinWidth      , FMaxWidth   , EDoubleThresholdMode_Outside);
				CodeImageSelection.RemoveUsingFloatFeature  (EFeature_BoundingBoxHeight,FMinHeight     , FMaxHeight  , EDoubleThresholdMode_Outside);
				CodeImageSelection.RemoveUsingIntegerFeature(EFeature_BottomLimit      ,FBtmHeight-1   , FBtmHeight+1, EDoubleThresholdMode_Outside);

				BlobCount = CodeImageSelection.GetElementCount();
				CodeImageSelection.Sort(EFeature_LeftLimit ,ESortDirection_Ascending);

				if(BlobCount!=0){
					for(int k=0; k<BlobCount; k++){
						if(CCount>=MAX_DEFECT_POINT) break; 
						CDefectPoint[CCount].Width  =  CodeImageSelection.GetElement(k).GetBoundingBoxWidth() ;
						CDefectPoint[CCount].Height =  CodeImageSelection.GetElement(k).GetBoundingBoxHeight();

						CDefectPoint[CCount].Rect.left   =(long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterX() - CDefectPoint[CCount].Width/2 ) +(BtmInLine[4].FP0.x+SideMargin));
						CDefectPoint[CCount].Rect.top    =(long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - CDefectPoint[CCount].Height/2) +(BtmInLine[4].FP0.y-FBtmHeight));
						CDefectPoint[CCount].Rect.right  =(long)(CDefectPoint[CCount].Rect.left+ CDefectPoint[CCount].Width );
						CDefectPoint[CCount].Rect.bottom =(long)(CDefectPoint[CCount].Rect.top + CDefectPoint[CCount].Height);
						PixelCount = 0;
						PixelValue = 0;

						// 내부 Pixel Data 축출 
						for(int n=CDefectPoint[CCount].Rect.top+1 ; n<CDefectPoint[CCount].Rect.bottom-1; n++){
							for(int m=CDefectPoint[CCount].Rect.left+1; m<CDefectPoint[CCount].Rect.right-1 ; m++){
								PixelValue = IElement(m,n);
								if(PixelValue < EnCapBtmThresHold) PixelCount++;
							}
						}
						CDefectPoint[CCount].Round  =  PixelCount;
						CDefectPoint[CCount].P.x    = (float)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterX() - CDefectPoint[CCount].Width/2 ) +(BtmInLine[4].FP0.x+SideMargin));
						CDefectPoint[CCount].P.y    = (float)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - CDefectPoint[CCount].Height/2) +(BtmInLine[4].FP0.y-FBtmHeight));

						// Image Rotate 기준 좌표를 다시 Rotate한다 _ Display 목적 
						if(ImgDegree!=0.0f){
							CDefectPoint[CCount].P = Math.OnRotate(CenterPoint, CDefectPoint[CCount].P, (ImgDegree));
						}
						// Image Rotate 기준 좌표를 회전 이후에 ImageHeight값을 더하여 실제 좌표를 산출한다 
						CDefectPoint[CCount].P.y    =(float)(CDefectPoint[CCount].P.y+ImageHeight);

						// Merge 위해서 데이터 필요함 
						CDefectPoint[CCount].Rect.top    =(long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - CDefectPoint[CCount].Height/2) +(BtmInLine[4].FP0.y-FBtmHeight)+ImageHeight);
						CDefectPoint[CCount].Rect.bottom =(long)(CDefectPoint[CCount].Rect.top + CDefectPoint[CCount].Height);
						CCount++;
					}
				}
			}
			BlobCount =0;
			/////////////////////////////////////////////////////////////////////////////////////////////
			// Notch부 직선영역 Dark Defect 검사 시퀀스 종료 

			/////////////////////////////////////////////////////////////////////////////////////////////
			// RF_MODEL 직선영역 Dark Defect 검사 시퀀스 시작 
// 			if(C2CirInEdgeCount==0 && C3CirInEdgeCount==0 && C4CirInEdgeCount==0 && C5CirInEdgeCount==0){
// 
// 			}
			/////////////////////////////////////////////////////////////////////////////////////////////
			// RF_MODEL 직선영역 Dark Defect 검사 시퀀스 종료 


			// 연마 후 세정 작업시 물이 들어갈경우 발생하는 불량 검출 목적 
			// 원형 박리불량, 꽃 박리불량 검출 시퀀스.....EnCap영역에서만 검사를 진행함 
			// Notch부 직선영역 Bright Defect 검사 시퀀스 시작 
			if(BrokenThresHold!=0 && !IsMarkBtm){
				// 이미지 변환 
// 				EasyImage::Threshold(&RotateImg,&DefectImg, BrokenThresHold); 
				DefectROI.Attach(&RotateBrokenImg);
				CodeImageSelection.SetFeretAngle(0.00f);
				CodeImageEncoder.GetGrayscaleSingleThresholdSegmenter().SetWhiteLayerEncoded(true );
				CodeImageEncoder.GetGrayscaleSingleThresholdSegmenter().SetBlackLayerEncoded(false);
				IAddress = RotateBrokenImg.GetImagePtr();

				// TEST 목적 
				FBtmHeight =70;
				// Notch부 직선영역 Dark Defect 검사 시퀀스 시작 
				//첫번째 Btm영역의 직선라인 기준 검사 
// 				if(BtmInLine[0].FP0.x!=0 && BtmInLine[0].FP0.y!=0 && BtmInLine[0].FP1.x!=0 && BtmInLine[0].FP1.y!=0){
// 					DefectROI.SetPlacement((int)(BtmInLine[0].FP0.x+SideMargin), (int)(BtmInLine[0].FP0.y-FBtmHeight), (BtmInLine[0].FP1.x - BtmInLine[0].FP0.x)-(2*SideMargin), FBtmHeight);
// 					if((BtmInLine[0].FP0.x+SideMargin) <=0          ||(BtmInLine[0].FP0.y-FBtmHeight)< 0           || (BtmInLine[0].FP1.x - BtmInLine[0].FP0.x)-(2*SideMargin)<=0          || FBtmHeight< 0          ) return false;
// 					if((BtmInLine[0].FP0.x+SideMargin) >=ImageWidth ||(BtmInLine[0].FP0.y-FBtmHeight)>BtmLimitLine || (BtmInLine[0].FP1.x - BtmInLine[0].FP0.x)-(2*SideMargin)>=ImageWidth || FBtmHeight>BtmLimitLine) return false;
// 					if((BtmInLine[0].FP0.x+SideMargin)+((BtmInLine[0].FP1.x - BtmInLine[0].FP0.x)-(2*SideMargin)) >=ImageWidth ||(BtmInLine[0].FP0.y-FBtmHeight)+FBtmHeight>BtmLimitLine                             ) return false;

				// 새로운 Cell박리 검사 목적...점점 소스가 더러워진다..첨부터  알았으면...이따구로 코딩할수 없을텐데...
				// 4_Round
				if(C2CirInEdgeCount==0 && C3CirInEdgeCount==0 && C4CirInEdgeCount==0 && C5CirInEdgeCount==0){
					if(BtmInLine[0].FP0.x!=0 && BtmInLine[0].FP0.y!=0 && BtmInLine[0].FP1.x!=0 && BtmInLine[0].FP1.y!=0){
						DefectROI.SetPlacement((int)(BtmInLine[0].FP0.x)-50, (int)(BtmInLine[0].FP0.y-FBtmHeight), (BtmInLine[0].FP1.x - BtmInLine[0].FP0.x)+100, FBtmHeight);
						if((BtmInLine[0].FP0.x-50) <=0          ||(BtmInLine[0].FP0.y-FBtmHeight)< 0           || ((BtmInLine[0].FP1.x - BtmInLine[0].FP0.x)+100)<=0          || FBtmHeight< 0          ) return false;
						if((BtmInLine[0].FP0.x-50) >=ImageWidth ||(BtmInLine[0].FP0.y-FBtmHeight)>BtmLimitLine || ((BtmInLine[0].FP1.x - BtmInLine[0].FP0.x)+100)>=ImageWidth || FBtmHeight>BtmLimitLine) return false;
						if((BtmInLine[0].FP0.x-50)+((BtmInLine[0].FP1.x - BtmInLine[0].FP0.x)+100) >=ImageWidth ||( BtmInLine[0].FP0.y-FBtmHeight)+FBtmHeight>BtmLimitLine                             ) return false;

						//Blob 검사 진행함 
						CodeImageSelection.Clear();
						CodeImageEncoder.Encode(DefectROI,CodeImage);
						CodeImageSelection.Clear();
						CodeImageSelection.AddObjects(CodeImage);
						// Blob 필터링 
						CodeImageSelection.RemoveUsingFloatFeature  (EFeature_BoundingBoxWidth ,3     , FMaxWidth   , EDoubleThresholdMode_Outside);
						CodeImageSelection.RemoveUsingFloatFeature  (EFeature_BoundingBoxHeight,3     , FMaxHeight  , EDoubleThresholdMode_Outside);
						// 					CodeImageSelection.RemoveUsingIntegerFeature(EFeature_BottomLimit      ,FBtmHeight-1   , FBtmHeight+1, EDoubleThresholdMode_Outside);

						BlobCount = CodeImageSelection.GetElementCount();
						CodeImageSelection.Sort(EFeature_LeftLimit ,ESortDirection_Ascending);

						if(BlobCount!=0){
							for(int k=0; k<BlobCount; k++){
								if(CCrackCount>=MAX_DEFECT_POINT) break; 
								CCrackPoint[CCrackCount].Width  =  CodeImageSelection.GetElement(k).GetBoundingBoxWidth() ;
								CCrackPoint[CCrackCount].Height =  CodeImageSelection.GetElement(k).GetBoundingBoxHeight();

								CCrackPoint[CCrackCount].Rect.left   =(long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterX() - CCrackPoint[CCrackCount].Width/2 ) +(BtmInLine[0].FP0.x)-50);
								CCrackPoint[CCrackCount].Rect.top    =(long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - CCrackPoint[CCrackCount].Height/2) +(BtmInLine[0].FP0.y-FBtmHeight));
								CCrackPoint[CCrackCount].Rect.right  =(long)(CCrackPoint[CCrackCount].Rect.left+ CCrackPoint[CCrackCount].Width );
								CCrackPoint[CCrackCount].Rect.bottom =(long)(CCrackPoint[CCrackCount].Rect.top + CCrackPoint[CCrackCount].Height);
								CCrackPoint[CCrackCount].LineAttach  =(CodeImageSelection.GetElement(k).GetBottomLimit()>(FBtmHeight-5)) ? 1: 0;
								PixelCount = 0;
								PixelValue = 0;

								// 내부 Pixel Data 축출 
								for(int n=CCrackPoint[CCrackCount].Rect.top+1 ; n<CCrackPoint[CCrackCount].Rect.bottom-1; n++){
									for(int m=CCrackPoint[CCrackCount].Rect.left+1; m<CCrackPoint[CCrackCount].Rect.right-1 ; m++){
										PixelValue = IElement(m,n);
										if(PixelValue > BrokenThresHold) PixelCount++;
									}
								}
								CCrackPoint[CCrackCount].Round  =  PixelCount;
								CCrackPoint[CCrackCount].P.x    = (float)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterX() - CCrackPoint[CCrackCount].Width/2 ) +(BtmInLine[0].FP0.x)-50);
								CCrackPoint[CCrackCount].P.y    = (float)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - CCrackPoint[CCrackCount].Height/2) +(BtmInLine[0].FP0.y-FBtmHeight));

								// Image Rotate 기준 좌표를 다시 Rotate한다 _ Display 목적 
								if(ImgDegree!=0.0f){
									CCrackPoint[CCrackCount].P = Math.OnRotate(CenterPoint, CCrackPoint[CCrackCount].P, (ImgDegree));
								}
								// Image Rotate 기준 좌표를 회전 이후에 ImageHeight값을 더하여 실제 좌표를 산출한다 
								CCrackPoint[CCrackCount].P.y    =(float)(CCrackPoint[CCrackCount].P.y+ImageHeight);

								// Merge 위해서 데이터 필요함 
								CCrackPoint[CCrackCount].Rect.top    =(long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - CCrackPoint[CCrackCount].Height/2) +(BtmInLine[0].FP0.y-FBtmHeight)+ImageHeight);
								CCrackPoint[CCrackCount].Rect.bottom =(long)(CCrackPoint[CCrackCount].Rect.top + CCrackPoint[CCrackCount].Height);
								CCrackCount++;
							}
						}
					}
				}
				BlobCount=0;


				if(BtmEdgePoint[0].x!=0 && BtmInLine[0].FP0.y!=0 && BtmEdgePoint[1].x!=0 && BtmInLine[0].FP1.y!=0){
					DefectROI.SetPlacement((int)(BtmEdgePoint[0].x)-50, (int)(BtmInLine[0].FP0.y-FBtmHeight), (BtmEdgePoint[1].x - BtmEdgePoint[0].x)+100, FBtmHeight);
					if((BtmEdgePoint[0].x-50) <=0          ||(BtmInLine[0].FP0.y-FBtmHeight)< 0           || ((BtmEdgePoint[1].x - BtmEdgePoint[0].x)+100)<=0          || FBtmHeight< 0          ) return false;
					if((BtmEdgePoint[0].x-50) >=ImageWidth ||(BtmInLine[0].FP0.y-FBtmHeight)>BtmLimitLine || ((BtmEdgePoint[1].x - BtmEdgePoint[0].x)+100)>=ImageWidth || FBtmHeight>BtmLimitLine) return false;
					if((BtmEdgePoint[0].x-50)+((BtmEdgePoint[1].x - BtmEdgePoint[0].x)) >=ImageWidth ||(BtmInLine[0].FP0.y-FBtmHeight)+FBtmHeight>BtmLimitLine                             ) return false;

					//Blob 검사 진행함 
					CodeImageSelection.Clear();
					CodeImageEncoder.Encode(DefectROI,CodeImage);
					CodeImageSelection.Clear();
					CodeImageSelection.AddObjects(CodeImage);
					// Blob 필터링 
					CodeImageSelection.RemoveUsingFloatFeature  (EFeature_BoundingBoxWidth ,3     , FMaxWidth   , EDoubleThresholdMode_Outside);
					CodeImageSelection.RemoveUsingFloatFeature  (EFeature_BoundingBoxHeight,3     , FMaxHeight  , EDoubleThresholdMode_Outside);
// 					CodeImageSelection.RemoveUsingIntegerFeature(EFeature_BottomLimit      ,FBtmHeight-1   , FBtmHeight+1, EDoubleThresholdMode_Outside);

					BlobCount = CodeImageSelection.GetElementCount();
					CodeImageSelection.Sort(EFeature_LeftLimit ,ESortDirection_Ascending);

					if(BlobCount!=0){
						for(int k=0; k<BlobCount; k++){
							if(CCrackCount>=MAX_DEFECT_POINT) break; 
							CCrackPoint[CCrackCount].Width  =  CodeImageSelection.GetElement(k).GetBoundingBoxWidth() ;
							CCrackPoint[CCrackCount].Height =  CodeImageSelection.GetElement(k).GetBoundingBoxHeight();

							CCrackPoint[CCrackCount].Rect.left   =(long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterX() - CCrackPoint[CCrackCount].Width/2 ) +(BtmEdgePoint[0].x-50));
							CCrackPoint[CCrackCount].Rect.top    =(long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - CCrackPoint[CCrackCount].Height/2) +(BtmInLine[0].FP0.y-FBtmHeight));
							CCrackPoint[CCrackCount].Rect.right  =(long)(CCrackPoint[CCrackCount].Rect.left+ CCrackPoint[CCrackCount].Width );
							CCrackPoint[CCrackCount].Rect.bottom =(long)(CCrackPoint[CCrackCount].Rect.top + CCrackPoint[CCrackCount].Height);
							CCrackPoint[CCrackCount].LineAttach  =(CodeImageSelection.GetElement(k).GetBottomLimit()>(FBtmHeight-5)) ? 1: 0;
							PixelCount = 0;
							PixelValue = 0;

							// 내부 Pixel Data 축출 
							for(int n=CCrackPoint[CCrackCount].Rect.top+1 ; n<CCrackPoint[CCrackCount].Rect.bottom-1; n++){
								for(int m=CCrackPoint[CCrackCount].Rect.left+1; m<CCrackPoint[CCrackCount].Rect.right-1 ; m++){
									PixelValue = IElement(m,n);
									if(PixelValue > BrokenThresHold) PixelCount++;
								}
							}
							CCrackPoint[CCrackCount].Round  =  PixelCount;
							CCrackPoint[CCrackCount].P.x    = (float)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterX() - CCrackPoint[CCrackCount].Width/2 ) +(BtmEdgePoint[0].x-50));
							CCrackPoint[CCrackCount].P.y    = (float)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - CCrackPoint[CCrackCount].Height/2) +(BtmInLine[0].FP0.y-FBtmHeight));

							// Image Rotate 기준 좌표를 다시 Rotate한다 _ Display 목적 
							if(ImgDegree!=0.0f){
								CCrackPoint[CCrackCount].P = Math.OnRotate(CenterPoint, CCrackPoint[CCrackCount].P, (ImgDegree));
							}
							// Image Rotate 기준 좌표를 회전 이후에 ImageHeight값을 더하여 실제 좌표를 산출한다 
							CCrackPoint[CCrackCount].P.y    =(float)(CCrackPoint[CCrackCount].P.y+ImageHeight);

							// Merge 위해서 데이터 필요함 
							CCrackPoint[CCrackCount].Rect.top    =(long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - CCrackPoint[CCrackCount].Height/2) +(BtmInLine[0].FP0.y-FBtmHeight)+ImageHeight);
							CCrackPoint[CCrackCount].Rect.bottom =(long)(CCrackPoint[CCrackCount].Rect.top + CCrackPoint[CCrackCount].Height);
							CCrackCount++;
						}
					}
				}
				BlobCount =0;

				///////////////////////////////////////////////////////////////////////////////////////////////
				//두번째 Btm영역의 직선라인 기준 검사 
				if(BtmInLine[1].FP0.x!=0 && BtmInLine[1].FP0.y!=0 && BtmInLine[1].FP1.x!=0 && BtmInLine[1].FP1.y!=0){
					DefectROI.SetPlacement((int)(BtmInLine[1].FP0.x-FRightWidth-SideMargin),(int)(BtmInLine[1].FP0.y), FRightWidth,  (BtmInLine[1].FP1.y - BtmInLine[1].FP0.y));
					if((BtmInLine[1].FP0.x-FRightWidth-SideMargin) <=0          || (BtmInLine[1].FP0.y)<0            || FRightWidth<=0          || (BtmInLine[1].FP1.y - BtmInLine[1].FP0.y)<=0          ) return false;
					if((BtmInLine[1].FP0.x-FRightWidth-SideMargin) >=ImageWidth || (BtmInLine[1].FP0.y)>BtmLimitLine || FRightWidth>=ImageWidth || (BtmInLine[1].FP1.y - BtmInLine[1].FP0.y)>BtmLimitLine) return false;
					if((BtmInLine[1].FP0.x-FRightWidth-SideMargin)+ FRightWidth >=ImageWidth ||(BtmInLine[1].FP0.y)+(BtmInLine[1].FP1.y - BtmInLine[1].FP0.y)>BtmLimitLine                               ) return false;

					// Line Position 
					LinePosition = BtmInLine[1].FP0.x-FRightWidth-SideMargin;
					// Blob 검사 진행 
					CodeImageSelection.Clear();
					CodeImageEncoder.Encode(DefectROI,CodeImage);
					CodeImageSelection.Clear();
					CodeImageSelection.AddObjects(CodeImage);
					// Blob 필터링 
					CodeImageSelection.RemoveUsingFloatFeature  (EFeature_BoundingBoxWidth ,3 , FMaxWidth  , EDoubleThresholdMode_Outside);
					CodeImageSelection.RemoveUsingFloatFeature  (EFeature_BoundingBoxHeight,3 , FMaxHeight , EDoubleThresholdMode_Outside);
// 					CodeImageSelection.RemoveUsingIntegerFeature(EFeature_RightLimit     ,FRightWidth -1            , FRightWidth+1            , EDoubleThresholdMode_Outside);

					BlobCount = CodeImageSelection.GetElementCount();
					CodeImageSelection.Sort(EFeature_TopLimit,ESortDirection_Ascending);

					if(BlobCount!=0){
						for(int k=0; k<BlobCount; k++){
							if(BCount>=MAX_DEFECT_POINT) break;
							BCrackPoint[BCrackCount].Width  = CodeImageSelection.GetElement(k).GetBoundingBoxWidth() ; 
							BCrackPoint[BCrackCount].Height = CodeImageSelection.GetElement(k).GetBoundingBoxHeight();

							BCrackPoint[BCrackCount].Rect.left   =(long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterX() - BCrackPoint[BCrackCount].Width/2 ) +(LinePosition)      );
							BCrackPoint[BCrackCount].Rect.top    =(long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - BCrackPoint[BCrackCount].Height/2) +(BtmInLine[1].FP0.y));
							BCrackPoint[BCrackCount].Rect.right  =(long)(BCrackPoint[BCrackCount].Rect.left+ BCrackPoint[BCrackCount].Width );
							BCrackPoint[BCrackCount].Rect.bottom =(long)(BCrackPoint[BCrackCount].Rect.top + BCrackPoint[BCrackCount].Height);
							BCrackPoint[BCrackCount].LineAttach  =(CodeImageSelection.GetElement(k).GetRightLimit()>(FRightWidth-5)) ? 1: 0;
							PixelCount = 0;
							PixelValue = 0;

							// 내부 Pixel Data 축출 
							for(int n=BCrackPoint[BCrackCount].Rect.top+1 ; n<BCrackPoint[BCrackCount].Rect.bottom-1; n++){
								for(int m=BCrackPoint[BCrackCount].Rect.left+1; m<BCrackPoint[BCrackCount].Rect.right-1 ; m++){
									PixelValue = IElement(m,n);
									if(PixelValue > BrokenThresHold) PixelCount++;
								}
							}
							BCrackPoint[BCrackCount].Round  = PixelCount;
							BCrackPoint[BCrackCount].P.x    =(float)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterX() - BCrackPoint[BCrackCount].Width/2 )+(LinePosition));
							BCrackPoint[BCrackCount].P.y    =(float)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - BCrackPoint[BCrackCount].Height/2)+(BtmInLine[1].FP0.y)+ImageHeight);
							BCrackPoint[BCrackCount].Width  =(InspectMode)? BCrackPoint[BCrackCount].Width: BCrackPoint[BCrackCount].Width+SideMargin;

							// Merge 위해서 데이터 필요함 
							BCrackPoint[BCrackCount].Rect.top    =(long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - BCrackPoint[BCrackCount].Height/2) +(BtmInLine[1].FP0.y)+ImageHeight);
							BCrackPoint[BCrackCount].Rect.bottom =(long)(BCrackPoint[BCrackCount].Rect.top + BCrackPoint[BCrackCount].Height);
							BCrackCount++;
						}
					}
				}
				BlobCount =0;

				///////////////////////////////////////////////////////////////////////////////////////////////
				//세번째 Btm영역의 직선라인 기준 검사 
// 				if(BtmInLine[2].FP0.x!=0 && BtmInLine[2].FP0.y!=0 && BtmInLine[2].FP1.x!=0 && BtmInLine[2].FP1.y!=0){
// 					DefectROI.SetPlacement((int)(BtmInLine[2].FP0.x+SideMargin), (int)(BtmInLine[2].FP0.y-FBtmHeight),(BtmInLine[2].FP1.x - BtmInLine[2].FP0.x)-(2*SideMargin), FBtmHeight);
// 					if((BtmInLine[2].FP0.x+SideMargin) <=0          ||(BtmInLine[2].FP0.y-FBtmHeight)< 0           || (BtmInLine[2].FP1.x - BtmInLine[2].FP0.x)-(2*SideMargin)<=0          || FBtmHeight<0           ) return false;
// 					if((BtmInLine[2].FP0.x+SideMargin) >=ImageWidth ||(BtmInLine[2].FP0.y-FBtmHeight)>BtmLimitLine || (BtmInLine[2].FP1.x - BtmInLine[2].FP0.x)-(2*SideMargin)>=ImageWidth || FBtmHeight>BtmLimitLine) return false;
// 					if((BtmInLine[2].FP0.x+SideMargin) +(BtmInLine[2].FP1.x - BtmInLine[2].FP0.x)-(2*SideMargin)>=ImageWidth ||(BtmInLine[2].FP0.y-FBtmHeight)+FBtmHeight>BtmLimitLine                               ) return false;
				// Bright Defect 
				if(BtmEdgePoint[4].x!=0 && BtmInLine[2].FP0.y!=0 && BtmEdgePoint[5].x!=0 && BtmInLine[2].FP1.y!=0){
					DefectROI.SetPlacement((int)(BtmEdgePoint[4].x-50), (int)(BtmInLine[2].FP0.y-FBtmHeight),((BtmEdgePoint[5].x - BtmEdgePoint[4].x)+100), FBtmHeight);
					if((BtmEdgePoint[4].x-50) <=0          ||(BtmInLine[2].FP0.y-FBtmHeight)< 0           || ((BtmEdgePoint[5].x - BtmEdgePoint[4].x)+100)<=0		     || FBtmHeight<0           ) return false;
					if((BtmEdgePoint[4].x-50) >=ImageWidth ||(BtmInLine[2].FP0.y-FBtmHeight)>BtmLimitLine || ((BtmEdgePoint[5].x - BtmEdgePoint[4].x)+100)>=ImageWidth || FBtmHeight>BtmLimitLine) return false;
					if((BtmEdgePoint[4].x-50) +((BtmEdgePoint[5].x - BtmEdgePoint[4].x)+20)>=ImageWidth ||(BtmInLine[2].FP0.y-FBtmHeight)+FBtmHeight>BtmLimitLine                               ) return false;

					//Blob 검사 진행함 
					CodeImageSelection.Clear();
					CodeImageEncoder.Encode(DefectROI,CodeImage);
					CodeImageSelection.Clear();
					CodeImageSelection.AddObjects(CodeImage);
					// Blob 필터링 
					CodeImageSelection.RemoveUsingFloatFeature  (EFeature_BoundingBoxWidth ,3, FMaxWidth   , EDoubleThresholdMode_Outside);
					CodeImageSelection.RemoveUsingFloatFeature  (EFeature_BoundingBoxHeight,3, FMaxHeight  , EDoubleThresholdMode_Outside);
// 					CodeImageSelection.RemoveUsingIntegerFeature(EFeature_BottomLimit      ,FBtmHeight-1   , FBtmHeight+1, EDoubleThresholdMode_Outside);

					BlobCount = CodeImageSelection.GetElementCount();
					CodeImageSelection.Sort(EFeature_LeftLimit ,ESortDirection_Ascending);

					if(BlobCount!=0){
						for(int k=0; k<BlobCount; k++){
							if(CCrackCount>=MAX_DEFECT_POINT) break; 
							CCrackPoint[CCrackCount].Width  =  CodeImageSelection.GetElement(k).GetBoundingBoxWidth() ;
							CCrackPoint[CCrackCount].Height =  CodeImageSelection.GetElement(k).GetBoundingBoxHeight();

							CCrackPoint[CCrackCount].Rect.left   =(long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterX() - CCrackPoint[CCrackCount].Width/2 ) +(BtmEdgePoint[4].x)-50);
							CCrackPoint[CCrackCount].Rect.top    =(long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - CCrackPoint[CCrackCount].Height/2) +(BtmInLine[2].FP0.y-FBtmHeight));
							CCrackPoint[CCrackCount].Rect.right  =(long)(CCrackPoint[CCrackCount].Rect.left+ CCrackPoint[CCrackCount].Width );
							CCrackPoint[CCrackCount].Rect.bottom =(long)(CCrackPoint[CCrackCount].Rect.top + CCrackPoint[CCrackCount].Height);
							CCrackPoint[CCrackCount].LineAttach  =(CodeImageSelection.GetElement(k).GetBottomLimit()>(FBtmHeight-5)) ? 1: 0;
							PixelCount = 0;
							PixelValue = 0;

							// 내부 Pixel Data 축출 
							for(int n=CCrackPoint[CCrackCount].Rect.top+1 ; n<CCrackPoint[CCrackCount].Rect.bottom-1; n++){
								for(int m=CCrackPoint[CCrackCount].Rect.left+1; m<CCrackPoint[CCrackCount].Rect.right-1 ; m++){
									PixelValue = IElement(m,n);
									if(PixelValue > BrokenThresHold) PixelCount++;
								}
							}
							CCrackPoint[CCrackCount].Round  =  PixelCount;
							CCrackPoint[CCrackCount].P.x    = (float)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterX() - CCrackPoint[CCrackCount].Width/2 ) +(BtmEdgePoint[4].x)-50);
							CCrackPoint[CCrackCount].P.y    = (float)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - CCrackPoint[CCrackCount].Height/2) +(BtmInLine[2].FP0.y-FBtmHeight));

							// Image Rotate 기준 좌표를 다시 Rotate한다 _ Display 목적 
							if(ImgDegree!=0.0f){
								CCrackPoint[CCrackCount].P = Math.OnRotate(CenterPoint, CCrackPoint[CCrackCount].P, (ImgDegree));
							}
							// Image Rotate 기준 좌표를 회전 이후에 ImageHeight값을 더하여 실제 좌표를 산출한다 
							CCrackPoint[CCrackCount].P.y    =(float)(CCrackPoint[CCrackCount].P.y+ImageHeight);

							// Merge 위해서 데이터 필요함 
							CCrackPoint[CCrackCount].Rect.top    =(long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - CCrackPoint[CCrackCount].Height/2) +(BtmInLine[2].FP0.y-FBtmHeight)+ImageHeight);
							CCrackPoint[CCrackCount].Rect.bottom =(long)(CCrackPoint[CCrackCount].Rect.top + CCrackPoint[CCrackCount].Height);
							CCrackCount++;
						}
					}
				}
				BlobCount =0;

				///////////////////////////////////////////////////////////////////////////////////////////////
				//네번째 Btm영역의 직선라인 기준 검사 
				if(BtmInLine[3].FP0.x!=0 && BtmInLine[3].FP0.y!=0 && BtmInLine[3].FP1.x!=0 && BtmInLine[3].FP1.y!=0){
					DefectROI.SetPlacement((int)(BtmInLine[3].FP0.x+SideMargin),(int)(BtmInLine[3].FP0.y), FLeftWidth, (BtmInLine[3].FP1.y - BtmInLine[3].FP0.y));
					if((BtmInLine[3].FP0.x+SideMargin) <=0          || BtmInLine[3].FP0.y<0            || FLeftWidth<=0          || (BtmInLine[3].FP1.y - BtmInLine[3].FP0.y)< 0          ) return false;
					if((BtmInLine[3].FP0.x+SideMargin) >=ImageWidth || BtmInLine[3].FP0.y>BtmLimitLine || FLeftWidth>=ImageWidth || (BtmInLine[3].FP1.y - BtmInLine[3].FP0.y)>BtmLimitLine) return false;
					if((BtmInLine[3].FP0.x+SideMargin)+FLeftWidth >=ImageWidth || BtmInLine[3].FP0.y+(BtmInLine[3].FP1.y - BtmInLine[3].FP0.y)>BtmLimitLine                               ) return false;
					// Line Position 
					LinePosition = BtmInLine[3].FP0.x+SideMargin;
					// Blob 검사 진행 
					CodeImageSelection.Clear();
					CodeImageEncoder.Encode(DefectROI,CodeImage);
					CodeImageSelection.Clear();
					CodeImageSelection.AddObjects(CodeImage);
					// Blob 필터링 
					CodeImageSelection.RemoveUsingFloatFeature(EFeature_BoundingBoxWidth ,3, FMaxWidth  , EDoubleThresholdMode_Outside);
					CodeImageSelection.RemoveUsingFloatFeature(EFeature_BoundingBoxHeight,3, FMaxHeight , EDoubleThresholdMode_Outside);
// 					CodeImageSelection.RemoveUsingIntegerFeature(EFeature_LeftLimit        ,0       , 1          , EDoubleThresholdMode_Outside);

					BlobCount = CodeImageSelection.GetElementCount();
					CodeImageSelection.Sort(EFeature_TopLimit,ESortDirection_Ascending);

					if(BlobCount!=0){
						for(int k=0; k<BlobCount; k++){
							if(DCount>=MAX_DEFECT_POINT) break;
							DCrackPoint[DCrackCount].Width  =  CodeImageSelection.GetElement(k).GetBoundingBoxWidth() ;
							DCrackPoint[DCrackCount].Height =  CodeImageSelection.GetElement(k).GetBoundingBoxHeight();

							DCrackPoint[DCrackCount].Rect.left   =(long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterX() - DCrackPoint[DCrackCount].Width/2 ) +LinePosition );
							DCrackPoint[DCrackCount].Rect.top    =(long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - DCrackPoint[DCrackCount].Height/2)+(BtmInLine[3].FP0.y));
							DCrackPoint[DCrackCount].Rect.right  =(long)(DCrackPoint[DCrackCount].Rect.left+ DCrackPoint[DCrackCount].Width );
							DCrackPoint[DCrackCount].Rect.bottom =(long)(DCrackPoint[DCrackCount].Rect.top + DCrackPoint[DCrackCount].Height);
							DCrackPoint[DCrackCount].LineAttach  =(CodeImageSelection.GetElement(k).GetLeftLimit()<5) ? 1: 0;
							PixelCount =0;
							PixelValue =0;

							// 내부 Pixel Data 축출 
							for(int n=DCrackPoint[DCrackCount].Rect.top+1 ; n<DCrackPoint[DCrackCount].Rect.bottom-1; n++){
								for(int m=DCrackPoint[DCrackCount].Rect.left+1; m<DCrackPoint[DCrackCount].Rect.right-1 ; m++){
									PixelValue = IElement(m,n);
									if(PixelValue > BrokenThresHold) PixelCount++;
								}
							}

							DCrackPoint[DCrackCount].Round = PixelCount;
							DCrackPoint[DCrackCount].P.x    =(float)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterX() - DCrackPoint[DCrackCount].Width/2 ) +LinePosition);
							DCrackPoint[DCrackCount].P.y    =(float)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - DCrackPoint[DCrackCount].Height/2)+(BtmInLine[3].FP0.y)+ImageHeight);
							DCrackPoint[DCrackCount].Width  = (InspectMode)?DCrackPoint[DCrackCount].Width: DCrackPoint[DCrackCount].Width+SideMargin;

							// Merge 위해서 데이터 필요함 
							DCrackPoint[DCrackCount].Rect.top    =(long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - DCrackPoint[DCrackCount].Height/2) +(BtmInLine[3].FP0.y)+ImageHeight);
							DCrackPoint[DCrackCount].Rect.bottom =(long)(DCrackPoint[DCrackCount].Rect.top + DCrackPoint[DCrackCount].Height);
							DCrackCount++;
						}
					}
				}
				BlobCount =0;

				///////////////////////////////////////////////////////////////////////////////////////////////
				//다섯번째 Btm영역의 직선라인 기준 검사 
// 				if(BtmInLine[4].FP0.x!=0 && BtmInLine[4].FP0.y!=0 && BtmInLine[4].FP1.x!=0 && BtmInLine[4].FP1.y!=0){
// 					DefectROI.SetPlacement((int)(BtmInLine[4].FP0.x+SideMargin), (int)(BtmInLine[4].FP0.y-FBtmHeight),(BtmInLine[4].FP1.x - BtmInLine[4].FP0.x)-(2*SideMargin), FBtmHeight);
// 					if((BtmInLine[4].FP0.x+SideMargin) <=0          ||(BtmInLine[4].FP0.y-FBtmHeight)<0            || (BtmInLine[4].FP1.x - BtmInLine[4].FP0.x)-(2*SideMargin)<=0          || FBtmHeight< 0          ) return false;
// 					if((BtmInLine[4].FP0.x+SideMargin) >=ImageWidth ||(BtmInLine[4].FP0.y-FBtmHeight)>BtmLimitLine || (BtmInLine[4].FP1.x - BtmInLine[4].FP0.x)-(2*SideMargin)>=ImageWidth || FBtmHeight>BtmLimitLine) return false;
// 					if((BtmInLine[4].FP0.x+SideMargin) + (BtmInLine[4].FP1.x - BtmInLine[4].FP0.x)-(2*SideMargin) >=ImageWidth ||(BtmInLine[4].FP0.y-FBtmHeight)+FBtmHeight>BtmLimitLine                             ) return false;

				if(BtmEdgePoint[8].x!=0 && BtmInLine[4].FP0.y!=0 && BtmEdgePoint[9].x!=0 && BtmInLine[4].FP1.y!=0){
					DefectROI.SetPlacement((int)(BtmEdgePoint[8].x)-50, (int)(BtmInLine[4].FP0.y-FBtmHeight),((BtmEdgePoint[9].x - BtmEdgePoint[8].x)+100), FBtmHeight);
					if((BtmEdgePoint[8].x-50) <=0          ||(BtmInLine[4].FP0.y-FBtmHeight)<0            || ((BtmEdgePoint[9].x - BtmEdgePoint[8].x)+100)<=0          || FBtmHeight< 0          ) return false;
					if((BtmEdgePoint[8].x-50) >=ImageWidth ||(BtmInLine[4].FP0.y-FBtmHeight)>BtmLimitLine || ((BtmEdgePoint[9].x - BtmEdgePoint[8].x)+100)>=ImageWidth || FBtmHeight>BtmLimitLine) return false;
					if((BtmEdgePoint[8].x-50) + ((BtmEdgePoint[9].x - BtmEdgePoint[9].x)-50) >=ImageWidth ||(BtmInLine[4].FP0.y-FBtmHeight)+FBtmHeight>BtmLimitLine                             ) return false;

					//Blob 검사 진행함 
					CodeImageSelection.Clear();
					CodeImageEncoder.Encode(DefectROI,CodeImage);
					CodeImageSelection.Clear();
					CodeImageSelection.AddObjects(CodeImage);
					// Blob 필터링 
					CodeImageSelection.RemoveUsingFloatFeature  (EFeature_BoundingBoxWidth ,3 , FMaxWidth   , EDoubleThresholdMode_Outside);
					CodeImageSelection.RemoveUsingFloatFeature  (EFeature_BoundingBoxHeight,3 , FMaxHeight  , EDoubleThresholdMode_Outside);
// 					CodeImageSelection.RemoveUsingIntegerFeature(EFeature_BottomLimit      ,FBtmHeight-1   , FBtmHeight+1, EDoubleThresholdMode_Outside);

					BlobCount = CodeImageSelection.GetElementCount();
					CodeImageSelection.Sort(EFeature_LeftLimit ,ESortDirection_Ascending);

					if(BlobCount!=0){
						for(int k=0; k<BlobCount; k++){
							if(CCrackCount>=MAX_DEFECT_POINT) break; 
							CCrackPoint[CCrackCount].Width  =  CodeImageSelection.GetElement(k).GetBoundingBoxWidth() ;
							CCrackPoint[CCrackCount].Height =  CodeImageSelection.GetElement(k).GetBoundingBoxHeight();

							CCrackPoint[CCrackCount].Rect.left   =(long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterX() - CCrackPoint[CCrackCount].Width/2 ) +(BtmEdgePoint[8].x-50));
							CCrackPoint[CCrackCount].Rect.top    =(long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - CCrackPoint[CCrackCount].Height/2) +(BtmInLine[4].FP0.y-FBtmHeight));
							CCrackPoint[CCrackCount].Rect.right  =(long)(CCrackPoint[CCrackCount].Rect.left+ CCrackPoint[CCrackCount].Width );
							CCrackPoint[CCrackCount].Rect.bottom =(long)(CCrackPoint[CCrackCount].Rect.top + CCrackPoint[CCrackCount].Height);
							CCrackPoint[CCrackCount].LineAttach  =(CodeImageSelection.GetElement(k).GetBottomLimit()>(FBtmHeight-5)) ? 1: 0;
							PixelCount = 0;
							PixelValue = 0;

							// 내부 Pixel Data 축출 
							for(int n=CCrackPoint[CCrackCount].Rect.top+1 ; n<CCrackPoint[CCrackCount].Rect.bottom-1; n++){
								for(int m=CCrackPoint[CCrackCount].Rect.left+1; m<CCrackPoint[CCrackCount].Rect.right-1 ; m++){
									PixelValue = IElement(m,n);
									if(PixelValue > BrokenThresHold) PixelCount++;
								}
							}
							CCrackPoint[CCrackCount].Round  =  PixelCount;
							CCrackPoint[CCrackCount].P.x    = (float)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterX() - CCrackPoint[CCrackCount].Width/2 ) +(BtmEdgePoint[8].x-50));
							CCrackPoint[CCrackCount].P.y    = (float)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - CCrackPoint[CCrackCount].Height/2) +(BtmInLine[4].FP0.y-FBtmHeight));

							// Image Rotate 기준 좌표를 다시 Rotate한다 _ Display 목적 
							if(ImgDegree!=0.0f){
								CCrackPoint[CCrackCount].P = Math.OnRotate(CenterPoint, CCrackPoint[CCrackCount].P, (ImgDegree));
							}
							// Image Rotate 기준 좌표를 회전 이후에 ImageHeight값을 더하여 실제 좌표를 산출한다 
							CCrackPoint[CCrackCount].P.y    =(float)(CCrackPoint[CCrackCount].P.y+ImageHeight);

							// Merge 위해서 데이터 필요함 
							CCrackPoint[CCrackCount].Rect.top    =(long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - CCrackPoint[CCrackCount].Height/2) +(BtmInLine[4].FP0.y-FBtmHeight)+ImageHeight);
							CCrackPoint[CCrackCount].Rect.bottom =(long)(CCrackPoint[CCrackCount].Rect.top + CCrackPoint[CCrackCount].Height);
							CCrackCount++;
						}
					}
				}
				BlobCount =0;
				// Notch부 직선영역 Bright Defect 검사 시퀀스 종료  



				/////////////////////////////////////////////////////////////////////////////////////////////
				// RF_MODEL 직선영역 Dark Defect 검사 시퀀스 시작 
// 				if(C2CirInEdgeCount==0 && C3CirInEdgeCount==0 && C4CirInEdgeCount==0 && C5CirInEdgeCount==0){
// 
// 				}
				/////////////////////////////////////////////////////////////////////////////////////////////
				// RF_MODEL 직선영역 Dark Defect 검사 시퀀스 종료 
			}
		}

		////////////////////////////////////////////////////////////////////////////////////////////////
		// 원본 이미지 회전하여 검사 이후 화면에 디스플레이 목적으로 좌표값을 다시 계사한다 
		////////////////////////////////////////////////////////////////////////////////////////////////
		// Cell Size 측정 데이터 넘겨줌(Image 회전 없을경우)
		if(FLBPoint.x!=0.0f && FLBPoint.y!=0.0f && FRBPoint.x!=0.0f && FRBPoint.y!=0.0f){
			LeftEndPos.x     =  FLBPoint.x            ;
			LeftEndPos.y     =  FLBPoint.y+ImageHeight;

			CenterEndPos.x =  BtmOutLine[2].FP0.x + (BtmOutLine[2].FP0.x - BtmOutLine[2].FP1.x)/2; 
			CenterEndPos.y =  (BtmOutLine[2].FP0.y + BtmOutLine[2].FP1.y)/2+ImageHeight; 
		}
		// Notch Cell Height Calc (Image  회전없음)
		if(BtmOutLine[2].FP0.x!=0.0f && BtmOutLine[2].FP0.y!=0.0f && BtmOutLine[2].FP1.x!=0.0f && BtmOutLine[2].FP1.y!=0.0f){
			NotchCenterPos.x =  BtmOutLine[2].FP0.x + (BtmOutLine[2].FP1.x - BtmOutLine[2].FP0.x)/2.0;
			NotchCenterPos.y = (BtmOutLine[2].FP0.y + BtmOutLine[2].FP1.y)/2.0;
			NotchCellSizeHeight = Math.GetLengthFrLineToPoint(FLBPoint, FRBPoint, NotchCenterPos);
		}
		// Notch Cell Width Calc(Image 회전없음)
		////////////////////////////////////////////////////////////////////////////////////////////////
		if(BtmEdgePoint[2].x!=0.0f && BtmEdgePoint[2].y!=0.0f && BtmEdgePoint[7].x!=0.0f && BtmEdgePoint[7].y!=0.0f){
			NotchCellSizeWidth = Math.GetLengthFrPointToPoint((float)BtmEdgePoint[2].x,(float)BtmEdgePoint[2].y, (float)BtmEdgePoint[7].x,(float)BtmEdgePoint[7].y);
		}
		// Center Cell Size Width Calc(Image 회전과 상관없음)
		if(TotalCellSizeWidth!=0.0f && TotalCellSizeCount!=0) CenCellSizeWidth = TotalCellSizeWidth/TotalCellSizeCount;

		if(ImgDegree!=0.0f ){
			FLBPoint    = Math.OnRotate(CenterPoint, FLBPoint     , (ImgDegree));
			FRBPoint    = Math.OnRotate(CenterPoint, FRBPoint     , (ImgDegree));

			// BtmLine 
			Line[3].FP0 = Math.OnRotate(CenterPoint, Line[3].FP0  , (ImgDegree));
			Line[3].FP1 = Math.OnRotate(CenterPoint, Line[3].FP1  , (ImgDegree));

			// LeftOutLine
			LeftOutLine[0].FP0 = Math.OnRotate(CenterPoint, LeftOutLine[0].FP0  , (ImgDegree));
			LeftOutLine[0].FP1 = Math.OnRotate(CenterPoint, LeftOutLine[0].FP1  , (ImgDegree));

			// RightOutLine
			RightOutLine[0].FP0 = Math.OnRotate(CenterPoint, RightOutLine[0].FP0  , (ImgDegree));
			RightOutLine[0].FP1 = Math.OnRotate(CenterPoint, RightOutLine[0].FP1  , (ImgDegree));

			// Cell Size 측정 데이터 넘겨줌(Image 회전 있음)
			if(FLBPoint.x!=0.0f && FLBPoint.y!=0.0f && FRBPoint.x!=0.0f && FRBPoint.y!=0.0f){
				LeftEndPos.x     =  FLBPoint.x            ;
				LeftEndPos.y     =  FLBPoint.y+ImageHeight;
				CenterEndPos.x =  BtmOutLine[2].FP0.x + (BtmOutLine[2].FP0.x - BtmOutLine[2].FP1.x)/2; 
				CenterEndPos.y =  (BtmOutLine[2].FP0.y + BtmOutLine[2].FP1.y)/2+ImageHeight; 
			}

			if(IsCornerBtm){
				FLBBPoint   = Math.OnRotate(CenterPoint, FLBBPoint    , (ImgDegree));
				FLBLPoint   = Math.OnRotate(CenterPoint, FLBLPoint    , (ImgDegree));
				FLBBInPoint = Math.OnRotate(CenterPoint, FLBBInPoint  , (ImgDegree));
				FLBLInPoint = Math.OnRotate(CenterPoint, FLBLInPoint  , (ImgDegree));
				FLBBMeaPoint= Math.OnRotate(CenterPoint, FLBBMeaPoint , (ImgDegree));
				FLBLMeaPoint= Math.OnRotate(CenterPoint, FLBLMeaPoint , (ImgDegree));

				FRBBPoint   = Math.OnRotate(CenterPoint, FRBBPoint    , (ImgDegree));
				FRBRPoint   = Math.OnRotate(CenterPoint, FRBRPoint    , (ImgDegree));
				FRBBInPoint = Math.OnRotate(CenterPoint, FRBBInPoint  , (ImgDegree));
				FRBRInPoint = Math.OnRotate(CenterPoint, FRBRInPoint  , (ImgDegree));
				FRBBMeaPoint= Math.OnRotate(CenterPoint, FRBBMeaPoint , (ImgDegree));
				FRBRMeaPoint= Math.OnRotate(CenterPoint, FRBRMeaPoint , (ImgDegree));

				// Corner Defect 좌표도 각도 적용하여 변경해야함 
				if(C3Count!=0){
					for(int k=0; k<C3Count; k++){
						// Fram기준 Y좌표값으로 원복한다 
						C3DefectPoint[k].P.y = C3DefectPoint[k].P.y - ImageHeight;
						if(C3DefectPoint[k].P.y>0) {
							C3DefectPoint[k].P   = Math.OnRotate(CenterPoint,C3DefectPoint[k].P,(ImgDegree)); 
							C3DefectPoint[k].P.y = C3DefectPoint[k].P.y + ImageHeight;
						}
						else {
							C3DefectPoint[k].P.y = C3DefectPoint[k].P.y + ImageHeight;
						}
					}
				}

				if(C4Count!=0){
					for(int k=0; k<C4Count; k++){
						// Fram기준 Y좌표값으로 원복한다 
						C4DefectPoint[k].P.y = C4DefectPoint[k].P.y - ImageHeight;
						if(C4DefectPoint[k].P.y>0) {
							C4DefectPoint[k].P   = Math.OnRotate(CenterPoint,C4DefectPoint[k].P,(ImgDegree)); 
							C4DefectPoint[k].P.y = C4DefectPoint[k].P.y + ImageHeight;
						}
						else {
							C4DefectPoint[k].P.y = C4DefectPoint[k].P.y + ImageHeight;
						}
					}
				}
				// GrindMarkPoint Rotate 
				if(IsMarkBtm){
					for(int k=0; k<19; k++){
						LtPos.x =0.0f, LtPos.y=0.0f,RbPos.x=0.0f,RbPos.y=0.0f;
						if(GrindMarkRect[k].left==0 || GrindMarkRect[k].top==0 || GrindMarkRect[k].right==0 || GrindMarkRect[k].bottom==0 ) continue;

						LtPos.x = (float)GrindMarkRect[k].left  ;
						LtPos.y = (float)GrindMarkRect[k].top   ;
						RbPos.x = (float)GrindMarkRect[k].right ;
						RbPos.y = (float)GrindMarkRect[k].bottom;
						LtPos = Math.OnRotate(CenterPoint, LtPos,ImgDegree);
						RbPos = Math.OnRotate(CenterPoint, RbPos,ImgDegree);

						GrindMarkRect[k].left   = (long)LtPos.x;
						GrindMarkRect[k].top    = (long)LtPos.y;
						GrindMarkRect[k].right  = (long)RbPos.x;
						GrindMarkRect[k].bottom = (long)RbPos.y;
						if(GrindMarkPoint[k].x!=0.0f && GrindMarkPoint[k].y!=0.0f) {
							GrindMarkPoint[k] = Math.OnRotate(CenterPoint, GrindMarkPoint[k],ImgDegree);
						}
					}
				}
			}
			else if(IsCircleBtm){
				// TrackLine 교차점 원본 이미지 기준 회전

				if(FInspectMode==Insp_Track){
					// LeftTrackLine
					LeftTrackLine[0].FP0 = Math.OnRotate(CenterPoint, LeftTrackLine[0].FP0  , (ImgDegree));
					LeftTrackLine[0].FP1 = Math.OnRotate(CenterPoint, LeftTrackLine[0].FP1  , (ImgDegree));

					// RightTrackLine
					RightTrackLine[0].FP0 = Math.OnRotate(CenterPoint, RightTrackLine[0].FP0  , (ImgDegree));
					RightTrackLine[0].FP1 = Math.OnRotate(CenterPoint, RightTrackLine[0].FP1  , (ImgDegree));

					// BtmTrackLine
					BtmTrackLine[0].FP0 = Math.OnRotate(CenterPoint, BtmTrackLine[0].FP0  , (ImgDegree));
					BtmTrackLine[0].FP1 = Math.OnRotate(CenterPoint, BtmTrackLine[0].FP1  , (ImgDegree));

					FTRLBPoint    = Math.OnRotate(CenterPoint, FTRLBPoint     , (ImgDegree));
					FTRRBPoint    = Math.OnRotate(CenterPoint, FTRRBPoint     , (ImgDegree));
				}

				
				// Btm Line Rotate 
				for(int k=0; k<MAX_BTM_COUNT; k++){
					if(BtmInLine[k].FP0.x ==0.0f || BtmInLine[k].FP0.y ==0.0f || BtmInLine[k].FP1.x ==0.0f || BtmInLine[k].FP1.y ==0.0f) continue;
					if(BtmOutLine[k].FP0.x==0.0f || BtmOutLine[k].FP0.y==0.0f || BtmOutLine[k].FP1.x==0.0f || BtmOutLine[k].FP1.y==0.0f) continue;
					BtmInLine   [k].FP0 = Math.OnRotate(CenterPoint, BtmInLine   [k].FP0,  (ImgDegree));
					BtmInLine   [k].FP1 = Math.OnRotate(CenterPoint, BtmInLine   [k].FP1,  (ImgDegree));
					BtmOutLine  [k].FP0 = Math.OnRotate(CenterPoint, BtmOutLine  [k].FP0,  (ImgDegree));
					BtmOutLine  [k].FP1 = Math.OnRotate(CenterPoint, BtmOutLine  [k].FP1,  (ImgDegree));

					if(FInspectMode==Insp_Track){
						if(BtmStandLine[k].FP0.x==0.0f || BtmStandLine[k].FP0.y==0.0f || BtmStandLine[k].FP1.x==0.0f || BtmStandLine[k].FP1.y==0.0f) continue;
						BtmStandLine[k].FP0 = Math.OnRotate(CenterPoint, BtmStandLine[k].FP0,  (ImgDegree));
						BtmStandLine[k].FP1 = Math.OnRotate(CenterPoint, BtmStandLine[k].FP1,  (ImgDegree));
					}
				}

				// Notch Cell Dis 측정 
				if(BtmOutLine[2].FP0.x!=0.0f && BtmOutLine[2].FP0.y!=0.0f && BtmOutLine[2].FP1.x!=0.0f && BtmOutLine[2].FP1.y!=0.0f){
					NotchCenterPos.x =  BtmOutLine[2].FP0.x + (BtmOutLine[2].FP1.x - BtmOutLine[2].FP0.x)/2.0;
					NotchCenterPos.y = (BtmOutLine[2].FP0.y + BtmOutLine[2].FP1.y)/2.0;
					NotchCellSizeHeight = Math.GetLengthFrLineToPoint(FLBPoint, FRBPoint, NotchCenterPos);
				}

				// Circle Defect Data 
				// Dark Defect Data 
				////////////////////////////////////////////////////////////////////////////////////////////////
				if(C1CirDeftectCnt!=0){
					for(int k=0; k<C1CirDeftectCnt; k++){
						C1CirDefectPoint[k].P.y = C1CirDefectPoint[k].P.y - ImageHeight;
						if(C1CirDefectPoint[k].P.y>0) {
							C1CirDefectPoint[k].P   = Math.OnRotate(CenterPoint,C1CirDefectPoint[k].P,(ImgDegree)); 
							C1CirDefectPoint[k].P.y = C1CirDefectPoint[k].P.y + ImageHeight;
						}
						else {
							C1CirDefectPoint[k].P.y = C1CirDefectPoint[k].P.y + ImageHeight;
						}
					}
				}

				if(C2CirDeftectCnt!=0){
					for(int k=0; k<C2CirDeftectCnt; k++){
						C2CirDefectPoint[k].P.y = C2CirDefectPoint[k].P.y - ImageHeight;
						if(C2CirDefectPoint[k].P.y>0) {
							C2CirDefectPoint[k].P   = Math.OnRotate(CenterPoint,C2CirDefectPoint[k].P,(ImgDegree)); 
							C2CirDefectPoint[k].P.y = C2CirDefectPoint[k].P.y + ImageHeight;
						}
						else {
							C2CirDefectPoint[k].P.y = C2CirDefectPoint[k].P.y + ImageHeight;
						}
					}
				}

				if(C3CirDeftectCnt!=0){
					for(int k=0; k<C3CirDeftectCnt; k++){
						C3CirDefectPoint[k].P.y = C3CirDefectPoint[k].P.y - ImageHeight;
						if(C3CirDefectPoint[k].P.y>0) {
							C3CirDefectPoint[k].P   = Math.OnRotate(CenterPoint,C3CirDefectPoint[k].P,(ImgDegree)); 
							C3CirDefectPoint[k].P.y = C3CirDefectPoint[k].P.y + ImageHeight;
						}
						else {
							C3CirDefectPoint[k].P.y = C3CirDefectPoint[k].P.y + ImageHeight;
						}
					}
				}

				if(C4CirDeftectCnt!=0){
					for(int k=0; k<C4CirDeftectCnt; k++){
						C4CirDefectPoint[k].P.y = C4CirDefectPoint[k].P.y - ImageHeight;
						if(C4CirDefectPoint[k].P.y>0) {
							C4CirDefectPoint[k].P   = Math.OnRotate(CenterPoint,C4CirDefectPoint[k].P,(ImgDegree)); 
							C4CirDefectPoint[k].P.y = C4CirDefectPoint[k].P.y + ImageHeight;
						}
						else {
							C4CirDefectPoint[k].P.y = C4CirDefectPoint[k].P.y + ImageHeight;
						}
					}
				}


				if(C5CirDeftectCnt!=0){
					for(int k=0; k<C5CirDeftectCnt; k++){
						C5CirDefectPoint[k].P.y = C5CirDefectPoint[k].P.y - ImageHeight;
						if(C5CirDefectPoint[k].P.y>0) {
							C5CirDefectPoint[k].P   = Math.OnRotate(CenterPoint,C5CirDefectPoint[k].P,(ImgDegree)); 
							C5CirDefectPoint[k].P.y = C5CirDefectPoint[k].P.y + ImageHeight;
						}
						else {
							C5CirDefectPoint[k].P.y = C5CirDefectPoint[k].P.y + ImageHeight;
						}
					}
				}


				if(C6CirDeftectCnt!=0){
					for(int k=0; k<C6CirDeftectCnt; k++){
						C6CirDefectPoint[k].P.y = C6CirDefectPoint[k].P.y - ImageHeight;
						if(C6CirDefectPoint[k].P.y>0) {
							C6CirDefectPoint[k].P   = Math.OnRotate(CenterPoint,C6CirDefectPoint[k].P,(ImgDegree)); 
							C6CirDefectPoint[k].P.y = C6CirDefectPoint[k].P.y + ImageHeight;
						}
						else {
							C6CirDefectPoint[k].P.y = C6CirDefectPoint[k].P.y + ImageHeight;
						}
					}
				}

				if(Btm3CirDefectCnt!=0){
					for(int k=0; k<Btm3CirDefectCnt; k++){
						Btm3CirDefectPoint[k].P.y = Btm3CirDefectPoint[k].P.y - ImageHeight;
						if(Btm3CirDefectPoint[k].P.y>0) {
							Btm3CirDefectPoint[k].P   = Math.OnRotate(CenterPoint,Btm3CirDefectPoint[k].P,(ImgDegree)); 
							Btm3CirDefectPoint[k].P.y = Btm3CirDefectPoint[k].P.y + ImageHeight;
						}
						else {
							Btm3CirDefectPoint[k].P.y = Btm3CirDefectPoint[k].P.y + ImageHeight;
						}
					}
				}

				///////////////////////////////////////////////////////////////////////////////////////////////////

				// Circle Defect Data 
				// Bright Defect Data e
				////////////////////////////////////////////////////////////////////////////////////////////////
				if(C1CirCrackCnt!=0){
					for(int k=0; k<C1CirCrackCnt; k++){
						C1CirCrackPoint[k].P.y = C1CirCrackPoint[k].P.y - ImageHeight;
						if(C1CirCrackPoint[k].P.y>0) {
							C1CirCrackPoint[k].P   = Math.OnRotate(CenterPoint,C1CirCrackPoint[k].P,(ImgDegree)); 
							C1CirCrackPoint[k].P.y = C1CirCrackPoint[k].P.y + ImageHeight;
						}
						else {
							C1CirCrackPoint[k].P.y = C1CirCrackPoint[k].P.y + ImageHeight;
						}
					}
				}

				if(C2CirCrackCnt!=0){
					for(int k=0; k<C2CirCrackCnt; k++){
						C2CirCrackPoint[k].P.y = C2CirCrackPoint[k].P.y - ImageHeight;
						if(C2CirCrackPoint[k].P.y>0) {
							C2CirCrackPoint[k].P   = Math.OnRotate(CenterPoint,C2CirCrackPoint[k].P,(ImgDegree)); 
							C2CirCrackPoint[k].P.y = C2CirCrackPoint[k].P.y + ImageHeight;
						}
						else {
							C2CirCrackPoint[k].P.y = C2CirCrackPoint[k].P.y + ImageHeight;
						}
					}
				}

				if(C3CirCrackCnt!=0){
					for(int k=0; k<C3CirCrackCnt; k++){
						C3CirCrackPoint[k].P.y = C3CirCrackPoint[k].P.y - ImageHeight;
						if(C3CirCrackPoint[k].P.y>0) {
							C3CirCrackPoint[k].P   = Math.OnRotate(CenterPoint,C3CirCrackPoint[k].P,(ImgDegree)); 
							C3CirCrackPoint[k].P.y = C3CirCrackPoint[k].P.y + ImageHeight;
						}
						else {
							C3CirCrackPoint[k].P.y = C3CirCrackPoint[k].P.y + ImageHeight;
						}
					}
				}

				if(C4CirCrackCnt!=0){
					for(int k=0; k<C4CirCrackCnt; k++){
						C4CirCrackPoint[k].P.y = C4CirCrackPoint[k].P.y - ImageHeight;
						if(C4CirCrackPoint[k].P.y>0) {
							C4CirCrackPoint[k].P   = Math.OnRotate(CenterPoint,C4CirCrackPoint[k].P,(ImgDegree)); 
							C4CirCrackPoint[k].P.y = C4CirCrackPoint[k].P.y + ImageHeight;
						}
						else {
							C4CirCrackPoint[k].P.y = C4CirCrackPoint[k].P.y + ImageHeight;
						}
					}
				}

				if(C5CirCrackCnt!=0){
					for(int k=0; k<C5CirCrackCnt; k++){
						C5CirCrackPoint[k].P.y = C5CirCrackPoint[k].P.y - ImageHeight;
						if(C5CirCrackPoint[k].P.y>0) {
							C5CirCrackPoint[k].P   = Math.OnRotate(CenterPoint,C5CirCrackPoint[k].P,(ImgDegree)); 
							C5CirCrackPoint[k].P.y = C5CirCrackPoint[k].P.y + ImageHeight;
						}
						else {
							C5CirCrackPoint[k].P.y = C5CirCrackPoint[k].P.y + ImageHeight;
						}
					}
				}

				if(C6CirCrackCnt!=0){
					for(int k=0; k<C6CirCrackCnt; k++){
						C6CirCrackPoint[k].P.y = C6CirCrackPoint[k].P.y - ImageHeight;
						if(C6CirCrackPoint[k].P.y>0) {
							C6CirCrackPoint[k].P   = Math.OnRotate(CenterPoint,C6CirCrackPoint[k].P,(ImgDegree)); 
							C6CirCrackPoint[k].P.y = C6CirCrackPoint[k].P.y + ImageHeight;
						}
						else {
							C6CirCrackPoint[k].P.y = C6CirCrackPoint[k].P.y + ImageHeight;
						}
					}
				}

				if(Btm3CirCrackCnt!=0){
					for(int k=0; k<Btm3CirCrackCnt; k++){
						Btm3CirCrackPoint[k].P.y = Btm3CirCrackPoint[k].P.y - ImageHeight;
						if(Btm3CirCrackPoint[k].P.y>0) {
							Btm3CirCrackPoint[k].P   = Math.OnRotate(CenterPoint,Btm3CirCrackPoint[k].P,(ImgDegree)); 
							Btm3CirCrackPoint[k].P.y = Btm3CirCrackPoint[k].P.y + ImageHeight;
						}
						else {
							Btm3CirCrackPoint[k].P.y = Btm3CirCrackPoint[k].P.y + ImageHeight;
						}
					}
				}

				/////////////////////////////////////////////////////////////////////////////////////////////////////////

				// C1 Circle Edge Point Rotate 
				if(C1CirStandEdgeCount!=0){
					for(int k=0; k<C1CirStandEdgeCount; k++){
						if(C1CirStandPoint[k].x==0.0f || C1CirStandPoint[k].y==0.0f) continue;
						C1CirStandPoint[k] = Math.OnRotate(CenterPoint, C1CirStandPoint[k], ImgDegree);
					}
				}
				if(C1CirInEdgeCount!=0){
					for(int k=0; k<C1CirInEdgeCount; k++){
						if(C1CirInPoint[k].x==0.0f || C1CirInPoint[k].y==0.0f) continue;
						C1CirInPoint[k] = Math.OnRotate(CenterPoint, C1CirInPoint[k], ImgDegree);
					}
				}
				if(C1CirOutEdgeCount!=0){
					for(int k=0; k<C1CirOutEdgeCount; k++){
						if(C1CirOutPoint[k].x==0.0f || C1CirOutPoint[k].y==0.0f) continue;
						C1CirOutPoint[k] = Math.OnRotate(CenterPoint, C1CirOutPoint[k], ImgDegree);
					}
				}
				if(C1CirCenter     .x!=0.0f && C1CirCenter     .y!=0.0f) C1CirCenter        = Math.OnRotate(CenterPoint, C1CirCenter         , (ImgDegree)); // 외곽 교차점 기준  
				if(RealC1CirCenter .x!=0.0f && RealC1CirCenter .y!=0.0f) RealC1CirCenter    = Math.OnRotate(CenterPoint, RealC1CirCenter     , (ImgDegree)); // Euresys 
				if(CircleFit1Center.x!=0.0f && CircleFit1Center.y!=0.0f) CircleFit1Center   = Math.OnRotate(CenterPoint, CircleFit1Center    , (ImgDegree)); // FAVION

				// C2 Circle Edge Point Rotate 
				if(C2CirStandEdgeCount!=0){
					for(int k=0; k<C2CirStandEdgeCount; k++){
						if(C2CirStandPoint[k].x==0.0f || C2CirStandPoint[k].y==0.0f) continue;
						C2CirStandPoint[k] = Math.OnRotate(CenterPoint, C2CirStandPoint[k], ImgDegree);
					}
				}
				if(C2CirInEdgeCount!=0){
					for(int k=0; k<C2CirInEdgeCount; k++){
						if(C2CirInPoint[k].x==0.0f || C2CirInPoint[k].y==0.0f) continue;
						C2CirInPoint[k] = Math.OnRotate(CenterPoint, C2CirInPoint[k], ImgDegree);
					}
				}
				if(C2CirOutEdgeCount!=0){
					for(int k=0; k<C2CirOutEdgeCount; k++){
						if(C2CirOutPoint[k].x==0.0f || C2CirOutPoint[k].y==0.0f) continue;
						C2CirOutPoint[k] = Math.OnRotate(CenterPoint, C2CirOutPoint[k], ImgDegree);
					}
				}
				if(C2CirCenter     .x!=0.0f && C2CirCenter     .y!=0.0f) C2CirCenter        = Math.OnRotate(CenterPoint, C2CirCenter         , (ImgDegree)); // 외곽 교차점 기준  
				if(RealC2CirCenter .x!=0.0f && RealC2CirCenter .y!=0.0f) RealC2CirCenter    = Math.OnRotate(CenterPoint, RealC2CirCenter     , (ImgDegree));
				if(CircleFit2Center.x!=0.0f && CircleFit2Center.y!=0.0f) CircleFit2Center   = Math.OnRotate(CenterPoint, CircleFit2Center    , (ImgDegree));

				// C3 Circle Edge Point Rotate 
				if(C3CirStandEdgeCount!=0){
					for(int k=0; k<C3CirStandEdgeCount; k++){
						if(C3CirStandPoint[k].x==0.0f || C3CirStandPoint[k].y==0.0f) continue;
						C3CirStandPoint[k] = Math.OnRotate(CenterPoint, C3CirStandPoint[k], ImgDegree);
					}
				}
				if(C3CirInEdgeCount!=0){
					for(int k=0; k<C3CirInEdgeCount; k++){
						if(C3CirInPoint[k].x==0.0f || C3CirInPoint[k].y==0.0f) continue;
						C3CirInPoint[k] = Math.OnRotate(CenterPoint, C3CirInPoint[k], ImgDegree);
					}
				}
				if(C3CirOutEdgeCount!=0){
					for(int k=0; k<C3CirOutEdgeCount; k++){
						if(C3CirOutPoint[k].x==0.0f || C3CirOutPoint[k].y==0.0f) continue;
						C3CirOutPoint[k] = Math.OnRotate(CenterPoint, C3CirOutPoint[k], ImgDegree);
					}
				}
				if(C3CirCenter     .x!=0.0f && C3CirCenter     .y!=0.0f) C3CirCenter        = Math.OnRotate(CenterPoint, C3CirCenter         , (ImgDegree)); // 외곽 교차점 기준  
				if(RealC3CirCenter .x!=0.0f && RealC3CirCenter .y!=0.0f) RealC3CirCenter    = Math.OnRotate(CenterPoint, RealC3CirCenter     , (ImgDegree));
				if(CircleFit3Center.x!=0.0f && CircleFit3Center.y!=0.0f) CircleFit3Center   = Math.OnRotate(CenterPoint, CircleFit3Center    , (ImgDegree));

				// C4 Circle Edge Point Rotate 
				if(C4CirStandEdgeCount!=0){
					for(int k=0; k<C4CirStandEdgeCount; k++){
						if(C4CirStandPoint[k].x==0.0f || C4CirStandPoint[k].y==0.0f) continue;
						C4CirStandPoint[k] = Math.OnRotate(CenterPoint, C4CirStandPoint[k], ImgDegree);
					}
				}
				if(C4CirInEdgeCount!=0){
					for(int k=0; k<C4CirInEdgeCount; k++){
						if(C4CirInPoint[k].x==0.0f || C4CirInPoint[k].y==0.0f) continue;
						C4CirInPoint[k] = Math.OnRotate(CenterPoint, C4CirInPoint[k], ImgDegree);
					}
				}
				if(C4CirOutEdgeCount!=0){
					for(int k=0; k<C4CirOutEdgeCount; k++){
						if(C4CirOutPoint[k].x==0.0f || C4CirOutPoint[k].y==0.0f) continue;
						C4CirOutPoint[k] = Math.OnRotate(CenterPoint, C4CirOutPoint[k], ImgDegree);
					}
				}
				if(C4CirCenter     .x!=0.0f && C4CirCenter     .y!=0.0f) C4CirCenter        = Math.OnRotate(CenterPoint, C4CirCenter         , (ImgDegree)); // 외곽 교차점 기준  
				if(RealC4CirCenter .x!=0.0f && RealC4CirCenter .y!=0.0f) RealC4CirCenter    = Math.OnRotate(CenterPoint, RealC4CirCenter     , (ImgDegree));
				if(CircleFit4Center.x!=0.0f && CircleFit4Center.y!=0.0f) CircleFit4Center   = Math.OnRotate(CenterPoint, CircleFit4Center    , (ImgDegree));

				// C5 Circle Edge Point Rotate 
				if(C5CirStandEdgeCount!=0){
					for(int k=0; k<C5CirStandEdgeCount; k++){
						if(C5CirStandPoint[k].x==0.0f || C5CirStandPoint[k].y==0.0f) continue;
						C5CirStandPoint[k] = Math.OnRotate(CenterPoint, C5CirStandPoint[k], ImgDegree);
					}
				}
				if(C5CirInEdgeCount!=0){
					for(int k=0; k<C5CirInEdgeCount; k++){
						if(C5CirInPoint[k].x==0.0f || C5CirInPoint[k].y==0.0f) continue;
						C5CirInPoint[k] = Math.OnRotate(CenterPoint, C5CirInPoint[k], ImgDegree);
					}
				}
				if(C5CirOutEdgeCount!=0){
					for(int k=0; k<C5CirOutEdgeCount; k++){
						if(C5CirOutPoint[k].x==0.0f || C5CirOutPoint[k].y==0.0f) continue;
						C5CirOutPoint[k] = Math.OnRotate(CenterPoint, C5CirOutPoint[k], ImgDegree);
					}
				}
				if(C5CirCenter     .x!=0.0f && C5CirCenter     .y!=0.0f) C5CirCenter        = Math.OnRotate(CenterPoint, C5CirCenter         , (ImgDegree)); // 외곽 교차점 기준  
				if(RealC5CirCenter .x!=0.0f && RealC5CirCenter .y!=0.0f) RealC5CirCenter    = Math.OnRotate(CenterPoint, RealC5CirCenter     , (ImgDegree));
				if(CircleFit5Center.x!=0.0f && CircleFit5Center.y!=0.0f) CircleFit5Center   = Math.OnRotate(CenterPoint, CircleFit5Center    , (ImgDegree));

				// C6 Circle Edge Point Rotate 
				if(C6CirStandEdgeCount!=0){
					for(int k=0; k<C6CirStandEdgeCount; k++){
						if(C6CirStandPoint[k].x==0.0f || C6CirStandPoint[k].y==0.0f) continue;
						C6CirStandPoint[k] = Math.OnRotate(CenterPoint, C6CirStandPoint[k], ImgDegree);
					}
				}
				if(C6CirInEdgeCount!=0){
					for(int k=0; k<C6CirInEdgeCount; k++){
						if(C6CirInPoint[k].x==0.0f || C6CirInPoint[k].y==0.0f) continue;
						C6CirInPoint[k] = Math.OnRotate(CenterPoint, C6CirInPoint[k], ImgDegree);
					}
				}
				if(C6CirOutEdgeCount!=0){
					for(int k=0; k<C6CirOutEdgeCount; k++){
						if(C6CirOutPoint[k].x==0.0f || C6CirOutPoint[k].y==0.0f) continue;
						C6CirOutPoint[k] = Math.OnRotate(CenterPoint, C6CirOutPoint[k], ImgDegree);
					}
				}
				if(C6CirCenter     .x!=0.0f && C6CirCenter     .y!=0.0f) C6CirCenter        = Math.OnRotate(CenterPoint, C6CirCenter         , (ImgDegree)); // 외곽 교차점 기준  
				if(RealC6CirCenter .x!=0.0f && RealC6CirCenter .y!=0.0f) RealC6CirCenter    = Math.OnRotate(CenterPoint, RealC6CirCenter     , (ImgDegree));
				if(CircleFit6Center.x!=0.0f && CircleFit6Center.y!=0.0f) CircleFit6Center   = Math.OnRotate(CenterPoint, CircleFit6Center    , (ImgDegree));

				// Narrow Trench Btm3 Data Rotate  
				if(Btm3InEdgeCount!=0){
					for(int k=0; k<Btm3InEdgeCount; k++){
						if(Btm3InPoint[k].x==0.0f || Btm3InPoint[k].y==0.0f) continue;
						Btm3InPoint[k] = Math.OnRotate(CenterPoint, Btm3InPoint[k], ImgDegree);
					}
				}
				if(Btm3OutEdgeCount!=0){
					for(int k=0; k<Btm3OutEdgeCount; k++){
						if(Btm3OutPoint[k].x==0.0f || Btm3OutPoint[k].y==0.0f) continue;
						Btm3OutPoint[k] = Math.OnRotate(CenterPoint, Btm3OutPoint[k], ImgDegree);
					}
				}
				if(CircleFitBtm3Center.x!=0.0f && CircleFitBtm3Center.y!=0.0f) CircleFitBtm3Center   = Math.OnRotate(CenterPoint, CircleFitBtm3Center    , (ImgDegree)); // FAVION


				// Grind Mark Pos 각도기준 회전해야함 
				if((FInspectMode==Insp_Mark || FInspectMode==Insp_Polygon) && IsMarkBtm){
					for(int k=0; k<19; k++){
						LtPos.x =0.0f, LtPos.y=0.0f,RbPos.x=0.0f,RbPos.y=0.0f;
						if(GrindMarkRect[k].left==0 || GrindMarkRect[k].top==0 || GrindMarkRect[k].right==0 || GrindMarkRect[k].bottom==0 ) continue;

						LtPos.x = (float)GrindMarkRect[k].left  ;
						LtPos.y = (float)GrindMarkRect[k].top   ;
						RbPos.x = (float)GrindMarkRect[k].right ;
						RbPos.y = (float)GrindMarkRect[k].bottom;
						LtPos = Math.OnRotate(CenterPoint, LtPos,ImgDegree);
						RbPos = Math.OnRotate(CenterPoint, RbPos,ImgDegree);

						GrindMarkRect[k].left   = (long)LtPos.x;
						GrindMarkRect[k].top    = (long)LtPos.y;
						GrindMarkRect[k].right  = (long)RbPos.x;
						GrindMarkRect[k].bottom = (long)RbPos.y;
						if(GrindMarkPoint[k].x!=0.0f && GrindMarkPoint[k].y!=0.0f) {
							GrindMarkPoint[k] = Math.OnRotate(CenterPoint, GrindMarkPoint[k],ImgDegree);
						}
					}
				}
			}
		}
		////////////////////////////////////////////////////////////////////////////////////////////////
		DefectPointCount = A1CirDeftectCnt+A2CirDeftectCnt+ACount+BCount+CCount+DCount+C1CirDeftectCnt+C2CirDeftectCnt+C3CirDeftectCnt+C4CirDeftectCnt+C5CirDeftectCnt+
			               C6CirDeftectCnt+ABurrCount+BBurrCount+CBurrCount+DBurrCount+ACrackCount+BCrackCount+CCrackCount+DCrackCount+A1CirCrackCnt+A2CirCrackCnt+
						   C1CirCrackCnt+C2CirCrackCnt+C3CirCrackCnt+C4CirCrackCnt+C5CirCrackCnt+C6CirCrackCnt+Btm3CirCrackCnt+Btm3CirDefectCnt; // 전체 불량개수 계산

		// BTM 영역 검사 종료 후 Cell Size 측정 
		// 검사 종료 후 Cell Size 측정함 
		if(LeftStaPos.x!=0.0f && LeftStaPos.y!=0.0f && LeftEndPos.x!=0.0f && LeftEndPos.y!=0.0f){
			LeftCellSizeHeight = Math.GetLengthFrPointToPoint(LeftStaPos, LeftEndPos);
		}
		if(CenterStaPos.x!=0.0f && CenterStaPos.y!=0.0f && CenterEndPos.x!=0.0f && CenterEndPos.y!=0.0f){
			CenCellSizeHeight  = Math.GetLengthFrPointToPoint(CenterStaPos, CenterEndPos);
		}

		// Defect Blob Merge
		///////////////////////////////////////////////////////////////////////////////////////////////
		// Circle_1 불량 Merge 기능 
		if(C1CirDeftectCnt!=0){
			bool IsxMg=false, IsyMg=false, IsInMg=false;
			CRect r1, r2;
			int sort =0;
			int tmpDDefectCount = C1CirDeftectCnt;

			for(int k=0; k<tmpDDefectCount; k++){
				if(C1CirDefectPoint[k].Rect.left==0 && C1CirDefectPoint[k].Rect.top==0 && C1CirDefectPoint[k].Rect.right==0 && C1CirDefectPoint[k].Rect.bottom==0) continue;

				for(int l=k+1; l<k+MgCount; l++ ){
					IsxMg = false; IsyMg = false;
					if(l>(tmpDDefectCount-1)) break;
					if(C1CirDefectPoint[l].Rect.left==0 && C1CirDefectPoint[l].Rect.top==0 && C1CirDefectPoint[k].Rect.right==0 && C1CirDefectPoint[k].Rect.bottom==0) continue;

					r1 = C1CirDefectPoint[k].Rect;
					r2 = C1CirDefectPoint[l].Rect; 

					register int HorDist   = abs((r1.left < r2.left) ?  r2.left - r1.right  : r1.left - r2.right );
					register int VerDist   = abs((r1.top  < r2.top ) ?  r2.top  - r1.bottom : r1.top  - r2.bottom);
					IsInMg    = ((r1.left<=r2.left) && (r1.top<r2.top) && (r1.bottom>r2.bottom) && (r1.right >r2.right))? true: false;

					if(HorDist>xMerge && VerDist>yMerge && !IsInMg ) continue;

					IsxMg = (HorDist<xMerge) ? true: false;
					IsyMg = (VerDist<yMerge) ? true: false;

					if((IsxMg && IsyMg) || IsInMg){
						C1CirDefectPoint[k].Round    += C1CirDefectPoint[l].Round;
						C1CirDefectPoint[k].Rect      = OnMerge(C1CirDefectPoint[k].Rect, C1CirDefectPoint[l].Rect);
						C1CirDefectPoint[k].Width     = C1CirDefectPoint[k].Rect.right  - C1CirDefectPoint[k].Rect.left;
						C1CirDefectPoint[k].Height    = C1CirDefectPoint[k].Rect.bottom - C1CirDefectPoint[k].Rect.top ;
						C1CirDefectPoint[k].Hor_Dis   = C1CirDefectPoint[k].Width ; 
						C1CirDefectPoint[k].Ver_Dis   = C1CirDefectPoint[k].Height;
						C1CirDefectPoint[k].P.x       = (float)(C1CirDefectPoint[k].Rect.left);
						C1CirDefectPoint[k].P.y       = (float)(C1CirDefectPoint[k].Rect.top ); 
						C1CirDefectPoint[l].Rect.left = C1CirDefectPoint[l].Rect.top = C1CirDefectPoint[l].Rect.right = C1CirDefectPoint[l].Rect.bottom =0;
						C1CirDeftectCnt--;
						k=-1;
						break;
					}

				}

			}
			for(int j=0; j<tmpDDefectCount; j++){
				if(C1CirDefectPoint[j].Rect.left==0 && C1CirDefectPoint[j].Rect.top==0 && C1CirDefectPoint[j].Rect.right==0 && C1CirDefectPoint[j].Rect.bottom==0) continue;
				C1CirDefectPoint[sort] = C1CirDefectPoint[j];
				sort++;
			}
		}
		////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

		// Circle_2 불량 Merge 기능 
		if(C2CirDeftectCnt!=0){
			bool IsxMg=false, IsyMg=false, IsInMg=false;
			CRect r1, r2;
			int sort =0;
			int tmpDDefectCount = C2CirDeftectCnt;

			for(int k=0; k<tmpDDefectCount; k++){
				if(C2CirDefectPoint[k].Rect.left==0 && C2CirDefectPoint[k].Rect.top==0 && C2CirDefectPoint[k].Rect.right==0 && C2CirDefectPoint[k].Rect.bottom==0) continue;

				for(int l=k+1; l<k+MgCount; l++ ){
					IsxMg = false; IsyMg = false;
					if(l>(tmpDDefectCount-1)) break;
					if(C2CirDefectPoint[l].Rect.left==0 && C2CirDefectPoint[l].Rect.top==0 && C2CirDefectPoint[k].Rect.right==0 && C2CirDefectPoint[k].Rect.bottom==0) continue;

					r1 = C2CirDefectPoint[k].Rect;
					r2 = C2CirDefectPoint[l].Rect; 

					register int HorDist   = abs((r1.left < r2.left) ?  r2.left - r1.right  : r1.left - r2.right );
					register int VerDist   = abs((r1.top  < r2.top ) ?  r2.top  - r1.bottom : r1.top  - r2.bottom);
					IsInMg    = ((r1.left<=r2.left) && (r1.top<r2.top) && (r1.bottom>r2.bottom) && (r1.right >r2.right))? true: false;

					if(HorDist>xMerge && VerDist>yMerge && !IsInMg ) continue;

					IsxMg = (HorDist<xMerge) ? true: false;
					IsyMg = (VerDist<yMerge) ? true: false;

					if((IsxMg && IsyMg) || IsInMg){
						C2CirDefectPoint[k].Round    += C2CirDefectPoint[l].Round;
						C2CirDefectPoint[k].Rect      = OnMerge(C2CirDefectPoint[k].Rect, C2CirDefectPoint[l].Rect);
						C2CirDefectPoint[k].Width     = C2CirDefectPoint[k].Rect.right  - C2CirDefectPoint[k].Rect.left;
						C2CirDefectPoint[k].Height    = C2CirDefectPoint[k].Rect.bottom - C2CirDefectPoint[k].Rect.top ;
						C2CirDefectPoint[k].Hor_Dis   = C2CirDefectPoint[k].Width ; 
						C2CirDefectPoint[k].Ver_Dis   = C2CirDefectPoint[k].Height;
						C2CirDefectPoint[k].P.x       = (float)(C2CirDefectPoint[k].Rect.left);
						C2CirDefectPoint[k].P.y       = (float)(C2CirDefectPoint[k].Rect.top ); 
						C2CirDefectPoint[l].Rect.left = C2CirDefectPoint[l].Rect.top = C2CirDefectPoint[l].Rect.right = C2CirDefectPoint[l].Rect.bottom =0;
						C2CirDeftectCnt--;
						k=-1;
						break;
					}

				}

			}
			for(int j=0; j<tmpDDefectCount; j++){
				if(C2CirDefectPoint[j].Rect.left==0 && C2CirDefectPoint[j].Rect.top==0 && C2CirDefectPoint[j].Rect.right==0 && C2CirDefectPoint[j].Rect.bottom==0) continue;
				C2CirDefectPoint[sort] = C2CirDefectPoint[j];
				sort++;
			}
		}
		////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

		// Circle_3 불량 Merge 기능 
		if(C3CirDeftectCnt!=0){
			bool IsxMg=false, IsyMg=false, IsInMg=false;
			CRect r1, r2;
			int sort =0;
			int tmpDDefectCount = C3CirDeftectCnt;

			for(int k=0; k<tmpDDefectCount; k++){
				if(C3CirDefectPoint[k].Rect.left==0 && C3CirDefectPoint[k].Rect.top==0 && C3CirDefectPoint[k].Rect.right==0 && C3CirDefectPoint[k].Rect.bottom==0) continue;

				for(int l=k+1; l<k+MgCount; l++ ){
					IsxMg = false; IsyMg = false;
					if(l>(tmpDDefectCount-1)) break;
					if(C3CirDefectPoint[l].Rect.left==0 && C3CirDefectPoint[l].Rect.top==0 && C3CirDefectPoint[k].Rect.right==0 && C3CirDefectPoint[k].Rect.bottom==0) continue;

					r1 = C3CirDefectPoint[k].Rect;
					r2 = C3CirDefectPoint[l].Rect; 

					register int HorDist   = abs((r1.left < r2.left) ?  r2.left - r1.right  : r1.left - r2.right );
					register int VerDist   = abs((r1.top  < r2.top ) ?  r2.top  - r1.bottom : r1.top  - r2.bottom);
					IsInMg    = ((r1.left<=r2.left) && (r1.top<r2.top) && (r1.bottom>r2.bottom) && (r1.right >r2.right))? true: false;

					if(HorDist>xMerge && VerDist>yMerge && !IsInMg ) continue;

					IsxMg = (HorDist<xMerge) ? true: false;
					IsyMg = (VerDist<yMerge) ? true: false;

					if((IsxMg && IsyMg) || IsInMg){
						C3CirDefectPoint[k].Round    += C3CirDefectPoint[l].Round;
						C3CirDefectPoint[k].Rect      = OnMerge(C3CirDefectPoint[k].Rect, C3CirDefectPoint[l].Rect);
						C3CirDefectPoint[k].Width     = C3CirDefectPoint[k].Rect.right  - C3CirDefectPoint[k].Rect.left;
						C3CirDefectPoint[k].Height    = C3CirDefectPoint[k].Rect.bottom - C3CirDefectPoint[k].Rect.top ;
						C3CirDefectPoint[k].Hor_Dis   = C3CirDefectPoint[k].Width ; 
						C3CirDefectPoint[k].Ver_Dis   = C3CirDefectPoint[k].Height;
						C3CirDefectPoint[k].P.x       = (float)(C3CirDefectPoint[k].Rect.left);
						C3CirDefectPoint[k].P.y       = (float)(C3CirDefectPoint[k].Rect.top ); 
						C3CirDefectPoint[l].Rect.left = C3CirDefectPoint[l].Rect.top = C3CirDefectPoint[l].Rect.right = C3CirDefectPoint[l].Rect.bottom =0;
						C3CirDeftectCnt--;
						k=-1;
						break;
					}

				}

			}
			for(int j=0; j<tmpDDefectCount; j++){
				if(C3CirDefectPoint[j].Rect.left==0 && C3CirDefectPoint[j].Rect.top==0 && C3CirDefectPoint[j].Rect.right==0 && C3CirDefectPoint[j].Rect.bottom==0) continue;
				C3CirDefectPoint[sort] = C3CirDefectPoint[j];
				sort++;
			}
		}
		////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

		// Circle_4 불량 Merge 기능 
		if(C4CirDeftectCnt!=0){
			bool IsxMg=false, IsyMg=false, IsInMg=false;
			CRect r1, r2;
			int sort =0;
			int tmpDDefectCount = C4CirDeftectCnt;

			for(int k=0; k<tmpDDefectCount; k++){
				if(C4CirDefectPoint[k].Rect.left==0 && C4CirDefectPoint[k].Rect.top==0 && C4CirDefectPoint[k].Rect.right==0 && C4CirDefectPoint[k].Rect.bottom==0) continue;

				for(int l=k+1; l<k+MgCount; l++ ){
					IsxMg = false; IsyMg = false;
					if(l>(tmpDDefectCount-1)) break;
					if(C4CirDefectPoint[l].Rect.left==0 && C4CirDefectPoint[l].Rect.top==0 && C4CirDefectPoint[k].Rect.right==0 && C4CirDefectPoint[k].Rect.bottom==0) continue;

					r1 = C4CirDefectPoint[k].Rect;
					r2 = C4CirDefectPoint[l].Rect; 

					register int HorDist   = abs((r1.left < r2.left) ?  r2.left - r1.right  : r1.left - r2.right );
					register int VerDist   = abs((r1.top  < r2.top ) ?  r2.top  - r1.bottom : r1.top  - r2.bottom);
					IsInMg    = ((r1.left<=r2.left) && (r1.top<r2.top) && (r1.bottom>r2.bottom) && (r1.right >r2.right))? true: false;

					if(HorDist>xMerge && VerDist>yMerge && !IsInMg ) continue;

					IsxMg = (HorDist<xMerge) ? true: false;
					IsyMg = (VerDist<yMerge) ? true: false;

					if((IsxMg && IsyMg) || IsInMg){
						C4CirDefectPoint[k].Round    += C4CirDefectPoint[l].Round;
						C4CirDefectPoint[k].Rect      = OnMerge(C4CirDefectPoint[k].Rect, C4CirDefectPoint[l].Rect);
						C4CirDefectPoint[k].Width     = C4CirDefectPoint[k].Rect.right  - C4CirDefectPoint[k].Rect.left;
						C4CirDefectPoint[k].Height    = C4CirDefectPoint[k].Rect.bottom - C4CirDefectPoint[k].Rect.top ;
						C4CirDefectPoint[k].Hor_Dis   = C4CirDefectPoint[k].Width ; 
						C4CirDefectPoint[k].Ver_Dis   = C4CirDefectPoint[k].Height;
						C4CirDefectPoint[k].P.x       = (float)(C4CirDefectPoint[k].Rect.left);
						C4CirDefectPoint[k].P.y       = (float)(C4CirDefectPoint[k].Rect.top ); 
						C4CirDefectPoint[l].Rect.left = C4CirDefectPoint[l].Rect.top = C4CirDefectPoint[l].Rect.right = C4CirDefectPoint[l].Rect.bottom =0;
						C4CirDeftectCnt--;
						k=-1;
						break;
					}

				}

			}
			for(int j=0; j<tmpDDefectCount; j++){
				if(C4CirDefectPoint[j].Rect.left==0 && C4CirDefectPoint[j].Rect.top==0 && C4CirDefectPoint[j].Rect.right==0 && C4CirDefectPoint[j].Rect.bottom==0) continue;
				C4CirDefectPoint[sort] = C4CirDefectPoint[j];
				sort++;
			}
		}
		////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

		// Circle_5 불량 Merge 기능 
		if(C5CirDeftectCnt!=0){
			bool IsxMg=false, IsyMg=false, IsInMg=false;
			CRect r1, r2;
			int sort =0;
			int tmpDDefectCount = C5CirDeftectCnt;

			for(int k=0; k<tmpDDefectCount; k++){
				if(C5CirDefectPoint[k].Rect.left==0 && C5CirDefectPoint[k].Rect.top==0 && C5CirDefectPoint[k].Rect.right==0 && C5CirDefectPoint[k].Rect.bottom==0) continue;

				for(int l=k+1; l<k+MgCount; l++ ){
					IsxMg = false; IsyMg = false;
					if(l>(tmpDDefectCount-1)) break;
					if(C5CirDefectPoint[l].Rect.left==0 && C5CirDefectPoint[l].Rect.top==0 && C5CirDefectPoint[k].Rect.right==0 && C5CirDefectPoint[k].Rect.bottom==0) continue;

					r1 = C5CirDefectPoint[k].Rect;
					r2 = C5CirDefectPoint[l].Rect; 

					register int HorDist   = abs((r1.left < r2.left) ?  r2.left - r1.right  : r1.left - r2.right );
					register int VerDist   = abs((r1.top  < r2.top ) ?  r2.top  - r1.bottom : r1.top  - r2.bottom);
					IsInMg    = ((r1.left<=r2.left) && (r1.top<r2.top) && (r1.bottom>r2.bottom) && (r1.right >r2.right))? true: false;

					if(HorDist>xMerge && VerDist>yMerge && !IsInMg ) continue;

					IsxMg = (HorDist<xMerge) ? true: false;
					IsyMg = (VerDist<yMerge) ? true: false;

					if((IsxMg && IsyMg) || IsInMg){
						C5CirDefectPoint[k].Round    += C5CirDefectPoint[l].Round;
						C5CirDefectPoint[k].Rect      = OnMerge(C5CirDefectPoint[k].Rect, C5CirDefectPoint[l].Rect);
						C5CirDefectPoint[k].Width     = C5CirDefectPoint[k].Rect.right  - C5CirDefectPoint[k].Rect.left;
						C5CirDefectPoint[k].Height    = C5CirDefectPoint[k].Rect.bottom - C5CirDefectPoint[k].Rect.top ;
						C5CirDefectPoint[k].Hor_Dis   = C5CirDefectPoint[k].Width ; 
						C5CirDefectPoint[k].Ver_Dis   = C5CirDefectPoint[k].Height;
						C5CirDefectPoint[k].P.x       = (float)(C5CirDefectPoint[k].Rect.left);
						C5CirDefectPoint[k].P.y       = (float)(C5CirDefectPoint[k].Rect.top ); 
						C5CirDefectPoint[l].Rect.left = C5CirDefectPoint[l].Rect.top = C5CirDefectPoint[l].Rect.right = C5CirDefectPoint[l].Rect.bottom =0;
						C5CirDeftectCnt--;
						k=-1;
						break;
					}

				}

			}
			for(int j=0; j<tmpDDefectCount; j++){
				if(C5CirDefectPoint[j].Rect.left==0 && C5CirDefectPoint[j].Rect.top==0 && C5CirDefectPoint[j].Rect.right==0 && C5CirDefectPoint[j].Rect.bottom==0) continue;
				C5CirDefectPoint[sort] = C5CirDefectPoint[j];
				sort++;
			}
		}
		////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

		// Circle_6 불량 Merge 기능 
		if(C6CirDeftectCnt!=0){
			bool IsxMg=false, IsyMg=false, IsInMg=false;
			CRect r1, r2;
			int sort =0;
			int tmpDDefectCount = C6CirDeftectCnt;

			for(int k=0; k<tmpDDefectCount; k++){
				if(C6CirDefectPoint[k].Rect.left==0 && C6CirDefectPoint[k].Rect.top==0 && C6CirDefectPoint[k].Rect.right==0 && C6CirDefectPoint[k].Rect.bottom==0) continue;

				for(int l=k+1; l<k+MgCount; l++ ){
					IsxMg = false; IsyMg = false;
					if(l>(tmpDDefectCount-1)) break;
					if(C6CirDefectPoint[l].Rect.left==0 && C6CirDefectPoint[l].Rect.top==0 && C6CirDefectPoint[k].Rect.right==0 && C6CirDefectPoint[k].Rect.bottom==0) continue;

					r1 = C6CirDefectPoint[k].Rect;
					r2 = C6CirDefectPoint[l].Rect; 

					register int HorDist   = abs((r1.left < r2.left) ?  r2.left - r1.right  : r1.left - r2.right );
					register int VerDist   = abs((r1.top  < r2.top ) ?  r2.top  - r1.bottom : r1.top  - r2.bottom);
					IsInMg    = ((r1.left<=r2.left) && (r1.top<r2.top) && (r1.bottom>r2.bottom) && (r1.right >r2.right))? true: false;

					if(HorDist>xMerge && VerDist>yMerge && !IsInMg ) continue;

					IsxMg = (HorDist<xMerge) ? true: false;
					IsyMg = (VerDist<yMerge) ? true: false;

					if((IsxMg && IsyMg) || IsInMg){
						C6CirDefectPoint[k].Round    += C6CirDefectPoint[l].Round;
						C6CirDefectPoint[k].Rect      = OnMerge(C6CirDefectPoint[k].Rect, C6CirDefectPoint[l].Rect);
						C6CirDefectPoint[k].Width     = C6CirDefectPoint[k].Rect.right  - C6CirDefectPoint[k].Rect.left;
						C6CirDefectPoint[k].Height    = C6CirDefectPoint[k].Rect.bottom - C6CirDefectPoint[k].Rect.top ;
						C6CirDefectPoint[k].Hor_Dis   = C6CirDefectPoint[k].Width ; 
						C6CirDefectPoint[k].Ver_Dis   = C6CirDefectPoint[k].Height;
						C6CirDefectPoint[k].P.x       = (float)(C6CirDefectPoint[k].Rect.left);
						C6CirDefectPoint[k].P.y       = (float)(C6CirDefectPoint[k].Rect.top ); 
						C6CirDefectPoint[l].Rect.left = C6CirDefectPoint[l].Rect.top = C6CirDefectPoint[l].Rect.right = C6CirDefectPoint[l].Rect.bottom =0;
						C6CirDeftectCnt--;
						k=-1;
						break;
					}

				}

			}
			for(int j=0; j<tmpDDefectCount; j++){
				if(C6CirDefectPoint[j].Rect.left==0 && C6CirDefectPoint[j].Rect.top==0 && C6CirDefectPoint[j].Rect.right==0 && C6CirDefectPoint[j].Rect.bottom==0) continue;
				C6CirDefectPoint[sort] = C6CirDefectPoint[j];
				sort++;
			}
		}
		////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


		// Side C Merge (박리불량)
		if(CCrackCount!=0){
			bool IsxMg=false, IsyMg=false, IsInMg=false;
			CRect r1, r2;
			int sort =0;
			int tmpDDefectCount = CCrackCount;

			for(int k=0; k<tmpDDefectCount; k++){
				if(CCrackPoint[k].Rect.left==0 && CCrackPoint[k].Rect.top==0 && CCrackPoint[k].Rect.right==0 && CCrackPoint[k].Rect.bottom==0) continue;

				for(int l=k+1; l<k+MgCount; l++ ){
					IsxMg = false; IsyMg = false;
					if(l>(tmpDDefectCount-1)) break;
					if(CCrackPoint[l].Rect.left==0 && CCrackPoint[l].Rect.top==0 && CCrackPoint[k].Rect.right==0 && CCrackPoint[k].Rect.bottom==0) continue;

					r1 = CCrackPoint[k].Rect;
					r2 = CCrackPoint[l].Rect; 

					register int HorDist   = abs((r1.left < r2.left) ?  r2.left - r1.right  : r1.left - r2.right );
					register int VerDist   = abs((r1.top  < r2.top ) ?  r2.top  - r1.bottom : r1.top  - r2.bottom);
					IsInMg    = ((r1.left<=r2.left) && (r1.top<r2.top) && (r1.bottom>r2.bottom) && (r1.right >r2.right))? true: false;

					if(HorDist>xMerge && VerDist>yMerge && !IsInMg ) continue;

					IsxMg = (HorDist<xMerge) ? true: false;
					IsyMg = (VerDist<yMerge) ? true: false;

					if((IsxMg && IsyMg) || IsInMg){
						CCrackPoint[k].Round    += CCrackPoint[l].Round;
						CCrackPoint[k].Rect      = OnMerge(CCrackPoint[k].Rect, CCrackPoint[l].Rect);
						CCrackPoint[k].Width     = CCrackPoint[k].Rect.right  - CCrackPoint[k].Rect.left;
						CCrackPoint[k].Height    = CCrackPoint[k].Rect.bottom - CCrackPoint[k].Rect.top ;
						CCrackPoint[k].P.x       = (float)(CCrackPoint[k].Rect.left);
						CCrackPoint[k].P.y       = (float)(CCrackPoint[k].Rect.top ); 
						CCrackPoint[l].Rect.left = CCrackPoint[l].Rect.top = CCrackPoint[l].Rect.right = CCrackPoint[l].Rect.bottom =0;
						CCrackCount--;
						k=-1;
						break;
					}

				}

			}
			for(int j=0; j<tmpDDefectCount; j++){
				if(CCrackPoint[j].Rect.left==0 && CCrackPoint[j].Rect.top==0 && CCrackPoint[j].Rect.right==0 && CCrackPoint[j].Rect.bottom==0) continue;
				CCrackPoint[sort] = CCrackPoint[j];
				sort++;
			}
		}

		// Side D Merge (Crack & Chipping)
		if(DCount!=0){
			bool IsxMg=false, IsyMg=false, IsInMg=false;
			CRect r1, r2;
			int sort =0;
			int tmpDDefectCount = DCount;

			for(int k=0; k<tmpDDefectCount; k++){
				if(DDefectPoint[k].Rect.left==0 && DDefectPoint[k].Rect.top==0 && DDefectPoint[k].Rect.right==0 && DDefectPoint[k].Rect.bottom==0) continue;

				for(int l=k+1; l<k+MgCount; l++ ){
					IsxMg = false; IsyMg = false;
					if(l>(tmpDDefectCount-1)) break;
					if(DDefectPoint[l].Rect.left==0 && DDefectPoint[l].Rect.top==0 && DDefectPoint[k].Rect.right==0 && DDefectPoint[k].Rect.bottom==0) continue;

					r1 = DDefectPoint[k].Rect;
					r2 = DDefectPoint[l].Rect; 

					register int HorDist   = abs((r1.left < r2.left) ?  r2.left - r1.right  : r1.left - r2.right );
					register int VerDist   = abs((r1.top  < r2.top ) ?  r2.top  - r1.bottom : r1.top  - r2.bottom);
					IsInMg    = ((r1.left<=r2.left) && (r1.top<r2.top) && (r1.bottom>r2.bottom) && (r1.right >r2.right))? true: false;

					if(HorDist>xMerge && VerDist>yMerge && !IsInMg ) continue;

					IsxMg = (HorDist<xMerge) ? true: false;
					IsyMg = (VerDist<yMerge) ? true: false;

					if((IsxMg && IsyMg) || IsInMg){
						DDefectPoint[k].Round    += DDefectPoint[l].Round;
						DDefectPoint[k].Rect      = OnMerge(DDefectPoint[k].Rect, DDefectPoint[l].Rect);
						DDefectPoint[k].Width     = DDefectPoint[k].Rect.right  - DDefectPoint[k].Rect.left;
						DDefectPoint[k].Height    = DDefectPoint[k].Rect.bottom - DDefectPoint[k].Rect.top ;
						DDefectPoint[k].P.x       = (float)(DDefectPoint[k].Rect.left);
						DDefectPoint[k].P.y       = (float)(DDefectPoint[k].Rect.top ); 
						DDefectPoint[l].Rect.left = DDefectPoint[l].Rect.top = DDefectPoint[l].Rect.right = DDefectPoint[l].Rect.bottom =0;
						DCount--;
						k=-1;
						break;
					}

				}

			}
			for(int j=0; j<tmpDDefectCount; j++){
				if(DDefectPoint[j].Rect.left==0 && DDefectPoint[j].Rect.top==0 && DDefectPoint[j].Rect.right==0 && DDefectPoint[j].Rect.bottom==0) continue;
				DDefectPoint[sort] = DDefectPoint[j];
				sort++;
			}
		}

		// Side D Merge(Burr & Remain)
		if(DBurrCount!=0){
			bool IsxMg=false, IsyMg=false, IsInMg=false;
			CRect r1, r2;
			int sort =0;
			int tmpDDefectCount = DBurrCount;

			for(int k=0; k<tmpDDefectCount; k++){
				if(DBurrPoint[k].Rect.left==0 && DBurrPoint[k].Rect.top==0 && DBurrPoint[k].Rect.right==0 && DBurrPoint[k].Rect.bottom==0) continue;

				for(int l=k+1; l<k+MgCount; l++ ){
					IsxMg = false; IsyMg = false;
					if(l>(tmpDDefectCount-1)) break;
					if(DBurrPoint[l].Rect.left==0 && DBurrPoint[l].Rect.top==0 && DBurrPoint[k].Rect.right==0 && DBurrPoint[k].Rect.bottom==0) continue;

					r1 = DBurrPoint[k].Rect;
					r2 = DBurrPoint[l].Rect; 

					register int HorDist   =abs((r1.left < r2.left) ?  r2.left - r1.right  : r1.left - r2.right );
					register int VerDist   =abs((r1.top  < r2.top ) ?  r2.top  - r1.bottom : r1.top  - r2.bottom);
					IsInMg    = ((r1.left<=r2.left) && (r1.top<r2.top) && (r1.bottom>r2.bottom) && (r1.right >r2.right))? true: false;

					if(HorDist>xMerge && VerDist>yMerge && !IsInMg ) continue;

					IsxMg = (HorDist<xMerge) ? true: false;
					IsyMg = (VerDist<yMerge) ? true: false;

					if((IsxMg && IsyMg) || IsInMg){
						DBurrPoint[k].Round    += DBurrPoint[l].Round;
						DBurrPoint[k].Rect      = OnMerge(DBurrPoint[k].Rect, DBurrPoint[l].Rect);
						DBurrPoint[k].Width     = DBurrPoint[k].Rect.right  - DBurrPoint[k].Rect.left;
						DBurrPoint[k].Height    = DBurrPoint[k].Rect.bottom - DBurrPoint[k].Rect.top ;
						DBurrPoint[k].P.x       = (float)(DBurrPoint[k].Rect.left);
						DBurrPoint[k].P.y       = (float)(DBurrPoint[k].Rect.top ); 
						DBurrPoint[l].Rect.left = DBurrPoint[l].Rect.top = DBurrPoint[l].Rect.right = DBurrPoint[l].Rect.bottom =0;
						DBurrCount--;
						k=-1;
						break;
					}

				}

			}
			for(int j=0; j<tmpDDefectCount; j++){
				if(DBurrPoint[j].Rect.left==0 && DBurrPoint[j].Rect.top==0 && DBurrPoint[j].Rect.right==0 && DBurrPoint[j].Rect.bottom==0) continue;
				DBurrPoint[sort] = DBurrPoint[j];
				sort++;
			}
		}


		// Side B Merge (Crack & Chipping)
		if(BCount!=0){
			bool IsxMg=false, IsyMg=false, IsInMg=false;
			CRect r1, r2;
			int sort =0;
			int tmpBDefectCount = BCount;

			for(int k=0; k<tmpBDefectCount; k++){
				if(BDefectPoint[k].Rect.left==0 && BDefectPoint[k].Rect.top==0 && BDefectPoint[k].Rect.right==0 && BDefectPoint[k].Rect.bottom==0) continue;

				for(int l=k+1; l<k+MgCount; l++ ){
					IsxMg = false; IsyMg = false;
					if(l>(tmpBDefectCount-1)) break;
					if(BDefectPoint[l].Rect.left==0 && BDefectPoint[l].Rect.top==0 && BDefectPoint[k].Rect.right==0 && BDefectPoint[k].Rect.bottom==0) continue;

					r1 = BDefectPoint[k].Rect;
					r2 = BDefectPoint[l].Rect; 

					register int HorDist   = abs((r1.left < r2.left) ?  r2.left - r1.right  : r1.left - r2.right );
					register int VerDist   = abs((r1.top  < r2.top ) ?  r2.top  - r1.bottom : r1.top  - r2.bottom);
					IsInMg    = ((r1.left<r2.left) && (r1.top<r2.top) && (r1.bottom>r2.bottom) && (r1.right >=r2.right))? true: false;

					if(HorDist>xMerge && VerDist>yMerge && !IsInMg ) continue;

					IsxMg = (HorDist<xMerge) ? true: false;
					IsyMg = (VerDist<yMerge) ? true: false;

					if((IsxMg && IsyMg) || IsInMg){
						BDefectPoint[k].Round    += BDefectPoint[l].Round;
						BDefectPoint[k].Rect      = OnMerge(BDefectPoint[k].Rect, BDefectPoint[l].Rect);
						BDefectPoint[k].Width     = BDefectPoint[k].Rect.right  - BDefectPoint[k].Rect.left;
						BDefectPoint[k].Height    = BDefectPoint[k].Rect.bottom - BDefectPoint[k].Rect.top ;
						BDefectPoint[k].P.x       = (float)(BDefectPoint[k].Rect.left);
						BDefectPoint[k].P.y       = (float)(BDefectPoint[k].Rect.top ); 
						BDefectPoint[l].Rect.left = BDefectPoint[l].Rect.top = BDefectPoint[l].Rect.right = BDefectPoint[l].Rect.bottom =0;
						BCount--;
						k=-1;
						break;
					}

				}

			}
			for(int j=0; j<tmpBDefectCount; j++){
				if(BDefectPoint[j].Rect.left==0 && BDefectPoint[j].Rect.top==0 && BDefectPoint[j].Rect.right==0 && BDefectPoint[j].Rect.bottom==0) continue;
				BDefectPoint[sort] = BDefectPoint[j];
				sort++;
			}
		}


		// Side B Merge (Burr & Remain)
		if(BBurrCount!=0){
			bool IsxMg=false, IsyMg=false, IsInMg=false;
			CRect r1, r2;
			int sort =0;
			int tmpBDefectCount = BBurrCount;

			for(int k=0; k<tmpBDefectCount; k++){
				if(BBurrPoint[k].Rect.left==0 && BBurrPoint[k].Rect.top==0 && BBurrPoint[k].Rect.right==0 && BBurrPoint[k].Rect.bottom==0) continue;

				for(int l=k+1; l<k+MgCount; l++ ){
					IsxMg = false; IsyMg = false;
					if(l>(tmpBDefectCount-1)) break;
					if(BBurrPoint[l].Rect.left==0 && BBurrPoint[l].Rect.top==0 && BBurrPoint[k].Rect.right==0 && BBurrPoint[k].Rect.bottom==0) continue;

					r1 = BBurrPoint[k].Rect;
					r2 = BBurrPoint[l].Rect; 

					register int HorDist   = abs((r1.left < r2.left) ?  r2.left - r1.right  : r1.left - r2.right );
					register int VerDist   = abs((r1.top  < r2.top ) ?  r2.top  - r1.bottom : r1.top  - r2.bottom);
					IsInMg    = ((r1.left<r2.left) && (r1.top<r2.top) && (r1.bottom>r2.bottom) && (r1.right >=r2.right))? true: false;

					if(HorDist>xMerge && VerDist>yMerge && !IsInMg ) continue;

					IsxMg = (HorDist<xMerge) ? true: false;
					IsyMg = (VerDist<yMerge) ? true: false;

					if((IsxMg && IsyMg) || IsInMg){
						BBurrPoint[k].Round    += BBurrPoint[l].Round;
						BBurrPoint[k].Rect      = OnMerge(BBurrPoint[k].Rect, BBurrPoint[l].Rect);
						BBurrPoint[k].Width     = BBurrPoint[k].Rect.right  - BBurrPoint[k].Rect.left;
						BBurrPoint[k].Height    = BBurrPoint[k].Rect.bottom - BBurrPoint[k].Rect.top ;
						BBurrPoint[k].P.x       = (float)(BBurrPoint[k].Rect.left);
						BBurrPoint[k].P.y       = (float)(BBurrPoint[k].Rect.top ); 
						BBurrPoint[l].Rect.left = BBurrPoint[l].Rect.top = BBurrPoint[l].Rect.right = BBurrPoint[l].Rect.bottom =0;
						BBurrCount--;
						k=-1;
						break;
					}

				}

			}
			for(int j=0; j<tmpBDefectCount; j++){
				if(BBurrPoint[j].Rect.left==0 && BBurrPoint[j].Rect.top==0 && BBurrPoint[j].Rect.right==0 && BBurrPoint[j].Rect.bottom==0) continue;
				BBurrPoint[sort] = BBurrPoint[j];
				sort++;
			}

		}

		if(!IsCornerTop){
			if(ACount!=0){ // Left 
				bool IsxMg, IsyMg;
				CRect r1, r2;
				int sort =0;
				int tmpBDefectCount = ACount;

				// SIDE A + SIDE D Merge 
				for(int k=0; k<tmpBDefectCount; k++){
					if(ADefectPoint[k].Rect.left==0 && ADefectPoint[k].Rect.top==0 && ADefectPoint[k].Rect.right==0 && ADefectPoint[k].Rect.bottom==0) continue;
					IsxMg = false; IsyMg = false;
					r1 = ADefectPoint[k].Rect;
					r2 = DDefectPoint[0].Rect; 

					register int HorDist   = abs((r1.left < r2.left) ?  r2.left - r1.right  : r1.left - r2.right );
					register int VerDist   = abs((r1.top  < r2.top ) ?  r2.top  - r1.bottom : r1.top  - r2.bottom);

					if(HorDist>xMerge && VerDist>yMerge) continue;

					IsxMg = (HorDist<xMerge) ? true: false;
					IsyMg = (VerDist<yMerge) ? true: false;

					if(IsxMg && IsyMg){
						DDefectPoint[0].Round     = (ADefectPoint[k].Round>DDefectPoint[0].Round) ? ADefectPoint[k].Round :DDefectPoint[0].Round; 
						DDefectPoint[0].Rect      = OnMerge(ADefectPoint[k].Rect, DDefectPoint[0].Rect);
						DDefectPoint[0].Width     = DDefectPoint[0].Rect.right  - DDefectPoint[0].Rect.left;
						DDefectPoint[0].Height    = DDefectPoint[0].Rect.bottom - DDefectPoint[0].Rect.top ;
						ADefectPoint[k].Rect.left = ADefectPoint[k].Rect.top = ADefectPoint[k].Rect.right = ADefectPoint[k].Rect.bottom =0;
						ACount--;
						k=-1;
						//break;
					}
				}

				for(int j=0; j<tmpBDefectCount; j++){
					if(ADefectPoint[j].Rect.left==0 && ADefectPoint[j].Rect.top==0 && ADefectPoint[j].Rect.right==0 && ADefectPoint[j].Rect.bottom==0) continue;
					ADefectPoint[sort] = ADefectPoint[j];
					sort++;
				}
			}

			if(ACount!=0){ // Right 
				bool IsxMg, IsyMg;
				CRect r1, r2;
				int sort =0;
				int tmpBDefectCount = ACount;

				// SIDE A + SIDE B Merge 
				for(int k=0; k<tmpBDefectCount; k++){
					if(ADefectPoint[k].Rect.left==0 && ADefectPoint[k].Rect.top==0 && ADefectPoint[k].Rect.right==0 && ADefectPoint[k].Rect.bottom==0) continue;
					IsxMg = false; IsyMg = false;
					r1 = ADefectPoint[k].Rect;
					r2 = BDefectPoint[0].Rect; 

					register int HorDist   = abs((r1.left < r2.left) ?  r2.left - r1.right  : r1.left - r2.right );
					register int VerDist   = abs((r1.top  < r2.top ) ?  r2.top  - r1.bottom : r1.top  - r2.bottom);

					if(HorDist>xMerge && VerDist>yMerge) continue;

					IsxMg = (HorDist<xMerge) ? true: false;
					IsyMg = (VerDist<yMerge) ? true: false;

					if(IsxMg && IsyMg){
						BDefectPoint[0].Round     = (ADefectPoint[k].Round>BDefectPoint[0].Round) ? ADefectPoint[k].Round :BDefectPoint[0].Round; 
						BDefectPoint[0].Rect      = OnMerge(ADefectPoint[k].Rect, BDefectPoint[0].Rect);
						BDefectPoint[0].Width     = BDefectPoint[0].Rect.right  - BDefectPoint[0].Rect.left;
						BDefectPoint[0].Height    = BDefectPoint[0].Rect.bottom - BDefectPoint[0].Rect.top ;
						ADefectPoint[k].Rect.left = ADefectPoint[k].Rect.top = ADefectPoint[k].Rect.right = ADefectPoint[k].Rect.bottom =0;
						ACount--;
						k=-1;
						//break;
					}
				}

				for(int j=0; j<tmpBDefectCount; j++){
					if(ADefectPoint[j].Rect.left==0 && ADefectPoint[j].Rect.top==0 && ADefectPoint[j].Rect.right==0 && ADefectPoint[j].Rect.bottom==0) continue;
					ADefectPoint[sort] = ADefectPoint[j];
					sort++;
				}
			}
		}
		//////////////////////////////////////////////////////////////////////////////////////////////
		// Blob Merge End
		Index = 0;
		return true;

		// BMDT RectH : 모자모양
		//------------------------------------------------------------------
	case 13 :

		if(FInspectMode==Insp_Surface){ //표면검사 시퀀스//
			DefectROI.Attach(&DefectImg);
			CodeImageSelection.SetFeretAngle(0.00f);
			CodeImageEncoder.GetGrayscaleSingleThresholdSegmenter().SetWhiteLayerEncoded(true );
			CodeImageEncoder.GetGrayscaleSingleThresholdSegmenter().SetBlackLayerEncoded(false);
			IAddress = DefectImg.GetImagePtr();

			//Side A
			////////////////////////////////////////////////////////////////////////////////////////////////
			DefectROI.SetPlacement((int)(FLTPoint.x+SideMargin), (int)((FLTPoint.y+FRTPoint.y)/2), TopWidth-(2*SideMargin), FTopHeight);
			if((FLTPoint.x+SideMargin) <=0          || ((FLTPoint.y+FRTPoint.y)/2)<=0           || TopWidth-(2*SideMargin)<=0          || FTopHeight<=0          )return false;
			if((FLTPoint.x+SideMargin) >=ImageWidth || ((FLTPoint.y+FRTPoint.y)/2)>TopLimitLine || TopWidth-(2*SideMargin)>=ImageWidth || FTopHeight>TopLimitLine) return false;
			if((FLTPoint.x+SideMargin)+(TopWidth-(2*SideMargin)) >=ImageWidth || ((FLTPoint.y+FRTPoint.y)/2)+ FTopHeight>TopLimitLine) return false;
			// Blob 검사 
			CodeImageSelection.Clear();
			CodeImageEncoder.Encode(DefectROI,CodeImage);
			CodeImageSelection.Clear();
			CodeImageSelection.AddObjects(CodeImage);
			// Blob 필터링 
			CodeImageSelection.RemoveUsingFloatFeature  (EFeature_BoundingBoxWidth ,FMinWidth                  , FMaxWidth                  , EDoubleThresholdMode_Outside);
			CodeImageSelection.RemoveUsingFloatFeature  (EFeature_BoundingBoxHeight,FMinHeight                 , FMaxHeight                 , EDoubleThresholdMode_Outside);
			CodeImageSelection.RemoveUsingIntegerFeature(EFeature_LeftLimit        ,0                          , 2                          , EDoubleThresholdMode_Inside ); // TOP영역에 붙어있는 데이터 제거 
			CodeImageSelection.RemoveUsingIntegerFeature(EFeature_TopLimit         ,0                          , 2                          , EDoubleThresholdMode_Inside ); // TOP영역에 붙어있는 데이터 제거 
			CodeImageSelection.RemoveUsingIntegerFeature(EFeature_RightLimit       ,(TopWidth-(2*SideMargin))-1, (TopWidth-(2*SideMargin))+1, EDoubleThresholdMode_Inside );

			BlobCount = CodeImageSelection.GetElementCount();
			CodeImageSelection.Sort(EFeature_LeftLimit ,ESortDirection_Ascending);

			if(BlobCount!=0){
				for(int k=0; k<BlobCount; k++){
					if(ACount>=MAX_DEFECT_POINT) break;
					ADefectPoint[ACount].Width  = CodeImageSelection.GetElement(k).GetBoundingBoxWidth() ;
					ADefectPoint[ACount].Height = CodeImageSelection.GetElement(k).GetBoundingBoxHeight();

					ADefectPoint[ACount].Rect.left   =(long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterX() - ADefectPoint[ACount].Width/2 ) +FLTPoint.x+SideMargin      );
					ADefectPoint[ACount].Rect.top    =(long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - ADefectPoint[ACount].Height/2) +((FLTPoint.y+FRTPoint.y)/2));
					ADefectPoint[ACount].Rect.right  =(long)(ADefectPoint[ACount].Rect.left+ ADefectPoint[ACount].Width );
					ADefectPoint[ACount].Rect.bottom =(long)(ADefectPoint[ACount].Rect.top + ADefectPoint[ACount].Height);
					PixelCount = 0;
					PixelValue = 0;

					// 내부 Pixel Data 축출 
					for(int n=ADefectPoint[ACount].Rect.top+1 ; n<ADefectPoint[ACount].Rect.bottom-1; n++){
						for(int m=ADefectPoint[ACount].Rect.left+1; m<ADefectPoint[ACount].Rect.right-1 ; m++){
							PixelValue = IElement(m,n);
							if(PixelValue > EnCapTopThresHold) PixelCount++;
						}
					}

					ADefectPoint[ACount].Round  = PixelCount;
					ADefectPoint[ACount].P.x    =(float)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterX() - ADefectPoint[ACount].Width/2 )+FLTPoint.x+SideMargin      );
					ADefectPoint[ACount].P.y    =(float)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - ADefectPoint[ACount].Height/2)+((FLTPoint.y+FRTPoint.y)/2));

					// Image Rotate 기준 좌표를 다시 Rotate한다 _ Display 목적 
					if(ImgDegree!=0.0f){
						ADefectPoint[ACount].P = Math.OnRotate(CenterPoint, ADefectPoint[ACount].P, (ImgDegree));
					}
					// Image Rotate 기준 좌표를 회전 이후에 ImageHeight값을 더하여 실제 좌표를 산출한다 
					ADefectPoint[ACount].P.y    =(float)(ADefectPoint[ACount].P.y+ImageHeight);

					//Merget위해서 필요함 
					ADefectPoint[ACount].Rect.top    =(long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - ADefectPoint[ACount].Height/2) +((FLTPoint.y+FRTPoint.y)/2)+ImageHeight);
					ADefectPoint[ACount].Rect.bottom =(long)(ADefectPoint[ACount].Rect.top + ADefectPoint[ACount].Height);
					ACount++;
				}
			}
			BlobCount =0;
		}
		else             { //외관검사 시퀀스//
			// Corner Defect 검사 
			if(IsCornerTop){
				if(C1InEdgeCount!=0){
					CornerCount=0;
					for(int k=0; k<C1InEdgeCount; k++){
						if(C1InPoint[k].y>FLTLPoint.y-1) continue;
						Dis = Math.GetLengthFrLineToPoint(FLTLInPoint, FLTTInPoint, C1InPoint[k]);
						C1Corner[CornerCount].Dv   = Dis         ;
						C1Corner[CornerCount].P.x  = C1InPoint[k].x;
						C1Corner[CornerCount].P.y  = C1InPoint[k].y;
						CornerCount++;
						if(Dis>MaxDv) MaxDv = Dis;
						if(Dis<MinDv) MinDv = Dis;
					}
					if(LTCornerWidth>(LTCornerHeight*2)) C1Count = GetSize(C1Corner, C1DefectPoint, CornerCount, 10);
					else                                 C1Count = GetSize(C1Corner, C1DefectPoint, CornerCount, 5 );
				}

				MaxDv =0.0f;
				MinDv =10000.0f;

				// Corner 2 
				if(C2InEdgeCount!=0){
					CornerCount=0;
					for(int k=0; k<C2InEdgeCount; k++){
						if(C2InPoint[k].y>FRTRPoint.y-1) continue;
						Dis = Math.GetLengthFrLineToPoint(FRTTInPoint, FRTRInPoint, C2InPoint[k]);
						C2Corner[CornerCount].Dv   = Dis         ;
						C2Corner[CornerCount].P.x  = C2InPoint[k].x;
						C2Corner[CornerCount].P.y  = C2InPoint[k].y;
						CornerCount++;
						if(Dis>MaxDv) MaxDv = Dis;
						if(Dis<MinDv) MinDv = Dis;
					}
					if(RTCornerWidth >(RTCornerHeight*1.5)) C2Count = GetSize(C2Corner, C2DefectPoint, CornerCount, 10);
					else                                    C2Count = GetSize(C2Corner, C2DefectPoint, CornerCount, 5 );

				}
				//Side A
				////////////////////////////////////////////////////////////////////////////////////////////////
				// 			LogUnit.SetLog("CAP_Side_A_Start_CamId: %d, ImageHeight: %d ",CamId,ImageHeight);     
				// 		DefectROI.SetPlacement((int)(FLTTPoint.x+SideMargin), (int)((FLTTPoint.y+FRTTPoint.y)/2), TopWidth-(2*SideMargin), FTopHeight);
				DefectROI.SetPlacement((int)(FLTTInPoint.x+SideMargin), (int)((FLTTInPoint.y+FRTTInPoint.y)/2), TopWidth-(2*SideMargin), FTopHeight);
				if((FLTTInPoint.x+SideMargin) <=0          || ((FLTTInPoint.y+FRTTInPoint.y)/2)<=0           || TopWidth-(2*SideMargin)<=0          || FTopHeight<=0          )return false;
				if((FLTTInPoint.x+SideMargin) >=ImageWidth || ((FLTTInPoint.y+FRTTInPoint.y)/2)>TopLimitLine || TopWidth-(2*SideMargin)>=ImageWidth || FTopHeight>TopLimitLine) return false;
				if((FLTTInPoint.x+SideMargin)+(TopWidth-(2*SideMargin)) >=ImageWidth || ((FRTTInPoint.y+FRTTPoint.y)/2)+ FTopHeight>TopLimitLine) return false;
				// Blob 검사 
				CodeImageSelection.Clear();
				CodeImageEncoder.Encode(DefectROI,CodeImage);
				CodeImageSelection.Clear();
				CodeImageSelection.AddObjects(CodeImage);
				// Blob 필터링 
				CodeImageSelection.RemoveUsingFloatFeature  (EFeature_BoundingBoxWidth ,FMinWidth , FMaxWidth  , EDoubleThresholdMode_Outside);
				CodeImageSelection.RemoveUsingFloatFeature  (EFeature_BoundingBoxHeight,FMinHeight, FMaxHeight , EDoubleThresholdMode_Outside);
				CodeImageSelection.RemoveUsingIntegerFeature(EFeature_TopLimit         ,0         , 3          , EDoubleThresholdMode_Outside);

				BlobCount = CodeImageSelection.GetElementCount();
				CodeImageSelection.Sort(EFeature_LeftLimit ,ESortDirection_Ascending);

				if(BlobCount!=0){
					for(int k=0; k<BlobCount; k++){
						if(ACount>=MAX_DEFECT_POINT) break;
						ADefectPoint[ACount].Width  = CodeImageSelection.GetElement(k).GetBoundingBoxWidth() ;
						ADefectPoint[ACount].Height = CodeImageSelection.GetElement(k).GetBoundingBoxHeight();

						ADefectPoint[ACount].Rect.left   =(long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterX() - ADefectPoint[ACount].Width/2 ) +FLTTInPoint.x+SideMargin      );
						ADefectPoint[ACount].Rect.top    =(long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - ADefectPoint[ACount].Height/2) +((FLTTInPoint.y+FRTTInPoint.y)/2));
						ADefectPoint[ACount].Rect.right  =(long)(ADefectPoint[ACount].Rect.left+ ADefectPoint[ACount].Width );
						ADefectPoint[ACount].Rect.bottom =(long)(ADefectPoint[ACount].Rect.top + ADefectPoint[ACount].Height);
						PixelCount = 0;
						PixelValue = 0;

						// 내부 Pixel Data 축출 
						for(int n=ADefectPoint[ACount].Rect.top+1 ; n<ADefectPoint[ACount].Rect.bottom-1; n++){
							for(int m=ADefectPoint[ACount].Rect.left+1; m<ADefectPoint[ACount].Rect.right-1 ; m++){
								PixelValue = IElement(m,n);
								if(PixelValue < EnCapTopThresHold) PixelCount++;
							}
						}

						ADefectPoint[ACount].Round  = PixelCount;
						ADefectPoint[ACount].P.x    =(float)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterX() - ADefectPoint[ACount].Width/2 )+FLTTInPoint.x+SideMargin       );
						ADefectPoint[ACount].P.y    =(float)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - ADefectPoint[ACount].Height/2)+((FLTTInPoint.y+FRTTInPoint.y)/2));

						// Image Rotate 기준 좌표를 다시 Rotate한다 _ Display 목적 
						if(ImgDegree!=0.0f){
							ADefectPoint[ACount].P = Math.OnRotate(CenterPoint, ADefectPoint[ACount].P, (ImgDegree));
						}
						// Image Rotate 기준 좌표를 회전 이후에 ImageHeight값을 더하여 실제 좌표를 산출한다 
						ADefectPoint[ACount].P.y    =(float)(ADefectPoint[ACount].P.y+ImageHeight);

						//Merget위해서 필요함 
						ADefectPoint[ACount].Rect.top    =(long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - ADefectPoint[ACount].Height/2) +((FLTTInPoint.y+FRTTInPoint.y)/2)+ImageHeight);
						ADefectPoint[ACount].Rect.bottom =(long)(ADefectPoint[ACount].Rect.top + ADefectPoint[ACount].Height);
						ACount++;
					}
				}

				//Side B
				////////////////////////////////////////////////////////////////////////////////////////////////
				// 			LogUnit.SetLog("CAP_Side_B_Start_CamId: %d, ImageHeight: %d ",CamId,ImageHeight);     
				// 			DefectROI.SetPlacement((int)(FRTRInPoint.x-FRightWidth-SideMargin), (int)(FRTRInPoint.y+Margin), FRightWidth, (RightHeight-(2*Margin)-TopMargin));
				// 			DefectROI.SetPlacement((int)(FRTRInPoint.x-FRightWidth-SideMargin), (int)(FRTRInPoint.y+Margin), FRightWidth, (RightHeight-(2*Margin)-TopMargin));
				DefectROI.SetPlacement((int)(FRTRInPoint.x-FRightWidth-SideMargin), (int)(FRTRInPoint.y+Margin), FRightWidth, (RightHeight-(2*Margin)-RightDegMargin));
				if((FRTRInPoint.x-FRightWidth-SideMargin) <=0          ||(FRTRInPoint.y+Margin)<=0           || FRightWidth<=0          || (RightHeight-(2*Margin)-RightDegMargin)<=0)           return false;
				if((FRTRInPoint.x-FRightWidth-SideMargin) >=ImageWidth ||(FRTRInPoint.y+Margin)>TopLimitLine || FRightWidth>=ImageWidth || (RightHeight-(2*Margin)-RightDegMargin)>TopLimitLine) return false;
				if((FRTRInPoint.x-FRightWidth-SideMargin)+FRightWidth >=ImageWidth ||((FRTRInPoint.y+Margin)+(RightHeight-(2*Margin)-RightDegMargin))>TopLimitLine) return false;
				//  Blob 검사 진행 
				CodeImageSelection.Clear();
				CodeImageEncoder.Encode(DefectROI,CodeImage);
				CodeImageSelection.Clear();
				CodeImageSelection.AddObjects(CodeImage);
				// Blob 필터링 
				CodeImageSelection.RemoveUsingFloatFeature(EFeature_BoundingBoxWidth ,FMinWidth     , FMaxWidth    , EDoubleThresholdMode_Outside);
				CodeImageSelection.RemoveUsingFloatFeature(EFeature_BoundingBoxHeight,FMinHeight    , FMaxHeight   , EDoubleThresholdMode_Outside);
				// 				CodeImageSelection.RemoveUsingIntegerFeature(EFeature_RightLimit     ,FRightWidth-2 , FRightWidth+1, EDoubleThresholdMode_Outside);
				CodeImageSelection.RemoveUsingIntegerFeature(EFeature_RightLimit     ,FRightWidth-1 , FRightWidth+1, EDoubleThresholdMode_Outside);

				BlobCount = CodeImageSelection.GetElementCount();
				CodeImageSelection.Sort(EFeature_TopLimit,ESortDirection_Ascending);

				if(BlobCount!=0){
					for(int k=0; k<BlobCount; k++){
						if(BCount>=MAX_DEFECT_POINT) break;
						BDefectPoint[BCount].Width  = CodeImageSelection.GetElement(k).GetBoundingBoxWidth() ;
						BDefectPoint[BCount].Height = CodeImageSelection.GetElement(k).GetBoundingBoxHeight();

						BDefectPoint[BCount].Rect.left   = (long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterX() - BDefectPoint[BCount].Width/2 ) +(FRTRInPoint.x-FRightWidth-SideMargin));
						BDefectPoint[BCount].Rect.top    = (long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - BDefectPoint[BCount].Height/2) +(FRTRInPoint.y+Margin)                );
						BDefectPoint[BCount].Rect.right  = (long)(BDefectPoint[BCount].Rect.left+ BDefectPoint[BCount].Width );
						BDefectPoint[BCount].Rect.bottom = (long)(BDefectPoint[BCount].Rect.top + BDefectPoint[BCount].Height);
						PixelCount = 0;
						PixelValue = 0;

						// 내부 Pixel Data 축출 
						for(int n=BDefectPoint[BCount].Rect.top+1 ; n<BDefectPoint[BCount].Rect.bottom-1; n++){
							for(int m=BDefectPoint[BCount].Rect.left+1; m<BDefectPoint[BCount].Rect.right-1 ; m++){
								PixelValue = IElement(m,n);
								if(PixelValue < EnCapTopThresHold) PixelCount++;
							}
						}
						BDefectPoint[BCount].Round  = PixelCount;
						BDefectPoint[BCount].P.x    = (float)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterX() - BDefectPoint[BCount].Width/2 ) +(FRTRInPoint.x-FRightWidth-SideMargin));
						BDefectPoint[BCount].P.y    = (float)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - BDefectPoint[BCount].Height/2) +(FRTRInPoint.y+Margin)+ImageHeight    );
						BDefectPoint[BCount].Width  = BDefectPoint[BCount].Width+SideMargin; 

						// Merge 위해서 데이터 필요함 
						BDefectPoint[BCount].Rect.top    =(long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - BDefectPoint[BCount].Height/2) + FRTRInPoint.y+Margin+ImageHeight);
						BDefectPoint[BCount].Rect.bottom =(long)(BDefectPoint[BCount].Rect.top + BDefectPoint[BCount].Height);
						BCount++;
					}
				}
				BlobCount =0;

				// 외곽라인에서 Mark까지의 거리 산출 
				if     (Line[waRightWall].FP0.x >Line[waRightWall].FP1.x) RDistance = ((Line[waRightWall].FP1.x+(Line[waRightWall].FP0.x - Line[waRightWall].FP1.x)/2) - FP1.x);
				else if(Line[waRightWall].FP0.x==Line[waRightWall].FP1.x) RDistance = (Line[waRightWall].FP0.x - FP1.x);
				else                                                      RDistance = ((Line[waRightWall].FP0.x+(Line[waRightWall].FP1.x - Line[waRightWall].FP0.x)/2) - FP1.x);

				MarktoBmLine = (IsMarkBtm) ? 5: 50;  
				if(IsMarkBtm) RDistance = RDistance-MarktoBmLine;
				else          RDistance = RDistance+MarktoBmLine;

				// Side D	
				////////////////////////////////////////////////////////////////////////////////////////////////
				// 			LogUnit.SetLog("CAP_Side_D_Start_CamId: %d, ImageHeight: %d ",CamId,ImageHeight);     
				// 			DefectROI.SetPlacement((int)(FLTLInPoint.x+SideMargin), (int)(FLTLInPoint.y+Margin), FLeftWidth, (LeftHeight-(2*Margin)-TopMargin));
				// 			if((FLTLInPoint.x+SideMargin) <=0          ||(FLTLInPoint.y+Margin)<=0           || FLeftWidth<=0          || (LeftHeight-(2*Margin)-TopMargin)<=0          ) return false;
				// 			if((FLTLInPoint.x+SideMargin) >=ImageWidth ||(FLTLInPoint.y+Margin)>TopLimitLine || FLeftWidth>=ImageWidth || (LeftHeight-(2*Margin)-TopMargin)>TopLimitLine) return false;
				// 			if((FLTLInPoint.x+SideMargin)+FLeftWidth >=ImageWidth ||(FLTLInPoint.y+Margin)+(LeftHeight-(2*Margin)-TopMargin)>TopLimitLine) return false;

				DefectROI.SetPlacement((int)(FLTLInPoint.x+SideMargin), (int)(FLTLInPoint.y+Margin), FLeftWidth, (LeftHeight-(2*Margin)-LeftDegMargin));
				if((FLTLInPoint.x+SideMargin) <=0          ||(FLTLInPoint.y+Margin)<=0           || FLeftWidth<=0          || (LeftHeight-(2*Margin)-LeftDegMargin)<=0          ) return false;
				if((FLTLInPoint.x+SideMargin) >=ImageWidth ||(FLTLInPoint.y+Margin)>TopLimitLine || FLeftWidth>=ImageWidth || (LeftHeight-(2*Margin)-LeftDegMargin)>TopLimitLine) return false;
				if((FLTLInPoint.x+SideMargin)+FLeftWidth >=ImageWidth ||(FLTLInPoint.y+Margin)+(LeftHeight-(2*Margin)-LeftDegMargin)>TopLimitLine) return false;

				// Blob 검사 진행 
				CodeImageSelection.Clear();
				CodeImageEncoder.Encode(DefectROI,CodeImage);
				CodeImageSelection.Clear();
				CodeImageSelection.AddObjects(CodeImage);

				// Blob 필터링 
				CodeImageSelection.RemoveUsingFloatFeature  (EFeature_BoundingBoxWidth ,FMinWidth , FMaxWidth  , EDoubleThresholdMode_Outside);
				CodeImageSelection.RemoveUsingFloatFeature  (EFeature_BoundingBoxHeight,FMinHeight, FMaxHeight , EDoubleThresholdMode_Outside);
				// 				CodeImageSelection.RemoveUsingIntegerFeature(EFeature_LeftLimit        ,0         , 3          , EDoubleThresholdMode_Outside);
				CodeImageSelection.RemoveUsingIntegerFeature(EFeature_LeftLimit        ,0         , 1          , EDoubleThresholdMode_Outside);

				BlobCount = CodeImageSelection.GetElementCount();
				CodeImageSelection.Sort(EFeature_TopLimit,ESortDirection_Ascending);

				if(BlobCount!=0){
					for(int k=0; k<BlobCount; k++){
						if(DCount>=MAX_DEFECT_POINT) break;
						DDefectPoint[DCount].Width     =  CodeImageSelection.GetElement(k).GetBoundingBoxWidth() ;
						DDefectPoint[DCount].Height    =  CodeImageSelection.GetElement(k).GetBoundingBoxHeight();

						DDefectPoint[DCount].Rect.left   = (long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterX() - DDefectPoint[DCount].Width/2 ) +(FLTLInPoint.x+SideMargin));
						DDefectPoint[DCount].Rect.top    = (long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - DDefectPoint[DCount].Height/2) +(FLTLInPoint.y+Margin)    );
						DDefectPoint[DCount].Rect.right  = (long)(DDefectPoint[DCount].Rect.left+ DDefectPoint[DCount].Width );
						DDefectPoint[DCount].Rect.bottom = (long)(DDefectPoint[DCount].Rect.top + DDefectPoint[DCount].Height);

						PixelCount = 0;
						PixelValue = 0;
						// 내부 Pixel Data 축출 
						for(int n=DDefectPoint[DCount].Rect.top+1 ; n<DDefectPoint[DCount].Rect.bottom-1; n++){
							for(int m=DDefectPoint[DCount].Rect.left+1; m<DDefectPoint[DCount].Rect.right-1 ; m++){
								PixelValue = IElement(m,n);
								if(PixelValue < EnCapTopThresHold) PixelCount++;
							}
						}
						// Display 데이터 필요함 
						DDefectPoint[DCount].Round = PixelCount;
						DDefectPoint[DCount].P.x       = (float)(DDefectPoint[DCount].Rect.left);
						DDefectPoint[DCount].P.y       = (float)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - DDefectPoint[DCount].Height/2)+(FLTLInPoint.y+Margin)+ImageHeight );
						DDefectPoint[DCount].Width     = DDefectPoint[DCount].Width+SideMargin; 

						// Merge 위해서 데이터 필요함 
						DDefectPoint[DCount].Rect.top    =(long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - DDefectPoint[DCount].Height/2) +(FLTLInPoint.y+Margin)+ImageHeight);
						DDefectPoint[DCount].Rect.bottom =(long)(DDefectPoint[DCount].Rect.top + DDefectPoint[DCount].Height);
						DCount++;
					}
				}
				BlobCount =0;

				// 외곽라인에서 Mark까지의 거리 산출 
				if     (Line[waLeftWall].FP0.x >Line[waLeftWall].FP1.x) LDistance = (FP0.x - (Line[waLeftWall].FP1.x+(Line[waLeftWall].FP0.x - Line[waLeftWall].FP1.x)/2));
				else if(Line[waLeftWall].FP0.x==Line[waLeftWall].FP1.x) LDistance = (FP0.x -  Line[waLeftWall].FP0.x)                                                     ;
				else                                                    LDistance = (FP0.x - (Line[waLeftWall].FP0.x+(Line[waLeftWall].FP1.x - Line[waLeftWall].FP0.x)/2)); 
			}
			else if(IsRectTop) {  // Corner Cutting이 없을경우 
				//Side A
				////////////////////////////////////////////////////////////////////////////////////////////////
				DefectROI.SetPlacement((int)(FLTPoint.x+SideMargin), (int)((FLTPoint.y+FRTPoint.y)/2), TopWidth-(2*SideMargin), FTopHeight);
				if((FLTPoint.x+SideMargin) <=0          || ((FLTPoint.y+FRTPoint.y)/2)<=0           || TopWidth-(2*SideMargin)<=0          || FTopHeight<=0          )return false;
				if((FLTPoint.x+SideMargin) >=ImageWidth || ((FLTPoint.y+FRTPoint.y)/2)>TopLimitLine || TopWidth-(2*SideMargin)>=ImageWidth || FTopHeight>TopLimitLine) return false;
				if((FLTPoint.x+SideMargin)+(TopWidth-(2*SideMargin)) >=ImageWidth || ((FLTPoint.y+FRTPoint.y)/2)+ FTopHeight>TopLimitLine) return false;
				// Blob 검사 
				CodeImageSelection.Clear();
				CodeImageEncoder.Encode(DefectROI,CodeImage);
				CodeImageSelection.Clear();
				CodeImageSelection.AddObjects(CodeImage);
				// Blob 필터링 
				CodeImageSelection.RemoveUsingFloatFeature  (EFeature_BoundingBoxWidth ,FMinWidth , FMaxWidth  , EDoubleThresholdMode_Outside);
				CodeImageSelection.RemoveUsingFloatFeature  (EFeature_BoundingBoxHeight,FMinHeight, FMaxHeight , EDoubleThresholdMode_Outside);
				CodeImageSelection.RemoveUsingIntegerFeature(EFeature_TopLimit         ,0         , 3          , EDoubleThresholdMode_Outside);

				BlobCount = CodeImageSelection.GetElementCount();
				CodeImageSelection.Sort(EFeature_LeftLimit ,ESortDirection_Ascending);

				if(BlobCount!=0){
					for(int k=0; k<BlobCount; k++){
						if(ACount>=MAX_DEFECT_POINT) break;
						ADefectPoint[ACount].Width  = CodeImageSelection.GetElement(k).GetBoundingBoxWidth() ;
						ADefectPoint[ACount].Height = CodeImageSelection.GetElement(k).GetBoundingBoxHeight();

						ADefectPoint[ACount].Rect.left   =(long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterX() - ADefectPoint[ACount].Width/2 ) +FLTPoint.x+SideMargin      );
						ADefectPoint[ACount].Rect.top    =(long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - ADefectPoint[ACount].Height/2) +((FLTPoint.y+FRTPoint.y)/2));
						ADefectPoint[ACount].Rect.right  =(long)(ADefectPoint[ACount].Rect.left+ ADefectPoint[ACount].Width );
						ADefectPoint[ACount].Rect.bottom =(long)(ADefectPoint[ACount].Rect.top + ADefectPoint[ACount].Height);
						PixelCount = 0;
						PixelValue = 0;

						// 내부 Pixel Data 축출 
						for(int n=ADefectPoint[ACount].Rect.top+1 ; n<ADefectPoint[ACount].Rect.bottom-1; n++){
							for(int m=ADefectPoint[ACount].Rect.left+1; m<ADefectPoint[ACount].Rect.right-1 ; m++){
								PixelValue = IElement(m,n);
								if(PixelValue < EnCapTopThresHold) PixelCount++;
							}
						}

						ADefectPoint[ACount].Round  = PixelCount;
						ADefectPoint[ACount].P.x    =(float)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterX() - ADefectPoint[ACount].Width/2 )+FLTPoint.x+SideMargin      );
						ADefectPoint[ACount].P.y    =(float)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - ADefectPoint[ACount].Height/2)+((FLTPoint.y+FRTPoint.y)/2));

						// Image Rotate 기준 좌표를 다시 Rotate한다 _ Display 목적 
						if(ImgDegree!=0.0f){
							ADefectPoint[ACount].P = Math.OnRotate(CenterPoint, ADefectPoint[ACount].P, (ImgDegree));
						}
						// Image Rotate 기준 좌표를 회전 이후에 ImageHeight값을 더하여 실제 좌표를 산출한다 
						ADefectPoint[ACount].P.y    =(float)(ADefectPoint[ACount].P.y+ImageHeight);

						//Merget위해서 필요함 
						ADefectPoint[ACount].Rect.top    =(long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - ADefectPoint[ACount].Height/2) +((FLTPoint.y+FRTPoint.y)/2)+ImageHeight);
						ADefectPoint[ACount].Rect.bottom =(long)(ADefectPoint[ACount].Rect.top + ADefectPoint[ACount].Height);
						ACount++;
					}
				}
				BlobCount =0;

				//Side B
				////////////////////////////////////////////////////////////////////////////////////////////////
				// 			LogUnit.SetLog("CAP_Side_B_Start_CamId: %d, ImageHeight: %d ",CamId,ImageHeight);     
				// 			DefectROI.SetPlacement((int)(FRTPoint.x-FRightWidth-SideMargin), (int)(FRTPoint.y+Margin), FRightWidth, (RightHeight-(2*Margin)-TopMargin));
				// 			if((FRTPoint.x-FRightWidth-SideMargin) <=0          ||(FRTPoint.y+Margin)<=0           || FRightWidth<=0          || (RightHeight-(2*Margin)-TopMargin)<=0)           return false;
				// 			if((FRTPoint.x-FRightWidth-SideMargin) >=ImageWidth ||(FRTPoint.y+Margin)>TopLimitLine || FRightWidth>=ImageWidth || (RightHeight-(2*Margin)-TopMargin)>TopLimitLine) return false;
				// 			if((FRTPoint.x-FRightWidth-SideMargin)+FRightWidth >=ImageWidth ||((FRTPoint.y+Margin)+(RightHeight-(2*Margin)-TopMargin))>TopLimitLine) return false;

				DefectROI.SetPlacement((int)(FRTPoint.x-FRightWidth-SideMargin), (int)(FRTPoint.y+Margin), FRightWidth, (RightHeight-(2*Margin)-RightDegMargin));
				if((FRTPoint.x-FRightWidth-SideMargin) <=0          ||(FRTPoint.y+Margin)<=0           || FRightWidth<=0          || (RightHeight-(2*Margin)-RightDegMargin)<=0)           return false;
				if((FRTPoint.x-FRightWidth-SideMargin) >=ImageWidth ||(FRTPoint.y+Margin)>TopLimitLine || FRightWidth>=ImageWidth || (RightHeight-(2*Margin)-RightDegMargin)>TopLimitLine) return false;
				if((FRTPoint.x-FRightWidth-SideMargin)+FRightWidth >=ImageWidth ||((FRTPoint.y+Margin)+(RightHeight-(2*Margin)-RightDegMargin))>TopLimitLine) return false;

				//  Blob 검사 진행 
				CodeImageSelection.Clear();
				CodeImageEncoder.Encode(DefectROI,CodeImage);
				CodeImageSelection.Clear();
				CodeImageSelection.AddObjects(CodeImage);
				// Blob 필터링 
				CodeImageSelection.RemoveUsingFloatFeature(EFeature_BoundingBoxWidth ,FMinWidth     , FMaxWidth    , EDoubleThresholdMode_Outside);
				CodeImageSelection.RemoveUsingFloatFeature(EFeature_BoundingBoxHeight,FMinHeight    , FMaxHeight   , EDoubleThresholdMode_Outside);
				// 				CodeImageSelection.RemoveUsingIntegerFeature(EFeature_RightLimit     ,FRightWidth-2 , FRightWidth+1, EDoubleThresholdMode_Outside);
				CodeImageSelection.RemoveUsingIntegerFeature(EFeature_RightLimit     ,FRightWidth-1 , FRightWidth+1, EDoubleThresholdMode_Outside);

				BlobCount = CodeImageSelection.GetElementCount();
				CodeImageSelection.Sort(EFeature_TopLimit,ESortDirection_Ascending);

				if(BlobCount!=0){
					for(int k=0; k<BlobCount; k++){
						if(BCount>=MAX_DEFECT_POINT) break;
						BDefectPoint[BCount].Width  = CodeImageSelection.GetElement(k).GetBoundingBoxWidth() ;
						BDefectPoint[BCount].Height = CodeImageSelection.GetElement(k).GetBoundingBoxHeight();

						BDefectPoint[BCount].Rect.left   = (long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterX() - BDefectPoint[BCount].Width/2 ) +(FRTPoint.x-FRightWidth-SideMargin));
						BDefectPoint[BCount].Rect.top    = (long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - BDefectPoint[BCount].Height/2) +(FRTPoint.y+Margin)                );
						BDefectPoint[BCount].Rect.right  = (long)(BDefectPoint[BCount].Rect.left+ BDefectPoint[BCount].Width );
						BDefectPoint[BCount].Rect.bottom = (long)(BDefectPoint[BCount].Rect.top + BDefectPoint[BCount].Height);
						PixelCount = 0;
						PixelValue = 0;

						// 내부 Pixel Data 축출 
						for(int n=BDefectPoint[BCount].Rect.top+1 ; n<BDefectPoint[BCount].Rect.bottom-1; n++){
							for(int m=BDefectPoint[BCount].Rect.left+1; m<BDefectPoint[BCount].Rect.right-1 ; m++){
								PixelValue = IElement(m,n);
								if(PixelValue < EnCapTopThresHold) PixelCount++;
							}
						}
						BDefectPoint[BCount].Round  = PixelCount;
						BDefectPoint[BCount].P.x    = (float)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterX() - BDefectPoint[BCount].Width/2 ) +(FRTPoint.x-FRightWidth-SideMargin));
						BDefectPoint[BCount].P.y    = (float)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - BDefectPoint[BCount].Height/2) +(FRTPoint.y+Margin)+ImageHeight    );
						BDefectPoint[BCount].Width  = BDefectPoint[BCount].Width+SideMargin; 

						// Merge 위해서 데이터 필요함 
						BDefectPoint[BCount].Rect.top    =(long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - BDefectPoint[BCount].Height/2) + FRTPoint.y+Margin+ImageHeight);
						BDefectPoint[BCount].Rect.bottom =(long)(BDefectPoint[BCount].Rect.top + BDefectPoint[BCount].Height);
						BCount++;
					}
				}
				BlobCount =0;

				// 외곽라인에서 Mark까지의 거리 산출 
				if     (Line[waRightWall].FP0.x >Line[waRightWall].FP1.x) RDistance = ((Line[waRightWall].FP1.x+(Line[waRightWall].FP0.x - Line[waRightWall].FP1.x)/2) - FP1.x);
				else if(Line[waRightWall].FP0.x==Line[waRightWall].FP1.x) RDistance = (Line[waRightWall].FP0.x - FP1.x);
				else                                                      RDistance = ((Line[waRightWall].FP0.x+(Line[waRightWall].FP1.x - Line[waRightWall].FP0.x)/2) - FP1.x);

				// 			MarktoBmLine = (IsMarkBtm) ? 5: 50;  
				// 			if(IsMarkBtm) RDistance = RDistance-MarktoBmLine;
				// 			else          RDistance = RDistance+MarktoBmLine;

				// Side D	
				////////////////////////////////////////////////////////////////////////////////////////////////
				// 			LogUnit.SetLog("CAP_Side_D_Start_CamId: %d, ImageHeight: %d ",CamId,ImageHeight);     
				// 			DefectROI.SetPlacement((int)(FLTPoint.x+SideMargin), (int)(FLTPoint.y+Margin), FLeftWidth, (LeftHeight-(2*Margin)-TopMargin));
				// 			if((FLTPoint.x+SideMargin) <=0          ||(FLTPoint.y+Margin)<=0           || FLeftWidth<=0          || (LeftHeight-(2*Margin)-TopMargin)<=0          ) return false;
				// 			if((FLTPoint.x+SideMargin) >=ImageWidth ||(FLTPoint.y+Margin)>TopLimitLine || FLeftWidth>=ImageWidth || (LeftHeight-(2*Margin)-TopMargin)>TopLimitLine) return false;
				// 			if((FLTPoint.x+SideMargin)+FLeftWidth >=ImageWidth ||(FLTPoint.y+Margin)+(LeftHeight-(2*Margin)-TopMargin)>TopLimitLine) return false;

				DefectROI.SetPlacement((int)(FLTPoint.x+SideMargin), (int)(FLTPoint.y+Margin), FLeftWidth, (LeftHeight-(2*Margin)-LeftDegMargin));
				if((FLTPoint.x+SideMargin) <=0          ||(FLTPoint.y+Margin)<=0           || FLeftWidth<=0          || (LeftHeight-(2*Margin)-LeftDegMargin)<=0          ) return false;
				if((FLTPoint.x+SideMargin) >=ImageWidth ||(FLTPoint.y+Margin)>TopLimitLine || FLeftWidth>=ImageWidth || (LeftHeight-(2*Margin)-LeftDegMargin)>TopLimitLine) return false;
				if((FLTPoint.x+SideMargin)+FLeftWidth >=ImageWidth ||(FLTPoint.y+Margin)+(LeftHeight-(2*Margin)-LeftDegMargin)>TopLimitLine) return false;

				// Blob 검사 진행 
				CodeImageSelection.Clear();
				CodeImageEncoder.Encode(DefectROI,CodeImage);
				CodeImageSelection.Clear();
				CodeImageSelection.AddObjects(CodeImage);

				// Blob 필터링 
				CodeImageSelection.RemoveUsingFloatFeature  (EFeature_BoundingBoxWidth ,FMinWidth , FMaxWidth  , EDoubleThresholdMode_Outside);
				CodeImageSelection.RemoveUsingFloatFeature  (EFeature_BoundingBoxHeight,FMinHeight, FMaxHeight , EDoubleThresholdMode_Outside);
				// 				CodeImageSelection.RemoveUsingIntegerFeature(EFeature_LeftLimit        ,0         , 3          , EDoubleThresholdMode_Outside);
				CodeImageSelection.RemoveUsingIntegerFeature(EFeature_LeftLimit        ,0         , 1          , EDoubleThresholdMode_Outside);

				BlobCount = CodeImageSelection.GetElementCount();
				CodeImageSelection.Sort(EFeature_TopLimit,ESortDirection_Ascending);

				if(BlobCount!=0){
					for(int k=0; k<BlobCount; k++){
						if(DCount>=MAX_DEFECT_POINT) break;
						DDefectPoint[DCount].Width     =  CodeImageSelection.GetElement(k).GetBoundingBoxWidth() ;
						DDefectPoint[DCount].Height    =  CodeImageSelection.GetElement(k).GetBoundingBoxHeight();

						DDefectPoint[DCount].Rect.left   = (long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterX() - DDefectPoint[DCount].Width/2 ) +(FLTPoint.x+SideMargin));
						DDefectPoint[DCount].Rect.top    = (long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - DDefectPoint[DCount].Height/2) +(FLTPoint.y+Margin)    );
						DDefectPoint[DCount].Rect.right  = (long)(DDefectPoint[DCount].Rect.left+ DDefectPoint[DCount].Width );
						DDefectPoint[DCount].Rect.bottom = (long)(DDefectPoint[DCount].Rect.top + DDefectPoint[DCount].Height);

						PixelCount = 0;
						PixelValue = 0;
						// 내부 Pixel Data 축출 
						for(int n=DDefectPoint[DCount].Rect.top+1 ; n<DDefectPoint[DCount].Rect.bottom-1; n++){
							for(int m=DDefectPoint[DCount].Rect.left+1; m<DDefectPoint[DCount].Rect.right-1 ; m++){
								PixelValue = IElement(m,n);
								if(PixelValue < EnCapTopThresHold) PixelCount++;
							}
						}
						// Display 데이터 필요함 
						DDefectPoint[DCount].Round = PixelCount;
						DDefectPoint[DCount].P.x       = (float)(DDefectPoint[DCount].Rect.left);
						DDefectPoint[DCount].P.y       = (float)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - DDefectPoint[DCount].Height/2)+(FLTPoint.y+Margin)+ImageHeight );
						DDefectPoint[DCount].Width     = DDefectPoint[DCount].Width+SideMargin; 

						// Merge 위해서 데이터 필요함 
						DDefectPoint[DCount].Rect.top    =(long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - DDefectPoint[DCount].Height/2) +(FLTPoint.y+Margin)+ImageHeight);
						DDefectPoint[DCount].Rect.bottom =(long)(DDefectPoint[DCount].Rect.top + DDefectPoint[DCount].Height);
						DCount++;
					}
				}
				BlobCount =0;

				// 외곽라인에서 Mark까지의 거리 산출 
				if     (Line[waLeftWall].FP0.x >Line[waLeftWall].FP1.x) LDistance = (FP0.x - (Line[waLeftWall].FP1.x+(Line[waLeftWall].FP0.x - Line[waLeftWall].FP1.x)/2));
				else if(Line[waLeftWall].FP0.x==Line[waLeftWall].FP1.x) LDistance = (FP0.x -  Line[waLeftWall].FP0.x)                                                     ;
				else                                                    LDistance = (FP0.x - (Line[waLeftWall].FP0.x+(Line[waLeftWall].FP1.x - Line[waLeftWall].FP0.x)/2)); 
			}
			else if(IsCircleTop){ // Circle Cutting일경우 Defect검사 진행 
				if(FInspectMode==Insp_Polygon){
					LogUnit.SetLog(L"Polygon_Defect_START");     
					if(A1CirInEdgeCount!=0){    // Polygon Mode 검사에서는 Dx,Dy,R,박리불량 미검사 
						IAddress = DefectImg.GetImagePtr(); // Pixel 정보 추출 목적 

						A1CirDeftectCnt  = GetPolygonSize(A1CirInPoint, A1CirDefectPoint, A1CirInEdgeCount, 50, 5);
						/////////////////////////////////////////////////////////////////////
						// Clipper Algorithm Test End 
						// 박리불량 검사 시퀀스 
						// 					if(!IsMarkBtm && A1CirInCrackCount>0 && BrokenThresHold!=0){
						// 						for(int i=0; i<A1CirInCrackCount; i++){
						// 							A1CircleData[i].Dv  =0.0f;
						// 							A1CircleData[i].Dis =0.0f;
						// 							A1CircleData[i].P.x  = A1CirInCrackPoint[i].x;
						// 							A1CircleData[i].P.y  = A1CirInCrackPoint[i].y;
						// 						}
						// 						IAddress = RotateBrokenImg.GetImagePtr(); // Pixel 정보 추출 목적 
						// 						A1CirCrackCnt  = GetCircleCrackSize(A1CircleData, A1CirCrackPoint, A1CirInCrackCount, 30,CrackACirDiameter1,ACircleFit1Center);
						// 					}
					}

					if(A2CirInEdgeCount!=0){
						IAddress = DefectImg.GetImagePtr(); // Pixel 정보 추출 목적 
						A2CirDeftectCnt  = GetPolygonSize(A2CirInPoint, A2CirDefectPoint, A2CirInEdgeCount, 50, 5);

						// 박리불량 검사 시퀀스 
						// 					if(!IsMarkBtm && A2CirInCrackCount>0 && BrokenThresHold!=0){
						// 						for(int i=0; i<A2CirInCrackCount; i++){
						// 							A2CircleData[i].Dv  =0.0f;
						// 							A2CircleData[i].Dis =0.0f;
						// 							A2CircleData[i].P.x  = A2CirInCrackPoint[i].x;
						// 							A2CircleData[i].P.y  = A2CirInCrackPoint[i].y;
						// 						}
						// 						IAddress = RotateBrokenImg.GetImagePtr(); // Pixel 정보 추출 목적 
						// 						A2CirCrackCnt  = GetCircleCrackSize(A2CircleData, A2CirCrackPoint, A2CirInCrackCount, 20,CrackACirDiameter2,ACircleFit2Center);
						// 					}
					}
					LogUnit.SetLog(L"Polygon_Defect_END");     
				}
				else                          {
					if(A1CirInEdgeCount!=0){
						IAddress = DefectImg.GetImagePtr(); // Pixel 정보 추출 목적 
						MaxDis =0.0f     ;
						MinDis =10000.0f ;
						MaxDv  =0.0f     ;
						MinDv  =10000.0f ;

						CircleCount=0;TotalCirDis=0.0f; AvgCirDis=0.0f;
						for(int k=0; k<A1CirInEdgeCount; k++){
							if(A1CirInPoint[k].x==0 || A1CirInPoint[k].y==0 || k>=MAX_CIRCLE_EDGEPOINT) continue;

							// 					Dis    = Math.GetLengthFrPointToPoint(A1CirCenter,A1CirInPoint[k]);
							Dis    = Math.GetLengthFrPointToPoint(ACircleFit1Center,A1CirInPoint[k]);

							if(Dis>MaxDis) MaxDis = Dis;
							if(Dis<MinDis) MinDis = Dis;

							if(k==0){ // BTM Defect 검사를 위한 좌표값 및 Dx,Dy 산출 
								A1CirDx = Math.GetLengthFrPointToPoint(ACircleFit1Center,A1CirInPoint[k]);
							} 
							if(k==(A1CirInEdgeCount-1)){
								A1CirDy = Math.GetLengthFrPointToPoint(ACircleFit1Center,A1CirInPoint[k]);
							}

							A1CircleData[CircleCount].Dis  = Dis              ;
							A1CircleData[CircleCount].P.x  = A1CirInPoint[k].x;
							A1CircleData[CircleCount].P.y  = A1CirInPoint[k].y;
							CircleCount++   ;
							TotalCirDis+=Dis;
						}
						if(CircleCount!=0 || TotalCirDis!=0){ // Circle AvgRound Cal
							AvgCirDis = (TotalCirDis/CircleCount);
							A1CirRound = AvgCirDis;
						}

						for(int i=0; i<CircleCount; i++){
							// 					A1CircleData[i].Dv = fabs(AvgCirDis - A1CircleData[i].Dis);
							A1CircleData[i].Dv = (ACirFitDiameter1 - A1CircleData[i].Dis) >0 ?(ACirFitDiameter1 - A1CircleData[i].Dis):0;
							if(A1CircleData[i].Dv>MaxDv) MaxDv = A1CircleData[i].Dv;
							if(A1CircleData[i].Dv<MinDv) MinDv = A1CircleData[i].Dv;

						}
						A1CirDeftectCnt  = GetCircleSize(A1CircleData, A1CirDefectPoint, CircleCount, 5);

						// 박리불량 검사 시퀀스 
						if(!IsMarkBtm && A1CirInCrackCount>0 && BrokenThresHold!=0){
							for(int i=0; i<A1CirInCrackCount; i++){
								A1CircleData[i].Dv  =0.0f;
								A1CircleData[i].Dis =0.0f;
								A1CircleData[i].P.x  = A1CirInCrackPoint[i].x;
								A1CircleData[i].P.y  = A1CirInCrackPoint[i].y;
							}
							IAddress = RotateBrokenImg.GetImagePtr(); // Pixel 정보 추출 목적 
							A1CirCrackCnt  = GetCircleCrackSize(A1CircleData, A1CirCrackPoint, A1CirInCrackCount, 30,CrackACirDiameter1,ACircleFit1Center);
						}
					}

					if(A2CirInEdgeCount!=0){
						IAddress = DefectImg.GetImagePtr(); // Pixel 정보 추출 목적 
						MaxDis =0.0f     ;
						MinDis =10000.0f ;
						MaxDv  =0.0f     ;
						MinDv  =10000.0f ;

						CircleCount=0;TotalCirDis=0.0f; AvgCirDis=0.0f;
						for(int k=0; k<A2CirInEdgeCount; k++){
							if(A2CirInPoint[k].x==0 || A2CirInPoint[k].y==0 || k>=MAX_CIRCLE_EDGEPOINT) continue;

							// 					Dis    = Math.GetLengthFrPointToPoint(A2CirCenter,A2CirInPoint[k]);
							Dis    = Math.GetLengthFrPointToPoint(ACircleFit2Center,A2CirInPoint[k]);

							if(Dis>MaxDis) MaxDis = Dis;
							if(Dis<MinDis) MinDis = Dis;

							if(k==0){ // BTM Defect 검사를 위한 좌표값 및 Dx,Dy 산출 
								A2CirDy = Math.GetLengthFrPointToPoint(ACircleFit2Center,A2CirInPoint[k]);
							} 
							if(k==(A2CirInEdgeCount-1)){
								A2CirDx = Math.GetLengthFrPointToPoint(ACircleFit2Center,A2CirInPoint[k]);
							}

							A2CircleData[CircleCount].Dis  = Dis              ;
							A2CircleData[CircleCount].P.x  = A2CirInPoint[k].x;
							A2CircleData[CircleCount].P.y  = A2CirInPoint[k].y;
							CircleCount++   ;
							TotalCirDis+=Dis;
						}
						if(CircleCount!=0 || TotalCirDis!=0){ // Circle AvgRound Cal
							AvgCirDis = (TotalCirDis/CircleCount);
							A2CirRound = AvgCirDis;
						}

						for(int i=0; i<CircleCount; i++){
							// 					A2CircleData[i].Dv = fabs(AvgCirDis - A2CircleData[i].Dis);
							A2CircleData[i].Dv = (ACirFitDiameter2 - A2CircleData[i].Dis) >0 ?(ACirFitDiameter2 - A2CircleData[i].Dis):0;
							if(A2CircleData[i].Dv>MaxDv) MaxDv = A2CircleData[i].Dv;
							if(A2CircleData[i].Dv<MinDv) MinDv = A2CircleData[i].Dv;
						}
						A2CirDeftectCnt  = GetCircleSize(A2CircleData, A2CirDefectPoint, CircleCount, 5);

						// 박리불량 검사 시퀀스 
						if(!IsMarkBtm && A2CirInCrackCount>0 && BrokenThresHold!=0){
							for(int i=0; i<A2CirInCrackCount; i++){
								A2CircleData[i].Dv  =0.0f;
								A2CircleData[i].Dis =0.0f;
								A2CircleData[i].P.x  = A2CirInCrackPoint[i].x;
								A2CircleData[i].P.y  = A2CirInCrackPoint[i].y;
							}
							IAddress = RotateBrokenImg.GetImagePtr(); // Pixel 정보 추출 목적 
							A2CirCrackCnt  = GetCircleCrackSize(A2CircleData, A2CirCrackPoint, A2CirInCrackCount, 20,CrackACirDiameter2,ACircleFit2Center);
						}
					}
				}

				// SIDE A 검사 
				////////////////////////////////////////////////////////////////////////////////////////////////
				DefectROI.SetPlacement((int)(TopEdgePoint[1].x+SideMargin), (int)((TopEdgePoint[1].y+TopEdgePoint[2].y)/2), TopWidth-(2*SideMargin), FTopHeight);
				if((TopEdgePoint[1].x+SideMargin) <=0          || ((TopEdgePoint[1].y+TopEdgePoint[2].y)/2)<=0           || TopWidth-(2*SideMargin)<=0          || FTopHeight<=0          ) return false;
				if((TopEdgePoint[1].x+SideMargin) >=ImageWidth || ((TopEdgePoint[1].y+TopEdgePoint[2].y)/2)>TopLimitLine || TopWidth-(2*SideMargin)>=ImageWidth || FTopHeight>TopLimitLine) return false;
				if((TopEdgePoint[1].x+SideMargin)+(TopWidth-(2*SideMargin)) >=ImageWidth || ((TopEdgePoint[1].y+TopEdgePoint[2].y)/2)+ FTopHeight>TopLimitLine                            ) return false;
				// Blob 검사 
				CodeImageSelection.Clear();
				CodeImageEncoder.Encode(DefectROI,CodeImage);
				CodeImageSelection.Clear();
				CodeImageSelection.AddObjects(CodeImage);
				// Blob 필터링 
				CodeImageSelection.RemoveUsingFloatFeature  (EFeature_BoundingBoxWidth ,FMinWidth , FMaxWidth  , EDoubleThresholdMode_Outside);
				CodeImageSelection.RemoveUsingFloatFeature  (EFeature_BoundingBoxHeight,FMinHeight, FMaxHeight , EDoubleThresholdMode_Outside);
				CodeImageSelection.RemoveUsingIntegerFeature(EFeature_TopLimit         ,0         , 3          , EDoubleThresholdMode_Outside);

				BlobCount = CodeImageSelection.GetElementCount();
				CodeImageSelection.Sort(EFeature_LeftLimit ,ESortDirection_Ascending);

				if(BlobCount!=0){
					for(int k=0; k<BlobCount; k++){
						if(ACount>=MAX_DEFECT_POINT) break;
						ADefectPoint[ACount].Width  = CodeImageSelection.GetElement(k).GetBoundingBoxWidth() ;
						ADefectPoint[ACount].Height = CodeImageSelection.GetElement(k).GetBoundingBoxHeight();

						ADefectPoint[ACount].Rect.left   =(long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterX() - ADefectPoint[ACount].Width/2 ) +(TopEdgePoint[1].x+SideMargin));
						ADefectPoint[ACount].Rect.top    =(long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - ADefectPoint[ACount].Height/2) +((TopEdgePoint[1].y+TopEdgePoint[2].y)/2));
						ADefectPoint[ACount].Rect.right  =(long)(ADefectPoint[ACount].Rect.left+ ADefectPoint[ACount].Width );
						ADefectPoint[ACount].Rect.bottom =(long)(ADefectPoint[ACount].Rect.top + ADefectPoint[ACount].Height);
						PixelCount = 0;
						PixelValue = 0;

						// 내부 Pixel Data 축출 
						for(int n=ADefectPoint[ACount].Rect.top+1 ; n<ADefectPoint[ACount].Rect.bottom-1; n++){
							for(int m=ADefectPoint[ACount].Rect.left+1; m<ADefectPoint[ACount].Rect.right-1 ; m++){
								PixelValue = IElement(m,n);
								if(PixelValue < EnCapTopThresHold) PixelCount++;
							}
						}

						ADefectPoint[ACount].Round  = PixelCount;
						ADefectPoint[ACount].P.x    =(float)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterX() - ADefectPoint[ACount].Width/2 )+(TopEdgePoint[1].x+SideMargin));
						ADefectPoint[ACount].P.y    =(float)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - ADefectPoint[ACount].Height/2)+((TopEdgePoint[1].y+TopEdgePoint[2].y)/2));


						// Image Rotate 기준 좌표를 다시 Rotate한다 _ Display 목적 
						if(ImgDegree!=0.0f){
							ADefectPoint[ACount].P = Math.OnRotate(CenterPoint, ADefectPoint[ACount].P, (ImgDegree));
						}
						// Image Rotate 기준 좌표를 회전 이후에 ImageHeight값을 더하여 실제 좌표를 산출한다 
						ADefectPoint[ACount].P.y    =(float)(ADefectPoint[ACount].P.y+ImageHeight);

						//Merget위해서 필요함 
						ADefectPoint[ACount].Rect.top    =(long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - ADefectPoint[ACount].Height/2) +((TopEdgePoint[1].y+TopEdgePoint[2].y)/2)+ImageHeight);
						ADefectPoint[ACount].Rect.bottom =(long)(ADefectPoint[ACount].Rect.top + ADefectPoint[ACount].Height);
						ACount++;
					}
				}
				BlobCount =0;

				// SIDE B 검사 
				//Side B
				////////////////////////////////////////////////////////////////////////////////////////////////
				// 			LogUnit.SetLog("CAP_Side_B_Start_CamId: %d, ImageHeight: %d ",CamId,ImageHeight);     
				// 			DefectROI.SetPlacement((int)(TopEdgePoint[3].x-FRightWidth-SideMargin), (int)(TopEdgePoint[3].y+Margin), FRightWidth, (RightHeight-(2*Margin)-TopMargin));
				// 			if((TopEdgePoint[3].x-FRightWidth-SideMargin) <=0          ||(TopEdgePoint[3].y+Margin)<=0           || FRightWidth<=0          || (RightHeight-(2*Margin)-TopMargin)<=0)           return false;
				// 			if((TopEdgePoint[3].x-FRightWidth-SideMargin) >=ImageWidth ||(TopEdgePoint[3].y+Margin)>TopLimitLine || FRightWidth>=ImageWidth || (RightHeight-(2*Margin)-TopMargin)>TopLimitLine) return false;
				// 			if((TopEdgePoint[3].x-FRightWidth-SideMargin)+FRightWidth >=ImageWidth ||((TopEdgePoint[3].y+Margin)+(RightHeight-(2*Margin)-TopMargin))>TopLimitLine) return false;

				DefectROI.SetPlacement((int)(TopEdgePoint[3].x-FRightWidth-SideMargin), (int)(TopEdgePoint[3].y+Margin), FRightWidth, (RightHeight-(2*Margin)-RightDegMargin));
				if((TopEdgePoint[3].x-FRightWidth-SideMargin) <=0          ||(TopEdgePoint[3].y+Margin)<=0           || FRightWidth<=0          || (RightHeight-(2*Margin)-RightDegMargin)<=0)           return false;
				if((TopEdgePoint[3].x-FRightWidth-SideMargin) >=ImageWidth ||(TopEdgePoint[3].y+Margin)>TopLimitLine || FRightWidth>=ImageWidth || (RightHeight-(2*Margin)-RightDegMargin)>TopLimitLine) return false;
				if((TopEdgePoint[3].x-FRightWidth-SideMargin)+FRightWidth >=ImageWidth ||((TopEdgePoint[3].y+Margin)+(RightHeight-(2*Margin)-RightDegMargin))>TopLimitLine) return false;

				//  Blob 검사 진행 
				CodeImageSelection.Clear();
				CodeImageEncoder.Encode(DefectROI,CodeImage);
				CodeImageSelection.Clear();
				CodeImageSelection.AddObjects(CodeImage);
				// Blob 필터링 
				CodeImageSelection.RemoveUsingFloatFeature(EFeature_BoundingBoxWidth ,FMinWidth     , FMaxWidth    , EDoubleThresholdMode_Outside);
				CodeImageSelection.RemoveUsingFloatFeature(EFeature_BoundingBoxHeight,FMinHeight    , FMaxHeight   , EDoubleThresholdMode_Outside);
				// 				CodeImageSelection.RemoveUsingIntegerFeature(EFeature_RightLimit     ,FRightWidth-2 , FRightWidth+1, EDoubleThresholdMode_Outside);
				CodeImageSelection.RemoveUsingIntegerFeature(EFeature_RightLimit     ,FRightWidth-1 , FRightWidth+1, EDoubleThresholdMode_Outside);

				BlobCount = CodeImageSelection.GetElementCount();
				CodeImageSelection.Sort(EFeature_TopLimit,ESortDirection_Ascending);

				if(BlobCount!=0){
					for(int k=0; k<BlobCount; k++){
						if(BCount>=MAX_DEFECT_POINT) break;
						BDefectPoint[BCount].Width  = CodeImageSelection.GetElement(k).GetBoundingBoxWidth() ;
						BDefectPoint[BCount].Height = CodeImageSelection.GetElement(k).GetBoundingBoxHeight();

						BDefectPoint[BCount].Rect.left   = (long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterX() - BDefectPoint[BCount].Width/2 ) +(TopEdgePoint[3].x-FRightWidth-SideMargin));
						BDefectPoint[BCount].Rect.top    = (long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - BDefectPoint[BCount].Height/2) +(TopEdgePoint[3].y+Margin)                );
						BDefectPoint[BCount].Rect.right  = (long)(BDefectPoint[BCount].Rect.left+ BDefectPoint[BCount].Width );
						BDefectPoint[BCount].Rect.bottom = (long)(BDefectPoint[BCount].Rect.top + BDefectPoint[BCount].Height);
						PixelCount = 0;
						PixelValue = 0;

						// 내부 Pixel Data 축출 
						for(int n=BDefectPoint[BCount].Rect.top+1 ; n<BDefectPoint[BCount].Rect.bottom-1; n++){
							for(int m=BDefectPoint[BCount].Rect.left+1; m<BDefectPoint[BCount].Rect.right-1 ; m++){
								PixelValue = IElement(m,n);
								if(PixelValue < EnCapTopThresHold) PixelCount++;
							}
						}
						BDefectPoint[BCount].Round  = PixelCount;
						BDefectPoint[BCount].P.x    = (float)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterX() - BDefectPoint[BCount].Width/2 ) +(TopEdgePoint[3].x-FRightWidth-SideMargin));
						BDefectPoint[BCount].P.y    = (float)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - BDefectPoint[BCount].Height/2) +(TopEdgePoint[3].y+Margin)+ImageHeight    );
						BDefectPoint[BCount].Width  = BDefectPoint[BCount].Width+SideMargin; 

						// Merge 위해서 데이터 필요함 
						BDefectPoint[BCount].Rect.top    =(long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - BDefectPoint[BCount].Height/2) + (TopEdgePoint[3].y+Margin)+ImageHeight);
						BDefectPoint[BCount].Rect.bottom =(long)(BDefectPoint[BCount].Rect.top + BDefectPoint[BCount].Height);
						BCount++;
					}
				}
				BlobCount =0;

				// 외곽라인에서 Mark까지의 거리 산출 
				if     (Line[waRightWall].FP0.x >Line[waRightWall].FP1.x) RDistance = ((Line[waRightWall].FP1.x+(Line[waRightWall].FP0.x - Line[waRightWall].FP1.x)/2) - FP1.x);
				else if(Line[waRightWall].FP0.x==Line[waRightWall].FP1.x) RDistance = (Line[waRightWall].FP0.x - FP1.x);
				else                                                      RDistance = ((Line[waRightWall].FP0.x+(Line[waRightWall].FP1.x - Line[waRightWall].FP0.x)/2) - FP1.x);

				// SIDE D 검사 
				////////////////////////////////////////////////////////////////////////////////////////////////
				// 			LogUnit.SetLog("CAP_Side_D_Start_CamId: %d, ImageHeight: %d ",CamId,ImageHeight);     
				// 			DefectROI.SetPlacement((int)(TopEdgePoint[0].x+SideMargin), (int)(TopEdgePoint[0].y+Margin), FLeftWidth, (LeftHeight-(2*Margin)-TopMargin));
				// 			if((TopEdgePoint[0].x+SideMargin) <=0          ||(TopEdgePoint[0].y+Margin)<=0           || FLeftWidth<=0          || (LeftHeight-(2*Margin)-TopMargin)<=0          ) return false;
				// 			if((TopEdgePoint[0].x+SideMargin) >=ImageWidth ||(TopEdgePoint[0].y+Margin)>TopLimitLine || FLeftWidth>=ImageWidth || (LeftHeight-(2*Margin)-TopMargin)>TopLimitLine) return false;
				// 			if((TopEdgePoint[0].x+SideMargin)+FLeftWidth >=ImageWidth ||(TopEdgePoint[0].y+Margin)+(LeftHeight-(2*Margin)-TopMargin)>TopLimitLine) return false;

				DefectROI.SetPlacement((int)(TopEdgePoint[0].x+SideMargin), (int)(TopEdgePoint[0].y+Margin), FLeftWidth, (LeftHeight-(2*Margin)-LeftDegMargin));
				if((TopEdgePoint[0].x+SideMargin) <=0          ||(TopEdgePoint[0].y+Margin)<=0           || FLeftWidth<=0          || (LeftHeight-(2*Margin)-LeftDegMargin)<=0          ) return false;
				if((TopEdgePoint[0].x+SideMargin) >=ImageWidth ||(TopEdgePoint[0].y+Margin)>TopLimitLine || FLeftWidth>=ImageWidth || (LeftHeight-(2*Margin)-LeftDegMargin)>TopLimitLine) return false;
				if((TopEdgePoint[0].x+SideMargin)+FLeftWidth >=ImageWidth ||(TopEdgePoint[0].y+Margin)+(LeftHeight-(2*Margin)-LeftDegMargin)>TopLimitLine) return false;

				// Blob 검사 진행 
				CodeImageSelection.Clear();
				CodeImageEncoder.Encode(DefectROI,CodeImage);
				CodeImageSelection.Clear();
				CodeImageSelection.AddObjects(CodeImage);

				// Blob 필터링 
				CodeImageSelection.RemoveUsingFloatFeature  (EFeature_BoundingBoxWidth ,FMinWidth , FMaxWidth  , EDoubleThresholdMode_Outside);
				CodeImageSelection.RemoveUsingFloatFeature  (EFeature_BoundingBoxHeight,FMinHeight, FMaxHeight , EDoubleThresholdMode_Outside);
				// 				CodeImageSelection.RemoveUsingIntegerFeature(EFeature_LeftLimit        ,0         , 3          , EDoubleThresholdMode_Outside);
				CodeImageSelection.RemoveUsingIntegerFeature(EFeature_LeftLimit        ,0         , 1          , EDoubleThresholdMode_Outside);

				BlobCount = CodeImageSelection.GetElementCount();
				CodeImageSelection.Sort(EFeature_TopLimit,ESortDirection_Ascending);

				if(BlobCount!=0){
					for(int k=0; k<BlobCount; k++){
						if(DCount>=MAX_DEFECT_POINT) break;
						DDefectPoint[DCount].Width     =  CodeImageSelection.GetElement(k).GetBoundingBoxWidth() ;
						DDefectPoint[DCount].Height    =  CodeImageSelection.GetElement(k).GetBoundingBoxHeight();

						DDefectPoint[DCount].Rect.left   = (long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterX() - DDefectPoint[DCount].Width/2 ) +(TopEdgePoint[0].x+SideMargin));
						DDefectPoint[DCount].Rect.top    = (long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - DDefectPoint[DCount].Height/2) +(TopEdgePoint[0].y+Margin)    );
						DDefectPoint[DCount].Rect.right  = (long)(DDefectPoint[DCount].Rect.left+ DDefectPoint[DCount].Width );
						DDefectPoint[DCount].Rect.bottom = (long)(DDefectPoint[DCount].Rect.top + DDefectPoint[DCount].Height);

						PixelCount = 0;
						PixelValue = 0;
						// 내부 Pixel Data 축출 
						for(int n=DDefectPoint[DCount].Rect.top+1 ; n<DDefectPoint[DCount].Rect.bottom-1; n++){
							for(int m=DDefectPoint[DCount].Rect.left+1; m<DDefectPoint[DCount].Rect.right-1 ; m++){
								PixelValue = IElement(m,n);
								if(PixelValue < EnCapTopThresHold) PixelCount++;
							}
						}
						// Display 데이터 필요함 
						DDefectPoint[DCount].Round = PixelCount;
						DDefectPoint[DCount].P.x       = (float)(DDefectPoint[DCount].Rect.left);
						DDefectPoint[DCount].P.y       = (float)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - DDefectPoint[DCount].Height/2)+(TopEdgePoint[0].y+Margin)+ImageHeight );
						DDefectPoint[DCount].Width     = DDefectPoint[DCount].Width+SideMargin; 

						// Merge 위해서 데이터 필요함 
						DDefectPoint[DCount].Rect.top    =(long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - DDefectPoint[DCount].Height/2) +(TopEdgePoint[0].y+Margin)+ImageHeight);
						DDefectPoint[DCount].Rect.bottom =(long)(DDefectPoint[DCount].Rect.top + DDefectPoint[DCount].Height);
						DCount++;
					}
				}
				BlobCount =0;

				// 외곽라인에서 Mark까지의 거리 산출 
				if     (Line[waLeftWall].FP0.x >Line[waLeftWall].FP1.x) LDistance = (FP0.x - (Line[waLeftWall].FP1.x+(Line[waLeftWall].FP0.x - Line[waLeftWall].FP1.x)/2));
				else if(Line[waLeftWall].FP0.x==Line[waLeftWall].FP1.x) LDistance = (FP0.x -  Line[waLeftWall].FP0.x)                                                     ;
				else                                                    LDistance = (FP0.x - (Line[waLeftWall].FP0.x+(Line[waLeftWall].FP1.x - Line[waLeftWall].FP0.x)/2)); 
			}
			// Cell Size 측정 데이터 넘겨줌(Image 회전 없을경우)
			LeftStaPos.x   =  FLTPoint.x            ;
			LeftStaPos.y   =  FLTPoint.y+ImageHeight;
			CenterStaPos.x =  FLTPoint.x + (FRTPoint.x - FLTPoint.x)/2            ; 
			CenterStaPos.y = (FLTPoint.y + FRTPoint.y)              /2+ImageHeight; 
		}

		// FLTPoint,FRTPoint 기준 Image Rotate 적용하여 Display 목적으로 원본이미지 기준 좌표값 복원시킨
		if(ImgDegree!=0.0f){
			// 검사영역 분리과 상관없이 무조건 각도 적용하여 다시 계산해야 하는 좌표값들 
			// TopLine 
			Line[1].FP0 = Math.OnRotate(CenterPoint, Line[1].FP0  , (ImgDegree));
			Line[1].FP1 = Math.OnRotate(CenterPoint, Line[1].FP1  , (ImgDegree));

			// LeftOutLIne 
			LeftOutLine[0].FP0 = Math.OnRotate(CenterPoint, LeftOutLine[0].FP0  , (ImgDegree));
			LeftOutLine[0].FP1 = Math.OnRotate(CenterPoint, LeftOutLine[0].FP1  , (ImgDegree));

			// RightOutLIne 
			RightOutLine[0].FP0 = Math.OnRotate(CenterPoint, RightOutLine[0].FP0  , (ImgDegree));
			RightOutLine[0].FP1 = Math.OnRotate(CenterPoint, RightOutLine[0].FP1  , (ImgDegree));

			FRTPoint    = Math.OnRotate(CenterPoint, FRTPoint     , (ImgDegree));
			FLTPoint    = Math.OnRotate(CenterPoint, FLTPoint     , (ImgDegree));

			// Cell Size 측정 데이터 넘겨줌(Image  회전)
			LeftStaPos.x   =  FLTPoint.x            ;
			LeftStaPos.y   =  FLTPoint.y+ImageHeight;
			CenterStaPos.x =  FLTPoint.x + (FRTPoint.x - FLTPoint.x)/2            ; 
			CenterStaPos.y = (FLTPoint.y + FRTPoint.y)              /2+ImageHeight; 

			if(IsCornerTop){
				FLTTPoint   = Math.OnRotate(CenterPoint, FLTTPoint    , (ImgDegree));
				FLTLPoint   = Math.OnRotate(CenterPoint, FLTLPoint    , (ImgDegree));
				FLTTInPoint = Math.OnRotate(CenterPoint, FLTTInPoint  , (ImgDegree));
				FLTLInPoint = Math.OnRotate(CenterPoint, FLTLInPoint  , (ImgDegree));
				FLTTMeaPoint= Math.OnRotate(CenterPoint, FLTTMeaPoint , (ImgDegree));
				FLTLMeaPoint= Math.OnRotate(CenterPoint, FLTLMeaPoint , (ImgDegree));

				FRTTPoint   = Math.OnRotate(CenterPoint, FRTTPoint    , (ImgDegree));
				FRTRPoint   = Math.OnRotate(CenterPoint, FRTRPoint    , (ImgDegree));
				FRTTInPoint = Math.OnRotate(CenterPoint, FRTTInPoint  , (ImgDegree));
				FRTRInPoint = Math.OnRotate(CenterPoint, FRTRInPoint  , (ImgDegree));
				FRTTMeaPoint= Math.OnRotate(CenterPoint, FRTTMeaPoint , (ImgDegree));
				FRTRMeaPoint= Math.OnRotate(CenterPoint, FRTRMeaPoint , (ImgDegree));

				// Corner Defect 좌표도 각도 적용하여 변경해야함 
				if(C1Count!=0){
					for(int k=0; k<C1Count; k++){
						// Fram기준 Y좌표값으로 원복한다 
						C1DefectPoint[k].P.y = C1DefectPoint[k].P.y - ImageHeight;
						if(C1DefectPoint[k].P.y>0) {
							C1DefectPoint[k].P   = Math.OnRotate(CenterPoint,C1DefectPoint[k].P,(ImgDegree)); 
							C1DefectPoint[k].P.y = C1DefectPoint[k].P.y + ImageHeight;
						}
						else {
							C1DefectPoint[k].P.y = C1DefectPoint[k].P.y + ImageHeight;
						}
					}
				}

				if(C2Count!=0){
					for(int k=0; k<C2Count; k++){
						// Fram기준 Y좌표값으로 원복한다 
						C2DefectPoint[k].P.y = C2DefectPoint[k].P.y - ImageHeight;
						if(C2DefectPoint[k].P.y>0) {
							C2DefectPoint[k].P   = Math.OnRotate(CenterPoint,C2DefectPoint[k].P,(ImgDegree)); 
							C2DefectPoint[k].P.y = C2DefectPoint[k].P.y + ImageHeight;
						}
						else {
							C2DefectPoint[k].P.y = C2DefectPoint[k].P.y + ImageHeight;
						}
					}
				}
			}
			else if(IsCircleTop) { // Display 목적으로 월래 각도 기준으로 좌표값을 다시 회전 시켜야 한다   
				// A영역 Circle_Defect 좌표 이미지 기준 회전함
				if(A1CirDeftectCnt!=0){
					for(int k=0; k<A1CirDeftectCnt; k++){
						A1CirDefectPoint[k].P.y = A1CirDefectPoint[k].P.y - ImageHeight;
						if(A1CirDefectPoint[k].P.y>0) {
							A1CirDefectPoint[k].P   = Math.OnRotate(CenterPoint,A1CirDefectPoint[k].P,(ImgDegree)); 
							A1CirDefectPoint[k].P.y = A1CirDefectPoint[k].P.y + ImageHeight;
						}
						else {
							A1CirDefectPoint[k].P.y = A1CirDefectPoint[k].P.y + ImageHeight;
						}
					}
				}

				if(A2CirDeftectCnt!=0){
					// A영역 Circle_Defect 좌표 이미지 기준 회전함
					for(int k=0; k<A2CirDeftectCnt; k++){
						A2CirDefectPoint[k].P.y = A2CirDefectPoint[k].P.y - ImageHeight;
						if(A2CirDefectPoint[k].P.y>0) {
							A2CirDefectPoint[k].P   = Math.OnRotate(CenterPoint,A2CirDefectPoint[k].P,(ImgDegree)); 
							A2CirDefectPoint[k].P.y = A2CirDefectPoint[k].P.y + ImageHeight;
						}
						else {
							A2CirDefectPoint[k].P.y = A2CirDefectPoint[k].P.y + ImageHeight;
						}
					}
				}

				// Circle Defect Data 
				// Bright Defect Data 
				////////////////////////////////////////////////////////////////////////////////////////////////
				if(A1CirCrackCnt!=0){
					for(int k=0; k<A1CirCrackCnt; k++){
						A1CirCrackPoint[k].P.y = A1CirCrackPoint[k].P.y - ImageHeight;
						if(A1CirCrackPoint[k].P.y>0) {
							A1CirCrackPoint[k].P   = Math.OnRotate(CenterPoint,A1CirCrackPoint[k].P,(ImgDegree)); 
							A1CirCrackPoint[k].P.y = A1CirCrackPoint[k].P.y + ImageHeight;
						}
						else {
							A1CirCrackPoint[k].P.y = A1CirCrackPoint[k].P.y + ImageHeight;
						}
					}
				}

				if(A2CirCrackCnt!=0){
					for(int k=0; k<A2CirCrackCnt; k++){
						A2CirCrackPoint[k].P.y = A2CirCrackPoint[k].P.y - ImageHeight;
						if(A2CirCrackPoint[k].P.y>0) {
							A2CirCrackPoint[k].P   = Math.OnRotate(CenterPoint,A2CirCrackPoint[k].P,(ImgDegree)); 
							A2CirCrackPoint[k].P.y = A2CirCrackPoint[k].P.y + ImageHeight;
						}
						else {
							A2CirCrackPoint[k].P.y = A2CirCrackPoint[k].P.y + ImageHeight;
						}
					}
				}
				//////////////////////////////////////////////////////////////////////////////////////

				if(A1CirInEdgeCount!=0){
					for(int k=0; k<A1CirInEdgeCount; k++){
						if(A1CirInPoint[k].x==0.0f || A1CirInPoint[k].y==0.0f) continue;
						A1CirInPoint[k] = Math.OnRotate(CenterPoint, A1CirInPoint[k], ImgDegree);
					}
				}
				if(A1CirOutEdgeCount!=0){
					for(int k=0; k<A1CirOutEdgeCount; k++){
						if(A1CirOutPoint[k].x==0.0f || A1CirOutPoint[k].y==0.0f) continue;
						A1CirOutPoint[k] = Math.OnRotate(CenterPoint, A1CirOutPoint[k], ImgDegree);
					}
				}
				if(A1CirCenter      .x!=0.0f && A1CirCenter      .y!=0.0f) A1CirCenter        = Math.OnRotate(CenterPoint, A1CirCenter       , (ImgDegree)); // 외곽 교차점 기준  
				if(RealA1CirCenter  .x!=0.0f && RealA1CirCenter  .y!=0.0f) RealA1CirCenter    = Math.OnRotate(CenterPoint, RealA1CirCenter   , (ImgDegree)); // Euresys 
				if(ACircleFit1Center.x!=0.0f && ACircleFit1Center.y!=0.0f) ACircleFit1Center  = Math.OnRotate(CenterPoint, ACircleFit1Center , (ImgDegree)); // FAVION

				if(A2CirInEdgeCount!=0){
					for(int k=0; k<A2CirInEdgeCount; k++){
						if(A2CirInPoint[k].x==0.0f || A2CirInPoint[k].y==0.0f) continue;
						A2CirInPoint[k] = Math.OnRotate(CenterPoint, A2CirInPoint[k], ImgDegree);
					}
				}
				if(A2CirOutEdgeCount!=0){
					for(int k=0; k<A2CirOutEdgeCount; k++){
						if(A2CirOutPoint[k].x==0.0f || A2CirOutPoint[k].y==0.0f) continue;
						A2CirOutPoint[k] = Math.OnRotate(CenterPoint, A2CirOutPoint[k], ImgDegree);
					}
				}
				if(A2CirCenter      .x!=0.0f && A2CirCenter      .y!=0.0f) A2CirCenter        = Math.OnRotate(CenterPoint, A2CirCenter       , (ImgDegree)); // 외곽 교차점 기준  
				if(RealA2CirCenter  .x!=0.0f && RealA2CirCenter  .y!=0.0f) RealA2CirCenter    = Math.OnRotate(CenterPoint, RealA2CirCenter   , (ImgDegree)); // Euresys 
				if(ACircleFit2Center.x!=0.0f && ACircleFit2Center.y!=0.0f) ACircleFit2Center  = Math.OnRotate(CenterPoint, ACircleFit2Center , (ImgDegree)); // FAVION

				// GrindMarkPoint Rotate 
				if(IsMarkBtm){
					for(int k=19; k<27; k++){
						if(GrindMarkPoint[k].x==0.0f || GrindMarkPoint[k].y==0.0f ) continue;
						GrindMarkPoint   [k] = Math.OnRotate(CenterPoint, GrindMarkPoint[k],ImgDegree);
					}
				}
			}
		}
		Index = 0;
		return true;

		// BMDT RectS : 스틱모양
		//------------------------------------------------------------------
	case 14 :

		if(FInspectMode==Insp_Surface){ //표면검사 시퀀스//
			DefectROI.Attach(&DefectImg);
			CodeImageSelection.SetFeretAngle(0.00f);
			CodeImageEncoder.GetGrayscaleSingleThresholdSegmenter().SetWhiteLayerEncoded(true );
			CodeImageEncoder.GetGrayscaleSingleThresholdSegmenter().SetBlackLayerEncoded(false);
			IAddress = DefectImg.GetImagePtr();

			// Side B
			/////////////////////////////////////////////////////////////////////////////////////////////////
			//LogUnit.SetLog("STATIC_Side_B_START_CamId: %d, ImageHeight: %d ",CamId,ImageHeight);     
			DefectROI.SetPlacement((int)(RSP.x-FRightWidth-SideMargin), (int)RSP.y, FRightWidth, RightHeight);
			if((RSP.x-FRightWidth-SideMargin) <=0          ||(RSP.y)<0           || FRightWidth<=0          || RightHeight<0         )return false;
			if((RSP.x-FRightWidth-SideMargin) >=ImageWidth ||(RSP.y)>ImageHeight || FRightWidth>=ImageWidth || RightHeight>ImageHeight)return false;
			if((RSP.x-FRightWidth-SideMargin)+FRightWidth >=ImageWidth ||(RSP.y)+RightHeight>ImageHeight                             )return false;
			//Line Position
			LinePosition = RSP.x-FRightWidth-SideMargin;
			// Blob 검사 진행함 
			CodeImageSelection.Clear();
			CodeImageEncoder.Encode(DefectROI,CodeImage);
			CodeImageSelection.Clear();
			CodeImageSelection.AddObjects(CodeImage);
			// Blob 필터링 
			CodeImageSelection.RemoveUsingFloatFeature  (EFeature_BoundingBoxWidth ,FMinWidth    , FMaxWidth     , EDoubleThresholdMode_Outside);
			CodeImageSelection.RemoveUsingFloatFeature  (EFeature_BoundingBoxHeight,FMinHeight   , FMaxHeight    , EDoubleThresholdMode_Outside);
			CodeImageSelection.RemoveUsingIntegerFeature(EFeature_RightLimit       ,FRightWidth-1, FRightWidth+1 , EDoubleThresholdMode_Inside ); // Range범위에 포함된 데이터 제거함 

			BlobCount = CodeImageSelection.GetElementCount();
			CodeImageSelection.Sort(EFeature_TopLimit,ESortDirection_Ascending);

			if(BlobCount!=0){
				for(int k=0; k<BlobCount; k++){
					if(BCount>=MAX_DEFECT_POINT) break; 
					BDefectPoint[BCount].Width  = CodeImageSelection.GetElement(k).GetBoundingBoxWidth();
					BDefectPoint[BCount].Height = CodeImageSelection.GetElement(k).GetBoundingBoxHeight();

					BDefectPoint[BCount].Rect.left   =(long)(((CodeImageSelection.GetElement(k).GetBoundingBoxCenterX() - BDefectPoint[BCount].Width/2) +LinePosition));
					BDefectPoint[BCount].Rect.top    =(long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - BDefectPoint[BCount].Height/2)               );
					BDefectPoint[BCount].Rect.right  =(long)(BDefectPoint[BCount].Rect.left+ BDefectPoint[BCount].Width );
					BDefectPoint[BCount].Rect.bottom =(long)(BDefectPoint[BCount].Rect.top + BDefectPoint[BCount].Height);

					PixelCount = 0;
					PixelValue = 0;

					// 내부 Pixel Data 축출 
					for(int n=BDefectPoint[BCount].Rect.top+1 ; n<BDefectPoint[BCount].Rect.bottom-1; n++){
						for(int m=BDefectPoint[BCount].Rect.left+1; m<BDefectPoint[BCount].Rect.right-1 ; m++){
							PixelValue = IElement(m,n);
							if(PixelValue > EnCapMidThresHold) PixelCount++;
						}
					}

					BDefectPoint[BCount].Round  = PixelCount;
					BDefectPoint[BCount].P.x    =(float)(BDefectPoint[BCount].Rect.left);
					BDefectPoint[BCount].P.y    =(float)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - BDefectPoint[BCount].Height/2) +ImageHeight );
					BDefectPoint[BCount].Width  = (InspectMode)? BDefectPoint[BCount].Width :BDefectPoint[BCount].Width+SideMargin; 

					// Merge 위해서 데이터 필요함 
					BDefectPoint[BCount].Rect.top    =(long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - BDefectPoint[BCount].Height/2) +ImageHeight);
					BDefectPoint[BCount].Rect.bottom =(long)(BDefectPoint[BCount].Rect.top + BDefectPoint[BCount].Height);
					BCount++;
				}
			}
			BlobCount =0;
			//  		LogUnit.SetLog("STATIC_Side_B_END_CamId: %d, ImageHeight: %d ",CamId,ImageHeight);     
			// 외곽라인에서 Mark까지의 거리 산출 
			// CellSize 
			if     (Line[waRightWall].FP0.x >Line[waRightWall].FP1.x) RDistance = (Line[waRightWall].FP1.x+(Line[waRightWall].FP0.x - Line[waRightWall].FP1.x)/2) - FP1.x;
			else if(Line[waRightWall].FP0.x==Line[waRightWall].FP1.x) RDistance =  Line[waRightWall].FP0.x - FP1.x;
			else                                                      RDistance = (Line[waRightWall].FP0.x+(Line[waRightWall].FP1.x - Line[waRightWall].FP0.x)/2) - FP1.x;

			// SIDE-D
			DefectROI.SetPlacement((int)(LSP.x+SideMargin),(int)LSP.y, FLeftWidth, LeftHeight);
			if((LSP.x+SideMargin) <=0          || (LSP.y)<0           || FLeftWidth<=0          || LeftHeight<0          ) return false;
			if((LSP.x+SideMargin) >=ImageWidth || (LSP.y)>ImageHeight || FLeftWidth>=ImageWidth || LeftHeight>ImageHeight) return false;
			if((LSP.x+SideMargin)+FLeftWidth >=ImageWidth || (LSP.y)+LeftHeight>ImageHeight                              ) return false;
			// Line Position
			LinePosition = LSP.x+SideMargin;
			// Blob 검사 진행 
			CodeImageSelection.Clear();
			CodeImageEncoder.Encode(DefectROI,CodeImage);
			CodeImageSelection.Clear();
			CodeImageSelection.AddObjects(CodeImage);
			// Blob 필터링 
			CodeImageSelection.RemoveUsingFloatFeature  (EFeature_BoundingBoxWidth ,FMinWidth , FMaxWidth  , EDoubleThresholdMode_Outside);
			CodeImageSelection.RemoveUsingFloatFeature  (EFeature_BoundingBoxHeight,FMinHeight, FMaxHeight , EDoubleThresholdMode_Outside);
			CodeImageSelection.RemoveUsingIntegerFeature(EFeature_LeftLimit        ,0         , 2          , EDoubleThresholdMode_Inside ); // Range범위에 포함된 데이터 제거함 

			BlobCount = CodeImageSelection.GetElementCount();
			CodeImageSelection.Sort(EFeature_TopLimit,ESortDirection_Ascending);

			if(BlobCount!=0){
				for(int k=0; k<BlobCount; k++){
					if(DCount>=MAX_DEFECT_POINT) break; 
					DDefectPoint[DCount].Width  = CodeImageSelection.GetElement(k).GetBoundingBoxWidth() ;
					DDefectPoint[DCount].Height = CodeImageSelection.GetElement(k).GetBoundingBoxHeight();

					DDefectPoint[DCount].Rect.left   =(long)(((CodeImageSelection.GetElement(k).GetBoundingBoxCenterX() - DDefectPoint[DCount].Width/2 ) +LinePosition));
					DDefectPoint[DCount].Rect.top    =(long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - DDefectPoint[DCount].Height/2)                );
					DDefectPoint[DCount].Rect.right  =(long)(DDefectPoint[DCount].Rect.left+ DDefectPoint[DCount].Width) ; 
					DDefectPoint[DCount].Rect.bottom =(long)(DDefectPoint[DCount].Rect.top + DDefectPoint[DCount].Height);

					PixelCount =0;
					PixelValue =0;

					// 내부 Pixel Data 축출 
					for(int n=DDefectPoint[DCount].Rect.top+1 ; n<DDefectPoint[DCount].Rect.bottom-1; n++){
						for(int m=DDefectPoint[DCount].Rect.left+1; m<DDefectPoint[DCount].Rect.right-1 ; m++){
							PixelValue = IElement(m,n);
							if(PixelValue > EnCapMidThresHold) PixelCount++;
						}
					}

					DDefectPoint[DCount].Round = PixelCount;
					DDefectPoint[DCount].P.x    =(float)(DDefectPoint[DCount].Rect.left); 
					DDefectPoint[DCount].P.y    =(float)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - DDefectPoint[DCount].Height/2)+ImageHeight  );
					DDefectPoint[DCount].Width  = (InspectMode)? DDefectPoint[DCount].Width :DDefectPoint[DCount].Width+SideMargin; 

					// Merge 위해서 데이터 필요함 
					DDefectPoint[DCount].Rect.top    =(long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - DDefectPoint[DCount].Height/2)+ImageHeight);
					DDefectPoint[DCount].Rect.bottom =(long)(DDefectPoint[DCount].Rect.top + DDefectPoint[DCount].Height);
					DCount++;
				}
			}
			BlobCount =0;
			//  		LogUnit.SetLog("STATIC_Side_D_END_CamId: %d, ImageHeight: %d ",CamId,ImageHeight);     
			// Notch Cell Size Calc
			if(LSP.x!=0.0f  && RSP.x!=0.0f ){
				CenterCellSize = Math.GetLengthFrPointToPoint(LSP,RSP);
				TotalCellSizeWidth+=CenterCellSize;
				TotalCellSizeCount++;
			}
			// 외곽라인에서 Mark까지의 거리 산출 
			// CellSize 
			if     (Line[waLeftWall].FP0.x >Line[waLeftWall].FP1.x) LDistance = FP0.x - (Line[waLeftWall].FP1.x+(Line[waLeftWall].FP0.x - Line[waLeftWall].FP1.x)/2);
			else if(Line[waLeftWall].FP0.x==Line[waLeftWall].FP1.x) LDistance = FP0.x -  Line[waLeftWall].FP0.x;
			else                                                    LDistance = FP0.x - (Line[waLeftWall].FP0.x+(Line[waLeftWall].FP1.x - Line[waLeftWall].FP0.x)/2); 
			////////////////////////////////////////////////////////////////////////////////////////////////
		}
		else             { //외관검사 시퀀스//
			// Side B
			/////////////////////////////////////////////////////////////////////////////////////////////////
			//LogUnit.SetLog("STATIC_Side_B_START_CamId: %d, ImageHeight: %d ",CamId,ImageHeight);     
			DefectROI.SetPlacement((int)(RSP.x-FRightWidth-SideMargin), (int)RSP.y, FRightWidth, RightHeight);
			if((RSP.x-FRightWidth-SideMargin) <=0          ||(RSP.y)<0           || FRightWidth<=0          || RightHeight<0         )return false;
			if((RSP.x-FRightWidth-SideMargin) >=ImageWidth ||(RSP.y)>ImageHeight || FRightWidth>=ImageWidth || RightHeight>ImageHeight)return false;
			if((RSP.x-FRightWidth-SideMargin)+FRightWidth >=ImageWidth ||(RSP.y)+RightHeight>ImageHeight                             )return false;
			//Line Position
			LinePosition = RSP.x-FRightWidth-SideMargin;
			// Blob 검사 진행함 
			CodeImageSelection.Clear();
			CodeImageEncoder.Encode(DefectROI,CodeImage);
			CodeImageSelection.Clear();
			CodeImageSelection.AddObjects(CodeImage);
			// Blob 필터링 
			CodeImageSelection.RemoveUsingFloatFeature  (EFeature_BoundingBoxWidth ,FMinWidth    , FMaxWidth     , EDoubleThresholdMode_Outside);
			CodeImageSelection.RemoveUsingFloatFeature  (EFeature_BoundingBoxHeight,FMinHeight   , FMaxHeight    , EDoubleThresholdMode_Outside);
			CodeImageSelection.RemoveUsingIntegerFeature(EFeature_RightLimit       ,FRightWidth-1, FRightWidth+1 , EDoubleThresholdMode_Outside);

			BlobCount = CodeImageSelection.GetElementCount();
			CodeImageSelection.Sort(EFeature_TopLimit,ESortDirection_Ascending);

			if(BlobCount!=0){
				for(int k=0; k<BlobCount; k++){
					if(BCount>=MAX_DEFECT_POINT) break; 
					BDefectPoint[BCount].Width  = CodeImageSelection.GetElement(k).GetBoundingBoxWidth();
					BDefectPoint[BCount].Height = CodeImageSelection.GetElement(k).GetBoundingBoxHeight();

					BDefectPoint[BCount].Rect.left   =(long)(((CodeImageSelection.GetElement(k).GetBoundingBoxCenterX() - BDefectPoint[BCount].Width/2) +LinePosition));
					BDefectPoint[BCount].Rect.top    =(long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - BDefectPoint[BCount].Height/2)               );
					BDefectPoint[BCount].Rect.right  =(long)(BDefectPoint[BCount].Rect.left+ BDefectPoint[BCount].Width );
					BDefectPoint[BCount].Rect.bottom =(long)(BDefectPoint[BCount].Rect.top + BDefectPoint[BCount].Height);

					PixelCount = 0;
					PixelValue = 0;

					// 내부 Pixel Data 축출 
					for(int n=BDefectPoint[BCount].Rect.top+1 ; n<BDefectPoint[BCount].Rect.bottom-1; n++){
						for(int m=BDefectPoint[BCount].Rect.left+1; m<BDefectPoint[BCount].Rect.right-1 ; m++){
							PixelValue = IElement(m,n);
							if(PixelValue < EnCapMidThresHold) PixelCount++;
						}
					}

					BDefectPoint[BCount].Round  = PixelCount;
					BDefectPoint[BCount].P.x    =(float)(BDefectPoint[BCount].Rect.left);
					BDefectPoint[BCount].P.y    =(float)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - BDefectPoint[BCount].Height/2) +ImageHeight );
					BDefectPoint[BCount].Width  = (InspectMode)? BDefectPoint[BCount].Width :BDefectPoint[BCount].Width+SideMargin; 

					// Merge 위해서 데이터 필요함 
					BDefectPoint[BCount].Rect.top    =(long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - BDefectPoint[BCount].Height/2) +ImageHeight);
					BDefectPoint[BCount].Rect.bottom =(long)(BDefectPoint[BCount].Rect.top + BDefectPoint[BCount].Height);
					BCount++;
				}
			}
			BlobCount =0;
			//  		LogUnit.SetLog("STATIC_Side_B_END_CamId: %d, ImageHeight: %d ",CamId,ImageHeight);     
			// 외곽라인에서 Mark까지의 거리 산출 
			// CellSize 
			if     (Line[waRightWall].FP0.x >Line[waRightWall].FP1.x) RDistance = (Line[waRightWall].FP1.x+(Line[waRightWall].FP0.x - Line[waRightWall].FP1.x)/2) - FP1.x;
			else if(Line[waRightWall].FP0.x==Line[waRightWall].FP1.x) RDistance =  Line[waRightWall].FP0.x - FP1.x;
			else                                                      RDistance = (Line[waRightWall].FP0.x+(Line[waRightWall].FP1.x - Line[waRightWall].FP0.x)/2) - FP1.x;

			// SIDE-D
			DefectROI.SetPlacement((int)(LSP.x+SideMargin),(int)LSP.y, FLeftWidth, LeftHeight);
			if((LSP.x+SideMargin) <=0          || (LSP.y)<0           || FLeftWidth<=0          || LeftHeight<0          ) return false;
			if((LSP.x+SideMargin) >=ImageWidth || (LSP.y)>ImageHeight || FLeftWidth>=ImageWidth || LeftHeight>ImageHeight) return false;
			if((LSP.x+SideMargin)+FLeftWidth >=ImageWidth || (LSP.y)+LeftHeight>ImageHeight                              ) return false;
			// Line Position
			LinePosition = LSP.x+SideMargin;
			// Blob 검사 진행 
			CodeImageSelection.Clear();
			CodeImageEncoder.Encode(DefectROI,CodeImage);
			CodeImageSelection.Clear();
			CodeImageSelection.AddObjects(CodeImage);
			// Blob 필터링 
			CodeImageSelection.RemoveUsingFloatFeature(EFeature_BoundingBoxWidth ,FMinWidth , FMaxWidth  , EDoubleThresholdMode_Outside);
			CodeImageSelection.RemoveUsingFloatFeature(EFeature_BoundingBoxHeight,FMinHeight, FMaxHeight , EDoubleThresholdMode_Outside);
			CodeImageSelection.RemoveUsingIntegerFeature(EFeature_LeftLimit        ,0       , 1          , EDoubleThresholdMode_Outside);

			BlobCount = CodeImageSelection.GetElementCount();
			CodeImageSelection.Sort(EFeature_TopLimit,ESortDirection_Ascending);

			if(BlobCount!=0){
				for(int k=0; k<BlobCount; k++){
					if(DCount>=MAX_DEFECT_POINT) break; 
					DDefectPoint[DCount].Width  = CodeImageSelection.GetElement(k).GetBoundingBoxWidth() ;
					DDefectPoint[DCount].Height = CodeImageSelection.GetElement(k).GetBoundingBoxHeight();

					DDefectPoint[DCount].Rect.left   =(long)(((CodeImageSelection.GetElement(k).GetBoundingBoxCenterX() - DDefectPoint[DCount].Width/2 ) +LinePosition));
					DDefectPoint[DCount].Rect.top    =(long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - DDefectPoint[DCount].Height/2)                );
					DDefectPoint[DCount].Rect.right  =(long)(DDefectPoint[DCount].Rect.left+ DDefectPoint[DCount].Width) ; 
					DDefectPoint[DCount].Rect.bottom =(long)(DDefectPoint[DCount].Rect.top + DDefectPoint[DCount].Height);

					PixelCount =0;
					PixelValue =0;

					// 내부 Pixel Data 축출 
					for(int n=DDefectPoint[DCount].Rect.top+1 ; n<DDefectPoint[DCount].Rect.bottom-1; n++){
						for(int m=DDefectPoint[DCount].Rect.left+1; m<DDefectPoint[DCount].Rect.right-1 ; m++){
							PixelValue = IElement(m,n);
							if(PixelValue < EnCapMidThresHold) PixelCount++;
						}
					}

					DDefectPoint[DCount].Round = PixelCount;
					DDefectPoint[DCount].P.x    =(float)(DDefectPoint[DCount].Rect.left); 
					DDefectPoint[DCount].P.y    =(float)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - DDefectPoint[DCount].Height/2)+ImageHeight  );
					DDefectPoint[DCount].Width  = (InspectMode)? DDefectPoint[DCount].Width :DDefectPoint[DCount].Width+SideMargin; 

					// Merge 위해서 데이터 필요함 
					DDefectPoint[DCount].Rect.top    =(long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - DDefectPoint[DCount].Height/2)+ImageHeight);
					DDefectPoint[DCount].Rect.bottom =(long)(DDefectPoint[DCount].Rect.top + DDefectPoint[DCount].Height);
					DCount++;
				}
			}
			BlobCount =0;
			//  		LogUnit.SetLog("STATIC_Side_D_END_CamId: %d, ImageHeight: %d ",CamId,ImageHeight);     
			// Notch Cell Size Calc
			if(LSP.x!=0.0f  && RSP.x!=0.0f ){
				CenterCellSize = Math.GetLengthFrPointToPoint(LSP,RSP);
				TotalCellSizeWidth+=CenterCellSize;
				TotalCellSizeCount++;
			}
			// 외곽라인에서 Mark까지의 거리 산출 
			// CellSize 
			if     (Line[waLeftWall].FP0.x >Line[waLeftWall].FP1.x) LDistance = FP0.x - (Line[waLeftWall].FP1.x+(Line[waLeftWall].FP0.x - Line[waLeftWall].FP1.x)/2);
			else if(Line[waLeftWall].FP0.x==Line[waLeftWall].FP1.x) LDistance = FP0.x -  Line[waLeftWall].FP0.x;
			else                                                    LDistance = FP0.x - (Line[waLeftWall].FP0.x+(Line[waLeftWall].FP1.x - Line[waLeftWall].FP0.x)/2); 
			////////////////////////////////////////////////////////////////////////////////////////////////

			// Broken 및 박리 불량 검사 시퀀스(EnCap만 진행함)
			if(!IsMarkBtm && BrokenThresHold!=0){
				RotateBrokenImg.SetSize(GImage->GetWidth(), GImage->GetHeight())       ;
				EasyImage::Oper(EArithmeticLogicOperation_Copy,GImage,&RotateBrokenImg);
				EasyImage::Threshold(GImage    ,&RotateBrokenImg, BrokenThresHold)     ;

				DefectROI.Attach(&RotateBrokenImg);
				CodeImageSelection.SetFeretAngle(0.00f);
				CodeImageEncoder.GetGrayscaleSingleThresholdSegmenter().SetWhiteLayerEncoded(true );
				CodeImageEncoder.GetGrayscaleSingleThresholdSegmenter().SetBlackLayerEncoded(false);
				IAddress = RotateBrokenImg.GetImagePtr();

				FRightWidth = 60; // 테스트 목적
				FLeftWidth  = 60; // 테스트 목적

				// Side_B Bright Defect 검출 및 분류(Broken,반원형 박리___꽃박리)
				/////////////////////////////////////////////////////////////////////////////////////////////////
				DefectROI.SetPlacement((int)(RSP.x-FRightWidth-SideMargin), (int)RSP.y, FRightWidth, RightHeight);
				if((RSP.x-FRightWidth-SideMargin) <=0          ||(RSP.y)<0           || FRightWidth<=0          || RightHeight<0          )return false;
				if((RSP.x-FRightWidth-SideMargin) >=ImageWidth ||(RSP.y)>ImageHeight || FRightWidth>=ImageWidth || RightHeight>ImageHeight)return false;
				if((RSP.x-FRightWidth-SideMargin)+FRightWidth >=ImageWidth ||(RSP.y)+RightHeight>ImageHeight                              )return false;
				//Line Position
				LinePosition = RSP.x-FRightWidth-SideMargin;
				// Blob 검사 진행함 
				CodeImageSelection.Clear();
				CodeImageEncoder.Encode(DefectROI,CodeImage);
				CodeImageSelection.Clear();
				CodeImageSelection.AddObjects(CodeImage);
				// Blob 필터링 
				CodeImageSelection.RemoveUsingFloatFeature  (EFeature_BoundingBoxWidth ,FMinWidth    , FMaxWidth     , EDoubleThresholdMode_Outside);
				CodeImageSelection.RemoveUsingFloatFeature  (EFeature_BoundingBoxHeight,FMinHeight   , FMaxHeight    , EDoubleThresholdMode_Outside);
				// 			CodeImageSelection.RemoveUsingIntegerFeature(EFeature_RightLimit       ,FRightWidth-1, FRightWidth+1 , EDoubleThresholdMode_Outside);

				BlobCount = CodeImageSelection.GetElementCount();
				CodeImageSelection.Sort(EFeature_TopLimit,ESortDirection_Ascending);

				if(BlobCount!=0){
					for(int k=0; k<BlobCount; k++){
						if(BCount>=MAX_DEFECT_POINT) break; 
						BCrackPoint[BCrackCount].Width  = CodeImageSelection.GetElement(k).GetBoundingBoxWidth();
						BCrackPoint[BCrackCount].Height = CodeImageSelection.GetElement(k).GetBoundingBoxHeight();

						BCrackPoint[BCrackCount].Rect.left   =(long)(((CodeImageSelection.GetElement(k).GetBoundingBoxCenterX() - BCrackPoint[BCrackCount].Width/2) +LinePosition));
						BCrackPoint[BCrackCount].Rect.top    =(long)(( CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - BCrackPoint[BCrackCount].Height/2)              );
						BCrackPoint[BCrackCount].Rect.right  =(long)(BCrackPoint[BCrackCount].Rect.left+ BCrackPoint[BCrackCount].Width );
						BCrackPoint[BCrackCount].Rect.bottom =(long)(BCrackPoint[BCrackCount].Rect.top + BCrackPoint[BCrackCount].Height);
						BCrackPoint[BCrackCount].LineAttach  =((CodeImageSelection.GetElement(k).GetRightLimit() > (FRightWidth-5))>0)? 1:0; //LineAttach:1 반원형 박리, 0: 꽃박리 

						PixelCount = 0;
						PixelValue = 0;

						// 내부 Pixel Data 축출 
						for(int n=BCrackPoint[BCrackCount].Rect.top+1 ; n<BCrackPoint[BCrackCount].Rect.bottom-1; n++){
							for(int m=BCrackPoint[BCrackCount].Rect.left+1; m<BCrackPoint[BCrackCount].Rect.right-1 ; m++){
								PixelValue = IElement(m,n);
								if(PixelValue > BrokenThresHold) PixelCount++;
							}
						}

						BCrackPoint[BCrackCount].Round  = PixelCount;
						BCrackPoint[BCrackCount].P.x    =(float)(BCrackPoint[BCrackCount].Rect.left);
						BCrackPoint[BCrackCount].P.y    =(float)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - BCrackPoint[BCrackCount].Height/2) +ImageHeight );
						BCrackPoint[BCrackCount].Width  = (InspectMode)? BCrackPoint[BCrackCount].Width :BCrackPoint[BCrackCount].Width+SideMargin; 

						// Merge 위해서 데이터 필요함 
						BCrackPoint[BCrackCount].Rect.top    =(long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - BCrackPoint[BCrackCount].Height/2) +ImageHeight);
						BCrackPoint[BCrackCount].Rect.bottom =(long)(BCrackPoint[BCrackCount].Rect.top + BCrackPoint[BCrackCount].Height);
						BCrackCount++;
					}
				}
				BlobCount =0;

				// Side_D Bright Defect 검출 및 분류(Broken,반원형 박리___꽃박리)
				/////////////////////////////////////////////////////////////////////////////////////////////////
				DefectROI.SetPlacement((int)(LSP.x+SideMargin),(int)LSP.y, FLeftWidth, LeftHeight);
				if((LSP.x+SideMargin) <=0          || (LSP.y)<0           || FLeftWidth<=0          || LeftHeight<0          ) return false;
				if((LSP.x+SideMargin) >=ImageWidth || (LSP.y)>ImageHeight || FLeftWidth>=ImageWidth || LeftHeight>ImageHeight) return false;
				if((LSP.x+SideMargin)+FLeftWidth >=ImageWidth || (LSP.y)+LeftHeight>ImageHeight                              ) return false;
				// Line Position
				LinePosition = LSP.x+SideMargin;
				// Blob 검사 진행 
				CodeImageSelection.Clear();
				CodeImageEncoder.Encode(DefectROI,CodeImage);
				CodeImageSelection.Clear();
				CodeImageSelection.AddObjects(CodeImage);
				// Blob 필터링 
				CodeImageSelection.RemoveUsingFloatFeature(EFeature_BoundingBoxWidth ,FMinWidth , FMaxWidth  , EDoubleThresholdMode_Outside);
				CodeImageSelection.RemoveUsingFloatFeature(EFeature_BoundingBoxHeight,FMinHeight, FMaxHeight , EDoubleThresholdMode_Outside);
				// 			CodeImageSelection.RemoveUsingIntegerFeature(EFeature_LeftLimit        ,0       , 1          , EDoubleThresholdMode_Outside);

				BlobCount = CodeImageSelection.GetElementCount();
				CodeImageSelection.Sort(EFeature_TopLimit,ESortDirection_Ascending);

				if(BlobCount!=0){
					for(int k=0; k<BlobCount; k++){
						if(BCount>=MAX_DEFECT_POINT) break; 
						DCrackPoint[DCrackCount].Width  = CodeImageSelection.GetElement(k).GetBoundingBoxWidth();
						DCrackPoint[DCrackCount].Height = CodeImageSelection.GetElement(k).GetBoundingBoxHeight();

						DCrackPoint[DCrackCount].Rect.left   =(long)(((CodeImageSelection.GetElement(k).GetBoundingBoxCenterX() - DCrackPoint[DCrackCount].Width/2) +LinePosition));
						DCrackPoint[DCrackCount].Rect.top    =(long)(( CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - DCrackPoint[DCrackCount].Height/2)              );
						DCrackPoint[DCrackCount].Rect.right  =(long)(DCrackPoint[DCrackCount].Rect.left+ DCrackPoint[DCrackCount].Width );
						DCrackPoint[DCrackCount].Rect.bottom =(long)(DCrackPoint[DCrackCount].Rect.top + DCrackPoint[DCrackCount].Height);
						DCrackPoint[DCrackCount].LineAttach  =(CodeImageSelection.GetElement(k).GetLeftLimit() < 5)? 1:0; //LineAttach:1 반원형 박리, 0: 꽃박리 

						PixelCount = 0;
						PixelValue = 0;

						// 내부 Pixel Data 축출 
						for(int n=DCrackPoint[DCrackCount].Rect.top+1 ; n<DCrackPoint[DCrackCount].Rect.bottom-1; n++){
							for(int m=DCrackPoint[DCrackCount].Rect.left+1; m<DCrackPoint[DCrackCount].Rect.right-1 ; m++){
								PixelValue = IElement(m,n);
								if(PixelValue > BrokenThresHold) PixelCount++;
							}
						}

						DCrackPoint[DCrackCount].Round  = PixelCount;
						DCrackPoint[DCrackCount].P.x    =(float)(DCrackPoint[DCrackCount].Rect.left);
						DCrackPoint[DCrackCount].P.y    =(float)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - DCrackPoint[DCrackCount].Height/2) +ImageHeight );
						DCrackPoint[DCrackCount].Width  = (InspectMode)? DCrackPoint[DCrackCount].Width :DCrackPoint[DCrackCount].Width+SideMargin; 

						// Merge 위해서 데이터 필요함 
						DCrackPoint[DCrackCount].Rect.top    =(long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - DCrackPoint[DCrackCount].Height/2) +ImageHeight);
						DCrackPoint[DCrackCount].Rect.bottom =(long)(DCrackPoint[DCrackCount].Rect.top + DCrackPoint[DCrackCount].Height);
						DCrackCount++;
					}
				}
				BlobCount =0;
			}
		}
		Index = 0;
		return true;

		// BMDT RectC : 컵모양
		//------------------------------------------------------------------
	case 15 :

		if(FInspectMode==Insp_Surface){ //표면검사 시퀀스//
			DefectROI.Attach(&DefectImg);
			CodeImageSelection.SetFeretAngle(0.00f);
			CodeImageEncoder.GetGrayscaleSingleThresholdSegmenter().SetWhiteLayerEncoded(true );
			CodeImageEncoder.GetGrayscaleSingleThresholdSegmenter().SetBlackLayerEncoded(false);
			IAddress = DefectImg.GetImagePtr();

			//SIDE C
			////////////////////////////////////////////////////////////////////////////////////////////////
			// Btm검사시 오버킬을 줄위기 위해서 
			if(fabs(FLBPoint.y - FRBPoint.y)>3) BTMLine = (FLBPoint.y > FRBPoint.y) ?(int)FRBPoint.y : (int)FLBPoint.y ;
			else                                BTMLine = (FLBPoint.y > FRBPoint.y) ?(int)FLBPoint.y : (int)FRBPoint.y ;

			DefectROI.SetPlacement((int)FLBPoint.x+SideMargin, (int)(BTMLine-FBtmHeight), BtmWidth-(2*SideMargin), FBtmHeight);
			if((FLBPoint.x+SideMargin) <=0          ||(BTMLine-FBtmHeight)<0            || BtmWidth-(2*SideMargin)<=0          || FBtmHeight<0           ) return false;
			if((FLBPoint.x+SideMargin) >=ImageWidth ||(BTMLine-FBtmHeight)>BtmLimitLine || BtmWidth-(2*SideMargin)>=ImageWidth || FBtmHeight>BtmLimitLine) return false;
			if((FLBPoint.x+SideMargin)+(BtmWidth-(2*SideMargin))>=ImageWidth ||(BTMLine-FBtmHeight)+FBtmHeight>BtmLimitLine                              ) return false;

			CodeImageSelection.Clear();
			CodeImageEncoder.Encode(DefectROI,CodeImage);
			CodeImageSelection.Clear();
			CodeImageSelection.AddObjects(CodeImage);
			// Blob 필터링 
			CodeImageSelection.RemoveUsingFloatFeature  (EFeature_BoundingBoxWidth ,FMinWidth                  , FMaxWidth                  , EDoubleThresholdMode_Outside);
			CodeImageSelection.RemoveUsingFloatFeature  (EFeature_BoundingBoxHeight,FMinHeight                 , FMaxHeight                 , EDoubleThresholdMode_Outside);
			CodeImageSelection.RemoveUsingIntegerFeature(EFeature_LeftLimit        ,0                          , 2                          , EDoubleThresholdMode_Inside ); // TOP영역에 붙어있는 데이터 제거 
			CodeImageSelection.RemoveUsingIntegerFeature(EFeature_RightLimit       ,(BtmWidth-(2*SideMargin))-1, (BtmWidth-(2*SideMargin))+1, EDoubleThresholdMode_Inside );
			CodeImageSelection.RemoveUsingIntegerFeature(EFeature_BottomLimit      ,FBtmHeight-1               , FBtmHeight+1               , EDoubleThresholdMode_Inside );

			BlobCount = CodeImageSelection.GetElementCount();
			CodeImageSelection.Sort(EFeature_LeftLimit ,ESortDirection_Ascending);

			if(BlobCount!=0){
				for(int k=0; k<BlobCount; k++){
					if(CCount>=MAX_DEFECT_POINT) break; 
					CDefectPoint[CCount].Width  =  CodeImageSelection.GetElement(k).GetBoundingBoxWidth() ;
					CDefectPoint[CCount].Height =  CodeImageSelection.GetElement(k).GetBoundingBoxHeight();

					CDefectPoint[CCount].Rect.left   =(long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterX() - CDefectPoint[CCount].Width/2 ) +FLBPoint.x+SideMargin);
					// 						CDefectPoint[CCount].Rect.top    =(long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - CDefectPoint[CCount].Height/2) +((FLBBPoint.y+FRBBPoint.y)/2-FBtmHeight-1));
					CDefectPoint[CCount].Rect.top    =(long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - CDefectPoint[CCount].Height/2) +(BTMLine-FBtmHeight));
					CDefectPoint[CCount].Rect.right  =(long)(CDefectPoint[CCount].Rect.left+ CDefectPoint[CCount].Width );
					CDefectPoint[CCount].Rect.bottom =(long)(CDefectPoint[CCount].Rect.top + CDefectPoint[CCount].Height);
					PixelCount = 0;
					PixelValue = 0;

					// 내부 Pixel Data 축출 
					for(int n=CDefectPoint[CCount].Rect.top+1 ; n<CDefectPoint[CCount].Rect.bottom-1; n++){
						for(int m=CDefectPoint[CCount].Rect.left+1; m<CDefectPoint[CCount].Rect.right-1 ; m++){
							PixelValue = IElement(m,n);
							if(PixelValue < EnCapBtmThresHold) PixelCount++;
						}
					}
					CDefectPoint[CCount].Round  =  PixelCount;
					CDefectPoint[CCount].P.x    = (float)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterX() - CDefectPoint[CCount].Width/2 )+FLBPoint.x+SideMargin);
					CDefectPoint[CCount].P.y    = (float)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - CDefectPoint[CCount].Height/2)+(BTMLine-FBtmHeight) );

					if(ImgDegree!=0.0f){
						CDefectPoint[CCount].P = Math.OnRotate(CenterPoint,CDefectPoint[CCount].P, ImgDegree);
					}
					CDefectPoint[CCount].P.y    = (float)(CDefectPoint[CCount].P.y+ImageHeight);

					// Merge 위해서 데이터 필요함 
					// 						CDefectPoint[CCount].Rect.top    =(long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - CDefectPoint[CCount].Height/2) +((FLBBPoint.y+FRBBPoint.y)/2-FBtmHeight-1)+ImageHeight);
					CDefectPoint[CCount].Rect.top    =(long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - CDefectPoint[CCount].Height/2) +(BTMLine-FBtmHeight)+ImageHeight);
					CDefectPoint[CCount].Rect.bottom =(long)(CDefectPoint[CCount].Rect.top + CDefectPoint[CCount].Height);
					CCount++;
				}
			}
			BlobCount =0;

			// 이미지 회전 후 화면 디스플레이 조정 및 Cell_Size 데이터 산출 
			if(ImgDegree!=0.0f){
				FLBPoint    = Math.OnRotate(CenterPoint, FLBPoint     , (ImgDegree));
				FRBPoint    = Math.OnRotate(CenterPoint, FRBPoint     , (ImgDegree));

				// BtmLine 
				Line[3].FP0 = Math.OnRotate(CenterPoint, Line[3].FP0  , (ImgDegree));
				Line[3].FP1 = Math.OnRotate(CenterPoint, Line[3].FP1  , (ImgDegree));

				// LeftOutLine
				LeftOutLine[0].FP0 = Math.OnRotate(CenterPoint, LeftOutLine[0].FP0  , (ImgDegree));
				LeftOutLine[0].FP1 = Math.OnRotate(CenterPoint, LeftOutLine[0].FP1  , (ImgDegree));

				// RightOutLine
				RightOutLine[0].FP0 = Math.OnRotate(CenterPoint, RightOutLine[0].FP0  , (ImgDegree));
				RightOutLine[0].FP1 = Math.OnRotate(CenterPoint, RightOutLine[0].FP1  , (ImgDegree));
			}
		}
		else             { //외관검사 시퀀스//
			if(IsCornerBtm)     { //Corner Cutting 일경우 Defect 검사 시퀀스 
				if(C3InEdgeCount!=0){
					CornerCount=0;
					for(int k=0; k<C3InEdgeCount; k++){
						if(C3InPoint[k].y<FLBLPoint.y-1) continue;
						Dis = Math.GetLengthFrLineToPoint(FLBLInPoint, FLBBInPoint, C3InPoint[k]);
						C3Corner[CornerCount].Dv   = Dis         ;
						C3Corner[CornerCount].P.x  = C3InPoint[k].x;
						C3Corner[CornerCount].P.y  = C3InPoint[k].y;
						CornerCount++;
					}
					C3Count = GetSize(C3Corner, C3DefectPoint, CornerCount, 5);
				}

				if(C4InEdgeCount!=0){
					CornerCount=0;
					for(int k=0; k<C4InEdgeCount; k++){
						if(C4InPoint[k].y<FRBRPoint.y-1) continue;
						Dis = Math.GetLengthFrLineToPoint(FRBRInPoint, FRBBInPoint, C4InPoint[k]);
						C4Corner[CornerCount].Dv   = Dis         ;
						C4Corner[CornerCount].P.x  = C4InPoint[k].x;
						C4Corner[CornerCount].P.y  = C4InPoint[k].y;
						CornerCount++;
					}
					C4Count = GetSize(C4Corner, C4DefectPoint, CornerCount, 5);
				}
				// Side D 
				///////////////////////////////////////////////////////////////////////////////////////////////////////////////
				//LogUnit.SetLog("CUP_Side_D_Start_CamId: %d, ImageHeight: %d ",CamId,ImageHeight);     
				DefectROI.SetPlacement((int)(SP.x+SideMargin),(int)(SP.y+BtmMargin), FLeftWidth, LeftHeight-(2*BtmMargin));
				if((SP.x+SideMargin) <=0          || SP.y+BtmMargin< 0            || FLeftWidth<=0          || LeftHeight-(2*BtmMargin)< 0           ) return false;
				if((SP.x+SideMargin) >=ImageWidth || SP.y+BtmMargin> BtmLimitLine || FLeftWidth>=ImageWidth || LeftHeight-(2*BtmMargin)> BtmLimitLine) return false;
				if((SP.x+SideMargin)+FLeftWidth >=ImageWidth || (SP.y+BtmMargin)+(LeftHeight-(2*BtmMargin))> BtmLimitLine                            ) return false;

				// Line Position 
				LinePosition = SP.x+SideMargin;
				// Blob 검사 진행 
				CodeImageSelection.Clear();
				CodeImageEncoder.Encode(DefectROI,CodeImage);
				CodeImageSelection.Clear();
				CodeImageSelection.AddObjects(CodeImage);
				// Blob 필터링 
				CodeImageSelection.RemoveUsingFloatFeature(EFeature_BoundingBoxWidth ,FMinWidth , FMaxWidth  , EDoubleThresholdMode_Outside);
				CodeImageSelection.RemoveUsingFloatFeature(EFeature_BoundingBoxHeight,FMinHeight, FMaxHeight , EDoubleThresholdMode_Outside);
				// 				CodeImageSelection.RemoveUsingIntegerFeature(EFeature_LeftLimit        ,0       , 3          , EDoubleThresholdMode_Outside);
				CodeImageSelection.RemoveUsingIntegerFeature(EFeature_LeftLimit        ,0       , 1          , EDoubleThresholdMode_Outside);

				BlobCount = CodeImageSelection.GetElementCount();
				CodeImageSelection.Sort(EFeature_TopLimit,ESortDirection_Ascending);

				if(BlobCount!=0){
					for(int k=0; k<BlobCount; k++){
						if(DCount>=MAX_DEFECT_POINT) break;
						DDefectPoint[DCount].Width  =  CodeImageSelection.GetElement(k).GetBoundingBoxWidth() ;
						DDefectPoint[DCount].Height =  CodeImageSelection.GetElement(k).GetBoundingBoxHeight();

						DDefectPoint[DCount].Rect.left   =(long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterX() - DDefectPoint[DCount].Width/2 ) +LinePosition );
						DDefectPoint[DCount].Rect.top    =(long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - DDefectPoint[DCount].Height/2)+(SP.y+BtmMargin));
						DDefectPoint[DCount].Rect.right  =(long)(DDefectPoint[DCount].Rect.left+ DDefectPoint[DCount].Width );
						DDefectPoint[DCount].Rect.bottom =(long)(DDefectPoint[DCount].Rect.top + DDefectPoint[DCount].Height);
						PixelCount =0;
						PixelValue =0;

						// 내부 Pixel Data 축출 
						for(int n=DDefectPoint[DCount].Rect.top+1 ; n<DDefectPoint[DCount].Rect.bottom-1; n++){
							for(int m=DDefectPoint[DCount].Rect.left+1; m<DDefectPoint[DCount].Rect.right-1 ; m++){
								PixelValue = IElement(m,n);
								if(PixelValue < EnCapBtmThresHold) PixelCount++;
							}
						}

						DDefectPoint[DCount].Round = PixelCount;
						DDefectPoint[DCount].P.x    =(float)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterX() - DDefectPoint[DCount].Width/2 ) +LinePosition);
						DDefectPoint[DCount].P.y    =(float)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - DDefectPoint[DCount].Height/2)+(SP.y+BtmMargin)+ImageHeight);
						DDefectPoint[DCount].Width  = (InspectMode)?DDefectPoint[DCount].Width: DDefectPoint[DCount].Width+SideMargin;

						// Merge 위해서 데이터 필요함 
						DDefectPoint[DCount].Rect.top    =(long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - DDefectPoint[DCount].Height/2) +(SP.y+BtmMargin)+ImageHeight);
						DDefectPoint[DCount].Rect.bottom =(long)(DDefectPoint[DCount].Rect.top + DDefectPoint[DCount].Height);
						DCount++;
					}
				}
				BlobCount=0;
				// 외곽라인에서 Mark까지의 거리 산출 
				if     (Line[waLeftWall].FP0.x >Line[waLeftWall].FP1.x) LDistance = FP0.x - (Line[waLeftWall].FP1.x+(Line[waLeftWall].FP0.x - Line[waLeftWall].FP1.x)/2);
				else if(Line[waLeftWall].FP0.x==Line[waLeftWall].FP1.x) LDistance = FP0.x -  Line[waLeftWall].FP0.x;
				else                                                    LDistance = FP0.x - (Line[waLeftWall].FP0.x+(Line[waLeftWall].FP1.x - Line[waLeftWall].FP0.x)/2); 
				////////////////////////////////////////////////////////////////////////////////////////////////


				// Side B
				////////////////////////////////////////////////////////////////////////////////////////////////
				DefectROI.SetPlacement((int)(EP.x-FRightWidth-SideMargin),(int)(EP.y+BtmMargin), FRightWidth,  RightHeight-(2*BtmMargin));
				if((EP.x-FRightWidth-SideMargin) <=0          || (EP.y+BtmMargin)< 0            || FRightWidth<=0           || RightHeight-(2*BtmMargin)< 0           ) return false;
				if((EP.x-FRightWidth-SideMargin) >=ImageWidth || (EP.y+BtmMargin)> BtmLimitLine || FRightWidth>=ImageWidth  || RightHeight-(2*BtmMargin)> BtmLimitLine) return false;
				if((EP.x-FRightWidth-SideMargin)+FRightWidth >=ImageWidth || (EP.y+BtmMargin)+(RightHeight-(2*BtmMargin))> BtmLimitLine                               ) return false;

				// Line Position 
				LinePosition = EP.x - FRightWidth- SideMargin;
				// Blob 검사 진행 
				CodeImageSelection.Clear();
				CodeImageEncoder.Encode(DefectROI,CodeImage);
				CodeImageSelection.Clear();
				CodeImageSelection.AddObjects(CodeImage);
				// Blob 필터링 
				CodeImageSelection.RemoveUsingFloatFeature  (EFeature_BoundingBoxWidth ,FMinWidth               , FMaxWidth                , EDoubleThresholdMode_Outside);
				CodeImageSelection.RemoveUsingFloatFeature  (EFeature_BoundingBoxHeight,FMinHeight              , FMaxHeight               , EDoubleThresholdMode_Outside);
				CodeImageSelection.RemoveUsingIntegerFeature(EFeature_RightLimit     ,FRightWidth -1            , FRightWidth+1            , EDoubleThresholdMode_Outside);

				BlobCount = CodeImageSelection.GetElementCount();
				CodeImageSelection.Sort(EFeature_TopLimit,ESortDirection_Ascending);

				if(BlobCount!=0){
					for(int k=0; k<BlobCount; k++){
						if(BCount>=MAX_DEFECT_POINT) break;
						BDefectPoint[BCount].Width  = CodeImageSelection.GetElement(k).GetBoundingBoxWidth() ; 
						BDefectPoint[BCount].Height = CodeImageSelection.GetElement(k).GetBoundingBoxHeight();

						BDefectPoint[BCount].Rect.left   =(long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterX() - BDefectPoint[BCount].Width/2 ) +(LinePosition)  );
						BDefectPoint[BCount].Rect.top    =(long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - BDefectPoint[BCount].Height/2) +(EP.y+BtmMargin));
						BDefectPoint[BCount].Rect.right  =(long)(BDefectPoint[BCount].Rect.left+ BDefectPoint[BCount].Width );
						BDefectPoint[BCount].Rect.bottom =(long)(BDefectPoint[BCount].Rect.top + BDefectPoint[BCount].Height);
						PixelCount = 0;
						PixelValue = 0;

						// 내부 Pixel Data 축출 
						for(int n=BDefectPoint[BCount].Rect.top+1 ; n<BDefectPoint[BCount].Rect.bottom-1; n++){
							for(int m=BDefectPoint[BCount].Rect.left+1; m<BDefectPoint[BCount].Rect.right-1 ; m++){
								PixelValue = IElement(m,n);
								if(PixelValue < EnCapBtmThresHold) PixelCount++;
							}
						}
						BDefectPoint[BCount].Round  = PixelCount;
						BDefectPoint[BCount].P.x    =(float)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterX() - BDefectPoint[BCount].Width/2 )+(LinePosition));
						BDefectPoint[BCount].P.y    =(float)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - BDefectPoint[BCount].Height/2)+(EP.y+BtmMargin)+ImageHeight   );
						BDefectPoint[BCount].Width  =(InspectMode)? BDefectPoint[BCount].Width: BDefectPoint[BCount].Width+SideMargin;

						// Merge 위해서 데이터 필요함 
						BDefectPoint[BCount].Rect.top    =(long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - BDefectPoint[BCount].Height/2) +(EP.y+BtmMargin)+ImageHeight);
						BDefectPoint[BCount].Rect.bottom =(long)(BDefectPoint[BCount].Rect.top + BDefectPoint[BCount].Height);
						BCount++;
					}
				}
				BlobCount =0;
				// 외곽라인에서 Mark까지의 거리 산출 
				if     (Line[waRightWall].FP0.x >Line[waRightWall].FP1.x) RDistance = (Line[waRightWall].FP1.x+(Line[waRightWall].FP0.x - Line[waRightWall].FP1.x)/2) - FP1.x;
				else if(Line[waRightWall].FP0.x==Line[waRightWall].FP1.x) RDistance =  Line[waRightWall].FP0.x - FP1.x;
				else                                                      RDistance = (Line[waRightWall].FP0.x+(Line[waRightWall].FP1.x - Line[waRightWall].FP0.x)/2) - FP1.x;
				////////////////////////////////////////////////////////////////////////////////////////////////
				// SIDE C 
				// Btm검사시 오버킬을 줄위기 위해서 
				if(fabs(FLBBPoint.y - FRBBPoint.y)>3) BTMLine = (FLBBPoint.y > FRBBPoint.y) ?(int)FRBBPoint.y : (int)FLBBPoint.y ;
				else                                  BTMLine = (FLBBPoint.y > FRBBPoint.y) ?(int)FLBBPoint.y : (int)FRBBPoint.y ;

				DefectROI.SetPlacement((int)FLBBPoint.x+SideMargin, (int)(BTMLine-FBtmHeight), BtmWidth -(2*SideMargin), FBtmHeight);
				if((FLBBPoint.x+SideMargin) <=0          ||(BTMLine-FBtmHeight)< 0            || BtmWidth -(2*SideMargin)<=0          || FBtmHeight< 0           ) return false;
				if((FLBBPoint.x+SideMargin) >=ImageWidth ||(BTMLine-FBtmHeight)> BtmLimitLine || BtmWidth -(2*SideMargin)>=ImageWidth || FBtmHeight> BtmLimitLine) return false;
				if((FLBBPoint.x+SideMargin)+(BtmWidth -(2*SideMargin)) >=ImageWidth ||(BTMLine-FBtmHeight)+FBtmHeight> BtmLimitLine                              ) return false;

				//if(BtmLimitLine!=0){
				//	if(((BtmBMLine[0].FP0.y+BtmBMLine[0].FP1.y)/2+BtmOffset)>BtmLimitLine) return false;
				//}

				CodeImageSelection.Clear();
				CodeImageEncoder.Encode(DefectROI,CodeImage);
				CodeImageSelection.Clear();
				CodeImageSelection.AddObjects(CodeImage);
				// Blob 필터링 
				CodeImageSelection.RemoveUsingFloatFeature  (EFeature_BoundingBoxWidth ,FMinWidth      , FMaxWidth   , EDoubleThresholdMode_Outside);
				CodeImageSelection.RemoveUsingFloatFeature  (EFeature_BoundingBoxHeight,FMinHeight     , FMaxHeight  , EDoubleThresholdMode_Outside);
				CodeImageSelection.RemoveUsingIntegerFeature(EFeature_BottomLimit      ,FBtmHeight-1   , FBtmHeight+1, EDoubleThresholdMode_Outside);


				BlobCount = CodeImageSelection.GetElementCount();
				CodeImageSelection.Sort(EFeature_LeftLimit ,ESortDirection_Ascending);

				if(BlobCount!=0){
					for(int k=0; k<BlobCount; k++){
						if(CCount>=MAX_DEFECT_POINT) break; 
						CDefectPoint[CCount].Width  =  CodeImageSelection.GetElement(k).GetBoundingBoxWidth() ;
						CDefectPoint[CCount].Height =  CodeImageSelection.GetElement(k).GetBoundingBoxHeight();

						CDefectPoint[CCount].Rect.left   =(long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterX() - CDefectPoint[CCount].Width/2 ) +FLBBPoint.x+SideMargin);
						// 						CDefectPoint[CCount].Rect.top    =(long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - CDefectPoint[CCount].Height/2) +((FLBBPoint.y+FRBBPoint.y)/2-FBtmHeight-1));
						CDefectPoint[CCount].Rect.top    =(long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - CDefectPoint[CCount].Height/2) +(BTMLine-FBtmHeight));
						CDefectPoint[CCount].Rect.right  =(long)(CDefectPoint[CCount].Rect.left+ CDefectPoint[CCount].Width );
						CDefectPoint[CCount].Rect.bottom =(long)(CDefectPoint[CCount].Rect.top + CDefectPoint[CCount].Height);
						PixelCount = 0;
						PixelValue = 0;

						// 내부 Pixel Data 축출 
						for(int n=CDefectPoint[CCount].Rect.top+1 ; n<CDefectPoint[CCount].Rect.bottom-1; n++){
							for(int m=CDefectPoint[CCount].Rect.left+1; m<CDefectPoint[CCount].Rect.right-1 ; m++){
								PixelValue = IElement(m,n);
								if(PixelValue < EnCapBtmThresHold) PixelCount++;
							}
						}
						CDefectPoint[CCount].Round  =  PixelCount;
						CDefectPoint[CCount].P.x    = (float)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterX() - CDefectPoint[CCount].Width/2 )+FLBBPoint.x+SideMargin);
						CDefectPoint[CCount].P.y    = (float)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - CDefectPoint[CCount].Height/2)+(BTMLine-FBtmHeight)  );

						if(ImgDegree!=0.0f){
							CDefectPoint[CCount].P = Math.OnRotate(CenterPoint,CDefectPoint[CCount].P, ImgDegree);
						}
						CDefectPoint[CCount].P.y    = (float)(CDefectPoint[CCount].P.y +ImageHeight);

						// Merge 위해서 데이터 필요함 
						// 						CDefectPoint[CCount].Rect.top    =(long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - CDefectPoint[CCount].Height/2) +((FLBBPoint.y+FRBBPoint.y)/2-FBtmHeight-1)+ImageHeight);
						CDefectPoint[CCount].Rect.top    =(long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - CDefectPoint[CCount].Height/2) +(BTMLine-FBtmHeight)+ImageHeight);
						CDefectPoint[CCount].Rect.bottom =(long)(CDefectPoint[CCount].Rect.top + CDefectPoint[CCount].Height);
						CCount++;
					}
				}
				BlobCount =0;
			}
			else if(IsRectBtm)  { //직사각형 경우 Defect 검사 시퀀스 
				// SIDE D 
				////////////////////////////////////////////////////////////////////////////////////////////////
				DefectROI.SetPlacement((int)(SP.x+SideMargin),(int)(SP.y+BtmMargin), FLeftWidth, LeftHeight-(2*BtmMargin));
				if((SP.x+SideMargin) <=0          || (SP.y+BtmMargin)<0            || FLeftWidth<=0          || LeftHeight-(2*BtmMargin)<  0           ) return false;
				if((SP.x+SideMargin) >=ImageWidth || (SP.y+BtmMargin)>BtmLimitLine || FLeftWidth>=ImageWidth || LeftHeight-(2*BtmMargin)>  BtmLimitLine) return false;
				if((SP.x+SideMargin)+FLeftWidth >=ImageWidth || (SP.y+BtmMargin)+(LeftHeight-(2*BtmMargin))> BtmLimitLine                              ) return false;
				// Line Position
				LinePosition = SP.x+SideMargin;

				CodeImageSelection.Clear();
				CodeImageEncoder.Encode(DefectROI,CodeImage);
				CodeImageSelection.Clear();
				CodeImageSelection.AddObjects(CodeImage);
				// Blob 필터링 
				CodeImageSelection.RemoveUsingFloatFeature(EFeature_BoundingBoxWidth ,FMinWidth , FMaxWidth  , EDoubleThresholdMode_Outside);
				CodeImageSelection.RemoveUsingFloatFeature(EFeature_BoundingBoxHeight,FMinHeight, FMaxHeight , EDoubleThresholdMode_Outside);
				// 			CodeImageSelection.RemoveUsingIntegerFeature(EFeature_LeftLimit        ,0       , 3          , EDoubleThresholdMode_Outside);
				CodeImageSelection.RemoveUsingIntegerFeature(EFeature_LeftLimit        ,0       , 2          , EDoubleThresholdMode_Outside);

				BlobCount = CodeImageSelection.GetElementCount();
				CodeImageSelection.Sort(EFeature_TopLimit,ESortDirection_Ascending);

				if(BlobCount!=0){
					for(int k=0; k<BlobCount; k++){
						if(DCount>=MAX_DEFECT_POINT) break; 
						DDefectPoint[DCount].Width  =  CodeImageSelection.GetElement(k).GetBoundingBoxWidth() ;
						DDefectPoint[DCount].Height =  CodeImageSelection.GetElement(k).GetBoundingBoxHeight();

						DDefectPoint[DCount].Rect.left   =(long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterX() - DDefectPoint[DCount].Width/2 ) +LinePosition);
						DDefectPoint[DCount].Rect.top    =(long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - DDefectPoint[DCount].Height/2) +(SP.y+BtmMargin));
						DDefectPoint[DCount].Rect.right  =(long)(DDefectPoint[DCount].Rect.left+ DDefectPoint[DCount].Width );
						DDefectPoint[DCount].Rect.bottom =(long)(DDefectPoint[DCount].Rect.top + DDefectPoint[DCount].Height);
						PixelCount =0;
						PixelValue =0;

						// 내부 Pixel Data 축출 
						for(int n=DDefectPoint[DCount].Rect.top+1 ; n<DDefectPoint[DCount].Rect.bottom-1; n++){
							for(int m=DDefectPoint[DCount].Rect.left+1; m<DDefectPoint[DCount].Rect.right-1 ; m++){
								PixelValue = IElement(m,n);
								if(PixelValue < EnCapBtmThresHold) PixelCount++;
							}
						}

						DDefectPoint[DCount].Round = PixelCount;
						DDefectPoint[DCount].P.x    =(float)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterX() - DDefectPoint[DCount].Width/2 ) +LinePosition   );
						DDefectPoint[DCount].P.y    =(float)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - DDefectPoint[DCount].Height/2)+(SP.y+BtmMargin)+ImageHeight     );

						// Merge 위해서 데이터 필요함 
						DDefectPoint[DCount].Rect.top    =(long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - DDefectPoint[DCount].Height/2) +(SP.y+BtmMargin)+ImageHeight);
						DDefectPoint[DCount].Rect.bottom =(long)(DDefectPoint[DCount].Rect.top + DDefectPoint[DCount].Height);
						DCount++;
					}
				}
				BlobCount=0;
				// 외곽라인에서 Mark까지의 거리 산출 
				//if     (Line[waLeftWall].FP0.x >Line[waLeftWall].FP1.x) LDistance = FP0.x - (Line[waLeftWall].FP1.x+(Line[waLeftWall].FP0.x - Line[waLeftWall].FP1.x)/2);
				//else if(Line[waLeftWall].FP0.x==Line[waLeftWall].FP1.x) LDistance = FP0.x -  Line[waLeftWall].FP0.x;
				//else                                                    LDistance = FP0.x - (Line[waLeftWall].FP0.x+(Line[waLeftWall].FP1.x - Line[waLeftWall].FP0.x)/2); 

				if     (Line[waLeftWall].FP0.x >Line[waLeftWall].FP1.x) LDistance = ((LeftBMLine[0].FP0.x+ LeftBMLine[0].FP1.x)/2) - (Line[waLeftWall].FP1.x+(Line[waLeftWall].FP0.x - Line[waLeftWall].FP1.x)/2);
				else if(Line[waLeftWall].FP0.x==Line[waLeftWall].FP1.x) LDistance = ((LeftBMLine[0].FP0.x+ LeftBMLine[0].FP1.x)/2) -  Line[waLeftWall].FP0.x;
				else                                                    LDistance = ((LeftBMLine[0].FP0.x+ LeftBMLine[0].FP1.x)/2) - (Line[waLeftWall].FP0.x+(Line[waLeftWall].FP1.x - Line[waLeftWall].FP0.x)/2); 
				////////////////////////////////////////////////////////////////////////////////////////////////

				// SIDE B
				////////////////////////////////////////////////////////////////////////////////////////////////
				DefectROI.SetPlacement((int)(EP.x-FRightWidth-SideMargin),(int)(EP.y+BtmMargin), FRightWidth, RightHeight-(2*BtmMargin));
				if((EP.x-FRightWidth-SideMargin) <=0          || (EP.y+BtmMargin)<0            || FRightWidth<=0          || RightHeight-(2*BtmMargin)< 0           ) return false;
				if((EP.x-FRightWidth-SideMargin) >=ImageWidth || (EP.y+BtmMargin)>BtmLimitLine || FRightWidth>=ImageWidth || RightHeight-(2*BtmMargin)> BtmLimitLine) return false;
				if((EP.x-FRightWidth-SideMargin)+FRightWidth >=ImageWidth || (EP.y+BtmMargin)+(RightHeight-(2*BtmMargin))>BtmLimitLine                              ) return false;

				// Line Position
				LinePosition = EP.x-FRightWidth;

				CodeImageSelection.Clear();
				CodeImageEncoder.Encode(DefectROI,CodeImage);
				CodeImageSelection.Clear();
				CodeImageSelection.AddObjects(CodeImage);
				// Blob 필터링 
				CodeImageSelection.RemoveUsingFloatFeature(EFeature_BoundingBoxWidth ,FMinWidth     , FMaxWidth    , EDoubleThresholdMode_Outside);
				CodeImageSelection.RemoveUsingFloatFeature(EFeature_BoundingBoxHeight,FMinHeight    , FMaxHeight   , EDoubleThresholdMode_Outside);
				// 				CodeImageSelection.RemoveUsingIntegerFeature(EFeature_RightLimit     ,FRightWidth-2             , FRightWidth+1            , EDoubleThresholdMode_Outside);
				CodeImageSelection.RemoveUsingIntegerFeature(EFeature_RightLimit     ,FRightWidth-1             , FRightWidth+1            , EDoubleThresholdMode_Outside);

				BlobCount = CodeImageSelection.GetElementCount();
				CodeImageSelection.Sort(EFeature_TopLimit,ESortDirection_Ascending);

				if(BlobCount!=0){
					for(int k=0; k<BlobCount; k++){
						if(BCount>=MAX_DEFECT_POINT) break; 
						BDefectPoint[BCount].Width  = CodeImageSelection.GetElement(k).GetBoundingBoxWidth() ;
						BDefectPoint[BCount].Height = CodeImageSelection.GetElement(k).GetBoundingBoxHeight();

						BDefectPoint[BCount].Rect.left   =(long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterX() - BDefectPoint[BCount].Width/2 ) +(LinePosition));
						BDefectPoint[BCount].Rect.top    =(long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - BDefectPoint[BCount].Height/2) +(EP.y+BtmMargin));
						BDefectPoint[BCount].Rect.right  =(long)(BDefectPoint[BCount].Rect.left+ BDefectPoint[BCount].Width );
						BDefectPoint[BCount].Rect.bottom =(long)(BDefectPoint[BCount].Rect.top + BDefectPoint[BCount].Height);
						PixelCount = 0;
						PixelValue = 0;

						// 내부 Pixel Data 축출 
						for(int n=BDefectPoint[BCount].Rect.top+1 ; n<BDefectPoint[BCount].Rect.bottom-1; n++){
							for(int m=BDefectPoint[BCount].Rect.left+1; m<BDefectPoint[BCount].Rect.right-1 ; m++){
								PixelValue = IElement(m,n);
								if(PixelValue < EnCapBtmThresHold) PixelCount++;
							}
						}
						BDefectPoint[BCount].Round  = PixelCount;
						BDefectPoint[BCount].P.x    =(float)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterX() - BDefectPoint[BCount].Width/2 )+(LinePosition));
						BDefectPoint[BCount].P.y    =(float)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - BDefectPoint[BCount].Height/2)+(EP.y+BtmMargin)+ImageHeight   );

						// Merge 위해서 데이터 필요함 
						BDefectPoint[BCount].Rect.top    =(long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - BDefectPoint[BCount].Height/2) +(EP.y+BtmMargin)+ImageHeight);
						BDefectPoint[BCount].Rect.bottom =(long)(BDefectPoint[BCount].Rect.top + BDefectPoint[BCount].Height);
						BCount++;
					}
				}

				BlobCount =0;
				// 외곽라인에서 Mark까지의 거리 산출 
				//if     (Line[waRightWall].FP0.x >Line[waRightWall].FP1.x) RDistance = (Line[waRightWall].FP1.x+(Line[waRightWall].FP0.x - Line[waRightWall].FP1.x)/2) - FP1.x;
				//else if(Line[waRightWall].FP0.x==Line[waRightWall].FP1.x) RDistance =  Line[waRightWall].FP0.x - FP1.x;
				//else                                                      RDistance = (Line[waRightWall].FP0.x+(Line[waRightWall].FP1.x - Line[waRightWall].FP0.x)/2) - FP1.x;

				if     (Line[waRightWall].FP0.x >Line[waRightWall].FP1.x) RDistance = (Line[waRightWall].FP1.x+(Line[waRightWall].FP0.x - Line[waRightWall].FP1.x)/2) - ((RightBMLine[0].FP0.x+ RightBMLine[0].FP1.x)/2);
				else if(Line[waRightWall].FP0.x==Line[waRightWall].FP1.x) RDistance =  Line[waRightWall].FP0.x                                                        - ((RightBMLine[0].FP0.x+ RightBMLine[0].FP1.x)/2);
				else                                                      RDistance = (Line[waRightWall].FP0.x+(Line[waRightWall].FP1.x - Line[waRightWall].FP0.x)/2) - ((RightBMLine[0].FP0.x+ RightBMLine[0].FP1.x)/2);
				////////////////////////////////////////////////////////////////////////////////////////////////

				//SIDE C
				////////////////////////////////////////////////////////////////////////////////////////////////
				// Btm검사시 오버킬을 줄위기 위해서 
				if(fabs(FLBPoint.y - FRBPoint.y)>3) BTMLine = (FLBPoint.y > FRBPoint.y) ?(int)FRBPoint.y : (int)FLBPoint.y ;
				else                                BTMLine = (FLBPoint.y > FRBPoint.y) ?(int)FLBPoint.y : (int)FRBPoint.y ;

				if(IsMarkBtm){
					DefectROI.SetPlacement((int)FLBPoint.x+SideMargin, (int)(BTMLine-FBtmHeight), BtmWidth-(2*SideMargin), FBtmHeight);
					if((FLBPoint.x+SideMargin) <=0          ||(BTMLine-FBtmHeight)<0            || BtmWidth-(2*SideMargin)<=0          || FBtmHeight<0           ) return false;
					if((FLBPoint.x+SideMargin) >=ImageWidth ||(BTMLine-FBtmHeight)>BtmLimitLine || BtmWidth-(2*SideMargin)>=ImageWidth || FBtmHeight>BtmLimitLine) return false;
					if((FLBPoint.x+SideMargin)+(BtmWidth-(2*SideMargin))>=ImageWidth ||(BTMLine-FBtmHeight)+FBtmHeight>BtmLimitLine                              ) return false;
				}
				else         {
					DefectROI.SetPlacement((int)FLBPoint.x+SideMargin, (int)(BTMLine-FBtmHeight), BtmWidth-(2*SideMargin), FBtmHeight-BtmInspOffset);
					if((FLBPoint.x+SideMargin) <=0          ||(BTMLine-FBtmHeight)<0            || BtmWidth-(2*SideMargin)<=0          || FBtmHeight-BtmInspOffset<0           ) return false;
					if((FLBPoint.x+SideMargin) >=ImageWidth ||(BTMLine-FBtmHeight)>BtmLimitLine || BtmWidth-(2*SideMargin)>=ImageWidth || FBtmHeight-BtmInspOffset>BtmLimitLine) return false;
					if((FLBPoint.x+SideMargin)+(BtmWidth-(2*SideMargin))>=ImageWidth ||(BTMLine-FBtmHeight)+FBtmHeight-BtmInspOffset>BtmLimitLine                              ) return false;
				}

				CodeImageSelection.Clear();
				CodeImageEncoder.Encode(DefectROI,CodeImage);
				CodeImageSelection.Clear();
				CodeImageSelection.AddObjects(CodeImage);
				// Blob 필터링 
				CodeImageSelection.RemoveUsingFloatFeature  (EFeature_BoundingBoxWidth ,FMinWidth      , FMaxWidth   , EDoubleThresholdMode_Outside);
				CodeImageSelection.RemoveUsingFloatFeature  (EFeature_BoundingBoxHeight,FMinHeight     , FMaxHeight  , EDoubleThresholdMode_Outside);
				if(IsMarkBtm) CodeImageSelection.RemoveUsingIntegerFeature(EFeature_BottomLimit      ,FBtmHeight-1                 , FBtmHeight+1              , EDoubleThresholdMode_Outside);
				else          CodeImageSelection.RemoveUsingIntegerFeature(EFeature_BottomLimit      ,FBtmHeight-BtmInspOffset-1   , FBtmHeight-BtmInspOffset+1, EDoubleThresholdMode_Outside);


				BlobCount = CodeImageSelection.GetElementCount();
				CodeImageSelection.Sort(EFeature_LeftLimit ,ESortDirection_Ascending);

				if(BlobCount!=0){
					for(int k=0; k<BlobCount; k++){
						if(CCount>=MAX_DEFECT_POINT) break; 
						CDefectPoint[CCount].Width  =  CodeImageSelection.GetElement(k).GetBoundingBoxWidth() ;
						CDefectPoint[CCount].Height =  CodeImageSelection.GetElement(k).GetBoundingBoxHeight();

						CDefectPoint[CCount].Rect.left   =(long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterX() - CDefectPoint[CCount].Width/2 ) +FLBPoint.x+SideMargin);
						// 						CDefectPoint[CCount].Rect.top    =(long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - CDefectPoint[CCount].Height/2) +((FLBBPoint.y+FRBBPoint.y)/2-FBtmHeight-1));
						CDefectPoint[CCount].Rect.top    =(long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - CDefectPoint[CCount].Height/2) +(BTMLine-FBtmHeight));
						CDefectPoint[CCount].Rect.right  =(long)(CDefectPoint[CCount].Rect.left+ CDefectPoint[CCount].Width );
						CDefectPoint[CCount].Rect.bottom =(long)(CDefectPoint[CCount].Rect.top + CDefectPoint[CCount].Height);
						PixelCount = 0;
						PixelValue = 0;

						// 내부 Pixel Data 축출 
						for(int n=CDefectPoint[CCount].Rect.top+1 ; n<CDefectPoint[CCount].Rect.bottom-1; n++){
							for(int m=CDefectPoint[CCount].Rect.left+1; m<CDefectPoint[CCount].Rect.right-1 ; m++){
								PixelValue = IElement(m,n);
								if(PixelValue < EnCapBtmThresHold) PixelCount++;
							}
						}
						CDefectPoint[CCount].Round  =  PixelCount;
						CDefectPoint[CCount].P.x    = (float)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterX() - CDefectPoint[CCount].Width/2 )+FLBPoint.x+SideMargin);
						CDefectPoint[CCount].P.y    = (float)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - CDefectPoint[CCount].Height/2)+(BTMLine-FBtmHeight) );

						if(ImgDegree!=0.0f){
							CDefectPoint[CCount].P = Math.OnRotate(CenterPoint,CDefectPoint[CCount].P, ImgDegree);
						}
						CDefectPoint[CCount].P.y    = (float)(CDefectPoint[CCount].P.y+ImageHeight);

						// Merge 위해서 데이터 필요함 
						// 						CDefectPoint[CCount].Rect.top    =(long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - CDefectPoint[CCount].Height/2) +((FLBBPoint.y+FRBBPoint.y)/2-FBtmHeight-1)+ImageHeight);
						CDefectPoint[CCount].Rect.top    =(long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - CDefectPoint[CCount].Height/2) +(BTMLine-FBtmHeight)+ImageHeight);
						CDefectPoint[CCount].Rect.bottom =(long)(CDefectPoint[CCount].Rect.top + CDefectPoint[CCount].Height);
						CCount++;
					}
				}
				BlobCount =0;
				////////////////////////////////////////////////////////////////////////////////////////////////
			}
			else if(IsCircleBtm){ //Circle Cutting일경우 Defect 검사 시퀀스 
				if(C1CirInEdgeCount!=0){
					IAddress = DefectImg.GetImagePtr(); // Pixel 정보 추출 목적 
					MaxDis =0.0f        ;
					MinDis =10000.0f    ;
					MaxDv  =0.0f        ;
					MinDv  =10000.0f    ;
					StdMaxDis =0.0f     ;
					StdMinDis =10000.0f ;
					MinCirCount =0      ;
					// 삼항 연산자 최소값 구하기  
					if      (FInspectMode==Insp_Track) MinCirCount = (C1CirInEdgeCount<C1CirOutEdgeCount)?(C1CirInEdgeCount<C1CirStandEdgeCount)?C1CirInEdgeCount:C1CirStandEdgeCount:(C1CirOutEdgeCount<C1CirStandEdgeCount)?C1CirOutEdgeCount:C1CirStandEdgeCount;
					else if (FInspectMode==Insp_Mark ) MinCirCount = C1CirInEdgeCount;

					CircleCount=0;TotalCirDis=0.0f; AvgCirDis=0.0f;
					for(int k=0; k<MinCirCount; k++){
						if(FInspectMode==Insp_Track){ // TrackMode 
							if(C1CirInPoint[k].x==0    || C1CirInPoint[k].y==0    || k>=MAX_CIRCLE_EDGEPOINT) continue;
							if(C1CirStandPoint[k].x==0 || C1CirStandPoint[k].y==0 || k>=MAX_CIRCLE_EDGEPOINT) continue;

							if(IsMarkBtm){ // RealC1CirCneter값은 TrackLine EdgePoint기준 Circle_Fitting 결과물 
								Dis    = Math.GetLengthFrPointToPoint(RealC1CirCenter,C1CirInPoint[k]   );
								StdDis = Math.GetLengthFrPointToPoint(RealC1CirCenter,C1CirStandPoint[k]);
							}
							else {        // TrackLine 교차점 기준 센터 
								Dis    = Math.GetLengthFrPointToPoint(TrackC1CirCenter,C1CirInPoint[k]   );
							}

							if(Dis>MaxDis) MaxDis = Dis;
							if(Dis<MinDis) MinDis = Dis;

							if(StdDis>StdMaxDis) StdMaxDis = StdDis;
							if(StdDis<StdMinDis) StdMinDis = StdDis;

							if(k==0){ // BTM Defect 검사를 위한 좌표값 및 Dx,Dy 산출 
								if(IsMarkBtm){ 					
									C1CirDy = Math.GetLengthFrPointToPoint(TrackC1CirCenter,C1CirInPoint[k]);
								}
								else {
									C1CirDy = Math.GetLengthFrPointToPoint(TrackC1CirCenter,C1CirInPoint[k]);
								}
							} 
							if(k==(C1CirInEdgeCount-1)){
								if(IsMarkBtm){ 					
									C1CirDx = Math.GetLengthFrPointToPoint(TrackC1CirCenter,C1CirInPoint[k]);
								}
								else {
									C1CirDx = Math.GetLengthFrPointToPoint(TrackC1CirCenter,C1CirInPoint[k]);
								}
							}
						}
						else if(FInspectMode==Insp_Mark){ // MarkMode 
							if(C1CirInPoint[k].x==0    || C1CirInPoint[k].y==0    || k>=MAX_CIRCLE_EDGEPOINT) continue;

							if(IsMarkBtm){ // RealC1CirCneter값은 연마안쪽 EdgePoint기준 Circle_Fitting 결과물 
								// 							Dis    = Math.GetLengthFrPointToPoint(RealC1CirCenter,C1CirInPoint[k] ); // Euresys Circle Fitting
								Dis = Math.GetLengthFrPointToPoint(CircleFit1Center,C1CirInPoint[k]   ); // FAVION  Circle Fitting 
							}
							else {
								Dis    = Math.GetLengthFrPointToPoint(CircleFit1Center,C1CirInPoint[k]   );
							}

							if(Dis>MaxDis) MaxDis = Dis;
							if(Dis<MinDis) MinDis = Dis;

							if(k==0){ // BTM Defect 검사를 위한 좌표값 및 Dx,Dy 산출 
								// 						    C1CirDy = Math.GetLengthFrPointToPoint(RealC1CirCenter,C1CirInPoint[k]);
								C1CirDy = Math.GetLengthFrPointToPoint(CircleFit1Center,C1CirInPoint[k]);
							} 
							if(k==(C1CirInEdgeCount-1)){
								// 						    C1CirDx = Math.GetLengthFrPointToPoint(RealC1CirCenter,C1CirInPoint[k]);
								C1CirDx = Math.GetLengthFrPointToPoint(CircleFit1Center,C1CirInPoint[k]);
							}
						}
						//Data 취합 
						C1CircleData[CircleCount].Dis  = Dis              ; 
						C1CircleData[CircleCount].P.x  = C1CirInPoint[k].x;
						C1CircleData[CircleCount].P.y  = C1CirInPoint[k].y;
						CircleCount++   ;
						TotalCirDis+=Dis;
					}

					if(CircleCount!=0 || TotalCirDis!=0){ // Circle AvgRound Cal
						AvgCirDis = (TotalCirDis/CircleCount);
						C1CirRound = AvgCirDis;
					}

					for(int i=0; i<CircleCount; i++){
						// 					C1CircleData[i].Dv = fabs(AvgCirDis - C1CircleData[i].Dis); // Avg EdgePoint 기준 편차값 
						C1CircleData[i].Dv = (CirFitDiameter1 - C1CircleData[i].Dis) >0 ?(CirFitDiameter1 - C1CircleData[i].Dis):0;
						if(C1CircleData[i].Dv>MaxDv) MaxDv = C1CircleData[i].Dv;
						if(C1CircleData[i].Dv<MinDv) MinDv = C1CircleData[i].Dv;
					}
					C1CirDeftectCnt  = GetCircleSize(C1CircleData, C1CirDefectPoint, CircleCount, 5);

					// 박리불량 검사 시퀀스 
					if(!IsMarkBtm && C1CirInCrackCount>0 && BrokenThresHold!=0){
						for(int i=0; i<C1CirInCrackCount; i++){
							C1CircleData[i].Dv  =0.0f;
							C1CircleData[i].Dis =0.0f;
							C1CircleData[i].P.x  = C1CirInCrackPoint[i].x;
							C1CircleData[i].P.y  = C1CirInCrackPoint[i].y;
						}
						IAddress = RotateBrokenImg.GetImagePtr(); // Pixel 정보 추출 목적 
						C1CirCrackCnt  = GetCircleCrackSize(C1CircleData, C1CirCrackPoint, C1CirInCrackCount, 30, CrackCirDiameter1,CircleFit1Center);
					}
				}

				// C2Circle Calculate 
				if(C2CirInEdgeCount!=0){
					IAddress = DefectImg.GetImagePtr(); // Pixel 정보 추출 목적 
					MaxDis =0.0f     ;
					MinDis =10000.0f ;
					MaxDv  =0.0f     ;
					MinDv  =10000.0f ;
					StdMaxDis =0.0f     ;
					StdMinDis =10000.0f ;
					MinCirCount =0      ;
					// 삼항 연산자 최소값 구하기  

					if      (FInspectMode==Insp_Track) MinCirCount = (C2CirInEdgeCount<C2CirOutEdgeCount)?(C2CirInEdgeCount<C2CirStandEdgeCount)?C2CirInEdgeCount:C2CirStandEdgeCount:(C2CirOutEdgeCount<C2CirStandEdgeCount)?C2CirOutEdgeCount:C2CirStandEdgeCount;
					else if (FInspectMode==Insp_Mark ) MinCirCount =  C2CirInEdgeCount;

					CircleCount=0;TotalCirDis=0.0f; AvgCirDis=0.0f;
					for(int k=0; k<MinCirCount; k++){
						if(FInspectMode==Insp_Track){ // TrackMode 
							if(C2CirInPoint[k].x==0    || C2CirInPoint[k].y==0    || k>=MAX_CIRCLE_EDGEPOINT) continue;
							if(C2CirStandPoint[k].x==0 || C2CirStandPoint[k].y==0 || k>=MAX_CIRCLE_EDGEPOINT) continue;

							if(IsMarkBtm){ // RealC2CirCneter값은 TrackLine EdgePoint기준 Circle_Fitting 결과물 
								Dis    = Math.GetLengthFrPointToPoint(RealC2CirCenter,C2CirInPoint[k]   );
								StdDis = Math.GetLengthFrPointToPoint(RealC2CirCenter,C2CirStandPoint[k]);
							}
							else {         // TrackLine 교차점 기준 센터 
								Dis    = Math.GetLengthFrPointToPoint(TrackC2CirCenter,C2CirInPoint[k]   );
							}

							if(Dis>MaxDis) MaxDis = Dis;
							if(Dis<MinDis) MinDis = Dis;
							if(StdDis>StdMaxDis) StdMaxDis = StdDis;
							if(StdDis<StdMinDis) StdMinDis = StdDis;

							if(k==0){ // BTM Defect 검사를 위한 좌표값 및 Dx,Dy 산출 
								if(IsMarkBtm){ 					
									C2CirDx = Math.GetLengthFrPointToPoint(TrackC2CirCenter,C2CirInPoint[k]);
								}
								else {
									C2CirDx = Math.GetLengthFrPointToPoint(TrackC2CirCenter,C2CirInPoint[k]);
								}
							} 
							if(k==(C2CirInEdgeCount-1)) {
								if(IsMarkBtm){ 					
									C2CirDy = Math.GetLengthFrPointToPoint(TrackC2CirCenter,C2CirInPoint[k]);
								}
								else {
									C2CirDy = Math.GetLengthFrPointToPoint(TrackC2CirCenter,C2CirInPoint[k]);
								}
							}
						}
						else if(FInspectMode==Insp_Mark){ // MarkMode 
							if(C2CirInPoint[k].x==0    || C2CirInPoint[k].y==0    || k>=MAX_CIRCLE_EDGEPOINT) continue;

							if(IsMarkBtm){ // RealC2CirCneter값은 연마안쪽 EdgePoint기준 Circle_Fitting 결과물 
								// 							Dis    = Math.GetLengthFrPointToPoint(RealC2CirCenter,C2CirInPoint[k]   );
								Dis = Math.GetLengthFrPointToPoint(CircleFit2Center,C2CirInPoint[k]     );
								// 							Dis    = Math.GetLengthFrPointToPoint(C2CirCenter,C2CirInPoint[k]   );
							}
							else {         // RealC2CirCneter값은 연마안쪽 EdgePoint기준 Circle_Fitting 결과물 
								Dis    = Math.GetLengthFrPointToPoint(CircleFit2Center,C2CirInPoint[k]   );
							}

							if(Dis>MaxDis) MaxDis = Dis;
							if(Dis<MinDis) MinDis = Dis;

							if(k==0){ // BTM Defect 검사를 위한 좌표값 및 Dx,Dy 산출 
								// 						    C2CirDx = Math.GetLengthFrPointToPoint(RealC2CirCenter,C2CirInPoint[k]);
								C2CirDx = Math.GetLengthFrPointToPoint(CircleFit2Center,C2CirInPoint[k]);
							} 
							if(k==(C2CirInEdgeCount-1)) {
								// 							C2CirDy = Math.GetLengthFrPointToPoint(RealC2CirCenter,C2CirInPoint[k]);
								C2CirDy = Math.GetLengthFrPointToPoint(CircleFit2Center,C2CirInPoint[k]);
							}
						}

						C2CircleData[CircleCount].Dis  = Dis              ; // FAVION  Circle Fitting 
						C2CircleData[CircleCount].P.x  = C2CirInPoint[k].x;
						C2CircleData[CircleCount].P.y  = C2CirInPoint[k].y;
						CircleCount++   ;
						TotalCirDis+=Dis;
					}
					if(CircleCount!=0 || TotalCirDis!=0){ // Circle AvgRound Cal
						AvgCirDis = (TotalCirDis/CircleCount);
						C2CirRound = AvgCirDis;
					}

					for(int i=0; i<CircleCount; i++){
						// 					C2CircleData[i].Dv = fabs(AvgCirDis - C2CircleData[i].Dis);      // Euresys Circle Fitting 
						C2CircleData[i].Dv = (CirFitDiameter2 - C2CircleData[i].Dis) >0 ?(CirFitDiameter2 - C2CircleData[i].Dis):0;
						if(C2CircleData[i].Dv>MaxDv) MaxDv = C2CircleData[i].Dv;
						if(C2CircleData[i].Dv<MinDv) MinDv = C2CircleData[i].Dv;
					}
					C2CirDeftectCnt  = GetCircleSize(C2CircleData, C2CirDefectPoint, CircleCount, 5);

					if(!IsMarkBtm && C2CirInCrackCount>0 && BrokenThresHold!=0){
						for(int i=0; i<C2CirInCrackCount; i++){
							C2CircleData[i].Dv  =0.0f;
							C2CircleData[i].Dis =0.0f;
							C2CircleData[i].P.x  = C2CirInCrackPoint[i].x;
							C2CircleData[i].P.y  = C2CirInCrackPoint[i].y;
						}
						IAddress = RotateBrokenImg.GetImagePtr(); // Pixel 정보 추출 목적 
						C2CirCrackCnt  = GetCircleCrackSize(C2CircleData, C2CirCrackPoint, C2CirInCrackCount, 30, CrackCirDiameter2,CircleFit2Center);
					}
				}

				// C3Circle Calculate 
				if(C3CirInEdgeCount!=0){
					IAddress = DefectImg.GetImagePtr(); // Pixel 정보 추출 목적 
					MaxDis =0.0f     ;
					MinDis =10000.0f ;
					MaxDv  =0.0f     ;
					MinDv  =10000.0f ;
					StdMaxDis =0.0f     ;
					StdMinDis =10000.0f ;
					MinCirCount =0      ;
					// 삼항 연산자 최소값 구하기  
					if      (FInspectMode==Insp_Track) MinCirCount = (C3CirInEdgeCount<C3CirOutEdgeCount)?(C3CirInEdgeCount<C3CirStandEdgeCount)?C3CirInEdgeCount:C3CirStandEdgeCount:(C3CirOutEdgeCount<C3CirStandEdgeCount)?C3CirOutEdgeCount:C3CirStandEdgeCount;
					else if (FInspectMode==Insp_Mark ) MinCirCount =  C3CirInEdgeCount; 

					CircleCount=0;TotalCirDis=0.0f; AvgCirDis=0.0f;
					for(int k=0; k<MinCirCount; k++){
						if(FInspectMode==Insp_Track){ // TrackMode
							if(C3CirInPoint[k].x==0    || C3CirInPoint[k].y==0    || k>=MAX_CIRCLE_EDGEPOINT) continue;
							if(C3CirStandPoint[k].x==0 || C3CirStandPoint[k].y==0 || k>=MAX_CIRCLE_EDGEPOINT) continue;

							if(IsMarkBtm){ // RealC3CirCneter값은 TrackLine EdgePoint기준 Circle_Fitting 결과물 
								Dis    = Math.GetLengthFrPointToPoint(RealC3CirCenter,C3CirInPoint[k]   );
								StdDis = Math.GetLengthFrPointToPoint(RealC3CirCenter,C3CirStandPoint[k]);
							}
							else {         // TrackLine 교차점 기준 센터 
								Dis    = Math.GetLengthFrPointToPoint(TrackC3CirCenter,C3CirInPoint[k]   );
							}

							if(Dis>MaxDis) MaxDis = Dis;
							if(Dis<MinDis) MinDis = Dis;

							if(StdDis>StdMaxDis) StdMaxDis = StdDis;
							if(StdDis<StdMinDis) StdMinDis = StdDis;

							if(k==0){ // BTM Defect 검사를 위한 좌표값 및 Dx,Dy 산출 
								if(IsMarkBtm){ 					
									C3CirDx = Math.GetLengthFrPointToPoint(TrackC3CirCenter,C3CirInPoint[k]);
								}
								else {
									C3CirDx = Math.GetLengthFrPointToPoint(TrackC3CirCenter,C3CirInPoint[k]);
								}
							} 
							if(k==(C3CirInEdgeCount-1)) {
								if(IsMarkBtm){ 					
									C3CirDy = Math.GetLengthFrPointToPoint(TrackC3CirCenter,C3CirInPoint[k]);
								}
								else {
									C3CirDy = Math.GetLengthFrPointToPoint(TrackC3CirCenter,C3CirInPoint[k]);
								}
							}
						}
						else if(FInspectMode==Insp_Mark){ // MarkMode 
							if(C3CirInPoint[k].x==0    || C3CirInPoint[k].y==0    || k>=MAX_CIRCLE_EDGEPOINT) continue;

							if(IsMarkBtm){ // RealC3CirCneter값은 연마안쪽 EdgePoint기준 Circle_Fitting 결과물 
								// 							Dis    = Math.GetLengthFrPointToPoint(RealC3CirCenter,C3CirInPoint[k]   );
								Dis = Math.GetLengthFrPointToPoint(CircleFit3Center,C3CirInPoint[k]  );
								// 							Dis    = Math.GetLengthFrPointToPoint(C3CirCenter,C3CirInPoint[k]   );
							}
							else {         // RealC1CirCneter값은 연마안쪽 EdgePoint기준 Circle_Fitting 결과물 
								Dis    = Math.GetLengthFrPointToPoint(CircleFit3Center,C3CirInPoint[k]   );
							}

							if(Dis>MaxDis) MaxDis = Dis;
							if(Dis<MinDis) MinDis = Dis;

							if(k==0){ // BTM Defect 검사를 위한 좌표값 및 Dx,Dy 산출 
								C3CirDx = Math.GetLengthFrPointToPoint(CircleFit3Center,C3CirInPoint[k]);
								// 							C3CirDx = Math.GetLengthFrPointToPoint(RealC3CirCenter,C3CirInPoint[k]);
							} 
							if(k==(C3CirInEdgeCount-1)) {
								// 							C3CirDy = Math.GetLengthFrPointToPoint(RealC3CirCenter,C3CirInPoint[k]);
								C3CirDy = Math.GetLengthFrPointToPoint(CircleFit3Center,C3CirInPoint[k]);
							}
						}

						C3CircleData[CircleCount].Dis  = Dis              ;  // FAVION Circle Fitting 
						C3CircleData[CircleCount].P.x  = C3CirInPoint[k].x;
						C3CircleData[CircleCount].P.y  = C3CirInPoint[k].y;
						CircleCount++   ;
						TotalCirDis+=Dis;
					}
					if(CircleCount!=0 || TotalCirDis!=0){ // Circle AvgRound Cal
						AvgCirDis = (TotalCirDis/CircleCount);
						C3CirRound = AvgCirDis;
					}

					for(int i=0; i<CircleCount; i++){
						// 					C3CircleData[i].Dv = fabs(AvgCirDis - C3CircleData[i].Dis);          // Euresys Circle Fitting 
						C3CircleData[i].Dv = (CirFitDiameter3 - C3CircleData[i].Dis) <0 ?fabs(CirFitDiameter3 - C3CircleData[i].Dis):0;
						if(C3CircleData[i].Dv>MaxDv) MaxDv = C3CircleData[i].Dv;
						if(C3CircleData[i].Dv<MinDv) MinDv = C3CircleData[i].Dv;
					}
					C3CirDeftectCnt  = GetCircleSize(C3CircleData, C3CirDefectPoint, CircleCount, 5);

					if(!IsMarkBtm && C3CirInCrackCount>0 && BrokenThresHold!=0){
						for(int i=0; i<C3CirInCrackCount; i++){
							C3CircleData[i].Dv  =0.0f;
							C3CircleData[i].Dis =0.0f;
							C3CircleData[i].P.x  = C3CirInCrackPoint[i].x;
							C3CircleData[i].P.y  = C3CirInCrackPoint[i].y;
						}
						IAddress = RotateBrokenImg.GetImagePtr(); // Pixel 정보 추출 목적 

						C3CirCrackCnt  = GetCircleCrackSize(C3CircleData, C3CirCrackPoint, C3CirInCrackCount, 30, CrackCirDiameter3,CircleFit3Center,false);
					}
				}

				// C4Circle Calculate 
				if(C4CirInEdgeCount!=0){
					IAddress = DefectImg.GetImagePtr(); // Pixel 정보 추출 목적 
					MaxDis =0.0f     ;
					MinDis =10000.0f ;
					MaxDv  =0.0f     ;
					MinDv  =10000.0f ;
					StdMaxDis =0.0f     ;
					StdMinDis =10000.0f ;
					MinCirCount =0      ;
					// 삼항 연산자 최소값 구하기  
					if      (FInspectMode==Insp_Track) MinCirCount = (C4CirInEdgeCount<C4CirOutEdgeCount)?(C4CirInEdgeCount<C4CirStandEdgeCount)?C4CirInEdgeCount:C4CirStandEdgeCount:(C4CirOutEdgeCount<C4CirStandEdgeCount)?C4CirOutEdgeCount:C4CirStandEdgeCount;
					else if (FInspectMode==Insp_Mark ) MinCirCount =  C4CirInEdgeCount;     

					CircleCount=0;TotalCirDis=0.0f; AvgCirDis=0.0f;
					for(int k=0; k<MinCirCount; k++){
						if(FInspectMode==Insp_Track){ // TrackMode 
							if(C4CirInPoint[k].x==0    || C4CirInPoint[k].y==0    || k>=MAX_CIRCLE_EDGEPOINT) continue;
							if(C4CirStandPoint[k].x==0 || C4CirStandPoint[k].y==0 || k>=MAX_CIRCLE_EDGEPOINT) continue;

							if(IsMarkBtm){  // RealC4CirCneter값은 TrackLine EdgePoint기준 Circle_Fitting 결과물 
								Dis    = Math.GetLengthFrPointToPoint(RealC4CirCenter,C4CirInPoint[k]   );
								StdDis = Math.GetLengthFrPointToPoint(RealC4CirCenter,C4CirStandPoint[k]);
							}
							else {          // TrackLine 교차점 기준 센터 
								Dis    = Math.GetLengthFrPointToPoint(TrackC4CirCenter,C4CirInPoint[k]   );
							}

							if(Dis>MaxDis) MaxDis = Dis;
							if(Dis<MinDis) MinDis = Dis;

							if(StdDis>StdMaxDis) StdMaxDis = StdDis;
							if(StdDis<StdMinDis) StdMinDis = StdDis;


							if(k==0){ // BTM Defect 검사를 위한 좌표값 및 Dx,Dy 산출 
								if(IsMarkBtm){ 					
									C4CirDy = Math.GetLengthFrPointToPoint(TrackC4CirCenter,C4CirInPoint[k]);
								}
								else {
									C4CirDy = Math.GetLengthFrPointToPoint(TrackC4CirCenter,C4CirInPoint[k]);
								}
							} 
							if(k==(C4CirInEdgeCount-1)) {
								if(IsMarkBtm){ 					
									C4CirDx = Math.GetLengthFrPointToPoint(TrackC4CirCenter,C4CirInPoint[k]);
								}
								else {
									C4CirDx = Math.GetLengthFrPointToPoint(TrackC4CirCenter,C4CirInPoint[k]);
								}
							}
						}
						else if(FInspectMode==Insp_Mark){ // MarkMode 
							if(C4CirInPoint[k].x==0    || C4CirInPoint[k].y==0    || k>=MAX_CIRCLE_EDGEPOINT) continue;

							if(IsMarkBtm){  // RealC4CirCneter값은 연마안쪽 EdgePoint기준 Circle_Fitting 결과물 
								// 							Dis    = Math.GetLengthFrPointToPoint(RealC4CirCenter,C4CirInPoint[k]   );
								Dis = Math.GetLengthFrPointToPoint(CircleFit4Center,C4CirInPoint[k]  );
								// 							Dis    = Math.GetLengthFrPointToPoint(C4CirCenter,C4CirInPoint[k]   );
							}
							else {          // RealC4CirCneter값은 연마안쪽 EdgePoint기준 Circle_Fitting 결과물 
								Dis    = Math.GetLengthFrPointToPoint(CircleFit4Center,C4CirInPoint[k]   );
							}

							if(Dis>MaxDis) MaxDis = Dis;
							if(Dis<MinDis) MinDis = Dis;

							if(k==0){ // BTM Defect 검사를 위한 좌표값 및 Dx,Dy 산출 
								// 							C4CirDy = Math.GetLengthFrPointToPoint(RealC4CirCenter,C4CirInPoint[k]);
								C4CirDy = Math.GetLengthFrPointToPoint(CircleFit4Center,C4CirInPoint[k]);
							} 
							if(k==(C4CirInEdgeCount-1)) {
								// 							C4CirDx = Math.GetLengthFrPointToPoint(RealC4CirCenter,C4CirInPoint[k]);
								C4CirDx = Math.GetLengthFrPointToPoint(CircleFit4Center,C4CirInPoint[k]);
							}
						}

						C4CircleData[CircleCount].Dis  = Dis              ;  // FAVION Circle Fitting
						C4CircleData[CircleCount].P.x  = C4CirInPoint[k].x;
						C4CircleData[CircleCount].P.y  = C4CirInPoint[k].y;
						CircleCount++   ;
						TotalCirDis+=Dis;
					}
					if(CircleCount!=0 || TotalCirDis!=0){ // Circle AvgRound Cal
						AvgCirDis = (TotalCirDis/CircleCount);
						C4CirRound = AvgCirDis;
					}

					for(int i=0; i<CircleCount; i++){
						// 					C4CircleData[i].Dv = fabs(AvgCirDis - C4CircleData[i].Dis);       // Euresys Circle Fitting 
						C4CircleData[i].Dv = (CirFitDiameter4 - C4CircleData[i].Dis) <0 ?fabs(CirFitDiameter4 - C4CircleData[i].Dis):0;
						if(C4CircleData[i].Dv>MaxDv) MaxDv = C4CircleData[i].Dv;
						if(C4CircleData[i].Dv<MinDv) MinDv = C4CircleData[i].Dv;
					}
					C4CirDeftectCnt  = GetCircleSize(C4CircleData, C4CirDefectPoint, CircleCount, 5);

					if(!IsMarkBtm && C4CirInCrackCount>0 && BrokenThresHold!=0){
						for(int i=0; i<C4CirInCrackCount; i++){
							C4CircleData[i].Dv  =0.0f;
							C4CircleData[i].Dis =0.0f;
							C4CircleData[i].P.x  = C4CirInCrackPoint[i].x;
							C4CircleData[i].P.y  = C4CirInCrackPoint[i].y;
						}
						IAddress = RotateBrokenImg.GetImagePtr(); // Pixel 정보 추출 목적 
						C4CirCrackCnt  = GetCircleCrackSize(C4CircleData, C4CirCrackPoint, C4CirInCrackCount, 30, CrackCirDiameter4,CircleFit4Center,false);
					}
				}

				// C5Circle Calculate 
				if(C5CirInEdgeCount!=0){
					IAddress = DefectImg.GetImagePtr(); // Pixel 정보 추출 목적 

					MaxDis =0.0f     ;
					MinDis =10000.0f ;
					MaxDv  =0.0f     ;
					MinDv  =10000.0f ;
					StdMaxDis =0.0f     ;
					StdMinDis =10000.0f ;
					MinCirCount =0      ;
					// 삼항 연산자 최소값 구하기  
					if      (FInspectMode==Insp_Track) MinCirCount = (C5CirInEdgeCount<C5CirOutEdgeCount)?(C5CirInEdgeCount<C5CirStandEdgeCount)?C5CirInEdgeCount:C5CirStandEdgeCount:(C5CirOutEdgeCount<C5CirStandEdgeCount)?C5CirOutEdgeCount:C5CirStandEdgeCount;
					else if (FInspectMode==Insp_Mark ) MinCirCount =  C5CirInEdgeCount;

					CircleCount=0;TotalCirDis=0.0f; AvgCirDis=0.0f;
					for(int k=0; k<MinCirCount; k++){
						if(FInspectMode==Insp_Track){ // TrackMode 
							if(C5CirInPoint[k].x==0    || C5CirInPoint[k].y==0    || k>=MAX_CIRCLE_EDGEPOINT) continue;
							if(C5CirStandPoint[k].x==0 || C5CirStandPoint[k].y==0 || k>=MAX_CIRCLE_EDGEPOINT) continue;

							if(IsMarkBtm){  // RealC5CirCneter값은 TrackLine EdgePoint기준 Circle_Fitting 결과물 
								Dis    = Math.GetLengthFrPointToPoint(RealC5CirCenter,C5CirInPoint[k]   );
								StdDis = Math.GetLengthFrPointToPoint(RealC5CirCenter,C5CirStandPoint[k]);
							}
							else {          // TrackLine 교차점 기준 센터 
								Dis    = Math.GetLengthFrPointToPoint(TrackC5CirCenter,C5CirInPoint[k]   );
							}

							if(Dis>MaxDis) MaxDis = Dis;
							if(Dis<MinDis) MinDis = Dis;

							if(StdDis>StdMaxDis) StdMaxDis = StdDis;
							if(StdDis<StdMinDis) StdMinDis = StdDis;

							if(k==0){ // BTM Defect 검사를 위한 좌표값 및 Dx,Dy 산출 
								if(IsMarkBtm){ 					
									C5CirDy = Math.GetLengthFrPointToPoint(TrackC5CirCenter,C5CirInPoint[k]);
								}
								else {
									C5CirDy = Math.GetLengthFrPointToPoint(TrackC5CirCenter,C5CirInPoint[k]);
								}
							} 
							if(k==(C5CirInEdgeCount-1)) {
								if(IsMarkBtm){ 					
									C5CirDx = Math.GetLengthFrPointToPoint(TrackC5CirCenter,C5CirInPoint[k]);
								}
								else {
									C5CirDx = Math.GetLengthFrPointToPoint(TrackC5CirCenter,C5CirInPoint[k]);
								}
							}
						}
						else if(FInspectMode==Insp_Mark){ // MarkMode 
							if(C5CirInPoint[k].x==0    || C5CirInPoint[k].y==0    || k>=MAX_CIRCLE_EDGEPOINT) continue;

							if(IsMarkBtm){  // RealC5CirCneter값은 연마안쪽 EdgePoint기준 Circle_Fitting 결과물 
								// 							Dis    = Math.GetLengthFrPointToPoint(RealC5CirCenter,C5CirInPoint[k]   );
								Dis = Math.GetLengthFrPointToPoint(CircleFit5Center,C5CirInPoint[k]  );
								// 							Dis    = Math.GetLengthFrPointToPoint(C5CirCenter,C5CirInPoint[k]   );
							}
							else {          // RealC5CirCneter값은 연마안쪽 EdgePoint기준 Circle_Fitting 결과물 
								Dis    = Math.GetLengthFrPointToPoint(CircleFit5Center,C5CirInPoint[k]   );
							}

							if(Dis>MaxDis) MaxDis = Dis;
							if(Dis<MinDis) MinDis = Dis;

							if(k==0){ // BTM Defect 검사를 위한 좌표값 및 Dx,Dy 산출 
								// 							C5CirDy = Math.GetLengthFrPointToPoint(RealC5CirCenter,C5CirInPoint[k]);
								C5CirDy = Math.GetLengthFrPointToPoint(CircleFit5Center,C5CirInPoint[k]);
							} 
							if(k==(C5CirInEdgeCount-1)) {
								// 							C5CirDx = Math.GetLengthFrPointToPoint(RealC5CirCenter,C5CirInPoint[k]);
								C5CirDx = Math.GetLengthFrPointToPoint(CircleFit5Center,C5CirInPoint[k]);
							}
						}

						C5CircleData[CircleCount].Dis  = Dis            ;  // FAVION  Circle Fitting 
						C5CircleData[CircleCount].P.x  = C5CirInPoint[k].x;
						C5CircleData[CircleCount].P.y  = C5CirInPoint[k].y;
						CircleCount++   ;
						TotalCirDis+=Dis;
					}
					if(CircleCount!=0 || TotalCirDis!=0){ // Circle AvgRound Cal
						AvgCirDis = (TotalCirDis/CircleCount);
						C5CirRound = AvgCirDis;
					}

					for(int i=0; i<CircleCount; i++){
						// 					C5CircleData[i].Dv = fabs(AvgCirDis - C5CircleData[i].Dis);       // Euresys Circle Fitting  
						C5CircleData[i].Dv = (CirFitDiameter5 - C5CircleData[i].Dis) >0 ?(CirFitDiameter5 - C5CircleData[i].Dis):0;
						if(C5CircleData[i].Dv>MaxDv) MaxDv = C5CircleData[i].Dv;
						if(C5CircleData[i].Dv<MinDv) MinDv = C5CircleData[i].Dv;
					}
					C5CirDeftectCnt  = GetCircleSize(C5CircleData, C5CirDefectPoint, CircleCount, 5);

					if(!IsMarkBtm && C5CirInCrackCount>0 && BrokenThresHold!=0){
						for(int i=0; i<C5CirInCrackCount; i++){
							C5CircleData[i].Dv  =0.0f;
							C5CircleData[i].Dis =0.0f;
							C5CircleData[i].P.x  = C5CirInCrackPoint[i].x;
							C5CircleData[i].P.y  = C5CirInCrackPoint[i].y;
						}
						IAddress = RotateBrokenImg.GetImagePtr(); // Pixel 정보 추출 목적 
						C5CirCrackCnt  = GetCircleCrackSize(C5CircleData, C5CirCrackPoint, C5CirInCrackCount, 30, CrackCirDiameter5,CircleFit5Center);
					}
				}

				// C6Circle Calculate 
				if(C6CirInEdgeCount!=0){
					IAddress = DefectImg.GetImagePtr(); // Pixel 정보 추출 목적 

					MaxDis =0.0f     ;
					MinDis =10000.0f ;
					MaxDv  =0.0f     ;
					MinDv  =10000.0f ;
					StdMaxDis =0.0f     ;
					StdMinDis =10000.0f ;
					MinCirCount =0      ;
					// 삼항 연산자 최소값 구하기  
					if      (FInspectMode==Insp_Track) MinCirCount = (C6CirInEdgeCount<C6CirOutEdgeCount)?(C6CirInEdgeCount<C6CirStandEdgeCount)?C6CirInEdgeCount:C6CirStandEdgeCount:(C6CirOutEdgeCount<C6CirStandEdgeCount)?C6CirOutEdgeCount:C6CirStandEdgeCount;
					else if (FInspectMode==Insp_Mark ) MinCirCount =  C6CirInEdgeCount;  

					CircleCount=0;TotalCirDis=0.0f; AvgCirDis=0.0f;
					for(int k=0; k<MinCirCount; k++){
						if(FInspectMode==Insp_Track){ // TrackMode 
							if(C6CirInPoint[k].x==0    || C6CirInPoint[k].y==0    || k>=MAX_CIRCLE_EDGEPOINT) continue;
							if(C6CirStandPoint[k].x==0 || C6CirStandPoint[k].y==0 || k>=MAX_CIRCLE_EDGEPOINT) continue;

							if(IsMarkBtm){  // RealC6CirCneter값은 TrackLine EdgePoint기준 Circle_Fitting 결과물 
								Dis    = Math.GetLengthFrPointToPoint(RealC6CirCenter,C6CirInPoint[k]   );
								StdDis = Math.GetLengthFrPointToPoint(RealC6CirCenter,C6CirStandPoint[k]);
							}
							else {          // TrackLine 교차점 기준 센터 
								Dis    = Math.GetLengthFrPointToPoint(TrackC6CirCenter,C6CirInPoint[k]   );
							}

							if(Dis>MaxDis) MaxDis = Dis;
							if(Dis<MinDis) MinDis = Dis;

							if(StdDis>StdMaxDis) StdMaxDis = StdDis;
							if(StdDis<StdMinDis) StdMinDis = StdDis;


							if(k==0){ // BTM Defect 검사를 위한 좌표값 및 Dx,Dy 산출 
								if(IsMarkBtm){ 					
									C6CirDx = Math.GetLengthFrPointToPoint(TrackC6CirCenter,C6CirInPoint[k]);
								}
								else {
									C6CirDx = Math.GetLengthFrPointToPoint(TrackC6CirCenter,C6CirInPoint[k]);
								}
							} 
							if(k==(C6CirInEdgeCount-1)) {
								if(IsMarkBtm){ 					
									C6CirDy = Math.GetLengthFrPointToPoint(TrackC6CirCenter,C6CirInPoint[k]);
								}
								else {
									C6CirDy = Math.GetLengthFrPointToPoint(TrackC6CirCenter,C6CirInPoint[k]);
								}
							}
						}
						else if(FInspectMode==Insp_Mark){ // MarkMode 
							if(C6CirInPoint[k].x==0    || C6CirInPoint[k].y==0    || k>=MAX_CIRCLE_EDGEPOINT) continue;

							if(IsMarkBtm){  // RealC6CirCneter값은 연마안쪽 EdgePoint기준 Circle_Fitting 결과물 
								// 							Dis    = Math.GetLengthFrPointToPoint(RealC6CirCenter,C6CirInPoint[k]   );
								Dis = Math.GetLengthFrPointToPoint(CircleFit6Center,C6CirInPoint[k]  );
								// 							Dis    = Math.GetLengthFrPointToPoint(C6CirCenter,C6CirInPoint[k]   );
							}
							else {          // RealC6CirCneter값은 연마안쪽 EdgePoint기준 Circle_Fitting 결과물 
								Dis    = Math.GetLengthFrPointToPoint(CircleFit6Center,C6CirInPoint[k]   );
							}

							if(Dis>MaxDis) MaxDis = Dis;
							if(Dis<MinDis) MinDis = Dis;

							if(k==0){ // BTM Defect 검사를 위한 좌표값 및 Dx,Dy 산출 
								C6CirDx = Math.GetLengthFrPointToPoint(CircleFit6Center,C6CirInPoint[k]);
								// 							C6CirDx = Math.GetLengthFrPointToPoint(RealC6CirCenter,C6CirInPoint[k]);
							} 
							if(k==(C6CirInEdgeCount-1)) {
								C6CirDy = Math.GetLengthFrPointToPoint(CircleFit6Center,C6CirInPoint[k]);
								// 							C6CirDy = Math.GetLengthFrPointToPoint(RealC6CirCenter,C6CirInPoint[k]);
							}
						}

						C6CircleData[CircleCount].Dis  = Dis            ; // FAVION Circle Fitting 
						C6CircleData[CircleCount].P.x  = C6CirInPoint[k].x;
						C6CircleData[CircleCount].P.y  = C6CirInPoint[k].y;
						CircleCount++   ;
						TotalCirDis+=Dis;
					}
					if(CircleCount!=0 || TotalCirDis!=0){ // Circle AvgRound Cal
						AvgCirDis = (TotalCirDis/CircleCount);
						C6CirRound = AvgCirDis;
					}

					for(int i=0; i<CircleCount; i++){
						// 					C6CircleData[i].Dv = fabs(AvgCirDis - C6CircleData[i].Dis);       // Euresys Circle Fitting 
						C6CircleData[i].Dv = (CirFitDiameter6 - C6CircleData[i].Dis) >0 ?(CirFitDiameter6 - C6CircleData[i].Dis):0;
						if(C6CircleData[i].Dv>MaxDv) MaxDv = C6CircleData[i].Dv;
						if(C6CircleData[i].Dv<MinDv) MinDv = C6CircleData[i].Dv;
					}
					C6CirDeftectCnt  = GetCircleSize(C6CircleData, C6CirDefectPoint, CircleCount, 5);

					if(!IsMarkBtm && C6CirInCrackCount>0 && BrokenThresHold!=0){
						for(int i=0; i<C6CirInCrackCount; i++){
							C6CircleData[i].Dv  =0.0f;
							C6CircleData[i].Dis =0.0f;
							C6CircleData[i].P.x  = C6CirInCrackPoint[i].x;
							C6CircleData[i].P.y  = C6CirInCrackPoint[i].y;
						}
						IAddress = RotateBrokenImg.GetImagePtr(); // Pixel 정보 추출 목적 
						C6CirCrackCnt  = GetCircleCrackSize(C6CircleData, C6CirCrackPoint, C6CirInCrackCount, 30, CrackCirDiameter6,CircleFit6Center);
					}
				}


				// Side D 
				///////////////////////////////////////////////////////////////////////////////////////////////////////////////
				//LogUnit.SetLog("CUP_Side_D_Start_CamId: %d, ImageHeight: %d ",CamId,ImageHeight);     
				// 			DefectROI.SetPlacement((int)(SP.x+SideMargin),(int)(SP.y+BtmMargin), FLeftWidth, LeftHeight-(2*BtmMargin));
				// 			if((SP.x+SideMargin) <=0          || SP.y+BtmMargin<0            || FLeftWidth<=0          || LeftHeight-(2*BtmMargin)< 0          ) return false;
				// 			if((SP.x+SideMargin) >=ImageWidth || SP.y+BtmMargin>BtmLimitLine || FLeftWidth>=ImageWidth || LeftHeight-(2*BtmMargin)>BtmLimitLine) return false;
				// 			if((SP.x+SideMargin)+FLeftWidth >=ImageWidth || (SP.y+BtmMargin)+(LeftHeight-(2*BtmMargin))>BtmLimitLine                           ) return false;

				IAddress = DefectImg.GetImagePtr(); // Pixel 정보 추출 목적 
				DefectROI.SetPlacement((int)(SP.x+SideMargin),(int)(SP.y+LeftDegMargin), FLeftWidth, LeftHeight-(2*LeftDegMargin));
				if((SP.x+SideMargin) <=0          || SP.y+LeftDegMargin<0            || FLeftWidth<=0          || LeftHeight-(2*LeftDegMargin)< 0          ) return false;
				if((SP.x+SideMargin) >=ImageWidth || SP.y+LeftDegMargin>BtmLimitLine || FLeftWidth>=ImageWidth || LeftHeight-(2*LeftDegMargin)>BtmLimitLine) return false;
				if((SP.x+SideMargin)+FLeftWidth >=ImageWidth || (SP.y+LeftDegMargin)+(LeftHeight-(2*LeftDegMargin))>BtmLimitLine                           ) return false;

				// Line Position 
				LinePosition = SP.x+SideMargin;
				// Blob 검사 진행 
				CodeImageSelection.Clear();
				CodeImageEncoder.Encode(DefectROI,CodeImage);
				CodeImageSelection.Clear();
				CodeImageSelection.AddObjects(CodeImage);
				// Blob 필터링 
				CodeImageSelection.RemoveUsingFloatFeature(EFeature_BoundingBoxWidth ,FMinWidth , FMaxWidth  , EDoubleThresholdMode_Outside);
				CodeImageSelection.RemoveUsingFloatFeature(EFeature_BoundingBoxHeight,FMinHeight, FMaxHeight , EDoubleThresholdMode_Outside);
				// 				CodeImageSelection.RemoveUsingIntegerFeature(EFeature_LeftLimit        ,0       , 3          , EDoubleThresholdMode_Outside);
				CodeImageSelection.RemoveUsingIntegerFeature(EFeature_LeftLimit        ,0       , 1          , EDoubleThresholdMode_Outside);

				BlobCount = CodeImageSelection.GetElementCount();
				CodeImageSelection.Sort(EFeature_TopLimit,ESortDirection_Ascending);

				if(BlobCount!=0){
					for(int k=0; k<BlobCount; k++){
						if(DCount>=MAX_DEFECT_POINT) break;
						DDefectPoint[DCount].Width  =  CodeImageSelection.GetElement(k).GetBoundingBoxWidth() ;
						DDefectPoint[DCount].Height =  CodeImageSelection.GetElement(k).GetBoundingBoxHeight();

						DDefectPoint[DCount].Rect.left   =(long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterX() - DDefectPoint[DCount].Width/2 ) +LinePosition );
						DDefectPoint[DCount].Rect.top    =(long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - DDefectPoint[DCount].Height/2)+(SP.y+LeftDegMargin));
						DDefectPoint[DCount].Rect.right  =(long)(DDefectPoint[DCount].Rect.left+ DDefectPoint[DCount].Width );
						DDefectPoint[DCount].Rect.bottom =(long)(DDefectPoint[DCount].Rect.top + DDefectPoint[DCount].Height);
						PixelCount =0;
						PixelValue =0;

						// 내부 Pixel Data 축출 
						for(int n=DDefectPoint[DCount].Rect.top+1 ; n<DDefectPoint[DCount].Rect.bottom-1; n++){
							for(int m=DDefectPoint[DCount].Rect.left+1; m<DDefectPoint[DCount].Rect.right-1 ; m++){
								PixelValue = IElement(m,n);
								if(PixelValue < EnCapBtmThresHold) PixelCount++;
							}
						}

						DDefectPoint[DCount].Round = PixelCount;
						DDefectPoint[DCount].P.x    =(float)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterX() - DDefectPoint[DCount].Width/2 ) +LinePosition);
						DDefectPoint[DCount].P.y    =(float)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - DDefectPoint[DCount].Height/2)+(SP.y+LeftDegMargin)+ImageHeight);
						DDefectPoint[DCount].Width  = (InspectMode)?DDefectPoint[DCount].Width: DDefectPoint[DCount].Width+SideMargin;

						// Merge 위해서 데이터 필요함 
						DDefectPoint[DCount].Rect.top    =(long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - DDefectPoint[DCount].Height/2) +(SP.y+LeftDegMargin)+ImageHeight);
						DDefectPoint[DCount].Rect.bottom =(long)(DDefectPoint[DCount].Rect.top + DDefectPoint[DCount].Height);
						DCount++;
					}
				}
				BlobCount=0;
				// 외곽라인에서 Mark까지의 거리 산출 
				if     (Line[waLeftWall].FP0.x >Line[waLeftWall].FP1.x) LDistance = FP0.x - (Line[waLeftWall].FP1.x+(Line[waLeftWall].FP0.x - Line[waLeftWall].FP1.x)/2);
				else if(Line[waLeftWall].FP0.x==Line[waLeftWall].FP1.x) LDistance = FP0.x -  Line[waLeftWall].FP0.x;
				else                                                    LDistance = FP0.x - (Line[waLeftWall].FP0.x+(Line[waLeftWall].FP1.x - Line[waLeftWall].FP0.x)/2); 
				////////////////////////////////////////////////////////////////////////////////////////////////


				// Side B
				////////////////////////////////////////////////////////////////////////////////////////////////
				DefectROI.SetPlacement((int)(EP.x-FRightWidth-SideMargin),(int)(EP.y+RightDegMargin), FRightWidth,  RightHeight-(2*RightDegMargin));
				if((EP.x-FRightWidth-SideMargin) <=0          || (EP.y+RightDegMargin)<0            || FRightWidth<=0          || RightHeight-(2*RightDegMargin)<0           ) return false;
				if((EP.x-FRightWidth-SideMargin) >=ImageWidth || (EP.y+RightDegMargin)>BtmLimitLine || FRightWidth>=ImageWidth || RightHeight-(2*RightDegMargin)>BtmLimitLine) return false;
				if((EP.x-FRightWidth-SideMargin)+FRightWidth >=ImageWidth || (EP.y+RightDegMargin)+(RightHeight-(2*RightDegMargin))>BtmLimitLine                             ) return false;

				// 			DefectROI.SetPlacement((int)(EP.x-FRightWidth-SideMargin),(int)(EP.y+BtmMargin), FRightWidth,  RightHeight-(2*BtmMargin));
				// 			if((EP.x-FRightWidth-SideMargin) <=0          || (EP.y+BtmMargin)<0            || FRightWidth<=0          || RightHeight-(2*BtmMargin)<0           ) return false;
				// 			if((EP.x-FRightWidth-SideMargin) >=ImageWidth || (EP.y+BtmMargin)>BtmLimitLine || FRightWidth>=ImageWidth || RightHeight-(2*BtmMargin)>BtmLimitLine) return false;
				// 			if((EP.x-FRightWidth-SideMargin)+FRightWidth >=ImageWidth || (EP.y+BtmMargin)+(RightHeight-(2*BtmMargin))>BtmLimitLine                             ) return false;

				// Line Position 
				LinePosition = EP.x - FRightWidth- SideMargin;
				// Blob 검사 진행 
				CodeImageSelection.Clear();
				CodeImageEncoder.Encode(DefectROI,CodeImage);
				CodeImageSelection.Clear();
				CodeImageSelection.AddObjects(CodeImage);
				// Blob 필터링 
				CodeImageSelection.RemoveUsingFloatFeature  (EFeature_BoundingBoxWidth ,FMinWidth               , FMaxWidth                , EDoubleThresholdMode_Outside);
				CodeImageSelection.RemoveUsingFloatFeature  (EFeature_BoundingBoxHeight,FMinHeight              , FMaxHeight               , EDoubleThresholdMode_Outside);
				CodeImageSelection.RemoveUsingIntegerFeature(EFeature_RightLimit       ,FRightWidth -1          , FRightWidth+1            , EDoubleThresholdMode_Outside);

				BlobCount = CodeImageSelection.GetElementCount();
				CodeImageSelection.Sort(EFeature_TopLimit,ESortDirection_Ascending);

				if(BlobCount!=0){
					for(int k=0; k<BlobCount; k++){
						if(BCount>=MAX_DEFECT_POINT) break;
						BDefectPoint[BCount].Width  = CodeImageSelection.GetElement(k).GetBoundingBoxWidth() ; 
						BDefectPoint[BCount].Height = CodeImageSelection.GetElement(k).GetBoundingBoxHeight();

						BDefectPoint[BCount].Rect.left   =(long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterX() - BDefectPoint[BCount].Width/2 ) +(LinePosition)  );
						BDefectPoint[BCount].Rect.top    =(long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - BDefectPoint[BCount].Height/2) +(EP.y+RightDegMargin));
						BDefectPoint[BCount].Rect.right  =(long)(BDefectPoint[BCount].Rect.left+ BDefectPoint[BCount].Width );
						BDefectPoint[BCount].Rect.bottom =(long)(BDefectPoint[BCount].Rect.top + BDefectPoint[BCount].Height);
						PixelCount = 0;
						PixelValue = 0;

						// 내부 Pixel Data 축출 
						for(int n=BDefectPoint[BCount].Rect.top+1 ; n<BDefectPoint[BCount].Rect.bottom-1; n++){
							for(int m=BDefectPoint[BCount].Rect.left+1; m<BDefectPoint[BCount].Rect.right-1 ; m++){
								PixelValue = IElement(m,n);
								if(PixelValue < EnCapBtmThresHold) PixelCount++;
							}
						}
						BDefectPoint[BCount].Round  = PixelCount;
						BDefectPoint[BCount].P.x    =(float)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterX() - BDefectPoint[BCount].Width/2 )+(LinePosition));
						BDefectPoint[BCount].P.y    =(float)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - BDefectPoint[BCount].Height/2)+(EP.y+RightDegMargin)+ImageHeight   );
						BDefectPoint[BCount].Width  =(InspectMode)? BDefectPoint[BCount].Width: BDefectPoint[BCount].Width+SideMargin;

						// Merge 위해서 데이터 필요함 
						BDefectPoint[BCount].Rect.top    =(long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - BDefectPoint[BCount].Height/2) +(EP.y+RightDegMargin)+ImageHeight);
						BDefectPoint[BCount].Rect.bottom =(long)(BDefectPoint[BCount].Rect.top + BDefectPoint[BCount].Height);
						BCount++;
					}
				}
				BlobCount =0;
				// 외곽라인에서 Mark까지의 거리 산출 
				if     (Line[waRightWall].FP0.x >Line[waRightWall].FP1.x) RDistance = (Line[waRightWall].FP1.x+(Line[waRightWall].FP0.x - Line[waRightWall].FP1.x)/2) - FP1.x;
				else if(Line[waRightWall].FP0.x==Line[waRightWall].FP1.x) RDistance =  Line[waRightWall].FP0.x - FP1.x;
				else                                                      RDistance = (Line[waRightWall].FP0.x+(Line[waRightWall].FP1.x - Line[waRightWall].FP0.x)/2) - FP1.x;
				////////////////////////////////////////////////////////////////////////////////////////////////

				// Side C 
				// Circle 검사 후 6개의 좌표기준으로 5개의 영역 검사 진행함 
				///////////////////////////////////////////////////////////////////////////////////////////////
				// Notch부 직선영역 Dark Defect 검사 시퀀스 시작 
				//첫번째 Btm영역의 직선라인 기준 검사 
				if(BtmInLine[0].FP0.x!=0 && BtmInLine[0].FP0.y!=0 && BtmInLine[0].FP1.x!=0 && BtmInLine[0].FP1.y!=0){
					DefectROI.SetPlacement((int)(BtmInLine[0].FP0.x+SideMargin), (int)(BtmInLine[0].FP0.y-FBtmHeight), (BtmInLine[0].FP1.x - BtmInLine[0].FP0.x)-(2*SideMargin), FBtmHeight);
					if((BtmInLine[0].FP0.x+SideMargin) <=0          ||(BtmInLine[0].FP0.y-FBtmHeight)< 0           || (BtmInLine[0].FP1.x - BtmInLine[0].FP0.x)-(2*SideMargin)<=0          || FBtmHeight< 0          ) return false;
					if((BtmInLine[0].FP0.x+SideMargin) >=ImageWidth ||(BtmInLine[0].FP0.y-FBtmHeight)>BtmLimitLine || (BtmInLine[0].FP1.x - BtmInLine[0].FP0.x)-(2*SideMargin)>=ImageWidth || FBtmHeight>BtmLimitLine) return false;
					if((BtmInLine[0].FP0.x+SideMargin)+((BtmInLine[0].FP1.x - BtmInLine[0].FP0.x)-(2*SideMargin)) >=ImageWidth ||(BtmInLine[0].FP0.y-FBtmHeight)+FBtmHeight>BtmLimitLine                             ) return false;
					//Blob 검사 진행함 
					CodeImageSelection.Clear();
					CodeImageEncoder.Encode(DefectROI,CodeImage);
					CodeImageSelection.Clear();
					CodeImageSelection.AddObjects(CodeImage);
					// Blob 필터링 
					CodeImageSelection.RemoveUsingFloatFeature  (EFeature_BoundingBoxWidth ,FMinWidth      , FMaxWidth   , EDoubleThresholdMode_Outside);
					CodeImageSelection.RemoveUsingFloatFeature  (EFeature_BoundingBoxHeight,FMinHeight     , FMaxHeight  , EDoubleThresholdMode_Outside);
					CodeImageSelection.RemoveUsingIntegerFeature(EFeature_BottomLimit      ,FBtmHeight-1   , FBtmHeight+1, EDoubleThresholdMode_Outside);

					BlobCount = CodeImageSelection.GetElementCount();
					CodeImageSelection.Sort(EFeature_LeftLimit ,ESortDirection_Ascending);

					if(BlobCount!=0){
						for(int k=0; k<BlobCount; k++){
							if(CCount>=MAX_DEFECT_POINT) break; 
							CDefectPoint[CCount].Width  =  CodeImageSelection.GetElement(k).GetBoundingBoxWidth() ;
							CDefectPoint[CCount].Height =  CodeImageSelection.GetElement(k).GetBoundingBoxHeight();

							CDefectPoint[CCount].Rect.left   =(long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterX() - CDefectPoint[CCount].Width/2 ) +(BtmInLine[0].FP0.x+SideMargin));
							CDefectPoint[CCount].Rect.top    =(long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - CDefectPoint[CCount].Height/2) +(BtmInLine[0].FP0.y-FBtmHeight));
							CDefectPoint[CCount].Rect.right  =(long)(CDefectPoint[CCount].Rect.left+ CDefectPoint[CCount].Width );
							CDefectPoint[CCount].Rect.bottom =(long)(CDefectPoint[CCount].Rect.top + CDefectPoint[CCount].Height);
							PixelCount = 0;
							PixelValue = 0;

							// 내부 Pixel Data 축출 
							for(int n=CDefectPoint[CCount].Rect.top+1 ; n<CDefectPoint[CCount].Rect.bottom-1; n++){
								for(int m=CDefectPoint[CCount].Rect.left+1; m<CDefectPoint[CCount].Rect.right-1 ; m++){
									PixelValue = IElement(m,n);
									if(PixelValue < EnCapBtmThresHold) PixelCount++;
								}
							}
							CDefectPoint[CCount].Round  =  PixelCount;
							CDefectPoint[CCount].P.x    = (float)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterX() - CDefectPoint[CCount].Width/2 ) +(BtmInLine[0].FP0.x+SideMargin));
							CDefectPoint[CCount].P.y    = (float)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - CDefectPoint[CCount].Height/2) +(BtmInLine[0].FP0.y-FBtmHeight));

							// Image Rotate 기준 좌표를 다시 Rotate한다 _ Display 목적 
							if(ImgDegree!=0.0f){
								CDefectPoint[CCount].P = Math.OnRotate(CenterPoint, CDefectPoint[CCount].P, (ImgDegree));
							}
							// Image Rotate 기준 좌표를 회전 이후에 ImageHeight값을 더하여 실제 좌표를 산출한다 
							CDefectPoint[CCount].P.y    =(float)(CDefectPoint[CCount].P.y+ImageHeight);

							// Merge 위해서 데이터 필요함 
							CDefectPoint[CCount].Rect.top    =(long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - CDefectPoint[CCount].Height/2) +(BtmInLine[0].FP0.y-FBtmHeight)+ImageHeight);
							CDefectPoint[CCount].Rect.bottom =(long)(CDefectPoint[CCount].Rect.top + CDefectPoint[CCount].Height);
							CCount++;
						}
					}
				}
				BlobCount =0;

				///////////////////////////////////////////////////////////////////////////////////////////////
				//두번째 Btm영역의 직선라인 기준 검사 
				if(BtmInLine[1].FP0.x!=0 && BtmInLine[1].FP0.y!=0 && BtmInLine[1].FP1.x!=0 && BtmInLine[1].FP1.y!=0){
					DefectROI.SetPlacement((int)(BtmInLine[1].FP0.x-FRightWidth-SideMargin),(int)(BtmInLine[1].FP0.y), FRightWidth,  (BtmInLine[1].FP1.y - BtmInLine[1].FP0.y));
					if((BtmInLine[1].FP0.x-FRightWidth-SideMargin) <=0          || (BtmInLine[1].FP0.y)<0            || FRightWidth<=0          || (BtmInLine[1].FP1.y - BtmInLine[1].FP0.y)<=0          ) return false;
					if((BtmInLine[1].FP0.x-FRightWidth-SideMargin) >=ImageWidth || (BtmInLine[1].FP0.y)>BtmLimitLine || FRightWidth>=ImageWidth || (BtmInLine[1].FP1.y - BtmInLine[1].FP0.y)>BtmLimitLine) return false;
					if((BtmInLine[1].FP0.x-FRightWidth-SideMargin)+ FRightWidth >=ImageWidth ||(BtmInLine[1].FP0.y)+(BtmInLine[1].FP1.y - BtmInLine[1].FP0.y)>BtmLimitLine                               ) return false;

					// Line Position 
					LinePosition = BtmInLine[1].FP0.x-FRightWidth-SideMargin;
					// Blob 검사 진행 
					CodeImageSelection.Clear();
					CodeImageEncoder.Encode(DefectROI,CodeImage);
					CodeImageSelection.Clear();
					CodeImageSelection.AddObjects(CodeImage);
					// Blob 필터링 
					CodeImageSelection.RemoveUsingFloatFeature  (EFeature_BoundingBoxWidth ,FMinWidth               , FMaxWidth                , EDoubleThresholdMode_Outside);
					CodeImageSelection.RemoveUsingFloatFeature  (EFeature_BoundingBoxHeight,FMinHeight              , FMaxHeight               , EDoubleThresholdMode_Outside);
					CodeImageSelection.RemoveUsingIntegerFeature(EFeature_RightLimit     ,FRightWidth -1            , FRightWidth+1            , EDoubleThresholdMode_Outside);

					BlobCount = CodeImageSelection.GetElementCount();
					CodeImageSelection.Sort(EFeature_TopLimit,ESortDirection_Ascending);

					if(BlobCount!=0){
						for(int k=0; k<BlobCount; k++){
							if(BCount>=MAX_DEFECT_POINT) break;
							BDefectPoint[BCount].Width  = CodeImageSelection.GetElement(k).GetBoundingBoxWidth() ; 
							BDefectPoint[BCount].Height = CodeImageSelection.GetElement(k).GetBoundingBoxHeight();

							BDefectPoint[BCount].Rect.left   =(long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterX() - BDefectPoint[BCount].Width/2 ) +(LinePosition)      );
							BDefectPoint[BCount].Rect.top    =(long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - BDefectPoint[BCount].Height/2) +(BtmInLine[1].FP0.y));
							BDefectPoint[BCount].Rect.right  =(long)(BDefectPoint[BCount].Rect.left+ BDefectPoint[BCount].Width );
							BDefectPoint[BCount].Rect.bottom =(long)(BDefectPoint[BCount].Rect.top + BDefectPoint[BCount].Height);
							PixelCount = 0;
							PixelValue = 0;

							// 내부 Pixel Data 축출 
							for(int n=BDefectPoint[BCount].Rect.top+1 ; n<BDefectPoint[BCount].Rect.bottom-1; n++){
								for(int m=BDefectPoint[BCount].Rect.left+1; m<BDefectPoint[BCount].Rect.right-1 ; m++){
									PixelValue = IElement(m,n);
									if(PixelValue < EnCapBtmThresHold) PixelCount++;
								}
							}
							BDefectPoint[BCount].Round  = PixelCount;
							BDefectPoint[BCount].P.x    =(float)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterX() - BDefectPoint[BCount].Width/2 )+(LinePosition));
							BDefectPoint[BCount].P.y    =(float)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - BDefectPoint[BCount].Height/2)+(BtmInLine[1].FP0.y)+ImageHeight);
							BDefectPoint[BCount].Width  =(InspectMode)? BDefectPoint[BCount].Width: BDefectPoint[BCount].Width+SideMargin;

							// Merge 위해서 데이터 필요함 
							BDefectPoint[BCount].Rect.top    =(long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - BDefectPoint[BCount].Height/2) +(BtmInLine[1].FP0.y)+ImageHeight);
							BDefectPoint[BCount].Rect.bottom =(long)(BDefectPoint[BCount].Rect.top + BDefectPoint[BCount].Height);
							BCount++;
						}
					}
				}
				BlobCount =0;

				///////////////////////////////////////////////////////////////////////////////////////////////
				//세번째 Btm영역의 직선라인 기준 검사 
				if(BtmInLine[2].FP0.x!=0 && BtmInLine[2].FP0.y!=0 && BtmInLine[2].FP1.x!=0 && BtmInLine[2].FP1.y!=0){
					// 				DefectROI.SetPlacement((int)(BtmInLine[2].FP0.x+SideMargin), (int)(BtmInLine[2].FP0.y-50),(BtmInLine[2].FP1.x - BtmInLine[2].FP0.x)-(2*SideMargin), 50);
					DefectROI.SetPlacement((int)(BtmInLine[2].FP0.x+SideMargin), (int)(BtmInLine[2].FP0.y-FBtmHeight),(BtmInLine[2].FP1.x - BtmInLine[2].FP0.x)-(2*SideMargin), FBtmHeight);
					if((BtmInLine[2].FP0.x+SideMargin) <=0          ||(BtmInLine[2].FP0.y-FBtmHeight)< 0           || (BtmInLine[2].FP1.x - BtmInLine[2].FP0.x)-(2*SideMargin)<=0          || FBtmHeight<0           ) return false;
					if((BtmInLine[2].FP0.x+SideMargin) >=ImageWidth ||(BtmInLine[2].FP0.y-FBtmHeight)>BtmLimitLine || (BtmInLine[2].FP1.x - BtmInLine[2].FP0.x)-(2*SideMargin)>=ImageWidth || FBtmHeight>BtmLimitLine) return false;
					// 				if((BtmInLine[2].FP0.x+SideMargin) <=0          ||(BtmInLine[2].FP0.y-50)< 0           || (BtmInLine[2].FP1.x - BtmInLine[2].FP0.x)-(2*SideMargin)<=0          || FBtmHeight<0           ) return false;
					// 				if((BtmInLine[2].FP0.x+SideMargin) >=ImageWidth ||(BtmInLine[2].FP0.y-50)>BtmLimitLine || (BtmInLine[2].FP1.x - BtmInLine[2].FP0.x)-(2*SideMargin)>=ImageWidth || FBtmHeight>BtmLimitLine) return false;
					if((BtmInLine[2].FP0.x+SideMargin) +(BtmInLine[2].FP1.x - BtmInLine[2].FP0.x)-(2*SideMargin)>=ImageWidth ||(BtmInLine[2].FP0.y-FBtmHeight)+FBtmHeight>BtmLimitLine                               ) return false;
					//Blob 검사 진행함 
					CodeImageSelection.Clear();
					CodeImageEncoder.Encode(DefectROI,CodeImage);
					CodeImageSelection.Clear();
					CodeImageSelection.AddObjects(CodeImage);
					// Blob 필터링 
					CodeImageSelection.RemoveUsingFloatFeature  (EFeature_BoundingBoxWidth ,FMinWidth      , FMaxWidth   , EDoubleThresholdMode_Outside);
					CodeImageSelection.RemoveUsingFloatFeature  (EFeature_BoundingBoxHeight,FMinHeight     , FMaxHeight  , EDoubleThresholdMode_Outside);
					CodeImageSelection.RemoveUsingIntegerFeature(EFeature_BottomLimit      ,FBtmHeight-1   , FBtmHeight+1, EDoubleThresholdMode_Outside);

					BlobCount = CodeImageSelection.GetElementCount();
					CodeImageSelection.Sort(EFeature_LeftLimit ,ESortDirection_Ascending);

					if(BlobCount!=0){
						for(int k=0; k<BlobCount; k++){
							if(CCount>=MAX_DEFECT_POINT) break; 
							CDefectPoint[CCount].Width  =  CodeImageSelection.GetElement(k).GetBoundingBoxWidth() ;
							CDefectPoint[CCount].Height =  CodeImageSelection.GetElement(k).GetBoundingBoxHeight();

							CDefectPoint[CCount].Rect.left   =(long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterX() - CDefectPoint[CCount].Width/2 ) +(BtmInLine[2].FP0.x+SideMargin));
							CDefectPoint[CCount].Rect.top    =(long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - CDefectPoint[CCount].Height/2) +(BtmInLine[2].FP0.y-FBtmHeight));
							CDefectPoint[CCount].Rect.right  =(long)(CDefectPoint[CCount].Rect.left+ CDefectPoint[CCount].Width );
							CDefectPoint[CCount].Rect.bottom =(long)(CDefectPoint[CCount].Rect.top + CDefectPoint[CCount].Height);
							PixelCount = 0;
							PixelValue = 0;

							// 내부 Pixel Data 축출 
							for(int n=CDefectPoint[CCount].Rect.top+1 ; n<CDefectPoint[CCount].Rect.bottom-1; n++){
								for(int m=CDefectPoint[CCount].Rect.left+1; m<CDefectPoint[CCount].Rect.right-1 ; m++){
									PixelValue = IElement(m,n);
									if(PixelValue < EnCapBtmThresHold) PixelCount++;
								}
							}
							CDefectPoint[CCount].Round  =  PixelCount;
							CDefectPoint[CCount].P.x    = (float)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterX() - CDefectPoint[CCount].Width/2 ) +(BtmInLine[2].FP0.x+SideMargin));
							CDefectPoint[CCount].P.y    = (float)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - CDefectPoint[CCount].Height/2) +(BtmInLine[2].FP0.y-FBtmHeight));

							// Image Rotate 기준 좌표를 다시 Rotate한다 _ Display 목적 
							if(ImgDegree!=0.0f){
								CDefectPoint[CCount].P = Math.OnRotate(CenterPoint, CDefectPoint[CCount].P, (ImgDegree));
							}
							// Image Rotate 기준 좌표를 회전 이후에 ImageHeight값을 더하여 실제 좌표를 산출한다 
							CDefectPoint[CCount].P.y    =(float)(CDefectPoint[CCount].P.y+ImageHeight);

							// Merge 위해서 데이터 필요함 
							CDefectPoint[CCount].Rect.top    =(long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - CDefectPoint[CCount].Height/2) +(BtmInLine[2].FP0.y-FBtmHeight)+ImageHeight);
							CDefectPoint[CCount].Rect.bottom =(long)(CDefectPoint[CCount].Rect.top + CDefectPoint[CCount].Height);
							CCount++;
						}
					}
				}
				BlobCount =0;

				///////////////////////////////////////////////////////////////////////////////////////////////
				//네번째 Btm영역의 직선라인 기준 검사 
				if(BtmInLine[3].FP0.x!=0 && BtmInLine[3].FP0.y!=0 && BtmInLine[3].FP1.x!=0 && BtmInLine[3].FP1.y!=0){
					DefectROI.SetPlacement((int)(BtmInLine[3].FP0.x+SideMargin),(int)(BtmInLine[3].FP0.y), FLeftWidth, (BtmInLine[3].FP1.y - BtmInLine[3].FP0.y));
					if((BtmInLine[3].FP0.x+SideMargin) <=0          || BtmInLine[3].FP0.y<0            || FLeftWidth<=0          || (BtmInLine[3].FP1.y - BtmInLine[3].FP0.y)< 0          ) return false;
					if((BtmInLine[3].FP0.x+SideMargin) >=ImageWidth || BtmInLine[3].FP0.y>BtmLimitLine || FLeftWidth>=ImageWidth || (BtmInLine[3].FP1.y - BtmInLine[3].FP0.y)>BtmLimitLine) return false;
					if((BtmInLine[3].FP0.x+SideMargin)+FLeftWidth >=ImageWidth || BtmInLine[3].FP0.y+(BtmInLine[3].FP1.y - BtmInLine[3].FP0.y)>BtmLimitLine                               ) return false;
					// Line Position 
					LinePosition = BtmInLine[3].FP0.x+SideMargin;
					// Blob 검사 진행 
					CodeImageSelection.Clear();
					CodeImageEncoder.Encode(DefectROI,CodeImage);
					CodeImageSelection.Clear();
					CodeImageSelection.AddObjects(CodeImage);
					// Blob 필터링 
					CodeImageSelection.RemoveUsingFloatFeature(EFeature_BoundingBoxWidth ,FMinWidth , FMaxWidth  , EDoubleThresholdMode_Outside);
					CodeImageSelection.RemoveUsingFloatFeature(EFeature_BoundingBoxHeight,FMinHeight, FMaxHeight , EDoubleThresholdMode_Outside);
					// 				CodeImageSelection.RemoveUsingIntegerFeature(EFeature_LeftLimit        ,0       , 3          , EDoubleThresholdMode_Outside);
					CodeImageSelection.RemoveUsingIntegerFeature(EFeature_LeftLimit        ,0       , 1          , EDoubleThresholdMode_Outside);

					BlobCount = CodeImageSelection.GetElementCount();
					CodeImageSelection.Sort(EFeature_TopLimit,ESortDirection_Ascending);

					if(BlobCount!=0){
						for(int k=0; k<BlobCount; k++){
							if(DCount>=MAX_DEFECT_POINT) break;
							DDefectPoint[DCount].Width  =  CodeImageSelection.GetElement(k).GetBoundingBoxWidth() ;
							DDefectPoint[DCount].Height =  CodeImageSelection.GetElement(k).GetBoundingBoxHeight();

							DDefectPoint[DCount].Rect.left   =(long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterX() - DDefectPoint[DCount].Width/2 ) +LinePosition );
							DDefectPoint[DCount].Rect.top    =(long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - DDefectPoint[DCount].Height/2)+(BtmInLine[3].FP0.y));
							DDefectPoint[DCount].Rect.right  =(long)(DDefectPoint[DCount].Rect.left+ DDefectPoint[DCount].Width );
							DDefectPoint[DCount].Rect.bottom =(long)(DDefectPoint[DCount].Rect.top + DDefectPoint[DCount].Height);
							PixelCount =0;
							PixelValue =0;

							// 내부 Pixel Data 축출 
							for(int n=DDefectPoint[DCount].Rect.top+1 ; n<DDefectPoint[DCount].Rect.bottom-1; n++){
								for(int m=DDefectPoint[DCount].Rect.left+1; m<DDefectPoint[DCount].Rect.right-1 ; m++){
									PixelValue = IElement(m,n);
									if(PixelValue < EnCapBtmThresHold) PixelCount++;
								}
							}

							DDefectPoint[DCount].Round = PixelCount;
							DDefectPoint[DCount].P.x    =(float)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterX() - DDefectPoint[DCount].Width/2 ) +LinePosition);
							DDefectPoint[DCount].P.y    =(float)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - DDefectPoint[DCount].Height/2)+(BtmInLine[3].FP0.y)+ImageHeight);
							DDefectPoint[DCount].Width  = (InspectMode)?DDefectPoint[DCount].Width: DDefectPoint[DCount].Width+SideMargin;

							// Merge 위해서 데이터 필요함 
							DDefectPoint[DCount].Rect.top    =(long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - DDefectPoint[DCount].Height/2) +(BtmInLine[3].FP0.y)+ImageHeight);
							DDefectPoint[DCount].Rect.bottom =(long)(DDefectPoint[DCount].Rect.top + DDefectPoint[DCount].Height);
							DCount++;
						}
					}
				}
				BlobCount =0;

				///////////////////////////////////////////////////////////////////////////////////////////////
				//다섯번째 Btm영역의 직선라인 기준 검사 
				if(BtmInLine[4].FP0.x!=0 && BtmInLine[4].FP0.y!=0 && BtmInLine[4].FP1.x!=0 && BtmInLine[4].FP1.y!=0){
					DefectROI.SetPlacement((int)(BtmInLine[4].FP0.x+SideMargin), (int)(BtmInLine[4].FP0.y-FBtmHeight),(BtmInLine[4].FP1.x - BtmInLine[4].FP0.x)-(2*SideMargin), FBtmHeight);
					if((BtmInLine[4].FP0.x+SideMargin) <=0          ||(BtmInLine[4].FP0.y-FBtmHeight)<0            || (BtmInLine[4].FP1.x - BtmInLine[4].FP0.x)-(2*SideMargin)<=0          || FBtmHeight< 0          ) return false;
					if((BtmInLine[4].FP0.x+SideMargin) >=ImageWidth ||(BtmInLine[4].FP0.y-FBtmHeight)>BtmLimitLine || (BtmInLine[4].FP1.x - BtmInLine[4].FP0.x)-(2*SideMargin)>=ImageWidth || FBtmHeight>BtmLimitLine) return false;
					if((BtmInLine[4].FP0.x+SideMargin) + (BtmInLine[4].FP1.x - BtmInLine[4].FP0.x)-(2*SideMargin) >=ImageWidth ||(BtmInLine[4].FP0.y-FBtmHeight)+FBtmHeight>BtmLimitLine                             ) return false;
					//Blob 검사 진행함 
					CodeImageSelection.Clear();
					CodeImageEncoder.Encode(DefectROI,CodeImage);
					CodeImageSelection.Clear();
					CodeImageSelection.AddObjects(CodeImage);
					// Blob 필터링 
					CodeImageSelection.RemoveUsingFloatFeature  (EFeature_BoundingBoxWidth ,FMinWidth      , FMaxWidth   , EDoubleThresholdMode_Outside);
					CodeImageSelection.RemoveUsingFloatFeature  (EFeature_BoundingBoxHeight,FMinHeight     , FMaxHeight  , EDoubleThresholdMode_Outside);
					CodeImageSelection.RemoveUsingIntegerFeature(EFeature_BottomLimit      ,FBtmHeight-1   , FBtmHeight+1, EDoubleThresholdMode_Outside);

					BlobCount = CodeImageSelection.GetElementCount();
					CodeImageSelection.Sort(EFeature_LeftLimit ,ESortDirection_Ascending);

					if(BlobCount!=0){
						for(int k=0; k<BlobCount; k++){
							if(CCount>=MAX_DEFECT_POINT) break; 
							CDefectPoint[CCount].Width  =  CodeImageSelection.GetElement(k).GetBoundingBoxWidth() ;
							CDefectPoint[CCount].Height =  CodeImageSelection.GetElement(k).GetBoundingBoxHeight();

							CDefectPoint[CCount].Rect.left   =(long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterX() - CDefectPoint[CCount].Width/2 ) +(BtmInLine[4].FP0.x+SideMargin));
							CDefectPoint[CCount].Rect.top    =(long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - CDefectPoint[CCount].Height/2) +(BtmInLine[4].FP0.y-FBtmHeight));
							CDefectPoint[CCount].Rect.right  =(long)(CDefectPoint[CCount].Rect.left+ CDefectPoint[CCount].Width );
							CDefectPoint[CCount].Rect.bottom =(long)(CDefectPoint[CCount].Rect.top + CDefectPoint[CCount].Height);
							PixelCount = 0;
							PixelValue = 0;

							// 내부 Pixel Data 축출 
							for(int n=CDefectPoint[CCount].Rect.top+1 ; n<CDefectPoint[CCount].Rect.bottom-1; n++){
								for(int m=CDefectPoint[CCount].Rect.left+1; m<CDefectPoint[CCount].Rect.right-1 ; m++){
									PixelValue = IElement(m,n);
									if(PixelValue < EnCapBtmThresHold) PixelCount++;
								}
							}
							CDefectPoint[CCount].Round  =  PixelCount;
							CDefectPoint[CCount].P.x    = (float)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterX() - CDefectPoint[CCount].Width/2 ) +(BtmInLine[4].FP0.x+SideMargin));
							CDefectPoint[CCount].P.y    = (float)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - CDefectPoint[CCount].Height/2) +(BtmInLine[4].FP0.y-FBtmHeight));

							// Image Rotate 기준 좌표를 다시 Rotate한다 _ Display 목적 
							if(ImgDegree!=0.0f){
								CDefectPoint[CCount].P = Math.OnRotate(CenterPoint, CDefectPoint[CCount].P, (ImgDegree));
							}
							// Image Rotate 기준 좌표를 회전 이후에 ImageHeight값을 더하여 실제 좌표를 산출한다 
							CDefectPoint[CCount].P.y    =(float)(CDefectPoint[CCount].P.y+ImageHeight);

							// Merge 위해서 데이터 필요함 
							CDefectPoint[CCount].Rect.top    =(long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - CDefectPoint[CCount].Height/2) +(BtmInLine[4].FP0.y-FBtmHeight)+ImageHeight);
							CDefectPoint[CCount].Rect.bottom =(long)(CDefectPoint[CCount].Rect.top + CDefectPoint[CCount].Height);
							CCount++;
						}
					}
				}
				BlobCount =0;
				/////////////////////////////////////////////////////////////////////////////////////////////
				// Notch부 직선영역 Dark Defect 검사 시퀀스 종료 

				/////////////////////////////////////////////////////////////////////////////////////////////
				// RF_MODEL 직선영역 Dark Defect 검사 시퀀스 시작 
				// 			if(C2CirInEdgeCount==0 && C3CirInEdgeCount==0 && C4CirInEdgeCount==0 && C5CirInEdgeCount==0){
				// 
				// 			}
				/////////////////////////////////////////////////////////////////////////////////////////////
				// RF_MODEL 직선영역 Dark Defect 검사 시퀀스 종료 


				// 연마 후 세정 작업시 물이 들어갈경우 발생하는 불량 검출 목적 
				// 원형 박리불량, 꽃 박리불량 검출 시퀀스.....EnCap영역에서만 검사를 진행함 
				// Notch부 직선영역 Bright Defect 검사 시퀀스 시작 
				if(BrokenThresHold!=0 && !IsMarkBtm){
					// 이미지 변환 
					// 				EasyImage::Threshold(&RotateImg,&DefectImg, BrokenThresHold); 
					DefectROI.Attach(&RotateBrokenImg);
					CodeImageSelection.SetFeretAngle(0.00f);
					CodeImageEncoder.GetGrayscaleSingleThresholdSegmenter().SetWhiteLayerEncoded(true );
					CodeImageEncoder.GetGrayscaleSingleThresholdSegmenter().SetBlackLayerEncoded(false);
					IAddress = RotateBrokenImg.GetImagePtr();

					// TEST 목적 
					FBtmHeight =70;
					// Notch부 직선영역 Dark Defect 검사 시퀀스 시작 
					//첫번째 Btm영역의 직선라인 기준 검사 
					// 				if(BtmInLine[0].FP0.x!=0 && BtmInLine[0].FP0.y!=0 && BtmInLine[0].FP1.x!=0 && BtmInLine[0].FP1.y!=0){
					// 					DefectROI.SetPlacement((int)(BtmInLine[0].FP0.x+SideMargin), (int)(BtmInLine[0].FP0.y-FBtmHeight), (BtmInLine[0].FP1.x - BtmInLine[0].FP0.x)-(2*SideMargin), FBtmHeight);
					// 					if((BtmInLine[0].FP0.x+SideMargin) <=0          ||(BtmInLine[0].FP0.y-FBtmHeight)< 0           || (BtmInLine[0].FP1.x - BtmInLine[0].FP0.x)-(2*SideMargin)<=0          || FBtmHeight< 0          ) return false;
					// 					if((BtmInLine[0].FP0.x+SideMargin) >=ImageWidth ||(BtmInLine[0].FP0.y-FBtmHeight)>BtmLimitLine || (BtmInLine[0].FP1.x - BtmInLine[0].FP0.x)-(2*SideMargin)>=ImageWidth || FBtmHeight>BtmLimitLine) return false;
					// 					if((BtmInLine[0].FP0.x+SideMargin)+((BtmInLine[0].FP1.x - BtmInLine[0].FP0.x)-(2*SideMargin)) >=ImageWidth ||(BtmInLine[0].FP0.y-FBtmHeight)+FBtmHeight>BtmLimitLine                             ) return false;

					// 새로운 Cell박리 검사 목적...점점 소스가 더러워진다..첨부터  알았으면...이따구로 코딩할수 없을텐데...
					// RF Bright 검사 시퀀스 외곽4EdgePoint부분만 Arc연마 가공진행함 
					if(C2CirInEdgeCount==0 && C3CirInEdgeCount==0 && C4CirInEdgeCount==0 && C5CirInEdgeCount==0){
						if(BtmInLine[0].FP0.x!=0 && BtmInLine[0].FP0.y!=0 && BtmInLine[0].FP1.x!=0 && BtmInLine[0].FP1.y!=0){
							DefectROI.SetPlacement((int)(BtmInLine[0].FP0.x)-50, (int)(BtmInLine[0].FP0.y-FBtmHeight), (BtmInLine[0].FP1.x - BtmInLine[0].FP0.x)+100, FBtmHeight);
							if((BtmInLine[0].FP0.x-50) <=0          ||(BtmInLine[0].FP0.y-FBtmHeight)< 0           || ((BtmInLine[0].FP1.x - BtmInLine[0].FP0.x)+100)<=0          || FBtmHeight< 0          ) return false;
							if((BtmInLine[0].FP0.x-50) >=ImageWidth ||(BtmInLine[0].FP0.y-FBtmHeight)>BtmLimitLine || ((BtmInLine[0].FP1.x - BtmInLine[0].FP0.x)+100)>=ImageWidth || FBtmHeight>BtmLimitLine) return false;
							if((BtmInLine[0].FP0.x-50)+((BtmInLine[0].FP1.x - BtmInLine[0].FP0.x)+100) >=ImageWidth ||( BtmInLine[0].FP0.y-FBtmHeight)+FBtmHeight>BtmLimitLine                             ) return false;

							//Blob 검사 진행함 
							CodeImageSelection.Clear();
							CodeImageEncoder.Encode(DefectROI,CodeImage);
							CodeImageSelection.Clear();
							CodeImageSelection.AddObjects(CodeImage);
							// Blob 필터링 
							CodeImageSelection.RemoveUsingFloatFeature  (EFeature_BoundingBoxWidth ,3     , FMaxWidth   , EDoubleThresholdMode_Outside);
							CodeImageSelection.RemoveUsingFloatFeature  (EFeature_BoundingBoxHeight,3     , FMaxHeight  , EDoubleThresholdMode_Outside);
							// 					CodeImageSelection.RemoveUsingIntegerFeature(EFeature_BottomLimit      ,FBtmHeight-1   , FBtmHeight+1, EDoubleThresholdMode_Outside);

							BlobCount = CodeImageSelection.GetElementCount();
							CodeImageSelection.Sort(EFeature_LeftLimit ,ESortDirection_Ascending);

							if(BlobCount!=0){
								for(int k=0; k<BlobCount; k++){
									if(CCrackCount>=MAX_DEFECT_POINT) break; 
									CCrackPoint[CCrackCount].Width  =  CodeImageSelection.GetElement(k).GetBoundingBoxWidth() ;
									CCrackPoint[CCrackCount].Height =  CodeImageSelection.GetElement(k).GetBoundingBoxHeight();

									CCrackPoint[CCrackCount].Rect.left   =(long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterX() - CCrackPoint[CCrackCount].Width/2 ) +(BtmInLine[0].FP0.x)-50);
									CCrackPoint[CCrackCount].Rect.top    =(long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - CCrackPoint[CCrackCount].Height/2) +(BtmInLine[0].FP0.y-FBtmHeight));
									CCrackPoint[CCrackCount].Rect.right  =(long)(CCrackPoint[CCrackCount].Rect.left+ CCrackPoint[CCrackCount].Width );
									CCrackPoint[CCrackCount].Rect.bottom =(long)(CCrackPoint[CCrackCount].Rect.top + CCrackPoint[CCrackCount].Height);
									CCrackPoint[CCrackCount].LineAttach  =(CodeImageSelection.GetElement(k).GetBottomLimit()>(FBtmHeight-5)) ? 1: 0;
									PixelCount = 0;
									PixelValue = 0;

									// 내부 Pixel Data 축출 
									for(int n=CCrackPoint[CCrackCount].Rect.top+1 ; n<CCrackPoint[CCrackCount].Rect.bottom-1; n++){
										for(int m=CCrackPoint[CCrackCount].Rect.left+1; m<CCrackPoint[CCrackCount].Rect.right-1 ; m++){
											PixelValue = IElement(m,n);
											if(PixelValue > BrokenThresHold) PixelCount++;
										}
									}
									CCrackPoint[CCrackCount].Round  =  PixelCount;
									CCrackPoint[CCrackCount].P.x    = (float)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterX() - CCrackPoint[CCrackCount].Width/2 ) +(BtmInLine[0].FP0.x)-50);
									CCrackPoint[CCrackCount].P.y    = (float)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - CCrackPoint[CCrackCount].Height/2) +(BtmInLine[0].FP0.y-FBtmHeight));

									// Image Rotate 기준 좌표를 다시 Rotate한다 _ Display 목적 
									if(ImgDegree!=0.0f){
										CCrackPoint[CCrackCount].P = Math.OnRotate(CenterPoint, CCrackPoint[CCrackCount].P, (ImgDegree));
									}
									// Image Rotate 기준 좌표를 회전 이후에 ImageHeight값을 더하여 실제 좌표를 산출한다 
									CCrackPoint[CCrackCount].P.y    =(float)(CCrackPoint[CCrackCount].P.y+ImageHeight);

									// Merge 위해서 데이터 필요함 
									CCrackPoint[CCrackCount].Rect.top    =(long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - CCrackPoint[CCrackCount].Height/2) +(BtmInLine[0].FP0.y-FBtmHeight)+ImageHeight);
									CCrackPoint[CCrackCount].Rect.bottom =(long)(CCrackPoint[CCrackCount].Rect.top + CCrackPoint[CCrackCount].Height);
									CCrackCount++;
								}
							}
						}
					}
					BlobCount=0;


					if(BtmEdgePoint[0].x!=0 && BtmInLine[0].FP0.y!=0 && BtmEdgePoint[1].x!=0 && BtmInLine[0].FP1.y!=0){
						DefectROI.SetPlacement((int)(BtmEdgePoint[0].x)-50, (int)(BtmInLine[0].FP0.y-FBtmHeight), (BtmEdgePoint[1].x - BtmEdgePoint[0].x)+100, FBtmHeight);
						if((BtmEdgePoint[0].x-50) <=0          ||(BtmInLine[0].FP0.y-FBtmHeight)< 0           || ((BtmEdgePoint[1].x - BtmEdgePoint[0].x)+100)<=0          || FBtmHeight< 0          ) return false;
						if((BtmEdgePoint[0].x-50) >=ImageWidth ||(BtmInLine[0].FP0.y-FBtmHeight)>BtmLimitLine || ((BtmEdgePoint[1].x - BtmEdgePoint[0].x)+100)>=ImageWidth || FBtmHeight>BtmLimitLine) return false;
						if((BtmEdgePoint[0].x-50)+((BtmEdgePoint[1].x - BtmEdgePoint[0].x)) >=ImageWidth ||(BtmInLine[0].FP0.y-FBtmHeight)+FBtmHeight>BtmLimitLine                             ) return false;

						//Blob 검사 진행함 
						CodeImageSelection.Clear();
						CodeImageEncoder.Encode(DefectROI,CodeImage);
						CodeImageSelection.Clear();
						CodeImageSelection.AddObjects(CodeImage);
						// Blob 필터링 
						CodeImageSelection.RemoveUsingFloatFeature  (EFeature_BoundingBoxWidth ,3     , FMaxWidth   , EDoubleThresholdMode_Outside);
						CodeImageSelection.RemoveUsingFloatFeature  (EFeature_BoundingBoxHeight,3     , FMaxHeight  , EDoubleThresholdMode_Outside);
						// 					CodeImageSelection.RemoveUsingIntegerFeature(EFeature_BottomLimit      ,FBtmHeight-1   , FBtmHeight+1, EDoubleThresholdMode_Outside);

						BlobCount = CodeImageSelection.GetElementCount();
						CodeImageSelection.Sort(EFeature_LeftLimit ,ESortDirection_Ascending);

						if(BlobCount!=0){
							for(int k=0; k<BlobCount; k++){
								if(CCrackCount>=MAX_DEFECT_POINT) break; 
								CCrackPoint[CCrackCount].Width  =  CodeImageSelection.GetElement(k).GetBoundingBoxWidth() ;
								CCrackPoint[CCrackCount].Height =  CodeImageSelection.GetElement(k).GetBoundingBoxHeight();

								CCrackPoint[CCrackCount].Rect.left   =(long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterX() - CCrackPoint[CCrackCount].Width/2 ) +(BtmEdgePoint[0].x-50));
								CCrackPoint[CCrackCount].Rect.top    =(long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - CCrackPoint[CCrackCount].Height/2) +(BtmInLine[0].FP0.y-FBtmHeight));
								CCrackPoint[CCrackCount].Rect.right  =(long)(CCrackPoint[CCrackCount].Rect.left+ CCrackPoint[CCrackCount].Width );
								CCrackPoint[CCrackCount].Rect.bottom =(long)(CCrackPoint[CCrackCount].Rect.top + CCrackPoint[CCrackCount].Height);
								CCrackPoint[CCrackCount].LineAttach  =(CodeImageSelection.GetElement(k).GetBottomLimit()>(FBtmHeight-5)) ? 1: 0;
								PixelCount = 0;
								PixelValue = 0;

								// 내부 Pixel Data 축출 
								for(int n=CCrackPoint[CCrackCount].Rect.top+1 ; n<CCrackPoint[CCrackCount].Rect.bottom-1; n++){
									for(int m=CCrackPoint[CCrackCount].Rect.left+1; m<CCrackPoint[CCrackCount].Rect.right-1 ; m++){
										PixelValue = IElement(m,n);
										if(PixelValue > BrokenThresHold) PixelCount++;
									}
								}
								CCrackPoint[CCrackCount].Round  =  PixelCount;
								CCrackPoint[CCrackCount].P.x    = (float)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterX() - CCrackPoint[CCrackCount].Width/2 ) +(BtmEdgePoint[0].x-50));
								CCrackPoint[CCrackCount].P.y    = (float)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - CCrackPoint[CCrackCount].Height/2) +(BtmInLine[0].FP0.y-FBtmHeight));

								// Image Rotate 기준 좌표를 다시 Rotate한다 _ Display 목적 
								if(ImgDegree!=0.0f){
									CCrackPoint[CCrackCount].P = Math.OnRotate(CenterPoint, CCrackPoint[CCrackCount].P, (ImgDegree));
								}
								// Image Rotate 기준 좌표를 회전 이후에 ImageHeight값을 더하여 실제 좌표를 산출한다 
								CCrackPoint[CCrackCount].P.y    =(float)(CCrackPoint[CCrackCount].P.y+ImageHeight);

								// Merge 위해서 데이터 필요함 
								CCrackPoint[CCrackCount].Rect.top    =(long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - CCrackPoint[CCrackCount].Height/2) +(BtmInLine[0].FP0.y-FBtmHeight)+ImageHeight);
								CCrackPoint[CCrackCount].Rect.bottom =(long)(CCrackPoint[CCrackCount].Rect.top + CCrackPoint[CCrackCount].Height);
								CCrackCount++;
							}
						}
					}
					BlobCount =0;

					///////////////////////////////////////////////////////////////////////////////////////////////
					//두번째 Btm영역의 직선라인 기준 검사 
					if(BtmInLine[1].FP0.x!=0 && BtmInLine[1].FP0.y!=0 && BtmInLine[1].FP1.x!=0 && BtmInLine[1].FP1.y!=0){
						DefectROI.SetPlacement((int)(BtmInLine[1].FP0.x-FRightWidth-SideMargin),(int)(BtmInLine[1].FP0.y), FRightWidth,  (BtmInLine[1].FP1.y - BtmInLine[1].FP0.y));
						if((BtmInLine[1].FP0.x-FRightWidth-SideMargin) <=0          || (BtmInLine[1].FP0.y)<0            || FRightWidth<=0          || (BtmInLine[1].FP1.y - BtmInLine[1].FP0.y)<=0          ) return false;
						if((BtmInLine[1].FP0.x-FRightWidth-SideMargin) >=ImageWidth || (BtmInLine[1].FP0.y)>BtmLimitLine || FRightWidth>=ImageWidth || (BtmInLine[1].FP1.y - BtmInLine[1].FP0.y)>BtmLimitLine) return false;
						if((BtmInLine[1].FP0.x-FRightWidth-SideMargin)+ FRightWidth >=ImageWidth ||(BtmInLine[1].FP0.y)+(BtmInLine[1].FP1.y - BtmInLine[1].FP0.y)>BtmLimitLine                               ) return false;

						// Line Position 
						LinePosition = BtmInLine[1].FP0.x-FRightWidth-SideMargin;
						// Blob 검사 진행 
						CodeImageSelection.Clear();
						CodeImageEncoder.Encode(DefectROI,CodeImage);
						CodeImageSelection.Clear();
						CodeImageSelection.AddObjects(CodeImage);
						// Blob 필터링 
						CodeImageSelection.RemoveUsingFloatFeature  (EFeature_BoundingBoxWidth ,3 , FMaxWidth  , EDoubleThresholdMode_Outside);
						CodeImageSelection.RemoveUsingFloatFeature  (EFeature_BoundingBoxHeight,3 , FMaxHeight , EDoubleThresholdMode_Outside);
						// 					CodeImageSelection.RemoveUsingIntegerFeature(EFeature_RightLimit     ,FRightWidth -1            , FRightWidth+1            , EDoubleThresholdMode_Outside);

						BlobCount = CodeImageSelection.GetElementCount();
						CodeImageSelection.Sort(EFeature_TopLimit,ESortDirection_Ascending);

						if(BlobCount!=0){
							for(int k=0; k<BlobCount; k++){
								if(BCount>=MAX_DEFECT_POINT) break;
								BCrackPoint[BCrackCount].Width  = CodeImageSelection.GetElement(k).GetBoundingBoxWidth() ; 
								BCrackPoint[BCrackCount].Height = CodeImageSelection.GetElement(k).GetBoundingBoxHeight();

								BCrackPoint[BCrackCount].Rect.left   =(long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterX() - BCrackPoint[BCrackCount].Width/2 ) +(LinePosition)      );
								BCrackPoint[BCrackCount].Rect.top    =(long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - BCrackPoint[BCrackCount].Height/2) +(BtmInLine[1].FP0.y));
								BCrackPoint[BCrackCount].Rect.right  =(long)(BCrackPoint[BCrackCount].Rect.left+ BCrackPoint[BCrackCount].Width );
								BCrackPoint[BCrackCount].Rect.bottom =(long)(BCrackPoint[BCrackCount].Rect.top + BCrackPoint[BCrackCount].Height);
								BCrackPoint[BCrackCount].LineAttach  =(CodeImageSelection.GetElement(k).GetRightLimit()>(FRightWidth-5)) ? 1: 0;
								PixelCount = 0;
								PixelValue = 0;

								// 내부 Pixel Data 축출 
								for(int n=BCrackPoint[BCrackCount].Rect.top+1 ; n<BCrackPoint[BCrackCount].Rect.bottom-1; n++){
									for(int m=BCrackPoint[BCrackCount].Rect.left+1; m<BCrackPoint[BCrackCount].Rect.right-1 ; m++){
										PixelValue = IElement(m,n);
										if(PixelValue > BrokenThresHold) PixelCount++;
									}
								}
								BCrackPoint[BCrackCount].Round  = PixelCount;
								BCrackPoint[BCrackCount].P.x    =(float)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterX() - BCrackPoint[BCrackCount].Width/2 )+(LinePosition));
								BCrackPoint[BCrackCount].P.y    =(float)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - BCrackPoint[BCrackCount].Height/2)+(BtmInLine[1].FP0.y)+ImageHeight);
								BCrackPoint[BCrackCount].Width  =(InspectMode)? BCrackPoint[BCrackCount].Width: BCrackPoint[BCrackCount].Width+SideMargin;

								// Merge 위해서 데이터 필요함 
								BCrackPoint[BCrackCount].Rect.top    =(long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - BCrackPoint[BCrackCount].Height/2) +(BtmInLine[1].FP0.y)+ImageHeight);
								BCrackPoint[BCrackCount].Rect.bottom =(long)(BCrackPoint[BCrackCount].Rect.top + BCrackPoint[BCrackCount].Height);
								BCrackCount++;
							}
						}
					}
					BlobCount =0;

					///////////////////////////////////////////////////////////////////////////////////////////////
					//세번째 Btm영역의 직선라인 기준 검사 
					// 				if(BtmInLine[2].FP0.x!=0 && BtmInLine[2].FP0.y!=0 && BtmInLine[2].FP1.x!=0 && BtmInLine[2].FP1.y!=0){
					// 					DefectROI.SetPlacement((int)(BtmInLine[2].FP0.x+SideMargin), (int)(BtmInLine[2].FP0.y-FBtmHeight),(BtmInLine[2].FP1.x - BtmInLine[2].FP0.x)-(2*SideMargin), FBtmHeight);
					// 					if((BtmInLine[2].FP0.x+SideMargin) <=0          ||(BtmInLine[2].FP0.y-FBtmHeight)< 0           || (BtmInLine[2].FP1.x - BtmInLine[2].FP0.x)-(2*SideMargin)<=0          || FBtmHeight<0           ) return false;
					// 					if((BtmInLine[2].FP0.x+SideMargin) >=ImageWidth ||(BtmInLine[2].FP0.y-FBtmHeight)>BtmLimitLine || (BtmInLine[2].FP1.x - BtmInLine[2].FP0.x)-(2*SideMargin)>=ImageWidth || FBtmHeight>BtmLimitLine) return false;
					// 					if((BtmInLine[2].FP0.x+SideMargin) +(BtmInLine[2].FP1.x - BtmInLine[2].FP0.x)-(2*SideMargin)>=ImageWidth ||(BtmInLine[2].FP0.y-FBtmHeight)+FBtmHeight>BtmLimitLine                               ) return false;

					if(BtmEdgePoint[4].x!=0 && BtmInLine[2].FP0.y!=0 && BtmEdgePoint[5].x!=0 && BtmInLine[2].FP1.y!=0){
						DefectROI.SetPlacement((int)(BtmEdgePoint[4].x-50), (int)(BtmInLine[2].FP0.y-FBtmHeight),((BtmEdgePoint[5].x - BtmEdgePoint[4].x)+100), FBtmHeight);
						if((BtmEdgePoint[4].x-50) <=0          ||(BtmInLine[2].FP0.y-FBtmHeight)< 0           || ((BtmEdgePoint[5].x - BtmEdgePoint[4].x)+100)<=0		     || FBtmHeight<0           ) return false;
						if((BtmEdgePoint[4].x-50) >=ImageWidth ||(BtmInLine[2].FP0.y-FBtmHeight)>BtmLimitLine || ((BtmEdgePoint[5].x - BtmEdgePoint[4].x)+100)>=ImageWidth || FBtmHeight>BtmLimitLine) return false;
						if((BtmEdgePoint[4].x-50) +((BtmEdgePoint[5].x - BtmEdgePoint[4].x)+20)>=ImageWidth ||(BtmInLine[2].FP0.y-FBtmHeight)+FBtmHeight>BtmLimitLine                               ) return false;

						//Blob 검사 진행함 
						CodeImageSelection.Clear();
						CodeImageEncoder.Encode(DefectROI,CodeImage);
						CodeImageSelection.Clear();
						CodeImageSelection.AddObjects(CodeImage);
						// Blob 필터링 
						CodeImageSelection.RemoveUsingFloatFeature  (EFeature_BoundingBoxWidth ,3, FMaxWidth   , EDoubleThresholdMode_Outside);
						CodeImageSelection.RemoveUsingFloatFeature  (EFeature_BoundingBoxHeight,3, FMaxHeight  , EDoubleThresholdMode_Outside);
						// 					CodeImageSelection.RemoveUsingIntegerFeature(EFeature_BottomLimit      ,FBtmHeight-1   , FBtmHeight+1, EDoubleThresholdMode_Outside);

						BlobCount = CodeImageSelection.GetElementCount();
						CodeImageSelection.Sort(EFeature_LeftLimit ,ESortDirection_Ascending);

						if(BlobCount!=0){
							for(int k=0; k<BlobCount; k++){
								if(CCrackCount>=MAX_DEFECT_POINT) break; 
								CCrackPoint[CCrackCount].Width  =  CodeImageSelection.GetElement(k).GetBoundingBoxWidth() ;
								CCrackPoint[CCrackCount].Height =  CodeImageSelection.GetElement(k).GetBoundingBoxHeight();

								CCrackPoint[CCrackCount].Rect.left   =(long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterX() - CCrackPoint[CCrackCount].Width/2 ) +(BtmEdgePoint[4].x)-50);
								CCrackPoint[CCrackCount].Rect.top    =(long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - CCrackPoint[CCrackCount].Height/2) +(BtmInLine[2].FP0.y-FBtmHeight));
								CCrackPoint[CCrackCount].Rect.right  =(long)(CCrackPoint[CCrackCount].Rect.left+ CCrackPoint[CCrackCount].Width );
								CCrackPoint[CCrackCount].Rect.bottom =(long)(CCrackPoint[CCrackCount].Rect.top + CCrackPoint[CCrackCount].Height);
								CCrackPoint[CCrackCount].LineAttach  =(CodeImageSelection.GetElement(k).GetBottomLimit()>(FBtmHeight-5)) ? 1: 0;
								PixelCount = 0;
								PixelValue = 0;

								// 내부 Pixel Data 축출 
								for(int n=CCrackPoint[CCrackCount].Rect.top+1 ; n<CCrackPoint[CCrackCount].Rect.bottom-1; n++){
									for(int m=CCrackPoint[CCrackCount].Rect.left+1; m<CCrackPoint[CCrackCount].Rect.right-1 ; m++){
										PixelValue = IElement(m,n);
										if(PixelValue > BrokenThresHold) PixelCount++;
									}
								}
								CCrackPoint[CCrackCount].Round  =  PixelCount;
								CCrackPoint[CCrackCount].P.x    = (float)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterX() - CCrackPoint[CCrackCount].Width/2 ) +(BtmEdgePoint[4].x)-50);
								CCrackPoint[CCrackCount].P.y    = (float)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - CCrackPoint[CCrackCount].Height/2) +(BtmInLine[2].FP0.y-FBtmHeight));

								// Image Rotate 기준 좌표를 다시 Rotate한다 _ Display 목적 
								if(ImgDegree!=0.0f){
									CCrackPoint[CCrackCount].P = Math.OnRotate(CenterPoint, CCrackPoint[CCrackCount].P, (ImgDegree));
								}
								// Image Rotate 기준 좌표를 회전 이후에 ImageHeight값을 더하여 실제 좌표를 산출한다 
								CCrackPoint[CCrackCount].P.y    =(float)(CCrackPoint[CCrackCount].P.y+ImageHeight);

								// Merge 위해서 데이터 필요함 
								CCrackPoint[CCrackCount].Rect.top    =(long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - CCrackPoint[CCrackCount].Height/2) +(BtmInLine[2].FP0.y-FBtmHeight)+ImageHeight);
								CCrackPoint[CCrackCount].Rect.bottom =(long)(CCrackPoint[CCrackCount].Rect.top + CCrackPoint[CCrackCount].Height);
								CCrackCount++;
							}
						}
					}
					BlobCount =0;

					///////////////////////////////////////////////////////////////////////////////////////////////
					//네번째 Btm영역의 직선라인 기준 검사 
					if(BtmInLine[3].FP0.x!=0 && BtmInLine[3].FP0.y!=0 && BtmInLine[3].FP1.x!=0 && BtmInLine[3].FP1.y!=0){
						DefectROI.SetPlacement((int)(BtmInLine[3].FP0.x+SideMargin),(int)(BtmInLine[3].FP0.y), FLeftWidth, (BtmInLine[3].FP1.y - BtmInLine[3].FP0.y));
						if((BtmInLine[3].FP0.x+SideMargin) <=0          || BtmInLine[3].FP0.y<0            || FLeftWidth<=0          || (BtmInLine[3].FP1.y - BtmInLine[3].FP0.y)< 0          ) return false;
						if((BtmInLine[3].FP0.x+SideMargin) >=ImageWidth || BtmInLine[3].FP0.y>BtmLimitLine || FLeftWidth>=ImageWidth || (BtmInLine[3].FP1.y - BtmInLine[3].FP0.y)>BtmLimitLine) return false;
						if((BtmInLine[3].FP0.x+SideMargin)+FLeftWidth >=ImageWidth || BtmInLine[3].FP0.y+(BtmInLine[3].FP1.y - BtmInLine[3].FP0.y)>BtmLimitLine                               ) return false;
						// Line Position 
						LinePosition = BtmInLine[3].FP0.x+SideMargin;
						// Blob 검사 진행 
						CodeImageSelection.Clear();
						CodeImageEncoder.Encode(DefectROI,CodeImage);
						CodeImageSelection.Clear();
						CodeImageSelection.AddObjects(CodeImage);
						// Blob 필터링 
						CodeImageSelection.RemoveUsingFloatFeature(EFeature_BoundingBoxWidth ,3, FMaxWidth  , EDoubleThresholdMode_Outside);
						CodeImageSelection.RemoveUsingFloatFeature(EFeature_BoundingBoxHeight,3, FMaxHeight , EDoubleThresholdMode_Outside);
						// 					CodeImageSelection.RemoveUsingIntegerFeature(EFeature_LeftLimit        ,0       , 1          , EDoubleThresholdMode_Outside);

						BlobCount = CodeImageSelection.GetElementCount();
						CodeImageSelection.Sort(EFeature_TopLimit,ESortDirection_Ascending);

						if(BlobCount!=0){
							for(int k=0; k<BlobCount; k++){
								if(DCount>=MAX_DEFECT_POINT) break;
								DCrackPoint[DCrackCount].Width  =  CodeImageSelection.GetElement(k).GetBoundingBoxWidth() ;
								DCrackPoint[DCrackCount].Height =  CodeImageSelection.GetElement(k).GetBoundingBoxHeight();

								DCrackPoint[DCrackCount].Rect.left   =(long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterX() - DCrackPoint[DCrackCount].Width/2 ) +LinePosition );
								DCrackPoint[DCrackCount].Rect.top    =(long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - DCrackPoint[DCrackCount].Height/2)+(BtmInLine[3].FP0.y));
								DCrackPoint[DCrackCount].Rect.right  =(long)(DCrackPoint[DCrackCount].Rect.left+ DCrackPoint[DCrackCount].Width );
								DCrackPoint[DCrackCount].Rect.bottom =(long)(DCrackPoint[DCrackCount].Rect.top + DCrackPoint[DCrackCount].Height);
								DCrackPoint[DCrackCount].LineAttach  =(CodeImageSelection.GetElement(k).GetLeftLimit()<5) ? 1: 0;
								PixelCount =0;
								PixelValue =0;

								// 내부 Pixel Data 축출 
								for(int n=DCrackPoint[DCrackCount].Rect.top+1 ; n<DCrackPoint[DCrackCount].Rect.bottom-1; n++){
									for(int m=DCrackPoint[DCrackCount].Rect.left+1; m<DCrackPoint[DCrackCount].Rect.right-1 ; m++){
										PixelValue = IElement(m,n);
										if(PixelValue > BrokenThresHold) PixelCount++;
									}
								}

								DCrackPoint[DCrackCount].Round = PixelCount;
								DCrackPoint[DCrackCount].P.x    =(float)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterX() - DCrackPoint[DCrackCount].Width/2 ) +LinePosition);
								DCrackPoint[DCrackCount].P.y    =(float)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - DCrackPoint[DCrackCount].Height/2)+(BtmInLine[3].FP0.y)+ImageHeight);
								DCrackPoint[DCrackCount].Width  = (InspectMode)?DCrackPoint[DCrackCount].Width: DCrackPoint[DCrackCount].Width+SideMargin;

								// Merge 위해서 데이터 필요함 
								DCrackPoint[DCrackCount].Rect.top    =(long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - DCrackPoint[DCrackCount].Height/2) +(BtmInLine[3].FP0.y)+ImageHeight);
								DCrackPoint[DCrackCount].Rect.bottom =(long)(DCrackPoint[DCrackCount].Rect.top + DCrackPoint[DCrackCount].Height);
								DCrackCount++;
							}
						}
					}
					BlobCount =0;

					///////////////////////////////////////////////////////////////////////////////////////////////
					//다섯번째 Btm영역의 직선라인 기준 검사 
					// 				if(BtmInLine[4].FP0.x!=0 && BtmInLine[4].FP0.y!=0 && BtmInLine[4].FP1.x!=0 && BtmInLine[4].FP1.y!=0){
					// 					DefectROI.SetPlacement((int)(BtmInLine[4].FP0.x+SideMargin), (int)(BtmInLine[4].FP0.y-FBtmHeight),(BtmInLine[4].FP1.x - BtmInLine[4].FP0.x)-(2*SideMargin), FBtmHeight);
					// 					if((BtmInLine[4].FP0.x+SideMargin) <=0          ||(BtmInLine[4].FP0.y-FBtmHeight)<0            || (BtmInLine[4].FP1.x - BtmInLine[4].FP0.x)-(2*SideMargin)<=0          || FBtmHeight< 0          ) return false;
					// 					if((BtmInLine[4].FP0.x+SideMargin) >=ImageWidth ||(BtmInLine[4].FP0.y-FBtmHeight)>BtmLimitLine || (BtmInLine[4].FP1.x - BtmInLine[4].FP0.x)-(2*SideMargin)>=ImageWidth || FBtmHeight>BtmLimitLine) return false;
					// 					if((BtmInLine[4].FP0.x+SideMargin) + (BtmInLine[4].FP1.x - BtmInLine[4].FP0.x)-(2*SideMargin) >=ImageWidth ||(BtmInLine[4].FP0.y-FBtmHeight)+FBtmHeight>BtmLimitLine                             ) return false;

					if(BtmEdgePoint[8].x!=0 && BtmInLine[4].FP0.y!=0 && BtmEdgePoint[9].x!=0 && BtmInLine[4].FP1.y!=0){
						DefectROI.SetPlacement((int)(BtmEdgePoint[8].x)-50, (int)(BtmInLine[4].FP0.y-FBtmHeight),((BtmEdgePoint[9].x - BtmEdgePoint[8].x)+100), FBtmHeight);
						if((BtmEdgePoint[8].x-50) <=0          ||(BtmInLine[4].FP0.y-FBtmHeight)<0            || ((BtmEdgePoint[9].x - BtmEdgePoint[8].x)+100)<=0          || FBtmHeight< 0          ) return false;
						if((BtmEdgePoint[8].x-50) >=ImageWidth ||(BtmInLine[4].FP0.y-FBtmHeight)>BtmLimitLine || ((BtmEdgePoint[9].x - BtmEdgePoint[8].x)+100)>=ImageWidth || FBtmHeight>BtmLimitLine) return false;
						if((BtmEdgePoint[8].x-50) + ((BtmEdgePoint[9].x - BtmEdgePoint[9].x)-50) >=ImageWidth ||(BtmInLine[4].FP0.y-FBtmHeight)+FBtmHeight>BtmLimitLine                             ) return false;

						//Blob 검사 진행함 
						CodeImageSelection.Clear();
						CodeImageEncoder.Encode(DefectROI,CodeImage);
						CodeImageSelection.Clear();
						CodeImageSelection.AddObjects(CodeImage);
						// Blob 필터링 
						CodeImageSelection.RemoveUsingFloatFeature  (EFeature_BoundingBoxWidth ,3 , FMaxWidth   , EDoubleThresholdMode_Outside);
						CodeImageSelection.RemoveUsingFloatFeature  (EFeature_BoundingBoxHeight,3 , FMaxHeight  , EDoubleThresholdMode_Outside);
						// 					CodeImageSelection.RemoveUsingIntegerFeature(EFeature_BottomLimit      ,FBtmHeight-1   , FBtmHeight+1, EDoubleThresholdMode_Outside);

						BlobCount = CodeImageSelection.GetElementCount();
						CodeImageSelection.Sort(EFeature_LeftLimit ,ESortDirection_Ascending);

						if(BlobCount!=0){
							for(int k=0; k<BlobCount; k++){
								if(CCrackCount>=MAX_DEFECT_POINT) break; 
								CCrackPoint[CCrackCount].Width  =  CodeImageSelection.GetElement(k).GetBoundingBoxWidth() ;
								CCrackPoint[CCrackCount].Height =  CodeImageSelection.GetElement(k).GetBoundingBoxHeight();

								CCrackPoint[CCrackCount].Rect.left   =(long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterX() - CCrackPoint[CCrackCount].Width/2 ) +(BtmEdgePoint[8].x-50));
								CCrackPoint[CCrackCount].Rect.top    =(long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - CCrackPoint[CCrackCount].Height/2) +(BtmInLine[4].FP0.y-FBtmHeight));
								CCrackPoint[CCrackCount].Rect.right  =(long)(CCrackPoint[CCrackCount].Rect.left+ CCrackPoint[CCrackCount].Width );
								CCrackPoint[CCrackCount].Rect.bottom =(long)(CCrackPoint[CCrackCount].Rect.top + CCrackPoint[CCrackCount].Height);
								CCrackPoint[CCrackCount].LineAttach  =(CodeImageSelection.GetElement(k).GetBottomLimit()>(FBtmHeight-5)) ? 1: 0;
								PixelCount = 0;
								PixelValue = 0;

								// 내부 Pixel Data 축출 
								for(int n=CCrackPoint[CCrackCount].Rect.top+1 ; n<CCrackPoint[CCrackCount].Rect.bottom-1; n++){
									for(int m=CCrackPoint[CCrackCount].Rect.left+1; m<CCrackPoint[CCrackCount].Rect.right-1 ; m++){
										PixelValue = IElement(m,n);
										if(PixelValue > BrokenThresHold) PixelCount++;
									}
								}
								CCrackPoint[CCrackCount].Round  =  PixelCount;
								CCrackPoint[CCrackCount].P.x    = (float)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterX() - CCrackPoint[CCrackCount].Width/2 ) +(BtmEdgePoint[8].x-50));
								CCrackPoint[CCrackCount].P.y    = (float)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - CCrackPoint[CCrackCount].Height/2) +(BtmInLine[4].FP0.y-FBtmHeight));

								// Image Rotate 기준 좌표를 다시 Rotate한다 _ Display 목적 
								if(ImgDegree!=0.0f){
									CCrackPoint[CCrackCount].P = Math.OnRotate(CenterPoint, CCrackPoint[CCrackCount].P, (ImgDegree));
								}
								// Image Rotate 기준 좌표를 회전 이후에 ImageHeight값을 더하여 실제 좌표를 산출한다 
								CCrackPoint[CCrackCount].P.y    =(float)(CCrackPoint[CCrackCount].P.y+ImageHeight);

								// Merge 위해서 데이터 필요함 
								CCrackPoint[CCrackCount].Rect.top    =(long)((CodeImageSelection.GetElement(k).GetBoundingBoxCenterY() - CCrackPoint[CCrackCount].Height/2) +(BtmInLine[4].FP0.y-FBtmHeight)+ImageHeight);
								CCrackPoint[CCrackCount].Rect.bottom =(long)(CCrackPoint[CCrackCount].Rect.top + CCrackPoint[CCrackCount].Height);
								CCrackCount++;
							}
						}
					}
					BlobCount =0;
					// Notch부 직선영역 Bright Defect 검사 시퀀스 종료  
				}
			}
			// 이미지 회전 후 화면 디스플레이 조정 및 Cell_Size 데이터 산출 
			////////////////////////////////////////////////////////////////////////////////////////////////
			// 원본 이미지 회전하여 검사 이후 화면에 디스플레이 목적으로 좌표값을 다시 계사한다 
			////////////////////////////////////////////////////////////////////////////////////////////////
			// Cell Size 측정 데이터 넘겨줌(Image 회전 없을경우)
			if(FLBPoint.x!=0.0f && FLBPoint.y!=0.0f && FRBPoint.x!=0.0f && FRBPoint.y!=0.0f){
				LeftEndPos.x     =  FLBPoint.x            ;
				LeftEndPos.y     =  FLBPoint.y+ImageHeight;

				CenterEndPos.x =  BtmOutLine[2].FP0.x + (BtmOutLine[2].FP0.x - BtmOutLine[2].FP1.x)/2; 
				CenterEndPos.y =  (BtmOutLine[2].FP0.y + BtmOutLine[2].FP1.y)/2+ImageHeight; 
			}
			// Notch Cell Height Calc (Image  회전없음)
			if(BtmOutLine[2].FP0.x!=0.0f && BtmOutLine[2].FP0.y!=0.0f && BtmOutLine[2].FP1.x!=0.0f && BtmOutLine[2].FP1.y!=0.0f){
				NotchCenterPos.x =  BtmOutLine[2].FP0.x + (BtmOutLine[2].FP1.x - BtmOutLine[2].FP0.x)/2.0;
				NotchCenterPos.y = (BtmOutLine[2].FP0.y + BtmOutLine[2].FP1.y)/2.0;
				NotchCellSizeHeight = Math.GetLengthFrLineToPoint(FLBPoint, FRBPoint, NotchCenterPos);
			}
			// Notch Cell Width Calc(Image 회전없음)
			////////////////////////////////////////////////////////////////////////////////////////////////
			if(BtmEdgePoint[2].x!=0.0f && BtmEdgePoint[2].y!=0.0f && BtmEdgePoint[7].x!=0.0f && BtmEdgePoint[7].y!=0.0f){
				NotchCellSizeWidth = Math.GetLengthFrPointToPoint((float)BtmEdgePoint[2].x,(float)BtmEdgePoint[2].y, (float)BtmEdgePoint[7].x,(float)BtmEdgePoint[7].y);
			}
			// Center Cell Size Width Calc(Image 회전과 상관없음)
			if(TotalCellSizeWidth!=0.0f && TotalCellSizeCount!=0) CenCellSizeWidth = TotalCellSizeWidth/TotalCellSizeCount;

			if(ImgDegree!=0.0f ){
				FLBPoint    = Math.OnRotate(CenterPoint, FLBPoint     , (ImgDegree));
				FRBPoint    = Math.OnRotate(CenterPoint, FRBPoint     , (ImgDegree));

				// BtmLine 
				Line[3].FP0 = Math.OnRotate(CenterPoint, Line[3].FP0  , (ImgDegree));
				Line[3].FP1 = Math.OnRotate(CenterPoint, Line[3].FP1  , (ImgDegree));

				// LeftOutLine
				LeftOutLine[0].FP0 = Math.OnRotate(CenterPoint, LeftOutLine[0].FP0  , (ImgDegree));
				LeftOutLine[0].FP1 = Math.OnRotate(CenterPoint, LeftOutLine[0].FP1  , (ImgDegree));

				// RightOutLine
				RightOutLine[0].FP0 = Math.OnRotate(CenterPoint, RightOutLine[0].FP0  , (ImgDegree));
				RightOutLine[0].FP1 = Math.OnRotate(CenterPoint, RightOutLine[0].FP1  , (ImgDegree));

				// Cell Size 측정 데이터 넘겨줌(Image 회전 있음)
				if(FLBPoint.x!=0.0f && FLBPoint.y!=0.0f && FRBPoint.x!=0.0f && FRBPoint.y!=0.0f){
					LeftEndPos.x     =  FLBPoint.x            ;
					LeftEndPos.y     =  FLBPoint.y+ImageHeight;
					CenterEndPos.x =  BtmOutLine[2].FP0.x + (BtmOutLine[2].FP0.x - BtmOutLine[2].FP1.x)/2; 
					CenterEndPos.y =  (BtmOutLine[2].FP0.y + BtmOutLine[2].FP1.y)/2+ImageHeight; 
				}

				if(IsCornerBtm){
					FLBBPoint   = Math.OnRotate(CenterPoint, FLBBPoint    , (ImgDegree));
					FLBLPoint   = Math.OnRotate(CenterPoint, FLBLPoint    , (ImgDegree));
					FLBBInPoint = Math.OnRotate(CenterPoint, FLBBInPoint  , (ImgDegree));
					FLBLInPoint = Math.OnRotate(CenterPoint, FLBLInPoint  , (ImgDegree));
					FLBBMeaPoint= Math.OnRotate(CenterPoint, FLBBMeaPoint , (ImgDegree));
					FLBLMeaPoint= Math.OnRotate(CenterPoint, FLBLMeaPoint , (ImgDegree));

					FRBBPoint   = Math.OnRotate(CenterPoint, FRBBPoint    , (ImgDegree));
					FRBRPoint   = Math.OnRotate(CenterPoint, FRBRPoint    , (ImgDegree));
					FRBBInPoint = Math.OnRotate(CenterPoint, FRBBInPoint  , (ImgDegree));
					FRBRInPoint = Math.OnRotate(CenterPoint, FRBRInPoint  , (ImgDegree));
					FRBBMeaPoint= Math.OnRotate(CenterPoint, FRBBMeaPoint , (ImgDegree));
					FRBRMeaPoint= Math.OnRotate(CenterPoint, FRBRMeaPoint , (ImgDegree));

					// Corner Defect 좌표도 각도 적용하여 변경해야함 
					if(C3Count!=0){
						for(int k=0; k<C3Count; k++){
							// Fram기준 Y좌표값으로 원복한다 
							C3DefectPoint[k].P.y = C3DefectPoint[k].P.y - ImageHeight;
							if(C3DefectPoint[k].P.y>0) {
								C3DefectPoint[k].P   = Math.OnRotate(CenterPoint,C3DefectPoint[k].P,(ImgDegree)); 
								C3DefectPoint[k].P.y = C3DefectPoint[k].P.y + ImageHeight;
							}
							else {
								C3DefectPoint[k].P.y = C3DefectPoint[k].P.y + ImageHeight;
							}
						}
					}

					if(C4Count!=0){
						for(int k=0; k<C4Count; k++){
							// Fram기준 Y좌표값으로 원복한다 
							C4DefectPoint[k].P.y = C4DefectPoint[k].P.y - ImageHeight;
							if(C4DefectPoint[k].P.y>0) {
								C4DefectPoint[k].P   = Math.OnRotate(CenterPoint,C4DefectPoint[k].P,(ImgDegree)); 
								C4DefectPoint[k].P.y = C4DefectPoint[k].P.y + ImageHeight;
							}
							else {
								C4DefectPoint[k].P.y = C4DefectPoint[k].P.y + ImageHeight;
							}
						}
					}
				}
				else if(IsCircleBtm){
					// TrackLine 교차점 원본 이미지 기준 회전

					if(FInspectMode==Insp_Track){
						// LeftTrackLine
						LeftTrackLine[0].FP0 = Math.OnRotate(CenterPoint, LeftTrackLine[0].FP0  , (ImgDegree));
						LeftTrackLine[0].FP1 = Math.OnRotate(CenterPoint, LeftTrackLine[0].FP1  , (ImgDegree));

						// RightTrackLine
						RightTrackLine[0].FP0 = Math.OnRotate(CenterPoint, RightTrackLine[0].FP0  , (ImgDegree));
						RightTrackLine[0].FP1 = Math.OnRotate(CenterPoint, RightTrackLine[0].FP1  , (ImgDegree));

						// BtmTrackLine
						BtmTrackLine[0].FP0 = Math.OnRotate(CenterPoint, BtmTrackLine[0].FP0  , (ImgDegree));
						BtmTrackLine[0].FP1 = Math.OnRotate(CenterPoint, BtmTrackLine[0].FP1  , (ImgDegree));

						FTRLBPoint    = Math.OnRotate(CenterPoint, FTRLBPoint     , (ImgDegree));
						FTRRBPoint    = Math.OnRotate(CenterPoint, FTRRBPoint     , (ImgDegree));
					}


					// Btm Line Rotate 
					for(int k=0; k<MAX_BTM_COUNT; k++){
						if(BtmInLine[k].FP0.x ==0.0f || BtmInLine[k].FP0.y ==0.0f || BtmInLine[k].FP1.x ==0.0f || BtmInLine[k].FP1.y ==0.0f) continue;
						if(BtmOutLine[k].FP0.x==0.0f || BtmOutLine[k].FP0.y==0.0f || BtmOutLine[k].FP1.x==0.0f || BtmOutLine[k].FP1.y==0.0f) continue;
						BtmInLine   [k].FP0 = Math.OnRotate(CenterPoint, BtmInLine   [k].FP0,  (ImgDegree));
						BtmInLine   [k].FP1 = Math.OnRotate(CenterPoint, BtmInLine   [k].FP1,  (ImgDegree));
						BtmOutLine  [k].FP0 = Math.OnRotate(CenterPoint, BtmOutLine  [k].FP0,  (ImgDegree));
						BtmOutLine  [k].FP1 = Math.OnRotate(CenterPoint, BtmOutLine  [k].FP1,  (ImgDegree));

						if(FInspectMode==Insp_Track){
							if(BtmStandLine[k].FP0.x==0.0f || BtmStandLine[k].FP0.y==0.0f || BtmStandLine[k].FP1.x==0.0f || BtmStandLine[k].FP1.y==0.0f) continue;
							BtmStandLine[k].FP0 = Math.OnRotate(CenterPoint, BtmStandLine[k].FP0,  (ImgDegree));
							BtmStandLine[k].FP1 = Math.OnRotate(CenterPoint, BtmStandLine[k].FP1,  (ImgDegree));
						}
					}

					// Notch Cell Dis 측정 
					if(BtmOutLine[2].FP0.x!=0.0f && BtmOutLine[2].FP0.y!=0.0f && BtmOutLine[2].FP1.x!=0.0f && BtmOutLine[2].FP1.y!=0.0f){
						NotchCenterPos.x =  BtmOutLine[2].FP0.x + (BtmOutLine[2].FP1.x - BtmOutLine[2].FP0.x)/2.0;
						NotchCenterPos.y = (BtmOutLine[2].FP0.y + BtmOutLine[2].FP1.y)/2.0;
						NotchCellSizeHeight = Math.GetLengthFrLineToPoint(FLBPoint, FRBPoint, NotchCenterPos);
					}

					// Circle Defect Data 
					// Dark Defect Data 
					////////////////////////////////////////////////////////////////////////////////////////////////
					if(C1CirDeftectCnt!=0){
						for(int k=0; k<C1CirDeftectCnt; k++){
							C1CirDefectPoint[k].P.y = C1CirDefectPoint[k].P.y - ImageHeight;
							if(C1CirDefectPoint[k].P.y>0) {
								C1CirDefectPoint[k].P   = Math.OnRotate(CenterPoint,C1CirDefectPoint[k].P,(ImgDegree)); 
								C1CirDefectPoint[k].P.y = C1CirDefectPoint[k].P.y + ImageHeight;
							}
							else {
								C1CirDefectPoint[k].P.y = C1CirDefectPoint[k].P.y + ImageHeight;
							}
						}
					}

					if(C2CirDeftectCnt!=0){
						for(int k=0; k<C2CirDeftectCnt; k++){
							C2CirDefectPoint[k].P.y = C2CirDefectPoint[k].P.y - ImageHeight;
							if(C2CirDefectPoint[k].P.y>0) {
								C2CirDefectPoint[k].P   = Math.OnRotate(CenterPoint,C2CirDefectPoint[k].P,(ImgDegree)); 
								C2CirDefectPoint[k].P.y = C2CirDefectPoint[k].P.y + ImageHeight;
							}
							else {
								C2CirDefectPoint[k].P.y = C2CirDefectPoint[k].P.y + ImageHeight;
							}
						}
					}

					if(C3CirDeftectCnt!=0){
						for(int k=0; k<C3CirDeftectCnt; k++){
							C3CirDefectPoint[k].P.y = C3CirDefectPoint[k].P.y - ImageHeight;
							if(C3CirDefectPoint[k].P.y>0) {
								C3CirDefectPoint[k].P   = Math.OnRotate(CenterPoint,C3CirDefectPoint[k].P,(ImgDegree)); 
								C3CirDefectPoint[k].P.y = C3CirDefectPoint[k].P.y + ImageHeight;
							}
							else {
								C3CirDefectPoint[k].P.y = C3CirDefectPoint[k].P.y + ImageHeight;
							}
						}
					}

					if(C4CirDeftectCnt!=0){
						for(int k=0; k<C4CirDeftectCnt; k++){
							C4CirDefectPoint[k].P.y = C4CirDefectPoint[k].P.y - ImageHeight;
							if(C4CirDefectPoint[k].P.y>0) {
								C4CirDefectPoint[k].P   = Math.OnRotate(CenterPoint,C4CirDefectPoint[k].P,(ImgDegree)); 
								C4CirDefectPoint[k].P.y = C4CirDefectPoint[k].P.y + ImageHeight;
							}
							else {
								C4CirDefectPoint[k].P.y = C4CirDefectPoint[k].P.y + ImageHeight;
							}
						}
					}


					if(C5CirDeftectCnt!=0){
						for(int k=0; k<C5CirDeftectCnt; k++){
							C5CirDefectPoint[k].P.y = C5CirDefectPoint[k].P.y - ImageHeight;
							if(C5CirDefectPoint[k].P.y>0) {
								C5CirDefectPoint[k].P   = Math.OnRotate(CenterPoint,C5CirDefectPoint[k].P,(ImgDegree)); 
								C5CirDefectPoint[k].P.y = C5CirDefectPoint[k].P.y + ImageHeight;
							}
							else {
								C5CirDefectPoint[k].P.y = C5CirDefectPoint[k].P.y + ImageHeight;
							}
						}
					}


					if(C6CirDeftectCnt!=0){
						for(int k=0; k<C6CirDeftectCnt; k++){
							C6CirDefectPoint[k].P.y = C6CirDefectPoint[k].P.y - ImageHeight;
							if(C6CirDefectPoint[k].P.y>0) {
								C6CirDefectPoint[k].P   = Math.OnRotate(CenterPoint,C6CirDefectPoint[k].P,(ImgDegree)); 
								C6CirDefectPoint[k].P.y = C6CirDefectPoint[k].P.y + ImageHeight;
							}
							else {
								C6CirDefectPoint[k].P.y = C6CirDefectPoint[k].P.y + ImageHeight;
							}
						}
					}
					///////////////////////////////////////////////////////////////////////////////////////////////////

					// Circle Defect Data 
					// Bright Defect Data e
					////////////////////////////////////////////////////////////////////////////////////////////////
					if(C1CirCrackCnt!=0){
						for(int k=0; k<C1CirCrackCnt; k++){
							C1CirCrackPoint[k].P.y = C1CirCrackPoint[k].P.y - ImageHeight;
							if(C1CirCrackPoint[k].P.y>0) {
								C1CirCrackPoint[k].P   = Math.OnRotate(CenterPoint,C1CirCrackPoint[k].P,(ImgDegree)); 
								C1CirCrackPoint[k].P.y = C1CirCrackPoint[k].P.y + ImageHeight;
							}
							else {
								C1CirCrackPoint[k].P.y = C1CirCrackPoint[k].P.y + ImageHeight;
							}
						}
					}

					if(C2CirCrackCnt!=0){
						for(int k=0; k<C2CirCrackCnt; k++){
							C2CirCrackPoint[k].P.y = C2CirCrackPoint[k].P.y - ImageHeight;
							if(C2CirCrackPoint[k].P.y>0) {
								C2CirCrackPoint[k].P   = Math.OnRotate(CenterPoint,C2CirCrackPoint[k].P,(ImgDegree)); 
								C2CirCrackPoint[k].P.y = C2CirCrackPoint[k].P.y + ImageHeight;
							}
							else {
								C2CirCrackPoint[k].P.y = C2CirCrackPoint[k].P.y + ImageHeight;
							}
						}
					}

					if(C3CirCrackCnt!=0){
						for(int k=0; k<C3CirCrackCnt; k++){
							C3CirCrackPoint[k].P.y = C3CirCrackPoint[k].P.y - ImageHeight;
							if(C3CirCrackPoint[k].P.y>0) {
								C3CirCrackPoint[k].P   = Math.OnRotate(CenterPoint,C3CirCrackPoint[k].P,(ImgDegree)); 
								C3CirCrackPoint[k].P.y = C3CirCrackPoint[k].P.y + ImageHeight;
							}
							else {
								C3CirCrackPoint[k].P.y = C3CirCrackPoint[k].P.y + ImageHeight;
							}
						}
					}

					if(C4CirCrackCnt!=0){
						for(int k=0; k<C4CirCrackCnt; k++){
							C4CirCrackPoint[k].P.y = C4CirCrackPoint[k].P.y - ImageHeight;
							if(C4CirCrackPoint[k].P.y>0) {
								C4CirCrackPoint[k].P   = Math.OnRotate(CenterPoint,C4CirCrackPoint[k].P,(ImgDegree)); 
								C4CirCrackPoint[k].P.y = C4CirCrackPoint[k].P.y + ImageHeight;
							}
							else {
								C4CirCrackPoint[k].P.y = C4CirCrackPoint[k].P.y + ImageHeight;
							}
						}
					}

					if(C5CirCrackCnt!=0){
						for(int k=0; k<C5CirCrackCnt; k++){
							C5CirCrackPoint[k].P.y = C5CirCrackPoint[k].P.y - ImageHeight;
							if(C5CirCrackPoint[k].P.y>0) {
								C5CirCrackPoint[k].P   = Math.OnRotate(CenterPoint,C5CirCrackPoint[k].P,(ImgDegree)); 
								C5CirCrackPoint[k].P.y = C5CirCrackPoint[k].P.y + ImageHeight;
							}
							else {
								C5CirCrackPoint[k].P.y = C5CirCrackPoint[k].P.y + ImageHeight;
							}
						}
					}

					if(C6CirCrackCnt!=0){
						for(int k=0; k<C6CirCrackCnt; k++){
							C6CirCrackPoint[k].P.y = C6CirCrackPoint[k].P.y - ImageHeight;
							if(C6CirCrackPoint[k].P.y>0) {
								C6CirCrackPoint[k].P   = Math.OnRotate(CenterPoint,C6CirCrackPoint[k].P,(ImgDegree)); 
								C6CirCrackPoint[k].P.y = C6CirCrackPoint[k].P.y + ImageHeight;
							}
							else {
								C6CirCrackPoint[k].P.y = C6CirCrackPoint[k].P.y + ImageHeight;
							}
						}
					}
					/////////////////////////////////////////////////////////////////////////////////////////////////////////

					// C1 Circle Edge Point Rotate 
					if(C1CirStandEdgeCount!=0){
						for(int k=0; k<C1CirStandEdgeCount; k++){
							if(C1CirStandPoint[k].x==0.0f || C1CirStandPoint[k].y==0.0f) continue;
							C1CirStandPoint[k] = Math.OnRotate(CenterPoint, C1CirStandPoint[k], ImgDegree);
						}
					}
					if(C1CirInEdgeCount!=0){
						for(int k=0; k<C1CirInEdgeCount; k++){
							if(C1CirInPoint[k].x==0.0f || C1CirInPoint[k].y==0.0f) continue;
							C1CirInPoint[k] = Math.OnRotate(CenterPoint, C1CirInPoint[k], ImgDegree);
						}
					}
					if(C1CirOutEdgeCount!=0){
						for(int k=0; k<C1CirOutEdgeCount; k++){
							if(C1CirOutPoint[k].x==0.0f || C1CirOutPoint[k].y==0.0f) continue;
							C1CirOutPoint[k] = Math.OnRotate(CenterPoint, C1CirOutPoint[k], ImgDegree);
						}
					}
					if(C1CirCenter     .x!=0.0f && C1CirCenter     .y!=0.0f) C1CirCenter        = Math.OnRotate(CenterPoint, C1CirCenter         , (ImgDegree)); // 외곽 교차점 기준  
					if(RealC1CirCenter .x!=0.0f && RealC1CirCenter .y!=0.0f) RealC1CirCenter    = Math.OnRotate(CenterPoint, RealC1CirCenter     , (ImgDegree)); // Euresys 
					if(CircleFit1Center.x!=0.0f && CircleFit1Center.y!=0.0f) CircleFit1Center   = Math.OnRotate(CenterPoint, CircleFit1Center    , (ImgDegree)); // FAVION

					// C2 Circle Edge Point Rotate 
					if(C2CirStandEdgeCount!=0){
						for(int k=0; k<C2CirStandEdgeCount; k++){
							if(C2CirStandPoint[k].x==0.0f || C2CirStandPoint[k].y==0.0f) continue;
							C2CirStandPoint[k] = Math.OnRotate(CenterPoint, C2CirStandPoint[k], ImgDegree);
						}
					}
					if(C2CirInEdgeCount!=0){
						for(int k=0; k<C2CirInEdgeCount; k++){
							if(C2CirInPoint[k].x==0.0f || C2CirInPoint[k].y==0.0f) continue;
							C2CirInPoint[k] = Math.OnRotate(CenterPoint, C2CirInPoint[k], ImgDegree);
						}
					}
					if(C2CirOutEdgeCount!=0){
						for(int k=0; k<C2CirOutEdgeCount; k++){
							if(C2CirOutPoint[k].x==0.0f || C2CirOutPoint[k].y==0.0f) continue;
							C2CirOutPoint[k] = Math.OnRotate(CenterPoint, C2CirOutPoint[k], ImgDegree);
						}
					}
					if(C2CirCenter     .x!=0.0f && C2CirCenter     .y!=0.0f) C2CirCenter        = Math.OnRotate(CenterPoint, C2CirCenter         , (ImgDegree)); // 외곽 교차점 기준  
					if(RealC2CirCenter .x!=0.0f && RealC2CirCenter .y!=0.0f) RealC2CirCenter    = Math.OnRotate(CenterPoint, RealC2CirCenter     , (ImgDegree));
					if(CircleFit2Center.x!=0.0f && CircleFit2Center.y!=0.0f) CircleFit2Center   = Math.OnRotate(CenterPoint, CircleFit2Center    , (ImgDegree));

					// C3 Circle Edge Point Rotate 
					if(C3CirStandEdgeCount!=0){
						for(int k=0; k<C3CirStandEdgeCount; k++){
							if(C3CirStandPoint[k].x==0.0f || C3CirStandPoint[k].y==0.0f) continue;
							C3CirStandPoint[k] = Math.OnRotate(CenterPoint, C3CirStandPoint[k], ImgDegree);
						}
					}
					if(C3CirInEdgeCount!=0){
						for(int k=0; k<C3CirInEdgeCount; k++){
							if(C3CirInPoint[k].x==0.0f || C3CirInPoint[k].y==0.0f) continue;
							C3CirInPoint[k] = Math.OnRotate(CenterPoint, C3CirInPoint[k], ImgDegree);
						}
					}
					if(C3CirOutEdgeCount!=0){
						for(int k=0; k<C3CirOutEdgeCount; k++){
							if(C3CirOutPoint[k].x==0.0f || C3CirOutPoint[k].y==0.0f) continue;
							C3CirOutPoint[k] = Math.OnRotate(CenterPoint, C3CirOutPoint[k], ImgDegree);
						}
					}
					if(C3CirCenter     .x!=0.0f && C3CirCenter     .y!=0.0f) C3CirCenter        = Math.OnRotate(CenterPoint, C3CirCenter         , (ImgDegree)); // 외곽 교차점 기준  
					if(RealC3CirCenter .x!=0.0f && RealC3CirCenter .y!=0.0f) RealC3CirCenter    = Math.OnRotate(CenterPoint, RealC3CirCenter     , (ImgDegree));
					if(CircleFit3Center.x!=0.0f && CircleFit3Center.y!=0.0f) CircleFit3Center   = Math.OnRotate(CenterPoint, CircleFit3Center    , (ImgDegree));

					// C4 Circle Edge Point Rotate 
					if(C4CirStandEdgeCount!=0){
						for(int k=0; k<C4CirStandEdgeCount; k++){
							if(C4CirStandPoint[k].x==0.0f || C4CirStandPoint[k].y==0.0f) continue;
							C4CirStandPoint[k] = Math.OnRotate(CenterPoint, C4CirStandPoint[k], ImgDegree);
						}
					}
					if(C4CirInEdgeCount!=0){
						for(int k=0; k<C4CirInEdgeCount; k++){
							if(C4CirInPoint[k].x==0.0f || C4CirInPoint[k].y==0.0f) continue;
							C4CirInPoint[k] = Math.OnRotate(CenterPoint, C4CirInPoint[k], ImgDegree);
						}
					}
					if(C4CirOutEdgeCount!=0){
						for(int k=0; k<C4CirOutEdgeCount; k++){
							if(C4CirOutPoint[k].x==0.0f || C4CirOutPoint[k].y==0.0f) continue;
							C4CirOutPoint[k] = Math.OnRotate(CenterPoint, C4CirOutPoint[k], ImgDegree);
						}
					}
					if(C4CirCenter     .x!=0.0f && C4CirCenter     .y!=0.0f) C4CirCenter        = Math.OnRotate(CenterPoint, C4CirCenter         , (ImgDegree)); // 외곽 교차점 기준  
					if(RealC4CirCenter .x!=0.0f && RealC4CirCenter .y!=0.0f) RealC4CirCenter    = Math.OnRotate(CenterPoint, RealC4CirCenter     , (ImgDegree));
					if(CircleFit4Center.x!=0.0f && CircleFit4Center.y!=0.0f) CircleFit4Center   = Math.OnRotate(CenterPoint, CircleFit4Center    , (ImgDegree));

					// C5 Circle Edge Point Rotate 
					if(C5CirStandEdgeCount!=0){
						for(int k=0; k<C5CirStandEdgeCount; k++){
							if(C5CirStandPoint[k].x==0.0f || C5CirStandPoint[k].y==0.0f) continue;
							C5CirStandPoint[k] = Math.OnRotate(CenterPoint, C5CirStandPoint[k], ImgDegree);
						}
					}
					if(C5CirInEdgeCount!=0){
						for(int k=0; k<C5CirInEdgeCount; k++){
							if(C5CirInPoint[k].x==0.0f || C5CirInPoint[k].y==0.0f) continue;
							C5CirInPoint[k] = Math.OnRotate(CenterPoint, C5CirInPoint[k], ImgDegree);
						}
					}
					if(C5CirOutEdgeCount!=0){
						for(int k=0; k<C5CirOutEdgeCount; k++){
							if(C5CirOutPoint[k].x==0.0f || C5CirOutPoint[k].y==0.0f) continue;
							C5CirOutPoint[k] = Math.OnRotate(CenterPoint, C5CirOutPoint[k], ImgDegree);
						}
					}
					if(C5CirCenter     .x!=0.0f && C5CirCenter     .y!=0.0f) C5CirCenter        = Math.OnRotate(CenterPoint, C5CirCenter         , (ImgDegree)); // 외곽 교차점 기준  
					if(RealC5CirCenter .x!=0.0f && RealC5CirCenter .y!=0.0f) RealC5CirCenter    = Math.OnRotate(CenterPoint, RealC5CirCenter     , (ImgDegree));
					if(CircleFit5Center.x!=0.0f && CircleFit5Center.y!=0.0f) CircleFit5Center   = Math.OnRotate(CenterPoint, CircleFit5Center    , (ImgDegree));

					// C6 Circle Edge Point Rotate 
					if(C6CirStandEdgeCount!=0){
						for(int k=0; k<C6CirStandEdgeCount; k++){
							if(C6CirStandPoint[k].x==0.0f || C6CirStandPoint[k].y==0.0f) continue;
							C6CirStandPoint[k] = Math.OnRotate(CenterPoint, C6CirStandPoint[k], ImgDegree);
						}
					}
					if(C6CirInEdgeCount!=0){
						for(int k=0; k<C6CirInEdgeCount; k++){
							if(C6CirInPoint[k].x==0.0f || C6CirInPoint[k].y==0.0f) continue;
							C6CirInPoint[k] = Math.OnRotate(CenterPoint, C6CirInPoint[k], ImgDegree);
						}
					}
					if(C6CirOutEdgeCount!=0){
						for(int k=0; k<C6CirOutEdgeCount; k++){
							if(C6CirOutPoint[k].x==0.0f || C6CirOutPoint[k].y==0.0f) continue;
							C6CirOutPoint[k] = Math.OnRotate(CenterPoint, C6CirOutPoint[k], ImgDegree);
						}
					}
					if(C6CirCenter     .x!=0.0f && C6CirCenter     .y!=0.0f) C6CirCenter        = Math.OnRotate(CenterPoint, C6CirCenter         , (ImgDegree)); // 외곽 교차점 기준  
					if(RealC6CirCenter .x!=0.0f && RealC6CirCenter .y!=0.0f) RealC6CirCenter    = Math.OnRotate(CenterPoint, RealC6CirCenter     , (ImgDegree));
					if(CircleFit6Center.x!=0.0f && CircleFit6Center.y!=0.0f) CircleFit6Center   = Math.OnRotate(CenterPoint, CircleFit6Center    , (ImgDegree));

					// Grind Mark Pos 각도기준 회전해야함 
					if(FInspectMode==Insp_Mark && IsMarkBtm){
						for(int k=0; k<19; k++){
							if(GrindMarkPoint[k].x==0.0f || GrindMarkPoint[k].y==0.0f ) continue;
							GrindMarkPoint   [k] = Math.OnRotate(CenterPoint, GrindMarkPoint[k],ImgDegree);
						}
					}
				}
			}

			// 검사 종료 후 Cell Size 측정함 
			if(LeftStaPos.x!=0.0f && LeftStaPos.y!=0.0f && LeftEndPos.x!=0.0f && LeftEndPos.y!=0.0f){
				LeftCellSizeHeight = Math.GetLengthFrPointToPoint(LeftStaPos, LeftEndPos);
			}
			if(CenterStaPos.x!=0.0f && CenterStaPos.y!=0.0f && CenterEndPos.x!=0.0f && CenterEndPos.y!=0.0f){
				CenCellSizeHeight  = Math.GetLengthFrPointToPoint(CenterStaPos, CenterEndPos);
			}
		}


		// Defect Data Merge 영역별 Merge 및 정리 (외관검사 및 표면검사 둘다 동일 시퀀스)
		// Defect Merge START 
		DefectPointCount = A1CirDeftectCnt+A2CirDeftectCnt+ACount+BCount+CCount+DCount+C1CirDeftectCnt+C2CirDeftectCnt+C3CirDeftectCnt+C4CirDeftectCnt+C5CirDeftectCnt+
			C6CirDeftectCnt+ABurrCount+BBurrCount+CBurrCount+DBurrCount+ACrackCount+BCrackCount+CCrackCount+DCrackCount+A1CirCrackCnt+A2CirCrackCnt+
			C1CirCrackCnt+C2CirCrackCnt+C3CirCrackCnt+C4CirCrackCnt+C5CirCrackCnt+C6CirCrackCnt; // 전체 불량개수 계산

		// Circle_1 불량 Merge 기능 
		if(C1CirDeftectCnt!=0){
			bool IsxMg=false, IsyMg=false, IsInMg=false;
			CRect r1, r2;
			int sort =0;
			int tmpDDefectCount = C1CirDeftectCnt;

			for(int k=0; k<tmpDDefectCount; k++){
				if(C1CirDefectPoint[k].Rect.left==0 && C1CirDefectPoint[k].Rect.top==0 && C1CirDefectPoint[k].Rect.right==0 && C1CirDefectPoint[k].Rect.bottom==0) continue;

				for(int l=k+1; l<k+MgCount; l++ ){
					IsxMg = false; IsyMg = false;
					if(l>(tmpDDefectCount-1)) break;
					if(C1CirDefectPoint[l].Rect.left==0 && C1CirDefectPoint[l].Rect.top==0 && C1CirDefectPoint[k].Rect.right==0 && C1CirDefectPoint[k].Rect.bottom==0) continue;

					r1 = C1CirDefectPoint[k].Rect;
					r2 = C1CirDefectPoint[l].Rect; 

					register int HorDist   = abs((r1.left < r2.left) ?  r2.left - r1.right  : r1.left - r2.right );
					register int VerDist   = abs((r1.top  < r2.top ) ?  r2.top  - r1.bottom : r1.top  - r2.bottom);
					IsInMg    = ((r1.left<=r2.left) && (r1.top<r2.top) && (r1.bottom>r2.bottom) && (r1.right >r2.right))? true: false;

					if(HorDist>xMerge && VerDist>yMerge && !IsInMg ) continue;

					IsxMg = (HorDist<xMerge) ? true: false;
					IsyMg = (VerDist<yMerge) ? true: false;

					if((IsxMg && IsyMg) || IsInMg){
						C1CirDefectPoint[k].Round    += C1CirDefectPoint[l].Round;
						C1CirDefectPoint[k].Rect      = OnMerge(C1CirDefectPoint[k].Rect, C1CirDefectPoint[l].Rect);
						C1CirDefectPoint[k].Width     = C1CirDefectPoint[k].Rect.right  - C1CirDefectPoint[k].Rect.left;
						C1CirDefectPoint[k].Height    = C1CirDefectPoint[k].Rect.bottom - C1CirDefectPoint[k].Rect.top ;
						C1CirDefectPoint[k].Hor_Dis   = C1CirDefectPoint[k].Width ; 
						C1CirDefectPoint[k].Ver_Dis   = C1CirDefectPoint[k].Height;
						C1CirDefectPoint[k].P.x       = (float)(C1CirDefectPoint[k].Rect.left);
						C1CirDefectPoint[k].P.y       = (float)(C1CirDefectPoint[k].Rect.top ); 
						C1CirDefectPoint[l].Rect.left = C1CirDefectPoint[l].Rect.top = C1CirDefectPoint[l].Rect.right = C1CirDefectPoint[l].Rect.bottom =0;
						C1CirDeftectCnt--;
						k=-1;
						break;
					}

				}

			}
			for(int j=0; j<tmpDDefectCount; j++){
				if(C1CirDefectPoint[j].Rect.left==0 && C1CirDefectPoint[j].Rect.top==0 && C1CirDefectPoint[j].Rect.right==0 && C1CirDefectPoint[j].Rect.bottom==0) continue;
				C1CirDefectPoint[sort] = C1CirDefectPoint[j];
				sort++;
			}
		}
		////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

		// Circle_2 불량 Merge 기능 
		if(C2CirDeftectCnt!=0){
			bool IsxMg=false, IsyMg=false, IsInMg=false;
			CRect r1, r2;
			int sort =0;
			int tmpDDefectCount = C2CirDeftectCnt;

			for(int k=0; k<tmpDDefectCount; k++){
				if(C2CirDefectPoint[k].Rect.left==0 && C2CirDefectPoint[k].Rect.top==0 && C2CirDefectPoint[k].Rect.right==0 && C2CirDefectPoint[k].Rect.bottom==0) continue;

				for(int l=k+1; l<k+MgCount; l++ ){
					IsxMg = false; IsyMg = false;
					if(l>(tmpDDefectCount-1)) break;
					if(C2CirDefectPoint[l].Rect.left==0 && C2CirDefectPoint[l].Rect.top==0 && C2CirDefectPoint[k].Rect.right==0 && C2CirDefectPoint[k].Rect.bottom==0) continue;

					r1 = C2CirDefectPoint[k].Rect;
					r2 = C2CirDefectPoint[l].Rect; 

					register int HorDist   = abs((r1.left < r2.left) ?  r2.left - r1.right  : r1.left - r2.right );
					register int VerDist   = abs((r1.top  < r2.top ) ?  r2.top  - r1.bottom : r1.top  - r2.bottom);
					IsInMg    = ((r1.left<=r2.left) && (r1.top<r2.top) && (r1.bottom>r2.bottom) && (r1.right >r2.right))? true: false;

					if(HorDist>xMerge && VerDist>yMerge && !IsInMg ) continue;

					IsxMg = (HorDist<xMerge) ? true: false;
					IsyMg = (VerDist<yMerge) ? true: false;

					if((IsxMg && IsyMg) || IsInMg){
						C2CirDefectPoint[k].Round    += C2CirDefectPoint[l].Round;
						C2CirDefectPoint[k].Rect      = OnMerge(C2CirDefectPoint[k].Rect, C2CirDefectPoint[l].Rect);
						C2CirDefectPoint[k].Width     = C2CirDefectPoint[k].Rect.right  - C2CirDefectPoint[k].Rect.left;
						C2CirDefectPoint[k].Height    = C2CirDefectPoint[k].Rect.bottom - C2CirDefectPoint[k].Rect.top ;
						C2CirDefectPoint[k].Hor_Dis   = C2CirDefectPoint[k].Width ; 
						C2CirDefectPoint[k].Ver_Dis   = C2CirDefectPoint[k].Height;
						C2CirDefectPoint[k].P.x       = (float)(C2CirDefectPoint[k].Rect.left);
						C2CirDefectPoint[k].P.y       = (float)(C2CirDefectPoint[k].Rect.top ); 
						C2CirDefectPoint[l].Rect.left = C2CirDefectPoint[l].Rect.top = C2CirDefectPoint[l].Rect.right = C2CirDefectPoint[l].Rect.bottom =0;
						C2CirDeftectCnt--;
						k=-1;
						break;
					}

				}

			}
			for(int j=0; j<tmpDDefectCount; j++){
				if(C2CirDefectPoint[j].Rect.left==0 && C2CirDefectPoint[j].Rect.top==0 && C2CirDefectPoint[j].Rect.right==0 && C2CirDefectPoint[j].Rect.bottom==0) continue;
				C2CirDefectPoint[sort] = C2CirDefectPoint[j];
				sort++;
			}
		}
		////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

		// Circle_3 불량 Merge 기능 
		if(C3CirDeftectCnt!=0){
			bool IsxMg=false, IsyMg=false, IsInMg=false;
			CRect r1, r2;
			int sort =0;
			int tmpDDefectCount = C3CirDeftectCnt;

			for(int k=0; k<tmpDDefectCount; k++){
				if(C3CirDefectPoint[k].Rect.left==0 && C3CirDefectPoint[k].Rect.top==0 && C3CirDefectPoint[k].Rect.right==0 && C3CirDefectPoint[k].Rect.bottom==0) continue;

				for(int l=k+1; l<k+MgCount; l++ ){
					IsxMg = false; IsyMg = false;
					if(l>(tmpDDefectCount-1)) break;
					if(C3CirDefectPoint[l].Rect.left==0 && C3CirDefectPoint[l].Rect.top==0 && C3CirDefectPoint[k].Rect.right==0 && C3CirDefectPoint[k].Rect.bottom==0) continue;

					r1 = C3CirDefectPoint[k].Rect;
					r2 = C3CirDefectPoint[l].Rect; 

					register int HorDist   = abs((r1.left < r2.left) ?  r2.left - r1.right  : r1.left - r2.right );
					register int VerDist   = abs((r1.top  < r2.top ) ?  r2.top  - r1.bottom : r1.top  - r2.bottom);
					IsInMg    = ((r1.left<=r2.left) && (r1.top<r2.top) && (r1.bottom>r2.bottom) && (r1.right >r2.right))? true: false;

					if(HorDist>xMerge && VerDist>yMerge && !IsInMg ) continue;

					IsxMg = (HorDist<xMerge) ? true: false;
					IsyMg = (VerDist<yMerge) ? true: false;

					if((IsxMg && IsyMg) || IsInMg){
						C3CirDefectPoint[k].Round    += C3CirDefectPoint[l].Round;
						C3CirDefectPoint[k].Rect      = OnMerge(C3CirDefectPoint[k].Rect, C3CirDefectPoint[l].Rect);
						C3CirDefectPoint[k].Width     = C3CirDefectPoint[k].Rect.right  - C3CirDefectPoint[k].Rect.left;
						C3CirDefectPoint[k].Height    = C3CirDefectPoint[k].Rect.bottom - C3CirDefectPoint[k].Rect.top ;
						C3CirDefectPoint[k].Hor_Dis   = C3CirDefectPoint[k].Width ; 
						C3CirDefectPoint[k].Ver_Dis   = C3CirDefectPoint[k].Height;
						C3CirDefectPoint[k].P.x       = (float)(C3CirDefectPoint[k].Rect.left);
						C3CirDefectPoint[k].P.y       = (float)(C3CirDefectPoint[k].Rect.top ); 
						C3CirDefectPoint[l].Rect.left = C3CirDefectPoint[l].Rect.top = C3CirDefectPoint[l].Rect.right = C3CirDefectPoint[l].Rect.bottom =0;
						C3CirDeftectCnt--;
						k=-1;
						break;
					}

				}

			}
			for(int j=0; j<tmpDDefectCount; j++){
				if(C3CirDefectPoint[j].Rect.left==0 && C3CirDefectPoint[j].Rect.top==0 && C3CirDefectPoint[j].Rect.right==0 && C3CirDefectPoint[j].Rect.bottom==0) continue;
				C3CirDefectPoint[sort] = C3CirDefectPoint[j];
				sort++;
			}
		}
		////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

		// Circle_4 불량 Merge 기능 
		if(C4CirDeftectCnt!=0){
			bool IsxMg=false, IsyMg=false, IsInMg=false;
			CRect r1, r2;
			int sort =0;
			int tmpDDefectCount = C4CirDeftectCnt;

			for(int k=0; k<tmpDDefectCount; k++){
				if(C4CirDefectPoint[k].Rect.left==0 && C4CirDefectPoint[k].Rect.top==0 && C4CirDefectPoint[k].Rect.right==0 && C4CirDefectPoint[k].Rect.bottom==0) continue;

				for(int l=k+1; l<k+MgCount; l++ ){
					IsxMg = false; IsyMg = false;
					if(l>(tmpDDefectCount-1)) break;
					if(C4CirDefectPoint[l].Rect.left==0 && C4CirDefectPoint[l].Rect.top==0 && C4CirDefectPoint[k].Rect.right==0 && C4CirDefectPoint[k].Rect.bottom==0) continue;

					r1 = C4CirDefectPoint[k].Rect;
					r2 = C4CirDefectPoint[l].Rect; 

					register int HorDist   = abs((r1.left < r2.left) ?  r2.left - r1.right  : r1.left - r2.right );
					register int VerDist   = abs((r1.top  < r2.top ) ?  r2.top  - r1.bottom : r1.top  - r2.bottom);
					IsInMg    = ((r1.left<=r2.left) && (r1.top<r2.top) && (r1.bottom>r2.bottom) && (r1.right >r2.right))? true: false;

					if(HorDist>xMerge && VerDist>yMerge && !IsInMg ) continue;

					IsxMg = (HorDist<xMerge) ? true: false;
					IsyMg = (VerDist<yMerge) ? true: false;

					if((IsxMg && IsyMg) || IsInMg){
						C4CirDefectPoint[k].Round    += C4CirDefectPoint[l].Round;
						C4CirDefectPoint[k].Rect      = OnMerge(C4CirDefectPoint[k].Rect, C4CirDefectPoint[l].Rect);
						C4CirDefectPoint[k].Width     = C4CirDefectPoint[k].Rect.right  - C4CirDefectPoint[k].Rect.left;
						C4CirDefectPoint[k].Height    = C4CirDefectPoint[k].Rect.bottom - C4CirDefectPoint[k].Rect.top ;
						C4CirDefectPoint[k].Hor_Dis   = C4CirDefectPoint[k].Width ; 
						C4CirDefectPoint[k].Ver_Dis   = C4CirDefectPoint[k].Height;
						C4CirDefectPoint[k].P.x       = (float)(C4CirDefectPoint[k].Rect.left);
						C4CirDefectPoint[k].P.y       = (float)(C4CirDefectPoint[k].Rect.top ); 
						C4CirDefectPoint[l].Rect.left = C4CirDefectPoint[l].Rect.top = C4CirDefectPoint[l].Rect.right = C4CirDefectPoint[l].Rect.bottom =0;
						C4CirDeftectCnt--;
						k=-1;
						break;
					}

				}

			}
			for(int j=0; j<tmpDDefectCount; j++){
				if(C4CirDefectPoint[j].Rect.left==0 && C4CirDefectPoint[j].Rect.top==0 && C4CirDefectPoint[j].Rect.right==0 && C4CirDefectPoint[j].Rect.bottom==0) continue;
				C4CirDefectPoint[sort] = C4CirDefectPoint[j];
				sort++;
			}
		}
		////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

		// Circle_5 불량 Merge 기능 
		if(C5CirDeftectCnt!=0){
			bool IsxMg=false, IsyMg=false, IsInMg=false;
			CRect r1, r2;
			int sort =0;
			int tmpDDefectCount = C5CirDeftectCnt;

			for(int k=0; k<tmpDDefectCount; k++){
				if(C5CirDefectPoint[k].Rect.left==0 && C5CirDefectPoint[k].Rect.top==0 && C5CirDefectPoint[k].Rect.right==0 && C5CirDefectPoint[k].Rect.bottom==0) continue;

				for(int l=k+1; l<k+MgCount; l++ ){
					IsxMg = false; IsyMg = false;
					if(l>(tmpDDefectCount-1)) break;
					if(C5CirDefectPoint[l].Rect.left==0 && C5CirDefectPoint[l].Rect.top==0 && C5CirDefectPoint[k].Rect.right==0 && C5CirDefectPoint[k].Rect.bottom==0) continue;

					r1 = C5CirDefectPoint[k].Rect;
					r2 = C5CirDefectPoint[l].Rect; 

					register int HorDist   = abs((r1.left < r2.left) ?  r2.left - r1.right  : r1.left - r2.right );
					register int VerDist   = abs((r1.top  < r2.top ) ?  r2.top  - r1.bottom : r1.top  - r2.bottom);
					IsInMg    = ((r1.left<=r2.left) && (r1.top<r2.top) && (r1.bottom>r2.bottom) && (r1.right >r2.right))? true: false;

					if(HorDist>xMerge && VerDist>yMerge && !IsInMg ) continue;

					IsxMg = (HorDist<xMerge) ? true: false;
					IsyMg = (VerDist<yMerge) ? true: false;

					if((IsxMg && IsyMg) || IsInMg){
						C5CirDefectPoint[k].Round    += C5CirDefectPoint[l].Round;
						C5CirDefectPoint[k].Rect      = OnMerge(C5CirDefectPoint[k].Rect, C5CirDefectPoint[l].Rect);
						C5CirDefectPoint[k].Width     = C5CirDefectPoint[k].Rect.right  - C5CirDefectPoint[k].Rect.left;
						C5CirDefectPoint[k].Height    = C5CirDefectPoint[k].Rect.bottom - C5CirDefectPoint[k].Rect.top ;
						C5CirDefectPoint[k].Hor_Dis   = C5CirDefectPoint[k].Width ; 
						C5CirDefectPoint[k].Ver_Dis   = C5CirDefectPoint[k].Height;
						C5CirDefectPoint[k].P.x       = (float)(C5CirDefectPoint[k].Rect.left);
						C5CirDefectPoint[k].P.y       = (float)(C5CirDefectPoint[k].Rect.top ); 
						C5CirDefectPoint[l].Rect.left = C5CirDefectPoint[l].Rect.top = C5CirDefectPoint[l].Rect.right = C5CirDefectPoint[l].Rect.bottom =0;
						C5CirDeftectCnt--;
						k=-1;
						break;
					}

				}

			}
			for(int j=0; j<tmpDDefectCount; j++){
				if(C5CirDefectPoint[j].Rect.left==0 && C5CirDefectPoint[j].Rect.top==0 && C5CirDefectPoint[j].Rect.right==0 && C5CirDefectPoint[j].Rect.bottom==0) continue;
				C5CirDefectPoint[sort] = C5CirDefectPoint[j];
				sort++;
			}
		}
		////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

		// Circle_6 불량 Merge 기능 
		if(C6CirDeftectCnt!=0){
			bool IsxMg=false, IsyMg=false, IsInMg=false;
			CRect r1, r2;
			int sort =0;
			int tmpDDefectCount = C6CirDeftectCnt;

			for(int k=0; k<tmpDDefectCount; k++){
				if(C6CirDefectPoint[k].Rect.left==0 && C6CirDefectPoint[k].Rect.top==0 && C6CirDefectPoint[k].Rect.right==0 && C6CirDefectPoint[k].Rect.bottom==0) continue;

				for(int l=k+1; l<k+MgCount; l++ ){
					IsxMg = false; IsyMg = false;
					if(l>(tmpDDefectCount-1)) break;
					if(C6CirDefectPoint[l].Rect.left==0 && C6CirDefectPoint[l].Rect.top==0 && C6CirDefectPoint[k].Rect.right==0 && C6CirDefectPoint[k].Rect.bottom==0) continue;

					r1 = C6CirDefectPoint[k].Rect;
					r2 = C6CirDefectPoint[l].Rect; 

					register int HorDist   = abs((r1.left < r2.left) ?  r2.left - r1.right  : r1.left - r2.right );
					register int VerDist   = abs((r1.top  < r2.top ) ?  r2.top  - r1.bottom : r1.top  - r2.bottom);
					IsInMg    = ((r1.left<=r2.left) && (r1.top<r2.top) && (r1.bottom>r2.bottom) && (r1.right >r2.right))? true: false;

					if(HorDist>xMerge && VerDist>yMerge && !IsInMg ) continue;

					IsxMg = (HorDist<xMerge) ? true: false;
					IsyMg = (VerDist<yMerge) ? true: false;

					if((IsxMg && IsyMg) || IsInMg){
						C6CirDefectPoint[k].Round    += C6CirDefectPoint[l].Round;
						C6CirDefectPoint[k].Rect      = OnMerge(C6CirDefectPoint[k].Rect, C6CirDefectPoint[l].Rect);
						C6CirDefectPoint[k].Width     = C6CirDefectPoint[k].Rect.right  - C6CirDefectPoint[k].Rect.left;
						C6CirDefectPoint[k].Height    = C6CirDefectPoint[k].Rect.bottom - C6CirDefectPoint[k].Rect.top ;
						C6CirDefectPoint[k].Hor_Dis   = C6CirDefectPoint[k].Width ; 
						C6CirDefectPoint[k].Ver_Dis   = C6CirDefectPoint[k].Height;
						C6CirDefectPoint[k].P.x       = (float)(C6CirDefectPoint[k].Rect.left);
						C6CirDefectPoint[k].P.y       = (float)(C6CirDefectPoint[k].Rect.top ); 
						C6CirDefectPoint[l].Rect.left = C6CirDefectPoint[l].Rect.top = C6CirDefectPoint[l].Rect.right = C6CirDefectPoint[l].Rect.bottom =0;
						C6CirDeftectCnt--;
						k=-1;
						break;
					}

				}

			}
			for(int j=0; j<tmpDDefectCount; j++){
				if(C6CirDefectPoint[j].Rect.left==0 && C6CirDefectPoint[j].Rect.top==0 && C6CirDefectPoint[j].Rect.right==0 && C6CirDefectPoint[j].Rect.bottom==0) continue;
				C6CirDefectPoint[sort] = C6CirDefectPoint[j];
				sort++;
			}
		}
		////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


		// Side C Merge (박리불량)
		if(CCrackCount!=0){
			bool IsxMg=false, IsyMg=false, IsInMg=false;
			CRect r1, r2;
			int sort =0;
			int tmpDDefectCount = CCrackCount;

			for(int k=0; k<tmpDDefectCount; k++){
				if(CCrackPoint[k].Rect.left==0 && CCrackPoint[k].Rect.top==0 && CCrackPoint[k].Rect.right==0 && CCrackPoint[k].Rect.bottom==0) continue;

				for(int l=k+1; l<k+MgCount; l++ ){
					IsxMg = false; IsyMg = false;
					if(l>(tmpDDefectCount-1)) break;
					if(CCrackPoint[l].Rect.left==0 && CCrackPoint[l].Rect.top==0 && CCrackPoint[k].Rect.right==0 && CCrackPoint[k].Rect.bottom==0) continue;

					r1 = CCrackPoint[k].Rect;
					r2 = CCrackPoint[l].Rect; 

					register int HorDist   = abs((r1.left < r2.left) ?  r2.left - r1.right  : r1.left - r2.right );
					register int VerDist   = abs((r1.top  < r2.top ) ?  r2.top  - r1.bottom : r1.top  - r2.bottom);
					IsInMg    = ((r1.left<=r2.left) && (r1.top<r2.top) && (r1.bottom>r2.bottom) && (r1.right >r2.right))? true: false;

					if(HorDist>xMerge && VerDist>yMerge && !IsInMg ) continue;

					IsxMg = (HorDist<xMerge) ? true: false;
					IsyMg = (VerDist<yMerge) ? true: false;

					if((IsxMg && IsyMg) || IsInMg){
						CCrackPoint[k].Round    += CCrackPoint[l].Round;
						CCrackPoint[k].Rect      = OnMerge(CCrackPoint[k].Rect, CCrackPoint[l].Rect);
						CCrackPoint[k].Width     = CCrackPoint[k].Rect.right  - CCrackPoint[k].Rect.left;
						CCrackPoint[k].Height    = CCrackPoint[k].Rect.bottom - CCrackPoint[k].Rect.top ;
						CCrackPoint[k].P.x       = (float)(CCrackPoint[k].Rect.left);
						CCrackPoint[k].P.y       = (float)(CCrackPoint[k].Rect.top ); 
						CCrackPoint[l].Rect.left = CCrackPoint[l].Rect.top = CCrackPoint[l].Rect.right = CCrackPoint[l].Rect.bottom =0;
						CCrackCount--;
						k=-1;
						break;
					}

				}

			}
			for(int j=0; j<tmpDDefectCount; j++){
				if(CCrackPoint[j].Rect.left==0 && CCrackPoint[j].Rect.top==0 && CCrackPoint[j].Rect.right==0 && CCrackPoint[j].Rect.bottom==0) continue;
				CCrackPoint[sort] = CCrackPoint[j];
				sort++;
			}
		}

		// Side D Merge (Crack & Chipping)
		if(DCount!=0){
			bool IsxMg=false, IsyMg=false, IsInMg=false;
			CRect r1, r2;
			int sort =0;
			int tmpDDefectCount = DCount;

			for(int k=0; k<tmpDDefectCount; k++){
				if(DDefectPoint[k].Rect.left==0 && DDefectPoint[k].Rect.top==0 && DDefectPoint[k].Rect.right==0 && DDefectPoint[k].Rect.bottom==0) continue;

				for(int l=k+1; l<k+MgCount; l++ ){
					IsxMg = false; IsyMg = false;
					if(l>(tmpDDefectCount-1)) break;
					if(DDefectPoint[l].Rect.left==0 && DDefectPoint[l].Rect.top==0 && DDefectPoint[k].Rect.right==0 && DDefectPoint[k].Rect.bottom==0) continue;

					r1 = DDefectPoint[k].Rect;
					r2 = DDefectPoint[l].Rect; 

					register int HorDist   = abs((r1.left < r2.left) ?  r2.left - r1.right  : r1.left - r2.right );
					register int VerDist   = abs((r1.top  < r2.top ) ?  r2.top  - r1.bottom : r1.top  - r2.bottom);
					IsInMg    = ((r1.left<=r2.left) && (r1.top<r2.top) && (r1.bottom>r2.bottom) && (r1.right >r2.right))? true: false;

					if(HorDist>xMerge && VerDist>yMerge && !IsInMg ) continue;

					IsxMg = (HorDist<xMerge) ? true: false;
					IsyMg = (VerDist<yMerge) ? true: false;

					if((IsxMg && IsyMg) || IsInMg){
						DDefectPoint[k].Round    += DDefectPoint[l].Round;
						DDefectPoint[k].Rect      = OnMerge(DDefectPoint[k].Rect, DDefectPoint[l].Rect);
						DDefectPoint[k].Width     = DDefectPoint[k].Rect.right  - DDefectPoint[k].Rect.left;
						DDefectPoint[k].Height    = DDefectPoint[k].Rect.bottom - DDefectPoint[k].Rect.top ;
						DDefectPoint[k].P.x       = (float)(DDefectPoint[k].Rect.left);
						DDefectPoint[k].P.y       = (float)(DDefectPoint[k].Rect.top ); 
						DDefectPoint[l].Rect.left = DDefectPoint[l].Rect.top = DDefectPoint[l].Rect.right = DDefectPoint[l].Rect.bottom =0;
						DCount--;
						k=-1;
						break;
					}

				}

			}
			for(int j=0; j<tmpDDefectCount; j++){
				if(DDefectPoint[j].Rect.left==0 && DDefectPoint[j].Rect.top==0 && DDefectPoint[j].Rect.right==0 && DDefectPoint[j].Rect.bottom==0) continue;
				DDefectPoint[sort] = DDefectPoint[j];
				sort++;
			}
		}

		// Side D Merge(Burr & Remain)
		if(DBurrCount!=0){
			bool IsxMg=false, IsyMg=false, IsInMg=false;
			CRect r1, r2;
			int sort =0;
			int tmpDDefectCount = DBurrCount;

			for(int k=0; k<tmpDDefectCount; k++){
				if(DBurrPoint[k].Rect.left==0 && DBurrPoint[k].Rect.top==0 && DBurrPoint[k].Rect.right==0 && DBurrPoint[k].Rect.bottom==0) continue;

				for(int l=k+1; l<k+MgCount; l++ ){
					IsxMg = false; IsyMg = false;
					if(l>(tmpDDefectCount-1)) break;
					if(DBurrPoint[l].Rect.left==0 && DBurrPoint[l].Rect.top==0 && DBurrPoint[k].Rect.right==0 && DBurrPoint[k].Rect.bottom==0) continue;

					r1 = DBurrPoint[k].Rect;
					r2 = DBurrPoint[l].Rect; 

					register int HorDist   =abs((r1.left < r2.left) ?  r2.left - r1.right  : r1.left - r2.right );
					register int VerDist   =abs((r1.top  < r2.top ) ?  r2.top  - r1.bottom : r1.top  - r2.bottom);
					IsInMg    = ((r1.left<=r2.left) && (r1.top<r2.top) && (r1.bottom>r2.bottom) && (r1.right >r2.right))? true: false;

					if(HorDist>xMerge && VerDist>yMerge && !IsInMg ) continue;

					IsxMg = (HorDist<xMerge) ? true: false;
					IsyMg = (VerDist<yMerge) ? true: false;

					if((IsxMg && IsyMg) || IsInMg){
						DBurrPoint[k].Round    += DBurrPoint[l].Round;
						DBurrPoint[k].Rect      = OnMerge(DBurrPoint[k].Rect, DBurrPoint[l].Rect);
						DBurrPoint[k].Width     = DBurrPoint[k].Rect.right  - DBurrPoint[k].Rect.left;
						DBurrPoint[k].Height    = DBurrPoint[k].Rect.bottom - DBurrPoint[k].Rect.top ;
						DBurrPoint[k].P.x       = (float)(DBurrPoint[k].Rect.left);
						DBurrPoint[k].P.y       = (float)(DBurrPoint[k].Rect.top ); 
						DBurrPoint[l].Rect.left = DBurrPoint[l].Rect.top = DBurrPoint[l].Rect.right = DBurrPoint[l].Rect.bottom =0;
						DBurrCount--;
						k=-1;
						break;
					}

				}

			}
			for(int j=0; j<tmpDDefectCount; j++){
				if(DBurrPoint[j].Rect.left==0 && DBurrPoint[j].Rect.top==0 && DBurrPoint[j].Rect.right==0 && DBurrPoint[j].Rect.bottom==0) continue;
				DBurrPoint[sort] = DBurrPoint[j];
				sort++;
			}
		}


		// Side B Merge (Crack & Chipping)
		if(BCount!=0){
			bool IsxMg=false, IsyMg=false, IsInMg=false;
			CRect r1, r2;
			int sort =0;
			int tmpBDefectCount = BCount;

			for(int k=0; k<tmpBDefectCount; k++){
				if(BDefectPoint[k].Rect.left==0 && BDefectPoint[k].Rect.top==0 && BDefectPoint[k].Rect.right==0 && BDefectPoint[k].Rect.bottom==0) continue;

				for(int l=k+1; l<k+MgCount; l++ ){
					IsxMg = false; IsyMg = false;
					if(l>(tmpBDefectCount-1)) break;
					if(BDefectPoint[l].Rect.left==0 && BDefectPoint[l].Rect.top==0 && BDefectPoint[k].Rect.right==0 && BDefectPoint[k].Rect.bottom==0) continue;

					r1 = BDefectPoint[k].Rect;
					r2 = BDefectPoint[l].Rect; 

					register int HorDist   = abs((r1.left < r2.left) ?  r2.left - r1.right  : r1.left - r2.right );
					register int VerDist   = abs((r1.top  < r2.top ) ?  r2.top  - r1.bottom : r1.top  - r2.bottom);
					IsInMg    = ((r1.left<r2.left) && (r1.top<r2.top) && (r1.bottom>r2.bottom) && (r1.right >=r2.right))? true: false;

					if(HorDist>xMerge && VerDist>yMerge && !IsInMg ) continue;

					IsxMg = (HorDist<xMerge) ? true: false;
					IsyMg = (VerDist<yMerge) ? true: false;

					if((IsxMg && IsyMg) || IsInMg){
						BDefectPoint[k].Round    += BDefectPoint[l].Round;
						BDefectPoint[k].Rect      = OnMerge(BDefectPoint[k].Rect, BDefectPoint[l].Rect);
						BDefectPoint[k].Width     = BDefectPoint[k].Rect.right  - BDefectPoint[k].Rect.left;
						BDefectPoint[k].Height    = BDefectPoint[k].Rect.bottom - BDefectPoint[k].Rect.top ;
						BDefectPoint[k].P.x       = (float)(BDefectPoint[k].Rect.left);
						BDefectPoint[k].P.y       = (float)(BDefectPoint[k].Rect.top ); 
						BDefectPoint[l].Rect.left = BDefectPoint[l].Rect.top = BDefectPoint[l].Rect.right = BDefectPoint[l].Rect.bottom =0;
						BCount--;
						k=-1;
						break;
					}

				}

			}
			for(int j=0; j<tmpBDefectCount; j++){
				if(BDefectPoint[j].Rect.left==0 && BDefectPoint[j].Rect.top==0 && BDefectPoint[j].Rect.right==0 && BDefectPoint[j].Rect.bottom==0) continue;
				BDefectPoint[sort] = BDefectPoint[j];
				sort++;
			}
		}


		// Side B Merge (Burr & Remain)
		if(BBurrCount!=0){
			bool IsxMg=false, IsyMg=false, IsInMg=false;
			CRect r1, r2;
			int sort =0;
			int tmpBDefectCount = BBurrCount;

			for(int k=0; k<tmpBDefectCount; k++){
				if(BBurrPoint[k].Rect.left==0 && BBurrPoint[k].Rect.top==0 && BBurrPoint[k].Rect.right==0 && BBurrPoint[k].Rect.bottom==0) continue;

				for(int l=k+1; l<k+MgCount; l++ ){
					IsxMg = false; IsyMg = false;
					if(l>(tmpBDefectCount-1)) break;
					if(BBurrPoint[l].Rect.left==0 && BBurrPoint[l].Rect.top==0 && BBurrPoint[k].Rect.right==0 && BBurrPoint[k].Rect.bottom==0) continue;

					r1 = BBurrPoint[k].Rect;
					r2 = BBurrPoint[l].Rect; 

					register int HorDist   = abs((r1.left < r2.left) ?  r2.left - r1.right  : r1.left - r2.right );
					register int VerDist   = abs((r1.top  < r2.top ) ?  r2.top  - r1.bottom : r1.top  - r2.bottom);
					IsInMg    = ((r1.left<r2.left) && (r1.top<r2.top) && (r1.bottom>r2.bottom) && (r1.right >=r2.right))? true: false;

					if(HorDist>xMerge && VerDist>yMerge && !IsInMg ) continue;

					IsxMg = (HorDist<xMerge) ? true: false;
					IsyMg = (VerDist<yMerge) ? true: false;

					if((IsxMg && IsyMg) || IsInMg){
						BBurrPoint[k].Round    += BBurrPoint[l].Round;
						BBurrPoint[k].Rect      = OnMerge(BBurrPoint[k].Rect, BBurrPoint[l].Rect);
						BBurrPoint[k].Width     = BBurrPoint[k].Rect.right  - BBurrPoint[k].Rect.left;
						BBurrPoint[k].Height    = BBurrPoint[k].Rect.bottom - BBurrPoint[k].Rect.top ;
						BBurrPoint[k].P.x       = (float)(BBurrPoint[k].Rect.left);
						BBurrPoint[k].P.y       = (float)(BBurrPoint[k].Rect.top ); 
						BBurrPoint[l].Rect.left = BBurrPoint[l].Rect.top = BBurrPoint[l].Rect.right = BBurrPoint[l].Rect.bottom =0;
						BBurrCount--;
						k=-1;
						break;
					}

				}

			}
			for(int j=0; j<tmpBDefectCount; j++){
				if(BBurrPoint[j].Rect.left==0 && BBurrPoint[j].Rect.top==0 && BBurrPoint[j].Rect.right==0 && BBurrPoint[j].Rect.bottom==0) continue;
				BBurrPoint[sort] = BBurrPoint[j];
				sort++;
			}

		}

		if(!IsCornerTop){
			if(ACount!=0){ // Left 
				bool IsxMg, IsyMg;
				CRect r1, r2;
				int sort =0;
				int tmpBDefectCount = ACount;

				// SIDE A + SIDE D Merge 
				for(int k=0; k<tmpBDefectCount; k++){
					if(ADefectPoint[k].Rect.left==0 && ADefectPoint[k].Rect.top==0 && ADefectPoint[k].Rect.right==0 && ADefectPoint[k].Rect.bottom==0) continue;
					IsxMg = false; IsyMg = false;
					r1 = ADefectPoint[k].Rect;
					r2 = DDefectPoint[0].Rect; 

					register int HorDist   = abs((r1.left < r2.left) ?  r2.left - r1.right  : r1.left - r2.right );
					register int VerDist   = abs((r1.top  < r2.top ) ?  r2.top  - r1.bottom : r1.top  - r2.bottom);

					if(HorDist>xMerge && VerDist>yMerge) continue;

					IsxMg = (HorDist<xMerge) ? true: false;
					IsyMg = (VerDist<yMerge) ? true: false;

					if(IsxMg && IsyMg){
						DDefectPoint[0].Round     = (ADefectPoint[k].Round>DDefectPoint[0].Round) ? ADefectPoint[k].Round :DDefectPoint[0].Round; 
						DDefectPoint[0].Rect      = OnMerge(ADefectPoint[k].Rect, DDefectPoint[0].Rect);
						DDefectPoint[0].Width     = DDefectPoint[0].Rect.right  - DDefectPoint[0].Rect.left;
						DDefectPoint[0].Height    = DDefectPoint[0].Rect.bottom - DDefectPoint[0].Rect.top ;
						ADefectPoint[k].Rect.left = ADefectPoint[k].Rect.top = ADefectPoint[k].Rect.right = ADefectPoint[k].Rect.bottom =0;
						ACount--;
						k=-1;
						//break;
					}
				}

				for(int j=0; j<tmpBDefectCount; j++){
					if(ADefectPoint[j].Rect.left==0 && ADefectPoint[j].Rect.top==0 && ADefectPoint[j].Rect.right==0 && ADefectPoint[j].Rect.bottom==0) continue;
					ADefectPoint[sort] = ADefectPoint[j];
					sort++;
				}
			}

			if(ACount!=0){ // Right 
				bool IsxMg, IsyMg;
				CRect r1, r2;
				int sort =0;
				int tmpBDefectCount = ACount;

				// SIDE A + SIDE B Merge 
				for(int k=0; k<tmpBDefectCount; k++){
					if(ADefectPoint[k].Rect.left==0 && ADefectPoint[k].Rect.top==0 && ADefectPoint[k].Rect.right==0 && ADefectPoint[k].Rect.bottom==0) continue;
					IsxMg = false; IsyMg = false;
					r1 = ADefectPoint[k].Rect;
					r2 = BDefectPoint[0].Rect; 

					register int HorDist   = abs((r1.left < r2.left) ?  r2.left - r1.right  : r1.left - r2.right );
					register int VerDist   = abs((r1.top  < r2.top ) ?  r2.top  - r1.bottom : r1.top  - r2.bottom);

					if(HorDist>xMerge && VerDist>yMerge) continue;

					IsxMg = (HorDist<xMerge) ? true: false;
					IsyMg = (VerDist<yMerge) ? true: false;

					if(IsxMg && IsyMg){
						BDefectPoint[0].Round     = (ADefectPoint[k].Round>BDefectPoint[0].Round) ? ADefectPoint[k].Round :BDefectPoint[0].Round; 
						BDefectPoint[0].Rect      = OnMerge(ADefectPoint[k].Rect, BDefectPoint[0].Rect);
						BDefectPoint[0].Width     = BDefectPoint[0].Rect.right  - BDefectPoint[0].Rect.left;
						BDefectPoint[0].Height    = BDefectPoint[0].Rect.bottom - BDefectPoint[0].Rect.top ;
						ADefectPoint[k].Rect.left = ADefectPoint[k].Rect.top = ADefectPoint[k].Rect.right = ADefectPoint[k].Rect.bottom =0;
						ACount--;
						k=-1;
						//break;
					}
				}

				for(int j=0; j<tmpBDefectCount; j++){
					if(ADefectPoint[j].Rect.left==0 && ADefectPoint[j].Rect.top==0 && ADefectPoint[j].Rect.right==0 && ADefectPoint[j].Rect.bottom==0) continue;
					ADefectPoint[sort] = ADefectPoint[j];
					sort++;
				}
			}
		}
		// Defect Merge END 
		Index = 0;
		return true;
    }
	return false;
}
// void CMultiLineDefect::OnWriteLogFile()
// {
//     CFolder Folder;
// 	CFileUnit FileUnit;
// 	CFile File;
// 	CTime Time = CTime::GetCurrentTime();
// 
// 	CString strData, strTime, Path, Temp;
// 
// 	strData.Format("%04d%02d%02d", Time.GetYear(), Time.GetMonth(), Time.GetDay()    );
// 	strTime.Format("%02d:%02d:%02d", Time.GetHour(), Time.GetMinute(), Time.GetSecond());
//     
// 
//     Path = "E:\\VISION_LOG";
//     if (!FileUnit.ExistDir(Path)) FileUnit.CreateDir(Path);
// 
//     Path    = Path +"\\" + strData;
//     if (!FileUnit.ExistDir(Path)) FileUnit.CreateDir(Path);
// 
//     Path = Path + "\\Result.csv";
// 
// 
//     FILE* fp  = NULL;
// 
// 	if (!FileUnit.FileExist(Path)) {
//         fp = fopen(Path, "a+");
//         CString sDate = "Time";
// 		Temp = sDate+" ,"+"MaxPixel"+" ,"+"ImageHeight"+" ,"+"TotalScore"+" ,"+"BrokenScore"+" ,"+"CrackScore"+" \r\n";
// 		fprintf(fp, Temp);
// 	}
// 	else {
//         fp = fopen(Path, "a+");
// 	}
// 
// 
// 
// 	if (fp==NULL) {
// 			::MessageBox(NULL, "PLEASE CLOSE THE LOG FILE!", "Error", MB_ICONERROR||MB_OK);
// 			return;
// 	}
// 	fprintf(fp, strTime);
// 	fprintf(fp,",%d,%d,%4.2f,%4.2f,%4.2f", 
// 		MaxPixel   , 
// 		ImageHeight, 
// 		TotalScore , 
// 		BrokenScore, 
// 		CrkackScore    
// 	);
// 	fprintf(fp,"\n");
// 	fclose(fp);
// }
int CMultiLineDefect::OnExecute(bool l, bool t, bool r, bool b, bool lt, bool rt, bool rb, bool lb)
{

    int x = IRoi->GetOrgX();
    int y = IRoi->GetOrgY();
    int w = IRoi->GetWidth();
    int h = IRoi->GetHeight();

    int szX = IRoi->GetWidth();
    int szY = IRoi->GetHeight();
    int szBuffer = szX > szY ? szX : szY;

	int nLRoiOffset =0;
	int nRRoiOffset =0;
	int CornerCount =0;
	int ROI_H       =0;
	int ROI_L       =0;

	const int MAX_SIDE     = 8  ;
	//const int BMWidth      = 500;
	const int BMHeight     = 200;
	const int GRWidth      = 250;
	const int GROffset     = 20 ;
	const int ROIOffset    = 10 ;
	const int CornerMargin = 2  ;
// 	const int BMLineMargin = 27 ;
	      int BMWidth      = 0  ;


	if(FCompanyMode==COM_TIANMA) BMWidth =500;
	if(FCompanyMode==COM_KWON  ) BMWidth =300;

	// 시작부분 Broken발생시 
	int LineMargin =30;
	int LineRange  =80;

	// Euresys ROI 
	// Median Filtter 적용 목적 ROI   
	EROIBW8   FilterROI                ;

	// Circle 생성시 필요한 데이터 
	const int   TrackLineMargin = 5    ;
	const int   CirAngleMargin  = 10   ;
	const int   CirCenterMargin = 0    ;
	const float CirCrackMargin  = 30.0f;  
	const float CirOffsetMargin = 7.0f ;

	//Polygon Value Test 
	int   PolygonMarginCnt= 0 ;

	// Circle Notch부 Trench_Width 길이 마진값 
	const int TrenchWidthMargin =2000;

	// ㅏMark Find 검사시 필요한 ROI영역 데이터 
	int GrindRectWidth=0, GrindRectHeight=0;

	// FAVION Circle Fitting 필요한 Data 
	float SampleSize   = 0.0f; //0.5~0.8이하로 입력할것
	float DistDevRatio = 0.15; //0.1~0.25 이하로 입력할것

	//Circle Count,Avg Round 
	int CircleCount      =0   ;
	int EdgeCount        =0   ;
	float Dis            =0   ;
	float AvgCirDis      =0.0f;
	float TotalCirDis    =0.0f;
	double MaxDis        =0.0f;
	double MinDis        =100000.0f; 
	double GrindMeaDis   =0.0f;
	double GrindWidthDis =0.0f;

    //Polygon Algorithm 적용시 OutData,InData 개별 최단거리 계산시 필요한 Count
	int GrindMarkOutCnt=0, GrindMarkInCnt =0; 

	// GOO 20150819
    //if (FDefectPoint != NULL) delete[] FDefectPoint;
    //FDefectPoint = new TFPoint[szBuffer];

    FLeftWall = l;
    FTopWall = t;
    FRightWall = r;
    FBottomWall = b;
    FLeftTop = lt;
    FRightTop = rt;
    FRightBottom = rb;
    FLeftBottom = lb;

	// TOP, BTM Cell_Size, Grind_Size 검사시 필요 변수

    int ImgW = GImage->GetWidth();
    int ImgH = GImage->GetHeight();

    TFPoint LT(0          ,           0);
    TFPoint RT((float)ImgW,           0);
    TFPoint RB((float)ImgW, (float)ImgH);
    TFPoint LB(0          , (float)ImgH);
    TFPoint LSP, LEP                    ;

	ImgDegree        =0.0f;

	for(int k=0; k<4; k++){
		MarkLine[k].FP0.x =0.0f;
        MarkLine[k].FP0.y =0.0f;
		MarkLine[k].FP1.x =0.0f;
		MarkLine[k].FP1.y =0.0f;
	}

	//-------------------------------------------------------

    // Data Init
    FLTPoint.x = 0.0f; //좌측라인과 상단라인의 교차점 좌표
    FLTPoint.y = 0.0f; //좌측라인과 상단라인의 교차점 좌표
    FRTPoint.x = 0.0f; //우측라인과 상단라인의 교차점 좌표
    FRTPoint.y = 0.0f; //우측라인과 상단라인의 교차점 좌표
    FRBPoint.x = 0.0f; //우측라인과 하단라인의 교차점 좌표
    FRBPoint.y = 0.0f; //우측라인과 하단라인의 교차점 좌표
    FLBPoint.x = 0.0f; //좌측라인과 하단라인의 교차점 좌표
    FLBPoint.y = 0.0f; //좌측라인과 하단라인의 교차점 좌표
	
    FLTLPoint.x = 0.0f; //좌측라인과   첫번째 코너 교차점 좌표 
    FLTLPoint.y = 0.0f; //좌측라인과   첫번째 코너 교차점 좌표 
    FLTTPoint.x = 0.0f; //위쪽라인과   첫번째 코너 교차점 좌표 
    FLTTPoint.y = 0.0f; //위쪽라인과   첫번째 코너 교차점 좌표 
    FRTRPoint.x = 0.0f; //우측라인과   두번째 코너 교차점 좌표 
    FRTRPoint.y = 0.0f; //우측라인과   두번째 코너 교차점 좌표 
    FRTTPoint.x = 0.0f; //위쪽라인과   두번째 코너 교차점 좌표 
    FRTTPoint.y = 0.0f; //위쪽라인과   두번째 코너 교차점 좌표 
    FRBRPoint.x = 0.0f; //우측라인과   세번째 코너 교차점 좌표 
    FRBRPoint.y = 0.0f; //우측라인과   세번째 코너 교차점 좌표 
    FRBBPoint.x = 0.0f; //아래쪽라인과 세번째 코너 교차점 좌표 
    FRBBPoint.y = 0.0f; //아래쪽라인과 세번째 코너 교차점 좌표 
    FLBLPoint.x = 0.0f; //좌측라인과   네번째 코너 교차점 좌표 
    FLBLPoint.y = 0.0f; //좌측라인과   네번째 코너 교차점 좌표 
    FLBBPoint.x = 0.0f; //아래쪽라인과 네번째 코너 교차점 좌표 
    FLBBPoint.y = 0.0f; //아래쪽라인과 네번째 코너 교차점 좌표 

	//NOTCH Inspection
	FLTLInPoint.x = 0.0f; //왼쪽라인과   코너 연마안쪽 라인과 교차점 좌표
	FLTLInPoint.y = 0.0f; //왼쪽라인과   코너 연마안쪽 라인과 교차점 좌표
	FLTTInPoint.x = 0.0f; //위쪽라인과   코너 연마안쪽 라인과 교차점 좌표
	FLTTInPoint.y = 0.0f; //위쪽라인과   코너 연마안쪽 라인과 교차점 좌표
	FRTRInPoint.x = 0.0f; //오른쪽라인과 코너 연마안쪽 라인과 교차점 좌표
	FRTRInPoint.y = 0.0f; //오른쪽라인과 코너 연마안쪽 라인과 교차점 좌표
	FRTTInPoint.x = 0.0f; //위쪽라인과   코너 연마안쪽 라인과 교차점 좌표
	FRTTInPoint.y = 0.0f; //위쪽라인과   코너 연마안쪽 라인과 교차점 좌표
	FLBLInPoint.x = 0.0f; //왼쪽라인과   코너 연마안쪽 라인과 교차점 좌표
	FLBLInPoint.y = 0.0f; //왼쪽라인과   코너 연마안쪽 라인과 교차점 좌표
	FLBBInPoint.x = 0.0f; //아래쪽라인과   코너 연마안쪽 라인과 교차점 좌표
	FLBBInPoint.y = 0.0f; //아래쪽라인과   코너 연마안쪽 라인과 교차점 좌표
	FRBRInPoint.x = 0.0f; //오른쪽라인과   코너 연마안쪽 라인과 교차점 좌표
	FRBRInPoint.y = 0.0f; //오른쪽라인과   코너 연마안쪽 라인과 교차점 좌표
	FRBBInPoint.x = 0.0f; //아래쪽라인과   코너 연마안쪽 라인과 교차점 좌표
	FRBBInPoint.y = 0.0f; //아래쪽라인과   코너 연마안쪽 라인과 교차점 좌표

	FLTLMeaPoint.x = 0.0f; //왼쪽라인과   코너 연마량 측정 기준 라인과 교차점 좌표
	FLTLMeaPoint.y = 0.0f; //왼쪽라인과   코너 연마량 측정 기준 라인과 교차점 좌표
	FLTTMeaPoint.x = 0.0f; //위쪽라인과   코너 연마량 측정 기준 라인과 교차점 좌표
	FLTTMeaPoint.y = 0.0f; //위쪽라인과   코너 연마량 측정 기준 라인과 교차점 좌표
	FRTRMeaPoint.x = 0.0f; //오른쪽라인과 코너 연마량 측정 기준 라인과 교차점 좌표
	FRTRMeaPoint.y = 0.0f; //오른쪽라인과 코너 연마량 측정 기준 라인과 교차점 좌표
	FRTTMeaPoint.x = 0.0f; //위쪽라인과   코너 연마량 측정 기준 라인과 교차점 좌표
	FRTTMeaPoint.y = 0.0f; //위쪽라인과   코너 연마량 측정 기준 라인과 교차점 좌표

	FLBLMeaPoint.x = 0.0f; //왼쪽라인과   코너 연마량 측정 기준 라인과 교차점 좌표
	FLBLMeaPoint.y = 0.0f; //왼쪽라인과   코너 연마량 측정 기준 라인과 교차점 좌표
	FLBBMeaPoint.x = 0.0f; //아래쪽라인과   코너 연마량 측정 기준 라인과 교차점 좌표
	FLBBMeaPoint.y = 0.0f; //아래쪽라인과   코너 연마량 측정 기준 라인과 교차점 좌표
	FRBRMeaPoint.x = 0.0f; //오른쪽라인과 코너 연마량 측정 기준 라인과 교차점 좌표
	FRBRMeaPoint.y = 0.0f; //오른쪽라인과 코너 연마량 측정 기준 라인과 교차점 좌표
	FRBBMeaPoint.x = 0.0f; //아래쪽라인과   코너 연마량 측정 기준 라인과 교차점 좌표
	FRBBMeaPoint.y = 0.0f; //아래쪽라인과   코너 연마량 측정 기준 라인과 교차점 좌표

	// Notch Cell Track 교차점 좌표 
	FTRLBPoint.x = 0.0f; //좌측트랙라인과 하단트랙라인의 교차점 좌표
	FTRLBPoint.y = 0.0f; //좌측트랙라인과 하단트랙라인의 교차점 좌표
	FTRRBPoint.x = 0.0f; //우측트랙라인과 하단트랙라인의 교차점 좌표
	FTRRBPoint.y = 0.0f; //우측트랙라인과 하단트랙라인의 교차점 좌표

	// EdgeInspection

	Cell_Size =0.0f;
	GrindSize =0.0f;
	Grind_Spec=0.0f;

	// NOTCH CELL INSPECTION
	Left_Grind_Width  = 0.0f;
	Left_Grind_Mea    = 0.0f;
	Right_Grind_Width = 0.0f;
	Right_Grind_Mea   = 0.0f;
	Btm_Grind_Width   = 0.0f;
// 	Top_Grind_Width   = 0.0f;
// 	Top_Grind_Mea     = 0.0f;

	// Mark에서 TrackLine까지 거리 값 
	float MarkToTrackLineDis1 =0.0f;
	float MarkToTrackLineDis2 =0.0f;

	// 외곽라인에서 TrackLine까지 거리 값 
	float LeftToTrackLineDis1  =0.0f;
	float LeftToTrackLineDis2  =0.0f;
	float RightToTrackLineDis1 =0.0f;
	float RightToTrackLineDis2 =0.0f;

	for(int i=0; i<MAX_SIDE; i++){
		Line[i].FP0.x = 0.0f;
		Line[i].FP0.y = 0.0f;
		Line[i].FP1.x = 0.0f;
		Line[i].FP1.y = 0.0f;
	}

    TFPoint OrgPoint;

	// BtmTrackLine 좌표
	TFPoint LeftBtmTrackPoint (0.0f, 0.0f);
	TFPoint RightBtmTrackPoint(0.0f, 0.0f);
    //int CornerWidth = 100;	//	
    //int CornerHeight =100;

    int Index = 10;

	// ThresHold Image Copy 
	if(GImage->GetImagePtr()){
		BinaryImg.SetSize(GImage->GetWidth(), GImage->GetHeight());
		EasyImage::Oper(EArithmeticLogicOperation_Copy,GImage,&BinaryImg);
	}
	else {
		return false;
	}

    switch (Index) {
        // Find Line
        //----------------------------------------------------------------------
        case 10 :
                 if (FLeftWall) {
					 if(FCompanyMode==COM_TIANMA) { // 천마 검사 시퀀스 
						 EasyImage::Threshold(GImage,&BinaryImg, EThresHold);
						 if(EThresHold==0)        {SingleLine->GImage = GImage;     SingleLine->FThreshold =5 ;}
						 else                     {SingleLine->GImage = &BinaryImg; SingleLine->FThreshold =10;}

						 SingleLine->IRoi->SetOrgX  (IRoi->GetOrgX());
						 SingleLine->IRoi->SetOrgY  (IRoi->GetOrgY());
						 SingleLine->IRoi->SetWidth (IRoi->GetWidth());
						 SingleLine->IRoi->SetHeight(IRoi->GetHeight());
	
						 if(IRoi->GetOrgX()<=0 || IRoi->GetWidth()<=0 || IRoi->GetHeight()<=0){
							 return false;
						 }

						 SingleLine->SetOrientation(orWest);
						 
// 						 if(IRoi->GetHeight()<300) SingleLine->FIncrement =5 ;
// 						 else                      SingleLine->FIncrement =10;

						 if(IRoi->GetHeight()<300) SingleLine->SetIncrement(5 );
						 else                      SingleLine->SetIncrement(10);

						 SingleLine->SetFindLineId(0);
						 SingleLine->OnExecute();
						 Line[0].FP0 = SingleLine->GetResultP0();
						 Line[0].FP1 = SingleLine->GetResultP1();


                         if((Line[0].FP0.x!=0.0f && Line[0].FP0.y!=0.0f && Line[0].FP1.x!=0.0f && Line[0].FP1.y!=0.0f) && (fabs(Line[0].FP0.x - Line[0].FP1.x)<LineMargin)){
								 PreLine[0].FP0.x = Line[0].FP0.x;    PreLine[0].FP1.x = Line[0].FP1.x;       
								 PreLine[0].FP0.y = Line[0].FP0.y;    PreLine[0].FP1.y = Line[0].FP1.y;       
						}
						 //Laege Broken 발생으로 Line을 찾지 못할경우 
						 if(Line[0].FP0.x==0.0f || Line[0].FP0.y==0.0f || Line[0].FP1.x==0.0f || Line[0].FP1.y==0.0f || (fabs(Line[0].FP0.x - Line[0].FP1.x)>LineMargin)){
							 if(PreLine[0].FP0.x==0.0f && PreLine[0].FP0.y==0.0f && PreLine[0].FP1.x==0.0f && PreLine[0].FP1.y==0.0f){// 시작부분 Broken발생으로 데이터가 없는경우 
								 // Mark좌표를 기준으로 라인좌표값을 다시 설정함 
								 ROI_H = IRoi->GetHeight();
								 Line[0].FP0.x = StartLeft;    Line[0].FP0.y = 0.0f        ;
								 Line[0].FP1.x = StartLeft;    Line[0].FP1.y = (float)ROI_H;

								 //Line 데이터를 PreLine에 넘겨준다 
								 PreLine[0].FP0.x = Line[0].FP0.x;    PreLine[0].FP1.x = Line[0].FP1.x;       
								 PreLine[0].FP0.y = Line[0].FP0.y;    PreLine[0].FP1.y = Line[0].FP1.y;       
							 }
							 else {                                                                                                    // 중간부분 Broken발생으로 데이터가 없는경우 
								 // PreLine 데이터를 넘겨줌 
								 Line[0].FP0.x = PreLine[0].FP0.x;  Line[0].FP1.x = PreLine[0].FP1.x;  
								 Line[0].FP0.y = PreLine[0].FP0.y;  Line[0].FP1.y = PreLine[0].FP1.y;  
							 }
						 }
// 						 if((fabs(PreLine[0].FP0.x - Line[0].FP0.x)>LineRange) && (fabs(PreLine[0].FP1.x - Line[0].FP1.x)>LineRange)){ // Broken 수직으로 발생할 경우 
// 							 // PreLine 데이터를 넘겨줌 
// 							 Line[0].FP0.x = PreLine[0].FP0.x;  Line[0].FP1.x = PreLine[0].FP1.x;  
// 							 Line[0].FP0.y = PreLine[0].FP0.y;  Line[0].FP1.y = PreLine[0].FP1.y;  
// 						 }
					 }
					 else if(FCompanyMode==COM_KWON) {           // 광원 검사 시퀀스 
						 EasyImage::Threshold(GImage,&BinaryImg, LeftEdgeThresHold);
						 if(LeftEdgeThresHold==0) {SingleLine->GImage = GImage;     SingleLine->FThreshold =5 ;}
						 else                     {SingleLine->GImage = &BinaryImg; SingleLine->FThreshold =10;}

						 SingleLine->IRoi->SetOrgX  (IRoi->GetOrgX());
						 SingleLine->IRoi->SetOrgY  (IRoi->GetOrgY());
						 SingleLine->IRoi->SetWidth (IRoi->GetWidth());
						 SingleLine->IRoi->SetHeight(IRoi->GetHeight());
						 
						 SingleLine->SetOrientation(orWest);
						 
						 if(IRoi->GetHeight()<350) SingleLine->SetIncrement(5 );
						 else                      SingleLine->SetIncrement(10);
						 SingleLine->SetFindLineId(0);
						 //SingleLine->FThreshold =10;
						 SingleLine->OnExecute();
						 Line[0].FP0 = SingleLine->GetResultP0();
						 Line[0].FP1 = SingleLine->GetResultP1();

						 // LeftLineData 
						 LeftLineData = (float)((Line[0].FP0.x + Line[0].FP1.x)/2.0);

						 if(FShape!=shRectH){ // 광원 검사시 필요한 BMLine Data 취합 
							 if(LeftOffset!=0 && LeftBmLineThresHold!=0){
								   // ThresHold 설정 
								 BMLineImg.SetSize(GImage->GetWidth(), GImage->GetHeight());
								 EasyImage::Oper(EArithmeticLogicOperation_Copy,GImage,&BMLineImg);
								 EasyImage::Threshold(GImage,&BMLineImg, LeftBmLineThresHold);
								 
								 SingleLine->GImage = &BMLineImg;

								 // 영역설정 
								 if(fabs(Line[0].FP0.x - Line[0].FP1.x) > 1){
									 LSP.x = (Line[0].FP0.x + Line[0].FP1.x)/2;
									 LSP.y = 0.0f;
								 }
								 else {
									 LSP = Math.OnIntersect(Line[0].FP0, Line[0].FP1, LT, RT);
								 }

								 // 20160226
								 //Btm, Top 구별하여 Line 찾기 
								 if(IsMarkBtm){ // BTM BMLine 찾기
									 SingleLine->IRoi->SetOrgX  ((int)LSP.x+(LeftOffset/2));
									 SingleLine->IRoi->SetOrgY  (0           );
									 SingleLine->IRoi->SetWidth (BMWidth     );
									 SingleLine->IRoi->SetHeight(ImgH        );
                                     SingleLine->SetEdgeType(0);
								 }
								 else {         // TOP BMLine 찾기 
									 SingleLine->IRoi->SetOrgX  ((int)(LSP.x+LeftOffset)-10);
									 SingleLine->IRoi->SetOrgY  (0           );
									 SingleLine->IRoi->SetWidth (BMWidth     );
									 SingleLine->IRoi->SetHeight(ImgH        );
                                     SingleLine->SetEdgeType(1);
								 }
								 if(LSP.x<=0 || (LSP.x+(LeftOffset/2))<=0 || ((LSP.x+LeftOffset)-10)<=0) return false;

								 SingleLine->SetOrientation(orWest);
								 SingleLine->FIncrement =10;
								 SingleLine->SetFindLineId(0);
								 SingleLine->OnExecute();
								 LeftBMLine[0].FP0 = SingleLine->GetResultP0();
								 LeftBMLine[0].FP1 = SingleLine->GetResultP1();

								 SingleLine->SetEdgeType(2);

								 /*
								 SingleLine->IRoi->SetOrgX  ((int)LSP.x+(LeftOffset/2));
								 SingleLine->IRoi->SetOrgY  (0           );
								 SingleLine->IRoi->SetWidth (BMWidth     );
								 SingleLine->IRoi->SetHeight(ImgH        );

								 if(IsMarkBtm) SingleLine->SetEdgeType(0);
								 else          SingleLine->SetEdgeType(1);


								 if(LSP.x<=0 || (LSP.x+(LeftOffset/2))<=0 || ((LSP.x+LeftOffset)-10)<=0) return false;
								 
								 SingleLine->SetOrientation(orWest);
								 SingleLine->FIncrement =10;
								 SingleLine->SetFindLineId(0);
								 SingleLine->OnExecute();
								 LeftBMLine[0].FP0 = SingleLine->GetResultP0();
								 LeftBMLine[0].FP1 = SingleLine->GetResultP1();

								 // SingleLine Org Parameter 
								 SingleLine->SetEdgeType(2);
								 */

							 }
						 }
					 }
					 else if(FCompanyMode==COM_BOE){ // Left LineSearch 
						 EasyImage::Threshold(GImage,&BinaryImg, EThresHold);
						 if(EThresHold==0)        {SingleLine->GImage = GImage;     SingleLine->FThreshold =5 ;}
						 else                     {SingleLine->GImage = &BinaryImg; SingleLine->FThreshold =10;}

						 SingleLine->IRoi->SetOrgX  (IRoi->GetOrgX());
						 SingleLine->IRoi->SetOrgY  (IRoi->GetOrgY());
						 SingleLine->IRoi->SetWidth (IRoi->GetWidth());
						 SingleLine->IRoi->SetHeight(IRoi->GetHeight());
						 if(IRoi->GetOrgX()<=0 || IRoi->GetWidth()<=0 || IRoi->GetHeight()<=0){
							 return false;
						 }

						 SingleLine->SetOrientation(orWest);

						 if(FShape==shRectHL || FShape==shRectCL) SingleLine->SetIncrement(10 );
						 else                                     SingleLine->SetIncrement(100);

// 						 if(IRoi->GetHeight()<300) SingleLine->SetIncrement(5 );
// 						 else                      SingleLine->SetIncrement(100);

						 SingleLine->SetFindLineId(0);
						 SingleLine->OnExecute();
						 Line[0].FP0 = SingleLine->GetResultP0();
						 Line[0].FP1 = SingleLine->GetResultP1();


						 if((Line[0].FP0.x!=0.0f && Line[0].FP0.y!=0.0f && Line[0].FP1.x!=0.0f && Line[0].FP1.y!=0.0f) && (fabs(Line[0].FP0.x - Line[0].FP1.x)<LineMargin)){
							 PreLine[0].FP0.x = Line[0].FP0.x;    PreLine[0].FP1.x = Line[0].FP1.x;       
							 PreLine[0].FP0.y = Line[0].FP0.y;    PreLine[0].FP1.y = Line[0].FP1.y;       
						 }
						 //Laege Broken 발생으로 Line을 찾지 못할경우 
						 if(Line[0].FP0.x==0.0f || Line[0].FP0.y==0.0f || Line[0].FP1.x==0.0f || Line[0].FP1.y==0.0f || (fabs(Line[0].FP0.x - Line[0].FP1.x)>LineMargin)){
							 if(PreLine[0].FP0.x==0.0f && PreLine[0].FP0.y==0.0f && PreLine[0].FP1.x==0.0f && PreLine[0].FP1.y==0.0f){// 시작부분 Broken발생으로 데이터가 없는경우 
								 // Mark좌표를 기준으로 라인좌표값을 다시 설정함 
								 ROI_H = IRoi->GetHeight();
								 Line[0].FP0.x = StartLeft;    Line[0].FP0.y = 0.0f        ;
								 Line[0].FP1.x = StartLeft;    Line[0].FP1.y = (float)ROI_H;

								 //Line 데이터를 PreLine에 넘겨준다 
								 PreLine[0].FP0.x = Line[0].FP0.x;    PreLine[0].FP1.x = Line[0].FP1.x;       
								 PreLine[0].FP0.y = Line[0].FP0.y;    PreLine[0].FP1.y = Line[0].FP1.y;       
							 }
							 else {                                                                                                    // 중간부분 Broken발생으로 데이터가 없는경우 
								 // PreLine 데이터를 넘겨줌 
								 Line[0].FP0.x = PreLine[0].FP0.x;  Line[0].FP1.x = PreLine[0].FP1.x;  
								 Line[0].FP0.y = PreLine[0].FP0.y;  Line[0].FP1.y = PreLine[0].FP1.y;  
							 }
						 }
					 }
					 else if(FCompanyMode==COM_NOTCH){ // 기본 LeftLine
						 EasyImage::Threshold(GImage,&BinaryImg, LeftEdgeThresHold);
						 if(LeftEdgeThresHold==0) {SingleLine->GImage = GImage;     SingleLine->FThreshold =5 ;}
						 else                     {SingleLine->GImage = &BinaryImg; SingleLine->FThreshold =10;}

						 if(FShape==shRectC){
							 SingleLine->IRoi->SetOrgX  (IRoi->GetOrgX()          );
							 SingleLine->IRoi->SetOrgY  (IRoi->GetOrgY()          );
							 SingleLine->IRoi->SetWidth (IRoi->GetWidth()         );
							 SingleLine->IRoi->SetHeight(FEndLine-CSideCircleHeight);
                             SingleLine->SetIncrement(1);
						 }
						 else if(FShape==shRectH) {
							 if(IsCircleTop){
								 SingleLine->IRoi->SetOrgX  (IRoi->GetOrgX()  );
								 SingleLine->IRoi->SetOrgY  (ASideCircleHeight+50);
								 SingleLine->IRoi->SetWidth (IRoi->GetWidth() );
								 SingleLine->IRoi->SetHeight(ImgH-(ASideCircleHeight+50));
								 SingleLine->SetIncrement(1);
							 }
							 else {
								 SingleLine->IRoi->SetOrgX  (IRoi->GetOrgX()  );
								 SingleLine->IRoi->SetOrgY  (IRoi->GetOrgY()  );
								 SingleLine->IRoi->SetWidth (IRoi->GetWidth() );
								 SingleLine->IRoi->SetHeight(IRoi->GetHeight());
								 SingleLine->SetIncrement(50);
							 }
						 }
						 else {
							 SingleLine->IRoi->SetOrgX  (IRoi->GetOrgX()  );
							 SingleLine->IRoi->SetOrgY  (IRoi->GetOrgY()  );
							 SingleLine->IRoi->SetWidth (IRoi->GetWidth() );
							 SingleLine->IRoi->SetHeight(IRoi->GetHeight());
							 ROI_H = IRoi->GetHeight();
							 if(ROI_H<700)  SingleLine->SetIncrement(50 );
							 else 	        SingleLine->SetIncrement(100);
						 }
						 SingleLine->SetOrientation(orWest);

// 						 if(IRoi->GetHeight()<350) SingleLine->SetIncrement(5 );
// 						 else                      SingleLine->SetIncrement(30);
						 // ORG
// 						 if(FShape==shRectC) Sing%leLine->SetIncrement(5  );
// 						 else                SingleLine->SetIncrement(100);

						 SingleLine->SetFindLineId(0);

						 if(IsMarkBtm) SingleLine->SetEdgeType(0); // Black to White 
						 else          SingleLine->SetEdgeType(1); // White to Black  
// 						 SingleLine->SetEdgeType(0); // Black To White 
						 SingleLine->OnExecute();
						 Line[0].FP0 = SingleLine->GetResultP0();
						 Line[0].FP1 = SingleLine->GetResultP1();

						 // Btm,Top 상관없이 첫번째
						 LeftOutLine[0].FP0.x = Line[0].FP0.x;
						 LeftOutLine[0].FP0.y = Line[0].FP0.y;
						 LeftOutLine[0].FP1.x = Line[0].FP1.x;
						 LeftOutLine[0].FP1.y = Line[0].FP1.y;

						 // LeftOutLine....make OutLine Data 
						 // 현재의 데이터를 넘겨준다 
						 // 검사중 기준라인을 찾지 못할경우 이전데이터 넘겨줘서 기준라인 생성함 
						 if(LeftOutLine[0].FP0.x!=0.0f && LeftOutLine[0].FP0.y!=0.0f && LeftOutLine[0].FP1.x!=0.0f && LeftOutLine[0].FP1.y!=0.0f){
							 PreLeftOutLine[0].FP0.x = LeftOutLine[0].FP0.x;    PreLeftOutLine[0].FP1.x = LeftOutLine[0].FP1.x;       
							 PreLeftOutLine[0].FP0.y = LeftOutLine[0].FP0.y;    PreLeftOutLine[0].FP1.y = LeftOutLine[0].FP1.y;       
						 } // 셀의 상단 시작부터 Broken 발생으로 데이터가 없는경우 
						 else if(LeftOutLine[0].FP0.x==0.0f || LeftOutLine[0].FP0.y==0.0f || LeftOutLine[0].FP1.x==0.0f || LeftOutLine[0].FP1.y==0.0f){
							 if(PreLeftOutLine[0].FP0.x==0.0f && PreLeftOutLine[0].FP0.y==0.0f && PreLeftOutLine[0].FP1.x==0.0f && PreLeftOutLine[0].FP1.y==0.0f){// 시작부분 Broken발생으로 데이터가 없는경우 
								 // Mark좌표를 기준으로 라인좌표값을 다시 설정함 
								 ROI_H = IRoi->GetHeight();
								 ROI_L = IRoi->GetOrgX()  ;
								 LeftOutLine[0].FP0.x = ROI_L;    LeftOutLine[0].FP0.y = 0.0f        ;
								 LeftOutLine[0].FP1.x = ROI_L;    LeftOutLine[0].FP1.y = (float)ROI_H;

								 //Line 데이터를 PreLine에 넘겨준다 
								 PreLeftOutLine[0].FP0.x = LeftOutLine[0].FP0.x;    PreLeftOutLine[0].FP1.x = LeftOutLine[0].FP1.x;       
								 PreLeftOutLine[0].FP0.y = LeftOutLine[0].FP0.y;    PreLeftOutLine[0].FP1.y = LeftOutLine[0].FP1.y;       
							 }
							 else { // 중간부분 Broken발생으로 데이터가 없는경우 
								 // PreLine 데이터를 넘겨줌 
								 LeftOutLine[0].FP0.x = PreLeftOutLine[0].FP0.x;  LeftOutLine[0].FP1.x = PreLeftOutLine[0].FP1.x;  
								 LeftOutLine[0].FP0.y = PreLeftOutLine[0].FP0.y;  LeftOutLine[0].FP1.y = PreLeftOutLine[0].FP1.y;  
							 }
						 }

						 // NOTCH CELL BTM Grind Line Search 
// 						 if(FShape!=shRectH){

						if(IsAllGrind){
							if(IsMarkBtm){ // LeftInLine, LeftTrackLine Search 
								// LeftInLine Search Start 
								EasyImage::Threshold(GImage,&BinaryImg, LeftEdgeThresHold);
								SingleLine->GImage = &BinaryImg;

								// 영역설정 
								if(fabs(LeftOutLine[0].FP0.x - LeftOutLine[0].FP1.x) > 3){
									LSP.x = (LeftOutLine[0].FP0.x + LeftOutLine[0].FP1.x)/2;
									LSP.y = 0.0f;
								}
								else {
									LSP = Math.OnIntersect(LeftOutLine[0].FP0, LeftOutLine[0].FP1, LT, RT);
								}

								SingleLine->IRoi->SetOrgX  ((int)LSP.x+3 );
								SingleLine->IRoi->SetOrgY  (0            );
								SingleLine->IRoi->SetWidth (100          );
								SingleLine->IRoi->SetHeight(ImgH         );

								if(((LSP.x+3)<=0) || ImgH<=0) return false;

								// 								if(IRoi->GetHeight()<300) SingleLine->SetIncrement(5 );
								// 								else                      SingleLine->SetIncrement(100);

								if(FShape==shRectC) SingleLine->SetIncrement(5 );
								else                SingleLine->SetIncrement(30);

								// 연마량 측정 OutLine
								SingleLine->SetFindLineId(0);
								SingleLine->SetOrientation(orWest);
								SingleLine->SetEdgeType(0); // Black to White 
								SingleLine->OnExecute();
								LeftInLine[0].FP0 = SingleLine->GetResultP0();
								LeftInLine[0].FP1 = SingleLine->GetResultP1();

								SingleLine->SetEdgeType(2); // Line Search Org 

								// LeftInLine None....make InLine Data 
								// 현재의 데이터를 넘겨준다 
								if(LeftInLine[0].FP0.x!=0.0f && LeftInLine[0].FP0.y!=0.0f && LeftInLine[0].FP1.x!=0.0f && LeftInLine[0].FP1.y!=0.0f){
									PreLeftInLine[0].FP0.x = LeftInLine[0].FP0.x;    PreLeftInLine[0].FP1.x = LeftInLine[0].FP1.x;       
									PreLeftInLine[0].FP0.y = LeftInLine[0].FP0.y;    PreLeftInLine[0].FP1.y = LeftInLine[0].FP1.y;       
								}
								else if(LeftInLine[0].FP0.x==0.0f || LeftInLine[0].FP0.y==0.0f || LeftInLine[0].FP1.x==0.0f || LeftInLine[0].FP1.y==0.0f){
									if(PreLeftInLine[0].FP0.x==0.0f && PreLeftInLine[0].FP0.y==0.0f && PreLeftInLine[0].FP1.x==0.0f && PreLeftInLine[0].FP1.y==0.0f){// 시작부분 Broken발생으로 데이터가 없는경우 
										// Mark좌표를 기준으로 라인좌표값을 다시 설정함 
										ROI_H = IRoi->GetHeight();
										ROI_L = IRoi->GetOrgX()  ;
										LeftInLine[0].FP0.x = ROI_L;   LeftInLine[0].FP0.y = 0.0f        ;
										LeftInLine[0].FP1.x = ROI_L;   LeftInLine[0].FP1.y = (float)ROI_H;

										//Line 데이터를 PreLine에 넘겨준다 
										PreLeftInLine[0].FP0.x = LeftInLine[0].FP0.x;    PreLeftInLine[0].FP1.x = LeftInLine[0].FP1.x;       
										PreLeftInLine[0].FP0.y = LeftInLine[0].FP0.y;    PreLeftInLine[0].FP1.y = LeftInLine[0].FP1.y;       
									}
									else {                                                                                                    // 중간부분 Broken발생으로 데이터가 없는경우 
										// PreLine 데이터를 넘겨줌 
										LeftInLine[0].FP0.x = PreLeftInLine[0].FP0.x;  LeftInLine[0].FP1.x = PreLeftInLine[0].FP1.x;  
										LeftInLine[0].FP0.y = PreLeftInLine[0].FP0.y;  LeftInLine[0].FP1.y = PreLeftInLine[0].FP1.y;  
									}
								}
								// NOTCH CELL Btm 검사에서만 연마폭 측정함 
								Left_Grind_Width =(float)(Math.GetLengthFrLineToPoint (LeftOutLine[0].FP0,LeftOutLine[0].FP1, LeftInLine[0].FP0 ));

								// Left TrackLine Search Start 
								/////////////////////////////////////////////////////////////////////////////////////////////
								// 									 BinaryImg.SetSize(GImage->GetWidth(), GImage->GetHeight());
								// 									 EasyImage::Oper(EArithmeticLogicOperation_Copy,GImage,&BinaryImg);
								EasyImage::Threshold(GImage,&BinaryImg, CirGrindMeaThresHold);
								SingleLine->GImage = &BinaryImg;

								// 영역설정 
								if(fabs(LeftInLine[0].FP0.x - LeftInLine[0].FP1.x) > 3){
									LSP.x = (LeftInLine[0].FP0.x + LeftInLine[0].FP1.x)/2;
									LSP.y = 0.0f;
								}
								else {
									LSP = Math.OnIntersect(LeftInLine[0].FP0, LeftInLine[0].FP1, LT, RT);
								}

								SingleLine->IRoi->SetOrgX  ((int)LSP.x+3 );
								SingleLine->IRoi->SetOrgY  (0            );
								SingleLine->IRoi->SetWidth (100          );
								SingleLine->IRoi->SetHeight(ImgH         );

								if(((LSP.x+3)<=0) || ImgH<=0) return false;

								if(IRoi->GetHeight()<300) SingleLine->SetIncrement(5 );
								else                      SingleLine->SetIncrement(100);

								// Left Track Line Search 
								SingleLine->SetFindLineId(0);
								SingleLine->SetOrientation(orWest);
								SingleLine->SetEdgeType(1); // White To Black  
								SingleLine->OnExecute();
								LeftTrackLine[0].FP0 = SingleLine->GetResultP0();
								LeftTrackLine[0].FP1 = SingleLine->GetResultP1();

								SingleLine->SetEdgeType(2); // Line Search Type Normal 

								// LeftTrackLine....make OutLine Data 
								// 현재의 데이터를 넘겨준다 
								// 검사중 기준라인을 찾지 못할경우 이전데이터 넘겨줘서 기준라인 생성함 
								if(LeftTrackLine[0].FP0.x!=0.0f && LeftTrackLine[0].FP0.y!=0.0f && LeftTrackLine[0].FP1.x!=0.0f && LeftTrackLine[0].FP1.y!=0.0f){
									PreLeftTrackLine[0].FP0.x = LeftTrackLine[0].FP0.x;    PreLeftTrackLine[0].FP1.x = LeftTrackLine[0].FP1.x;       
									PreLeftTrackLine[0].FP0.y = LeftTrackLine[0].FP0.y;    PreLeftTrackLine[0].FP1.y = LeftTrackLine[0].FP1.y;       
								} // 셀의 상단 시작부터 Broken 발생으로 데이터가 없는경우 
								else if(LeftTrackLine[0].FP0.x==0.0f || LeftTrackLine[0].FP0.y==0.0f || LeftTrackLine[0].FP1.x==0.0f || LeftTrackLine[0].FP1.y==0.0f){
									if(PreLeftTrackLine[0].FP0.x==0.0f && PreLeftTrackLine[0].FP0.y==0.0f && PreLeftTrackLine[0].FP1.x==0.0f && PreLeftTrackLine[0].FP1.y==0.0f){// 시작부분 Broken발생으로 데이터가 없는경우 
										// Mark좌표를 기준으로 라인좌표값을 다시 설정함 
										ROI_H = IRoi->GetHeight();
										ROI_L = IRoi->GetOrgX()  ;
										LeftTrackLine[0].FP0.x = ROI_L;    LeftTrackLine[0].FP0.y = 0.0f        ;
										LeftTrackLine[0].FP1.x = ROI_L;    LeftTrackLine[0].FP1.y = (float)ROI_H;

										//LeftTrackLine 데이터를 PreLeftTrackLine에 넘겨준다 
										PreLeftTrackLine[0].FP0.x = LeftTrackLine[0].FP0.x;    PreLeftTrackLine[0].FP1.x = LeftTrackLine[0].FP1.x;       
										PreLeftTrackLine[0].FP0.y = LeftTrackLine[0].FP0.y;    PreLeftTrackLine[0].FP1.y = LeftTrackLine[0].FP1.y;       
									}
									else { // 중간부분 Broken발생으로 데이터가 없는경우 
										// PreLeftTrackLine 데이터를 넘겨줌 
										LeftTrackLine[0].FP0.x = PreLeftTrackLine[0].FP0.x;  LeftTrackLine[0].FP1.x = PreLeftTrackLine[0].FP1.x;  
										LeftTrackLine[0].FP0.y = PreLeftTrackLine[0].FP0.y;  LeftTrackLine[0].FP1.y = PreLeftTrackLine[0].FP1.y;  
									}
								}
								// NOTCH CELL Btm 검사에서만 연마폭 측정함 
								Left_Grind_Mea =(float)(Math.GetLengthFrLineToPoint (LeftOutLine[0].FP0,LeftOutLine[0].FP1, LeftTrackLine[0].FP0 ));

								// 마크라인에서 부터 LeftTrackLine 까지 거리 산출 
								// LeftTrackLine Data 존재할 경우 거리 측정함 
								if(LeftTrackLine[0].FP0.x!=0.0f && LeftTrackLine[0].FP0.y!=0.0f && LeftTrackLine[0].FP1.x!=0.0f && LeftTrackLine[0].FP1.y!=0.0f){
// 									LeftTrackLine[0].FP0.y = LeftTrackLine[0].FP0.y + ImageHeight; //전체 이미지 기준 y좌표
// 									LeftTrackLine[0].FP1.y = LeftTrackLine[0].FP1.y + ImageHeight; //전체 이미지 기준 y좌표
// 
// 									MarkToTrackLineDis1 = Math.GetLengthFrLineToPoint(LeftMarkSta, LeftMarkEnd, LeftTrackLine[0].FP0);//Mark라인에서 TrackLine거리 
// 									MarkToTrackLineDis2 = Math.GetLengthFrLineToPoint(LeftMarkSta, LeftMarkEnd, LeftTrackLine[0].FP1);//Mark라인에서 TrackLine거리 
// 
// 									TotalLeftTrackDis  +=  (int)((MarkToTrackLineDis1 + MarkToTrackLineDis2)/2.0); //Mark라인에서 TrackLine거리 누적                   
// 									LeftTrackLineCount++; //누적 카운트 증가
// 
// 									// Org Data 
// 									LeftTrackLine[0].FP0.y = LeftTrackLine[0].FP0.y - ImageHeight; //Frame 이미지 기준 y좌표 원복
// 									LeftTrackLine[0].FP1.y = LeftTrackLine[0].FP1.y - ImageHeight; //Frame 이미지 기준 y좌표 원복 
								}
							}
							else { //EnCap(Top영역) LeftInLine Search , LeftTrackLine Data Overlap 
								// LeftInLine Search Start 
								EasyImage::Threshold(GImage,&BinaryImg, LeftEdgeThresHold);
								SingleLine->GImage = &BinaryImg;

								// 영역설정 
								if(fabs(LeftOutLine[0].FP0.x - LeftOutLine[0].FP1.x) > 3){
									LSP.x = (LeftOutLine[0].FP0.x + LeftOutLine[0].FP1.x)/2;
									LSP.y = 0.0f;
								}
								else {
									LSP = Math.OnIntersect(LeftOutLine[0].FP0, LeftOutLine[0].FP1, LT, RT);
								}

								SingleLine->IRoi->SetOrgX  ((int)LSP.x+3 );
								SingleLine->IRoi->SetOrgY  (0            );
								SingleLine->IRoi->SetWidth (100          );
								SingleLine->IRoi->SetHeight(ImgH         );

								if(((LSP.x+3)<=0) || ImgH<=0) return false;

								// 								if(IRoi->GetHeight()<300) SingleLine->SetIncrement(5 );
								// 								else                      SingleLine->SetIncrement(100);

								if(FShape==shRectC) SingleLine->SetIncrement(5 );
								else                SingleLine->SetIncrement(30);

								// 연마량 측정 OutLine
								SingleLine->SetFindLineId(0);
								SingleLine->SetOrientation(orWest);
								SingleLine->SetEdgeType(0); // Black to White 
								SingleLine->OnExecute();
								LeftInLine[0].FP0 = SingleLine->GetResultP0();
								LeftInLine[0].FP1 = SingleLine->GetResultP1();

								SingleLine->SetEdgeType(2); // Line Search Org 

								// LeftInLine None....make InLine Data 
								// 현재의 데이터를 넘겨준다 
								if(LeftInLine[0].FP0.x!=0.0f && LeftInLine[0].FP0.y!=0.0f && LeftInLine[0].FP1.x!=0.0f && LeftInLine[0].FP1.y!=0.0f){
									PreLeftInLine[0].FP0.x = LeftInLine[0].FP0.x;    PreLeftInLine[0].FP1.x = LeftInLine[0].FP1.x;       
									PreLeftInLine[0].FP0.y = LeftInLine[0].FP0.y;    PreLeftInLine[0].FP1.y = LeftInLine[0].FP1.y;       
								}
								else if(LeftInLine[0].FP0.x==0.0f || LeftInLine[0].FP0.y==0.0f || LeftInLine[0].FP1.x==0.0f || LeftInLine[0].FP1.y==0.0f){
									if(PreLeftInLine[0].FP0.x==0.0f && PreLeftInLine[0].FP0.y==0.0f && PreLeftInLine[0].FP1.x==0.0f && PreLeftInLine[0].FP1.y==0.0f){// 시작부분 Broken발생으로 데이터가 없는경우 
										// Mark좌표를 기준으로 라인좌표값을 다시 설정함 
										ROI_H = IRoi->GetHeight();
										ROI_L = IRoi->GetOrgX()  ;
										LeftInLine[0].FP0.x = ROI_L;   LeftInLine[0].FP0.y = 0.0f        ;
										LeftInLine[0].FP1.x = ROI_L;   LeftInLine[0].FP1.y = (float)ROI_H;

										//Line 데이터를 PreLine에 넘겨준다 
										PreLeftInLine[0].FP0.x = LeftInLine[0].FP0.x;    PreLeftInLine[0].FP1.x = LeftInLine[0].FP1.x;       
										PreLeftInLine[0].FP0.y = LeftInLine[0].FP0.y;    PreLeftInLine[0].FP1.y = LeftInLine[0].FP1.y;       
									}
									else {                                                                                                    // 중간부분 Broken발생으로 데이터가 없는경우 
										// PreLine 데이터를 넘겨줌 
										LeftInLine[0].FP0.x = PreLeftInLine[0].FP0.x;  LeftInLine[0].FP1.x = PreLeftInLine[0].FP1.x;  
										LeftInLine[0].FP0.y = PreLeftInLine[0].FP0.y;  LeftInLine[0].FP1.y = PreLeftInLine[0].FP1.y;  
									}
								}
								// NOTCH CELL Btm 검사에서만 연마폭 측정함 
								Left_Grind_Width =(float)(Math.GetLengthFrLineToPoint (LeftOutLine[0].FP0,LeftOutLine[0].FP1, LeftInLine[0].FP0 ));

								//LeftTrackLine Data Overlap 
								/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
								if(AvgLeftTrackLineDis!=0){
// 									LeftOutLine[0].FP0.y = LeftOutLine[0].FP0.y + ImageHeight; //전체 이미지 기준 y좌표
// 									LeftOutLine[0].FP1.y = LeftOutLine[0].FP1.y + ImageHeight; //전체 이미지 기준 y좌표
// 
// 									MarkToTrackLineDis1 = Math.GetLengthFrLineToPoint(LeftMarkSta, LeftMarkEnd, LeftOutLine[0].FP0);//Mark라인에서 OutLine까지 거리 
// 									MarkToTrackLineDis2 = Math.GetLengthFrLineToPoint(LeftMarkSta, LeftMarkEnd, LeftOutLine[0].FP1);//Mark라인에서 OutLine까지 거리 
// 
// 									if(MarkToTrackLineDis1>AvgLeftTrackLineDis) LeftTrackLine[0].FP0.x = LeftOutLine[0].FP0.x+(MarkToTrackLineDis1 - AvgLeftTrackLineDis);
// 									if(MarkToTrackLineDis2>AvgLeftTrackLineDis) LeftTrackLine[0].FP1.x = LeftOutLine[0].FP1.x+(MarkToTrackLineDis2 - AvgLeftTrackLineDis);
// 
// 									// LeftOutLine Data 원본 
// 									LeftOutLine[0].FP0.y = LeftOutLine[0].FP0.y - ImageHeight; 
// 									LeftOutLine[0].FP1.y = LeftOutLine[0].FP1.y - ImageHeight; 
// 
// 									LeftTrackLine[0].FP0.y = LeftOutLine[0].FP0.y;
// 									LeftTrackLine[0].FP1.y = LeftOutLine[0].FP1.y;
								/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
								}
							}
						}
						else {
							if(IsMarkBtm){ //LeftTrackLine Search 
								if(FInspectMode==Insp_Track){
									//BinaryImg.SetSize(GImage->GetWidth(), GImage->GetHeight());
									//EasyImage::Oper(EArithmeticLogicOperation_Copy,GImage,&BinaryImg);
									EasyImage::Threshold(GImage,&BinaryImg, CirGrindMeaThresHold);

									// LeftOutLine 기준 LeftTrackLine 검출 
									SingleLine->GImage = &BinaryImg;

									// 영역설정 
									if(fabs(LeftOutLine[0].FP0.x - LeftOutLine[0].FP1.x) > 3){
										LSP.x = (LeftOutLine[0].FP0.x + LeftOutLine[0].FP1.x)/2;
										LSP.y = 0.0f;
									}
									else {
										LSP = Math.OnIntersect(LeftOutLine[0].FP0, LeftOutLine[0].FP1, LT, RT);
									}

									if(FShape==shRectC){
										SingleLine->IRoi->SetOrgX  ((int)LSP.x+3 );
										SingleLine->IRoi->SetOrgY  (0            );
										SingleLine->IRoi->SetWidth (47           );
										SingleLine->IRoi->SetHeight(FEndLine-CSideCircleHeight);
										SingleLine->SetIncrement(1 );
										if(((LSP.x+3)<=0) || ImgH<=0) return false;
									}
									else {
										SingleLine->IRoi->SetOrgX  ((int)LSP.x+3 );
										SingleLine->IRoi->SetOrgY  (0            );
										SingleLine->IRoi->SetWidth (47           );
										SingleLine->IRoi->SetHeight(ImgH         );
										SingleLine->SetIncrement(50);
										if(((LSP.x+3)<=0) || ImgH<=0) return false;
									}

									// Left Track Line Search 
									SingleLine->SetFindLineId(0);
									SingleLine->SetOrientation(orWest);
									SingleLine->SetEdgeType(1); // White To Black  
									SingleLine->OnExecute();
									LeftTrackLine[0].FP0 = SingleLine->GetResultP0();
									LeftTrackLine[0].FP1 = SingleLine->GetResultP1();

									SingleLine->SetEdgeType(2); // Line Search Type Normal 

									// LeftTrackLine....Make OutLine Data 
									// 현재의 데이터를 넘겨준다 
									// 검사중 기준라인을 찾지 못할경우 이전데이터 넘겨줘서 기준라인 생성함 
									if(LeftTrackLine[0].FP0.x!=0.0f && LeftTrackLine[0].FP0.y!=0.0f && LeftTrackLine[0].FP1.x!=0.0f && LeftTrackLine[0].FP1.y!=0.0f){
										PreLeftTrackLine[0].FP0.x = LeftTrackLine[0].FP0.x;    PreLeftTrackLine[0].FP1.x = LeftTrackLine[0].FP1.x;       
										PreLeftTrackLine[0].FP0.y = LeftTrackLine[0].FP0.y;    PreLeftTrackLine[0].FP1.y = LeftTrackLine[0].FP1.y;       
									} // 셀의 상단 시작부터 Broken 발생으로 데이터가 없는경우 
									else if(LeftTrackLine[0].FP0.x==0.0f || LeftTrackLine[0].FP0.y==0.0f || LeftTrackLine[0].FP1.x==0.0f || LeftTrackLine[0].FP1.y==0.0f){
										if(PreLeftTrackLine[0].FP0.x==0.0f && PreLeftTrackLine[0].FP0.y==0.0f && PreLeftTrackLine[0].FP1.x==0.0f && PreLeftTrackLine[0].FP1.y==0.0f){// 시작부분 Broken발생으로 데이터가 없는경우 
											// Mark좌표를 기준으로 라인좌표값을 다시 설정함 
											ROI_H = IRoi->GetHeight();
											ROI_L = IRoi->GetOrgX()  ;
											LeftTrackLine[0].FP0.x = ROI_L;    LeftTrackLine[0].FP0.y = 0.0f        ;
											LeftTrackLine[0].FP1.x = ROI_L;    LeftTrackLine[0].FP1.y = (float)ROI_H;

											//LeftTrackLine 데이터를 PreLeftTrackLine에 넘겨준다 
											PreLeftTrackLine[0].FP0.x = LeftTrackLine[0].FP0.x;    PreLeftTrackLine[0].FP1.x = LeftTrackLine[0].FP1.x;       
											PreLeftTrackLine[0].FP0.y = LeftTrackLine[0].FP0.y;    PreLeftTrackLine[0].FP1.y = LeftTrackLine[0].FP1.y;       
										}
										else { // 중간부분 Broken발생으로 데이터가 없는경우 
											// PreLeftTrackLine 데이터를 넘겨줌 
											LeftTrackLine[0].FP0.x = PreLeftTrackLine[0].FP0.x;  LeftTrackLine[0].FP1.x = PreLeftTrackLine[0].FP1.x;  
											LeftTrackLine[0].FP0.y = PreLeftTrackLine[0].FP0.y;  LeftTrackLine[0].FP1.y = PreLeftTrackLine[0].FP1.y;  
										}
									}

									// 마크라인에서 부터 LeftTrackLine 까지 거리 산출 
									// LeftTrackLine Data 존재할 경우 거리 측정함 
									// Image Rotate 없음
									// 외곽기준으로 EnCap에 데이터 오버랩 목적으로 데이터 계산함 
									if(LeftTrackLine[0].FP0.x!=0.0f && LeftTrackLine[0].FP0.y!=0.0f && LeftTrackLine[0].FP1.x!=0.0f && LeftTrackLine[0].FP1.y!=0.0f){
										if(LeftOutLine[0].FP0.x!=0.0f && LeftOutLine[0].FP0.y!=0.0f && LeftOutLine[0].FP1.x!=0.0f && LeftOutLine[0].FP1.y!=0.0f){
											LeftToTrackLineDis1 = Math.GetLengthFrLineToPoint(LeftOutLine[0].FP0, LeftOutLine[0].FP1, LeftTrackLine[0].FP0);//외곽라인에서 TrackLine거리 
											LeftToTrackLineDis2 = Math.GetLengthFrLineToPoint(LeftOutLine[0].FP0, LeftOutLine[0].FP1, LeftTrackLine[0].FP1);//외곽라인에서 TrackLine거리 

											TotalLeftTrackDis  +=  (int)((LeftToTrackLineDis1 + LeftToTrackLineDis2)/2.0); //Mark라인에서 TrackLine거리 누적                   
											LeftTrackLineCount++; //누적 카운트 증가
										}
									}
								}
							}
							else {//EnCap(Top영역) LeftTrackLine Data Overlap 
								//LeftTrackLine Data Overlap 
								/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
								if(AvgLeftTrackLineDis!=0){
									if(FInspectMode==Insp_Track){ // TrackMode 외곽라인 기준  
										if(LeftOutLine[0].FP0.x!=0.0f && LeftOutLine[0].FP0.y!=0.0f && LeftOutLine[0].FP1.x!=0.0f && LeftOutLine[0].FP1.y!=0.0f){
											// TOP영역 LeftTrackLine x좌표 
											LeftTrackLine[0].FP0.x = LeftOutLine[0].FP0.x+AvgLeftTrackLineDis;
											LeftTrackLine[0].FP1.x = LeftOutLine[0].FP1.x+AvgLeftTrackLineDis;

											// TOP영역 LeftTrackLine y좌표 
											LeftTrackLine[0].FP0.y = LeftOutLine[0].FP0.y;
											LeftTrackLine[0].FP1.y = LeftOutLine[0].FP1.y;
										}
									}
								}
							}
						}
					 }
					 else if(FCompanyMode==COM_BMDT){ // 기본 LeftLine
						 EasyImage::Threshold(GImage,&BinaryImg, LeftEdgeThresHold);
						 if(LeftEdgeThresHold==0) {SingleLine->GImage = GImage;     SingleLine->FThreshold =5 ;}
						 else                     {SingleLine->GImage = &BinaryImg; SingleLine->FThreshold =10;}

						 if(FInspectMode==Insp_Surface){ // 표면검사 
							 if(FShape==shRectC){
								 SingleLine->IRoi->SetOrgX  (IRoi->GetOrgX()          );
								 SingleLine->IRoi->SetOrgY  (IRoi->GetOrgY()          );
								 SingleLine->IRoi->SetWidth (IRoi->GetWidth()         );
								 SingleLine->IRoi->SetHeight(FEndLine-CSideCircleHeight);
								 SingleLine->SetIncrement(1);
							 }
							 else if(FShape==shRectH) {
								 if(IsCircleTop){
									 SingleLine->IRoi->SetOrgX  (IRoi->GetOrgX()  );
									 SingleLine->IRoi->SetOrgY  (ASideCircleHeight+50);
									 SingleLine->IRoi->SetWidth (IRoi->GetWidth() );
									 SingleLine->IRoi->SetHeight(ImgH-(ASideCircleHeight+50));
									 SingleLine->SetIncrement(1);
								 }
								 else {
									 SingleLine->IRoi->SetOrgX  (IRoi->GetOrgX()  );
									 SingleLine->IRoi->SetOrgY  (IRoi->GetOrgY()  );
									 SingleLine->IRoi->SetWidth (IRoi->GetWidth() );
									 SingleLine->IRoi->SetHeight(IRoi->GetHeight());
									 SingleLine->SetIncrement(10);
								 }
							 }
							 else {
								 SingleLine->IRoi->SetOrgX  (IRoi->GetOrgX()  );
								 SingleLine->IRoi->SetOrgY  (IRoi->GetOrgY()  );
								 SingleLine->IRoi->SetWidth (IRoi->GetWidth() );
								 SingleLine->IRoi->SetHeight(IRoi->GetHeight());
								 ROI_H = IRoi->GetHeight();
								 if(ROI_H<700)  SingleLine->SetIncrement(50 );
								 else 	        SingleLine->SetIncrement(100);
							 }
							 SingleLine->SetOrientation(orWest);
							 SingleLine->SetFindLineId(0);

							 // 표면검사 외곽Edge White 
							 if(IsMarkBtm) SingleLine->SetEdgeType(1); // White To Black  
							 else          SingleLine->SetEdgeType(1); // White To Black  

							 SingleLine->OnExecute();
							 Line[0].FP0 = SingleLine->GetResultP0();
							 Line[0].FP1 = SingleLine->GetResultP1();

							 // Btm,Top 상관없이 첫번째
							 LeftOutLine[0].FP0.x = Line[0].FP0.x;
							 LeftOutLine[0].FP0.y = Line[0].FP0.y;
							 LeftOutLine[0].FP1.x = Line[0].FP1.x;
							 LeftOutLine[0].FP1.y = Line[0].FP1.y;

							 // LeftOutLine....make OutLine Data 
							 // 현재의 데이터를 넘겨준다 
							 // 검사중 기준라인을 찾지 못할경우 이전데이터 넘겨줘서 기준라인 생성함 
							 if(LeftOutLine[0].FP0.x!=0.0f && LeftOutLine[0].FP0.y!=0.0f && LeftOutLine[0].FP1.x!=0.0f && LeftOutLine[0].FP1.y!=0.0f){
								 PreLeftOutLine[0].FP0.x = LeftOutLine[0].FP0.x;    PreLeftOutLine[0].FP1.x = LeftOutLine[0].FP1.x;       
								 PreLeftOutLine[0].FP0.y = LeftOutLine[0].FP0.y;    PreLeftOutLine[0].FP1.y = LeftOutLine[0].FP1.y;       
							 } // 셀의 상단 시작부터 Broken 발생으로 데이터가 없는경우 
							 else if(LeftOutLine[0].FP0.x==0.0f || LeftOutLine[0].FP0.y==0.0f || LeftOutLine[0].FP1.x==0.0f || LeftOutLine[0].FP1.y==0.0f){
								 if(PreLeftOutLine[0].FP0.x==0.0f && PreLeftOutLine[0].FP0.y==0.0f && PreLeftOutLine[0].FP1.x==0.0f && PreLeftOutLine[0].FP1.y==0.0f){// 시작부분 Broken발생으로 데이터가 없는경우 
									 // Mark좌표를 기준으로 라인좌표값을 다시 설정함 
									 ROI_H = IRoi->GetHeight();
									 ROI_L = IRoi->GetOrgX()  ;
									 LeftOutLine[0].FP0.x = ROI_L;    LeftOutLine[0].FP0.y = 0.0f        ;
									 LeftOutLine[0].FP1.x = ROI_L;    LeftOutLine[0].FP1.y = (float)ROI_H;

									 //Line 데이터를 PreLine에 넘겨준다 
									 PreLeftOutLine[0].FP0.x = LeftOutLine[0].FP0.x;    PreLeftOutLine[0].FP1.x = LeftOutLine[0].FP1.x;       
									 PreLeftOutLine[0].FP0.y = LeftOutLine[0].FP0.y;    PreLeftOutLine[0].FP1.y = LeftOutLine[0].FP1.y;       
								 }
								 else { // 중간부분 Broken발생으로 데이터가 없는경우 
									 // PreLine 데이터를 넘겨줌 
									 LeftOutLine[0].FP0.x = PreLeftOutLine[0].FP0.x;  LeftOutLine[0].FP1.x = PreLeftOutLine[0].FP1.x;  
									 LeftOutLine[0].FP0.y = PreLeftOutLine[0].FP0.y;  LeftOutLine[0].FP1.y = PreLeftOutLine[0].FP1.y;  
								 }
							 }
						 }
						 else             { //// 외관검사 ////
							 if(FShape==shRectC){
								 SingleLine->IRoi->SetOrgX  (IRoi->GetOrgX()          );
								 SingleLine->IRoi->SetOrgY  (IRoi->GetOrgY()          );
								 SingleLine->IRoi->SetWidth (IRoi->GetWidth()         );
								 SingleLine->IRoi->SetHeight(FEndLine-CSideCircleHeight);
								 SingleLine->SetIncrement(1);
							 }
							 else if(FShape==shRectH) {
								 if(IsCircleTop){
									 SingleLine->IRoi->SetOrgX  (IRoi->GetOrgX()  );
									 SingleLine->IRoi->SetOrgY  (ASideCircleHeight+50);
									 SingleLine->IRoi->SetWidth (IRoi->GetWidth() );
									 SingleLine->IRoi->SetHeight(ImgH-(ASideCircleHeight+50));
									 SingleLine->SetIncrement(1);
								 }
								 else {
									 SingleLine->IRoi->SetOrgX  (IRoi->GetOrgX()  );
									 SingleLine->IRoi->SetOrgY  (IRoi->GetOrgY()  );
									 SingleLine->IRoi->SetWidth (IRoi->GetWidth() );
									 SingleLine->IRoi->SetHeight(IRoi->GetHeight());
									 SingleLine->SetIncrement(50);
								 }
							 }
							 else {
								 SingleLine->IRoi->SetOrgX  (IRoi->GetOrgX()  );
								 SingleLine->IRoi->SetOrgY  (IRoi->GetOrgY()  );
								 SingleLine->IRoi->SetWidth (IRoi->GetWidth() );
								 SingleLine->IRoi->SetHeight(IRoi->GetHeight());
								 ROI_H = IRoi->GetHeight();
								 if(ROI_H<700)  SingleLine->SetIncrement(50 );
								 else 	        SingleLine->SetIncrement(100);
							 }
							 SingleLine->SetOrientation(orWest);

							 SingleLine->SetFindLineId(0);

							 if(IsMarkBtm) SingleLine->SetEdgeType(0); // White 
							 else          SingleLine->SetEdgeType(0); // White   
							 // 						 SingleLine->SetEdgeType(0); // Black To White 
							 SingleLine->OnExecute();
							 Line[0].FP0 = SingleLine->GetResultP0();
							 Line[0].FP1 = SingleLine->GetResultP1();

							 // Btm,Top 상관없이 첫번째
							 LeftOutLine[0].FP0.x = Line[0].FP0.x;
							 LeftOutLine[0].FP0.y = Line[0].FP0.y;
							 LeftOutLine[0].FP1.x = Line[0].FP1.x;
							 LeftOutLine[0].FP1.y = Line[0].FP1.y;

							 // LeftOutLine....make OutLine Data 
							 // 현재의 데이터를 넘겨준다 
							 // 검사중 기준라인을 찾지 못할경우 이전데이터 넘겨줘서 기준라인 생성함 
							 if(LeftOutLine[0].FP0.x!=0.0f && LeftOutLine[0].FP0.y!=0.0f && LeftOutLine[0].FP1.x!=0.0f && LeftOutLine[0].FP1.y!=0.0f){
								 PreLeftOutLine[0].FP0.x = LeftOutLine[0].FP0.x;    PreLeftOutLine[0].FP1.x = LeftOutLine[0].FP1.x;       
								 PreLeftOutLine[0].FP0.y = LeftOutLine[0].FP0.y;    PreLeftOutLine[0].FP1.y = LeftOutLine[0].FP1.y;       
							 } // 셀의 상단 시작부터 Broken 발생으로 데이터가 없는경우 
							 else if(LeftOutLine[0].FP0.x==0.0f || LeftOutLine[0].FP0.y==0.0f || LeftOutLine[0].FP1.x==0.0f || LeftOutLine[0].FP1.y==0.0f){
								 if(PreLeftOutLine[0].FP0.x==0.0f && PreLeftOutLine[0].FP0.y==0.0f && PreLeftOutLine[0].FP1.x==0.0f && PreLeftOutLine[0].FP1.y==0.0f){// 시작부분 Broken발생으로 데이터가 없는경우 
									 // Mark좌표를 기준으로 라인좌표값을 다시 설정함 
									 ROI_H = IRoi->GetHeight();
									 ROI_L = IRoi->GetOrgX()  ;
									 LeftOutLine[0].FP0.x = ROI_L;    LeftOutLine[0].FP0.y = 0.0f        ;
									 LeftOutLine[0].FP1.x = ROI_L;    LeftOutLine[0].FP1.y = (float)ROI_H;

									 //Line 데이터를 PreLine에 넘겨준다 
									 PreLeftOutLine[0].FP0.x = LeftOutLine[0].FP0.x;    PreLeftOutLine[0].FP1.x = LeftOutLine[0].FP1.x;       
									 PreLeftOutLine[0].FP0.y = LeftOutLine[0].FP0.y;    PreLeftOutLine[0].FP1.y = LeftOutLine[0].FP1.y;       
								 }
								 else { // 중간부분 Broken발생으로 데이터가 없는경우 
									 // PreLine 데이터를 넘겨줌 
									 LeftOutLine[0].FP0.x = PreLeftOutLine[0].FP0.x;  LeftOutLine[0].FP1.x = PreLeftOutLine[0].FP1.x;  
									 LeftOutLine[0].FP0.y = PreLeftOutLine[0].FP0.y;  LeftOutLine[0].FP1.y = PreLeftOutLine[0].FP1.y;  
								 }
							 }
						 }

						 if(IsAllGrind){
							 if(IsMarkBtm){ // LeftInLine, LeftTrackLine Search 
								 // LeftInLine Search Start 
								 EasyImage::Threshold(GImage,&BinaryImg, LeftEdgeThresHold);
								 SingleLine->GImage = &BinaryImg;

								 // 영역설정 
								 if(fabs(LeftOutLine[0].FP0.x - LeftOutLine[0].FP1.x) > 3){
									 LSP.x = (LeftOutLine[0].FP0.x + LeftOutLine[0].FP1.x)/2;
									 LSP.y = 0.0f;
								 }
								 else {
									 LSP = Math.OnIntersect(LeftOutLine[0].FP0, LeftOutLine[0].FP1, LT, RT);
								 }

								 SingleLine->IRoi->SetOrgX  ((int)LSP.x+3 );
								 SingleLine->IRoi->SetOrgY  (0            );
								 SingleLine->IRoi->SetWidth (100          );
								 SingleLine->IRoi->SetHeight(ImgH         );

								 if(((LSP.x+3)<=0) || ImgH<=0) return false;

								 // 								if(IRoi->GetHeight()<300) SingleLine->SetIncrement(5 );
								 // 								else                      SingleLine->SetIncrement(100);

								 if(FShape==shRectC) SingleLine->SetIncrement(5 );
								 else                SingleLine->SetIncrement(30);

								 // 연마량 측정 OutLine
								 SingleLine->SetFindLineId(0);
								 SingleLine->SetOrientation(orWest);
								 SingleLine->SetEdgeType(0); // Black to White 
								 SingleLine->OnExecute();
								 LeftInLine[0].FP0 = SingleLine->GetResultP0();
								 LeftInLine[0].FP1 = SingleLine->GetResultP1();

								 SingleLine->SetEdgeType(2); // Line Search Org 

								 // LeftInLine None....make InLine Data 
								 // 현재의 데이터를 넘겨준다 
								 if(LeftInLine[0].FP0.x!=0.0f && LeftInLine[0].FP0.y!=0.0f && LeftInLine[0].FP1.x!=0.0f && LeftInLine[0].FP1.y!=0.0f){
									 PreLeftInLine[0].FP0.x = LeftInLine[0].FP0.x;    PreLeftInLine[0].FP1.x = LeftInLine[0].FP1.x;       
									 PreLeftInLine[0].FP0.y = LeftInLine[0].FP0.y;    PreLeftInLine[0].FP1.y = LeftInLine[0].FP1.y;       
								 }
								 else if(LeftInLine[0].FP0.x==0.0f || LeftInLine[0].FP0.y==0.0f || LeftInLine[0].FP1.x==0.0f || LeftInLine[0].FP1.y==0.0f){
									 if(PreLeftInLine[0].FP0.x==0.0f && PreLeftInLine[0].FP0.y==0.0f && PreLeftInLine[0].FP1.x==0.0f && PreLeftInLine[0].FP1.y==0.0f){// 시작부분 Broken발생으로 데이터가 없는경우 
										 // Mark좌표를 기준으로 라인좌표값을 다시 설정함 
										 ROI_H = IRoi->GetHeight();
										 ROI_L = IRoi->GetOrgX()  ;
										 LeftInLine[0].FP0.x = ROI_L;   LeftInLine[0].FP0.y = 0.0f        ;
										 LeftInLine[0].FP1.x = ROI_L;   LeftInLine[0].FP1.y = (float)ROI_H;

										 //Line 데이터를 PreLine에 넘겨준다 
										 PreLeftInLine[0].FP0.x = LeftInLine[0].FP0.x;    PreLeftInLine[0].FP1.x = LeftInLine[0].FP1.x;       
										 PreLeftInLine[0].FP0.y = LeftInLine[0].FP0.y;    PreLeftInLine[0].FP1.y = LeftInLine[0].FP1.y;       
									 }
									 else {                                                                                                    // 중간부분 Broken발생으로 데이터가 없는경우 
										 // PreLine 데이터를 넘겨줌 
										 LeftInLine[0].FP0.x = PreLeftInLine[0].FP0.x;  LeftInLine[0].FP1.x = PreLeftInLine[0].FP1.x;  
										 LeftInLine[0].FP0.y = PreLeftInLine[0].FP0.y;  LeftInLine[0].FP1.y = PreLeftInLine[0].FP1.y;  
									 }
								 }
								 // NOTCH CELL Btm 검사에서만 연마폭 측정함 
								 Left_Grind_Width =(float)(Math.GetLengthFrLineToPoint (LeftOutLine[0].FP0,LeftOutLine[0].FP1, LeftInLine[0].FP0 ));

								 // Left TrackLine Search Start 
								 /////////////////////////////////////////////////////////////////////////////////////////////
								 // 									 BinaryImg.SetSize(GImage->GetWidth(), GImage->GetHeight());
								 // 									 EasyImage::Oper(EArithmeticLogicOperation_Copy,GImage,&BinaryImg);
								 EasyImage::Threshold(GImage,&BinaryImg, CirGrindMeaThresHold);
								 SingleLine->GImage = &BinaryImg;

								 // 영역설정 
								 if(fabs(LeftInLine[0].FP0.x - LeftInLine[0].FP1.x) > 3){
									 LSP.x = (LeftInLine[0].FP0.x + LeftInLine[0].FP1.x)/2;
									 LSP.y = 0.0f;
								 }
								 else {
									 LSP = Math.OnIntersect(LeftInLine[0].FP0, LeftInLine[0].FP1, LT, RT);
								 }

								 SingleLine->IRoi->SetOrgX  ((int)LSP.x+3 );
								 SingleLine->IRoi->SetOrgY  (0            );
								 SingleLine->IRoi->SetWidth (100          );
								 SingleLine->IRoi->SetHeight(ImgH         );

								 if(((LSP.x+3)<=0) || ImgH<=0) return false;

								 if(IRoi->GetHeight()<300) SingleLine->SetIncrement(5 );
								 else                      SingleLine->SetIncrement(100);

								 // Left Track Line Search 
								 SingleLine->SetFindLineId(0);
								 SingleLine->SetOrientation(orWest);
								 SingleLine->SetEdgeType(1); // White To Black  
								 SingleLine->OnExecute();
								 LeftTrackLine[0].FP0 = SingleLine->GetResultP0();
								 LeftTrackLine[0].FP1 = SingleLine->GetResultP1();

								 SingleLine->SetEdgeType(2); // Line Search Type Normal 

								 // LeftTrackLine....make OutLine Data 
								 // 현재의 데이터를 넘겨준다 
								 // 검사중 기준라인을 찾지 못할경우 이전데이터 넘겨줘서 기준라인 생성함 
								 if(LeftTrackLine[0].FP0.x!=0.0f && LeftTrackLine[0].FP0.y!=0.0f && LeftTrackLine[0].FP1.x!=0.0f && LeftTrackLine[0].FP1.y!=0.0f){
									 PreLeftTrackLine[0].FP0.x = LeftTrackLine[0].FP0.x;    PreLeftTrackLine[0].FP1.x = LeftTrackLine[0].FP1.x;       
									 PreLeftTrackLine[0].FP0.y = LeftTrackLine[0].FP0.y;    PreLeftTrackLine[0].FP1.y = LeftTrackLine[0].FP1.y;       
								 } // 셀의 상단 시작부터 Broken 발생으로 데이터가 없는경우 
								 else if(LeftTrackLine[0].FP0.x==0.0f || LeftTrackLine[0].FP0.y==0.0f || LeftTrackLine[0].FP1.x==0.0f || LeftTrackLine[0].FP1.y==0.0f){
									 if(PreLeftTrackLine[0].FP0.x==0.0f && PreLeftTrackLine[0].FP0.y==0.0f && PreLeftTrackLine[0].FP1.x==0.0f && PreLeftTrackLine[0].FP1.y==0.0f){// 시작부분 Broken발생으로 데이터가 없는경우 
										 // Mark좌표를 기준으로 라인좌표값을 다시 설정함 
										 ROI_H = IRoi->GetHeight();
										 ROI_L = IRoi->GetOrgX()  ;
										 LeftTrackLine[0].FP0.x = ROI_L;    LeftTrackLine[0].FP0.y = 0.0f        ;
										 LeftTrackLine[0].FP1.x = ROI_L;    LeftTrackLine[0].FP1.y = (float)ROI_H;

										 //LeftTrackLine 데이터를 PreLeftTrackLine에 넘겨준다 
										 PreLeftTrackLine[0].FP0.x = LeftTrackLine[0].FP0.x;    PreLeftTrackLine[0].FP1.x = LeftTrackLine[0].FP1.x;       
										 PreLeftTrackLine[0].FP0.y = LeftTrackLine[0].FP0.y;    PreLeftTrackLine[0].FP1.y = LeftTrackLine[0].FP1.y;       
									 }
									 else { // 중간부분 Broken발생으로 데이터가 없는경우 
										 // PreLeftTrackLine 데이터를 넘겨줌 
										 LeftTrackLine[0].FP0.x = PreLeftTrackLine[0].FP0.x;  LeftTrackLine[0].FP1.x = PreLeftTrackLine[0].FP1.x;  
										 LeftTrackLine[0].FP0.y = PreLeftTrackLine[0].FP0.y;  LeftTrackLine[0].FP1.y = PreLeftTrackLine[0].FP1.y;  
									 }
								 }
								 // NOTCH CELL Btm 검사에서만 연마폭 측정함 
								 Left_Grind_Mea =(float)(Math.GetLengthFrLineToPoint (LeftOutLine[0].FP0,LeftOutLine[0].FP1, LeftTrackLine[0].FP0 ));

								 // 마크라인에서 부터 LeftTrackLine 까지 거리 산출 
								 // LeftTrackLine Data 존재할 경우 거리 측정함 
								 if(LeftTrackLine[0].FP0.x!=0.0f && LeftTrackLine[0].FP0.y!=0.0f && LeftTrackLine[0].FP1.x!=0.0f && LeftTrackLine[0].FP1.y!=0.0f){
									 // 									LeftTrackLine[0].FP0.y = LeftTrackLine[0].FP0.y + ImageHeight; //전체 이미지 기준 y좌표
									 // 									LeftTrackLine[0].FP1.y = LeftTrackLine[0].FP1.y + ImageHeight; //전체 이미지 기준 y좌표
									 // 
									 // 									MarkToTrackLineDis1 = Math.GetLengthFrLineToPoint(LeftMarkSta, LeftMarkEnd, LeftTrackLine[0].FP0);//Mark라인에서 TrackLine거리 
									 // 									MarkToTrackLineDis2 = Math.GetLengthFrLineToPoint(LeftMarkSta, LeftMarkEnd, LeftTrackLine[0].FP1);//Mark라인에서 TrackLine거리 
									 // 
									 // 									TotalLeftTrackDis  +=  (int)((MarkToTrackLineDis1 + MarkToTrackLineDis2)/2.0); //Mark라인에서 TrackLine거리 누적                   
									 // 									LeftTrackLineCount++; //누적 카운트 증가
									 // 
									 // 									// Org Data 
									 // 									LeftTrackLine[0].FP0.y = LeftTrackLine[0].FP0.y - ImageHeight; //Frame 이미지 기준 y좌표 원복
									 // 									LeftTrackLine[0].FP1.y = LeftTrackLine[0].FP1.y - ImageHeight; //Frame 이미지 기준 y좌표 원복 
								 }
							 }
							 else { //EnCap(Top영역) LeftInLine Search , LeftTrackLine Data Overlap 
								 // LeftInLine Search Start 
								 EasyImage::Threshold(GImage,&BinaryImg, LeftEdgeThresHold);
								 SingleLine->GImage = &BinaryImg;

								 // 영역설정 
								 if(fabs(LeftOutLine[0].FP0.x - LeftOutLine[0].FP1.x) > 3){
									 LSP.x = (LeftOutLine[0].FP0.x + LeftOutLine[0].FP1.x)/2;
									 LSP.y = 0.0f;
								 }
								 else {
									 LSP = Math.OnIntersect(LeftOutLine[0].FP0, LeftOutLine[0].FP1, LT, RT);
								 }

								 SingleLine->IRoi->SetOrgX  ((int)LSP.x+3 );
								 SingleLine->IRoi->SetOrgY  (0            );
								 SingleLine->IRoi->SetWidth (100          );
								 SingleLine->IRoi->SetHeight(ImgH         );

								 if(((LSP.x+3)<=0) || ImgH<=0) return false;

								 // 								if(IRoi->GetHeight()<300) SingleLine->SetIncrement(5 );
								 // 								else                      SingleLine->SetIncrement(100);

								 if(FShape==shRectC) SingleLine->SetIncrement(5 );
								 else                SingleLine->SetIncrement(30);

								 // 연마량 측정 OutLine
								 SingleLine->SetFindLineId(0);
								 SingleLine->SetOrientation(orWest);
								 SingleLine->SetEdgeType(0); // Black to White 
								 SingleLine->OnExecute();
								 LeftInLine[0].FP0 = SingleLine->GetResultP0();
								 LeftInLine[0].FP1 = SingleLine->GetResultP1();

								 SingleLine->SetEdgeType(2); // Line Search Org 

								 // LeftInLine None....make InLine Data 
								 // 현재의 데이터를 넘겨준다 
								 if(LeftInLine[0].FP0.x!=0.0f && LeftInLine[0].FP0.y!=0.0f && LeftInLine[0].FP1.x!=0.0f && LeftInLine[0].FP1.y!=0.0f){
									 PreLeftInLine[0].FP0.x = LeftInLine[0].FP0.x;    PreLeftInLine[0].FP1.x = LeftInLine[0].FP1.x;       
									 PreLeftInLine[0].FP0.y = LeftInLine[0].FP0.y;    PreLeftInLine[0].FP1.y = LeftInLine[0].FP1.y;       
								 }
								 else if(LeftInLine[0].FP0.x==0.0f || LeftInLine[0].FP0.y==0.0f || LeftInLine[0].FP1.x==0.0f || LeftInLine[0].FP1.y==0.0f){
									 if(PreLeftInLine[0].FP0.x==0.0f && PreLeftInLine[0].FP0.y==0.0f && PreLeftInLine[0].FP1.x==0.0f && PreLeftInLine[0].FP1.y==0.0f){// 시작부분 Broken발생으로 데이터가 없는경우 
										 // Mark좌표를 기준으로 라인좌표값을 다시 설정함 
										 ROI_H = IRoi->GetHeight();
										 ROI_L = IRoi->GetOrgX()  ;
										 LeftInLine[0].FP0.x = ROI_L;   LeftInLine[0].FP0.y = 0.0f        ;
										 LeftInLine[0].FP1.x = ROI_L;   LeftInLine[0].FP1.y = (float)ROI_H;

										 //Line 데이터를 PreLine에 넘겨준다 
										 PreLeftInLine[0].FP0.x = LeftInLine[0].FP0.x;    PreLeftInLine[0].FP1.x = LeftInLine[0].FP1.x;       
										 PreLeftInLine[0].FP0.y = LeftInLine[0].FP0.y;    PreLeftInLine[0].FP1.y = LeftInLine[0].FP1.y;       
									 }
									 else {                                                                                                    // 중간부분 Broken발생으로 데이터가 없는경우 
										 // PreLine 데이터를 넘겨줌 
										 LeftInLine[0].FP0.x = PreLeftInLine[0].FP0.x;  LeftInLine[0].FP1.x = PreLeftInLine[0].FP1.x;  
										 LeftInLine[0].FP0.y = PreLeftInLine[0].FP0.y;  LeftInLine[0].FP1.y = PreLeftInLine[0].FP1.y;  
									 }
								 }
								 // NOTCH CELL Btm 검사에서만 연마폭 측정함 
								 Left_Grind_Width =(float)(Math.GetLengthFrLineToPoint (LeftOutLine[0].FP0,LeftOutLine[0].FP1, LeftInLine[0].FP0 ));

								 //LeftTrackLine Data Overlap 
								 /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
								 if(AvgLeftTrackLineDis!=0){
									 // 									LeftOutLine[0].FP0.y = LeftOutLine[0].FP0.y + ImageHeight; //전체 이미지 기준 y좌표
									 // 									LeftOutLine[0].FP1.y = LeftOutLine[0].FP1.y + ImageHeight; //전체 이미지 기준 y좌표
									 // 
									 // 									MarkToTrackLineDis1 = Math.GetLengthFrLineToPoint(LeftMarkSta, LeftMarkEnd, LeftOutLine[0].FP0);//Mark라인에서 OutLine까지 거리 
									 // 									MarkToTrackLineDis2 = Math.GetLengthFrLineToPoint(LeftMarkSta, LeftMarkEnd, LeftOutLine[0].FP1);//Mark라인에서 OutLine까지 거리 
									 // 
									 // 									if(MarkToTrackLineDis1>AvgLeftTrackLineDis) LeftTrackLine[0].FP0.x = LeftOutLine[0].FP0.x+(MarkToTrackLineDis1 - AvgLeftTrackLineDis);
									 // 									if(MarkToTrackLineDis2>AvgLeftTrackLineDis) LeftTrackLine[0].FP1.x = LeftOutLine[0].FP1.x+(MarkToTrackLineDis2 - AvgLeftTrackLineDis);
									 // 
									 // 									// LeftOutLine Data 원본 
									 // 									LeftOutLine[0].FP0.y = LeftOutLine[0].FP0.y - ImageHeight; 
									 // 									LeftOutLine[0].FP1.y = LeftOutLine[0].FP1.y - ImageHeight; 
									 // 
									 // 									LeftTrackLine[0].FP0.y = LeftOutLine[0].FP0.y;
									 // 									LeftTrackLine[0].FP1.y = LeftOutLine[0].FP1.y;
									 /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
								 }
							 }
						 }
						 else {
							 if(IsMarkBtm){ //LeftTrackLine Search 
								 if(FInspectMode==Insp_Track){
									 //BinaryImg.SetSize(GImage->GetWidth(), GImage->GetHeight());
									 //EasyImage::Oper(EArithmeticLogicOperation_Copy,GImage,&BinaryImg);
									 EasyImage::Threshold(GImage,&BinaryImg, CirGrindMeaThresHold);

									 // LeftOutLine 기준 LeftTrackLine 검출 
									 SingleLine->GImage = &BinaryImg;

									 // 영역설정 
									 if(fabs(LeftOutLine[0].FP0.x - LeftOutLine[0].FP1.x) > 3){
										 LSP.x = (LeftOutLine[0].FP0.x + LeftOutLine[0].FP1.x)/2;
										 LSP.y = 0.0f;
									 }
									 else {
										 LSP = Math.OnIntersect(LeftOutLine[0].FP0, LeftOutLine[0].FP1, LT, RT);
									 }

									 if(FShape==shRectC){
										 SingleLine->IRoi->SetOrgX  ((int)LSP.x+3 );
										 SingleLine->IRoi->SetOrgY  (0            );
										 SingleLine->IRoi->SetWidth (47           );
										 SingleLine->IRoi->SetHeight(FEndLine-CSideCircleHeight);
										 SingleLine->SetIncrement(1 );
										 if(((LSP.x+3)<=0) || ImgH<=0) return false;
									 }
									 else {
										 SingleLine->IRoi->SetOrgX  ((int)LSP.x+3 );
										 SingleLine->IRoi->SetOrgY  (0            );
										 // 										 SingleLine->IRoi->SetWidth (47           );
										 SingleLine->IRoi->SetWidth (70           );
										 SingleLine->IRoi->SetHeight(ImgH         );
										 SingleLine->SetIncrement(50);
										 if(((LSP.x+3)<=0) || ImgH<=0) return false;
									 }

									 // Left Track Line Search 
									 SingleLine->SetFindLineId(0);
									 SingleLine->SetOrientation(orWest);
									 SingleLine->SetEdgeType(0); // Black To White
									 SingleLine->OnExecute();
									 LeftTrackLine[0].FP0 = SingleLine->GetResultP0();
									 LeftTrackLine[0].FP1 = SingleLine->GetResultP1();

									 SingleLine->SetEdgeType(2); // Line Search Type Normal 

									 // LeftTrackLine....Make OutLine Data 
									 // 현재의 데이터를 넘겨준다 
									 // 검사중 기준라인을 찾지 못할경우 이전데이터 넘겨줘서 기준라인 생성함 
									 if(LeftTrackLine[0].FP0.x!=0.0f && LeftTrackLine[0].FP0.y!=0.0f && LeftTrackLine[0].FP1.x!=0.0f && LeftTrackLine[0].FP1.y!=0.0f){
										 PreLeftTrackLine[0].FP0.x = LeftTrackLine[0].FP0.x;    PreLeftTrackLine[0].FP1.x = LeftTrackLine[0].FP1.x;       
										 PreLeftTrackLine[0].FP0.y = LeftTrackLine[0].FP0.y;    PreLeftTrackLine[0].FP1.y = LeftTrackLine[0].FP1.y;       
									 } // 셀의 상단 시작부터 Broken 발생으로 데이터가 없는경우 
									 else if(LeftTrackLine[0].FP0.x==0.0f || LeftTrackLine[0].FP0.y==0.0f || LeftTrackLine[0].FP1.x==0.0f || LeftTrackLine[0].FP1.y==0.0f){
										 if(PreLeftTrackLine[0].FP0.x==0.0f && PreLeftTrackLine[0].FP0.y==0.0f && PreLeftTrackLine[0].FP1.x==0.0f && PreLeftTrackLine[0].FP1.y==0.0f){// 시작부분 Broken발생으로 데이터가 없는경우 
											 // Mark좌표를 기준으로 라인좌표값을 다시 설정함 
											 ROI_H = IRoi->GetHeight();
											 ROI_L = IRoi->GetOrgX()  ;
											 LeftTrackLine[0].FP0.x = ROI_L;    LeftTrackLine[0].FP0.y = 0.0f        ;
											 LeftTrackLine[0].FP1.x = ROI_L;    LeftTrackLine[0].FP1.y = (float)ROI_H;

											 //LeftTrackLine 데이터를 PreLeftTrackLine에 넘겨준다 
											 PreLeftTrackLine[0].FP0.x = LeftTrackLine[0].FP0.x;    PreLeftTrackLine[0].FP1.x = LeftTrackLine[0].FP1.x;       
											 PreLeftTrackLine[0].FP0.y = LeftTrackLine[0].FP0.y;    PreLeftTrackLine[0].FP1.y = LeftTrackLine[0].FP1.y;       
										 }
										 else { // 중간부분 Broken발생으로 데이터가 없는경우 
											 // PreLeftTrackLine 데이터를 넘겨줌 
											 LeftTrackLine[0].FP0.x = PreLeftTrackLine[0].FP0.x;  LeftTrackLine[0].FP1.x = PreLeftTrackLine[0].FP1.x;  
											 LeftTrackLine[0].FP0.y = PreLeftTrackLine[0].FP0.y;  LeftTrackLine[0].FP1.y = PreLeftTrackLine[0].FP1.y;  
										 }
									 }

									 // 마크라인에서 부터 LeftTrackLine 까지 거리 산출 
									 // LeftTrackLine Data 존재할 경우 거리 측정함 
									 // Image Rotate 없음
									 // 외곽기준으로 EnCap에 데이터 오버랩 목적으로 데이터 계산함 
									 if(LeftTrackLine[0].FP0.x!=0.0f && LeftTrackLine[0].FP0.y!=0.0f && LeftTrackLine[0].FP1.x!=0.0f && LeftTrackLine[0].FP1.y!=0.0f){
										 if(LeftOutLine[0].FP0.x!=0.0f && LeftOutLine[0].FP0.y!=0.0f && LeftOutLine[0].FP1.x!=0.0f && LeftOutLine[0].FP1.y!=0.0f){
											 LeftToTrackLineDis1 = Math.GetLengthFrLineToPoint(LeftOutLine[0].FP0, LeftOutLine[0].FP1, LeftTrackLine[0].FP0);//외곽라인에서 TrackLine거리 
											 LeftToTrackLineDis2 = Math.GetLengthFrLineToPoint(LeftOutLine[0].FP0, LeftOutLine[0].FP1, LeftTrackLine[0].FP1);//외곽라인에서 TrackLine거리 

											 TotalLeftTrackDis  +=  (int)((LeftToTrackLineDis1 + LeftToTrackLineDis2)/2.0); //Mark라인에서 TrackLine거리 누적                   
											 LeftTrackLineCount++; //누적 카운트 증가
										 }
									 }
								 }
							 }
							 else {//EnCap(Top영역) LeftTrackLine Data Overlap 
								 //LeftTrackLine Data Overlap 
								 /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
								 if(AvgLeftTrackLineDis!=0){
									 if(FInspectMode==Insp_Track){ // TrackMode 외곽라인 기준  
										 if(LeftOutLine[0].FP0.x!=0.0f && LeftOutLine[0].FP0.y!=0.0f && LeftOutLine[0].FP1.x!=0.0f && LeftOutLine[0].FP1.y!=0.0f){
											 // TOP영역 LeftTrackLine x좌표 
											 LeftTrackLine[0].FP0.x = LeftOutLine[0].FP0.x+AvgLeftTrackLineDis;
											 LeftTrackLine[0].FP1.x = LeftOutLine[0].FP1.x+AvgLeftTrackLineDis;

											 // TOP영역 LeftTrackLine y좌표 
											 LeftTrackLine[0].FP0.y = LeftOutLine[0].FP0.y;
											 LeftTrackLine[0].FP1.y = LeftOutLine[0].FP1.y;
										 }
									 }
								 }
							 }
						 }
					 }
                 }
                 if (FTopWall) {
					 if(FCompanyMode==COM_TIANMA) {
						 if(IsMarkLine) EasyImage::Threshold(GImage,&BinaryImg, TopEdgeThresHold);
						 else           EasyImage::Threshold(GImage,&BinaryImg, EThresHold      );

						 if(EThresHold==0 )    {SingleLine->GImage = GImage;     SingleLine->FThreshold =5 ;}
						 else                  {SingleLine->GImage = &BinaryImg; SingleLine->FThreshold =10;} 

						 SingleLine->IRoi->SetOrgX  (IRoi->GetOrgX());
						 SingleLine->IRoi->SetOrgY  (IRoi->GetOrgY());
						 SingleLine->IRoi->SetWidth (IRoi->GetWidth());
						 SingleLine->IRoi->SetHeight(IRoi->GetHeight());
						 if(IRoi->GetOrgX()<=0 || IRoi->GetWidth()<=0 || IRoi->GetHeight()<=0){
							 return false;
						 }

						 if(IsShortCell && IsMarkLine) nTopBtmStart = IRoi->GetOrgX();

						 SingleLine->SetOrientation(orNorth);
						 SingleLine->FIncrement =10;
						 SingleLine->SetFindLineId(0);
						 SingleLine->FThreshold =5;
						 SingleLine->OnExecute();
						 Line[1].FP0 = SingleLine->GetResultP0();
						 Line[1].FP1 = SingleLine->GetResultP1();

						 if(TopOffset!=0){
							 TopBMLine[0].FP0.x = FP0.x;
							 TopBMLine[0].FP0.y = FP0.y;
							 TopBMLine[0].FP1.x = FP1.x;
							 TopBMLine[0].FP1.y = FP1.y;
						 }
					 }
					 else if(FCompanyMode==COM_KWON) {
						 EasyImage::Threshold(GImage,&BinaryImg, TopEdgeThresHold);
						 if(TopEdgeThresHold==0)  {SingleLine->GImage = GImage;     SingleLine->FThreshold =5 ;}
						 else                     {SingleLine->GImage = &BinaryImg; SingleLine->FThreshold =10;}

						 SingleLine->IRoi->SetOrgX  (IRoi->GetOrgX());
						 SingleLine->IRoi->SetOrgY  (IRoi->GetOrgY());
						 SingleLine->IRoi->SetWidth (IRoi->GetWidth());
						 SingleLine->IRoi->SetHeight(IRoi->GetHeight());
						 if(IRoi->GetOrgX()<=0 || IRoi->GetWidth()<=0 || IRoi->GetHeight()<=0){
							 return false;
						 }

						 if(IsShortCell && IsMarkLine) nTopBtmStart = IRoi->GetOrgX();

						 SingleLine->SetOrientation(orNorth);
						 SingleLine->FIncrement =10;
						 SingleLine->SetFindLineId(0);
						 SingleLine->FThreshold =5;
						 SingleLine->OnExecute();
						 Line[1].FP0 = SingleLine->GetResultP0();
						 Line[1].FP1 = SingleLine->GetResultP1();

						 if(TopOffset!=0){
							 TopBMLine[0].FP0.x = FP0.x;
							 TopBMLine[0].FP0.y = FP0.y;
							 TopBMLine[0].FP1.x = FP1.x;
							 TopBMLine[0].FP1.y = FP1.y;
						 }
					 }
					 else if(FCompanyMode==COM_BOE){  // TOP LineSearch 
						 EasyImage::Threshold(GImage,&BinaryImg, TopEdgeThresHold);
						 if(TopEdgeThresHold==0)  {SingleLine->GImage = GImage;     SingleLine->FThreshold =5 ;}
						 else                     {SingleLine->GImage = &BinaryImg; SingleLine->FThreshold =10;}

						 SingleLine->IRoi->SetOrgX  (IRoi->GetOrgX());
						 SingleLine->IRoi->SetOrgY  (IRoi->GetOrgY());
						 SingleLine->IRoi->SetWidth (IRoi->GetWidth());
						 SingleLine->IRoi->SetHeight(IRoi->GetHeight());
						 if(IRoi->GetOrgX()<=0 || IRoi->GetWidth()<=0 || IRoi->GetHeight()<=0){
							 return false;
						 }

// 						 if(IsShortCell && IsMarkLine) nTopBtmStart = IRoi->GetOrgX();

						 SingleLine->SetOrientation(orNorth);
						 SingleLine->FIncrement =10;
						 SingleLine->SetFindLineId(0);
						 SingleLine->FThreshold =5;
						 SingleLine->OnExecute();
						 Line[1].FP0 = SingleLine->GetResultP0();
						 Line[1].FP1 = SingleLine->GetResultP1();
					 }
					 else if(FCompanyMode==COM_NOTCH){ // TopLine
						 EasyImage::Threshold(GImage,&BinaryImg, TopEdgeThresHold);
						 if(TopEdgeThresHold==0)  {SingleLine->GImage = GImage;     SingleLine->FThreshold =5 ;}
						 else                     {SingleLine->GImage = &BinaryImg; SingleLine->FThreshold =10;}

						 SingleLine->IRoi->SetOrgX  (IRoi->GetOrgX());
						 SingleLine->IRoi->SetOrgY  (IRoi->GetOrgY());
						 SingleLine->IRoi->SetWidth (IRoi->GetWidth());
						 SingleLine->IRoi->SetHeight(IRoi->GetHeight());
						 if(IRoi->GetOrgX()<=0 || IRoi->GetWidth()<=0 || IRoi->GetHeight()<=0){
							 return false;
						 }

						 SingleLine->SetOrientation(orNorth);
						 SingleLine->FIncrement =100;
						 SingleLine->SetFindLineId(0);
						 SingleLine->FThreshold =5;

						 if(FCutMode==Normal_Cut) SingleLine->SetEdgeType(0);  // Black To White
						 if(FCutMode==CAI_Cut   ) SingleLine->SetEdgeType(1);  // White To Black 
                         
						 SingleLine->OnExecute();
						 Line[1].FP0 = SingleLine->GetResultP0();
						 Line[1].FP1 = SingleLine->GetResultP1();
					 }
					 else if(FCompanyMode==COM_BMDT){  // 기본 TopLine 표면검사,외관검사 동일하게 사용
						 EasyImage::Threshold(GImage,&BinaryImg, TopEdgeThresHold);
						 if(TopEdgeThresHold==0)  {SingleLine->GImage = GImage;     SingleLine->FThreshold =5 ;}
						 else                     {SingleLine->GImage = &BinaryImg; SingleLine->FThreshold =10;}

						 SingleLine->IRoi->SetOrgX  (IRoi->GetOrgX());
						 SingleLine->IRoi->SetOrgY  (IRoi->GetOrgY());
						 SingleLine->IRoi->SetWidth (IRoi->GetWidth());
						 SingleLine->IRoi->SetHeight(IRoi->GetHeight());
						 if(IRoi->GetOrgX()<=0 || IRoi->GetWidth()<=0 || IRoi->GetHeight()<=0){
							 return false;
						 }

						 SingleLine->SetOrientation(orNorth);
						 SingleLine->FIncrement =100;
						 SingleLine->SetFindLineId(0);
						 SingleLine->FThreshold =5;

						 if(FInspectMode==Insp_Surface) SingleLine->SetEdgeType(1);  // White To Black 
						 else                           SingleLine->SetEdgeType(0);  // Black To White  

						 SingleLine->OnExecute();
						 Line[1].FP0 = SingleLine->GetResultP0();
						 Line[1].FP1 = SingleLine->GetResultP1();
					 }
                 }
                 if (FRightWall) {
					 if(FCompanyMode==COM_TIANMA) { // 천마 검사 시퀀스 
						 EasyImage::Threshold(GImage,&BinaryImg, EThresHold);
						 if(EThresHold==0)        {SingleLine->GImage = GImage;     SingleLine->FThreshold =5 ;}
						 else                     {SingleLine->GImage = &BinaryImg; SingleLine->FThreshold =10;}

						 SingleLine->IRoi->SetOrgX  (IRoi->GetOrgX());
						 SingleLine->IRoi->SetOrgY  (IRoi->GetOrgY());
						 SingleLine->IRoi->SetWidth (IRoi->GetWidth());
						 SingleLine->IRoi->SetHeight(IRoi->GetHeight());

						 if(IRoi->GetOrgX()<=0 || IRoi->GetWidth()<=0 || IRoi->GetHeight()<=0){
							 return false;
						 }
						  
						 SingleLine->SetOrientation(orEast);
						 SingleLine->FIncrement =10;
						 SingleLine->SetFindLineId(0);
						 SingleLine->FThreshold =5;
						 SingleLine->OnExecute();
						 Line[waRightWall].FP0 = SingleLine->GetResultP0();
						 Line[waRightWall].FP1 = SingleLine->GetResultP1();

					 }
					 else if(FCompanyMode==COM_KWON) {            // 광원 검사 시퀀스 
						 EasyImage::Threshold(GImage,&BinaryImg, RightEdgeThresHold);
						 if(RightEdgeThresHold==0)  {SingleLine->GImage = GImage;     SingleLine->FThreshold =5 ;}
						 else                       {SingleLine->GImage = &BinaryImg; SingleLine->FThreshold =10;}

						 SingleLine->IRoi->SetOrgX  (IRoi->GetOrgX());
						 SingleLine->IRoi->SetOrgY  (IRoi->GetOrgY());
						 SingleLine->IRoi->SetWidth (IRoi->GetWidth());
						 SingleLine->IRoi->SetHeight(IRoi->GetHeight());
						 
						 SingleLine->SetOrientation(orEast);
						 SingleLine->FIncrement =10;
						 SingleLine->SetFindLineId(0);
						 SingleLine->FThreshold =5;
						 SingleLine->OnExecute();
						 Line[waRightWall].FP0 = SingleLine->GetResultP0();
						 Line[waRightWall].FP1 = SingleLine->GetResultP1();

						 // RightLineData 
						 RightLineData = (float)((Line[waRightWall].FP0.x + Line[waRightWall].FP1.x)/2.0);

						 if(FShape!=shRectH){
							 if(RightOffset!=0 && RightBmLineThresHold!=0){
								 // ThresHold 설정 
								 BMLineImg.SetSize(GImage->GetWidth(), GImage->GetHeight());
								 EasyImage::Oper(EArithmeticLogicOperation_Copy,GImage,&BMLineImg);
								 EasyImage::Threshold(GImage,&BMLineImg, RightBmLineThresHold);
								 
								 SingleLine->GImage = &BMLineImg;
								 
								 // 영역설정 
								 if(fabs(Line[2].FP0.x - Line[2].FP1.x) > 1){
									 LSP.x = (Line[2].FP0.x + Line[2].FP1.x)/2;
									 LSP.y = 0.0f;
								 }
								 else {
									 LSP = Math.OnIntersect(Line[2].FP0, Line[2].FP1, LT, RT);
								 }


                                 // 20160226 
								 if(IsMarkBtm){
									 // 검사 영역 설정 
									 SingleLine->IRoi->SetOrgX  ((int)LSP.x-BMWidth);
									 SingleLine->IRoi->SetOrgY  (0                 );
									 //SingleLine->IRoi->SetWidth (BMWidth-2         );
									 //SingleLine->IRoi->SetWidth (BMWidth-RightOffset/2);
									 SingleLine->IRoi->SetWidth (BMWidth-(RightOffset-4));
									 SingleLine->IRoi->SetHeight(ImgH              );
                                     SingleLine->SetEdgeType(0);
									 if((LSP.x<0) || (LSP.x-BMWidth)<=0 || (BMWidth-(RightOffset-4))<=0) return false;

									 // 영역에서 Line 찾기 
									 SingleLine->SetOrientation(orEast);
									 SingleLine->FIncrement =10;
									 SingleLine->SetFindLineId(0);
									 SingleLine->OnExecute();
									 RightBMLine[0].FP0 = SingleLine->GetResultP0();
									 RightBMLine[0].FP1 = SingleLine->GetResultP1();
								 }
								 else {
									 if(LeftBMLine[0].FP0.x!=0.0f && LeftBMLine[0].FP0.y!=0.0f && LeftBMLine[0].FP1.x!=0.0f && LeftBMLine[0].FP1.y!=0.0f){
                                         RightBMLine[0].FP0.x = LeftBMLine[0].FP0.x + BMLineDistance;
										 RightBMLine[0].FP0.y = LeftBMLine[0].FP0.y                 ; 
										 RightBMLine[0].FP1.x = LeftBMLine[0].FP1.x + BMLineDistance;
										 RightBMLine[0].FP1.y = LeftBMLine[0].FP1.y                 ; 
									 }
								 }

								 // SingleLine Org Parameter 
								 SingleLine->SetEdgeType(2);

                                 /*
								 SingleLine->IRoi->SetOrgX  ((int)LSP.x-BMWidth);
								 SingleLine->IRoi->SetOrgY  (0                 );
								 SingleLine->IRoi->SetWidth (BMWidth-(RightOffset-4));
								 SingleLine->IRoi->SetHeight(ImgH              );
								 SingleLine->SetEdgeType(0);
								 if((LSP.x<0) || (LSP.x-BMWidth)<=0 || (BMWidth-(RightOffset-4))<=0) return false;
								 
								 if(IsMarkBtm) SingleLine->SetEdgeType(0);
								 else          SingleLine->SetEdgeType(1);

								 // 영역에서 Line 찾기 
								 SingleLine->SetOrientation(orEast);
								 SingleLine->FIncrement =10;
								 SingleLine->SetFindLineId(0);
								 SingleLine->OnExecute();
								 RightBMLine[0].FP0 = SingleLine->GetResultP0();
								 RightBMLine[0].FP1 = SingleLine->GetResultP1();

								 // SingleLine Org Parameter 
								 SingleLine->SetEdgeType(2);
								 */
							 }
						 }
					 }
					 else if(FCompanyMode==COM_NOTCH){ //기본 Right Line
						 EasyImage::Threshold(GImage,&BinaryImg, RightEdgeThresHold);
						 if(LeftEdgeThresHold==0) {SingleLine->GImage = GImage;     SingleLine->FThreshold =5 ;}
						 else                     {SingleLine->GImage = &BinaryImg; SingleLine->FThreshold =10;}

						 // 영상이상함 Test목적...나중에 소스 지워야함 
// 						 if(IsMarkBtm) SingleLine->SetEdgeType(0); // Black to White 
// 						 else          SingleLine->SetEdgeType(1); // White to Black  

						 if(FShape==shRectC){
							 SingleLine->IRoi->SetOrgX  (IRoi->GetOrgX()          );
							 SingleLine->IRoi->SetOrgY  (IRoi->GetOrgY()          );
							 SingleLine->IRoi->SetWidth (IRoi->GetWidth()         );
							 SingleLine->IRoi->SetHeight(FEndLine-CSideCircleHeight);
                             SingleLine->SetIncrement(1 );
						 }
						 else if(FShape==shRectH){
							 if(IsCircleTop){
								 SingleLine->IRoi->SetOrgX  (IRoi->GetOrgX()  );
								 SingleLine->IRoi->SetOrgY  (ASideCircleHeight+50);
								 SingleLine->IRoi->SetWidth (IRoi->GetWidth() );
								 SingleLine->IRoi->SetHeight(ImgH-(ASideCircleHeight+50));
								 SingleLine->SetIncrement(1 );
							 }
							 else {
								 SingleLine->IRoi->SetOrgX  (IRoi->GetOrgX()  );
								 SingleLine->IRoi->SetOrgY  (IRoi->GetOrgY()  );
								 SingleLine->IRoi->SetWidth (IRoi->GetWidth() );
								 SingleLine->IRoi->SetHeight(IRoi->GetHeight());
								 SingleLine->SetIncrement(50 );
							 }
						 }
						 else {
							 SingleLine->IRoi->SetOrgX  (IRoi->GetOrgX());
							 SingleLine->IRoi->SetOrgY  (IRoi->GetOrgY());
							 SingleLine->IRoi->SetWidth (IRoi->GetWidth());
							 SingleLine->IRoi->SetHeight(IRoi->GetHeight());
							 ROI_H = IRoi->GetHeight();
							 if(ROI_H<700)  SingleLine->SetIncrement(50 );
							 else 	        SingleLine->SetIncrement(100);
						 }

						 SingleLine->SetOrientation(orEast);
						 // org 
// 						 if(IRoi->GetHeight()<350) SingleLine->SetIncrement(5 );
// 						 else                      SingleLine->SetIncrement(30);

						 SingleLine->SetFindLineId(0);
						 SingleLine->FThreshold =10;
// 						 SingleLine->SetEdgeType(1);  // White To Black 
						 // TEST 
						 if(IsMarkBtm) SingleLine->SetEdgeType(0); // Black to White 
						 else          SingleLine->SetEdgeType(1); // White to Black  

						 SingleLine->OnExecute();
						 Line[2].FP0 = SingleLine->GetResultP0();
						 Line[2].FP1 = SingleLine->GetResultP1();

						 // Btm,Top 상관없이 첫번째
						 RightOutLine[0].FP0.x = Line[2].FP0.x;
						 RightOutLine[0].FP0.y = Line[2].FP0.y;
						 RightOutLine[0].FP1.x = Line[2].FP1.x;
						 RightOutLine[0].FP1.y = Line[2].FP1.y;

						 // LeftOutLine....make OutLine Data 
						 // 현재의 데이터를 넘겨준다 
						 // 검사중 기준라인을 찾지 못할경우 이전데이터 넘겨줘서 기준라인 생성함 
						 if(RightOutLine[0].FP0.x!=0.0f && RightOutLine[0].FP0.y!=0.0f && RightOutLine[0].FP1.x!=0.0f && RightOutLine[0].FP1.y!=0.0f){
							 PreRightOutLine[0].FP0.x = RightOutLine[0].FP0.x;    PreRightOutLine[0].FP1.x = RightOutLine[0].FP1.x;       
							 PreRightOutLine[0].FP0.y = RightOutLine[0].FP0.y;    PreRightOutLine[0].FP1.y = RightOutLine[0].FP1.y;       
						 } // 셀의 상단 시작부터 Broken 발생으로 데이터가 없는경우 
						 else if(RightOutLine[0].FP0.x==0.0f || RightOutLine[0].FP0.y==0.0f || RightOutLine[0].FP1.x==0.0f || RightOutLine[0].FP1.y==0.0f){
							 if(PreRightOutLine[0].FP0.x==0.0f && PreRightOutLine[0].FP0.y==0.0f && PreRightOutLine[0].FP1.x==0.0f && PreRightOutLine[0].FP1.y==0.0f){// 시작부분 Broken발생으로 데이터가 없는경우 
								 // Mark좌표를 기준으로 라인좌표값을 다시 설정함 
								 ROI_H = IRoi->GetHeight();
								 RightOutLine[0].FP0.x = Line[2].FP0.x;    RightOutLine[0].FP0.y = 0.0f        ;
								 RightOutLine[0].FP1.x = Line[2].FP1.x;    RightOutLine[0].FP1.y = (float)ROI_H;

								 //Line 데이터를 PreLine에 넘겨준다 
								 PreRightOutLine[0].FP0.x = RightOutLine[0].FP0.x;    PreRightOutLine[0].FP1.x = RightOutLine[0].FP1.x;       
								 PreRightOutLine[0].FP0.y = RightOutLine[0].FP0.y;    PreRightOutLine[0].FP1.y = RightOutLine[0].FP1.y;       
							 }
							 else { // 중간부분 Broken발생으로 데이터가 없는경우 
								 // PreLine 데이터를 넘겨줌 
								 RightOutLine[0].FP0.x = PreRightOutLine[0].FP0.x;  RightOutLine[0].FP1.x = PreRightOutLine[0].FP1.x;  
								 RightOutLine[0].FP0.y = PreRightOutLine[0].FP0.y;  RightOutLine[0].FP1.y = PreRightOutLine[0].FP1.y;  
							 }
						 }

						 if(IsAllGrind){
							 if(IsMarkBtm){ // RightInLine, RightTrackLine Search 
								 // RightInLine Search Start 
								 /////////////////////////////////////////////////////////////////////////////
								 EasyImage::Threshold(GImage,&BinaryImg, RightEdgeThresHold);
								 SingleLine->GImage = &BinaryImg;

								 // 영역설정 
								 if(fabs(RightOutLine[0].FP0.x - RightOutLine[0].FP1.x) > 3){
									 LSP.x = (RightOutLine[0].FP0.x + RightOutLine[0].FP1.x)/2;
									 LSP.y = 0.0f;
								 }
								 else {
									 LSP = Math.OnIntersect(RightOutLine[0].FP0, RightOutLine[0].FP1, LT, RT);
								 }

								 SingleLine->IRoi->SetOrgX  ((int)LSP.x-100);
								 SingleLine->IRoi->SetOrgY  (0             );
								 SingleLine->IRoi->SetWidth (97            );
								 SingleLine->IRoi->SetHeight(ImgH          );

								 if(((LSP.x+3)<=0) || ImgH<=0) return false;

								 if(IRoi->GetHeight()<300) SingleLine->SetIncrement(5 );
								 else                      SingleLine->SetIncrement(100);

								 // 연마량 측정 OutLine
								 SingleLine->SetFindLineId(0);
								 SingleLine->SetOrientation(orEast);
								 SingleLine->SetEdgeType(0); // Black to White 
								 SingleLine->OnExecute();
								 RightInLine[0].FP0 = SingleLine->GetResultP0();
								 RightInLine[0].FP1 = SingleLine->GetResultP1();

								 SingleLine->SetEdgeType(2); // Line Search Org 

								 // RightInLine None....make InLine Data 
								 // 현재의 데이터를 넘겨준다 
								 if(RightInLine[0].FP0.x!=0.0f && RightInLine[0].FP0.y!=0.0f && RightInLine[0].FP1.x!=0.0f && RightInLine[0].FP1.y!=0.0f){
									 PreRightInLine[0].FP0.x = RightInLine[0].FP0.x;    PreRightInLine[0].FP1.x = RightInLine[0].FP1.x;       
									 PreRightInLine[0].FP0.y = RightInLine[0].FP0.y;    PreRightInLine[0].FP1.y = RightInLine[0].FP1.y;       
								 }
								 else if(RightInLine[0].FP0.x==0.0f || RightInLine[0].FP0.y==0.0f || RightInLine[0].FP1.x==0.0f || RightInLine[0].FP1.y==0.0f){
									 if(PreRightInLine[0].FP0.x==0.0f && PreRightInLine[0].FP0.y==0.0f && PreRightInLine[0].FP1.x==0.0f && PreRightInLine[0].FP1.y==0.0f){// 시작부분 Broken발생으로 데이터가 없는경우 
										 // Mark좌표를 기준으로 라인좌표값을 다시 설정함 
										 ROI_H = IRoi->GetHeight();
										 ROI_L = IRoi->GetOrgX()  ;
										 RightInLine[0].FP0.x = ROI_L;   RightInLine[0].FP0.y = 0.0f        ;
										 RightInLine[0].FP1.x = ROI_L;   RightInLine[0].FP1.y = (float)ROI_H;

										 //Line 데이터를 PreLine에 넘겨준다 
										 PreRightInLine[0].FP0.x = RightInLine[0].FP0.x;    PreRightInLine[0].FP1.x = RightInLine[0].FP1.x;       
										 PreRightInLine[0].FP0.y = RightInLine[0].FP0.y;    PreRightInLine[0].FP1.y = RightInLine[0].FP1.y;       
									 }
									 else {                                                                                                    // 중간부분 Broken발생으로 데이터가 없는경우 
										 // PreLine 데이터를 넘겨줌 
										 RightInLine[0].FP0.x = PreRightInLine[0].FP0.x;  RightInLine[0].FP1.x = PreRightInLine[0].FP1.x;  
										 RightInLine[0].FP0.y = PreRightInLine[0].FP0.y;  RightInLine[0].FP1.y = PreRightInLine[0].FP1.y;  
									 }
								 }
								 // NOTCH CELL Btm 검사에서만 연마폭 측정함 
								 Right_Grind_Width =(float)(Math.GetLengthFrLineToPoint (RightOutLine[0].FP0,RightOutLine[0].FP1, RightInLine[0].FP0 ));
								 // RightInLine Search End
								 /////////////////////////////////////////////////////////////////////////////


								 // Right TrackLine Search 
								 /////////////////////////////////////////////////////////////////////////////////////////////
								 // 									 BinaryImg.SetSize(GImage->GetWidth(), GImage->GetHeight());
								 // 									 EasyImage::Oper(EArithmeticLogicOperation_Copy,GImage,&BinaryImg);
								 EasyImage::Threshold(GImage,&BinaryImg, CirGrindMeaThresHold);
								 SingleLine->GImage = &BinaryImg;

								 // 영역설정 
								 if(fabs(RightInLine[0].FP0.x - RightInLine[0].FP1.x) > 3){
									 LSP.x = (RightInLine[0].FP0.x + RightInLine[0].FP1.x)/2;
									 LSP.y = 0.0f;
								 }
								 else {
									 LSP = Math.OnIntersect(RightInLine[0].FP0, RightInLine[0].FP1, LT, RT);
								 }

								 SingleLine->IRoi->SetOrgX  ((int)LSP.x-100);
								 SingleLine->IRoi->SetOrgY  (0             );
								 SingleLine->IRoi->SetWidth (97            );
								 SingleLine->IRoi->SetHeight(ImgH          );

								 if(((LSP.x+3)<=0) || ImgH<=0) return false;

								 if(IRoi->GetHeight()<300) SingleLine->SetIncrement(5 );
								 else                      SingleLine->SetIncrement(100);

								 // 연마량 측정 OutLine
								 SingleLine->SetFindLineId(0);
								 SingleLine->SetOrientation(orEast);
								 SingleLine->SetEdgeType(1); // White To Black  
								 SingleLine->OnExecute();
								 RightTrackLine[0].FP0 = SingleLine->GetResultP0();
								 RightTrackLine[0].FP1 = SingleLine->GetResultP1();

								 SingleLine->SetEdgeType(2); // Line Search Org 

								 // RightTrackLine....make OutLine Data 
								 // 현재의 데이터를 넘겨준다 
								 // 검사중 기준라인을 찾지 못할경우 이전데이터 넘겨줘서 기준라인 생성함 
								 if(RightTrackLine[0].FP0.x!=0.0f && RightTrackLine[0].FP0.y!=0.0f && RightTrackLine[0].FP1.x!=0.0f && RightTrackLine[0].FP1.y!=0.0f){
									 PreRightTrackLine[0].FP0.x = RightTrackLine[0].FP0.x;    PreRightTrackLine[0].FP1.x = RightTrackLine[0].FP1.x;       
									 PreRightTrackLine[0].FP0.y = RightTrackLine[0].FP0.y;    PreRightTrackLine[0].FP1.y = RightTrackLine[0].FP1.y;       
								 } // 셀의 상단 시작부터 Broken 발생으로 데이터가 없는경우 
								 else if(RightTrackLine[0].FP0.x==0.0f || RightTrackLine[0].FP0.y==0.0f || RightTrackLine[0].FP1.x==0.0f || RightTrackLine[0].FP1.y==0.0f){
									 if(PreRightTrackLine[0].FP0.x==0.0f && PreRightTrackLine[0].FP0.y==0.0f && PreRightTrackLine[0].FP1.x==0.0f && PreRightTrackLine[0].FP1.y==0.0f){// 시작부분 Broken발생으로 데이터가 없는경우 
										 // Mark좌표를 기준으로 라인좌표값을 다시 설정함 
										 ROI_H = IRoi->GetHeight();
										 ROI_L = IRoi->GetOrgX()  ;
										 RightTrackLine[0].FP0.x = ROI_L;    RightTrackLine[0].FP0.y = 0.0f        ;
										 RightTrackLine[0].FP1.x = ROI_L;    RightTrackLine[0].FP1.y = (float)ROI_H;

										 //RightTrackLine 데이터를 PreRightTrackLine에 넘겨준다 
										 PreRightTrackLine[0].FP0.x = RightTrackLine[0].FP0.x;    PreRightTrackLine[0].FP1.x = RightTrackLine[0].FP1.x;       
										 PreRightTrackLine[0].FP0.y = RightTrackLine[0].FP0.y;    PreRightTrackLine[0].FP1.y = RightTrackLine[0].FP1.y;       
									 }
									 else { // 중간부분 Broken발생으로 데이터가 없는경우 
										 // PreRightTrackLine 데이터를 넘겨줌 
										 RightTrackLine[0].FP0.x = PreRightTrackLine[0].FP0.x;  RightTrackLine[0].FP1.x = PreRightTrackLine[0].FP1.x;  
										 RightTrackLine[0].FP0.y = PreRightTrackLine[0].FP0.y;  RightTrackLine[0].FP1.y = PreRightTrackLine[0].FP1.y;  
									 }
								 }
								 // NOTCH CELL Btm 검사에서만 연마폭 측정함 
								 Right_Grind_Mea =(float)(Math.GetLengthFrLineToPoint (RightOutLine[0].FP0,RightOutLine[0].FP1,RightTrackLine[0].FP0));
								 // RightInLine Search End 
								 /////////////////////////////////////////////////////////////////////////////


								 // 마크라인에서 부터 RightTrackLine 까지 거리 산출 
								 // RightTrackLine Data 존재할 경우 거리 측정함 
								 // RightTrackLine Data 생성 
								 //////////////////////////////////////////////////////////////////////////////
								 if(RightTrackLine[0].FP0.x!=0.0f && RightTrackLine[0].FP0.y!=0.0f && RightTrackLine[0].FP1.x!=0.0f && RightTrackLine[0].FP1.y!=0.0f){
// 									 RightTrackLine[0].FP0.y = RightTrackLine[0].FP0.y + ImageHeight; //전체 이미지 기준 y좌표
// 									 RightTrackLine[0].FP1.y = RightTrackLine[0].FP1.y + ImageHeight; //전체 이미지 기준 y좌표
// 
// 									 MarkToTrackLineDis1 = Math.GetLengthFrLineToPoint(RightMarkSta, RightMarkEnd, RightTrackLine[0].FP0);//Mark라인에서 TrackLine거리 
// 									 MarkToTrackLineDis2 = Math.GetLengthFrLineToPoint(RightMarkSta, RightMarkEnd, RightTrackLine[0].FP1);//Mark라인에서 TrackLine거리 
// 
// 									 TotalRightTrackDis  +=  (int)((MarkToTrackLineDis1 + MarkToTrackLineDis2)/2.0); //Mark라인에서 TrackLine거리 누적                   
// 									 RightTrackLineCount++; //누적 카운트 증가
// 
// 									 // Org Data 
// 									 RightTrackLine[0].FP0.y = RightTrackLine[0].FP0.y - ImageHeight; //Frame 이미지 기준 y좌표 원복
// 									 RightTrackLine[0].FP1.y = RightTrackLine[0].FP1.y - ImageHeight; //Frame 이미지 기준 y좌표 원복 
								 }
								 // RightTrackLine Data 생성 종료 
								 ////////////////////////////////////////////////////////////////////////////////
							 }
							 else {//EnCap(Top영역) RightInLine Search , RightTrackLine Data Overlap 
								 // RightInLine Search Start 
								 /////////////////////////////////////////////////////////////////////////////
								 EasyImage::Threshold(GImage,&BinaryImg, RightEdgeThresHold);
								 SingleLine->GImage = &BinaryImg;

								 // 영역설정 
								 if(fabs(RightOutLine[0].FP0.x - RightOutLine[0].FP1.x) > 3){
									 LSP.x = (RightOutLine[0].FP0.x + RightOutLine[0].FP1.x)/2;
									 LSP.y = 0.0f;
								 }
								 else {
									 LSP = Math.OnIntersect(RightOutLine[0].FP0, RightOutLine[0].FP1, LT, RT);
								 }

								 SingleLine->IRoi->SetOrgX  ((int)LSP.x-100);
								 SingleLine->IRoi->SetOrgY  (0             );
								 SingleLine->IRoi->SetWidth (97            );
								 SingleLine->IRoi->SetHeight(ImgH          );

								 if(((LSP.x+3)<=0) || ImgH<=0) return false;

								 if(IRoi->GetHeight()<300) SingleLine->SetIncrement(5 );
								 else                      SingleLine->SetIncrement(100);

								 // 연마량 측정 OutLine
								 SingleLine->SetFindLineId(0);
								 SingleLine->SetOrientation(orEast);
								 SingleLine->SetEdgeType(0); // Black to White 
								 SingleLine->OnExecute();
								 RightInLine[0].FP0 = SingleLine->GetResultP0();
								 RightInLine[0].FP1 = SingleLine->GetResultP1();

								 SingleLine->SetEdgeType(2); // Line Search Org 

								 // RightInLine None....make InLine Data 
								 // 현재의 데이터를 넘겨준다 
								 if(RightInLine[0].FP0.x!=0.0f && RightInLine[0].FP0.y!=0.0f && RightInLine[0].FP1.x!=0.0f && RightInLine[0].FP1.y!=0.0f){
									 PreRightInLine[0].FP0.x = RightInLine[0].FP0.x;    PreRightInLine[0].FP1.x = RightInLine[0].FP1.x;       
									 PreRightInLine[0].FP0.y = RightInLine[0].FP0.y;    PreRightInLine[0].FP1.y = RightInLine[0].FP1.y;       
								 }
								 else if(RightInLine[0].FP0.x==0.0f || RightInLine[0].FP0.y==0.0f || RightInLine[0].FP1.x==0.0f || RightInLine[0].FP1.y==0.0f){
									 if(PreRightInLine[0].FP0.x==0.0f && PreRightInLine[0].FP0.y==0.0f && PreRightInLine[0].FP1.x==0.0f && PreRightInLine[0].FP1.y==0.0f){// 시작부분 Broken발생으로 데이터가 없는경우 
										 // Mark좌표를 기준으로 라인좌표값을 다시 설정함 
										 ROI_H = IRoi->GetHeight();
										 ROI_L = IRoi->GetOrgX()  ;
										 RightInLine[0].FP0.x = ROI_L;   RightInLine[0].FP0.y = 0.0f        ;
										 RightInLine[0].FP1.x = ROI_L;   RightInLine[0].FP1.y = (float)ROI_H;

										 //Line 데이터를 PreLine에 넘겨준다 
										 PreRightInLine[0].FP0.x = RightInLine[0].FP0.x;    PreRightInLine[0].FP1.x = RightInLine[0].FP1.x;       
										 PreRightInLine[0].FP0.y = RightInLine[0].FP0.y;    PreRightInLine[0].FP1.y = RightInLine[0].FP1.y;       
									 }
									 else {                                                                                                    // 중간부분 Broken발생으로 데이터가 없는경우 
										 // PreLine 데이터를 넘겨줌 
										 RightInLine[0].FP0.x = PreRightInLine[0].FP0.x;  RightInLine[0].FP1.x = PreRightInLine[0].FP1.x;  
										 RightInLine[0].FP0.y = PreRightInLine[0].FP0.y;  RightInLine[0].FP1.y = PreRightInLine[0].FP1.y;  
									 }
								 }
								 // NOTCH CELL Btm 검사에서만 연마폭 측정함 
								 Right_Grind_Width =(float)(Math.GetLengthFrLineToPoint (RightOutLine[0].FP0,RightOutLine[0].FP1, RightInLine[0].FP0 ));
								 // RightInLine Search End
								 /////////////////////////////////////////////////////////////////////////////


								 // RightTrackLine Data OverLap Start
								 //////////////////////////////////////////////////////////////////////////////
								 if(AvgRightTrackLineDis!=0){
// 									 RightOutLine[0].FP0.y = RightOutLine[0].FP0.y + ImageHeight; //전체 이미지 기준 y좌표
// 									 RightOutLine[0].FP1.y = RightOutLine[0].FP1.y + ImageHeight; //전체 이미지 기준 y좌표
// 
// 									 MarkToTrackLineDis1 = Math.GetLengthFrLineToPoint(RightMarkSta, RightMarkEnd, RightOutLine[0].FP0);//Mark라인에서 OutLine까지 거리 
// 									 MarkToTrackLineDis2 = Math.GetLengthFrLineToPoint(RightMarkSta, RightMarkEnd, RightOutLine[0].FP1);//Mark라인에서 OutLine까지 거리 
// 
// 									 if(MarkToTrackLineDis1>AvgRightTrackLineDis) RightTrackLine[0].FP0.x = RightOutLine[0].FP0.x - (MarkToTrackLineDis1 - AvgRightTrackLineDis);
// 									 if(MarkToTrackLineDis2>AvgRightTrackLineDis) RightTrackLine[0].FP1.x = RightOutLine[0].FP1.x - (MarkToTrackLineDis2 - AvgRightTrackLineDis);
// 
// 									 // RightOutLine Data 원본 
// 									 RightOutLine[0].FP0.y = RightOutLine[0].FP0.y - ImageHeight; 
// 									 RightOutLine[0].FP1.y = RightOutLine[0].FP1.y - ImageHeight; 
// 
// 									 RightTrackLine[0].FP0.y = RightOutLine[0].FP0.y;
// 									 RightTrackLine[0].FP1.y = RightOutLine[0].FP1.y;
								 }
								 // RightTrackLine Data OverLap End 
								 //////////////////////////////////////////////////////////////////////////////
							 }
						 }
						 else {
							 if(IsMarkBtm){ //RightTrackLine Search 
								 if(FInspectMode==Insp_Track){
									 // Right TrackLine Search 
									 /////////////////////////////////////////////////////////////////////////////////////////////
									 //BinaryImg.SetSize(GImage->GetWidth(), GImage->GetHeight());
									 //EasyImage::Oper(EArithmeticLogicOperation_Copy,GImage,&BinaryImg);
									 EasyImage::Threshold(GImage,&BinaryImg, CirGrindMeaThresHold);
									 SingleLine->GImage = &BinaryImg;

									 // 영역설정 
									 if(fabs(RightOutLine[0].FP0.x - RightOutLine[0].FP1.x) > 3){
										 LSP.x = (RightOutLine[0].FP0.x + RightOutLine[0].FP1.x)/2;
										 LSP.y = 0.0f;
									 }
									 else {
										 LSP = Math.OnIntersect(RightOutLine[0].FP0, RightOutLine[0].FP1, LT, RT);
									 }

									 SingleLine->IRoi->SetOrgX  ((int)LSP.x-50 );
									 SingleLine->IRoi->SetOrgY  (0             );
									 SingleLine->IRoi->SetWidth (47            );
									 SingleLine->IRoi->SetHeight(ImgH          );

									 if(FShape==shRectC){
										 SingleLine->IRoi->SetOrgX  ((int)LSP.x-50);
										 SingleLine->IRoi->SetOrgY  (0            );
										 SingleLine->IRoi->SetWidth (47           );
										 SingleLine->IRoi->SetHeight(FEndLine-CSideCircleHeight);
										 SingleLine->SetIncrement(1 );
										 if(((LSP.x-50)<=0) || ImgH<=0) return false;
									 }
									 else {
										 SingleLine->IRoi->SetOrgX  ((int)LSP.x-50);
										 SingleLine->IRoi->SetOrgY  (0            );
										 SingleLine->IRoi->SetWidth (47           );
										 SingleLine->IRoi->SetHeight(ImgH         );
										 SingleLine->SetIncrement(50);
										 if(((LSP.x-50)<=0) || ImgH<=0) return false;
									 }

									 // 연마량 측정 OutLine
									 SingleLine->SetFindLineId(0);
									 SingleLine->SetOrientation(orEast);
									 SingleLine->SetEdgeType(1); // White To Black  
									 SingleLine->OnExecute();
									 RightTrackLine[0].FP0 = SingleLine->GetResultP0();
									 RightTrackLine[0].FP1 = SingleLine->GetResultP1();

									 SingleLine->SetEdgeType(2); // Line Search Org 

									 // RightTrackLine....make OutLine Data 
									 // 현재의 데이터를 넘겨준다 
									 // 검사중 기준라인을 찾지 못할경우 이전데이터 넘겨줘서 기준라인 생성함 
									 if(RightTrackLine[0].FP0.x!=0.0f && RightTrackLine[0].FP0.y!=0.0f && RightTrackLine[0].FP1.x!=0.0f && RightTrackLine[0].FP1.y!=0.0f){
										 PreRightTrackLine[0].FP0.x = RightTrackLine[0].FP0.x;    PreRightTrackLine[0].FP1.x = RightTrackLine[0].FP1.x;       
										 PreRightTrackLine[0].FP0.y = RightTrackLine[0].FP0.y;    PreRightTrackLine[0].FP1.y = RightTrackLine[0].FP1.y;       
									 } // 셀의 상단 시작부터 Broken 발생으로 데이터가 없는경우 
									 else if(RightTrackLine[0].FP0.x==0.0f || RightTrackLine[0].FP0.y==0.0f || RightTrackLine[0].FP1.x==0.0f || RightTrackLine[0].FP1.y==0.0f){
										 if(PreRightTrackLine[0].FP0.x==0.0f && PreRightTrackLine[0].FP0.y==0.0f && PreRightTrackLine[0].FP1.x==0.0f && PreRightTrackLine[0].FP1.y==0.0f){// 시작부분 Broken발생으로 데이터가 없는경우 
											 // Mark좌표를 기준으로 라인좌표값을 다시 설정함 
											 ROI_H = IRoi->GetHeight();
											 ROI_L = IRoi->GetOrgX()  ;
											 RightTrackLine[0].FP0.x = ROI_L;    RightTrackLine[0].FP0.y = 0.0f        ;
											 RightTrackLine[0].FP1.x = ROI_L;    RightTrackLine[0].FP1.y = (float)ROI_H;

											 //RightTrackLine 데이터를 PreRightTrackLine에 넘겨준다 
											 PreRightTrackLine[0].FP0.x = RightTrackLine[0].FP0.x;    PreRightTrackLine[0].FP1.x = RightTrackLine[0].FP1.x;       
											 PreRightTrackLine[0].FP0.y = RightTrackLine[0].FP0.y;    PreRightTrackLine[0].FP1.y = RightTrackLine[0].FP1.y;       
										 }
										 else { // 중간부분 Broken발생으로 데이터가 없는경우 
											 // PreRightTrackLine 데이터를 넘겨줌 
											 RightTrackLine[0].FP0.x = PreRightTrackLine[0].FP0.x;  RightTrackLine[0].FP1.x = PreRightTrackLine[0].FP1.x;  
											 RightTrackLine[0].FP0.y = PreRightTrackLine[0].FP0.y;  RightTrackLine[0].FP1.y = PreRightTrackLine[0].FP1.y;  
										 }
									 }
									 // NOTCH CELL Btm 검사에서만 연마폭 측정함 
									 Right_Grind_Mea =(float)(Math.GetLengthFrLineToPoint (RightOutLine[0].FP0,RightOutLine[0].FP1,RightTrackLine[0].FP0));
									 // RightInLine Search End 
									 /////////////////////////////////////////////////////////////////////////////


									 // 마크라인에서 부터 RightTrackLine 까지 거리 산출 
									 // RightTrackLine Data 존재할 경우 거리 측정함 
									 // RightTrackLine Data 생성 
									if(RightTrackLine[0].FP0.x!=0.0f && RightTrackLine[0].FP0.y!=0.0f && RightTrackLine[0].FP1.x!=0.0f && RightTrackLine[0].FP1.y!=0.0f){
									    if(RightOutLine[0].FP0.x!=0.0f && RightOutLine[0].FP0.y!=0.0f && RightOutLine[0].FP1.x!=0.0f && RightOutLine[0].FP1.y!=0.0f){
											RightToTrackLineDis1 = Math.GetLengthFrLineToPoint(RightOutLine[0].FP0, RightOutLine[0].FP1, RightTrackLine[0].FP0);//외곽라인에서 TrackLine거리 
											RightToTrackLineDis2 = Math.GetLengthFrLineToPoint(RightOutLine[0].FP0, RightOutLine[0].FP1, RightTrackLine[0].FP1);//외곽라인에서 TrackLine거리 

											TotalRightTrackDis  +=  (int)((RightToTrackLineDis1 + RightToTrackLineDis2)/2.0); //Mark라인에서 TrackLine거리 누적                   
											RightTrackLineCount++; //누적 카운트 증가
										}
									}
								 }
							 }
							 else {//EnCap(Top영역) RightTrackLine Data Overlap 
								 // RightTrackLine Data OverLap Start
								 //////////////////////////////////////////////////////////////////////////////
								 if(AvgRightTrackLineDis!=0){
									 if(FInspectMode==Insp_Track){ //외곽기준 데이터 오버랩 한다 
										 if(RightOutLine[0].FP0.x!=0.0f && RightOutLine[0].FP0.y!=0.0f && RightOutLine[0].FP1.x!=0.0f && RightOutLine[0].FP1.y!=0.0f){
											 // TOP영역 LeftTrackLine x좌표 
											 RightTrackLine[0].FP0.x = RightOutLine[0].FP0.x - AvgRightTrackLineDis;
											 RightTrackLine[0].FP1.x = RightOutLine[0].FP1.x - AvgRightTrackLineDis;

											 // TOP영역 LeftTrackLine y좌표 
											 RightTrackLine[0].FP0.y = RightOutLine[0].FP0.y;
											 RightTrackLine[0].FP1.y = RightOutLine[0].FP1.y;
										 }
									 }
								 }
							 }
						 }
					 }
					 else if(FCompanyMode==COM_BMDT){ // 기본 Right Line Search 
						 EasyImage::Threshold(GImage,&BinaryImg, RightEdgeThresHold);
						 if(RightEdgeThresHold==0) {SingleLine->GImage = GImage;     SingleLine->FThreshold =5 ;}
						 else                      {SingleLine->GImage = &BinaryImg; SingleLine->FThreshold =10;}

						 if(FInspectMode==Insp_Surface){ // 표면검사 시퀀스 //
							 if(FShape==shRectC){
								 SingleLine->IRoi->SetOrgX  (IRoi->GetOrgX()          );
								 SingleLine->IRoi->SetOrgY  (IRoi->GetOrgY()          );
								 SingleLine->IRoi->SetWidth (IRoi->GetWidth()         );
								 SingleLine->IRoi->SetHeight(FEndLine-CSideCircleHeight);
								 SingleLine->SetIncrement(1 );
							 }
							 else if(FShape==shRectH){
								 if(IsCircleTop){
									 SingleLine->IRoi->SetOrgX  (IRoi->GetOrgX()  );
									 SingleLine->IRoi->SetOrgY  (ASideCircleHeight+50);
									 SingleLine->IRoi->SetWidth (IRoi->GetWidth() );
									 SingleLine->IRoi->SetHeight(ImgH-(ASideCircleHeight+50));
									 SingleLine->SetIncrement(1 );
								 }
								 else {
									 SingleLine->IRoi->SetOrgX  (IRoi->GetOrgX()  );
									 SingleLine->IRoi->SetOrgY  (IRoi->GetOrgY()  );
									 SingleLine->IRoi->SetWidth (IRoi->GetWidth() );
									 SingleLine->IRoi->SetHeight(IRoi->GetHeight());
									 SingleLine->SetIncrement(10 );
								 }
							 }
							 else {
								 SingleLine->IRoi->SetOrgX  (IRoi->GetOrgX());
								 SingleLine->IRoi->SetOrgY  (IRoi->GetOrgY());
								 SingleLine->IRoi->SetWidth (IRoi->GetWidth());
								 SingleLine->IRoi->SetHeight(IRoi->GetHeight());
								 ROI_H = IRoi->GetHeight();
								 if(ROI_H<700)  SingleLine->SetIncrement(50 );
								 else 	        SingleLine->SetIncrement(100);
							 }

							 SingleLine->SetOrientation(orEast);

							 SingleLine->SetFindLineId(0);
							 SingleLine->FThreshold =10;

							 if(IsMarkBtm) SingleLine->SetEdgeType(1); // White To Black  
							 else          SingleLine->SetEdgeType(1); // White To Black  

							 SingleLine->OnExecute();
							 Line[2].FP0 = SingleLine->GetResultP0();
							 Line[2].FP1 = SingleLine->GetResultP1();

							 // Btm,Top 상관없이 첫번째
							 RightOutLine[0].FP0.x = Line[2].FP0.x;
							 RightOutLine[0].FP0.y = Line[2].FP0.y;
							 RightOutLine[0].FP1.x = Line[2].FP1.x;
							 RightOutLine[0].FP1.y = Line[2].FP1.y;

							 // RightOutLine....make OutLine Data 
							 // 현재의 데이터를 넘겨준다 
							 // 검사중 기준라인을 찾지 못할경우 이전데이터 넘겨줘서 기준라인 생성함 
							 if(RightOutLine[0].FP0.x!=0.0f && RightOutLine[0].FP0.y!=0.0f && RightOutLine[0].FP1.x!=0.0f && RightOutLine[0].FP1.y!=0.0f){
								 PreRightOutLine[0].FP0.x = RightOutLine[0].FP0.x;    PreRightOutLine[0].FP1.x = RightOutLine[0].FP1.x;       
								 PreRightOutLine[0].FP0.y = RightOutLine[0].FP0.y;    PreRightOutLine[0].FP1.y = RightOutLine[0].FP1.y;       
							 } // 셀의 상단 시작부터 Broken 발생으로 데이터가 없는경우 
							 else if(RightOutLine[0].FP0.x==0.0f || RightOutLine[0].FP0.y==0.0f || RightOutLine[0].FP1.x==0.0f || RightOutLine[0].FP1.y==0.0f){
								 if(PreRightOutLine[0].FP0.x==0.0f && PreRightOutLine[0].FP0.y==0.0f && PreRightOutLine[0].FP1.x==0.0f && PreRightOutLine[0].FP1.y==0.0f){// 시작부분 Broken발생으로 데이터가 없는경우 
									 // Mark좌표를 기준으로 라인좌표값을 다시 설정함 
									 ROI_H = IRoi->GetHeight();
									 RightOutLine[0].FP0.x = Line[2].FP0.x;    RightOutLine[0].FP0.y = 0.0f        ;
									 RightOutLine[0].FP1.x = Line[2].FP1.x;    RightOutLine[0].FP1.y = (float)ROI_H;

									 //Line 데이터를 PreLine에 넘겨준다 
									 PreRightOutLine[0].FP0.x = RightOutLine[0].FP0.x;    PreRightOutLine[0].FP1.x = RightOutLine[0].FP1.x;       
									 PreRightOutLine[0].FP0.y = RightOutLine[0].FP0.y;    PreRightOutLine[0].FP1.y = RightOutLine[0].FP1.y;       
								 }
								 else { // 중간부분 Broken발생으로 데이터가 없는경우 
									 // PreLine 데이터를 넘겨줌 
									 RightOutLine[0].FP0.x = PreRightOutLine[0].FP0.x;  RightOutLine[0].FP1.x = PreRightOutLine[0].FP1.x;  
									 RightOutLine[0].FP0.y = PreRightOutLine[0].FP0.y;  RightOutLine[0].FP1.y = PreRightOutLine[0].FP1.y;  
								 }
							 }
						 }
						 else             { // 외관검사 시퀀스 // 기본 Right Line Search 
							 if(FShape==shRectC){
								 SingleLine->IRoi->SetOrgX  (IRoi->GetOrgX()          );
								 SingleLine->IRoi->SetOrgY  (IRoi->GetOrgY()          );
								 SingleLine->IRoi->SetWidth (IRoi->GetWidth()         );
								 SingleLine->IRoi->SetHeight(FEndLine-CSideCircleHeight);
								 SingleLine->SetIncrement(1 );
							 }
							 else if(FShape==shRectH){
								 if(IsCircleTop){
									 SingleLine->IRoi->SetOrgX  (IRoi->GetOrgX()  );
									 SingleLine->IRoi->SetOrgY  (ASideCircleHeight+50);
									 SingleLine->IRoi->SetWidth (IRoi->GetWidth() );
									 SingleLine->IRoi->SetHeight(ImgH-(ASideCircleHeight+50));
									 SingleLine->SetIncrement(1 );
								 }
								 else {
									 SingleLine->IRoi->SetOrgX  (IRoi->GetOrgX()  );
									 SingleLine->IRoi->SetOrgY  (IRoi->GetOrgY()  );
									 SingleLine->IRoi->SetWidth (IRoi->GetWidth() );
									 SingleLine->IRoi->SetHeight(IRoi->GetHeight());
									 SingleLine->SetIncrement(50 );
								 }
							 }
							 else {
								 SingleLine->IRoi->SetOrgX  (IRoi->GetOrgX());
								 SingleLine->IRoi->SetOrgY  (IRoi->GetOrgY());
								 SingleLine->IRoi->SetWidth (IRoi->GetWidth());
								 SingleLine->IRoi->SetHeight(IRoi->GetHeight());
								 ROI_H = IRoi->GetHeight();
								 if(ROI_H<700)  SingleLine->SetIncrement(50 );
								 else 	        SingleLine->SetIncrement(100);
							 }

							 SingleLine->SetOrientation(orEast);

							 SingleLine->SetFindLineId(0);
							 SingleLine->FThreshold =10;

							 if(IsMarkBtm) SingleLine->SetEdgeType(0); // Black to White 
							 else          SingleLine->SetEdgeType(0); // Black to White   

							 SingleLine->OnExecute();
							 Line[2].FP0 = SingleLine->GetResultP0();
							 Line[2].FP1 = SingleLine->GetResultP1();

							 // Btm,Top 상관없이 첫번째
							 RightOutLine[0].FP0.x = Line[2].FP0.x;
							 RightOutLine[0].FP0.y = Line[2].FP0.y;
							 RightOutLine[0].FP1.x = Line[2].FP1.x;
							 RightOutLine[0].FP1.y = Line[2].FP1.y;

							 // RightOutLine....make OutLine Data 
							 // 현재의 데이터를 넘겨준다 
							 // 검사중 기준라인을 찾지 못할경우 이전데이터 넘겨줘서 기준라인 생성함 
							 if(RightOutLine[0].FP0.x!=0.0f && RightOutLine[0].FP0.y!=0.0f && RightOutLine[0].FP1.x!=0.0f && RightOutLine[0].FP1.y!=0.0f){
								 PreRightOutLine[0].FP0.x = RightOutLine[0].FP0.x;    PreRightOutLine[0].FP1.x = RightOutLine[0].FP1.x;       
								 PreRightOutLine[0].FP0.y = RightOutLine[0].FP0.y;    PreRightOutLine[0].FP1.y = RightOutLine[0].FP1.y;       
							 } // 셀의 상단 시작부터 Broken 발생으로 데이터가 없는경우 
							 else if(RightOutLine[0].FP0.x==0.0f || RightOutLine[0].FP0.y==0.0f || RightOutLine[0].FP1.x==0.0f || RightOutLine[0].FP1.y==0.0f){
								 if(PreRightOutLine[0].FP0.x==0.0f && PreRightOutLine[0].FP0.y==0.0f && PreRightOutLine[0].FP1.x==0.0f && PreRightOutLine[0].FP1.y==0.0f){// 시작부분 Broken발생으로 데이터가 없는경우 
									 // Mark좌표를 기준으로 라인좌표값을 다시 설정함 
									 ROI_H = IRoi->GetHeight();
									 RightOutLine[0].FP0.x = Line[2].FP0.x;    RightOutLine[0].FP0.y = 0.0f        ;
									 RightOutLine[0].FP1.x = Line[2].FP1.x;    RightOutLine[0].FP1.y = (float)ROI_H;

									 //Line 데이터를 PreLine에 넘겨준다 
									 PreRightOutLine[0].FP0.x = RightOutLine[0].FP0.x;    PreRightOutLine[0].FP1.x = RightOutLine[0].FP1.x;       
									 PreRightOutLine[0].FP0.y = RightOutLine[0].FP0.y;    PreRightOutLine[0].FP1.y = RightOutLine[0].FP1.y;       
								 }
								 else { // 중간부분 Broken발생으로 데이터가 없는경우 
									 // PreLine 데이터를 넘겨줌 
									 RightOutLine[0].FP0.x = PreRightOutLine[0].FP0.x;  RightOutLine[0].FP1.x = PreRightOutLine[0].FP1.x;  
									 RightOutLine[0].FP0.y = PreRightOutLine[0].FP0.y;  RightOutLine[0].FP1.y = PreRightOutLine[0].FP1.y;  
								 }
							 }

							 if(IsAllGrind){
								 if(IsMarkBtm){ // RightInLine, RightTrackLine Search 
									 // RightInLine Search Start 
									 /////////////////////////////////////////////////////////////////////////////
									 EasyImage::Threshold(GImage,&BinaryImg, RightEdgeThresHold);
									 SingleLine->GImage = &BinaryImg;

									 // 영역설정 
									 if(fabs(RightOutLine[0].FP0.x - RightOutLine[0].FP1.x) > 3){
										 LSP.x = (RightOutLine[0].FP0.x + RightOutLine[0].FP1.x)/2;
										 LSP.y = 0.0f;
									 }
									 else {
										 LSP = Math.OnIntersect(RightOutLine[0].FP0, RightOutLine[0].FP1, LT, RT);
									 }

									 SingleLine->IRoi->SetOrgX  ((int)LSP.x-100);
									 SingleLine->IRoi->SetOrgY  (0             );
									 SingleLine->IRoi->SetWidth (97            );
									 SingleLine->IRoi->SetHeight(ImgH          );

									 if(((LSP.x+3)<=0) || ImgH<=0) return false;

									 if(IRoi->GetHeight()<300) SingleLine->SetIncrement(5 );
									 else                      SingleLine->SetIncrement(100);

									 // 연마량 측정 OutLine
									 SingleLine->SetFindLineId(0);
									 SingleLine->SetOrientation(orEast);
									 SingleLine->SetEdgeType(0); // Black to White 
									 SingleLine->OnExecute();
									 RightInLine[0].FP0 = SingleLine->GetResultP0();
									 RightInLine[0].FP1 = SingleLine->GetResultP1();

									 SingleLine->SetEdgeType(2); // Line Search Org 

									 // RightInLine None....make InLine Data 
									 // 현재의 데이터를 넘겨준다 
									 if(RightInLine[0].FP0.x!=0.0f && RightInLine[0].FP0.y!=0.0f && RightInLine[0].FP1.x!=0.0f && RightInLine[0].FP1.y!=0.0f){
										 PreRightInLine[0].FP0.x = RightInLine[0].FP0.x;    PreRightInLine[0].FP1.x = RightInLine[0].FP1.x;       
										 PreRightInLine[0].FP0.y = RightInLine[0].FP0.y;    PreRightInLine[0].FP1.y = RightInLine[0].FP1.y;       
									 }
									 else if(RightInLine[0].FP0.x==0.0f || RightInLine[0].FP0.y==0.0f || RightInLine[0].FP1.x==0.0f || RightInLine[0].FP1.y==0.0f){
										 if(PreRightInLine[0].FP0.x==0.0f && PreRightInLine[0].FP0.y==0.0f && PreRightInLine[0].FP1.x==0.0f && PreRightInLine[0].FP1.y==0.0f){// 시작부분 Broken발생으로 데이터가 없는경우 
											 // Mark좌표를 기준으로 라인좌표값을 다시 설정함 
											 ROI_H = IRoi->GetHeight();
											 ROI_L = IRoi->GetOrgX()  ;
											 RightInLine[0].FP0.x = ROI_L;   RightInLine[0].FP0.y = 0.0f        ;
											 RightInLine[0].FP1.x = ROI_L;   RightInLine[0].FP1.y = (float)ROI_H;

											 //Line 데이터를 PreLine에 넘겨준다 
											 PreRightInLine[0].FP0.x = RightInLine[0].FP0.x;    PreRightInLine[0].FP1.x = RightInLine[0].FP1.x;       
											 PreRightInLine[0].FP0.y = RightInLine[0].FP0.y;    PreRightInLine[0].FP1.y = RightInLine[0].FP1.y;       
										 }
										 else {                                                                                                    // 중간부분 Broken발생으로 데이터가 없는경우 
											 // PreLine 데이터를 넘겨줌 
											 RightInLine[0].FP0.x = PreRightInLine[0].FP0.x;  RightInLine[0].FP1.x = PreRightInLine[0].FP1.x;  
											 RightInLine[0].FP0.y = PreRightInLine[0].FP0.y;  RightInLine[0].FP1.y = PreRightInLine[0].FP1.y;  
										 }
									 }
									 // NOTCH CELL Btm 검사에서만 연마폭 측정함 
									 Right_Grind_Width =(float)(Math.GetLengthFrLineToPoint (RightOutLine[0].FP0,RightOutLine[0].FP1, RightInLine[0].FP0 ));
									 // RightInLine Search End
									 /////////////////////////////////////////////////////////////////////////////


									 // Right TrackLine Search 
									 /////////////////////////////////////////////////////////////////////////////////////////////
									 // 									 BinaryImg.SetSize(GImage->GetWidth(), GImage->GetHeight());
									 // 									 EasyImage::Oper(EArithmeticLogicOperation_Copy,GImage,&BinaryImg);
									 EasyImage::Threshold(GImage,&BinaryImg, CirGrindMeaThresHold);
									 SingleLine->GImage = &BinaryImg;

									 // 영역설정 
									 if(fabs(RightInLine[0].FP0.x - RightInLine[0].FP1.x) > 3){
										 LSP.x = (RightInLine[0].FP0.x + RightInLine[0].FP1.x)/2;
										 LSP.y = 0.0f;
									 }
									 else {
										 LSP = Math.OnIntersect(RightInLine[0].FP0, RightInLine[0].FP1, LT, RT);
									 }

									 SingleLine->IRoi->SetOrgX  ((int)LSP.x-100);
									 SingleLine->IRoi->SetOrgY  (0             );
									 SingleLine->IRoi->SetWidth (97            );
									 SingleLine->IRoi->SetHeight(ImgH          );

									 if(((LSP.x+3)<=0) || ImgH<=0) return false;

									 if(IRoi->GetHeight()<300) SingleLine->SetIncrement(5 );
									 else                      SingleLine->SetIncrement(100);

									 // 연마량 측정 OutLine
									 SingleLine->SetFindLineId(0);
									 SingleLine->SetOrientation(orEast);
									 SingleLine->SetEdgeType(1); // White To Black  
									 SingleLine->OnExecute();
									 RightTrackLine[0].FP0 = SingleLine->GetResultP0();
									 RightTrackLine[0].FP1 = SingleLine->GetResultP1();

									 SingleLine->SetEdgeType(2); // Line Search Org 

									 // RightTrackLine....make OutLine Data 
									 // 현재의 데이터를 넘겨준다 
									 // 검사중 기준라인을 찾지 못할경우 이전데이터 넘겨줘서 기준라인 생성함 
									 if(RightTrackLine[0].FP0.x!=0.0f && RightTrackLine[0].FP0.y!=0.0f && RightTrackLine[0].FP1.x!=0.0f && RightTrackLine[0].FP1.y!=0.0f){
										 PreRightTrackLine[0].FP0.x = RightTrackLine[0].FP0.x;    PreRightTrackLine[0].FP1.x = RightTrackLine[0].FP1.x;       
										 PreRightTrackLine[0].FP0.y = RightTrackLine[0].FP0.y;    PreRightTrackLine[0].FP1.y = RightTrackLine[0].FP1.y;       
									 } // 셀의 상단 시작부터 Broken 발생으로 데이터가 없는경우 
									 else if(RightTrackLine[0].FP0.x==0.0f || RightTrackLine[0].FP0.y==0.0f || RightTrackLine[0].FP1.x==0.0f || RightTrackLine[0].FP1.y==0.0f){
										 if(PreRightTrackLine[0].FP0.x==0.0f && PreRightTrackLine[0].FP0.y==0.0f && PreRightTrackLine[0].FP1.x==0.0f && PreRightTrackLine[0].FP1.y==0.0f){// 시작부분 Broken발생으로 데이터가 없는경우 
											 // Mark좌표를 기준으로 라인좌표값을 다시 설정함 
											 ROI_H = IRoi->GetHeight();
											 ROI_L = IRoi->GetOrgX()  ;
											 RightTrackLine[0].FP0.x = ROI_L;    RightTrackLine[0].FP0.y = 0.0f        ;
											 RightTrackLine[0].FP1.x = ROI_L;    RightTrackLine[0].FP1.y = (float)ROI_H;

											 //RightTrackLine 데이터를 PreRightTrackLine에 넘겨준다 
											 PreRightTrackLine[0].FP0.x = RightTrackLine[0].FP0.x;    PreRightTrackLine[0].FP1.x = RightTrackLine[0].FP1.x;       
											 PreRightTrackLine[0].FP0.y = RightTrackLine[0].FP0.y;    PreRightTrackLine[0].FP1.y = RightTrackLine[0].FP1.y;       
										 }
										 else { // 중간부분 Broken발생으로 데이터가 없는경우 
											 // PreRightTrackLine 데이터를 넘겨줌 
											 RightTrackLine[0].FP0.x = PreRightTrackLine[0].FP0.x;  RightTrackLine[0].FP1.x = PreRightTrackLine[0].FP1.x;  
											 RightTrackLine[0].FP0.y = PreRightTrackLine[0].FP0.y;  RightTrackLine[0].FP1.y = PreRightTrackLine[0].FP1.y;  
										 }
									 }
									 // NOTCH CELL Btm 검사에서만 연마폭 측정함 
									 Right_Grind_Mea =(float)(Math.GetLengthFrLineToPoint (RightOutLine[0].FP0,RightOutLine[0].FP1,RightTrackLine[0].FP0));
									 // RightInLine Search End 
									 /////////////////////////////////////////////////////////////////////////////


									 // 마크라인에서 부터 RightTrackLine 까지 거리 산출 
									 // RightTrackLine Data 존재할 경우 거리 측정함 
									 // RightTrackLine Data 생성 
									 //////////////////////////////////////////////////////////////////////////////
									 if(RightTrackLine[0].FP0.x!=0.0f && RightTrackLine[0].FP0.y!=0.0f && RightTrackLine[0].FP1.x!=0.0f && RightTrackLine[0].FP1.y!=0.0f){
										 // 									 RightTrackLine[0].FP0.y = RightTrackLine[0].FP0.y + ImageHeight; //전체 이미지 기준 y좌표
										 // 									 RightTrackLine[0].FP1.y = RightTrackLine[0].FP1.y + ImageHeight; //전체 이미지 기준 y좌표
										 // 
										 // 									 MarkToTrackLineDis1 = Math.GetLengthFrLineToPoint(RightMarkSta, RightMarkEnd, RightTrackLine[0].FP0);//Mark라인에서 TrackLine거리 
										 // 									 MarkToTrackLineDis2 = Math.GetLengthFrLineToPoint(RightMarkSta, RightMarkEnd, RightTrackLine[0].FP1);//Mark라인에서 TrackLine거리 
										 // 
										 // 									 TotalRightTrackDis  +=  (int)((MarkToTrackLineDis1 + MarkToTrackLineDis2)/2.0); //Mark라인에서 TrackLine거리 누적                   
										 // 									 RightTrackLineCount++; //누적 카운트 증가
										 // 
										 // 									 // Org Data 
										 // 									 RightTrackLine[0].FP0.y = RightTrackLine[0].FP0.y - ImageHeight; //Frame 이미지 기준 y좌표 원복
										 // 									 RightTrackLine[0].FP1.y = RightTrackLine[0].FP1.y - ImageHeight; //Frame 이미지 기준 y좌표 원복 
									 }
									 // RightTrackLine Data 생성 종료 
									 ////////////////////////////////////////////////////////////////////////////////
								 }
								 else {//EnCap(Top영역) RightInLine Search , RightTrackLine Data Overlap 
									 // RightInLine Search Start 
									 /////////////////////////////////////////////////////////////////////////////
									 EasyImage::Threshold(GImage,&BinaryImg, RightEdgeThresHold);
									 SingleLine->GImage = &BinaryImg;

									 // 영역설정 
									 if(fabs(RightOutLine[0].FP0.x - RightOutLine[0].FP1.x) > 3){
										 LSP.x = (RightOutLine[0].FP0.x + RightOutLine[0].FP1.x)/2;
										 LSP.y = 0.0f;
									 }
									 else {
										 LSP = Math.OnIntersect(RightOutLine[0].FP0, RightOutLine[0].FP1, LT, RT);
									 }

									 SingleLine->IRoi->SetOrgX  ((int)LSP.x-100);
									 SingleLine->IRoi->SetOrgY  (0             );
									 SingleLine->IRoi->SetWidth (97            );
									 SingleLine->IRoi->SetHeight(ImgH          );

									 if(((LSP.x+3)<=0) || ImgH<=0) return false;

									 if(IRoi->GetHeight()<300) SingleLine->SetIncrement(5 );
									 else                      SingleLine->SetIncrement(100);

									 // 연마량 측정 OutLine
									 SingleLine->SetFindLineId(0);
									 SingleLine->SetOrientation(orEast);
									 SingleLine->SetEdgeType(0); // Black to White 
									 SingleLine->OnExecute();
									 RightInLine[0].FP0 = SingleLine->GetResultP0();
									 RightInLine[0].FP1 = SingleLine->GetResultP1();

									 SingleLine->SetEdgeType(2); // Line Search Org 

									 // RightInLine None....make InLine Data 
									 // 현재의 데이터를 넘겨준다 
									 if(RightInLine[0].FP0.x!=0.0f && RightInLine[0].FP0.y!=0.0f && RightInLine[0].FP1.x!=0.0f && RightInLine[0].FP1.y!=0.0f){
										 PreRightInLine[0].FP0.x = RightInLine[0].FP0.x;    PreRightInLine[0].FP1.x = RightInLine[0].FP1.x;       
										 PreRightInLine[0].FP0.y = RightInLine[0].FP0.y;    PreRightInLine[0].FP1.y = RightInLine[0].FP1.y;       
									 }
									 else if(RightInLine[0].FP0.x==0.0f || RightInLine[0].FP0.y==0.0f || RightInLine[0].FP1.x==0.0f || RightInLine[0].FP1.y==0.0f){
										 if(PreRightInLine[0].FP0.x==0.0f && PreRightInLine[0].FP0.y==0.0f && PreRightInLine[0].FP1.x==0.0f && PreRightInLine[0].FP1.y==0.0f){// 시작부분 Broken발생으로 데이터가 없는경우 
											 // Mark좌표를 기준으로 라인좌표값을 다시 설정함 
											 ROI_H = IRoi->GetHeight();
											 ROI_L = IRoi->GetOrgX()  ;
											 RightInLine[0].FP0.x = ROI_L;   RightInLine[0].FP0.y = 0.0f        ;
											 RightInLine[0].FP1.x = ROI_L;   RightInLine[0].FP1.y = (float)ROI_H;

											 //Line 데이터를 PreLine에 넘겨준다 
											 PreRightInLine[0].FP0.x = RightInLine[0].FP0.x;    PreRightInLine[0].FP1.x = RightInLine[0].FP1.x;       
											 PreRightInLine[0].FP0.y = RightInLine[0].FP0.y;    PreRightInLine[0].FP1.y = RightInLine[0].FP1.y;       
										 }
										 else {                                                                                                    // 중간부분 Broken발생으로 데이터가 없는경우 
											 // PreLine 데이터를 넘겨줌 
											 RightInLine[0].FP0.x = PreRightInLine[0].FP0.x;  RightInLine[0].FP1.x = PreRightInLine[0].FP1.x;  
											 RightInLine[0].FP0.y = PreRightInLine[0].FP0.y;  RightInLine[0].FP1.y = PreRightInLine[0].FP1.y;  
										 }
									 }
									 // NOTCH CELL Btm 검사에서만 연마폭 측정함 
									 Right_Grind_Width =(float)(Math.GetLengthFrLineToPoint (RightOutLine[0].FP0,RightOutLine[0].FP1, RightInLine[0].FP0 ));
									 // RightInLine Search End
									 /////////////////////////////////////////////////////////////////////////////


									 // RightTrackLine Data OverLap Start
									 //////////////////////////////////////////////////////////////////////////////
									 if(AvgRightTrackLineDis!=0){
										 // 									 RightOutLine[0].FP0.y = RightOutLine[0].FP0.y + ImageHeight; //전체 이미지 기준 y좌표
										 // 									 RightOutLine[0].FP1.y = RightOutLine[0].FP1.y + ImageHeight; //전체 이미지 기준 y좌표
										 // 
										 // 									 MarkToTrackLineDis1 = Math.GetLengthFrLineToPoint(RightMarkSta, RightMarkEnd, RightOutLine[0].FP0);//Mark라인에서 OutLine까지 거리 
										 // 									 MarkToTrackLineDis2 = Math.GetLengthFrLineToPoint(RightMarkSta, RightMarkEnd, RightOutLine[0].FP1);//Mark라인에서 OutLine까지 거리 
										 // 
										 // 									 if(MarkToTrackLineDis1>AvgRightTrackLineDis) RightTrackLine[0].FP0.x = RightOutLine[0].FP0.x - (MarkToTrackLineDis1 - AvgRightTrackLineDis);
										 // 									 if(MarkToTrackLineDis2>AvgRightTrackLineDis) RightTrackLine[0].FP1.x = RightOutLine[0].FP1.x - (MarkToTrackLineDis2 - AvgRightTrackLineDis);
										 // 
										 // 									 // RightOutLine Data 원본 
										 // 									 RightOutLine[0].FP0.y = RightOutLine[0].FP0.y - ImageHeight; 
										 // 									 RightOutLine[0].FP1.y = RightOutLine[0].FP1.y - ImageHeight; 
										 // 
										 // 									 RightTrackLine[0].FP0.y = RightOutLine[0].FP0.y;
										 // 									 RightTrackLine[0].FP1.y = RightOutLine[0].FP1.y;
									 }
									 // RightTrackLine Data OverLap End 
									 //////////////////////////////////////////////////////////////////////////////
								 }
							 }
							 else {
								 if(IsMarkBtm){ //RightTrackLine Search 
									 if(FInspectMode==Insp_Track){
										 // Right TrackLine Search 
										 /////////////////////////////////////////////////////////////////////////////////////////////
										 //BinaryImg.SetSize(GImage->GetWidth(), GImage->GetHeight());
										 //EasyImage::Oper(EArithmeticLogicOperation_Copy,GImage,&BinaryImg);
										 EasyImage::Threshold(GImage,&BinaryImg, CirGrindMeaThresHold);
										 SingleLine->GImage = &BinaryImg;

										 // 영역설정 
										 if(fabs(RightOutLine[0].FP0.x - RightOutLine[0].FP1.x) > 3){
											 LSP.x = (RightOutLine[0].FP0.x + RightOutLine[0].FP1.x)/2;
											 LSP.y = 0.0f;
										 }
										 else {
											 LSP = Math.OnIntersect(RightOutLine[0].FP0, RightOutLine[0].FP1, LT, RT);
										 }

										 SingleLine->IRoi->SetOrgX  ((int)LSP.x-50 );
										 SingleLine->IRoi->SetOrgY  (0             );
										 SingleLine->IRoi->SetWidth (47            );
										 SingleLine->IRoi->SetHeight(ImgH          );

										 if(FShape==shRectC){
											 SingleLine->IRoi->SetOrgX  ((int)LSP.x-50);
											 SingleLine->IRoi->SetOrgY  (0            );
											 SingleLine->IRoi->SetWidth (47           );
											 SingleLine->IRoi->SetHeight(FEndLine-CSideCircleHeight);
											 SingleLine->SetIncrement(1 );
											 if(((LSP.x-50)<=0) || ImgH<=0) return false;
										 }
										 else {
											 SingleLine->IRoi->SetOrgX  ((int)LSP.x-50);
											 SingleLine->IRoi->SetOrgY  (0            );
											 // 											 SingleLine->IRoi->SetWidth (47           );
											 SingleLine->IRoi->SetWidth (70           );
											 SingleLine->IRoi->SetHeight(ImgH         );
											 SingleLine->SetIncrement(50);
											 if(((LSP.x-50)<=0) || ImgH<=0) return false;
										 }

										 // 연마량 측정 OutLine
										 SingleLine->SetFindLineId(0);
										 SingleLine->SetOrientation(orEast);
										 // 										 SingleLine->SetEdgeType(1); // White To Black  
										 SingleLine->SetEdgeType(0); // Black To White
										 SingleLine->OnExecute();
										 RightTrackLine[0].FP0 = SingleLine->GetResultP0();
										 RightTrackLine[0].FP1 = SingleLine->GetResultP1();

										 SingleLine->SetEdgeType(2); // Line Search Org 

										 // RightTrackLine....make OutLine Data 
										 // 현재의 데이터를 넘겨준다 
										 // 검사중 기준라인을 찾지 못할경우 이전데이터 넘겨줘서 기준라인 생성함 
										 if(RightTrackLine[0].FP0.x!=0.0f && RightTrackLine[0].FP0.y!=0.0f && RightTrackLine[0].FP1.x!=0.0f && RightTrackLine[0].FP1.y!=0.0f){
											 PreRightTrackLine[0].FP0.x = RightTrackLine[0].FP0.x;    PreRightTrackLine[0].FP1.x = RightTrackLine[0].FP1.x;       
											 PreRightTrackLine[0].FP0.y = RightTrackLine[0].FP0.y;    PreRightTrackLine[0].FP1.y = RightTrackLine[0].FP1.y;       
										 } // 셀의 상단 시작부터 Broken 발생으로 데이터가 없는경우 
										 else if(RightTrackLine[0].FP0.x==0.0f || RightTrackLine[0].FP0.y==0.0f || RightTrackLine[0].FP1.x==0.0f || RightTrackLine[0].FP1.y==0.0f){
											 if(PreRightTrackLine[0].FP0.x==0.0f && PreRightTrackLine[0].FP0.y==0.0f && PreRightTrackLine[0].FP1.x==0.0f && PreRightTrackLine[0].FP1.y==0.0f){// 시작부분 Broken발생으로 데이터가 없는경우 
												 // Mark좌표를 기준으로 라인좌표값을 다시 설정함 
												 ROI_H = IRoi->GetHeight();
												 ROI_L = IRoi->GetOrgX()  ;
												 RightTrackLine[0].FP0.x = ROI_L;    RightTrackLine[0].FP0.y = 0.0f        ;
												 RightTrackLine[0].FP1.x = ROI_L;    RightTrackLine[0].FP1.y = (float)ROI_H;

												 //RightTrackLine 데이터를 PreRightTrackLine에 넘겨준다 
												 PreRightTrackLine[0].FP0.x = RightTrackLine[0].FP0.x;    PreRightTrackLine[0].FP1.x = RightTrackLine[0].FP1.x;       
												 PreRightTrackLine[0].FP0.y = RightTrackLine[0].FP0.y;    PreRightTrackLine[0].FP1.y = RightTrackLine[0].FP1.y;       
											 }
											 else { // 중간부분 Broken발생으로 데이터가 없는경우 
												 // PreRightTrackLine 데이터를 넘겨줌 
												 RightTrackLine[0].FP0.x = PreRightTrackLine[0].FP0.x;  RightTrackLine[0].FP1.x = PreRightTrackLine[0].FP1.x;  
												 RightTrackLine[0].FP0.y = PreRightTrackLine[0].FP0.y;  RightTrackLine[0].FP1.y = PreRightTrackLine[0].FP1.y;  
											 }
										 }
										 // NOTCH CELL Btm 검사에서만 연마폭 측정함 
										 Right_Grind_Mea =(float)(Math.GetLengthFrLineToPoint (RightOutLine[0].FP0,RightOutLine[0].FP1,RightTrackLine[0].FP0));
										 // RightInLine Search End 
										 /////////////////////////////////////////////////////////////////////////////


										 // 마크라인에서 부터 RightTrackLine 까지 거리 산출 
										 // RightTrackLine Data 존재할 경우 거리 측정함 
										 // RightTrackLine Data 생성 
										 if(RightTrackLine[0].FP0.x!=0.0f && RightTrackLine[0].FP0.y!=0.0f && RightTrackLine[0].FP1.x!=0.0f && RightTrackLine[0].FP1.y!=0.0f){
											 if(RightOutLine[0].FP0.x!=0.0f && RightOutLine[0].FP0.y!=0.0f && RightOutLine[0].FP1.x!=0.0f && RightOutLine[0].FP1.y!=0.0f){
												 RightToTrackLineDis1 = Math.GetLengthFrLineToPoint(RightOutLine[0].FP0, RightOutLine[0].FP1, RightTrackLine[0].FP0);//외곽라인에서 TrackLine거리 
												 RightToTrackLineDis2 = Math.GetLengthFrLineToPoint(RightOutLine[0].FP0, RightOutLine[0].FP1, RightTrackLine[0].FP1);//외곽라인에서 TrackLine거리 

												 TotalRightTrackDis  +=  (int)((RightToTrackLineDis1 + RightToTrackLineDis2)/2.0); //Mark라인에서 TrackLine거리 누적                   
												 RightTrackLineCount++; //누적 카운트 증가
											 }
										 }
									 }
								 }
								 else {//EnCap(Top영역) RightTrackLine Data Overlap 
									 // RightTrackLine Data OverLap Start
									 //////////////////////////////////////////////////////////////////////////////
									 if(AvgRightTrackLineDis!=0){
										 if(FInspectMode==Insp_Track){ //외곽기준 데이터 오버랩 한다 
											 if(RightOutLine[0].FP0.x!=0.0f && RightOutLine[0].FP0.y!=0.0f && RightOutLine[0].FP1.x!=0.0f && RightOutLine[0].FP1.y!=0.0f){
												 // TOP영역 LeftTrackLine x좌표 
												 RightTrackLine[0].FP0.x = RightOutLine[0].FP0.x - AvgRightTrackLineDis;
												 RightTrackLine[0].FP1.x = RightOutLine[0].FP1.x - AvgRightTrackLineDis;

												 // TOP영역 LeftTrackLine y좌표 
												 RightTrackLine[0].FP0.y = RightOutLine[0].FP0.y;
												 RightTrackLine[0].FP1.y = RightOutLine[0].FP1.y;
											 }
										 }
									 }
								 }
							 }
						 }
					 }
                 }
                 if (FBottomWall) {
					 if(FCompanyMode==COM_TIANMA) {  // 천마 검사 시퀀스 
						 if(IsMarkLine) EasyImage::Threshold(GImage,&BinaryImg, TopEdgeThresHold);
						 else           EasyImage::Threshold(GImage,&BinaryImg, EThresHold      );


						 if(EThresHold==0)        {SingleLine->GImage = GImage;     SingleLine->FThreshold =5 ;}
						 else                     {SingleLine->GImage = &BinaryImg; SingleLine->FThreshold =10;}

						 SingleLine->IRoi->SetOrgX  (IRoi->GetOrgX());
						 SingleLine->IRoi->SetOrgY  (IRoi->GetOrgY());
						 SingleLine->IRoi->SetWidth (IRoi->GetWidth());
						 SingleLine->IRoi->SetHeight(IRoi->GetHeight());

						 if(IRoi->GetOrgX()<=0 || IRoi->GetWidth()<=0 || IRoi->GetHeight()<=0){
							 return false;
						 }

						 if(IsShortCell && IsMarkLine) nTopBtmStart = IRoi->GetOrgX();

						 SingleLine->SetOrientation(orSouth);
// 						 SingleLine->FIncrement =10;
						 SingleLine->FIncrement =20;
						 SingleLine->SetFindLineId(0);
						 SingleLine->FThreshold =5;
						 SingleLine->OnExecute();
						 Line[3].FP0 = SingleLine->GetResultP0();
						 Line[3].FP1 = SingleLine->GetResultP1();
					 }
					 else if(FCompanyMode==COM_KWON) {             // 광원 검사 시퀀스 
						 EasyImage::Threshold(GImage,&BinaryImg, BtmEdgeThresHold);
						 if(BtmEdgeThresHold==0)    {SingleLine->GImage = GImage;     SingleLine->FThreshold =5 ;}
						 else                       {SingleLine->GImage = &BinaryImg; SingleLine->FThreshold =10;}

						 SingleLine->IRoi->SetOrgX  (IRoi->GetOrgX());
						 SingleLine->IRoi->SetOrgY  (IRoi->GetOrgY());
						 SingleLine->IRoi->SetWidth (IRoi->GetWidth());
						 SingleLine->IRoi->SetHeight(IRoi->GetHeight());
						 
						 SingleLine->SetOrientation(orSouth);
						 SingleLine->FIncrement =10;
						 SingleLine->SetFindLineId(0);
						 SingleLine->FThreshold =5;
						 SingleLine->OnExecute();
						 Line[waBottomWall].FP0 = SingleLine->GetResultP0();
						 Line[waBottomWall].FP1 = SingleLine->GetResultP1();

						 if(BtmOffset!=0 && BtmBmLineThresHold!=0){
							 // ThresHold 설정 
							 BMLineImg.SetSize(GImage->GetWidth(), GImage->GetHeight());
							 EasyImage::Oper(EArithmeticLogicOperation_Copy,GImage,&BMLineImg);
							 EasyImage::Threshold(GImage,&BMLineImg, BtmBmLineThresHold);
							 
							 SingleLine->GImage = &BMLineImg;
							 
							 // 영역설정 
							 if(fabs(Line[3].FP0.x - Line[3].FP1.x) > 3){
								 LSP.x = 
									 LSP.y = (Line[3].FP0.y + Line[3].FP1.y)/2;
							 }
							 else {
								 LSP = Math.OnIntersect(Line[3].FP0, Line[3].FP1, LT, LB);
							 }
							 
							 SingleLine->IRoi->SetOrgX  (IRoi->GetOrgX()        );
							 SingleLine->IRoi->SetOrgY  ((int)(LSP.y-BMHeight)  );
							 SingleLine->IRoi->SetWidth (IRoi->GetWidth()       );
							 SingleLine->IRoi->SetHeight(BMHeight               );
							 
							 // EdgeType Check 
							 if(IsMarkBtm) SingleLine->SetEdgeType(0); 
							 else          SingleLine->SetEdgeType(1); 
							 
							 if((LSP.y-2)<0) return false;
							 
							 SingleLine->SetOrientation(orSouth);
							 SingleLine->FIncrement =10;
							 SingleLine->SetFindLineId(0);
							 SingleLine->OnExecute();
							 BtmBMLine[0].FP0 = SingleLine->GetResultP0();
							 BtmBMLine[0].FP1 = SingleLine->GetResultP1();
							 
							 // SingleLine Org Parameter 
							 SingleLine->SetEdgeType(2);
						 }
					 }
					 else if(FCompanyMode==COM_BOE){  // BTM LineSearch 
						 EasyImage::Threshold(GImage,&BinaryImg, BtmEdgeThresHold);
						 if(BtmEdgeThresHold==0)    {SingleLine->GImage = GImage;     SingleLine->FThreshold =5 ;}
						 else                       {SingleLine->GImage = &BinaryImg; SingleLine->FThreshold =10;}

						 SingleLine->IRoi->SetOrgX  (IRoi->GetOrgX());
						 SingleLine->IRoi->SetOrgY  (IRoi->GetOrgY());
						 SingleLine->IRoi->SetWidth (IRoi->GetWidth());
						 SingleLine->IRoi->SetHeight(IRoi->GetHeight());

						 SingleLine->SetOrientation(orSouth);
						 SingleLine->FIncrement =10;
						 SingleLine->SetFindLineId(0);
						 SingleLine->FThreshold =5;
						 SingleLine->OnExecute();
						 Line[waBottomWall].FP0 = SingleLine->GetResultP0();
						 Line[waBottomWall].FP1 = SingleLine->GetResultP1();
					 }
					 else if(FCompanyMode==COM_NOTCH){ // Btm Line Search (Image Rotate 없음)
						 EasyImage::Threshold(GImage,&BinaryImg, BtmEdgeThresHold);
						 if(BtmEdgeThresHold==0)    {SingleLine->GImage = GImage;     SingleLine->FThreshold =5 ;}
						 else                       {SingleLine->GImage = &BinaryImg; SingleLine->FThreshold =10;}

						 SingleLine->IRoi->SetOrgX  (IRoi->GetOrgX());
						 SingleLine->IRoi->SetOrgY  (FEndLine-100   );
						 SingleLine->IRoi->SetWidth (IRoi->GetWidth());
						 SingleLine->IRoi->SetHeight(200             );

						 SingleLine->SetOrientation(orSouth);
						 SingleLine->FIncrement =50;
						 SingleLine->SetFindLineId(0);
						 SingleLine->FThreshold =5;

						 if(IsMarkBtm) SingleLine->SetEdgeType(1);  // White To Black 
						 else          SingleLine->SetEdgeType(1);  // White To Black 
						 
						 // 기본 BtmLine Search 
						 SingleLine->OnExecute();
// 						 Line[waBottomWall].FP0 = SingleLine->GetResultP0();
// 						 Line[waBottomWall].FP1 = SingleLine->GetResultP1();
						 Line[3].FP0 = SingleLine->GetResultP0();
						 Line[3].FP1 = SingleLine->GetResultP1();

						 // Btm TrackLine Search Only LTCell ==> Btm 검사시 
						 if(IsMarkBtm){
							 if(FInspectMode==Insp_Track){
								 EasyImage::Threshold(GImage,&BinaryImg, CirGrindMeaThresHold);
								 if(BtmEdgeThresHold==0)    {SingleLine->GImage = GImage;     SingleLine->FThreshold =5 ;}
								 else                       {SingleLine->GImage = &BinaryImg; SingleLine->FThreshold =10;}

								 SingleLine->IRoi->SetOrgX  (IRoi->GetOrgX());
								 SingleLine->IRoi->SetOrgY  (FEndLine-100   );
								 SingleLine->IRoi->SetWidth (IRoi->GetWidth());
								 SingleLine->IRoi->SetHeight(200             );
								 if((FEndLine-100<=0)|| (FEndLine-100>=ImgW)) return false;

								 SingleLine->SetOrientation(orSouth);
								 SingleLine->FIncrement =10;
								 SingleLine->SetFindLineId(0);
								 SingleLine->FThreshold =5;

								 SingleLine->SetEdgeType(1);  //White To Black 

								 SingleLine->OnExecute();
								 BtmTrackLine[0].FP0 = SingleLine->GetResultP0();
								 BtmTrackLine[0].FP1 = SingleLine->GetResultP1();

								 // TrackLine CrossPoint Calculate (Org Data)
								 FTRLBPoint = Math.OnIntersect(LeftTrackLine [0].FP0, LeftTrackLine [0].FP1, BtmTrackLine[0].FP0 , BtmTrackLine[0].FP1);
								 FTRRBPoint = Math.OnIntersect(RightTrackLine[0].FP0, RightTrackLine[0].FP1, BtmTrackLine[0].FP0 , BtmTrackLine[0].FP1);

								 if(TotalLeftTrackDis!=0  && LeftTrackLineCount!=0){ //LeftTrackLine 거리편차 평균값 
									 AvgLeftTrackLineDis  = (int)(TotalLeftTrackDis/LeftTrackLineCount);
								 }
								 if(TotalRightTrackDis!=0 && RightTrackLineCount!=0){//RightTrackLine 거리편차 평균값 
									 AvgRightTrackLineDis = (int)(TotalRightTrackDis/RightTrackLineCount);
								 }

								 if(BtmTrackLine[0].FP0.x!=0 && BtmTrackLine[0].FP0.y!=0 && BtmTrackLine[0].FP1.x!=0 && BtmTrackLine[0].FP1.y!=0){
								     if(Line[3].FP0.x!=0 && Line[3].FP0.y!=0 && Line[3].FP1.x!=0 && Line[3].FP1.y!=0){
								         AvgLeftBtmTrackLineDis = Math.GetLengthFrLineToPoint(Line[3].FP0, Line[3].FP1, BtmTrackLine[0].FP0);//외곽라인에서 TrackLine거리 
										 AvgRightBtmTrackLineDis= Math.GetLengthFrLineToPoint(Line[3].FP0, Line[3].FP1, BtmTrackLine[0].FP1);//외곽라인에서 TrackLine거리 
								     }
								 }
							 }
						 }
						 else { // EnCap Cell 검사시 TrackLine 데이터 만들어 준다 
							 if(AvgLeftBtmTrackLineDis!=0 && AvgRightBtmTrackLineDis!=0){
								 if(FInspectMode==Insp_Track){
									 BtmTrackLine[0].FP0.y = Line[3].FP0.y - AvgLeftBtmTrackLineDis ;
									 BtmTrackLine[0].FP1.y = Line[3].FP1.y - AvgRightBtmTrackLineDis;

									 BtmTrackLine[0].FP0.x = Line[3].FP0.x;
									 BtmTrackLine[0].FP1.x = Line[3].FP1.x;
								 }
							 }
							 // EnCap영역에 TrackLine 교차점을 LT영역 데이터를 이용하여 가상으로 생성해준다 
							 // Image Rotate 없음 (원본 이미지 기준 좌표)
							 if(LeftTrackLine[0].FP0.x!=0.0f && LeftTrackLine[0].FP0.y!=0.0f && RightTrackLine[0].FP0.x!=0.0f && RightTrackLine[0].FP0.y!=0.0f&&
								LeftTrackLine[0].FP1.x!=0.0f && LeftTrackLine[0].FP1.y!=0.0f && RightTrackLine[0].FP1.x!=0.0f && RightTrackLine[0].FP1.y!=0.0f){
								 if(BtmTrackLine[0].FP0.x!=0.0f && BtmTrackLine[0].FP0.y!=0.0f && BtmTrackLine[0].FP1.x!=0.0f && BtmTrackLine[0].FP1.y!=0.0f){
									FTRLBPoint = Math.OnIntersect(LeftTrackLine [0].FP0, LeftTrackLine [0].FP1, BtmTrackLine[0].FP0 , BtmTrackLine[0].FP1);
									FTRRBPoint = Math.OnIntersect(RightTrackLine[0].FP0, RightTrackLine[0].FP1, BtmTrackLine[0].FP0 , BtmTrackLine[0].FP1);
								 }
							 }
						 }
					 }
					 else if(FCompanyMode==COM_BMDT){ // Btm Line Search (Image Rotate 없음)
						 EasyImage::Threshold(GImage,&BinaryImg, BtmEdgeThresHold);
						 if(BtmEdgeThresHold==0)    {SingleLine->GImage = GImage;     SingleLine->FThreshold =5 ;}
						 else                       {SingleLine->GImage = &BinaryImg; SingleLine->FThreshold =10;}

						 if(FInspectMode==Insp_Surface){ // 표면검사 시퀀스 //
							 SingleLine->IRoi->SetOrgX  (IRoi->GetOrgX());
							 SingleLine->IRoi->SetOrgY  (FEndLine-100   );
							 SingleLine->IRoi->SetWidth (IRoi->GetWidth());
							 SingleLine->IRoi->SetHeight(200             );

							 SingleLine->SetOrientation(orSouth);
							 SingleLine->FIncrement =50;
							 SingleLine->SetFindLineId(0);
							 SingleLine->FThreshold =5;

							 if(IsMarkBtm) SingleLine->SetEdgeType(1);  // White To Black
							 else          SingleLine->SetEdgeType(1);  // White To Black

							 // 기본 BtmLine Search 
							 SingleLine->OnExecute();
							 Line[3].FP0 = SingleLine->GetResultP0();
							 Line[3].FP1 = SingleLine->GetResultP1();
						 }
						 else             { // 외관검사 시퀀스 //
							 SingleLine->IRoi->SetOrgX  (IRoi->GetOrgX());
							 SingleLine->IRoi->SetOrgY  (FEndLine-100   );
							 SingleLine->IRoi->SetWidth (IRoi->GetWidth());
							 SingleLine->IRoi->SetHeight(200             );

							 SingleLine->SetOrientation(orSouth);
							 SingleLine->FIncrement =50;
							 SingleLine->SetFindLineId(0);
							 SingleLine->FThreshold =5;

							 if(IsMarkBtm) SingleLine->SetEdgeType(1);  // White To Black 
							 else          SingleLine->SetEdgeType(1);  // White To Black 

							 // 기본 BtmLine Search 
							 SingleLine->OnExecute();
							 // 						 Line[waBottomWall].FP0 = SingleLine->GetResultP0();
							 // 						 Line[waBottomWall].FP1 = SingleLine->GetResultP1();
							 Line[3].FP0 = SingleLine->GetResultP0();
							 Line[3].FP1 = SingleLine->GetResultP1();

							 // Btm TrackLine Search Only LTCell ==> Btm 검사시 
							 if(IsMarkBtm){
								 if(FInspectMode==Insp_Track){
									 EasyImage::Threshold(GImage,&BinaryImg, CirGrindMeaThresHold);
									 if(BtmEdgeThresHold==0)    {SingleLine->GImage = GImage;     SingleLine->FThreshold =5 ;}
									 else                       {SingleLine->GImage = &BinaryImg; SingleLine->FThreshold =10;}

									 SingleLine->IRoi->SetOrgX  (IRoi->GetOrgX());
									 SingleLine->IRoi->SetOrgY  (FEndLine-100   );
									 SingleLine->IRoi->SetWidth (IRoi->GetWidth());
									 SingleLine->IRoi->SetHeight(200             );
									 if((FEndLine-100<=0)|| (FEndLine-100>=ImgW)) return false;

									 SingleLine->SetOrientation(orSouth);
									 SingleLine->FIncrement =10;
									 SingleLine->SetFindLineId(0);
									 SingleLine->FThreshold =5;

									 SingleLine->SetEdgeType(1);  //White To Black 

									 SingleLine->OnExecute();
									 BtmTrackLine[0].FP0 = SingleLine->GetResultP0();
									 BtmTrackLine[0].FP1 = SingleLine->GetResultP1();

									 // TrackLine CrossPoint Calculate (Org Data)
									 FTRLBPoint = Math.OnIntersect(LeftTrackLine [0].FP0, LeftTrackLine [0].FP1, BtmTrackLine[0].FP0 , BtmTrackLine[0].FP1);
									 FTRRBPoint = Math.OnIntersect(RightTrackLine[0].FP0, RightTrackLine[0].FP1, BtmTrackLine[0].FP0 , BtmTrackLine[0].FP1);

									 if(TotalLeftTrackDis!=0  && LeftTrackLineCount!=0){ //LeftTrackLine 거리편차 평균값 
										 AvgLeftTrackLineDis  = (int)(TotalLeftTrackDis/LeftTrackLineCount);
									 }
									 if(TotalRightTrackDis!=0 && RightTrackLineCount!=0){//RightTrackLine 거리편차 평균값 
										 AvgRightTrackLineDis = (int)(TotalRightTrackDis/RightTrackLineCount);
									 }

									 if(BtmTrackLine[0].FP0.x!=0 && BtmTrackLine[0].FP0.y!=0 && BtmTrackLine[0].FP1.x!=0 && BtmTrackLine[0].FP1.y!=0){
										 if(Line[3].FP0.x!=0 && Line[3].FP0.y!=0 && Line[3].FP1.x!=0 && Line[3].FP1.y!=0){
											 AvgLeftBtmTrackLineDis = Math.GetLengthFrLineToPoint(Line[3].FP0, Line[3].FP1, BtmTrackLine[0].FP0);//외곽라인에서 TrackLine거리 
											 AvgRightBtmTrackLineDis= Math.GetLengthFrLineToPoint(Line[3].FP0, Line[3].FP1, BtmTrackLine[0].FP1);//외곽라인에서 TrackLine거리 
										 }
									 }
								 }
							 }
							 else { // EnCap Cell 검사시 TrackLine 데이터 만들어 준다 
								 if(AvgLeftBtmTrackLineDis!=0 && AvgRightBtmTrackLineDis!=0){
									 if(FInspectMode==Insp_Track){
										 BtmTrackLine[0].FP0.y = Line[3].FP0.y - AvgLeftBtmTrackLineDis ;
										 BtmTrackLine[0].FP1.y = Line[3].FP1.y - AvgRightBtmTrackLineDis;

										 BtmTrackLine[0].FP0.x = Line[3].FP0.x;
										 BtmTrackLine[0].FP1.x = Line[3].FP1.x;
									 }
								 }
								 // EnCap영역에 TrackLine 교차점을 LT영역 데이터를 이용하여 가상으로 생성해준다 
								 // Image Rotate 없음 (원본 이미지 기준 좌표)
								 if(LeftTrackLine[0].FP0.x!=0.0f && LeftTrackLine[0].FP0.y!=0.0f && RightTrackLine[0].FP0.x!=0.0f && RightTrackLine[0].FP0.y!=0.0f&&
									 LeftTrackLine[0].FP1.x!=0.0f && LeftTrackLine[0].FP1.y!=0.0f && RightTrackLine[0].FP1.x!=0.0f && RightTrackLine[0].FP1.y!=0.0f){
										 if(BtmTrackLine[0].FP0.x!=0.0f && BtmTrackLine[0].FP0.y!=0.0f && BtmTrackLine[0].FP1.x!=0.0f && BtmTrackLine[0].FP1.y!=0.0f){
											 FTRLBPoint = Math.OnIntersect(LeftTrackLine [0].FP0, LeftTrackLine [0].FP1, BtmTrackLine[0].FP0 , BtmTrackLine[0].FP1);
											 FTRRBPoint = Math.OnIntersect(RightTrackLine[0].FP0, RightTrackLine[0].FP1, BtmTrackLine[0].FP0 , BtmTrackLine[0].FP1);
										 }
								 }
							 }
						 }
					 }
                 }
                 if (FLeftTop) {
				     if(FCompanyMode==COM_KWON){
						 if(ECThresHold==0) {SingleLine->GImage = GImage; SingleLine->FThreshold =5 ;}
						 else               {
							 EasyImage::Threshold(GImage,&BinaryImg, ECThresHold);
							 SingleLine->GImage = &BinaryImg; SingleLine->FThreshold =10;
						 }

						 OrgPoint = Math.OnIntersect(Line[waLeftWall].FP0, Line[waLeftWall].FP1, Line[waTopWall].FP0, Line[waTopWall].FP1);
						 FLTPoint = OrgPoint;
						 SingleLine->IRoi->SetOrgX  ((int)OrgPoint.x-10                );
						 SingleLine->IRoi->SetOrgY  ((int)OrgPoint.y                   );
						 SingleLine->IRoi->SetWidth ((int)CornerWidth                  );
						 SingleLine->IRoi->SetHeight((int)CornerHeight                 );

						 SingleLine->SetOrientation(orWest);
						 SingleLine->FIncrement =1;
						 SingleLine->FThreshold =15;
						 SingleLine->SetFindLineId(0);
						 SingleLine->OnExecute();
						 Line[waLeftTop].FP0 = SingleLine->GetResultP0();
						 Line[waLeftTop].FP1 = SingleLine->GetResultP1();

						 int Count  = SingleLine->FEdgePointCount;

						 // ORG 
						 FLTLPoint = Math.OnIntersect(SingleLine->GetResultP0(), SingleLine->GetResultP1(), Line[waLeftWall].FP0, Line[waLeftWall].FP1);
						 FLTTPoint = Math.OnIntersect(SingleLine->GetResultP0(), SingleLine->GetResultP1(), Line[waTopWall ].FP0, Line[waTopWall ].FP1);

						 // Mark기준 새로운 Line 계산 
						 MarkDegree = -(Math.GetDegree(FP0.x, FP0.y, FP1.x, FP1.y));
						 MarkLine[0].FP0.x = FP0.x-CELL_A; MarkLine[0].FP0.y = FP0.y;
						 MarkLine[0].FP0   = Math.OnRotate(FP0, MarkLine[0].FP0, MarkDegree);

						 MarkDegree = Math.GetDegree(Line[0].FP0.x, Line[0].FP0.y, Line[0].FP1.x, Line[0].FP1.y);
						 MarkLine[0].FP1.x =MarkLine[0].FP0.x; MarkLine[0].FP1.y = Line[0].FP1.y;
						 MarkLine[0].FP1 = Math.OnRotate(MarkLine[0].FP0, MarkLine[0].FP1, MarkDegree);

						 MarkDegree = Math.GetDegree(FP0.x, FP0.y, FP1.x, FP1.y);
						 MarkLine[1].FP0.x = FP0.x+30; MarkLine[1].FP0.y = FP0.y - CELL_D;
						 MarkLine[1].FP0 = Math.OnRotate(FP0, MarkLine[1].FP0, MarkDegree);

						 MarkDegree = Math.GetDegree(FP0.x, FP0.y, FP1.x, FP1.y);
						 MarkLine[1].FP1.x = FP1.x-30; MarkLine[1].FP1.y = FP1.y - CELL_D;
						 MarkLine[1].FP1 = Math.OnRotate(FP1, MarkLine[1].FP1, MarkDegree);

						 MarkFLTLPoint  = Math.OnIntersect(SingleLine->GetResultP0(), SingleLine->GetResultP1(),MarkLine[0].FP0,MarkLine[0].FP1);
						 MarkFLTTPoint  = Math.OnIntersect(SingleLine->GetResultP0(), SingleLine->GetResultP1(),MarkLine[1].FP0,MarkLine[1].FP1);
						 MarkCrossPoint = Math.OnIntersect(MarkLine[0].FP0, MarkLine[0].FP1, MarkLine[1].FP0, MarkLine[1].FP1);

						 // 연마가 되지 않을 경우 
						 if(IsCornerTop){
							 if((FLTLPoint.x==0 || FLTLPoint.y==0 || FLTTPoint.x==0 || FLTTPoint.y==0) || (SingleLine->FEdgePointCount <30)){
								 LTDx = 0.0f;
								 LTDy = 0.0f;
								 //화면에 디스플레이 위해서 
								 FLTLPoint.x = FLTPoint.x;
								 FLTLPoint.y = FLTPoint.y;
								 FLTTPoint.x = FLTPoint.x;
								 FLTTPoint.y = FLTPoint.y;
							 }
							 else {
								 // 							 LTDx = Math.GetLengthFrPointToPoint(FLTPoint, FLTTPoint);
								 // 							 LTDy = Math.GetLengthFrPointToPoint(FLTPoint, FLTLPoint);

								 // NEW 
								 MarkLTDx = Math.GetLengthFrPointToPoint(MarkCrossPoint, MarkFLTTPoint);
								 MarkLTDy = Math.GetLengthFrPointToPoint(MarkCrossPoint, MarkFLTLPoint);

								 LTDx = MarkLTDx;
								 LTDy = MarkLTDy;
							 }
						 }
						 else {
							 LTDx = 0.0f;
							 LTDy = 0.0f;
							 //화면에 디스플레이 위해서 
							 FLTLPoint.x = FLTPoint.x;
							 FLTLPoint.y = FLTPoint.y;
							 FLTTPoint.x = FLTPoint.x;
							 FLTTPoint.y = FLTPoint.y;
						 }

						 // New Corner 
						 if((SingleLine->FEdgePointCount) - (CornerMargin*2)>0){
							 if(C1Point!=NULL) delete[] C1Point;
							 C1Point  = new TFPoint [(SingleLine->FEdgePointCount) - (CornerMargin*2)];
							 C1EdgeCount = (SingleLine->FEdgePointCount) -(CornerMargin*2);

							 CornerCount =0;  
							 for(int k=CornerMargin; k<((SingleLine->FEdgePointCount)-CornerMargin); k++){
								 if(CornerCount>=MAX_DEFECT_POINT) break;
								 C1Point[CornerCount].x = SingleLine->FEdgePoint[k].x;
								 C1Point[CornerCount].y = SingleLine->FEdgePoint[k].y;
								 CornerCount++;
							 }
						 }
					 }
					 else if(FCompanyMode==COM_BOE){ // LeftTop LineSearch 
						 if(ECThresHold==0) {SingleLine->GImage = GImage; SingleLine->FThreshold =5 ;}
						 else               {
							 EasyImage::Threshold(GImage,&BinaryImg, ECThresHold);
							 SingleLine->GImage = &BinaryImg; SingleLine->FThreshold =10;
						 }

						 OrgPoint = Math.OnIntersect(Line[waLeftWall].FP0, Line[waLeftWall].FP1, Line[waTopWall].FP0, Line[waTopWall].FP1);
						 FLTPoint = OrgPoint;
						 // 스팩값 기준 자동 ROI설정이 방식 
// 						 SingleLine->IRoi->SetOrgX  ((int)OrgPoint.x-10                );
// 						 SingleLine->IRoi->SetOrgY  ((int)OrgPoint.y                   );
// 						 SingleLine->IRoi->SetWidth ((int)CornerWidth                  );
// 						 SingleLine->IRoi->SetHeight((int)CornerHeight                 );

						 if(IsCornerTop){
							 // 스팩값 기준 자동 ROI설정이 방식
							 CornerWidth  = Line[1].FP0.x - OrgPoint.x;
							 CornerHeight = Line[0].FP0.y - OrgPoint.y; 
							 SingleLine->IRoi->SetOrgX  ((int)OrgPoint.x-10                );
							 SingleLine->IRoi->SetOrgY  ((int)OrgPoint.y                   );
							 SingleLine->IRoi->SetWidth ((int)CornerWidth                  );
							 SingleLine->IRoi->SetHeight((int)CornerHeight                 );

							 if((OrgPoint.x-10)<=0    || OrgPoint.y<0    || CornerWidth<=0    || CornerHeight<=0   ) return false;
							 if((OrgPoint.x-10)>=ImgW || OrgPoint.y>ImgH || CornerWidth>=ImgW || CornerHeight>=ImgH) return false;

							 SingleLine->SetOrientation(orWest);
							 SingleLine->FIncrement =1 ;
							 SingleLine->FThreshold =15;
							 SingleLine->SetFindLineId(0);
							 SingleLine->OnExecute();
							 // 						 Line[waLeftTop].FP0 = SingleLine->GetResultP0();
							 // 						 Line[waLeftTop].FP1 = SingleLine->GetResultP1();
							 Line[4].FP0 = SingleLine->GetResultP0();
							 Line[4].FP1 = SingleLine->GetResultP1();


							 int Count  = SingleLine->FEdgePointCount;

							 // ORG 
							 FLTLPoint = Math.OnIntersect(SingleLine->GetResultP0(), SingleLine->GetResultP1(), Line[waLeftWall].FP0, Line[waLeftWall].FP1);
							 FLTTPoint = Math.OnIntersect(SingleLine->GetResultP0(), SingleLine->GetResultP1(), Line[waTopWall ].FP0, Line[waTopWall ].FP1);

							 // 연마가 되지 않을 경우 
							 if((FLTLPoint.x==0 || FLTLPoint.y==0 || FLTTPoint.x==0 || FLTTPoint.y==0) || (SingleLine->FEdgePointCount <30)){
								 LTDx = 0.0f;
								 LTDy = 0.0f;
								 //화면에 디스플레이 위해서 
								 FLTLPoint.x = FLTPoint.x;
								 FLTLPoint.y = FLTPoint.y;
								 FLTTPoint.x = FLTPoint.x;
								 FLTTPoint.y = FLTPoint.y;
							}
							else {
								 LTDx = Math.GetLengthFrPointToPoint(FLTPoint, FLTTPoint);
								 LTDy = Math.GetLengthFrPointToPoint(FLTPoint, FLTLPoint);

								 // New Corner 
								 if((SingleLine->FEdgePointCount) - (CornerMargin*2)>0){
									 if(C1Point!=NULL) delete[] C1Point;
									 C1Point  = new TFPoint [(SingleLine->FEdgePointCount) - (CornerMargin*2)];
									 C1EdgeCount = (SingleLine->FEdgePointCount) -(CornerMargin*2);

									 CornerCount =0;  
									 for(int k=CornerMargin; k<((SingleLine->FEdgePointCount)-CornerMargin); k++){
										 if(CornerCount>=MAX_DEFECT_POINT) break;
										 C1Point[CornerCount].x = SingleLine->FEdgePoint[k].x;
										 C1Point[CornerCount].y = SingleLine->FEdgePoint[k].y;
										 CornerCount++;
									 }
								 }
							}
						}
						else {
							 LTDx = 0.0f;
							 LTDy = 0.0f;
							 //화면에 디스플레이 위해서 
							 FLTLPoint.x = FLTPoint.x;
							 FLTLPoint.y = FLTPoint.y;
							 FLTTPoint.x = FLTPoint.x;
							 FLTTPoint.y = FLTPoint.y;
						}
					 }
					 else if(FCompanyMode==COM_NOTCH){ // FLeftTop
// 						 if(ECThresHold==0) {SingleLine->GImage = GImage; SingleLine->FThreshold =5 ;}
// 						 else               {
// 							 EasyImage::Threshold(GImage,&BinaryImg, ECThresHold);
// 							 SingleLine->GImage = &BinaryImg; SingleLine->FThreshold =10;
// 						 }
// 
// 						 OrgPoint = Math.OnIntersect(Line[waLeftWall].FP0, Line[waLeftWall].FP1, Line[waTopWall].FP0, Line[waTopWall].FP1);
// 						 FLTPoint = OrgPoint;
// 
// 						 if(IsCornerTop){
// 							 SingleLine->IRoi->SetOrgX  ((int)OrgPoint.x-10                );
// 							 SingleLine->IRoi->SetOrgY  ((int)OrgPoint.y                   );
// 							 SingleLine->IRoi->SetWidth ((int)CornerWidth+20               );
// 							 SingleLine->IRoi->SetHeight((int)CornerHeight                 );
// 
// 							 SingleLine->SetOrientation(orWest);
// 							 SingleLine->FIncrement =1;
// 							 SingleLine->FThreshold =15;
// 							 SingleLine->SetFindLineId(0);
// 							 SingleLine->SetEdgeType(1);  //White To Black 
// 							 SingleLine->OnExecute();
// 							 Line[waLeftTop].FP0 = SingleLine->GetResultP0();
// 							 Line[waLeftTop].FP1 = SingleLine->GetResultP1();
// 
// 							 // ORG 
// 							 FLTLPoint = Math.OnIntersect(SingleLine->GetResultP0(), SingleLine->GetResultP1(), Line[waLeftWall].FP0, Line[waLeftWall].FP1);
// 							 FLTTPoint = Math.OnIntersect(SingleLine->GetResultP0(), SingleLine->GetResultP1(), Line[waTopWall ].FP0, Line[waTopWall ].FP1);
// 
// 							 if((FLTLPoint.x==0 || FLTLPoint.y==0 || FLTTPoint.x==0 || FLTTPoint.y==0) || (SingleLine->FEdgePointCount <30)){
// 								 LTDx = 0.0f;
// 								 LTDy = 0.0f;
// 								 //화면에 디스플레이 위해서 
// 								 FLTLPoint.x = FLTPoint.x;
// 								 FLTLPoint.y = FLTPoint.y;
// 								 FLTTPoint.x = FLTPoint.x;
// 								 FLTTPoint.y = FLTPoint.y;
// 							 }
// 							 else {
// 								 LTDx = Math.GetLengthFrPointToPoint(FLTPoint, FLTTPoint);
// 								 LTDy = Math.GetLengthFrPointToPoint(FLTPoint, FLTLPoint);
// 
// 								 // OutLine C1Corner Data 
// 								 if((SingleLine->FEdgePointCount) - (CornerMargin*2)>0){
// 									 if(C1Point!=NULL) delete[] C1Point;
// 									 C1Point  = new TFPoint [(SingleLine->FEdgePointCount) - (CornerMargin*2)];
// 									 C1EdgeCount = (SingleLine->FEdgePointCount) -(CornerMargin*2);
// 
// 									 CornerCount =0;  
// 									 for(int k=CornerMargin; k<((SingleLine->FEdgePointCount)-CornerMargin); k++){
// 										 if(CornerCount>=MAX_DEFECT_POINT) break;
// 										 C1Point[CornerCount].x = SingleLine->FEdgePoint[k].x;
// 										 C1Point[CornerCount].y = SingleLine->FEdgePoint[k].y;
// 										 CornerCount++;
// 									 }
// 								 }
// 
// 								 // Corner 연마 안쪽라인 찾는다 
// 								 SingleLine->SetFindLineId(0);
// 								 SingleLine->SetEdgeType(0);  //Black To White 
// 								 SingleLine->OnExecute();
// 
// 								 // InLine C1Corner Data 
// 								 if((SingleLine->FEdgePointCount) - (CornerMargin*2)>0){
// 									 if(C1InPoint!=NULL) delete[] C1InPoint;
// 									 C1InPoint  = new TFPoint [(SingleLine->FEdgePointCount) - (CornerMargin*2)];
// 									 C1EdgeCount = (SingleLine->FEdgePointCount) -(CornerMargin*2);
// 
// 									 CornerCount =0;  
// 									 for(int k=CornerMargin; k<((SingleLine->FEdgePointCount)-CornerMargin); k++){
// 										 if(CornerCount>=MAX_DEFECT_POINT) break;
// 										 C1InPoint[CornerCount].x = SingleLine->FEdgePoint[k].x;
// 										 C1InPoint[CornerCount].y = SingleLine->FEdgePoint[k].y;
// 										 CornerCount++;
// 									 }
// 								 }
// 								 //코너 연마안쪽라인 기준 새로운 교차점 생성 
// 								 FLTLInPoint = Math.OnIntersect(SingleLine->GetResultP0(), SingleLine->GetResultP1(), Line[waLeftWall].FP0, Line[waLeftWall].FP1);
// 								 FLTTInPoint = Math.OnIntersect(SingleLine->GetResultP0(), SingleLine->GetResultP1(), Line[waTopWall ].FP0, Line[waTopWall ].FP1);
//                                  
// 								 //코너 연마폭, 연마량 계산 
// 								 double Dis =0.0f, AvgGrindWidth=0.0f, AvgGrindMea=0.0f, TotalGrindWidth=0.0f;
// 								 for(int k=0; k<C1EdgeCount; k++){
// 									 Dis = Math.GetLengthFrLineToPoint(FLTLPoint, FLTTPoint, C1InPoint[k]);
// 									 TotalGrindWidth+=Dis;
// 								 }
// 								 if(C1EdgeCount!=0){
// 									 AvgGrindWidth = (TotalGrindWidth/C1EdgeCount);
// 									 C1CorGrindWd  = AvgGrindWidth;
// 								 }
// 							 }
// 						 }
// 						 else {
// 							 LTDx = 0.0f;
// 							 LTDy = 0.0f;
// 							 //화면에 디스플레이 위해서 
// 							 FLTLPoint.x = FLTPoint.x;
// 							 FLTLPoint.y = FLTPoint.y;
// 							 FLTTPoint.x = FLTPoint.x;
// 							 FLTTPoint.y = FLTPoint.y;
// 						 }
 					 }
					 else if(FCompanyMode==COM_BMDT){  // FLeftTop Image 회전 후 다시 검사하기때문에 중복검사 일단, 주석 처리함 
// 						 if(ECThresHold==0) {SingleLine->GImage = GImage; SingleLine->FThreshold =5 ;}
// 						 else               {
// 							 EasyImage::Threshold(GImage,&BinaryImg, ECThresHold);
// 							 SingleLine->GImage = &BinaryImg; SingleLine->FThreshold =10;
// 						 }
// 
// 						 OrgPoint = Math.OnIntersect(Line[waLeftWall].FP0, Line[waLeftWall].FP1, Line[waTopWall].FP0, Line[waTopWall].FP1);
// 						 FLTPoint = OrgPoint;
// 
// 						 if(IsCornerTop){
// 							 SingleLine->IRoi->SetOrgX  ((int)OrgPoint.x-10                );
// 							 SingleLine->IRoi->SetOrgY  ((int)OrgPoint.y                   );
// 							 SingleLine->IRoi->SetWidth ((int)CornerWidth+20               );
// 							 SingleLine->IRoi->SetHeight((int)CornerHeight                 );
// 
// 							 SingleLine->SetOrientation(orWest);
// 							 SingleLine->FIncrement =1;
// 							 SingleLine->FThreshold =15;
// 							 SingleLine->SetFindLineId(0);
// 							 SingleLine->SetEdgeType(1);  //White To Black 
// 							 SingleLine->OnExecute();
// 							 Line[waLeftTop].FP0 = SingleLine->GetResultP0();
// 							 Line[waLeftTop].FP1 = SingleLine->GetResultP1();
// 
// 							 // ORG 
// 							 FLTLPoint = Math.OnIntersect(SingleLine->GetResultP0(), SingleLine->GetResultP1(), Line[waLeftWall].FP0, Line[waLeftWall].FP1);
// 							 FLTTPoint = Math.OnIntersect(SingleLine->GetResultP0(), SingleLine->GetResultP1(), Line[waTopWall ].FP0, Line[waTopWall ].FP1);
// 
// 							 if((FLTLPoint.x==0 || FLTLPoint.y==0 || FLTTPoint.x==0 || FLTTPoint.y==0) || (SingleLine->FEdgePointCount <30)){
// 								 LTDx = 0.0f;
// 								 LTDy = 0.0f;
// 								 //화면에 디스플레이 위해서 
// 								 FLTLPoint.x = FLTPoint.x;
// 								 FLTLPoint.y = FLTPoint.y;
// 								 FLTTPoint.x = FLTPoint.x;
// 								 FLTTPoint.y = FLTPoint.y;
// 							 }
// 							 else {
// 								 LTDx = Math.GetLengthFrPointToPoint(FLTPoint, FLTTPoint);
// 								 LTDy = Math.GetLengthFrPointToPoint(FLTPoint, FLTLPoint);
// 
// 								 // OutLine C1Corner Data 
// 								 if((SingleLine->FEdgePointCount) - (CornerMargin*2)>0){
// 									 if(C1Point!=NULL) delete[] C1Point;
// 									 C1Point  = new TFPoint [(SingleLine->FEdgePointCount) - (CornerMargin*2)];
// 									 C1EdgeCount = (SingleLine->FEdgePointCount) -(CornerMargin*2);
// 
// 									 CornerCount =0;  
// 									 for(int k=CornerMargin; k<((SingleLine->FEdgePointCount)-CornerMargin); k++){
// 										 if(CornerCount>=MAX_DEFECT_POINT) break;
// 										 C1Point[CornerCount].x = SingleLine->FEdgePoint[k].x;
// 										 C1Point[CornerCount].y = SingleLine->FEdgePoint[k].y;
// 										 CornerCount++;
// 									 }
// 								 }
// 
// 								 // Corner 연마 안쪽라인 찾는다 
// 								 SingleLine->SetFindLineId(0);
// 								 SingleLine->SetEdgeType(0);  //Black To White 
// 								 SingleLine->OnExecute();
// 
// 								 // InLine C1Corner Data 
// 								 if((SingleLine->FEdgePointCount) - (CornerMargin*2)>0){
// 									 if(C1InPoint!=NULL) delete[] C1InPoint;
// 									 C1InPoint  = new TFPoint [(SingleLine->FEdgePointCount) - (CornerMargin*2)];
// 									 C1EdgeCount = (SingleLine->FEdgePointCount) -(CornerMargin*2);
// 
// 									 CornerCount =0;  
// 									 for(int k=CornerMargin; k<((SingleLine->FEdgePointCount)-CornerMargin); k++){
// 										 if(CornerCount>=MAX_DEFECT_POINT) break;
// 										 C1InPoint[CornerCount].x = SingleLine->FEdgePoint[k].x;
// 										 C1InPoint[CornerCount].y = SingleLine->FEdgePoint[k].y;
// 										 CornerCount++;
// 									 }
// 								 }
// 								 //코너 연마안쪽라인 기준 새로운 교차점 생성 
// 								 FLTLInPoint = Math.OnIntersect(SingleLine->GetResultP0(), SingleLine->GetResultP1(), Line[waLeftWall].FP0, Line[waLeftWall].FP1);
// 								 FLTTInPoint = Math.OnIntersect(SingleLine->GetResultP0(), SingleLine->GetResultP1(), Line[waTopWall ].FP0, Line[waTopWall ].FP1);
// 
// 								 //코너 연마폭, 연마량 계산 
// 								 double Dis =0.0f, AvgGrindWidth=0.0f, AvgGrindMea=0.0f, TotalGrindWidth=0.0f;
// 								 for(int k=0; k<C1EdgeCount; k++){
// 									 Dis = Math.GetLengthFrLineToPoint(FLTLPoint, FLTTPoint, C1InPoint[k]);
// 									 TotalGrindWidth+=Dis;
// 								 }
// 								 if(C1EdgeCount!=0){
// 									 AvgGrindWidth = (TotalGrindWidth/C1EdgeCount);
// 									 C1CorGrindWd  = AvgGrindWidth;
// 								 }
// 							 }
// 						 }
// 						 else {
// 							 LTDx = 0.0f;
// 							 LTDy = 0.0f;
// 							 //화면에 디스플레이 위해서 
// 							 FLTLPoint.x = FLTPoint.x;
// 							 FLTLPoint.y = FLTPoint.y;
// 							 FLTTPoint.x = FLTPoint.x;
// 							 FLTTPoint.y = FLTPoint.y;
// 						 }
					 }
                 }
                 if (FRightTop) {
					 if(FCompanyMode==COM_KWON){
						 if(ECThresHold==0) {SingleLine->GImage = GImage; SingleLine->FThreshold =5 ;}
						 else               {
							 EasyImage::Threshold(GImage,&BinaryImg, ECThresHold);
							 SingleLine->GImage = &BinaryImg; SingleLine->FThreshold =10;
						 }

						 OrgPoint = Math.OnIntersect(Line[waRightWall].FP0, Line[waRightWall].FP1, Line[waTopWall].FP0, Line[waTopWall].FP1);
						 FRTPoint = OrgPoint;
						 //                      SingleLine->IRoi->SetOrgX  ((int)(OrgPoint.x-CornerWidth));
						 //                      SingleLine->IRoi->SetOrgY  ((int) OrgPoint.y+CornerMargin);
						 //                      SingleLine->IRoi->SetWidth (CornerWidth+10               );
						 //                      SingleLine->IRoi->SetHeight(CornerHeight-(CornerMargin*2));

						 if(IsCornerTop){
							 SingleLine->IRoi->SetOrgX  ((int)(OrgPoint.x-CornerWidth));
							 SingleLine->IRoi->SetOrgY  ((int) OrgPoint.y             );
							 SingleLine->IRoi->SetWidth (CornerWidth+10               );
							 SingleLine->IRoi->SetHeight(CornerHeight                 );

							 SingleLine->SetOrientation(orEast);
							 SingleLine->FIncrement =1;
							 SingleLine->FThreshold =15;
							 SingleLine->SetFindLineId(0);
							 SingleLine->OnExecute();
							 Line[waRightTop].FP0 = SingleLine->GetResultP0();
							 Line[waRightTop].FP1 = SingleLine->GetResultP1();

							 int Count  = SingleLine->FEdgePointCount;  

							 FRTRPoint = Math.OnIntersect(SingleLine->GetResultP0(), SingleLine->GetResultP1(), Line[waRightWall].FP0, Line[waRightWall].FP1);
							 FRTTPoint = Math.OnIntersect(SingleLine->GetResultP0(), SingleLine->GetResultP1(), Line[waTopWall].FP0, Line[waTopWall].FP1);


							 // Mark기준 새로운 Line 계산 
							 MarkDegree =-(Math.GetDegree(FP0.x, FP0.y, FP1.x, FP1.y));
							 MarkLine[2].FP0.x = FP1.x+CELL_C; MarkLine[2].FP0.y = FP1.y;
							 MarkLine[2].FP0   = Math.OnRotate(FP1, MarkLine[2].FP0, MarkDegree);

							 MarkDegree = Math.GetDegree(Line[2].FP0.x, Line[2].FP0.y, Line[2].FP1.x, Line[2].FP1.y);
							 MarkLine[2].FP1.x =MarkLine[2].FP0.x; MarkLine[2].FP1.y = Line[2].FP1.y;
							 MarkLine[2].FP1   = Math.OnRotate(MarkLine[2].FP0, MarkLine[2].FP1, MarkDegree);

							 MarkFRTRPoint  = Math.OnIntersect(SingleLine->GetResultP0(), SingleLine->GetResultP1(),MarkLine[2].FP0,MarkLine[2].FP1);
							 MarkFRTTPoint  = Math.OnIntersect(SingleLine->GetResultP0(), SingleLine->GetResultP1(),MarkLine[1].FP0,MarkLine[1].FP1);
							 MarkCrossPoint = Math.OnIntersect(MarkLine[2].FP0,MarkLine[2].FP1, MarkLine[1].FP0, MarkLine[1].FP1);

							 // 연마가 되지 않을 경우 
							 if((FRTRPoint.x==0 || FRTRPoint.y==0 || FRTTPoint.x==0 || FRTTPoint.y==0) || (SingleLine->FEdgePointCount <30)){
								 RTDx = 0.0f;
								 RTDy = 0.0f;
								 //화면에 디스플레이 위해서 
								 FRTRPoint.x = FRTPoint.x;
								 FRTRPoint.y = FRTPoint.y;
								 FRTTPoint.x = FRTPoint.x;
								 FRTTPoint.y = FRTPoint.y;
							 }
							 else {
								 MarkRTDx = Math.GetLengthFrPointToPoint(MarkCrossPoint, MarkFRTTPoint);
								 MarkRTDy = Math.GetLengthFrPointToPoint(MarkCrossPoint, MarkFRTRPoint);

								 RTDx = MarkRTDx;
								 RTDy = MarkRTDy;

								 // New Corner 
								 if((SingleLine->FEdgePointCount) - (CornerMargin*2)>0){
									 if(C2Point!=NULL) delete[] C2Point;
									 C2Point  = new TFPoint [(SingleLine->FEdgePointCount) - (CornerMargin*2)];
									 C2EdgeCount = (SingleLine->FEdgePointCount) -(CornerMargin*2);

									 CornerCount =0;  
									 for(int k=CornerMargin; k<((SingleLine->FEdgePointCount)-CornerMargin); k++){
										 if(CornerCount>=MAX_DEFECT_POINT) break;
										 C2Point[CornerCount].x = SingleLine->FEdgePoint[k].x;
										 C2Point[CornerCount].y = SingleLine->FEdgePoint[k].y;
										 CornerCount++;
									 }
								 }
							 }
						 }
						 else {
							 RTDx = 0.0f;
							 RTDy = 0.0f;
							 //화면에 디스플레이 위해서 
							 FRTRPoint.x = FRTPoint.x;
							 FRTRPoint.y = FRTPoint.y;
							 FRTTPoint.x = FRTPoint.x;
							 FRTTPoint.y = FRTPoint.y;
						 }
					 }
					 else if(FCompanyMode==COM_NOTCH){ //FRightTop
// 						 if(ECThresHold==0) {SingleLine->GImage = GImage; SingleLine->FThreshold =5 ;}
// 						 else               {
// 							 EasyImage::Threshold(GImage,&BinaryImg, ECThresHold);
// 							 SingleLine->GImage = &BinaryImg; SingleLine->FThreshold =10;
// 						 }
// 
// 						 OrgPoint = Math.OnIntersect(Line[waRightWall].FP0, Line[waRightWall].FP1, Line[waTopWall].FP0, Line[waTopWall].FP1);
// 						 FRTPoint = OrgPoint;
// 
// 						 if(IsCornerTop){
// 							 SingleLine->IRoi->SetOrgX  ((int)(OrgPoint.x-CornerWidth-20));
// 							 SingleLine->IRoi->SetOrgY  ((int) OrgPoint.y                );
// 							 SingleLine->IRoi->SetWidth (CornerWidth+10                  );
// 							 SingleLine->IRoi->SetHeight(CornerHeight                    );
// 
// 							 SingleLine->SetOrientation(orEast);
// 							 SingleLine->FIncrement =1;
// 							 SingleLine->FThreshold =15;
// 							 SingleLine->SetFindLineId(0);
// 							 SingleLine->SetEdgeType(1);  //White To Black 
// 							 SingleLine->OnExecute();
// 							 Line[waRightTop].FP0 = SingleLine->GetResultP0();
// 							 Line[waRightTop].FP1 = SingleLine->GetResultP1();
// 
// 							 // ORG 
// 							 FRTRPoint = Math.OnIntersect(SingleLine->GetResultP0(), SingleLine->GetResultP1(), Line[waRightWall].FP0, Line[waRightWall].FP1);
// 							 FRTTPoint = Math.OnIntersect(SingleLine->GetResultP0(), SingleLine->GetResultP1(), Line[waTopWall  ].FP0, Line[waTopWall].FP1  );
// 
// 							 if((FRTRPoint.x==0 || FRTRPoint.y==0 || FRTTPoint.x==0 || FRTTPoint.y==0) || (SingleLine->FEdgePointCount <30)){
// 								 RTDx = 0.0f;
// 								 RTDy = 0.0f;
// 								 //화면에 디스플레이 위해서 
// 								 FRTRPoint.x = FRTPoint.x;
// 								 FRTRPoint.y = FRTPoint.y;
// 								 FRTTPoint.x = FRTPoint.x;
// 								 FRTTPoint.y = FRTPoint.y;
// 							 }
// 							 else {
// 								 RTDx = Math.GetLengthFrPointToPoint(FRTPoint, FRTTPoint);
// 								 RTDy = Math.GetLengthFrPointToPoint(FRTPoint, FRTRPoint);
// 
// 								 // OutLine C2Corner Data 
// 								 if((SingleLine->FEdgePointCount) - (CornerMargin*2)>0){
// 									 if(C2Point!=NULL) delete[] C2Point;
// 									 C2Point  = new TFPoint [(SingleLine->FEdgePointCount) - (CornerMargin*2)];
// 									 C2EdgeCount = (SingleLine->FEdgePointCount) -(CornerMargin*2);
// 
// 									 CornerCount =0;  
// 									 for(int k=CornerMargin; k<((SingleLine->FEdgePointCount)-CornerMargin); k++){
// 										 if(CornerCount>=MAX_DEFECT_POINT) break;
// 										 C2Point[CornerCount].x = SingleLine->FEdgePoint[k].x;
// 										 C2Point[CornerCount].y = SingleLine->FEdgePoint[k].y;
// 										 CornerCount++;
// 									 }
// 								 }
// 
// 								 // Corner 연마 안쪽라인 찾는다 
// 								 SingleLine->SetFindLineId(0);
// 								 SingleLine->SetEdgeType(0);  //Black To White 
// 								 SingleLine->OnExecute();
// 
// 								 // InLine C2Corner Data 
// 								 if((SingleLine->FEdgePointCount) - (CornerMargin*2)>0){
// 									 if(C2InPoint!=NULL) delete[] C2InPoint;
// 									 C2InPoint  = new TFPoint [(SingleLine->FEdgePointCount) - (CornerMargin*2)];
// 									 C2EdgeCount = (SingleLine->FEdgePointCount) -(CornerMargin*2);
// 
// 									 CornerCount =0;  
// 									 for(int k=CornerMargin; k<((SingleLine->FEdgePointCount)-CornerMargin); k++){
// 										 if(CornerCount>=MAX_DEFECT_POINT) break;
// 										 C2InPoint[CornerCount].x = SingleLine->FEdgePoint[k].x;
// 										 C2InPoint[CornerCount].y = SingleLine->FEdgePoint[k].y;
// 										 CornerCount++;
// 									 }
// 								 }
// 								 //코너 연마안쪽라인 기준 새로운 교차점 생성 
// 								 FRTRInPoint = Math.OnIntersect(SingleLine->GetResultP0(), SingleLine->GetResultP1(), Line[waRightWall].FP0, Line[waRightWall].FP1);
// 								 FRTTInPoint = Math.OnIntersect(SingleLine->GetResultP0(), SingleLine->GetResultP1(), Line[waTopWall  ].FP0, Line[waTopWall].FP1  );
// 
// 								 //코너 연마폭, 연마량 계산 
// 								 double Dis =0.0f, AvgGrindWidth=0.0f, AvgGrindMea=0.0f, TotalGrindWidth=0.0f;
// 								 for(int k=0; k<C2EdgeCount; k++){
// 									 Dis = Math.GetLengthFrLineToPoint(FRTRPoint, FRTTPoint, C2InPoint[k]);
// 									 TotalGrindWidth+=Dis;
// 								 }
// 								 if(C2EdgeCount!=0){
// 									 AvgGrindWidth = (TotalGrindWidth/C2EdgeCount);
// 									 C2CorGrindWd  = AvgGrindWidth;
// 								 }
// 							 }
// 						 }
// 						 else {
// 							 RTDx = 0.0f;
// 							 RTDy = 0.0f;
// 							 //화면에 디스플레이 위해서 
// 							 FRTRPoint.x = FRTPoint.x;
// 							 FRTRPoint.y = FRTPoint.y;
// 							 FRTTPoint.x = FRTPoint.x;
// 							 FRTTPoint.y = FRTPoint.y;
// 						 }
					 }
					 else if(FCompanyMode==COM_BMDT){ //FRightTop Image 회전 후 다시 검사하기때문에 중복검사 일단, 주석 처리함 
// 						 if(ECThresHold==0) {SingleLine->GImage = GImage; SingleLine->FThreshold =5 ;}
// 						 else               {
// 							 EasyImage::Threshold(GImage,&BinaryImg, ECThresHold);
// 							 SingleLine->GImage = &BinaryImg; SingleLine->FThreshold =10;
// 						 }
// 
// 						 OrgPoint = Math.OnIntersect(Line[waRightWall].FP0, Line[waRightWall].FP1, Line[waTopWall].FP0, Line[waTopWall].FP1);
// 						 FRTPoint = OrgPoint;
// 
// 						 if(IsCornerTop){
// 							 SingleLine->IRoi->SetOrgX  ((int)(OrgPoint.x-CornerWidth-20));
// 							 SingleLine->IRoi->SetOrgY  ((int) OrgPoint.y                );
// 							 SingleLine->IRoi->SetWidth (CornerWidth+10                  );
// 							 SingleLine->IRoi->SetHeight(CornerHeight                    );
// 
// 							 SingleLine->SetOrientation(orEast);
// 							 SingleLine->FIncrement =1;
// 							 SingleLine->FThreshold =15;
// 							 SingleLine->SetFindLineId(0);
// 							 SingleLine->SetEdgeType(1);  //White To Black 
// 							 SingleLine->OnExecute();
// 							 Line[waRightTop].FP0 = SingleLine->GetResultP0();
// 							 Line[waRightTop].FP1 = SingleLine->GetResultP1();
// 
// 							 // ORG 
// 							 FRTRPoint = Math.OnIntersect(SingleLine->GetResultP0(), SingleLine->GetResultP1(), Line[waRightWall].FP0, Line[waRightWall].FP1);
// 							 FRTTPoint = Math.OnIntersect(SingleLine->GetResultP0(), SingleLine->GetResultP1(), Line[waTopWall  ].FP0, Line[waTopWall].FP1  );
// 
// 							 if((FRTRPoint.x==0 || FRTRPoint.y==0 || FRTTPoint.x==0 || FRTTPoint.y==0) || (SingleLine->FEdgePointCount <30)){
// 								 RTDx = 0.0f;
// 								 RTDy = 0.0f;
// 								 //화면에 디스플레이 위해서 
// 								 FRTRPoint.x = FRTPoint.x;
// 								 FRTRPoint.y = FRTPoint.y;
// 								 FRTTPoint.x = FRTPoint.x;
// 								 FRTTPoint.y = FRTPoint.y;
// 							 }
// 							 else {
// 								 RTDx = Math.GetLengthFrPointToPoint(FRTPoint, FRTTPoint);
// 								 RTDy = Math.GetLengthFrPointToPoint(FRTPoint, FRTRPoint);
// 
// 								 // OutLine C2Corner Data 
// 								 if((SingleLine->FEdgePointCount) - (CornerMargin*2)>0){
// 									 if(C2Point!=NULL) delete[] C2Point;
// 									 C2Point  = new TFPoint [(SingleLine->FEdgePointCount) - (CornerMargin*2)];
// 									 C2EdgeCount = (SingleLine->FEdgePointCount) -(CornerMargin*2);
// 
// 									 CornerCount =0;  
// 									 for(int k=CornerMargin; k<((SingleLine->FEdgePointCount)-CornerMargin); k++){
// 										 if(CornerCount>=MAX_DEFECT_POINT) break;
// 										 C2Point[CornerCount].x = SingleLine->FEdgePoint[k].x;
// 										 C2Point[CornerCount].y = SingleLine->FEdgePoint[k].y;
// 										 CornerCount++;
// 									 }
// 								 }
// 
// 								 // Corner 연마 안쪽라인 찾는다 
// 								 SingleLine->SetFindLineId(0);
// 								 SingleLine->SetEdgeType(0);  //Black To White 
// 								 SingleLine->OnExecute();
// 
// 								 // InLine C2Corner Data 
// 								 if((SingleLine->FEdgePointCount) - (CornerMargin*2)>0){
// 									 if(C2InPoint!=NULL) delete[] C2InPoint;
// 									 C2InPoint  = new TFPoint [(SingleLine->FEdgePointCount) - (CornerMargin*2)];
// 									 C2EdgeCount = (SingleLine->FEdgePointCount) -(CornerMargin*2);
// 
// 									 CornerCount =0;  
// 									 for(int k=CornerMargin; k<((SingleLine->FEdgePointCount)-CornerMargin); k++){
// 										 if(CornerCount>=MAX_DEFECT_POINT) break;
// 										 C2InPoint[CornerCount].x = SingleLine->FEdgePoint[k].x;
// 										 C2InPoint[CornerCount].y = SingleLine->FEdgePoint[k].y;
// 										 CornerCount++;
// 									 }
// 								 }
// 								 //코너 연마안쪽라인 기준 새로운 교차점 생성 
// 								 FRTRInPoint = Math.OnIntersect(SingleLine->GetResultP0(), SingleLine->GetResultP1(), Line[waRightWall].FP0, Line[waRightWall].FP1);
// 								 FRTTInPoint = Math.OnIntersect(SingleLine->GetResultP0(), SingleLine->GetResultP1(), Line[waTopWall  ].FP0, Line[waTopWall].FP1  );
// 
// 								 //코너 연마폭, 연마량 계산 
// 								 double Dis =0.0f, AvgGrindWidth=0.0f, AvgGrindMea=0.0f, TotalGrindWidth=0.0f;
// 								 for(int k=0; k<C2EdgeCount; k++){
// 									 Dis = Math.GetLengthFrLineToPoint(FRTRPoint, FRTTPoint, C2InPoint[k]);
// 									 TotalGrindWidth+=Dis;
// 								 }
// 								 if(C2EdgeCount!=0){
// 									 AvgGrindWidth = (TotalGrindWidth/C2EdgeCount);
// 									 C2CorGrindWd  = AvgGrindWidth;
// 								 }
// 							 }
// 						 }
// 						 else {
// 							 RTDx = 0.0f;
// 							 RTDy = 0.0f;
// 							 //화면에 디스플레이 위해서 
// 							 FRTRPoint.x = FRTPoint.x;
// 							 FRTRPoint.y = FRTPoint.y;
// 							 FRTTPoint.x = FRTPoint.x;
// 							 FRTTPoint.y = FRTPoint.y;
// 						 }
					 }
                 }
                 if (FRightBottom) {
					 if(ECThresHold==0) {SingleLine->GImage = GImage; SingleLine->FThreshold =5 ;}
                     else               {
						 EasyImage::Threshold(GImage,&BinaryImg, ECThresHold);
						 SingleLine->GImage = &BinaryImg; SingleLine->FThreshold =10;
					 }

					 //CornerHeight = 45;
					 SingleLine->FIncrement =1;
					 SingleLine->SetFindLineId(0);

                     OrgPoint = Math.OnIntersect(Line[waRightWall].FP0, Line[waRightWall].FP1, Line[waBottomWall].FP0, Line[waBottomWall].FP1);
                     FRBPoint = OrgPoint;
//                      SingleLine->IRoi->SetOrgX  ((int)(OrgPoint.x-CornerWidth              ));
//                      SingleLine->IRoi->SetOrgY  ((int)(OrgPoint.y-CornerHeight+CornerMargin));
//                      SingleLine->IRoi->SetWidth (CornerWidth                                );
//                      SingleLine->IRoi->SetHeight(CornerHeight-(CornerMargin*2)              );
					 if(IsCornerBtm){
						 SingleLine->IRoi->SetOrgX  ((int)(OrgPoint.x-CornerWidth              ));
						 SingleLine->IRoi->SetOrgY  ((int)(OrgPoint.y-CornerHeight             ));
						 SingleLine->IRoi->SetWidth (CornerWidth+10                             );
						 SingleLine->IRoi->SetHeight(CornerHeight                               );

						 SingleLine->SetOrientation(orEast);
						 SingleLine->OnExecute();
						 Line[waRightBottom].FP0 = SingleLine->GetResultP0();
						 Line[waRightBottom].FP1 = SingleLine->GetResultP1();

						 int Count  = SingleLine->FEdgePointCount;  

						 // ORG 
						 FRBRPoint = Math.OnIntersect(SingleLine->GetResultP0(), SingleLine->GetResultP1(), Line[waRightWall].FP0, Line[waRightWall].FP1);
						 FRBBPoint = Math.OnIntersect(SingleLine->GetResultP0(), SingleLine->GetResultP1(), Line[waBottomWall].FP0, Line[waBottomWall].FP1);

						 // NEW 
						 if(fabs(RightBMLine[0].FP0.x - RightBMLine[0].FP1.x)>1){
							 RightBMLine[0].FP0.x = (RightBMLine[0].FP0.x + RightBMLine[0].FP1.x)/2.0f;
							 RightBMLine[0].FP1.x = (RightBMLine[0].FP0.x + RightBMLine[0].FP1.x)/2.0f;
						 }
						 MarkLine[2].FP0.x = RightBMLine[0].FP0.x + RightOffset;  MarkLine[2].FP0.y = RightBMLine[0].FP0.y          ;
						 MarkLine[2].FP1.x = RightBMLine[0].FP1.x + RightOffset;  MarkLine[2].FP1.y = RightBMLine[0].FP1.y          ;
						 MarkLine[3].FP0.x = BtmBMLine  [0].FP0.x              ;  MarkLine[3].FP0.y = BtmBMLine  [0].FP0.y+BtmOffset;
						 MarkLine[3].FP1.x = BtmBMLine  [0].FP1.x              ;  MarkLine[3].FP1.y = BtmBMLine  [0].FP1.y+BtmOffset;

						 MarkFRBRPoint  = Math.OnIntersect(SingleLine->GetResultP0(), SingleLine->GetResultP1(),MarkLine[2].FP0, MarkLine[2].FP1);
						 MarkFRBBPoint  = Math.OnIntersect(SingleLine->GetResultP0(), SingleLine->GetResultP1(),MarkLine[3].FP0, MarkLine[3].FP1);
						 MarkCrossPoint = Math.OnIntersect(MarkLine[2].FP0, MarkLine[2].FP1, MarkLine[3].FP0, MarkLine[3].FP1);

						 // 연마가 되지 않을 경우 
					     if((FRBRPoint.x==0 || FRBRPoint.y==0 || FRBBPoint.x==0 || FRBBPoint.y==0)  || (SingleLine->FEdgePointCount <25)){
							 RBDx = 0.0f;
							 RBDy = 0.0f;
							 //화면에 디스플레이 위해서 
							 FRBRPoint.x = FRBPoint.x;
							 FRBRPoint.y = FRBPoint.y;
							 FRBBPoint.x = FRBPoint.x;
							 FRBBPoint.y = FRBPoint.y;
						}
						else {
							 MarkRBDx = Math.GetLengthFrPointToPoint(MarkCrossPoint, MarkFRBBPoint);
							 MarkRBDy = Math.GetLengthFrPointToPoint(MarkCrossPoint, MarkFRBRPoint);

							 RBDx = MarkRBDx;
							 RBDy = MarkRBDy;

							 // New Corner 
							 if((SingleLine->FEdgePointCount) - (CornerMargin*2)>0){
								 if(C4Point!=NULL) delete[] C4Point;
								 C4Point  = new TFPoint [(SingleLine->FEdgePointCount) - (CornerMargin*2)];
								 C4EdgeCount = (SingleLine->FEdgePointCount) -(CornerMargin*2);

								 CornerCount =0;  
								 for(int k=CornerMargin; k<((SingleLine->FEdgePointCount)-CornerMargin); k++){
									 if(CornerCount>=MAX_DEFECT_POINT) break;
									 C4Point[CornerCount].x = SingleLine->FEdgePoint[k].x;
									 C4Point[CornerCount].y = SingleLine->FEdgePoint[k].y;
									 CornerCount++;
								 }
							 }
						}
					 }
					 else {
						 RBDx = 0.0f;
						 RBDy = 0.0f;
						 //화면에 디스플레이 위해서 
						 FRBRPoint.x = FRBPoint.x;
						 FRBRPoint.y = FRBPoint.y;
						 FRBBPoint.x = FRBPoint.x;
						 FRBBPoint.y = FRBPoint.y;
					 }
                 }
                 if (FLeftBottom) {
					 if(FCompanyMode==COM_KWON){
						 if(ECThresHold==0) {SingleLine->GImage = GImage; SingleLine->FThreshold =5 ;}
						 else               {
							 EasyImage::Threshold(GImage,&BinaryImg, ECThresHold);
							 SingleLine->GImage = &BinaryImg; SingleLine->FThreshold =10;
						 }

						 //CornerHeight = 45;
						 SingleLine->FIncrement =5   ;
						 SingleLine->SetFindLineId(0);

						 OrgPoint = Math.OnIntersect(Line[waLeftWall].FP0, Line[waLeftWall].FP1, Line[waBottomWall].FP0, Line[waBottomWall].FP1);
						 FLBPoint = OrgPoint;
						 //SingleLine->IRoi->SetOrgX  ((int) OrgPoint.x                           );
						 //SingleLine->IRoi->SetOrgY  ((int)(OrgPoint.y-CornerHeight+CornerMargin));
						 //SingleLine->IRoi->SetWidth (CornerWidth                                );
						 //SingleLine->IRoi->SetHeight(CornerHeight-(CornerMargin*2)              );

						 if(IsCornerBtm){
							 SingleLine->IRoi->SetOrgX  ((int) OrgPoint.x  - 10                     );
							 SingleLine->IRoi->SetOrgY  ((int)(OrgPoint.y-CornerHeight             ));
							 SingleLine->IRoi->SetWidth (CornerWidth                                );
							 SingleLine->IRoi->SetHeight(CornerHeight                               );

							 SingleLine->SetOrientation(orWest);
							 SingleLine->OnExecute();
							 Line[waLeftBottom].FP0 = SingleLine->GetResultP0();
							 Line[waLeftBottom].FP1 = SingleLine->GetResultP1();

							 int Count  = SingleLine->FEdgePointCount;  

							 // ORG 
							 FLBLPoint = Math.OnIntersect(SingleLine->GetResultP0(), SingleLine->GetResultP1(), Line[waLeftWall].FP0, Line[waLeftWall].FP1);
							 FLBBPoint = Math.OnIntersect(SingleLine->GetResultP0(), SingleLine->GetResultP1(), Line[waBottomWall].FP0, Line[waBottomWall].FP1);

							 // NEW 
							 if(fabs(LeftBMLine[0].FP0.x - LeftBMLine[0].FP1.x)>1){
								 LeftBMLine[0].FP0.x = (LeftBMLine[0].FP0.x + LeftBMLine[0].FP1.x)/2.0f;
								 LeftBMLine[0].FP1.x = (LeftBMLine[0].FP0.x + LeftBMLine[0].FP1.x)/2.0f;
							 }
							 MarkLine[0].FP0.x = LeftBMLine[0].FP0.x - LeftOffset;  MarkLine[0].FP0.y = LeftBMLine[0].FP0.y          ;
							 MarkLine[0].FP1.x = LeftBMLine[0].FP1.x - LeftOffset;  MarkLine[0].FP1.y = LeftBMLine[0].FP1.y          ;
							 MarkLine[3].FP0.x = BtmBMLine [0].FP0.x             ;  MarkLine[3].FP0.y = BtmBMLine [0].FP0.y+BtmOffset;
							 MarkLine[3].FP1.x = BtmBMLine [0].FP1.x             ;  MarkLine[3].FP1.y = BtmBMLine [0].FP1.y+BtmOffset;


							 MarkFLBLPoint  = Math.OnIntersect(SingleLine->GetResultP0(), SingleLine->GetResultP1(),MarkLine[0].FP0, MarkLine[0].FP1);
							 MarkFLBBPoint  = Math.OnIntersect(SingleLine->GetResultP0(), SingleLine->GetResultP1(),MarkLine[3].FP0, MarkLine[3].FP1);
							 MarkCrossPoint = Math.OnIntersect(MarkLine[0].FP0, MarkLine[0].FP1, MarkLine[3].FP0, MarkLine[3].FP1);

							 // 연마가 되지 않을 경우 
							 if(IsCornerBtm){
								 if((FLBLPoint.x==0 || FLBLPoint.y==0 || FLBBPoint.x==0 || FLBBPoint.y==0)  || (SingleLine->FEdgePointCount <25)){
									 LBDx = 0.0f;
									 LBDy = 0.0f;
									 //화면에 디스플레이 위해서 
									 FLBLPoint.x = FLBPoint.x;
									 FLBLPoint.y = FLBPoint.y;

									 FLBBPoint.x = FLBPoint.x;
									 FLBBPoint.y = FLBPoint.y;
								 }
								 else {
									 MarkLBDx = Math.GetLengthFrPointToPoint(MarkCrossPoint, MarkFLBBPoint);
									 MarkLBDy = Math.GetLengthFrPointToPoint(MarkCrossPoint, MarkFLBLPoint);

									 LBDx = MarkLBDx;
									 LBDy = MarkLBDy;

									 // New Corner 
									 if((SingleLine->FEdgePointCount) - (CornerMargin*2)>0){
										 if(C3Point!=NULL) delete[] C3Point;
										 C3Point  = new TFPoint [(SingleLine->FEdgePointCount) - (CornerMargin*2)];
										 C3EdgeCount = (SingleLine->FEdgePointCount) -(CornerMargin*2);

										 CornerCount =0;  
										 for(int k=CornerMargin; k<((SingleLine->FEdgePointCount)-CornerMargin); k++){
											 if(CornerCount>=MAX_DEFECT_POINT) break;
											 C3Point[CornerCount].x = SingleLine->FEdgePoint[k].x;
											 C3Point[CornerCount].y = SingleLine->FEdgePoint[k].y;
											 CornerCount++;
										 }
									 }
								 }
							 }
						 }
						 else {
							 LBDx = 0.0f;
							 LBDy = 0.0f;
							 //화면에 디스플레이 위해서 
							 FLBLPoint.x = FLBPoint.x;
							 FLBLPoint.y = FLBPoint.y;
							 FLBBPoint.x = FLBPoint.x;
							 FLBBPoint.y = FLBPoint.y;
						 }
					 }
					 else if(FCompanyMode==COM_BOE){  // LeftBtm LineSearch 
						 if(ECThresHold==0) {SingleLine->GImage = GImage; SingleLine->FThreshold =5 ;}
						 else               {
							 EasyImage::Threshold(GImage,&BinaryImg, ECThresHold);
							 SingleLine->GImage = &BinaryImg; SingleLine->FThreshold =10;
						 }

						 //CornerHeight = 45;
						 SingleLine->FIncrement =1;
						 SingleLine->SetFindLineId(0);

						 OrgPoint = Math.OnIntersect(Line[waLeftWall].FP0, Line[waLeftWall].FP1, Line[waBottomWall].FP0, Line[waBottomWall].FP1);
						 FLBPoint = OrgPoint;

						 //SingleLine->IRoi->SetOrgX  ((int) OrgPoint.x                           );
						 //SingleLine->IRoi->SetOrgY  ((int)(OrgPoint.y-CornerHeight+CornerMargin));
						 //SingleLine->IRoi->SetWidth (CornerWidth                                );
						 //SingleLine->IRoi->SetHeight(CornerHeight-(CornerMargin*2)              );

						 // 스팩값 기준 자동 ROI설정이 방식 
						 // 						 SingleLine->IRoi->SetOrgX  ((int) OrgPoint.x  - 10                     );
						 // 						 SingleLine->IRoi->SetOrgY  ((int)(OrgPoint.y-CornerHeight             ));
						 // 						 SingleLine->IRoi->SetWidth (CornerWidth                                );
						 // 						 SingleLine->IRoi->SetHeight(CornerHeight                               );

						 if(IsCornerBtm){
							 // 스팩값 기준 자동 ROI설정이 방식
							 CornerWidth  = Line[3].FP0.x - OrgPoint.x  ;
							 CornerHeight = OrgPoint.y    -Line[0].FP1.y; 
							 SingleLine->IRoi->SetOrgX  ((int)OrgPoint.x-10                );
							 SingleLine->IRoi->SetOrgY  ((int)OrgPoint.y -CornerHeight     );
							 SingleLine->IRoi->SetWidth ((int)CornerWidth                  );
							 SingleLine->IRoi->SetHeight((int)CornerHeight                 );

							 if((OrgPoint.x-10)<=0    || OrgPoint.y -CornerHeight<0     || CornerWidth<=0    || CornerHeight<=0   ) return false;
							 if((OrgPoint.x-10)>=ImgW || OrgPoint.y -CornerHeight>ImgH  || CornerWidth>=ImgW || CornerHeight>=ImgH) return false;

							 SingleLine->SetOrientation(orWest);
							 SingleLine->OnExecute();
							 // 						 Line[waLeftBottom].FP0 = SingleLine->GetResultP0();
							 // 						 Line[waLeftBottom].FP1 = SingleLine->GetResultP1();

							 Line[7].FP0 = SingleLine->GetResultP0();
							 Line[7].FP1 = SingleLine->GetResultP1();

							 int Count  = SingleLine->FEdgePointCount;  

							 // ORG 
							 FLBLPoint = Math.OnIntersect(SingleLine->GetResultP0(), SingleLine->GetResultP1(), Line[waLeftWall].FP0, Line[waLeftWall].FP1);
							 FLBBPoint = Math.OnIntersect(SingleLine->GetResultP0(), SingleLine->GetResultP1(), Line[waBottomWall].FP0, Line[waBottomWall].FP1);

							 // 연마가 되지 않을 경우 
							 if((FLBLPoint.x==0 || FLBLPoint.y==0 || FLBBPoint.x==0 || FLBBPoint.y==0)  || (SingleLine->FEdgePointCount <25)){
								 LBDx = 0.0f;
								 LBDy = 0.0f;
								 //화면에 디스플레이 위해서 
								 FLBLPoint.x = FLBPoint.x;
								 FLBLPoint.y = FLBPoint.y;

								 FLBBPoint.x = FLBPoint.x;
								 FLBBPoint.y = FLBPoint.y;
							}
							else {
								 LBDx = Math.GetLengthFrPointToPoint(FLBPoint, FLBBPoint);
								 LBDy = Math.GetLengthFrPointToPoint(FLBPoint, FLBLPoint);

								 // New Corner 
								 if((SingleLine->FEdgePointCount) - (CornerMargin*2)>0){
									 if(C3Point!=NULL) delete[] C3Point;
									 C3Point  = new TFPoint [(SingleLine->FEdgePointCount) - (CornerMargin*2)];
									 C3EdgeCount = (SingleLine->FEdgePointCount) -(CornerMargin*2);

									 CornerCount =0;  
									 for(int k=CornerMargin; k<((SingleLine->FEdgePointCount)-CornerMargin); k++){
										 if(CornerCount>=MAX_DEFECT_POINT) break;
										 C3Point[CornerCount].x = SingleLine->FEdgePoint[k].x;
										 C3Point[CornerCount].y = SingleLine->FEdgePoint[k].y;
										 CornerCount++;
									 }
								 }
							}
						 }
						 else {
							 LBDx = 0.0f;
							 LBDy = 0.0f;
							 //화면에 디스플레이 위해서 
							 FLBLPoint.x = FLBPoint.x;
							 FLBLPoint.y = FLBPoint.y;
							 FLBBPoint.x = FLBPoint.x;
							 FLBBPoint.y = FLBPoint.y;
						}
					 }
                 }

				 // 광원,온셀텍,솔브레인 외관검사시 셀 얼라인 불안정하여 셀이 틀어졌을경우 
				 // 검사 ROI영역을 틀어진 각도 기준으로 회전하여도 외곽라인 근처에 존재하는 패턴으로 인해서 오버킬 발생함 
				 // 이로 인해서 부득이하게 원본 이미지를 복사하여 틀어진 각도만큼 회전하여 기본 Edge데이터를 다시 산출 및 Defect검사시 
				 // 회전된 이미지기준으로 검사 진행함 
				 // 외관 검사 시퀀스중 광원,솔브레인,온셀텍과 NOTCH CELL검사 분류하여 진행해야함 
				 if(FShape==shRectH ){
					 if(FCompanyMode==COM_KWON){
						 if(FLTPoint.x!=0 && FLTPoint.y!=0 && FRTPoint.x!=0 && FRTPoint.y!=0) ImgDegree = -(Math.GetDegree(FLTPoint.x , FLTPoint.y, FRTPoint.x, FRTPoint.y));
						 if(ImgDegree!=0.0f){
							 // 원본 RotateImg Size 설정 및 복사 
							 RotateImg.SetSize(GImage->GetWidth(), GImage->GetHeight());
							 EasyImage::Oper(EArithmeticLogicOperation_Copy,GImage,&RotateImg);
							 // 						 GImage->Save("D:\\ROTATE_IMG\\GImage원본_HAP.bmp");
							 // 						 RotateImg.Save("D:\\ROTATE_IMG\\RotateImg원본_HAP.bmp");

							 // 원본 복사하여 이미지 회전 
							 EasyImage::ScaleRotate(GImage, (float)ImgW/2, (float)ImgH/2, (float)ImgW/2, (float)ImgH/2, 1.0f, 1.0f, ImgDegree, &RotateImg, 8);
							 CenterPoint.x = ImgW/2;
							 CenterPoint.y = ImgH/2;
							 // 						 EasyImage::ScaleRotate(GImage, (float)ImgW/2, (float)ImgH/2, (float)ImgW/2, (float)ImgH/2, 1.0f, 0.2f, ImgDegree, &RotateImg, 0);
							 // 						 EasyImage::ScaleRotate(GImage, (float)ImgW/2, (float)ImgH/2, (float)ImgW/2, (float)ImgH/2, 1.0f, 1.0f, ImgDegree, &RotateImg, 0);
							 // 						 RotateImg.Save("D:\\ROTATE_IMG\\RotateImg회전_HAP.bmp");

							 // Binary RotateImg Size 설정 및 복사 
							 RotateBinaryImg.SetSize(RotateImg.GetWidth(), RotateImg.GetHeight());
							 EasyImage::Oper(EArithmeticLogicOperation_Copy,&RotateImg,&RotateBinaryImg);
							 // 						 RotateBinaryImg.Save("D:\\ROTATE_IMG\\RotateBinaryImg회전_HAP.bmp");

							 if(FLeftWall){
								 EasyImage::Threshold(&RotateImg,&RotateBinaryImg, LeftEdgeThresHold);
								 if(LeftEdgeThresHold==0) {SingleLine->GImage = &RotateImg      ; SingleLine->FThreshold =5 ;}
								 else                     {SingleLine->GImage = &RotateBinaryImg; SingleLine->FThreshold =10;}

								 SingleLine->IRoi->SetOrgX  (IRoi->GetOrgX());
								 SingleLine->IRoi->SetOrgY  (IRoi->GetOrgY());
								 SingleLine->IRoi->SetWidth (IRoi->GetWidth());
								 SingleLine->IRoi->SetHeight(IRoi->GetHeight());

								 SingleLine->SetOrientation(orWest);

								 if(IRoi->GetHeight()<350) SingleLine->SetIncrement(5 );
								 else                      SingleLine->SetIncrement(10);
								 SingleLine->SetFindLineId(0);
								 //SingleLine->FThreshold =10;
								 SingleLine->OnExecute();
								 Line[0].FP0 = SingleLine->GetResultP0(); // 기본 외곽라인 찾는다 
								 Line[0].FP1 = SingleLine->GetResultP1(); // 기본 외곽라인 찾는다 
							 }
							 if(FTopWall ){
								 EasyImage::Threshold(&RotateImg,&RotateBinaryImg, TopEdgeThresHold);
								 if(TopEdgeThresHold==0)  {SingleLine->GImage = &RotateImg      ;   SingleLine->FThreshold =5 ;}
								 else                     {SingleLine->GImage = &RotateBinaryImg;   SingleLine->FThreshold =10;}

								 SingleLine->IRoi->SetOrgX  (IRoi->GetOrgX());
								 SingleLine->IRoi->SetOrgY  (IRoi->GetOrgY());
								 SingleLine->IRoi->SetWidth (IRoi->GetWidth());
								 SingleLine->IRoi->SetHeight(IRoi->GetHeight());
								 if(IRoi->GetOrgX()<=0 || IRoi->GetWidth()<=0 || IRoi->GetHeight()<=0) return false;

								 SingleLine->SetOrientation(orNorth);
								 SingleLine->FIncrement =10;
								 SingleLine->SetFindLineId(0);
								 SingleLine->FThreshold =5;
								 SingleLine->OnExecute();
								 Line[1].FP0 = SingleLine->GetResultP0();
								 Line[1].FP1 = SingleLine->GetResultP1();

								 if(TopOffset!=0){
									 TopBMLine[0].FP0.x = FP0.x;
									 TopBMLine[0].FP0.y = FP0.y;
									 TopBMLine[0].FP1.x = FP1.x;
									 TopBMLine[0].FP1.y = FP1.y;
								 }
							 }
							 if(FRightWall){
								 EasyImage::Threshold(&RotateImg,&RotateBinaryImg, RightEdgeThresHold);
								 if(RightEdgeThresHold==0)  {SingleLine->GImage = &RotateImg      ; SingleLine->FThreshold =5 ;}
								 else                       {SingleLine->GImage = &RotateBinaryImg; SingleLine->FThreshold =10;}

								 SingleLine->IRoi->SetOrgX  (IRoi->GetOrgX());
								 SingleLine->IRoi->SetOrgY  (IRoi->GetOrgY());
								 SingleLine->IRoi->SetWidth (IRoi->GetWidth());
								 SingleLine->IRoi->SetHeight(IRoi->GetHeight());

								 SingleLine->SetOrientation(orEast);
								 SingleLine->FIncrement =10;
								 SingleLine->SetFindLineId(0);
								 SingleLine->FThreshold =5;
								 SingleLine->OnExecute();
								 Line[waRightWall].FP0 = SingleLine->GetResultP0();
								 Line[waRightWall].FP1 = SingleLine->GetResultP1();
							 }
							 if(FLeftTop ){
								 if(ECThresHold==0) {SingleLine->GImage = &RotateImg; SingleLine->FThreshold =5 ;}
								 else               {
									 EasyImage::Threshold(&RotateImg,&RotateBinaryImg, ECThresHold);
									 SingleLine->GImage = &RotateBinaryImg; SingleLine->FThreshold =10;
								 }

								 OrgPoint = Math.OnIntersect(Line[waLeftWall].FP0, Line[waLeftWall].FP1, Line[waTopWall].FP0, Line[waTopWall].FP1);
								 FLTPoint = OrgPoint;
							 }
							 if(FRightTop){
								 if(ECThresHold==0) {SingleLine->GImage = &RotateImg; SingleLine->FThreshold =5 ;}
								 else               {
									 EasyImage::Threshold(&RotateImg,&RotateBinaryImg, ECThresHold);
									 SingleLine->GImage = &RotateBinaryImg; SingleLine->FThreshold =10;
								 }

								 OrgPoint = Math.OnIntersect(Line[waRightWall].FP0, Line[waRightWall].FP1, Line[waTopWall].FP0, Line[waTopWall].FP1);
								 FRTPoint = OrgPoint;
							 }
						 }
					 }
					 else if(FCompanyMode==COM_NOTCH){ // shRectH Image Rotate Sequence 
					      // Image Roate 전 원본이미지 기준 데이터 산출 
						 FLTPoint = Math.OnIntersect(Line[waLeftWall].FP0 , Line[waLeftWall].FP1 , Line[waTopWall].FP0, Line[waTopWall].FP1);
						 FRTPoint = Math.OnIntersect(Line[waRightWall].FP0, Line[waRightWall].FP1, Line[waTopWall].FP0, Line[waTopWall].FP1);

// 						 if(FLTPoint.x!=0 && FLTPoint.y!=0 && FRTPoint.x!=0 && FRTPoint.y!=0) ImgDegree = -(Math.GetDegree(FLTPoint.x , FLTPoint.y, FRTPoint.x, FRTPoint.y));
						 if(FP0.x!=0 && FP0.y!=0 && FP1.x!=0 && FP1.y!=0) ImgDegree = -(Math.GetDegree(FP0.x , FP0.y, FP1.x, FP1.y));

							// 원본 RotateImg Size 설정 및 복사 
// 						 LogUnit.SetLog("shRectH_RotateImg_Start");     
						 RotateImg.SetSize(GImage->GetWidth(), GImage->GetHeight());
						 EasyImage::Oper(EArithmeticLogicOperation_Copy,GImage,&RotateImg);
						 // 						 GImage->Save("D:\\ROTATE_IMG\\GImage원본_HAP.bmp");
						 
						 // 원본 복사하여 이미지 회전 
						 EasyImage::ScaleRotate(GImage, (float)ImgW/2, (float)ImgH/2, (float)ImgW/2, (float)ImgH/2, 1.0f, 1.0f, ImgDegree, &RotateImg, 4);
						 CenterPoint.x = ImgW/2;
						 CenterPoint.y = ImgH/2;
						 
// 						 EasyImage::ScaleRotate(GImage, (float)ImgW/2, (float)ImgH/2, (float)ImgW/2, (float)ImgH/2, 1.0f, 0.2f, ImgDegree, &RotateImg, 0);
// 						 EasyImage::ScaleRotate(GImage, (float)ImgW/2, (float)ImgH/2, (float)ImgW/2, (float)ImgH/2, 1.0f, 1.0f, ImgDegree, &RotateImg, 0);
// 						 	 GImage->Save   ("D:\\ROTATE_IMG\\GImage_HAP.bmp");
//						 RotateImg.Save("D:\\ROTATE_IMG\\RotateImg회전_HAP_원본.bmp");
						 
						 // Binary RotateImg Size 설정 및 복사 
						 RotateBinaryImg.SetSize(RotateImg.GetWidth(), RotateImg.GetHeight());
						 EasyImage::Oper(EArithmeticLogicOperation_Copy,&RotateImg,&RotateBinaryImg);
						 // Grind Measure Corner, Circle 검사 목적 
						 RotateGrindBinaryImg.SetSize(RotateImg.GetWidth(), RotateImg.GetHeight());
						 EasyImage::Oper(EArithmeticLogicOperation_Copy,&RotateImg,&RotateGrindBinaryImg);
/*						 LogUnit.SetLog("shRectH_RotateImg_End");     */

						 if(FLeftWall){
						     EasyImage::Threshold(&RotateImg,&RotateBinaryImg, LeftEdgeThresHold);
							 if(LeftEdgeThresHold==0) {SingleLine->GImage = &RotateImg      ; SingleLine->FThreshold =5 ;}
							 else                     {SingleLine->GImage = &RotateBinaryImg; SingleLine->FThreshold =10;}

							 if(IsCircleTop){
								 SingleLine->IRoi->SetOrgX  (IRoi->GetOrgX()  );
								 SingleLine->IRoi->SetOrgY  (ASideCircleHeight+50);
								 SingleLine->IRoi->SetWidth (IRoi->GetWidth() );
								 SingleLine->IRoi->SetHeight(ImgH-(ASideCircleHeight+50));
								 SingleLine->SetIncrement(1 );
							 }
							 else {
								 SingleLine->IRoi->SetOrgX  (IRoi->GetOrgX()  );
								 SingleLine->IRoi->SetOrgY  (IRoi->GetOrgY()  );
								 SingleLine->IRoi->SetWidth (IRoi->GetWidth() );
								 SingleLine->IRoi->SetHeight(IRoi->GetHeight());
								 SingleLine->SetIncrement(5 );
							 }
							 SingleLine->SetOrientation(orWest);

// 							 if(IRoi->GetHeight()<350) SingleLine->SetIncrement(1 );
// 							 else                      SingleLine->SetIncrement(5 );

							 SingleLine->SetFindLineId(0);
// 							 SingleLine->SetEdgeType(0);  // Black To White 
							 if(IsMarkBtm) SingleLine->SetEdgeType(0); // Black to White 
							 else          SingleLine->SetEdgeType(1); // White to Black  

							 SingleLine->OnExecute();
							 Line[0].FP0 = SingleLine->GetResultP0();
							 Line[0].FP1 = SingleLine->GetResultP1();

							 // Multi Round Test 
							 if((fabs(Line[0].FP0.x - Line[0].FP1.x)>2) && (Line[0].FP1.x <Line[0].FP0.x)) Line[0].FP0.x = Line[0].FP1.x;

							 // Btm,Top 상관없이 첫번째
							 // 비선형 아크영역으로 인해서 LeftLine 추가 조절해야함 
// 							 if(fabs(Line[0].FP0.x - Line[0].FP1.x)>2){
// 								 if(Line[0].FP0.x> Line[0].FP1.x) Line[0].FP0.x = Line[0].FP1.x;
// 								 if(Line[0].FP0.x< Line[0].FP1.x) Line[0].FP0.x = Line[0].FP1.x;
// 							 }
							 LeftOutLine[0].FP0.x = Line[0].FP0.x;
							 LeftOutLine[0].FP0.y = Line[0].FP0.y;
							 LeftOutLine[0].FP1.x = Line[0].FP1.x;
							 LeftOutLine[0].FP1.y = Line[0].FP1.y;

							 // LeftOutLine....make OutLine Data 
							 // 현재의 데이터를 넘겨준다 
							 // 검사중 기준라인을 찾지 못할경우 이전데이터 넘겨줘서 기준라인 생성함 
							 if(LeftOutLine[0].FP0.x!=0.0f && LeftOutLine[0].FP0.y!=0.0f && LeftOutLine[0].FP1.x!=0.0f && LeftOutLine[0].FP1.y!=0.0f){
								 PreLeftOutLine[0].FP0.x = LeftOutLine[0].FP0.x;    PreLeftOutLine[0].FP1.x = LeftOutLine[0].FP1.x;       
								 PreLeftOutLine[0].FP0.y = LeftOutLine[0].FP0.y;    PreLeftOutLine[0].FP1.y = LeftOutLine[0].FP1.y;       
							 } // 셀의 상단 시작부터 Broken 발생으로 데이터가 없는경우 
							 else if(LeftOutLine[0].FP0.x==0.0f || LeftOutLine[0].FP0.y==0.0f || LeftOutLine[0].FP1.x==0.0f || LeftOutLine[0].FP1.y==0.0f){
								 if(PreLeftOutLine[0].FP0.x==0.0f && PreLeftOutLine[0].FP0.y==0.0f && PreLeftOutLine[0].FP1.x==0.0f && PreLeftOutLine[0].FP1.y==0.0f){// 시작부분 Broken발생으로 데이터가 없는경우 
									 // Mark좌표를 기준으로 라인좌표값을 다시 설정함 
									 ROI_H = IRoi->GetHeight();
									 LeftOutLine[0].FP0.x = Line[0].FP0.x;    LeftOutLine[0].FP0.y = 0.0f        ;
									 LeftOutLine[0].FP1.x = Line[0].FP1.x;    LeftOutLine[0].FP1.y = (float)ROI_H;

									 //Line 데이터를 PreLine에 넘겨준다 
									 PreLeftOutLine[0].FP0.x = LeftOutLine[0].FP0.x;    PreLeftOutLine[0].FP1.x = LeftOutLine[0].FP1.x;       
									 PreLeftOutLine[0].FP0.y = LeftOutLine[0].FP0.y;    PreLeftOutLine[0].FP1.y = LeftOutLine[0].FP1.y;       
								 }
								 else { // 중간부분 Broken발생으로 데이터가 없는경우 
									 // PreLine 데이터를 넘겨줌 
									 LeftOutLine[0].FP0.x = PreLeftOutLine[0].FP0.x;  LeftOutLine[0].FP1.x = PreLeftOutLine[0].FP1.x;  
									 LeftOutLine[0].FP0.y = PreLeftOutLine[0].FP0.y;  LeftOutLine[0].FP1.y = PreLeftOutLine[0].FP1.y;  
								 }
							 }
						 }
						 if(FTopWall ){ // ImageRotate 
							 EasyImage::Threshold(&RotateImg,&RotateBinaryImg, TopEdgeThresHold);
							 if(TopEdgeThresHold==0)  {SingleLine->GImage = &RotateImg      ;  SingleLine->FThreshold = 5;}
							 else                     {SingleLine->GImage = &RotateBinaryImg;  SingleLine->FThreshold =10;}

							 SingleLine->IRoi->SetOrgX  (IRoi->GetOrgX()  );
							 SingleLine->IRoi->SetOrgY  (IRoi->GetOrgY()  );
							 SingleLine->IRoi->SetWidth (IRoi->GetWidth() );
							 SingleLine->IRoi->SetHeight(IRoi->GetHeight());

// 							 int OrgX = IRoi->GetOrgX()  ;
// 							 int OrgY = IRoi->GetOrgY()  ;
// 							 int OrgW = IRoi->GetWidth() ;
// 							 int OrgH = IRoi->GetHeight();

							 if(IRoi->GetOrgX()<=0 || IRoi->GetWidth()<=0 || IRoi->GetHeight()<=0){
								 return false;
							 }

							 SingleLine->SetOrientation(orNorth);
							 SingleLine->FIncrement =100;
							 SingleLine->SetFindLineId(0);
							 SingleLine->FThreshold =5;

							 if(FCutMode==Normal_Cut){
								 SingleLine->SetEdgeType(0);  // Black To White 
								 SingleLine->OnExecute();
								 Line[1].FP0 = SingleLine->GetResultP0();
								 Line[1].FP1 = SingleLine->GetResultP1();
							 }
							 if(FCutMode==CAI_Cut)    {
								 SingleLine->SetEdgeType(1);  // White To Black  
								 SingleLine->OnExecute();
								 Line[1].FP0 = SingleLine->GetResultP0();
								 Line[1].FP1 = SingleLine->GetResultP1();

								 // 연마 외곽라인 
								 TopOutLine[0].FP0 = SingleLine->GetResultP0();
								 TopOutLine[0].FP1 = SingleLine->GetResultP1();

								 // Image Rotate 후 빈공간에 데이터 생성됨 이로인해서 ROI양역 추가 설정해야함 
								 SingleLine->IRoi->SetOrgX  (TopOutLine[0].FP0.GetX()-10                             );
								 SingleLine->IRoi->SetOrgY  (TopOutLine[0].FP0.GetY()-10                             );
								 SingleLine->IRoi->SetWidth ((TopOutLine[0].FP1.GetX() - TopOutLine[0].FP0.GetX())+20);
								 SingleLine->IRoi->SetHeight(100                                                     );

								 if((TopOutLine[0].FP0.GetX()-10)<=0 ||((TopOutLine[0].FP1.GetX() - TopOutLine[0].FP0.GetX())+20)<=0 || (TopOutLine[0].FP0.GetY()-10)<=0){
									 return false;
								 }

								 SingleLine->SetEdgeType(0);  // Black To White  
								 SingleLine->OnExecute();

								 // 연마 안쪽라인 
								 TopInLine[0].FP0 = SingleLine->GetResultP0();
								 TopInLine[0].FP1 = SingleLine->GetResultP1();

								 // 연마폭 계산  
// 								 Top_Grind_Width = Math.GetLengthFrLineToPoint(TopOutLine[0].FP0 ,  TopOutLine[0].FP1, TopInLine[0].FP0);
// 								 Top_Grind_Mea   = 0.0f; // 가공량 측정 기준이 현재 없음(20180710)

								 // 최대 개수는 10까지...단, 현재 테스트 진행시 첫번째에 데이터 넘겨준다 
								 ASideGrindWd [0] = Math.GetLengthFrLineToPoint(TopOutLine[0].FP0 ,  TopOutLine[0].FP1, TopInLine[0].FP0);
								 ASideGrindMea[0] = 0.0f; // 가공량 측정 기준이 현재 없음(20180710)

							 }
						 }
						 if(FRightWall){
							 EasyImage::Threshold(&RotateImg,&RotateBinaryImg, RightEdgeThresHold);
							 if(LeftEdgeThresHold==0) {SingleLine->GImage = &RotateImg      ;  SingleLine->FThreshold =5 ;}
							 else                     {SingleLine->GImage = &RotateBinaryImg;  SingleLine->FThreshold =10;}

							 if(IsCircleTop){
								 SingleLine->IRoi->SetOrgX  (IRoi->GetOrgX()  );
								 SingleLine->IRoi->SetOrgY  (ASideCircleHeight+50);
								 SingleLine->IRoi->SetWidth (IRoi->GetWidth() );
								 SingleLine->IRoi->SetHeight(ImgH-(ASideCircleHeight+50));
								 SingleLine->SetIncrement(1 );
							 }
							 else {
								 SingleLine->IRoi->SetOrgX  (IRoi->GetOrgX()  );
								 SingleLine->IRoi->SetOrgY  (IRoi->GetOrgY()  );
								 SingleLine->IRoi->SetWidth (IRoi->GetWidth() );
								 SingleLine->IRoi->SetHeight(IRoi->GetHeight());
                                 SingleLine->SetIncrement(5 );
							 }

							 SingleLine->SetOrientation(orEast);
// 							 if(IRoi->GetHeight()<350) SingleLine->SetIncrement(1 );
// 							 else                      SingleLine->SetIncrement(5 );
							 SingleLine->SetFindLineId(0);
							 SingleLine->FThreshold =10;

							 if(IsMarkBtm) SingleLine->SetEdgeType(0); // Black to White 
							 else          SingleLine->SetEdgeType(1); // White to Black  

							 SingleLine->OnExecute();
							 Line[2].FP0 = SingleLine->GetResultP0();
							 Line[2].FP1 = SingleLine->GetResultP1();

							 // Multi Round Test 
							 if((fabs(Line[2].FP0.x - Line[2].FP1.x)>2) && (Line[2].FP1.x >Line[2].FP0.x)) Line[2].FP0.x = Line[2].FP1.x;

							 // Btm,Top 상관없이 첫번째
							 // 비선형 아크영역으로 인해서 LeftLine 추가 조절해야함 
// 							 if(fabs(Line[2].FP0.x - Line[2].FP1.x)>2){
// 								 if(Line[2].FP0.x> Line[2].FP1.x) Line[2].FP1.x = Line[2].FP0.x;
// 								 if(Line[2].FP0.x< Line[2].FP1.x) Line[2].FP0.x = Line[2].FP1.x;
// 							 }

							 RightOutLine[0].FP0.x = Line[2].FP0.x;
							 RightOutLine[0].FP0.y = Line[2].FP0.y;
							 RightOutLine[0].FP1.x = Line[2].FP1.x;
							 RightOutLine[0].FP1.y = Line[2].FP1.y;

							 // LeftOutLine....make OutLine Data 
							 // 현재의 데이터를 넘겨준다 
							 // 검사중 기준라인을 찾지 못할경우 이전데이터 넘겨줘서 기준라인 생성함 
							 if(RightOutLine[0].FP0.x!=0.0f && RightOutLine[0].FP0.y!=0.0f && RightOutLine[0].FP1.x!=0.0f && RightOutLine[0].FP1.y!=0.0f){
								 PreRightOutLine[0].FP0.x = RightOutLine[0].FP0.x;    PreRightOutLine[0].FP1.x = RightOutLine[0].FP1.x;       
								 PreRightOutLine[0].FP0.y = RightOutLine[0].FP0.y;    PreRightOutLine[0].FP1.y = RightOutLine[0].FP1.y;       
							 } // 셀의 상단 시작부터 Broken 발생으로 데이터가 없는경우 
							 else if(RightOutLine[0].FP0.x==0.0f || RightOutLine[0].FP0.y==0.0f || RightOutLine[0].FP1.x==0.0f || RightOutLine[0].FP1.y==0.0f){
								 if(PreRightOutLine[0].FP0.x==0.0f && PreRightOutLine[0].FP0.y==0.0f && PreRightOutLine[0].FP1.x==0.0f && PreRightOutLine[0].FP1.y==0.0f){// 시작부분 Broken발생으로 데이터가 없는경우 
									 // Mark좌표를 기준으로 라인좌표값을 다시 설정함 
									 ROI_H = IRoi->GetHeight();
									 RightOutLine[0].FP0.x = Line[2].FP0.x;    RightOutLine[0].FP0.y = 0.0f        ;
									 RightOutLine[0].FP1.x = Line[2].FP1.x;    RightOutLine[0].FP1.y = (float)ROI_H;

									 //Line 데이터를 PreLine에 넘겨준다 
									 PreRightOutLine[0].FP0.x = RightOutLine[0].FP0.x;    PreRightOutLine[0].FP1.x = RightOutLine[0].FP1.x;       
									 PreRightOutLine[0].FP0.y = RightOutLine[0].FP0.y;    PreRightOutLine[0].FP1.y = RightOutLine[0].FP1.y;       
								 }
								 else { // 중간부분 Broken발생으로 데이터가 없는경우 
									 // PreLine 데이터를 넘겨줌 
									 RightOutLine[0].FP0.x = PreRightOutLine[0].FP0.x;  RightOutLine[0].FP1.x = PreRightOutLine[0].FP1.x;  
									 RightOutLine[0].FP0.y = PreRightOutLine[0].FP0.y;  RightOutLine[0].FP1.y = PreRightOutLine[0].FP1.y;  
								 }
							 }
						 }
						 // Org Image Rotate 후 교차점 다시 계산 
						 FLTPoint = Math.OnIntersect(Line[waLeftWall ].FP0, Line[waLeftWall ].FP1, Line[waTopWall].FP0, Line[waTopWall].FP1);
						 FRTPoint = Math.OnIntersect(Line[waRightWall].FP0, Line[waRightWall].FP1, Line[waTopWall].FP0, Line[waTopWall].FP1);

						 if(FLeftTop){ // Notch 교차점은 무조건 찾는다 
// 						     LogUnit.SetLog("shRectH_Rotate_LeftTop_Start");     
							 EasyImage::Threshold(&RotateImg,&RotateBinaryImg, ECThresHold);
							 EasyImage::Threshold(&RotateImg,&RotateGrindBinaryImg, CorGrindMeaThresHold);
// 							 RotateGrindBinaryImg.Save("D:\\ROTATE_IMG\\RotateImg회전_HAP_CorGrind.bmp");

							 if(ECThresHold==0)  {SingleLine->GImage = &RotateImg      ;  SingleLine->FThreshold =5 ;}
							 else                {SingleLine->GImage = &RotateBinaryImg;  SingleLine->FThreshold =10;}

							 OrgPoint = Math.OnIntersect(Line[waLeftWall].FP0, Line[waLeftWall].FP1, Line[waTopWall].FP0, Line[waTopWall].FP1);
							 FLTPoint = OrgPoint;

							 // Left Mark To TopSide Height 
							 if(IsMarkBtm){
								 if(FP0.x!=0.0f && FP0.y!=0.0f && Line[1].FP0.x!=0.0f && Line[1].FP0.y!=0.0f && Line[1].FP1.x!=0.0f && Line[1].FP1.y!=0.0f ) {
									 FP0 = Math.OnRotate(CenterPoint,FP0, -ImgDegree);
									 LeftMarkToTopHeight = GetLengthFrLineToPoint(Line[1].FP0, Line[1].FP1, FP0);
									 // 								 LeftMarkToTopHeight = FP0.y - Line[1].FP0.y;
								 }
								 // Right Mark To TopSide Height 
								 if(FP1.x!=0.0f && FP1.y!=0.0f && Line[1].FP0.x!=0.0f && Line[1].FP0.y!=0.0f && Line[1].FP1.x!=0.0f && Line[1].FP1.y!=0.0f ) {
									 FP1 = Math.OnRotate(CenterPoint,FP1, -ImgDegree);
									 RightMarkToTopHeight = GetLengthFrLineToPoint(Line[1].FP0, Line[1].FP1, FP1);
									 // 								 RightMarkToTopHeight = FP1.y - Line[1].FP1.y;
								 }
								 // Center Mark To TopSide Height
								 if(LeftMarkToTopHeight!=0.0f && RightMarkToTopHeight!=0.0f){
									 CenMarkToTopHeight = ((FP0.y+FP1.y)/2.0) - ((Line[1].FP0.y+Line[1].FP1.y)/2.0);
								 }
							 }

							 if(IsCornerTop){ //코너 연마량 설정되어 있을경우 코너 검사진행함(Dx,Dy,R,GW,GM 측정함)
								 if(AMarkToGrindMarkDvX==0.0f && AMarkToGrindMarkDvY==0.0f){ // 3Point 기준으로 가공량 측정 방법 적용 시퀀스 
									 // Corner 연마 외곽라인 
									 SingleLine->IRoi->SetOrgX  ((int)OrgPoint.x-10    );
									 SingleLine->IRoi->SetOrgY  ((int)OrgPoint.y       );
									 SingleLine->IRoi->SetWidth ((int)LTCornerWidth+20 );
									 SingleLine->IRoi->SetHeight((int)LTCornerHeight   );

									 // 								 SingleLine->SetOrientation(orNorth);
									 SingleLine->SetOrientation(orWest);
									 SingleLine->FIncrement =1;
									 SingleLine->FThreshold =15;
									 SingleLine->SetFindLineId(0);
									 SingleLine->SetEdgeType(1);  //White To Black 
									 SingleLine->OnExecute();
									 // 									Line[waLeftTop].FP0 = SingleLine->GetResultP0();
									 // 									Line[waLeftTop].FP1 = SingleLine->GetResultP1();
									 Line[4].FP0 = SingleLine->GetResultP0();
									 Line[4].FP1 = SingleLine->GetResultP1();

									 // ORG 교차점 
									 FLTLPoint = Math.OnIntersect(SingleLine->GetResultP0(), SingleLine->GetResultP1(), Line[waLeftWall].FP0, Line[waLeftWall].FP1);
									 FLTTPoint = Math.OnIntersect(SingleLine->GetResultP0(), SingleLine->GetResultP1(), Line[waTopWall ].FP0, Line[waTopWall ].FP1);

									 if((FLTLPoint.x==0 || FLTLPoint.y==0 || FLTTPoint.x==0 || FLTTPoint.y==0) || (SingleLine->FEdgePointCount <30)){
										 LTDx = 0.0f;
										 LTDy = 0.0f;
										 //화면에 디스플레이 위해서 
										 FLTLPoint.x = FLTPoint.x;
										 FLTLPoint.y = FLTPoint.y;
										 FLTTPoint.x = FLTPoint.x;
										 FLTTPoint.y = FLTPoint.y;
									 }
									 else { 
										 LTDx = Math.GetLengthFrPointToPoint(FLTPoint, FLTTPoint);
										 LTDy = Math.GetLengthFrPointToPoint(FLTPoint, FLTLPoint);

										 // OutLine C1Corner Data 
										 if((SingleLine->FEdgePointCount) - (CornerMargin*2)>0){
											 if(C1Point!=NULL) delete[] C1Point;
											 C1Point  = new TFPoint [(SingleLine->FEdgePointCount) - (CornerMargin*2)];
											 C1EdgeCount = (SingleLine->FEdgePointCount) -(CornerMargin*2);

											 CornerCount =0;  
											 for(int k=CornerMargin; k<((SingleLine->FEdgePointCount)-CornerMargin); k++){
												 if(CornerCount>=MAX_CORNER_POINT) break;
												 C1Point[CornerCount].x = SingleLine->FEdgePoint[k].x;
												 C1Point[CornerCount].y = SingleLine->FEdgePoint[k].y;
												 CornerCount++;
											 }
										 }

										 double Dis =0.0f, AvgGrindWidth=0.0f, AvgGrindMea=0.0f, TotalGrindWidth=0.0f, TotalGrindMeasure=0.0f;
										 // Corner Grind In Gray Level 편차로 인해서 Corner Grind Out/In ThresHold값을 분류하다 
										 // Corner Grind In Start 
										 if(CorGrindInThresHold!=0){ // Corner InLine Search Sequence 
											 EasyImage::Threshold(&RotateImg,&RotateBinaryImg, CorGrindInThresHold);
											 SingleLine->GImage = &RotateBinaryImg;  SingleLine->FThreshold =10;

											 // Corner 기울기 완만하여 Edge찾을 경우 Defect 오버킬 발생함 
											 // 방향을 Top방향에서 다시 엣지를 찾음 (Corner Defect OverKill 감소 목적)
											 // if(LTCornerWidth >(LTCornerHeight*3)){
											 if(LTCornerWidth >(LTCornerHeight*1.5)){
												 SingleLine->IRoi->SetOrgX  ((int)FLTPoint.x );
												 SingleLine->IRoi->SetOrgY  ((int)FLTPoint.y );
												 SingleLine->IRoi->SetWidth ((int)((FLTTPoint.x - FLTLPoint.x+5 )));
												 SingleLine->IRoi->SetHeight((int)((FLTLPoint.y - FLTTPoint.y+10)));

												 if(FLTPoint.x<=0    || FLTPoint.y<=0    || (FLTTPoint.x - FLTLPoint.x)<=0    || (FLTLPoint.y - FLTTPoint.y)<=0   ) return false;
												 if(FLTPoint.x>=ImgW || FLTPoint.y>=ImgH || (FLTTPoint.x - FLTLPoint.x)>=ImgW || (FLTLPoint.y - FLTTPoint.y)>=ImgH) return false;

												 SingleLine->SetOrientation(orNorth);
												 SingleLine->FIncrement =2;
												 SingleLine->SetFindLineId(0);
												 SingleLine->SetEdgeType(0);  //Black To White 
												 SingleLine->OnExecute();

												 // InLine C1Corner Data 
												 if((SingleLine->FEdgePointCount) - (CornerMargin*2)>0){
													 if(C1InPoint!=NULL) delete[] C1InPoint;
													 C1InPoint  = new TFPoint [(SingleLine->FEdgePointCount) - (CornerMargin*2)];
													 C1InEdgeCount = (SingleLine->FEdgePointCount) -(CornerMargin*2);

													 CornerCount =0;  
													 for(int k=CornerMargin; k<((SingleLine->FEdgePointCount)-CornerMargin); k++){
														 if(CornerCount>=MAX_CORNER_POINT) break;
														 C1InPoint[CornerCount].x = SingleLine->FEdgePoint[k].x;
														 C1InPoint[CornerCount].y = SingleLine->FEdgePoint[k].y;
														 CornerCount++;
													 }
												 }
											 }
											 else {
												 // Corner 연마 안쪽라인 찾는다 
												 SingleLine->SetOrientation(orWest);
												 SingleLine->SetFindLineId(0);
												 SingleLine->FIncrement =1;
												 SingleLine->SetEdgeType(0);  //Black To White 
												 SingleLine->OnExecute();

												 // InLine C1Corner Data 
												 if((SingleLine->FEdgePointCount) - (CornerMargin*2)>0){
													 if(C1InPoint!=NULL) delete[] C1InPoint;
													 C1InPoint  = new TFPoint [(SingleLine->FEdgePointCount) - (CornerMargin*2)];
													 C1InEdgeCount = (SingleLine->FEdgePointCount) -(CornerMargin*2);

													 CornerCount =0;  
													 for(int k=CornerMargin; k<((SingleLine->FEdgePointCount)-CornerMargin); k++){
														 if(CornerCount>=MAX_CORNER_POINT) break;
														 C1InPoint[CornerCount].x = SingleLine->FEdgePoint[k].x;
														 C1InPoint[CornerCount].y = SingleLine->FEdgePoint[k].y;
														 CornerCount++;
													 }
												 }
											 }

											 //코너 연마안쪽라인 기준 새로운 교차점 생성 
											 FLTLInPoint = Math.OnIntersect(SingleLine->GetResultP0(), SingleLine->GetResultP1(), Line[waLeftWall].FP0, Line[waLeftWall].FP1);
											 FLTTInPoint = Math.OnIntersect(SingleLine->GetResultP0(), SingleLine->GetResultP1(), Line[waTopWall ].FP0, Line[waTopWall ].FP1);

											 //코너 연마폭 
											 Dis =0.0f, AvgGrindWidth=0.0f, AvgGrindMea=0.0f, TotalGrindWidth=0.0f, TotalGrindMeasure=0.0f;
											 for(int k=0; k<C1InEdgeCount; k++){
												 Dis = Math.GetLengthFrLineToPoint(FLTLPoint, FLTTPoint, C1InPoint[k]);
												 TotalGrindWidth+=Dis;
											 }
											 if(C1InEdgeCount!=0){
												 AvgGrindWidth = (TotalGrindWidth/C1InEdgeCount);
												 C1CorGrindWd  = AvgGrindWidth;
											 }
										 }
										 // Corner Grind In End 

										 if(CorGrindMeaThresHold!=0){ // Corner Grind ThresHold값이 설정되어 있을경우만 연마량 검사를 진행한다 
											 // 코너 연마량 기준 라인을 찾는다 
											 // ROI 영역 설정(3개의 흰색 점선 기준 라인을 찾는다)
											 if(CorGrindMeaThresHold==0){SingleLine->GImage = &RotateImg           ;  SingleLine->FThreshold =5 ;}
											 else                       {SingleLine->GImage = &RotateGrindBinaryImg;  SingleLine->FThreshold =10;}

											 // 존나 찝찝함....일단 스팩을 받기전까지 임시로 영역을 분류하여 CornerEdgePoint 찾자 
											 if(LTCornerWidth >(LTCornerHeight*1.5)){
												 SingleLine->IRoi->SetOrgX  ((int)OrgPoint.x       );
												 SingleLine->IRoi->SetOrgY  ((int)OrgPoint.y+30    );
												 SingleLine->IRoi->SetWidth (LTCornerWidth -50     );
												 SingleLine->IRoi->SetHeight((int)LTCornerHeight-40);

												 SingleLine->SetOrientation(orNorth);
												 SingleLine->SetFindLineId(0);
												 SingleLine->FIncrement =1;
												 SingleLine->SetEdgeType(0);  //Black To White 
												 SingleLine->OnExecute();

												 // C1Corner Grind Measure Stand Data 
												 if((SingleLine->FEdgePointCount)>0){
													 if(C1MeaPoint!=NULL) delete[] C1MeaPoint;
													 C1MeaPoint     = new TFPoint [(SingleLine->FEdgePointCount)];
													 C1MeaEdgeCount = (SingleLine->FEdgePointCount);

													 CornerCount =0;  
													 for(int k=0; k<(SingleLine->FEdgePointCount); k++){
														 if(CornerCount>=MAX_CORNER_POINT) break;
														 if(k==0               ) P1 = SingleLine->FEdgePoint[k];
														 if(k==C1MeaEdgeCount-1) P2 = SingleLine->FEdgePoint[k];
														 C1MeaPoint[CornerCount].x = SingleLine->FEdgePoint[k].x;
														 C1MeaPoint[CornerCount].y = SingleLine->FEdgePoint[k].y;
														 CornerCount++;
													 }
												 }

												 FLTLMeaPoint = Math.OnIntersect(P1, P2, Line[waLeftWall].FP0, Line[waLeftWall].FP1);
												 FLTTMeaPoint = Math.OnIntersect(P1, P2, Line[waTopWall ].FP0, Line[waTopWall ].FP1);


												 //코너 연마량 계산  
												 Dis =0.0f, AvgGrindMea=0.0f, TotalGrindMeasure=0.0f;
												 for(int k=0; k<C1EdgeCount; k++){
													 Dis = Math.GetLengthFrLineToPoint(FLTLMeaPoint, FLTTMeaPoint, C1Point[k]);
													 TotalGrindMeasure+=Dis;
												 }
												 if(C1EdgeCount!=0){
													 AvgGrindMea    = (TotalGrindMeasure/C1EdgeCount);
													 C1CorGrindMea  = AvgGrindMea;
												 }
											 }
											 else {
												 SingleLine->IRoi->SetOrgX  ((int)OrgPoint.x+15    );
												 SingleLine->IRoi->SetOrgY  ((int)OrgPoint.y+15    );
												 SingleLine->IRoi->SetWidth ((int)LTCornerWidth    );
												 SingleLine->IRoi->SetHeight((int)LTCornerHeight   );

												 SingleLine->SetOrientation(orWest);
												 SingleLine->SetFindLineId(0);
												 SingleLine->FIncrement =1;
												 SingleLine->SetEdgeType(0);  //Black To White 
												 SingleLine->OnExecute();

												 P1 = SingleLine->GetResultP0();
												 P2 = SingleLine->GetResultP1();

												 //코너 연마량 기준 라인과 새로운 교차점 생성 
												 FLTLMeaPoint = Math.OnIntersect(SingleLine->GetResultP0(), SingleLine->GetResultP1(), Line[waLeftWall].FP0, Line[waLeftWall].FP1);
												 FLTTMeaPoint = Math.OnIntersect(SingleLine->GetResultP0(), SingleLine->GetResultP1(), Line[waTopWall ].FP0, Line[waTopWall ].FP1);

												 // C1Corner Grind Measure Stand Data 
												 if((SingleLine->FEdgePointCount)>0){
													 if(C1MeaPoint!=NULL) delete[] C1MeaPoint;
													 C1MeaPoint     = new TFPoint [(SingleLine->FEdgePointCount)];
													 C1MeaEdgeCount = (SingleLine->FEdgePointCount);

													 CornerCount =0;  
													 for(int k=0; k<(SingleLine->FEdgePointCount); k++){
														 if(CornerCount>=MAX_CORNER_POINT) break;
														 C1MeaPoint[CornerCount].x = SingleLine->FEdgePoint[k].x;
														 C1MeaPoint[CornerCount].y = SingleLine->FEdgePoint[k].y;
														 CornerCount++;
													 }
												 }
												 //코너 연마량 계산  
												 Dis =0.0f, AvgGrindMea=0.0f, TotalGrindMeasure=0.0f;
												 for(int k=0; k<C1EdgeCount; k++){
													 Dis = Math.GetLengthFrLineToPoint(FLTLMeaPoint, FLTTMeaPoint, C1Point[k]);
													 TotalGrindMeasure+=Dis;
												 }
												 if(C1EdgeCount!=0){
													 AvgGrindMea    = (TotalGrindMeasure/C1EdgeCount);
													 C1CorGrindMea  = AvgGrindMea;
												 }
											 }
										 }
									 }		
								 }
								 else { // 십자가 마크 기준 연마량,가공량 측정 시퀀스 
									 TFPoint C1GrindRectPoint(0.0f, 0.0f);
									 // Corner 연마 외곽라인 
									 SingleLine->IRoi->SetOrgX  ((int)OrgPoint.x-10    );
									 SingleLine->IRoi->SetOrgY  ((int)OrgPoint.y       );
									 SingleLine->IRoi->SetWidth ((int)LTCornerWidth+20 );
									 SingleLine->IRoi->SetHeight((int)LTCornerHeight   );

									 SingleLine->SetOrientation(orWest);
									 SingleLine->FIncrement =1;
									 SingleLine->FThreshold =15;
									 SingleLine->SetFindLineId(0);
									 SingleLine->SetEdgeType(1);  //White To Black 
									 SingleLine->OnExecute();

									 Line[4].FP0 = SingleLine->GetResultP0();
									 Line[4].FP1 = SingleLine->GetResultP1();

									 // ORG 교차점 
									 FLTLPoint = Math.OnIntersect(SingleLine->GetResultP0(), SingleLine->GetResultP1(), Line[waLeftWall].FP0, Line[waLeftWall].FP1);
									 FLTTPoint = Math.OnIntersect(SingleLine->GetResultP0(), SingleLine->GetResultP1(), Line[waTopWall ].FP0, Line[waTopWall ].FP1);

									 if((FLTLPoint.x==0 || FLTLPoint.y==0 || FLTTPoint.x==0 || FLTTPoint.y==0) || (SingleLine->FEdgePointCount <30)){
										 LTDx = 0.0f;
										 LTDy = 0.0f;
										 //화면에 디스플레이 위해서 
										 FLTLPoint.x = FLTPoint.x;
										 FLTLPoint.y = FLTPoint.y;
										 FLTTPoint.x = FLTPoint.x;
										 FLTTPoint.y = FLTPoint.y;
									 }
									 else { 
										 LTDx = Math.GetLengthFrPointToPoint(FLTPoint, FLTTPoint);
										 LTDy = Math.GetLengthFrPointToPoint(FLTPoint, FLTLPoint);

										 // OutLine C1Corner Data 
										 if((SingleLine->FEdgePointCount) - (CornerMargin*2)>0){
											 if(C1Point!=NULL) {
												 delete[] C1Point;
											 }
											 C1Point  = new TFPoint [(SingleLine->FEdgePointCount) - (CornerMargin*2)];
											 C1EdgeCount = (SingleLine->FEdgePointCount) -(CornerMargin*2);

											 CornerCount =0;  
											 for(int k=CornerMargin; k<((SingleLine->FEdgePointCount)-CornerMargin); k++){
												 if(CornerCount>=MAX_CORNER_POINT) break;
												 C1Point[CornerCount].x = SingleLine->FEdgePoint[k].x;
												 C1Point[CornerCount].y = SingleLine->FEdgePoint[k].y;
												 CornerCount++;
											 }
										 }

										 double Dis =0.0f, AvgGrindWidth=0.0f, AvgGrindMea=0.0f, TotalGrindWidth=0.0f, TotalGrindMeasure=0.0f;
										 // Corner Grind In Gray Level 편차로 인해서 Corner Grind Out/In ThresHold값을 분류하다 
										 // Corner Grind In Start 
										 if(CorGrindInThresHold!=0){ // Corner InLine Search Sequence 
											 EasyImage::Threshold(&RotateImg,&RotateBinaryImg, CorGrindInThresHold);
											 SingleLine->GImage = &RotateBinaryImg;  SingleLine->FThreshold =10;

											 // Corner 기울기 완만하여 Edge찾을 경우 Defect 오버킬 발생함 
											 // 방향을 Top방향에서 다시 엣지를 찾음 (Corner Defect OverKill 감소 목적)
											 // if(LTCornerWidth >(LTCornerHeight*3)){
											 if(LTCornerWidth >(LTCornerHeight*1.5)){
												 SingleLine->IRoi->SetOrgX  ((int)FLTPoint.x );
												 SingleLine->IRoi->SetOrgY  ((int)FLTPoint.y );
												 SingleLine->IRoi->SetWidth ((int)((FLTTPoint.x - FLTLPoint.x+5 )));
												 SingleLine->IRoi->SetHeight((int)((FLTLPoint.y - FLTTPoint.y+10)));

												 if(FLTPoint.x<=0    || FLTPoint.y<=0    || (FLTTPoint.x - FLTLPoint.x)<=0    || (FLTLPoint.y - FLTTPoint.y)<=0   ) return false;
												 if(FLTPoint.x>=ImgW || FLTPoint.y>=ImgH || (FLTTPoint.x - FLTLPoint.x)>=ImgW || (FLTLPoint.y - FLTTPoint.y)>=ImgH) return false;

												 SingleLine->SetOrientation(orNorth);
												 SingleLine->FIncrement =2;
												 SingleLine->SetFindLineId(0);
												 SingleLine->SetEdgeType(0);  //Black To White 
												 SingleLine->OnExecute();

												 // InLine C1Corner Data 
												 if((SingleLine->FEdgePointCount) - (CornerMargin*2)>0){
													 if(C1InPoint!=NULL) delete[] C1InPoint;
													 C1InPoint  = new TFPoint [(SingleLine->FEdgePointCount) - (CornerMargin*2)];
													 C1InEdgeCount = (SingleLine->FEdgePointCount) -(CornerMargin*2);

													 CornerCount =0;  
													 for(int k=CornerMargin; k<((SingleLine->FEdgePointCount)-CornerMargin); k++){
														 if(CornerCount>=MAX_CORNER_POINT) break;
														 C1InPoint[CornerCount].x = SingleLine->FEdgePoint[k].x;
														 C1InPoint[CornerCount].y = SingleLine->FEdgePoint[k].y;
														 CornerCount++;
													 }
												 }
											 }
											 else {
												 // Corner 연마 안쪽라인 찾는다 
												 SingleLine->SetOrientation(orWest);
												 SingleLine->SetFindLineId(0);
												 SingleLine->FIncrement =1;
												 SingleLine->SetEdgeType(0);  //Black To White 
												 SingleLine->OnExecute();

												 // InLine C1Corner Data 
												 if((SingleLine->FEdgePointCount) - (CornerMargin*2)>0){
													 if(C1InPoint!=NULL){
														 delete[] C1InPoint;
													 }
													 C1InPoint  = new TFPoint [(SingleLine->FEdgePointCount) - (CornerMargin*2)];
													 C1InEdgeCount = (SingleLine->FEdgePointCount) -(CornerMargin*2);

													 CornerCount =0;  
													 for(int k=CornerMargin; k<((SingleLine->FEdgePointCount)-CornerMargin); k++){
														 if(CornerCount>=MAX_CORNER_POINT) break;
														 C1InPoint[CornerCount].x = SingleLine->FEdgePoint[k].x;
														 C1InPoint[CornerCount].y = SingleLine->FEdgePoint[k].y;
														 CornerCount++;
													 }
												 }
											 }

											 //코너 연마안쪽라인 기준 새로운 교차점 생성 
											 FLTLInPoint = Math.OnIntersect(SingleLine->GetResultP0(), SingleLine->GetResultP1(), Line[waLeftWall].FP0, Line[waLeftWall].FP1);
											 FLTTInPoint = Math.OnIntersect(SingleLine->GetResultP0(), SingleLine->GetResultP1(), Line[waTopWall ].FP0, Line[waTopWall ].FP1);
										 }

										 // GrindMark기준 연마량,가공량 측정함 
										 // LeftTop Corner Mark Find 
										 if(FP0.x!=0.0f && FP0.y!=0.0f){
											 GrindMarkRect[25].left   = (FP0.x-AMarkToGrindMarkDvX)-40;
											 GrindMarkRect[25].top    = (FP0.y+AMarkToGrindMarkDvY)-40;
											 GrindMarkRect[25].right  = (GrindMarkRect[25].left + 80);
											 GrindMarkRect[25].bottom = (GrindMarkRect[25].top  + 80);

											 GrindRectWidth  = (GrindMarkRect[25].right  - GrindMarkRect[25].left);
											 GrindRectHeight = (GrindMarkRect[25].bottom - GrindMarkRect[25].top );

											 // 원본이미지에서 Mark 찾는다 
											 Find->OnLoad(true,FindDir,1)                   ;
											 Find->GImage = &RotateImg                      ;
											 //Find->SetContrastMode(EFindContrastMode_Any)   ;
											 Find->SetContrastMode(EFindContrastMode_Normal);
											 //Find->SetMinScore(0.8f)                        ;
											 Find->SetMinScore (GrindPadMarkMinScore)       ; // PatternrFind 검사 최소 Score
											 Find->SetZeroScore(GrindPadMarkMinScore)       ; // 검사 후 최소 Score 
											 //ind->SetMinScore (0.75)                       ; // PatternrFind 검사 최소 Score
											 //ind->SetZeroScore(0.75)                       ; // 검사 후 최소 Score 
											 Find->SetMaxInstances(1)                       ;
											 Find->SetAngleTolerance(20.0f)                 ;
											 Find->SetAngleBias(45.0f)                      ;
											 Find->SetScaleBias(1.00f)                      ;
											 Find->SetScaleTolerance(0.0f)                  ;
											 Find->Property.Ox = (float)ImgW/2              ;
											 Find->Property.Oy = (float)ImgH/2              ;

											 Find->IRoi->SetPlacement(GrindMarkRect[25].left,GrindMarkRect[25].top,GrindRectWidth,GrindRectHeight);
											 if(GrindMarkRect[25].left<=0 || GrindMarkRect[25].top<=0 || GrindRectWidth<=0 || GrindRectHeight<=0) return false;

											 // 검사 및 Match Pos 좌표 받어온다 
											 // Find 검사 성공시 데이터 받아옴 
											 if(Find->OnExecute()){
												 GrindMarkPoint[25].x = Find->Result[0].Px;
												 GrindMarkPoint[25].y = Find->Result[0].Py;
												 GrindMarkScore[25]   = Find->Result[0].Score;
											 }
											 // Contrast Gradient Pixel Value
											 GrindMarkGradient[25] = EasyImage::Focusing(Find->IRoi);
										 }

										 // GrindMakr찾을경우 연마량,가공량 측정함
										 if(GrindMarkPoint[25].x!=0.0f && GrindMarkPoint[25].y!=0.0f){
											 // GrindMark기준 OutData 최단거리 Count정보 Calc 
											 GrindMeaDis =0.0f, MinDis =10000.0f; GrindMarkOutCnt=0;
											 for(int k=0; k<C1EdgeCount; k++){
												 if(C1Point[k].x  ==0.0f       || C1Point[k].y        ==0.0f) continue;
												 if(GrindMarkPoint[25].x==0.0f || GrindMarkPoint[25].y==0.0f) continue;

												 GrindMeaDis = Math.GetLength(GrindMarkPoint[25], C1Point[k]);
												 if(GrindMeaDis<MinDis){
													 MinDis = GrindMeaDis;
													 GrindMarkOutCnt = k;
												 }
											 }
											 // OutData기준 InData 최단거리 Count정보 Calc 
											 if(GrindMarkOutCnt!=0){
												 GrindMeaDis =0.0f, MinDis =10000.0f; GrindMarkInCnt=0;
												 for(int k=0; k<C1InEdgeCount; k++){
													 if(C1InPoint[k].x   ==0.0f          || C1InPoint[k].y             ==0.0f) continue;
													 if(C1Point[GrindMarkOutCnt].x==0.0f || C1Point[GrindMarkOutCnt].y ==0.0f) continue;

													 GrindMeaDis = Math.GetLength(C1Point[GrindMarkOutCnt], C1InPoint[k]);
													 if(GrindMeaDis<MinDis){
														 MinDis = GrindMeaDis;
														 GrindMarkInCnt = k;
													 }
												 }
											 }

											 // GrindMark기준 수직 포인트 주변값 Avg산출한다 ==>가공량 측정(OutData기준)
											 if(GrindMarkOutCnt!=0 && GrindMarkOutCnt>5){
												 CircleCount=0,TotalCirDis=0.0f,GrindMeaDis=0.0f;
												 for(int k=GrindMarkOutCnt-5; k<GrindMarkOutCnt+5; k++){
													 if(C1Point[k].x==0.0f || C1Point[k].y==0.0f) continue;

													 GrindMeaDis = Math.GetLength(GrindMarkPoint[25], C1Point[k]);
													 TotalCirDis+= GrindMeaDis;
													 CircleCount++;
												 }
												 if(TotalCirDis!=0.0f && CircleCount!=0){
													 C1CorGrindMea = TotalCirDis/CircleCount;
												 }
											 }

											 // GrindMark기준 수직 포인트 주변값 Avg산출한다 ==>연마량 측정(OutData,InData기준)
											 if((GrindMarkOutCnt!=0 && GrindMarkOutCnt>5) && (GrindMarkInCnt!=0 && GrindMarkInCnt>5)){
												 CircleCount=0,TotalCirDis=0.0f,GrindWidthDis=0.0f;
												 for(int k=-5; k<5; k++){
													 if(C1Point  [GrindMarkOutCnt+k].x==0.0f && C1Point  [GrindMarkOutCnt+k].y==0.0f) continue;
													 if(C1InPoint[GrindMarkInCnt +k].x==0.0f && C1InPoint[GrindMarkInCnt +k].y==0.0f) continue;
													 GrindWidthDis = Math.GetLength(C1InPoint[GrindMarkInCnt+k], C1Point[GrindMarkOutCnt+k]);
													 TotalCirDis+=   GrindWidthDis;
													 CircleCount++;
												 }
												 if(TotalCirDis!=0.0f && CircleCount!=0){
												     C1CorGrindWd  = TotalCirDis/CircleCount;
												 }
											 }
										 }
										 else { // GrindMrk 못찾을경우 연마량만 측정함 
											 // OutData기준 최소값 데이터 Count산출 
											 GrindMeaDis =0.0f, MinDis =10000.0f; GrindMarkOutCnt=0;
											 for(int k=0; k<C1EdgeCount; k++){
												 if(C1Point[k].x==0.0f || C1Point[k].y==0.0f) continue;

												 C1GrindRectPoint.x = GrindMarkRect[25].left + (GrindMarkRect[25].right  - GrindMarkRect[25].left)/2; 
												 C1GrindRectPoint.y = GrindMarkRect[25].top  + (GrindMarkRect[25].bottom - GrindMarkRect[25].top )/2; 

												 GrindMeaDis = Math.GetLength(C1GrindRectPoint, C1Point[k]);
												 if(GrindMeaDis<MinDis){
													 MinDis = GrindMeaDis;
													 GrindMarkOutCnt = k;
												 }
											 }

											 // 최단거리OUtCount기준 InData 최단거리 Count정보 Calc 
											 if(GrindMarkOutCnt!=0){
												 GrindMeaDis =0.0f, MinDis =10000.0f; GrindMarkInCnt=0;
												 for(int k=0; k<C1InEdgeCount; k++){
													 if(C1InPoint[k].x            ==0.0f || C1InPoint[k].y             ==0.0f) continue;
													 if(C1Point[GrindMarkOutCnt].x==0.0f || C1Point[GrindMarkOutCnt].y ==0.0f) continue;

													 GrindMeaDis = Math.GetLength(C1Point[GrindMarkOutCnt], C1InPoint[k]);
													 if(GrindMeaDis<MinDis){
														 MinDis = GrindMeaDis;
														 GrindMarkInCnt = k;
													 }
												 }
											 }

											 // GrindMark기준 수직 포인트 주변값 Avg산출한다 ==>연마량 측정(OutData,InData기준)
											 if((GrindMarkOutCnt!=0 && GrindMarkOutCnt>5) && (GrindMarkInCnt!=0 && GrindMarkInCnt>5)){
												 CircleCount=0,TotalCirDis=0.0f,GrindWidthDis=0.0f;
												 for(int k=-5; k<5; k++){
													 if(C1Point  [GrindMarkOutCnt+k].x==0.0f && C1Point  [GrindMarkOutCnt+k].y==0.0f) continue;
													 if(C1InPoint[GrindMarkInCnt +k].x==0.0f && C1InPoint[GrindMarkInCnt +k].y==0.0f) continue;
													 GrindWidthDis = Math.GetLength(C1InPoint[GrindMarkInCnt+k], C1Point[GrindMarkOutCnt+k]);
													 TotalCirDis+=   GrindWidthDis;
													 CircleCount++;
												 }
												 if(TotalCirDis!=0.0f && CircleCount!=0){
													 C1CorGrindWd = TotalCirDis/CircleCount;
												 }
											 }
										 }
									 }		
								 }
							 }
							 else if(IsRectTop){ // 코너 설정값이 없을경우 교차점 기준 검사 Rect검사  
								 LTDx = 0.0f;
								 LTDy = 0.0f;
								 //화면에 디스플레이 위해서 
								 FLTLPoint.x = FLTPoint.x;
								 FLTLPoint.y = FLTPoint.y;
								 FLTTPoint.x = FLTPoint.x;
								 FLTTPoint.y = FLTPoint.y;
							 }
							 else if(IsCircleTop){ // TOP영역 LeftTop Circle 검사 
								 // A_Side Pad영역에는 TrackLine존재하지 않음, 즉 GrindMark기준 가공량,연마량 측정만 가능함 
								 // Org A1CircleData 
								 int OrgA1CirInEdgeCount =0;		  
								 int OrgA1CirOutEdgeCount=0;	    
								 int A1GrindWidthCount   =0;		  
								 int A1GrindMarkCount    =0;
								 int A1Diameter          =0;
								 GrindRectWidth          =0;
								 GrindRectHeight         =0;

								 TFPoint *OrgA1CirInPoint =NULL;	 
								 TFPoint *OrgA1CirOutPoint=NULL;

								 TFPoint AGrindMarkRectPoint1(0.0f, 0.0f);

								 // Find Mark Search Start
								 ////////////////////////////////////////////////////////////////////////////
								 if(IsMarkBtm && FInspectMode!=Insp_Track){
									 LogUnit.SetLog(L"CellID:%d, CamID:%d ==>A1MarkFind_START",CellId,CamId);     

									 if(FP0.x!=0.0f && FP0.y!=0.0f){
										 // 원본이미지에서 Mark 찾는다 
										 Find->OnLoad(true,FindDir,1)                   ;
										 Find->GImage = &RotateImg                      ;
// 										 Find->SetContrastMode(EFindContrastMode_Any)   ;
										 Find->SetContrastMode(EFindContrastMode_Normal);
// 										 Find->SetMinScore(0.8f)                        ;
										 Find->SetMinScore (GrindPadMarkMinScore)       ; // PatternrFind 검사 최소 Score
										 Find->SetZeroScore(GrindPadMarkMinScore)       ; // 검사 후 최소 Score 
// 										 Find->SetMinScore (0.75)                       ; // PatternrFind 검사 최소 Score
// 										 Find->SetZeroScore(0.75)                       ; // 검사 후 최소 Score 
										 Find->SetMaxInstances(1)                       ;
										 Find->SetAngleTolerance(20.0f)                 ;
// 										 Find->SetAngleBias(45.0f)                      ;
										 Find->SetScaleBias(1.00f)                      ;
										 Find->SetScaleTolerance(0.0f)                  ;
										 Find->Property.Ox = (float)ImgW/2              ;
										 Find->Property.Oy = (float)ImgH/2              ;

										 // 첫번째 GrindMark기준 센터 25번 Search 
										 if(AMarkToGrindMarkDvX!=0.0f && AMarkToGrindMarkDvY!=0.0f){
											 GrindMarkRect[25].left   = (FP0.x-AMarkToGrindMarkDvX)-40;
											 GrindMarkRect[25].top    = (FP0.y+AMarkToGrindMarkDvY)-40;
											 GrindMarkRect[25].right  = (GrindMarkRect[25].left + 80);
											 GrindMarkRect[25].bottom = (GrindMarkRect[25].top  + 80);

											 GrindRectWidth  = (GrindMarkRect[25].right  - GrindMarkRect[25].left);
											 GrindRectHeight = (GrindMarkRect[25].bottom - GrindMarkRect[25].top );

											 Find->IRoi->SetPlacement(GrindMarkRect[25].left,GrindMarkRect[25].top,GrindRectWidth,GrindRectHeight);
											 if(GrindMarkRect[25].left<=0 || GrindMarkRect[25].top<=0 || GrindRectWidth<=0 || GrindRectHeight<=0) return false;

											 // 검사 및 Match Pos 좌표 받어온다 
											 // Find 검사 성공시 데이터 받아옴 
											 Find->SetAngleBias(45.0f);
											 if(Find->OnExecute()){
												 GrindMarkPoint[25].x = Find->Result[0].Px;
												 GrindMarkPoint[25].y = Find->Result[0].Py;
												 GrindMarkScore[25]   = Find->Result[0].Score;
											 }
											 // Contrast Gradient Pixel Value
											 GrindMarkGradient[25] = EasyImage::Focusing(Find->IRoi);
										 }

										 // 두번째 GrindMark기준 센터 24번 Search 
										 if(AMarkToGrindMarkDvX2!=0.0f && AMarkToGrindMarkDvY2!=0.0f){
											 GrindMarkRect[24].left   = (FP0.x+AMarkToGrindMarkDvX2)-40;
											 GrindMarkRect[24].top    = (FP0.y+AMarkToGrindMarkDvY2)-40;
											 GrindMarkRect[24].right  = (GrindMarkRect[24].left + 80);
											 GrindMarkRect[24].bottom = (GrindMarkRect[24].top  + 80);

											 GrindRectWidth  = (GrindMarkRect[24].right  - GrindMarkRect[24].left);
											 GrindRectHeight = (GrindMarkRect[24].bottom - GrindMarkRect[24].top );

											 Find->IRoi->SetPlacement(GrindMarkRect[24].left,GrindMarkRect[24].top,GrindRectWidth,GrindRectHeight);
											 if(GrindMarkRect[24].left<=0 || GrindMarkRect[24].top<=0 || GrindRectWidth<=0 || GrindRectHeight<=0) return false;

											 // 검사 및 Match Pos 좌표 받어온다 
											 // Find 검사 성공시 데이터 받아옴 
											 Find->SetAngleBias(90.0f);
											 if(Find->OnExecute()){
												 GrindMarkPoint[24].x = Find->Result[0].Px;
												 GrindMarkPoint[24].y = Find->Result[0].Py;
												 GrindMarkScore[24]   = Find->Result[0].Score;
											 }
											 // Contrast Gradient Pixel Value
											 GrindMarkGradient[24] = EasyImage::Focusing(Find->IRoi);
										 }
									 }
									 // Find Mark Search Start
									 ////////////////////////////////////////////////////////////////////////////
									 LogUnit.SetLog(L"CellID:%d, CamID:%d ==>A1MarkFind_END",CellId,CamId);     
								 }

								 // NOTCH LeftTop 
								 if(FInspectMode==Insp_Polygon){ // 비선형 곡선 알고리즘 
									 
//									 RotateBinaryImg.Save("D:\\ROTATE_IMG\\Polygon_BinaryImg1.bmp");
									 LogUnit.SetLog(L"CellID:%d, CamID:%d ==>LeftTop_Polygon_START",CellId,CamId);     

									 TPoint P1(0,0),P2(0,0),P3(0,0),P4(0,0);

// 									 P1.x = (int)(FLTPoint.x-20);    P1.y =(int)(FLTPoint.y-20            ); P2.x = (int)(P1.x+ASideCircleWidth+50);    P2.y = (int)(P1.y);
// 									 P3.x = (int)(FLTPoint.x-20);    P3.y =(int)(P1.y+ASideCircleHeight+50); P4.x = (int)(P2.x                    );    P4.y = (int)(P3.y);

// 									 P1.x = (int)(FLTPoint.x-20);    P1.y =(int)(FLTPoint.y-20            ); P2.x = (int)(P1.x+ASideCircleWidth+40);    P2.y = (int)(P1.y);
// 									 P3.x = (int)(FLTPoint.x-20);    P3.y =(int)(P1.y+ASideCircleHeight+40); P4.x = (int)(P2.x                    );    P4.y = (int)(P3.y);

									 P1.x = (int)(FLTPoint.x-20);    P1.y =(int)(FLTPoint.y-20            ); P2.x = (int)(P1.x+ASideCircleWidth+20);    P2.y = (int)(P1.y);
									 P3.x = (int)(FLTPoint.x-20);    P3.y =(int)(P1.y+ASideCircleHeight+20); P4.x = (int)(P2.x                    );    P4.y = (int)(P3.y);


									 int PixelCnt =0;

									 // Median Filter 적용 
									 if(P1.x<=0    || P1.y<=0    || (P2.x - P1.x)<=0    || (P3.y - P1.y)<=0   ) return false;
									 if(P1.x>=ImgW || P1.y>=ImgH || (P2.x - P1.x)>=ImgW || (P3.y - P1.y)>=ImgH) return false;
									 FilterROI.SetSize(int(P2.x - P1.x),int(P3.y - P1.y) )                      ;
									 FilterROI.Attach(&RotateBinaryImg)                                         ;
									 FilterROI.SetPlacement(P1.x, P1.y, int(P2.x - P1.x), int(P3.y - P1.y))     ;
									 EasyImage::Median(&FilterROI, &FilterROI)                                  ;
// 									 RotateBinaryImg.Save("D:\\ROTATE_IMG\\Polygon_LeftTop_필터.bmp");

									 Polygon->GImage = &RotateBinaryImg                          ;
									 Polygon->IWidth = ImgW                                      ;
									 Polygon->IHeight= ImgH                                      ;
									 Polygon->PoPa.FMinWidth  =(int)(ASideCircleWidth/2)         ;                       
// 									 Polygon->PoPa.FMaxWidth  =(int)((FRTPoint.x - FLTPoint.x)/2);
									 Polygon->PoPa.FMaxWidth  =(int)(ASideCircleWidth+100)       ;
									 Polygon->PoPa.FMinHeight =(int)(ASideCircleHeight/2)        ;
// 									 Polygon->PoPa.FMaxHeight =1000                              ;
									 Polygon->PoPa.FMaxHeight =(int)(ASideCircleHeight+100)      ;
									 Polygon->PoPa.MinPxCnt   =100                               ;
									 Polygon->PoPa.MaxPxCnt   =20000                             ;
									 Polygon->PoPa.MaxBbCnt   =10                                ;
									 Polygon->PoPa.IsSeparate =true                              ;
									 Polygon->PoPa.IsInToOut  =false                             ;
									 Polygon->PoPa.HiThHold   = ECThresHold                      ;
									 Polygon->PoPa.LoThHold   = 0                                ;

									 if(P1.x!=0 && P1.y!=0 && P2.x!=0 && P2.y!=0 && P3.x!=0 && P3.y!=0 && P4.x!=0 && P4.y!=0){
										 Polygon->OnExecute(P1,P2,P3,P4);
									 }

									 // Polygon Algorithm InEdgeData/OutEdgeData Separate 
									 if(Polygon->BlobCount==1){
										 PolygonMarginCnt =5;
										 if(Polygon->Blob[0].InCnt>(PolygonMarginCnt*2)){
											 A1CirInEdgeCount=0;
											 A1CirInEdgeCount = (Polygon->Blob[0].InCnt - (PolygonMarginCnt*2));
											 if(A1CirInEdgeCount>0){
												 if(A1CirInPoint!=NULL) delete[] A1CirInPoint;
												 A1CirInPoint = new TFPoint[A1CirInEdgeCount];

												 PixelCnt=0;
												 for(int k=0; k<Polygon->Blob[0].InCnt; k++){
													 if(k<PolygonMarginCnt || k>=(Polygon->Blob[0].InCnt-PolygonMarginCnt)) continue;
													 A1CirInPoint[PixelCnt].x   = Polygon->Blob[0].InPoint[k].x ;
													 A1CirInPoint[PixelCnt].y   = Polygon->Blob[0].InPoint[k].y ;
													 PixelCnt++;
												 }
											 }
										 }

										 if(Polygon->Blob[0].OutCnt>(PolygonMarginCnt*2)){
											 A1CirOutEdgeCount=0;
											 A1CirOutEdgeCount = (Polygon->Blob[0].OutCnt - (PolygonMarginCnt*2));
											 if(A1CirOutEdgeCount>0){
												 if(A1CirOutPoint!=NULL) delete[] A1CirOutPoint;
												 A1CirOutPoint = new TFPoint[A1CirOutEdgeCount];

												 PixelCnt=0;
												 for(int k=0; k<Polygon->Blob[0].OutCnt; k++){
													 if(k<PolygonMarginCnt || k>=(Polygon->Blob[0].OutCnt-PolygonMarginCnt)) continue;
													 A1CirOutPoint[PixelCnt].x  = Polygon->Blob[0].OutPoint[k].x ;
													 A1CirOutPoint[PixelCnt].y  = Polygon->Blob[0].OutPoint[k].y ;
													 PixelCnt++;
												 }
											 }
										 }
										 // Polygon Data Clear
// 										 Polygon->ClearData();
									 }

									 // InEdgeData/OutEdgeData 기준 가공량 및 연마량 계산
									 // Polygon 알고리즘에서는 GrindMark기준 OutData,InData 최단거리 2개 Tag값 산출해야함 
									 if(IsMarkBtm){ // LTPS 가공량,연마량 계산 
										 if(A1CirOutEdgeCount!=0 && A1CirInEdgeCount!=0){ // MarkMode경우 가공량 검사를 먼저 진행 후 연마량 산출 
											 // 25번째 GrindMark Search 및 연마,가공 데이터 계산
											 /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
											 if(GrindMarkPoint[25].x!=0.0f && GrindMarkPoint[25].y!=0.0f){  //GrindMark 찾았을경우 
												 // GrindMark기준 OutData 최단거리 Count정보 Calc 
												 GrindMeaDis =0.0f, MinDis =10000.0f; GrindMarkOutCnt=0;
												 for(int k=0; k<A1CirOutEdgeCount; k++){
													 if(A1CirOutPoint[k].x  ==0.0f || A1CirOutPoint[k].y  ==0.0f) continue;
													 if(GrindMarkPoint[25].x==0.0f || GrindMarkPoint[25].y==0.0f) continue;

													 GrindMeaDis = Math.GetLength(GrindMarkPoint[25], A1CirOutPoint[k]);
													 if(GrindMeaDis<MinDis){
														 MinDis = GrindMeaDis;
														 GrindMarkOutCnt = k;
													 }
												 }
												 // GrindMark기준 InData 최단거리 Count정보 Calc 
												 GrindMeaDis =0.0f, MinDis =10000.0f; GrindMarkInCnt=0;
												 for(int k=0; k<A1CirInEdgeCount; k++){
													 if(A1CirInPoint[k].x   ==0.0f || A1CirInPoint[k].y    ==0.0f) continue;
													 if(GrindMarkPoint[25].x==0.0f || GrindMarkPoint[25].y ==0.0f) continue;

													 GrindMeaDis = Math.GetLength(GrindMarkPoint[25], A1CirInPoint[k]);
													 if(GrindMeaDis<MinDis){
														 MinDis = GrindMeaDis;
														 GrindMarkInCnt = k;
													 }
												 }

												 // GrindMark기준 InData 최단거리 Count정보 Calc 
												 if(GrindMarkOutCnt!=0){
													 GrindMeaDis =0.0f, MinDis =10000.0f; GrindMarkInCnt=0;
													 for(int k=0; k<A1CirInEdgeCount; k++){
														 if(A1CirInPoint[k].x   ==0.0f             || A1CirInPoint[k].y                ==0.0f) continue;
														 if(A1CirOutPoint[GrindMarkOutCnt].x==0.0f || A1CirOutPoint[GrindMarkOutCnt].y ==0.0f) continue;

														 GrindMeaDis = Math.GetLength(A1CirOutPoint[GrindMarkOutCnt], A1CirInPoint[k]);
														 if(GrindMeaDis<MinDis){
															 MinDis = GrindMeaDis;
															 GrindMarkInCnt = k;
														 }
													 }
												 }

												 // GrindMark기준 수직 포인트 주변값 Avg산출한다 ==>가공량 측정(OutData기준)
												 if(GrindMarkOutCnt!=0 && GrindMarkOutCnt>5){
													 CircleCount=0,TotalCirDis=0.0f,GrindMeaDis=0.0f;
													 for(int k=GrindMarkOutCnt-5; k<GrindMarkOutCnt+5; k++){
														 if(A1CirOutPoint[k].x==0.0f || A1CirOutPoint[k].y==0.0f) continue;

														 GrindMeaDis = Math.GetLength(GrindMarkPoint[25], A1CirOutPoint[k]);
														 TotalCirDis+= GrindMeaDis;
														 CircleCount++;
													 }
													 if(TotalCirDis!=0.0f && CircleCount!=0){
														 A1CirGrindMea[2] = TotalCirDis/CircleCount;
														 A1CirGrindMea[2] = A1CirGrindMea[2]+0.5; //SubPixel 
													 }
												 }

												 // GrindMark기준 수직 포인트 주변값 Avg산출한다 ==>연마량 측정(OutData,InData기준)
												 if((GrindMarkOutCnt!=0 && GrindMarkOutCnt>5) && (GrindMarkInCnt!=0 && GrindMarkInCnt>5)){
													 CircleCount=0,TotalCirDis=0.0f,GrindWidthDis=0.0f;
													 for(int k=-5; k<5; k++){
														 if(A1CirOutPoint[GrindMarkOutCnt+k].x==0.0f && A1CirOutPoint[GrindMarkOutCnt+k].y==0.0f) continue;
														 if(A1CirInPoint [GrindMarkInCnt +k].x==0.0f && A1CirInPoint [GrindMarkInCnt +k].y==0.0f) continue;
														 GrindWidthDis = Math.GetLength(A1CirInPoint[GrindMarkInCnt+k], A1CirOutPoint[GrindMarkOutCnt+k]);
														 TotalCirDis+=   GrindWidthDis;
														 CircleCount++;
													 }
													 if(TotalCirDis!=0.0f && CircleCount!=0){
														 A1CirGrindWd[2] = TotalCirDis/CircleCount;
														 A1CirGrindWd[2] = A1CirGrindWd[2]+0.5; //SubPixel
													 }
												 }
											 }
											 else if(GrindMarkRect[25].left!=0 && GrindMarkRect[25].top!=0 && GrindMarkRect[25].right!=0 && GrindMarkRect[25].bottom!=0){  //GrindMark 못 찾았을경우
												 // OutData기준 최소값 데이터 Count산출 
												 GrindMeaDis =0.0f, MinDis =10000.0f; GrindMarkOutCnt=0;
												 for(int k=0; k<A1CirOutEdgeCount; k++){
													 if(A1CirOutPoint[k].x==0.0f || A1CirOutPoint[k].y==0.0f) continue;

													 AGrindMarkRectPoint1.x = GrindMarkRect[25].left + (GrindMarkRect[25].right  - GrindMarkRect[25].left)/2; 
													 AGrindMarkRectPoint1.y = GrindMarkRect[25].top  + (GrindMarkRect[25].bottom - GrindMarkRect[25].top )/2; 

													 GrindMeaDis = Math.GetLength(AGrindMarkRectPoint1, A1CirOutPoint[k]);
													 if(GrindMeaDis<MinDis){
														 MinDis = GrindMeaDis;
														 GrindMarkOutCnt = k;
													 }
												 }

												 // 최단거리OUtCount기준 InData 최단거리 Count정보 Calc 
												 if(GrindMarkOutCnt!=0){
													 GrindMeaDis =0.0f, MinDis =10000.0f; GrindMarkInCnt=0;
													 for(int k=0; k<A1CirInEdgeCount; k++){
														 if(A1CirInPoint[k].x   ==0.0f             || A1CirInPoint[k].y                ==0.0f) continue;
														 if(A1CirOutPoint[GrindMarkOutCnt].x==0.0f || A1CirOutPoint[GrindMarkOutCnt].y ==0.0f) continue;

														 GrindMeaDis = Math.GetLength(A1CirOutPoint[GrindMarkOutCnt], A1CirInPoint[k]);
														 if(GrindMeaDis<MinDis){
															 MinDis = GrindMeaDis;
															 GrindMarkInCnt = k;
														 }
													 }
												 }

												 // GrindMark기준 수직 포인트 주변값 Avg산출한다 ==>연마량 측정(OutData,InData기준)
												 if((GrindMarkOutCnt!=0 && GrindMarkOutCnt>5) && (GrindMarkInCnt!=0 && GrindMarkInCnt>5)){
													 CircleCount=0,TotalCirDis=0.0f,GrindWidthDis=0.0f;
													 for(int k=-5; k<5; k++){
														 if(A1CirOutPoint[GrindMarkOutCnt+k].x==0.0f && A1CirOutPoint[GrindMarkOutCnt+k].y==0.0f) continue;
														 if(A1CirInPoint [GrindMarkInCnt +k].x==0.0f && A1CirInPoint [GrindMarkInCnt +k].y==0.0f) continue;
														 GrindWidthDis = Math.GetLength(A1CirInPoint[GrindMarkInCnt+k], A1CirOutPoint[GrindMarkOutCnt+k]);
														 TotalCirDis+=   GrindWidthDis;
														 CircleCount++;
													 }
													 if(TotalCirDis!=0.0f && CircleCount!=0){
														 A1CirGrindWd[2] = TotalCirDis/CircleCount;
														 A1CirGrindWd[2] = A1CirGrindWd[2]+0.5; //SubPixel
													 }
												 }
											 }
											 /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


											 // 24번째 GrindMark Search 및 연마,가공 데이터 계산
											 /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
											 if(GrindMarkPoint[24].x!=0.0f && GrindMarkPoint[24].y!=0.0f){  //GrindMark 찾았을경우 
												 // GrindMark기준 OutData 최단거리 Count정보 Calc 
												 GrindMeaDis =0.0f, MinDis =10000.0f; GrindMarkOutCnt=0;
												 for(int k=0; k<A1CirOutEdgeCount; k++){
													 if(A1CirOutPoint[k].x  ==0.0f || A1CirOutPoint[k].y  ==0.0f) continue;
													 if(GrindMarkPoint[24].x==0.0f || GrindMarkPoint[24].y==0.0f) continue;

													 GrindMeaDis = Math.GetLength(GrindMarkPoint[24], A1CirOutPoint[k]);
													 if(GrindMeaDis<MinDis){
														 MinDis = GrindMeaDis;
														 GrindMarkOutCnt = k;
													 }
												 }
												 // GrindMark기준 InData 최단거리 Count정보 Calc 
												 GrindMeaDis =0.0f, MinDis =10000.0f; GrindMarkInCnt=0;
												 for(int k=0; k<A1CirInEdgeCount; k++){
													 if(A1CirInPoint[k].x   ==0.0f || A1CirInPoint[k].y    ==0.0f) continue;
													 if(GrindMarkPoint[24].x==0.0f || GrindMarkPoint[24].y ==0.0f) continue;

													 GrindMeaDis = Math.GetLength(GrindMarkPoint[24], A1CirInPoint[k]);
													 if(GrindMeaDis<MinDis){
														 MinDis = GrindMeaDis;
														 GrindMarkInCnt = k;
													 }
												 }

												 // GrindMark기준 InData 최단거리 Count정보 Calc 
												 if(GrindMarkOutCnt!=0){
													 GrindMeaDis =0.0f, MinDis =10000.0f; GrindMarkInCnt=0;
													 for(int k=0; k<A1CirInEdgeCount; k++){
														 if(A1CirInPoint[k].x   ==0.0f             || A1CirInPoint[k].y                ==0.0f) continue;
														 if(A1CirOutPoint[GrindMarkOutCnt].x==0.0f || A1CirOutPoint[GrindMarkOutCnt].y ==0.0f) continue;

														 GrindMeaDis = Math.GetLength(A1CirOutPoint[GrindMarkOutCnt], A1CirInPoint[k]);
														 if(GrindMeaDis<MinDis){
															 MinDis = GrindMeaDis;
															 GrindMarkInCnt = k;
														 }
													 }
												 }

												 // GrindMark기준 수직 포인트 주변값 Avg산출한다 ==>가공량 측정(OutData기준)
												 if(GrindMarkOutCnt!=0 && GrindMarkOutCnt>5){
													 CircleCount=0,TotalCirDis=0.0f,GrindMeaDis=0.0f;
													 for(int k=GrindMarkOutCnt-5; k<GrindMarkOutCnt+5; k++){
														 if(A1CirOutPoint[k].x==0.0f || A1CirOutPoint[k].y==0.0f) continue;

														 GrindMeaDis = Math.GetLength(GrindMarkPoint[24], A1CirOutPoint[k]);
														 TotalCirDis+= GrindMeaDis;
														 CircleCount++;
													 }
													 if(TotalCirDis!=0.0f && CircleCount!=0){
														 A1CirGrindMea[1] = TotalCirDis/CircleCount;
														 A1CirGrindMea[1] = A1CirGrindMea[1]+0.5; //SubPixel 
													 }
												 }

												 // GrindMark기준 수직 포인트 주변값 Avg산출한다 ==>연마량 측정(OutData,InData기준)
												 if((GrindMarkOutCnt!=0 && GrindMarkOutCnt>5) && (GrindMarkInCnt!=0 && GrindMarkInCnt>5)){
													 CircleCount=0,TotalCirDis=0.0f,GrindWidthDis=0.0f;
													 for(int k=-5; k<5; k++){
														 if(A1CirOutPoint[GrindMarkOutCnt+k].x==0.0f && A1CirOutPoint[GrindMarkOutCnt+k].y==0.0f) continue;
														 if(A1CirInPoint [GrindMarkInCnt +k].x==0.0f && A1CirInPoint [GrindMarkInCnt +k].y==0.0f) continue;
														 GrindWidthDis = Math.GetLength(A1CirInPoint[GrindMarkInCnt+k], A1CirOutPoint[GrindMarkOutCnt+k]);
														 TotalCirDis+=   GrindWidthDis;
														 CircleCount++;
													 }
													 if(TotalCirDis!=0.0f && CircleCount!=0){
														 A1CirGrindWd[1] = TotalCirDis/CircleCount;
														 A1CirGrindWd[1] = A1CirGrindWd[1]+0.5; //SubPixel
													 }
												 }
											 }
											 else if(GrindMarkRect[24].left!=0 && GrindMarkRect[24].top!=0 && GrindMarkRect[24].right!=0 && GrindMarkRect[24].bottom!=0){  //GrindMark 못 찾았을경우
												 // OutData기준 최소값 데이터 Count산출 
												 GrindMeaDis =0.0f, MinDis =10000.0f; GrindMarkOutCnt=0;
												 for(int k=0; k<A1CirOutEdgeCount; k++){
													 if(A1CirOutPoint[k].x==0.0f || A1CirOutPoint[k].y==0.0f) continue;

													 AGrindMarkRectPoint1.x = GrindMarkRect[24].left + (GrindMarkRect[24].right  - GrindMarkRect[24].left)/2; 
													 AGrindMarkRectPoint1.y = GrindMarkRect[24].top  + (GrindMarkRect[24].bottom - GrindMarkRect[24].top )/2; 

													 GrindMeaDis = Math.GetLength(AGrindMarkRectPoint1, A1CirOutPoint[k]);
													 if(GrindMeaDis<MinDis){
														 MinDis = GrindMeaDis;
														 GrindMarkOutCnt = k;
													 }
												 }

												 // 최단거리OUtCount기준 InData 최단거리 Count정보 Calc 
												 if(GrindMarkOutCnt!=0){
													 GrindMeaDis =0.0f, MinDis =10000.0f; GrindMarkInCnt=0;
													 for(int k=0; k<A1CirInEdgeCount; k++){
														 if(A1CirInPoint[k].x   ==0.0f             || A1CirInPoint[k].y                ==0.0f) continue;
														 if(A1CirOutPoint[GrindMarkOutCnt].x==0.0f || A1CirOutPoint[GrindMarkOutCnt].y ==0.0f) continue;

														 GrindMeaDis = Math.GetLength(A1CirOutPoint[GrindMarkOutCnt], A1CirInPoint[k]);
														 if(GrindMeaDis<MinDis){
															 MinDis = GrindMeaDis;
															 GrindMarkInCnt = k;
														 }
													 }
												 }

												 // GrindMark기준 수직 포인트 주변값 Avg산출한다 ==>연마량 측정(OutData,InData기준)
												 if((GrindMarkOutCnt!=0 && GrindMarkOutCnt>5) && (GrindMarkInCnt!=0 && GrindMarkInCnt>5)){
													 CircleCount=0,TotalCirDis=0.0f,GrindWidthDis=0.0f;
													 for(int k=-5; k<5; k++){
														 if(A1CirOutPoint[GrindMarkOutCnt+k].x==0.0f && A1CirOutPoint[GrindMarkOutCnt+k].y==0.0f) continue;
														 if(A1CirInPoint [GrindMarkInCnt +k].x==0.0f && A1CirInPoint [GrindMarkInCnt +k].y==0.0f) continue;
														 GrindWidthDis = Math.GetLength(A1CirInPoint[GrindMarkInCnt+k], A1CirOutPoint[GrindMarkOutCnt+k]);
														 TotalCirDis+=   GrindWidthDis;
														 CircleCount++;
													 }
													 if(TotalCirDis!=0.0f && CircleCount!=0){
														 A1CirGrindWd[1] = TotalCirDis/CircleCount;
														 A1CirGrindWd[1] = A1CirGrindWd[1]+0.5; //SubPixel
													 }
												 }
											 }
											 /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
										 }
									 }
									 else         { //Polygon EnCap 계산시 OutPoint 중간값 기준 실측 거리 평균값을 계산한다(LeftTop) 
										 if(A1CirInEdgeCount!=0 && A1CirOutEdgeCount!=0){
											 GrindMeaDis =0.0f, MinDis =10000.0f; GrindMarkOutCnt=0;
											 GrindMarkOutCnt = (int)(A1CirOutEdgeCount/2);
											 // 최단거리OUtCount기준 InData 최단거리 Count정보 Calc 
											 if(GrindMarkOutCnt!=0){
												 GrindMeaDis =0.0f, MinDis =10000.0f; GrindMarkInCnt=0;
												 for(int k=0; k<A1CirInEdgeCount; k++){
													 if(A1CirInPoint[k].x   ==0.0f             || A1CirInPoint[k].y                ==0.0f) continue;
													 if(A1CirOutPoint[GrindMarkOutCnt].x==0.0f || A1CirOutPoint[GrindMarkOutCnt].y ==0.0f) continue;

													 GrindMeaDis = Math.GetLength(A1CirOutPoint[GrindMarkOutCnt], A1CirInPoint[k]);
													 if(GrindMeaDis<MinDis){
														 MinDis = GrindMeaDis;
														 GrindMarkInCnt = k;
													 }
												 }
											 }

											 // GrindMark기준 수직 포인트 주변값 Avg산출한다 ==>연마량 측정(OutData,InData기준)
											 if((GrindMarkOutCnt!=0 && GrindMarkOutCnt>5) && (GrindMarkInCnt!=0 && GrindMarkInCnt>5)){
												 CircleCount=0,TotalCirDis=0.0f,GrindWidthDis=0.0f;
												 for(int k=-5; k<5; k++){
													 if(A1CirOutPoint[GrindMarkOutCnt+k].x==0.0f && A1CirOutPoint[GrindMarkOutCnt+k].y==0.0f) continue;
													 if(A1CirInPoint [GrindMarkInCnt +k].x==0.0f && A1CirInPoint [GrindMarkInCnt +k].y==0.0f) continue;
													 GrindWidthDis = Math.GetLength(A1CirInPoint[GrindMarkInCnt+k], A1CirOutPoint[GrindMarkOutCnt+k]);
													 TotalCirDis+=   GrindWidthDis;
													 CircleCount++;
												 }
												 if(TotalCirDis!=0.0f && CircleCount!=0){
													 A1CirGrindWd[2] = TotalCirDis/CircleCount;
													 A1CirGrindWd[2] = A1CirGrindWd[2]+0.5; //SubPixel
												 }
											 }
										 }
									 }

									 // FAVION Circle Fitting 결과물(LeftTop)
									 SampleSize = A1CirInEdgeCount*0.75; //0.5~0.8이하로 입력할것
									 DistDevRatio = 0.15; //0.1~0.25 이하로 입력할것
									 CircleFit->OnRansac(A1CirInPoint,A1CirInEdgeCount,SampleSize,DistDevRatio,&ACircleFit1Center,&ACirFitDiameter1);

									 // Polygon 박리 검사 시퀀스(LeftTop) 
									 if(!IsMarkBtm && BrokenThresHold!=0){
										 RotateBrokenImg.SetSize(RotateImg.GetWidth(), RotateImg.GetHeight());
										 EasyImage::Oper(EArithmeticLogicOperation_Copy,&RotateImg,&RotateBrokenImg);
										 EasyImage::Threshold(&RotateImg,&RotateBrokenImg, BrokenThresHold);
										 Edge->GImage = &RotateBrokenImg;
										 Edge->SetEdgeType(0);
// 										 RotateBrokenImg.Save("D:\\ROTATE_IMG\\Polygon_LeftTop_박리.bmp");

										 int DvCnt =0, DataCount=0;
										 double deg =0.0f; 
										 TFPoint Target(0.0f, 0.0f);

										 if(GrindMarkInCnt>GrindMarkOutCnt){
											 DvCnt = GrindMarkInCnt - GrindMarkOutCnt;
											 for(int k=0; k<A1CirOutEdgeCount; k++){
												 deg =0.0f, Target.x =0.0f, Target.y =0.0f;
												 if(((k+DvCnt)<A1CirInEdgeCount) && A1CirInPoint[k+DvCnt].x>0  && A1CirInPoint[k+DvCnt].y>0){
													 deg = Math.GetDegree(A1CirOutPoint[k],A1CirInPoint[k+DvCnt]);

													 Target  = Math.OnFindPerpendicularPointXY(A1CirOutPoint[k],dEdgeToTrapLineDis,dEdgeToTrapLineDis,deg);
													 Edge->OnExecute(A1CirOutPoint[k],Target); // 연마외곽라인에서 Target까지 White Point Search 
													 if(Edge->GetResultEdgePointCount()>0){
														 A1CircleData[DataCount].Dis =0.0f;
														 A1CircleData[DataCount].Dv  =0.0f;
														 A1CircleData[DataCount].P   = Edge->GetResultEdgePoint(0);
														 A1CircleData[DataCount].P.y = A1CircleData[DataCount].P.y - ImageHeight; // Frame기준 단위좌표로 변경함  
														 DataCount++;
													 }
												 }
											 }
											 A1CirInCrackCount = DataCount;
										 }
										 else if(GrindMarkInCnt<GrindMarkOutCnt)   {
											 DvCnt = GrindMarkOutCnt - GrindMarkInCnt;
											 for(int k=DvCnt; k<A1CirOutEdgeCount; k++){
												 deg =0.0f, Target.x =0.0f, Target.y =0.0f;
												 if(((k-DvCnt)<A1CirInEdgeCount) && A1CirInPoint[k-DvCnt].x>0  && A1CirInPoint[k-DvCnt].y>0 && k-DvCnt>=0){
													 deg = Math.GetDegree(A1CirOutPoint[k],A1CirInPoint[k-DvCnt]);

													 Target  = Math.OnFindPerpendicularPointXY(A1CirOutPoint[k],dEdgeToTrapLineDis,dEdgeToTrapLineDis,deg);
													 Edge->OnExecute(A1CirOutPoint[k],Target); // 연마외곽라인에서 Target까지 White Point Search 
													 if(Edge->GetResultEdgePointCount()>0){
														 A1CircleData[DataCount].Dis =0.0f;
														 A1CircleData[DataCount].Dv  =0.0f;
														 A1CircleData[DataCount].P   = Edge->GetResultEdgePoint(0);
														 A1CircleData[DataCount].P.y = A1CircleData[DataCount].P.y - ImageHeight; // Frame기준 단위좌표로 변경함  
														 DataCount++;
													 }
												 }
											 }
											 A1CirInCrackCount = DataCount;
										 }
									 }
									 LogUnit.SetLog(L"CellID:%d, CamID:%d ==>LeftTop_Polygon_END",CellId,CamId);     
								 }
								 else if(FInspectMode==Insp_Mark){
									 LogUnit.SetLog(L"LeftTop_Mark_START");     

									 // 자재의 외곽라인 교차점 기준 CirCenter 설정함 
									 if(ASideCircleWidth!=0.0f && ASideCircleHeight!=0.0f) A1CirCenter.x = FLTPoint.x + ASideCircleWidth;  A1CirCenter.y = FLTPoint.y + ASideCircleHeight;  
									 // Circle Fitting 진행시 공통으로 사용하는 설정값
									 Circle->SetSamplingStep(1)                              ; // A1Circle Edge 간격 
									 //A1 In Circle EdgePoint Data 추출 
									 if(A1CirCenter.x!=0 && A1CirCenter.y!=0){
// 										 RotateBinaryImg.Save("D:\\ROTATE_IMG\\LeftTop_원본.bmp");

										 // A_Side Circle 검사전 Median 필터 적용 
										 TPoint P1(0,0),P2(0,0),P3(0,0),P4(0,0);
										 P1.x = (int)(FLTPoint.x-20);    P1.y =(int)(FLTPoint.y-20            ); P2.x = (int)(P1.x+ASideCircleWidth+40);    P2.y = (int)(P1.y);
										 P3.x = (int)(FLTPoint.x-20);    P3.y =(int)(P1.y+ASideCircleHeight+40); P4.x = (int)(P2.x                    );    P4.y = (int)(P3.y);

										 // Median Filter 적용 
										 if(P1.x<=0    || P1.y<=0    || (P2.x - P1.x)<=0    || (P3.y - P1.y)<=0   ) return false;
										 if(P1.x>=ImgW || P1.y>=ImgH || (P2.x - P1.x)>=ImgW || (P3.y - P1.y)>=ImgH) return false;
										 FilterROI.SetSize(int(P2.x - P1.x),int(P3.y - P1.y) )                 ;
										 FilterROI.Attach(&RotateBinaryImg)                                    ;
										 FilterROI.SetPlacement(P1.x, P1.y, int(P2.x - P1.x), int(P3.y - P1.y));
										 EasyImage::Median(&FilterROI, &FilterROI)                             ;

// 										 RotateBinaryImg.Save("D:\\ROTATE_IMG\\LeftTop_필터.bmp");


										 if(ECThresHold==0) Circle->GImage = &RotateImg      ; //Org Image 넘겨줌 
										 else               Circle->GImage = &RotateBinaryImg; //Binary Image 넘겨줌 

										 Circle->SetCenterXY(A1CirCenter.x , A1CirCenter.y)  ; // Circle Center 좌표설정 
										 // 									 A1Diameter = ((ASideCircleWidth*2)+((ASideCircleWidth-OutToTrackLineDis)*2))/2;
										 A1Diameter = (ASideCircleWidth*2);

										 Circle->SetDiameter(A1Diameter)             ;
										 Circle->SetTolerance(60.0f )                ; // A1Circle Tolerance 
										 Circle->SetCircleChoice(1)                  ; // 0:From Begin, 1:From End, 2:Largest Amplitude 
										 Circle->SetCircleIndex (1)                  ; // Circle EdgePoint Index 
										 Circle->SetAngle(180+CirAngleMargin)        ; // Cirlce Angle 
										 Circle->SetAmplitude(90-(2*CirAngleMargin)) ; // Circle Amplitude

										 // Circle InData EdgePoint 
										 //////////////////////////////////////////////////////////////////////////////////////////////////////
										 Circle->SetCircleType(2)                          ; // 0:Black to White, 1:White to Black 2: Both Black, White 
										 Circle->OnExecute()                               ;

										 // Circle In Data 기준 새로운 Circle Center 좌표 받아옴 
										 // Euresys Circle Fitting Center & Diameter  
										 RealA1CirCenter.x = Circle->FCP.x;
										 RealA1CirCenter.y = Circle->FCP.y;
										 ACirDiameter1     = (Circle->Diameter)/2.0;

										 // Circle In Data취합 
										 OrgA1CirInEdgeCount = Circle->FCirclePointCount;
										 if(OrgA1CirInEdgeCount>0){
											 if(OrgA1CirInPoint!=NULL) delete[] OrgA1CirInPoint;
											 OrgA1CirInPoint = new TFPoint[OrgA1CirInEdgeCount];

											 for(int k=0; k<OrgA1CirInEdgeCount; k++){
												 if(k>MAX_CIRCLE_EDGEPOINT) break;
												 OrgA1CirInPoint[k].x = Circle->FCirclePoint[k].x;
												 OrgA1CirInPoint[k].y = Circle->FCirclePoint[k].y;
												 if(OrgA1CirInPoint[k].x==0.0f && OrgA1CirInPoint[k].y==0.0f) A1CirInEdgeCount++;
											 }
										 }
										 //////////////////////////////////////////////////////////////////////////////////////////////////////

										 // Circle Out Data 다시 검사  
										 //////////////////////////////////////////////////////////////////////////////////////////////////////
										 Circle->SetTolerance(60.0f )      ; // Circle Tolerance 
										 Circle->SetDiameter (A1Diameter)  ; // Circle Diameter 
										 Circle->SetCircleChoice(1)        ; // 0:From Begin, 1:From End, 2:Largest Amplitude 
										 Circle->SetCircleType(2)          ; // 0:Black to White, 1:White to Black 2: Both Black, White 
										 Circle->SetCircleIndex (0)        ; // Circle EdgePoint Index 

										 Circle->OnExecute()               ;

										 // Circle Out Data취합 
										 OrgA1CirOutEdgeCount = Circle->FCirclePointCount;
										 if(OrgA1CirOutEdgeCount>0){
											 if(OrgA1CirOutPoint!=NULL) delete[] OrgA1CirOutPoint;
											 OrgA1CirOutPoint = new TFPoint[OrgA1CirOutEdgeCount];

											 for(int k=0; k<OrgA1CirOutEdgeCount; k++){
												 if(k>MAX_CIRCLE_EDGEPOINT) break;
												 OrgA1CirOutPoint[k].x = Circle->FCirclePoint[k].x;
												 OrgA1CirOutPoint[k].y = Circle->FCirclePoint[k].y;
												 // BTM영역 Circle을 제외한 영역 Defect검사 목적에 좌표계산 
												 if(k==0                     ) {TopEdgePoint[0].x = OrgA1CirOutPoint[k].x; TopEdgePoint[0].y = OrgA1CirOutPoint[k].y;}
												 if(k==OrgA1CirOutEdgeCount-1) {TopEdgePoint[1].x = OrgA1CirOutPoint[k].x; TopEdgePoint[1].y = OrgA1CirOutPoint[k].y;}
												 if(OrgA1CirOutPoint[k].x==0.0f && OrgA1CirOutPoint[k].y==0.0f) A1CirOutEdgeCount++;
											 }
										 }

										 // A1Circle Grind_Width Calculate (연마량 계산)
										 if(IsMarkBtm){ // LTPS경우 가공량 계산 ==> 연마량 계산 
											 if(OrgA1CirOutEdgeCount!=0 && OrgA1CirInEdgeCount!=0){ // MarkMode경우 가공량 검사를 먼저 진행 후 연마량 산출  
												 GrindMeaDis =0.0f, MinDis =10000.0f; A1GrindMarkCount=0;
												 if(GrindMarkPoint[25].x!=0.0f && GrindMarkPoint[25].y!=0.0f){  //GrindMark 찾았을경우 
													 for(int k=0; k<OrgA1CirOutEdgeCount; k++){
														 if(OrgA1CirOutPoint[k].x==0.0f || OrgA1CirOutPoint[k].y==0.0f) continue;
														 if(GrindMarkPoint[25].x  ==0.0f || GrindMarkPoint[25].y  ==0.0f) continue;

														 GrindMeaDis = Math.GetLength(GrindMarkPoint[25], OrgA1CirOutPoint[k]);
														 if(GrindMeaDis<MinDis){
															 MinDis = GrindMeaDis;
															 A1GrindMarkCount = k;
														 }
													 }
													 // GrindMark기준 수직 포인트 주변값 Avg산출한다 ==>가공량 측정 
													 if(A1GrindMarkCount!=0 && A1GrindMarkCount>5){
														 CircleCount=0,TotalCirDis=0.0f,GrindMeaDis=0.0f;
														 for(int k=A1GrindMarkCount-5; k<A1GrindMarkCount+5; k++){
															 if(OrgA1CirOutPoint[k].x==0.0f || OrgA1CirOutPoint[k].y==0.0f) continue;

															 GrindMeaDis = Math.GetLength(GrindMarkPoint[25], OrgA1CirOutPoint[k]);
															 TotalCirDis+= GrindMeaDis;
															 CircleCount++;
														 }
														 if(TotalCirDis!=0.0f && CircleCount!=0){
															 A1CirGrindMea[2] = TotalCirDis/CircleCount;
														 }
													 }

													 // GrindMark기준 수직 평균값 연마량 측정 
													 if(A1GrindMarkCount!=0 && A1GrindMarkCount>5){
														 CircleCount=0,TotalCirDis=0.0f,GrindWidthDis=0.0f;
														 for(int k=A1GrindMarkCount-5; k<A1GrindMarkCount+5; k++){
															 if(OrgA1CirOutPoint[k].x==0.0f && OrgA1CirOutPoint[k].y==0.0f) continue;
															 if(OrgA1CirInPoint [k].x==0.0f && OrgA1CirInPoint [k].y==0.0f) continue;
															 GrindWidthDis = Math.GetLength(OrgA1CirInPoint[k], OrgA1CirOutPoint[k]);
															 TotalCirDis+=   GrindWidthDis;
															 CircleCount++;
														 }
														 if(TotalCirDis!=0.0f && CircleCount!=0){
															 A1CirGrindWd[2] = TotalCirDis/CircleCount;
														 }
													 }
												 }
												 else {  //GrindMark 못 찾았을경우
													 for(int k=0; k<OrgA1CirOutEdgeCount; k++){
														 if(OrgA1CirOutPoint[k].x==0.0f || OrgA1CirOutPoint[k].y==0.0f) continue;

														 AGrindMarkRectPoint1.x = GrindMarkRect[25].left + (GrindMarkRect[25].right  - GrindMarkRect[25].left)/2; 
														 AGrindMarkRectPoint1.y = GrindMarkRect[25].top  + (GrindMarkRect[25].bottom - GrindMarkRect[25].top )/2; 

														 GrindMeaDis = Math.GetLength(AGrindMarkRectPoint1, OrgA1CirOutPoint[k]);
														 if(GrindMeaDis<MinDis){
															 MinDis = GrindMeaDis;
															 A1GrindMarkCount = k;
														 }
													 }
													 // GrindMark기준 수직 평균값 연마량 측정 
													 if(A1GrindMarkCount!=0 && A1GrindMarkCount>5 && (A1GrindMarkCount+5<OrgA1CirOutEdgeCount)){
														 CircleCount=0,TotalCirDis=0.0f,GrindWidthDis=0.0f;
														 for(int k=A1GrindMarkCount-5; k<A1GrindMarkCount+5; k++){
															 if(OrgA1CirOutPoint[k].x==0.0f && OrgA1CirOutPoint[k].y==0.0f) continue;
															 if(OrgA1CirInPoint [k].x==0.0f && OrgA1CirInPoint [k].y==0.0f) continue;
															 GrindWidthDis = Math.GetLength(OrgA1CirInPoint[k], OrgA1CirOutPoint[k]);
															 TotalCirDis+=   GrindWidthDis;
															 CircleCount++;
														 }
														 if(TotalCirDis!=0.0f && CircleCount!=0){
															 A1CirGrindWd[2] = TotalCirDis/CircleCount;
														 }
													 }
												 }
											 }
										 }
										 else     { // MarkMode ==> EnCap경우 연마량만 계산한다 
											 if(OrgA1CirInEdgeCount==OrgA1CirOutEdgeCount){
												 double OutDis=0.0f, InDis=0.0f, TotalGrindWidth=0.0f, AvgGrindWidth=0.0f;A1GrindWidthCount=0;
												 for(int k=0; k<OrgA1CirInEdgeCount; k++){
													 if(OrgA1CirOutPoint[k].x==0.0f && OrgA1CirOutPoint[k].y==0.0f){
														 OutDis =0.0f;
													 }
													 else {
														 OutDis = Math.GetLengthFrPointToPoint(A1CirCenter,OrgA1CirOutPoint[k]);
													 }

													 if(OrgA1CirInPoint[k].x==0.0f && OrgA1CirInPoint[k].y==0.0f){
														 InDis =0.0f;
													 }
													 else {
														 InDis = Math.GetLengthFrPointToPoint(A1CirCenter,OrgA1CirInPoint[k]);
													 }

													 // CircleFitting 진행시 실제 EdgePoint 데이터가 존재 할 경우만 포함하여 계산한다
													 if(OutDis!=0.0f && InDis!=0.0f){
														 TotalGrindWidth+=(OutDis - InDis);
														 A1GrindWidthCount++;
													 }
												 }
												 if(A1GrindWidthCount!=0){
													 AvgGrindWidth = (TotalGrindWidth/A1GrindWidthCount);
													 A1CirGrindWd[2] = AvgGrindWidth;
												 }
											 }
										 }

										 //////////////////////////////////////////////////////////////////////////////////////////////////////
										 // Org Circle데이터중 유호하지 않은 값을 제외한 실제 존재하는 데이터 기준으로 동적 메모리 생성함
										 // Circle Defect검사에 필요한 Edge데이터 값
										 int Count=0;
										 if(OrgA1CirInEdgeCount>0){ // A1 CircleInData
											 A1CirInEdgeCount = OrgA1CirInEdgeCount - A1CirInEdgeCount;
											 if(A1CirInEdgeCount>0){
												 if(A1CirInPoint!=NULL) delete[] A1CirInPoint;
												 A1CirInPoint = new TFPoint[A1CirInEdgeCount];

												 for(int k=0; k<OrgA1CirInEdgeCount; k++){
													 if(k>MAX_CIRCLE_EDGEPOINT) break;
													 if(OrgA1CirInPoint[k].x==0.0f && OrgA1CirInPoint[k].y==0.0f) continue;
													 A1CirInPoint[Count].x = OrgA1CirInPoint[k].x;
													 A1CirInPoint[Count].y = OrgA1CirInPoint[k].y;
													 Count++;
												 }
											 }
											 // Circle 원본 데이터 메모리 삭제
											 if(OrgA1CirInPoint!=NULL) delete[] OrgA1CirInPoint;
										 }
										 // FAVION Circle Fitting 결과물 
										 SampleSize = A1CirInEdgeCount*0.75; //0.5~0.8이하로 입력할것
										 DistDevRatio = 0.15; //0.1~0.25 이하로 입력할것
										 CircleFit->OnRansac(A1CirInPoint,A1CirInEdgeCount,SampleSize,DistDevRatio,&ACircleFit1Center,&ACirFitDiameter1);

										 if(OrgA1CirOutEdgeCount>0){// A1 CircleOutData 
											 A1CirOutEdgeCount = OrgA1CirOutEdgeCount - A1CirOutEdgeCount;
											 Count =0;
											 if(A1CirOutEdgeCount>0){
												 if(A1CirOutPoint!=NULL) delete[] A1CirOutPoint;
												 A1CirOutPoint = new TFPoint[A1CirOutEdgeCount];

												 for(int k=0; k<OrgA1CirOutEdgeCount; k++){
													 if(k>MAX_CIRCLE_EDGEPOINT) break;
													 if(OrgA1CirOutPoint[k].x==0.0f && OrgA1CirOutPoint[k].y==0.0f) continue;
													 A1CirOutPoint[Count].x = OrgA1CirOutPoint[k].x;
													 A1CirOutPoint[Count].y = OrgA1CirOutPoint[k].y;
													 Count++;
												 }
											 }
											 // Circle 원본 데이터 메모리 삭제
											 if(OrgA1CirOutPoint!=NULL) delete[] OrgA1CirOutPoint;
										 }
										 // Circle 영역 꽃박리, 원형박리 검출 목적 시퀀스(EnCap)
										 // 정식 명칭은 몰라서.....일단 Crack으로 정함 
										 // NOTCH LeftTop 박리 검사 
										 if(!IsMarkBtm && BrokenThresHold!=0){
											 RotateBrokenImg.SetSize(RotateImg.GetWidth(), RotateImg.GetHeight());
											 EasyImage::Oper(EArithmeticLogicOperation_Copy,&RotateImg,&RotateBrokenImg);
											 EasyImage::Threshold(&RotateImg,&RotateBrokenImg, BrokenThresHold);
											 // 										 RotateBrokenImg.Save("D:\\ROTATE_IMG\\RotateBrokenImg_HAP.bmp");

											 if(ACirFitDiameter1!=0.0f && ACircleFit1Center.x!=0.0f && ACircleFit1Center.y!=0.0f){ // FAVION Circle Fitting 성공시 박리검사 진행 
												 Circle->GImage = &RotateBrokenImg;                                             //Binary Image 넘겨줌 

												 Circle->SetCenterXY(ACircleFit1Center.x,ACircleFit1Center.y);
												 // 											 Circle->SetTolerance(CirCrackMargin)                      ; // Circle Tolerance 
												 // 											 Circle->SetDiameter ((ACirFitDiameter1-CirCrackMargin)*2)  ; // Circle Diameter 
												 Circle->SetTolerance((dEdgeToTrapLineDis/2)-CirOffsetMargin)      ; // Circle Tolerance 
												 Circle->SetDiameter ((ACirFitDiameter1-(dEdgeToTrapLineDis/2))*2) ; // Circle Diameter 
												 Circle->SetCircleChoice(0)                                ; // 0:From Begin, 1:From End, 2:Largest Amplitude 
												 Circle->SetCircleType  (0)                                ; // 0:Black to White, 1:White to Black 2: Both Black, White 
												 Circle->SetCircleIndex (0)                                ; // Circle EdgePoint Index 
												 Circle->SetAmplitude(25)                                  ; // 패턴으로 인해서 오버킬 발생...범위를 좁혀준다 
												 Circle->OnExecute(true)                                   ;
												 CrackACirDiameter1 = (ACirFitDiameter1-(dEdgeToTrapLineDis/2))+((dEdgeToTrapLineDis/2)-CirOffsetMargin);

												 A1CirInCrackCount = Circle->FCirclePointCount;

												 if(A1CirInCrackCount>0){
													 if(A1CirInCrackPoint!=NULL) delete[] A1CirInCrackPoint;
													 A1CirInCrackPoint = new TFPoint[A1CirInCrackCount];

													 for(int k=0; k<A1CirInCrackCount; k++){
														 if(k>MAX_CIRCLE_EDGEPOINT) break;
														 A1CirInCrackPoint[k].x = Circle->FCirclePoint[k].x;
														 A1CirInCrackPoint[k].y = Circle->FCirclePoint[k].y;
													 }
												 }
											 }
										 }
									 }
									 LogUnit.SetLog(L"LeftTop_Mark_END");     
								 }
							 }
        				 }

						 if(FRightTop){
// 							 LogUnit.SetLog("shRectH_Rotate_RightTop_Start");     
							 EasyImage::Threshold(&RotateImg,&RotateBinaryImg, ECThresHold);
							 EasyImage::Threshold(&RotateImg,&RotateGrindBinaryImg, CorGrindMeaThresHold);
//							 RotateBinaryImg.Save("D:\\ROTATE_IMG\\RotateBinaryImg회전_HAP.bmp");

							 if(ECThresHold==0)  {SingleLine->GImage = &RotateImg      ;  SingleLine->FThreshold =5 ;}
							 else                {SingleLine->GImage = &RotateBinaryImg;  SingleLine->FThreshold =10;}

							 OrgPoint = Math.OnIntersect(Line[waRightWall].FP0, Line[waRightWall].FP1, Line[waTopWall].FP0, Line[waTopWall].FP1);
							 FRTPoint = OrgPoint;

							 if(IsCornerTop){
								 if(AMarkToGrindMarkDvX==0.0f && AMarkToGrindMarkDvY==0.0f){ // 3Point 기준으로 가공량 측정 방법 적용 시퀀스 
									 SingleLine->IRoi->SetOrgX  ((int)(OrgPoint.x-RTCornerWidth));
									 SingleLine->IRoi->SetOrgY  ((int) OrgPoint.y               );
									 SingleLine->IRoi->SetWidth (RTCornerWidth +10              );
									 SingleLine->IRoi->SetHeight(RTCornerHeight                 );

									 SingleLine->SetOrientation(orEast);
									 SingleLine->FIncrement =1;
									 SingleLine->FThreshold =15;
									 SingleLine->SetFindLineId(0);
									 SingleLine->SetEdgeType(1);  //White To Black 
									 SingleLine->OnExecute();
									 Line[waRightTop].FP0 = SingleLine->GetResultP0();
									 Line[waRightTop].FP1 = SingleLine->GetResultP1();

									 // ORG 
									 FRTRPoint = Math.OnIntersect(SingleLine->GetResultP0(), SingleLine->GetResultP1(), Line[waRightWall].FP0, Line[waRightWall].FP1);
									 FRTTPoint = Math.OnIntersect(SingleLine->GetResultP0(), SingleLine->GetResultP1(), Line[waTopWall  ].FP0, Line[waTopWall].FP1  );

									 if((FRTRPoint.x==0 || FRTRPoint.y==0 || FRTTPoint.x==0 || FRTTPoint.y==0) || (SingleLine->FEdgePointCount <30)){
										 RTDx = 0.0f;
										 RTDy = 0.0f;
										 //화면에 디스플레이 위해서 
										 FRTRPoint.x = FRTPoint.x;
										 FRTRPoint.y = FRTPoint.y;
										 FRTTPoint.x = FRTPoint.x;
										 FRTTPoint.y = FRTPoint.y;
									 }
									 else {
										 RTDx = Math.GetLengthFrPointToPoint(FRTPoint, FRTTPoint);
										 RTDy = Math.GetLengthFrPointToPoint(FRTPoint, FRTRPoint);

										 // OutLine C2Corner Data 
										 if((SingleLine->FEdgePointCount) - (CornerMargin*2)>0){
											 if(C2Point!=NULL) delete[] C2Point;
											 C2Point  = new TFPoint [(SingleLine->FEdgePointCount) - (CornerMargin*2)];
											 C2EdgeCount = (SingleLine->FEdgePointCount) -(CornerMargin*2);

											 CornerCount =0;  
											 for(int k=CornerMargin; k<((SingleLine->FEdgePointCount)-CornerMargin); k++){
												 if(CornerCount>=MAX_CORNER_POINT) break;
												 C2Point[CornerCount].x = SingleLine->FEdgePoint[k].x;
												 C2Point[CornerCount].y = SingleLine->FEdgePoint[k].y;
												 CornerCount++;
											 }
										 }

										 // Value Init 
										 double Dis =0.0f, AvgGrindWidth=0.0f, AvgGrindMea=0.0f, TotalGrindWidth=0.0f, TotalGrindMeasure=0.0f;

										 // Corner Grind In Start 
										 if(CorGrindInThresHold!=0){
											 EasyImage::Threshold(&RotateImg,&RotateBinaryImg, CorGrindInThresHold);
											 SingleLine->GImage = &RotateBinaryImg;  SingleLine->FThreshold =10;

											 // Corner 기울기 완만하여 Edge찾을 경우 Defect 오버킬 발생함 
											 // 방향을 Top방향에서 다시 엣지를 찾음 (Corner Defect OverKill 감소 목적)
											 // if(RTCornerWidth >(RTCornerHeight*3)){
											 if(RTCornerWidth >(RTCornerHeight*1.5)){
												 if(FRTTPoint.x!=0.0f && FRTTPoint.y!=0.0f && FRTRPoint.x!=0.0f && FRTRPoint.y!=0.0f){

													 SingleLine->IRoi->SetOrgX  ((int)(FRTPoint.x-(FRTRPoint.x-FRTTPoint.x)+5));
													 SingleLine->IRoi->SetOrgY  ((int) FRTPoint.y                             );
													 SingleLine->IRoi->SetWidth ((int)((FRTRPoint.x-FRTTPoint.x)+5)           );
													 SingleLine->IRoi->SetHeight((int)((FRTRPoint.y - FRTTPoint.y)+10)        );

													 if(FRTTPoint.x<=0    || FRTTPoint.y<=0    || (FRTRPoint.x - FRTTPoint.x)<=0    || (FRTRPoint.y - FRTTPoint.y)<=0   ) return false;
													 if(FRTTPoint.x>=ImgW || FRTTPoint.y>=ImgH || (FRTRPoint.x - FRTTPoint.x)>=ImgW || (FRTRPoint.y - FRTTPoint.y)>=ImgH) return false;

													 SingleLine->SetOrientation(orNorth);
													 SingleLine->FIncrement =2;
													 SingleLine->SetFindLineId(0);
													 SingleLine->SetEdgeType(0);  //Black To White 
													 SingleLine->OnExecute();

													 // InLine C2Corner Data 
													 if((SingleLine->FEdgePointCount) - (CornerMargin*2)>0){
														 if(C2InPoint!=NULL) delete[] C2InPoint;
														 C2InPoint  = new TFPoint [(SingleLine->FEdgePointCount) - (CornerMargin*2)];
														 C2InEdgeCount = (SingleLine->FEdgePointCount) -(CornerMargin*2);

														 CornerCount =0;  
														 for(int k=CornerMargin; k<((SingleLine->FEdgePointCount)-CornerMargin); k++){
															 if(CornerCount>=MAX_CORNER_POINT) break;
															 C2InPoint[CornerCount].x = SingleLine->FEdgePoint[k].x;
															 C2InPoint[CornerCount].y = SingleLine->FEdgePoint[k].y;
															 CornerCount++;
														 }
													 }
												 }
											 }
											 else {
												 // Corner 연마 안쪽라인 찾는다 
												 SingleLine->SetOrientation(orEast);
												 SingleLine->SetFindLineId(0);
												 SingleLine->FIncrement =1;
												 SingleLine->SetEdgeType(0);  //Black To White 
												 SingleLine->OnExecute();

												 // InLine C2Corner Data 
												 if((SingleLine->FEdgePointCount) - (CornerMargin*2)>0){
													 if(C2InPoint!=NULL) delete[] C2InPoint;
													 C2InPoint  = new TFPoint [(SingleLine->FEdgePointCount) - (CornerMargin*2)];
													 C2InEdgeCount = (SingleLine->FEdgePointCount) -(CornerMargin*2);

													 CornerCount =0;  
													 for(int k=CornerMargin; k<((SingleLine->FEdgePointCount)-CornerMargin); k++){
														 if(CornerCount>=MAX_CORNER_POINT) break;
														 C2InPoint[CornerCount].x = SingleLine->FEdgePoint[k].x;
														 C2InPoint[CornerCount].y = SingleLine->FEdgePoint[k].y;
														 CornerCount++;
													 }
												 }
											 }

											 //코너 연마안쪽라인 기준 새로운 교차점 생성 
											 FRTRInPoint = Math.OnIntersect(SingleLine->GetResultP0(), SingleLine->GetResultP1(), Line[waRightWall].FP0, Line[waRightWall].FP1);
											 FRTTInPoint = Math.OnIntersect(SingleLine->GetResultP0(), SingleLine->GetResultP1(), Line[waTopWall  ].FP0, Line[waTopWall].FP1  );

											 //코너 연마폭, 연마량 계산 
											 Dis =0.0f, AvgGrindWidth=0.0f, AvgGrindMea=0.0f, TotalGrindWidth=0.0f, TotalGrindMeasure=0.0f;
											 for(int k=0; k<C2InEdgeCount; k++){
												 Dis = Math.GetLengthFrLineToPoint(FRTRPoint, FRTTPoint, C2InPoint[k]);
												 TotalGrindWidth+=Dis;
											 }
											 if(C2InEdgeCount!=0){
												 AvgGrindWidth = (TotalGrindWidth/C2InEdgeCount);
												 C2CorGrindWd  = AvgGrindWidth;
											 }
										 }

										 if(CorGrindMeaThresHold!=0){ // Corner Grind ThresHold값이 설정되어 있을경우만 연마량 검사를 진행한다 
											 // 코너 연마량 기준 라인을 찾는다 
											 // ROI 영역 설정 
											 if(CorGrindMeaThresHold==0){SingleLine->GImage = &RotateImg           ;  SingleLine->FThreshold =5 ;}
											 else                       {SingleLine->GImage = &RotateGrindBinaryImg;  SingleLine->FThreshold =10;}

											 // 존나 찝찝함....일단 스팩을 받기전까지 임시로 영역을 분류하여 CornerEdgePoint 찾자 
											 if(RTCornerWidth >(RTCornerHeight*1.5)){
												 SingleLine->IRoi->SetOrgX  ((int) OrgPoint.x-(RTCornerWidth-50));
												 SingleLine->IRoi->SetOrgY  ((int) OrgPoint.y+30                );
												 SingleLine->IRoi->SetWidth (RTCornerWidth -50                  );
												 SingleLine->IRoi->SetHeight(RTCornerHeight-40                  );

												 SingleLine->SetOrientation(orNorth);
												 SingleLine->SetFindLineId(0);
												 SingleLine->FIncrement =1;
												 SingleLine->SetEdgeType(0);  //Black To White 
												 SingleLine->OnExecute();

												 P1 = SingleLine->GetResultP0();
												 P2 = SingleLine->GetResultP1();

												 //코너 연마안쪽라인 기준 새로운 교차점 생성 
												 FRTRMeaPoint = Math.OnIntersect(SingleLine->GetResultP0(), SingleLine->GetResultP1(), Line[waRightWall].FP0, Line[waRightWall].FP1);
												 FRTTMeaPoint = Math.OnIntersect(SingleLine->GetResultP0(), SingleLine->GetResultP1(), Line[waTopWall  ].FP0, Line[waTopWall].FP1  );

												 // C1Corner Grind Measure Stand Data 
												 if((SingleLine->FEdgePointCount)>0){
													 if(C2MeaPoint!=NULL) delete[] C2MeaPoint;
													 C2MeaPoint     = new TFPoint [(SingleLine->FEdgePointCount)];
													 C2MeaEdgeCount = (SingleLine->FEdgePointCount);

													 CornerCount =0;  
													 for(int k=0; k<(SingleLine->FEdgePointCount); k++){
														 if(CornerCount>=MAX_CORNER_POINT) break;
														 C2MeaPoint[CornerCount].x = SingleLine->FEdgePoint[k].x;
														 C2MeaPoint[CornerCount].y = SingleLine->FEdgePoint[k].y;
														 CornerCount++;
													 }
												 }
												 //코너 연마량 계산  
												 Dis =0.0f, AvgGrindMea=0.0f, TotalGrindMeasure=0.0f;
												 for(int k=0; k<C2EdgeCount; k++){
													 Dis = Math.GetLengthFrLineToPoint(FRTRMeaPoint, FRTTMeaPoint, C2Point[k]);
													 TotalGrindMeasure+=Dis;
												 }
												 if(C2EdgeCount!=0){
													 AvgGrindMea    = (TotalGrindMeasure/C2EdgeCount);
													 C2CorGrindMea  = AvgGrindMea;
												 }
											 }
											 else {
												 // 											 SingleLine->IRoi->SetOrgX  ((int) OrgPoint.x-RTCornerWidth    );
												 SingleLine->IRoi->SetOrgX  ((int) OrgPoint.x-RTCornerWidth+20 );
												 SingleLine->IRoi->SetOrgY  ((int) OrgPoint.y+15               );
												 SingleLine->IRoi->SetWidth (RTCornerWidth                     );
												 // 											 SingleLine->IRoi->SetHeight(RTCornerHeight                    );
												 SingleLine->IRoi->SetHeight(RTCornerHeight+10                 );

												 SingleLine->SetOrientation(orEast);
												 SingleLine->SetFindLineId(0);
												 SingleLine->FIncrement =1;
												 SingleLine->SetEdgeType(0);  //Black To White 
												 SingleLine->OnExecute();

												 P1 = SingleLine->GetResultP0();
												 P2 = SingleLine->GetResultP1();

												 //코너 연마안쪽라인 기준 새로운 교차점 생성 
												 FRTRMeaPoint = Math.OnIntersect(SingleLine->GetResultP0(), SingleLine->GetResultP1(), Line[waRightWall].FP0, Line[waRightWall].FP1);
												 FRTTMeaPoint = Math.OnIntersect(SingleLine->GetResultP0(), SingleLine->GetResultP1(), Line[waTopWall  ].FP0, Line[waTopWall].FP1  );

												 // C1Corner Grind Measure Stand Data 
												 if((SingleLine->FEdgePointCount)>0){
													 if(C2MeaPoint!=NULL) delete[] C2MeaPoint;
													 C2MeaPoint     = new TFPoint [(SingleLine->FEdgePointCount)];
													 C2MeaEdgeCount = (SingleLine->FEdgePointCount);

													 CornerCount =0;  
													 for(int k=0; k<(SingleLine->FEdgePointCount); k++){
														 if(CornerCount>=MAX_CORNER_POINT) break;
														 C2MeaPoint[CornerCount].x = SingleLine->FEdgePoint[k].x;
														 C2MeaPoint[CornerCount].y = SingleLine->FEdgePoint[k].y;
														 CornerCount++;
													 }
												 }
												 //코너 연마량 계산  
												 Dis =0.0f, AvgGrindMea=0.0f, TotalGrindMeasure=0.0f;
												 for(int k=0; k<C2EdgeCount; k++){
													 Dis = Math.GetLengthFrLineToPoint(FRTRMeaPoint, FRTTMeaPoint, C2Point[k]);
													 TotalGrindMeasure+=Dis;
												 }
												 if(C2EdgeCount!=0){
													 AvgGrindMea    = (TotalGrindMeasure/C2EdgeCount);
													 C2CorGrindMea  = AvgGrindMea;
												 }
											 }
										 }
									 }
								 }
								 else { //십자가 마크 기준 연마량,가공량 측정 시퀀스 
									 TFPoint C2GrindRectPoint(0.0f, 0.0f);

									 SingleLine->IRoi->SetOrgX  ((int)(OrgPoint.x-RTCornerWidth));
									 SingleLine->IRoi->SetOrgY  ((int) OrgPoint.y               );
									 SingleLine->IRoi->SetWidth (RTCornerWidth +10              );
									 SingleLine->IRoi->SetHeight(RTCornerHeight                 );

									 SingleLine->SetOrientation(orEast);
									 SingleLine->FIncrement =1;
									 SingleLine->FThreshold =15;
									 SingleLine->SetFindLineId(0);
									 SingleLine->SetEdgeType(1);  //White To Black 
									 SingleLine->OnExecute();
									 Line[waRightTop].FP0 = SingleLine->GetResultP0();
									 Line[waRightTop].FP1 = SingleLine->GetResultP1();

									 // ORG 
									 FRTRPoint = Math.OnIntersect(SingleLine->GetResultP0(), SingleLine->GetResultP1(), Line[waRightWall].FP0, Line[waRightWall].FP1);
									 FRTTPoint = Math.OnIntersect(SingleLine->GetResultP0(), SingleLine->GetResultP1(), Line[waTopWall  ].FP0, Line[waTopWall].FP1  );

									 if((FRTRPoint.x==0 || FRTRPoint.y==0 || FRTTPoint.x==0 || FRTTPoint.y==0) || (SingleLine->FEdgePointCount <30)){
										 RTDx = 0.0f;
										 RTDy = 0.0f;
										 //화면에 디스플레이 위해서 
										 FRTRPoint.x = FRTPoint.x;
										 FRTRPoint.y = FRTPoint.y;
										 FRTTPoint.x = FRTPoint.x;
										 FRTTPoint.y = FRTPoint.y;
									 }
									 else {
										 RTDx = Math.GetLengthFrPointToPoint(FRTPoint, FRTTPoint);
										 RTDy = Math.GetLengthFrPointToPoint(FRTPoint, FRTRPoint);

										 // OutLine C2Corner Data 
										 if((SingleLine->FEdgePointCount) - (CornerMargin*2)>0){
											 if(C2Point!=NULL) delete[] C2Point;
											 C2Point  = new TFPoint [(SingleLine->FEdgePointCount) - (CornerMargin*2)];
											 C2EdgeCount = (SingleLine->FEdgePointCount) -(CornerMargin*2);

											 CornerCount =0;  
											 for(int k=CornerMargin; k<((SingleLine->FEdgePointCount)-CornerMargin); k++){
												 if(CornerCount>=MAX_CORNER_POINT) break;
												 C2Point[CornerCount].x = SingleLine->FEdgePoint[k].x;
												 C2Point[CornerCount].y = SingleLine->FEdgePoint[k].y;
												 CornerCount++;
											 }
										 }

										 // Value Init 
										 double Dis =0.0f, AvgGrindWidth=0.0f, AvgGrindMea=0.0f, TotalGrindWidth=0.0f, TotalGrindMeasure=0.0f;

										 // Corner Grind In Start 
										 if(CorGrindInThresHold!=0){
											 EasyImage::Threshold(&RotateImg,&RotateBinaryImg, CorGrindInThresHold);
											 SingleLine->GImage = &RotateBinaryImg;  SingleLine->FThreshold =10;

											 // Corner 기울기 완만하여 Edge찾을 경우 Defect 오버킬 발생함 
											 // 방향을 Top방향에서 다시 엣지를 찾음 (Corner Defect OverKill 감소 목적)
											 // if(RTCornerWidth >(RTCornerHeight*3)){
											 if(RTCornerWidth >(RTCornerHeight*1.5)){
												 if(FRTTPoint.x!=0.0f && FRTTPoint.y!=0.0f && FRTRPoint.x!=0.0f && FRTRPoint.y!=0.0f){

													 SingleLine->IRoi->SetOrgX  ((int)(FRTPoint.x-(FRTRPoint.x-FRTTPoint.x)+5));
													 SingleLine->IRoi->SetOrgY  ((int) FRTPoint.y                             );
													 SingleLine->IRoi->SetWidth ((int)((FRTRPoint.x-FRTTPoint.x)+5)           );
													 SingleLine->IRoi->SetHeight((int)((FRTRPoint.y - FRTTPoint.y)+10)        );

													 if(FRTTPoint.x<=0    || FRTTPoint.y<=0    || (FRTRPoint.x - FRTTPoint.x)<=0    || (FRTRPoint.y - FRTTPoint.y)<=0   ) return false;
													 if(FRTTPoint.x>=ImgW || FRTTPoint.y>=ImgH || (FRTRPoint.x - FRTTPoint.x)>=ImgW || (FRTRPoint.y - FRTTPoint.y)>=ImgH) return false;

													 SingleLine->SetOrientation(orNorth);
													 SingleLine->FIncrement =2;
													 SingleLine->SetFindLineId(0);
													 SingleLine->SetEdgeType(0);  //Black To White 
													 SingleLine->OnExecute();

													 // InLine C2Corner Data 
													 if((SingleLine->FEdgePointCount) - (CornerMargin*2)>0){
														 if(C2InPoint!=NULL) delete[] C2InPoint;
														 C2InPoint  = new TFPoint [(SingleLine->FEdgePointCount) - (CornerMargin*2)];
														 C2InEdgeCount = (SingleLine->FEdgePointCount) -(CornerMargin*2);

														 CornerCount =0;  
														 for(int k=CornerMargin; k<((SingleLine->FEdgePointCount)-CornerMargin); k++){
															 if(CornerCount>=MAX_CORNER_POINT) break;
															 C2InPoint[CornerCount].x = SingleLine->FEdgePoint[k].x;
															 C2InPoint[CornerCount].y = SingleLine->FEdgePoint[k].y;
															 CornerCount++;
														 }
													 }
												 }
											 }
											 else {
												 // Corner 연마 안쪽라인 찾는다 
												 SingleLine->SetOrientation(orEast);
												 SingleLine->SetFindLineId(0);
												 SingleLine->FIncrement =1;
												 SingleLine->SetEdgeType(0);  //Black To White 
												 SingleLine->OnExecute();

												 // InLine C2Corner Data 
												 if((SingleLine->FEdgePointCount) - (CornerMargin*2)>0){
													 if(C2InPoint!=NULL) delete[] C2InPoint;
													 C2InPoint  = new TFPoint [(SingleLine->FEdgePointCount) - (CornerMargin*2)];
													 C2InEdgeCount = (SingleLine->FEdgePointCount) -(CornerMargin*2);

													 CornerCount =0;  
													 for(int k=CornerMargin; k<((SingleLine->FEdgePointCount)-CornerMargin); k++){
														 if(CornerCount>=MAX_CORNER_POINT) break;
														 C2InPoint[CornerCount].x = SingleLine->FEdgePoint[k].x;
														 C2InPoint[CornerCount].y = SingleLine->FEdgePoint[k].y;
														 CornerCount++;
													 }
												 }
											 }

											 //코너 연마안쪽라인 기준 새로운 교차점 생성 
											 FRTRInPoint = Math.OnIntersect(SingleLine->GetResultP0(), SingleLine->GetResultP1(), Line[waRightWall].FP0, Line[waRightWall].FP1);
											 FRTTInPoint = Math.OnIntersect(SingleLine->GetResultP0(), SingleLine->GetResultP1(), Line[waTopWall  ].FP0, Line[waTopWall].FP1  );
										 }

										 // GrindMark기준 연마량,가공량 측정함 
										 // RightTop Corner Mark Find 
										 if(FP1.x!=0.0f && FP1.y!=0.0f){
											 GrindMarkRect[20].left   = (FP1.x+AMarkToGrindMarkDvX)-40;
											 GrindMarkRect[20].top    = (FP1.y+AMarkToGrindMarkDvY)-40;
											 GrindMarkRect[20].right  = (GrindMarkRect[20].left + 80);
											 GrindMarkRect[20].bottom = (GrindMarkRect[20].top  + 80);

											 GrindRectWidth  = (GrindMarkRect[20].right  - GrindMarkRect[20].left);
											 GrindRectHeight = (GrindMarkRect[20].bottom - GrindMarkRect[20].top );

											 // 원본이미지에서 Mark 찾는다 
											 Find->OnLoad(true,FindDir,1)                   ;
											 Find->GImage = &RotateImg                      ;
											 //Find->SetContrastMode(EFindContrastMode_Any)   ;
											 Find->SetContrastMode(EFindContrastMode_Normal);
											 //Find->SetMinScore(0.8f)                        ;
											 Find->SetMinScore (GrindPadMarkMinScore)       ; // PatternrFind 검사 최소 Score
											 Find->SetZeroScore(GrindPadMarkMinScore)       ; // 검사 후 최소 Score 
											 //ind->SetMinScore (0.75)                       ; // PatternrFind 검사 최소 Score
											 //ind->SetZeroScore(0.75)                       ; // 검사 후 최소 Score 
											 Find->SetMaxInstances(1)                       ;
											 Find->SetAngleTolerance(20.0f)                 ;
											 Find->SetAngleBias(135.0f)                     ;
											 Find->SetScaleBias(1.00f)                      ;
											 Find->SetScaleTolerance(0.0f)                  ;
											 Find->Property.Ox = (float)ImgW/2              ;
											 Find->Property.Oy = (float)ImgH/2              ;

											 Find->IRoi->SetPlacement(GrindMarkRect[20].left,GrindMarkRect[20].top,GrindRectWidth,GrindRectHeight);
											 if(GrindMarkRect[20].left<=0 || GrindMarkRect[20].top<=0 || GrindRectWidth<=0 || GrindRectHeight<=0) return false;

											 // 검사 및 Match Pos 좌표 받어온다 
											 // Find 검사 성공시 데이터 받아옴 
											 if(Find->OnExecute()){
												 GrindMarkPoint[20].x = Find->Result[0].Px;
												 GrindMarkPoint[20].y = Find->Result[0].Py;
												 GrindMarkScore[20]   = Find->Result[0].Score;
											 }
											 // Contrast Gradient Pixel Value
											 GrindMarkGradient[20] = EasyImage::Focusing(Find->IRoi);
										 }

										 // GrindMakr찾을경우 연마량,가공량 측정함
										 if(GrindMarkPoint[20].x!=0.0f && GrindMarkPoint[20].y!=0.0f){
											 // GrindMark기준 OutData 최단거리 Count정보 Calc 
											 GrindMeaDis =0.0f, MinDis =10000.0f; GrindMarkOutCnt=0;
											 for(int k=0; k<C2EdgeCount; k++){
												 if(C2Point[k].x  ==0.0f       || C2Point[k].y        ==0.0f) continue;
												 if(GrindMarkPoint[20].x==0.0f || GrindMarkPoint[20].y==0.0f) continue;

												 GrindMeaDis = Math.GetLength(GrindMarkPoint[20], C2Point[k]);
												 if(GrindMeaDis<MinDis){
													 MinDis = GrindMeaDis;
													 GrindMarkOutCnt = k;
												 }
											 }
											 // OutData기준 InData 최단거리 Count정보 Calc 
											 if(GrindMarkOutCnt!=0){
												 GrindMeaDis =0.0f, MinDis =10000.0f; GrindMarkInCnt=0;
												 for(int k=0; k<C2InEdgeCount; k++){
													 if(C2InPoint[k].x   ==0.0f          || C2InPoint[k].y             ==0.0f) continue;
													 if(C2Point[GrindMarkOutCnt].x==0.0f || C2Point[GrindMarkOutCnt].y ==0.0f) continue;

													 GrindMeaDis = Math.GetLength(C2Point[GrindMarkOutCnt], C2InPoint[k]);
													 if(GrindMeaDis<MinDis){
														 MinDis = GrindMeaDis;
														 GrindMarkInCnt = k;
													 }
												 }
											 }

											 // GrindMark기준 수직 포인트 주변값 Avg산출한다 ==>가공량 측정(OutData기준)
											 if(GrindMarkOutCnt!=0 && GrindMarkOutCnt>5){
												 CircleCount=0,TotalCirDis=0.0f,GrindMeaDis=0.0f;
												 for(int k=GrindMarkOutCnt-5; k<GrindMarkOutCnt+5; k++){
													 if(C2Point[k].x==0.0f || C2Point[k].y==0.0f) continue;

													 GrindMeaDis = Math.GetLength(GrindMarkPoint[20], C2Point[k]);
													 TotalCirDis+= GrindMeaDis;
													 CircleCount++;
												 }
												 if(TotalCirDis!=0.0f && CircleCount!=0){
													 C2CorGrindMea = TotalCirDis/CircleCount;
												 }
											 }

											 // GrindMark기준 수직 포인트 주변값 Avg산출한다 ==>연마량 측정(OutData,InData기준)
											 if((GrindMarkOutCnt!=0 && GrindMarkOutCnt>5) && (GrindMarkInCnt!=0 && GrindMarkInCnt>5)){
												 CircleCount=0,TotalCirDis=0.0f,GrindWidthDis=0.0f;
												 for(int k=-5; k<5; k++){
													 if(C2Point  [GrindMarkOutCnt+k].x==0.0f && C2Point  [GrindMarkOutCnt+k].y==0.0f) continue;
													 if(C2InPoint[GrindMarkInCnt +k].x==0.0f && C2InPoint[GrindMarkInCnt +k].y==0.0f) continue;
													 GrindWidthDis = Math.GetLength(C2InPoint[GrindMarkInCnt+k], C2Point[GrindMarkOutCnt+k]);
													 TotalCirDis+=   GrindWidthDis;
													 CircleCount++;
												 }
												 if(TotalCirDis!=0.0f && CircleCount!=0){
													 C2CorGrindWd  = TotalCirDis/CircleCount;
												 }
											 }
										 }
										 else { // GrindMrk 못찾을경우 연마량만 측정함 
											 // OutData기준 최소값 데이터 Count산출 
											 GrindMeaDis =0.0f, MinDis =10000.0f; GrindMarkOutCnt=0;
											 for(int k=0; k<C2EdgeCount; k++){
												 if(C2Point[k].x==0.0f || C2Point[k].y==0.0f) continue;

												 C2GrindRectPoint.x = GrindMarkRect[20].left + (GrindMarkRect[20].right  - GrindMarkRect[20].left)/2; 
												 C2GrindRectPoint.y = GrindMarkRect[20].top  + (GrindMarkRect[20].bottom - GrindMarkRect[20].top )/2; 

												 GrindMeaDis = Math.GetLength(C2GrindRectPoint, C2Point[k]);
												 if(GrindMeaDis<MinDis){
													 MinDis = GrindMeaDis;
													 GrindMarkOutCnt = k;
												 }
											 }

											 // 최단거리OUtCount기준 InData 최단거리 Count정보 Calc 
											 if(GrindMarkOutCnt!=0){
												 GrindMeaDis =0.0f, MinDis =10000.0f; GrindMarkInCnt=0;
												 for(int k=0; k<C2InEdgeCount; k++){
													 if(C2InPoint[k].x            ==0.0f || C2InPoint[k].y             ==0.0f) continue;
													 if(C2Point[GrindMarkOutCnt].x==0.0f || C2Point[GrindMarkOutCnt].y ==0.0f) continue;

													 GrindMeaDis = Math.GetLength(C2Point[GrindMarkOutCnt], C2InPoint[k]);
													 if(GrindMeaDis<MinDis){
														 MinDis = GrindMeaDis;
														 GrindMarkInCnt = k;
													 }
												 }
											 }

											 // GrindMark기준 수직 포인트 주변값 Avg산출한다 ==>연마량 측정(OutData,InData기준)
											 if((GrindMarkOutCnt!=0 && GrindMarkOutCnt>5) && (GrindMarkInCnt!=0 && GrindMarkInCnt>5)){
												 CircleCount=0,TotalCirDis=0.0f,GrindWidthDis=0.0f;
												 for(int k=-5; k<5; k++){
													 if(C2Point  [GrindMarkOutCnt+k].x==0.0f && C2Point  [GrindMarkOutCnt+k].y==0.0f) continue;
													 if(C2InPoint[GrindMarkInCnt +k].x==0.0f && C2InPoint[GrindMarkInCnt +k].y==0.0f) continue;
													 GrindWidthDis = Math.GetLength(C2InPoint[GrindMarkInCnt+k], C2Point[GrindMarkOutCnt+k]);
													 TotalCirDis+=   GrindWidthDis;
													 CircleCount++;
												 }
												 if(TotalCirDis!=0.0f && CircleCount!=0){
													 C2CorGrindWd = TotalCirDis/CircleCount;
												 }
											 }
										 }
									 }
								 }
							 }
							 else if(IsRectTop){
								 RTDx = 0.0f;
								 RTDy = 0.0f;
								 //화면에 디스플레이 위해서 
								 FRTRPoint.x = FRTPoint.x;
								 FRTRPoint.y = FRTPoint.y;
								 FRTTPoint.x = FRTPoint.x;
								 FRTTPoint.y = FRTPoint.y;
							 }
							 else if(IsCircleTop){ // TOP영역 RightTop Circle 검사  A2Circle 
								 // Org A1CircleData 
								 int OrgA2CirInEdgeCount =0;		  
								 int OrgA2CirOutEdgeCount=0;	    
								 int A2GrindWidthCount   =0;		  
								 int A2GrindMarkCount    =0;
								 int A2Diameter          =0;
								 GrindRectWidth          =0;
								 GrindRectHeight         =0;

								 TFPoint *OrgA2CirInPoint =NULL;	 
								 TFPoint *OrgA2CirOutPoint=NULL;

								 TFPoint AGrindMarkRectPoint2(0.0f, 0.0f);

								 // Find Mark Search Start
								 ////////////////////////////////////////////////////////////////////////////
								 if(IsMarkBtm && FInspectMode!=Insp_Track){
									 LogUnit.SetLog(L"CellID:%d, CamID:%d ==>A2MarkFind_START",CellId,CamId);     

									 if(FP1.x!=0.0f && FP1.y!=0.0f){
										 Find->OnLoad(true,FindDir,1)                   ;
										 Find->GImage = &RotateImg                      ;
										 Find->SetContrastMode(EFindContrastMode_Normal);
// 										 Find->SetContrastMode(EFindContrastMode_Any    );
// 										 Find->SetMinScore(0.8f)                        ;
										 Find->SetMinScore (GrindPadMarkMinScore)       ; // PatternrFind 검사 최소 Score
										 Find->SetZeroScore(GrindPadMarkMinScore)       ; // 검사 후 최소 Score 
// 										 Find->SetMinScore (0.75)                       ; // PatternrFind 검사 최소 Score
// 										 Find->SetZeroScore(0.75)                       ; // 검사 후 최소 Score 
										 Find->SetMaxInstances(1)                       ;
										 Find->SetAngleTolerance(20.0f)                 ;
// 										 Find->SetAngleBias(135.0f)                     ;
										 Find->SetScaleBias(1.00f)                      ;
										 Find->SetScaleTolerance(0.0f)                  ;
										 Find->Property.Ox = (float)ImgW/2              ;
										 Find->Property.Oy = (float)ImgH/2              ;

										 // 첫번째 GrindMark기준 센터 20번 Search
										 if(AMarkToGrindMarkDvX!=0.0f && AMarkToGrindMarkDvX!=0.0f){
											 GrindMarkRect[20].left   = (FP1.x+AMarkToGrindMarkDvX)-40;
											 GrindMarkRect[20].top    = (FP1.y+AMarkToGrindMarkDvY)-40;
											 GrindMarkRect[20].right  = (GrindMarkRect[20].left + 80);
											 GrindMarkRect[20].bottom = (GrindMarkRect[20].top  + 80);

											 GrindRectWidth  = (GrindMarkRect[20].right  - GrindMarkRect[20].left);
											 GrindRectHeight = (GrindMarkRect[20].bottom - GrindMarkRect[20].top );

											 Find->IRoi->SetPlacement(GrindMarkRect[20].left,GrindMarkRect[20].top,GrindRectWidth,GrindRectHeight);
											 if(GrindMarkRect[20].left<=0 || GrindMarkRect[20].top<=0 || GrindRectWidth<=0 || GrindRectHeight<=0) return false;

											 // 검사 및 Match Pos 좌표 받어온다 
											 // Find 검사 성공시 데이터 받아옴 
											 Find->SetAngleBias(135.0f);
											 if(Find->OnExecute()){
												 GrindMarkPoint[20].x = Find->Result[0].Px;
												 GrindMarkPoint[20].y = Find->Result[0].Py;
												 GrindMarkScore[20]   = Find->Result[0].Score;
											 }
											 // Contrast Gradient Pixel Value
											 GrindMarkGradient[20] = EasyImage::Focusing(Find->IRoi);
										 }

										 // 두번째 GrindMark기준 센터 20번 Search
										 if(AMarkToGrindMarkDvX2!=0.0f && AMarkToGrindMarkDvX2!=0.0f){
											 GrindMarkRect[21].left   = (FP1.x-AMarkToGrindMarkDvX2)-40;
											 GrindMarkRect[21].top    = (FP1.y+AMarkToGrindMarkDvY2)-40;
											 GrindMarkRect[21].right  = (GrindMarkRect[21].left + 80);
											 GrindMarkRect[21].bottom = (GrindMarkRect[21].top  + 80);

											 GrindRectWidth  = (GrindMarkRect[21].right  - GrindMarkRect[21].left);
											 GrindRectHeight = (GrindMarkRect[21].bottom - GrindMarkRect[21].top );

											 Find->IRoi->SetPlacement(GrindMarkRect[21].left,GrindMarkRect[21].top,GrindRectWidth,GrindRectHeight);
											 if(GrindMarkRect[21].left<=0 || GrindMarkRect[21].top<=0 || GrindRectWidth<=0 || GrindRectHeight<=0) return false;

											 // 검사 및 Match Pos 좌표 받어온다 
											 // Find 검사 성공시 데이터 받아옴 
											 Find->SetAngleBias(90.0f);
											 if(Find->OnExecute()){
												 GrindMarkPoint[21].x = Find->Result[0].Px;
												 GrindMarkPoint[21].y = Find->Result[0].Py;
												 GrindMarkScore[21]   = Find->Result[0].Score;
											 }
											 // Contrast Gradient Pixel Value
											 GrindMarkGradient[21] = EasyImage::Focusing(Find->IRoi);
										 }
									 }
									 LogUnit.SetLog(L"CellID:%d, CamID:%d ==>A2MarkFind_END",CellId,CamId);     
								 }
								 // Find Mark Search Start
								 ////////////////////////////////////////////////////////////////////////////

								 // NOTCH RightTop
								 if(FInspectMode==Insp_Polygon){
									 LogUnit.SetLog(L"CellID:%d, CamID:%d ==>RightTop_Polygon_START",CellId,CamId);     

// 									 RotateBinaryImg.Save("D:\\ROTATE_IMG\\Polygon_BinaryImg2.bmp");
									 TPoint P1(0,0),P2(0,0),P3(0,0),P4(0,0);

// 									 P1.x = (int)(FRTPoint.x-ASideCircleWidth-30);    P1.y =(int)(FRTPoint.y-20            );    P2.x = (int)(FRTPoint.x+20);    P2.y = (int)(P1.y);
// 									 P3.x = (int)(P1.x)                          ;    P3.y =(int)(P1.y+ASideCircleHeight+50);    P4.x = (int)(P2.x         );    P4.y = (int)(P3.y);
									 P1.x = (int)(FRTPoint.x-ASideCircleWidth   );    P1.y =(int)(FRTPoint.y-20            );    P2.x = (int)(FRTPoint.x+20);    P2.y = (int)(P1.y);
									 P3.x = (int)(P1.x)                          ;    P3.y =(int)(P1.y+ASideCircleHeight+20);    P4.x = (int)(P2.x         );    P4.y = (int)(P3.y);

									 int PixelCnt =0;

									 // Median Filter 적용 
									 if(P1.x<=0    || P1.y<=0    || (P2.x - P1.x)<=0    || (P3.y - P1.y)<=0   ) return false;
									 if(P1.x>=ImgW || P1.y>=ImgH || (P2.x - P1.x)>=ImgW || (P3.y - P1.y)>=ImgH) return false;
									 FilterROI.SetSize(int(P2.x - P1.x),int(P3.y - P1.y) )                 ;
									 FilterROI.Attach(&RotateBinaryImg)                                    ;
									 FilterROI.SetPlacement(P1.x, P1.y, int(P2.x - P1.x), int(P3.y - P1.y));
									 EasyImage::Median(&FilterROI, &FilterROI)                             ;
// 									 RotateBinaryImg.Save("D:\\ROTATE_IMG\\Polygon_RightTop_필터.bmp");

									 Polygon->GImage = &RotateBinaryImg                          ;
									 Polygon->IWidth = ImgW                                      ;
									 Polygon->IHeight= ImgH                                      ;
									 Polygon->PoPa.FMinWidth  =(int)(ASideCircleWidth/2)         ;                       
// 									 Polygon->PoPa.FMaxWidth  =(int)((FRTPoint.x - FLTPoint.x)/2);
									 Polygon->PoPa.FMaxWidth  =(int)(ASideCircleWidth+100)       ;
									 Polygon->PoPa.FMinHeight =(int)(ASideCircleHeight/2)        ;
// 									 Polygon->PoPa.FMaxHeight =1000                              ;
									 Polygon->PoPa.FMaxHeight =(int)(ASideCircleHeight+100)      ;
									 Polygon->PoPa.MinPxCnt   =100                               ;
									 Polygon->PoPa.MaxPxCnt   =20000                             ;
									 Polygon->PoPa.MaxBbCnt   =10                                ;
									 Polygon->PoPa.IsSeparate =true                              ;
									 Polygon->PoPa.IsInToOut  =false                             ;
									 Polygon->PoPa.HiThHold   = ECThresHold                      ;
									 Polygon->PoPa.LoThHold   = 0                                ;

									 if(P1.x!=0 && P1.y!=0 && P2.x!=0 && P2.y!=0 && P3.x!=0 && P3.y!=0 && P4.x!=0 && P4.y!=0){
										 Polygon->OnExecute(P1,P2,P3,P4);
									 }
									 // Polygon Algorithm InEdgeData/OutEdgeData Separate 
									 if(Polygon->BlobCount==1){
										 PolygonMarginCnt =5;
										 if(Polygon->Blob[0].InCnt>(PolygonMarginCnt*2)){
											 A2CirInEdgeCount=0;
											 A2CirInEdgeCount = (Polygon->Blob[0].InCnt - (PolygonMarginCnt*2));
											 if(A2CirInEdgeCount>0){
												 if(A2CirInPoint!=NULL) delete[] A2CirInPoint;
												 A2CirInPoint = new TFPoint[A2CirInEdgeCount];

												 PixelCnt=0;
												 for(int k=0; k<Polygon->Blob[0].InCnt; k++){
													 if(k<PolygonMarginCnt || k>=(Polygon->Blob[0].InCnt-PolygonMarginCnt)) continue;
													 A2CirInPoint[PixelCnt].x = Polygon->Blob[0].InPoint[k].x ;
													 A2CirInPoint[PixelCnt].y = Polygon->Blob[0].InPoint[k].y ;
													 PixelCnt++;
												 }
											 }
										 }

										 if(Polygon->Blob[0].OutCnt>(PolygonMarginCnt*2)){
											 A2CirOutEdgeCount=0;
											 A2CirOutEdgeCount = (Polygon->Blob[0].OutCnt - (PolygonMarginCnt*2));
											 if(A2CirOutEdgeCount>0){
												 if(A2CirOutPoint!=NULL) delete[] A2CirOutPoint;
												 A2CirOutPoint = new TFPoint[A2CirOutEdgeCount];

												 PixelCnt=0;
												 for(int k=0; k<Polygon->Blob[0].OutCnt; k++){
													 if(k<PolygonMarginCnt || k>=(Polygon->Blob[0].OutCnt-PolygonMarginCnt)) continue;
													 A2CirOutPoint[PixelCnt].x = Polygon->Blob[0].OutPoint[k].x ;
													 A2CirOutPoint[PixelCnt].y = Polygon->Blob[0].OutPoint[k].y ;
													 PixelCnt++;
												 }
											 }
										 }
										 // Polygon Data Clear
// 										 Polygon->ClearData();
									 }


									 // InEdgeData/OutEdgeData 기준 가공량 및 연마량 계산
									 if(IsMarkBtm){ // LTPS 가공량,연마량 계산 
										 if(A2CirOutEdgeCount!=0 && A2CirInEdgeCount!=0){ // MarkMode경우 가공량 검사를 먼저 진행 후 연마량 산출
											 ////////////////////////////////////////////////////////////////////////////////////////////////////
											 if(GrindMarkPoint[20].x!=0.0f && GrindMarkPoint[20].y!=0.0f){  //GrindMark 찾았을경우 
												 // GrindMark기준 OutData 최단거리 Count정보 Calc 
												 GrindMeaDis =0.0f, MinDis =10000.0f; GrindMarkOutCnt=0;
												 for(int k=0; k<A2CirOutEdgeCount; k++){
													 if(A2CirOutPoint[k].x  ==0.0f || A2CirOutPoint[k].y  ==0.0f) continue;
													 if(GrindMarkPoint[20].x==0.0f || GrindMarkPoint[20].y==0.0f) continue;

													 GrindMeaDis = Math.GetLength(GrindMarkPoint[20], A2CirOutPoint[k]);
													 if(GrindMeaDis<MinDis){
														 MinDis = GrindMeaDis;
														 GrindMarkOutCnt = k;
													 }
												 }
												 // GrindMark기준 InData 최단거리 Count정보 Calc 
												 GrindMeaDis =0.0f, MinDis =10000.0f; GrindMarkInCnt=0;
												 for(int k=0; k<A2CirInEdgeCount; k++){
													 if(A2CirInPoint[k].x   ==0.0f || A2CirInPoint[k].y    ==0.0f) continue;
													 if(GrindMarkPoint[20].x==0.0f || GrindMarkPoint[20].y ==0.0f) continue;

													 GrindMeaDis = Math.GetLength(GrindMarkPoint[20], A2CirInPoint[k]);
													 if(GrindMeaDis<MinDis){
														 MinDis = GrindMeaDis;
														 GrindMarkInCnt = k;
													 }
												 }

												 if(GrindMarkOutCnt!=0){
													 // GrindMark기준 InData 최단거리 Count정보 Calc 
													 GrindMeaDis =0.0f, MinDis =10000.0f; GrindMarkInCnt=0;
													 for(int k=0; k<A2CirInEdgeCount; k++){
														 if(A2CirInPoint[k].x               ==0.0f || A2CirInPoint[k].y                ==0.0f) continue;
														 if(A2CirOutPoint[GrindMarkOutCnt].x==0.0f || A2CirOutPoint[GrindMarkOutCnt].y ==0.0f) continue;

														 GrindMeaDis = Math.GetLength(A2CirOutPoint[GrindMarkOutCnt], A2CirInPoint[k]);
														 if(GrindMeaDis<MinDis){
															 MinDis = GrindMeaDis;
															 GrindMarkInCnt = k;
														 }
													 }
												 }

												 // GrindMark기준 수직 포인트 주변값 Avg산출한다 ==>가공량 측정(OutData기준)
												 if(GrindMarkOutCnt!=0 && GrindMarkOutCnt>5){
													 CircleCount=0,TotalCirDis=0.0f,GrindMeaDis=0.0f;
													 for(int k=GrindMarkOutCnt-5; k<GrindMarkOutCnt+5; k++){
														 if(A2CirOutPoint[k].x==0.0f || A2CirOutPoint[k].y==0.0f) continue;

														 GrindMeaDis = Math.GetLength(GrindMarkPoint[20], A2CirOutPoint[k]);
														 TotalCirDis+= GrindMeaDis;
														 CircleCount++;
													 }
													 if(TotalCirDis!=0.0f && CircleCount!=0){
														 A2CirGrindMea[2] = TotalCirDis/CircleCount;
														 A2CirGrindMea[2] = A2CirGrindMea[2]+0.5; //SubPixel 
													 }
												 }

												 // GrindMark기준 수직 포인트 주변값 Avg산출한다 ==>연마량 측정(OutData,InData기준)
												 if((GrindMarkOutCnt!=0 && GrindMarkOutCnt>5) && (GrindMarkInCnt!=0 && GrindMarkInCnt>5)){
													 CircleCount=0,TotalCirDis=0.0f,GrindWidthDis=0.0f;
													 for(int k=-5; k<5; k++){
														 if(A2CirOutPoint[GrindMarkOutCnt+k].x==0.0f && A2CirOutPoint[GrindMarkOutCnt+k].y==0.0f) continue;
														 if(A2CirInPoint [GrindMarkInCnt +k].x==0.0f && A2CirInPoint [GrindMarkInCnt +k].y==0.0f) continue;
														 GrindWidthDis = Math.GetLength(A2CirInPoint[GrindMarkInCnt+k], A2CirOutPoint[GrindMarkOutCnt+k]);
														 TotalCirDis+=   GrindWidthDis;
														 CircleCount++;
													 }
													 if(TotalCirDis!=0.0f && CircleCount!=0){
														 A2CirGrindWd[2] = TotalCirDis/CircleCount;
														 A2CirGrindWd[2] = A2CirGrindWd[2]+0.5; //SubPixel
													 }
												 }
											 }
											 else if(GrindMarkRect[20].left!=0 && GrindMarkRect[20].top!=0 && GrindMarkRect[20].right!=0 && GrindMarkRect[20].bottom!=0){  //GrindMark 못 찾았을경우
												 // OutData기준 최소값 데이터 Count산출 
												 GrindMeaDis =0.0f, MinDis =10000.0f; GrindMarkOutCnt=0;
												 for(int k=0; k<A2CirOutEdgeCount; k++){
													 if(A2CirOutPoint[k].x==0.0f || A2CirOutPoint[k].y==0.0f) continue;

													 AGrindMarkRectPoint2.x = GrindMarkRect[20].left + (GrindMarkRect[20].right  - GrindMarkRect[20].left)/2; 
													 AGrindMarkRectPoint2.y = GrindMarkRect[20].top  + (GrindMarkRect[20].bottom - GrindMarkRect[20].top )/2; 

													 GrindMeaDis = Math.GetLength(AGrindMarkRectPoint2, A2CirOutPoint[k]);
													 if(GrindMeaDis<MinDis){
														 MinDis = GrindMeaDis;
														 GrindMarkOutCnt = k;
													 }
												 }

												 // 최단거리OUtCount기준 InData 최단거리 Count정보 Calc 
												 if(GrindMarkOutCnt!=0){
													 GrindMeaDis =0.0f, MinDis =10000.0f; GrindMarkInCnt=0;
													 for(int k=0; k<A2CirInEdgeCount; k++){
														 if(A2CirInPoint[k].x   ==0.0f             || A2CirInPoint[k].y                ==0.0f) continue;
														 if(A2CirOutPoint[GrindMarkOutCnt].x==0.0f || A2CirOutPoint[GrindMarkOutCnt].y ==0.0f) continue;

														 GrindMeaDis = Math.GetLength(A2CirOutPoint[GrindMarkOutCnt], A2CirInPoint[k]);
														 if(GrindMeaDis<MinDis){
															 MinDis = GrindMeaDis;
															 GrindMarkInCnt = k;
														 }
													 }
												 }

												 // GrindMark기준 수직 포인트 주변값 Avg산출한다 ==>연마량 측정(OutData,InData기준)
												 if((GrindMarkOutCnt!=0 && GrindMarkOutCnt>5) && (GrindMarkInCnt!=0 && GrindMarkInCnt>5)){
													 CircleCount=0,TotalCirDis=0.0f,GrindWidthDis=0.0f;
													 for(int k=-5; k<5; k++){
														 if(A2CirOutPoint[GrindMarkOutCnt+k].x==0.0f && A2CirOutPoint[GrindMarkOutCnt+k].y==0.0f) continue;
														 if(A2CirInPoint [GrindMarkInCnt +k].x==0.0f && A2CirInPoint [GrindMarkInCnt +k].y==0.0f) continue;
														 GrindWidthDis = Math.GetLength(A2CirInPoint[GrindMarkInCnt+k], A2CirOutPoint[GrindMarkOutCnt+k]);
														 TotalCirDis+=   GrindWidthDis;
														 CircleCount++;
													 }
													 if(TotalCirDis!=0.0f && CircleCount!=0){
														 A2CirGrindWd[2] = TotalCirDis/CircleCount;
														 A2CirGrindWd[2] = A2CirGrindWd[2]+0.5; //SubPixel
													 }
												 }
											 }
											 /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

											 ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
											 if(GrindMarkPoint[21].x!=0.0f && GrindMarkPoint[21].y!=0.0f){  //GrindMark 찾았을경우 
												 // GrindMark기준 OutData 최단거리 Count정보 Calc 
												 GrindMeaDis =0.0f, MinDis =10000.0f; GrindMarkOutCnt=0;
												 for(int k=0; k<A2CirOutEdgeCount; k++){
													 if(A2CirOutPoint[k].x  ==0.0f || A2CirOutPoint[k].y  ==0.0f) continue;
													 if(GrindMarkPoint[21].x==0.0f || GrindMarkPoint[21].y==0.0f) continue;

													 GrindMeaDis = Math.GetLength(GrindMarkPoint[21], A2CirOutPoint[k]);
													 if(GrindMeaDis<MinDis){
														 MinDis = GrindMeaDis;
														 GrindMarkOutCnt = k;
													 }
												 }
												 // GrindMark기준 InData 최단거리 Count정보 Calc 
												 GrindMeaDis =0.0f, MinDis =10000.0f; GrindMarkInCnt=0;
												 for(int k=0; k<A2CirInEdgeCount; k++){
													 if(A2CirInPoint[k].x   ==0.0f || A2CirInPoint[k].y    ==0.0f) continue;
													 if(GrindMarkPoint[21].x==0.0f || GrindMarkPoint[21].y ==0.0f) continue;

													 GrindMeaDis = Math.GetLength(GrindMarkPoint[21], A2CirInPoint[k]);
													 if(GrindMeaDis<MinDis){
														 MinDis = GrindMeaDis;
														 GrindMarkInCnt = k;
													 }
												 }
												 if(GrindMarkOutCnt!=0){
													 // GrindMark기준 InData 최단거리 Count정보 Calc 
													 GrindMeaDis =0.0f, MinDis =10000.0f; GrindMarkInCnt=0;
													 for(int k=0; k<A2CirInEdgeCount; k++){
														 if(A2CirInPoint[k].x               ==0.0f || A2CirInPoint[k].y                ==0.0f) continue;
														 if(A2CirOutPoint[GrindMarkOutCnt].x==0.0f || A2CirOutPoint[GrindMarkOutCnt].y ==0.0f) continue;

														 GrindMeaDis = Math.GetLength(A2CirOutPoint[GrindMarkOutCnt], A2CirInPoint[k]);
														 if(GrindMeaDis<MinDis){
															 MinDis = GrindMeaDis;
															 GrindMarkInCnt = k;
														 }
													 }
												 }

												 // GrindMark기준 수직 포인트 주변값 Avg산출한다 ==>가공량 측정(OutData기준)
												 if(GrindMarkOutCnt!=0 && GrindMarkOutCnt>5){
													 CircleCount=0,TotalCirDis=0.0f,GrindMeaDis=0.0f;
													 for(int k=GrindMarkOutCnt-5; k<GrindMarkOutCnt+5; k++){
														 if(A2CirOutPoint[k].x==0.0f || A2CirOutPoint[k].y==0.0f) continue;

														 GrindMeaDis = Math.GetLength(GrindMarkPoint[21], A2CirOutPoint[k]);
														 TotalCirDis+= GrindMeaDis;
														 CircleCount++;
													 }
													 if(TotalCirDis!=0.0f && CircleCount!=0){
														 A2CirGrindMea[1] = TotalCirDis/CircleCount;
														 A2CirGrindMea[1] = A2CirGrindMea[1]+0.5; //SubPixel 
													 }
												 }

												 // GrindMark기준 수직 포인트 주변값 Avg산출한다 ==>연마량 측정(OutData,InData기준)
												 if((GrindMarkOutCnt!=0 && GrindMarkOutCnt>5) && (GrindMarkInCnt!=0 && GrindMarkInCnt>5)){
													 CircleCount=0,TotalCirDis=0.0f,GrindWidthDis=0.0f;
													 for(int k=-5; k<5; k++){
														 if(A2CirOutPoint[GrindMarkOutCnt+k].x==0.0f && A2CirOutPoint[GrindMarkOutCnt+k].y==0.0f) continue;
														 if(A2CirInPoint [GrindMarkInCnt +k].x==0.0f && A2CirInPoint [GrindMarkInCnt +k].y==0.0f) continue;
														 GrindWidthDis = Math.GetLength(A2CirInPoint[GrindMarkInCnt+k], A2CirOutPoint[GrindMarkOutCnt+k]);
														 TotalCirDis+=   GrindWidthDis;
														 CircleCount++;
													 }
													 if(TotalCirDis!=0.0f && CircleCount!=0){
														 A2CirGrindWd[1] = TotalCirDis/CircleCount;
														 A2CirGrindWd[1] = A2CirGrindWd[1]+0.5; //SubPixel
													 }
												 }
											 }
											 else if(GrindMarkRect[21].left!=0 && GrindMarkRect[21].top!=0 && GrindMarkRect[21].right!=0 && GrindMarkRect[21].bottom!=0){  //GrindMark 못 찾았을경우
												 // OutData기준 최소값 데이터 Count산출 
												 GrindMeaDis =0.0f, MinDis =10000.0f; GrindMarkOutCnt=0;
												 for(int k=0; k<A2CirOutEdgeCount; k++){
													 if(A2CirOutPoint[k].x==0.0f || A2CirOutPoint[k].y==0.0f) continue;

													 AGrindMarkRectPoint2.x = GrindMarkRect[21].left + (GrindMarkRect[21].right  - GrindMarkRect[21].left)/2; 
													 AGrindMarkRectPoint2.y = GrindMarkRect[21].top  + (GrindMarkRect[21].bottom - GrindMarkRect[21].top )/2; 

													 GrindMeaDis = Math.GetLength(AGrindMarkRectPoint2, A2CirOutPoint[k]);
													 if(GrindMeaDis<MinDis){
														 MinDis = GrindMeaDis;
														 GrindMarkOutCnt = k;
													 }
												 }

												 // 최단거리OUtCount기준 InData 최단거리 Count정보 Calc 
												 if(GrindMarkOutCnt!=0){
													 GrindMeaDis =0.0f, MinDis =10000.0f; GrindMarkInCnt=0;
													 for(int k=0; k<A2CirInEdgeCount; k++){
														 if(A2CirInPoint[k].x   ==0.0f             || A2CirInPoint[k].y                ==0.0f) continue;
														 if(A2CirOutPoint[GrindMarkOutCnt].x==0.0f || A2CirOutPoint[GrindMarkOutCnt].y ==0.0f) continue;

														 GrindMeaDis = Math.GetLength(A2CirOutPoint[GrindMarkOutCnt], A2CirInPoint[k]);
														 if(GrindMeaDis<MinDis){
															 MinDis = GrindMeaDis;
															 GrindMarkInCnt = k;
														 }
													 }
												 }

												 // GrindMark기준 수직 포인트 주변값 Avg산출한다 ==>연마량 측정(OutData,InData기준)
												 if((GrindMarkOutCnt!=0 && GrindMarkOutCnt>5) && (GrindMarkInCnt!=0 && GrindMarkInCnt>5)){
													 CircleCount=0,TotalCirDis=0.0f,GrindWidthDis=0.0f;
													 for(int k=-5; k<5; k++){
														 if(A2CirOutPoint[GrindMarkOutCnt+k].x==0.0f && A2CirOutPoint[GrindMarkOutCnt+k].y==0.0f) continue;
														 if(A2CirInPoint [GrindMarkInCnt +k].x==0.0f && A2CirInPoint [GrindMarkInCnt +k].y==0.0f) continue;
														 GrindWidthDis = Math.GetLength(A2CirInPoint[GrindMarkInCnt+k], A2CirOutPoint[GrindMarkOutCnt+k]);
														 TotalCirDis+=   GrindWidthDis;
														 CircleCount++;
													 }
													 if(TotalCirDis!=0.0f && CircleCount!=0){
														 A2CirGrindWd[1] = TotalCirDis/CircleCount;
														 A2CirGrindWd[1] = A2CirGrindWd[1]+0.5; //SubPixel
													 }
												 }
											 }
											 /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
										 }
									 }
									 else         { //Polygon EnCap 계산시 OutPoint 중간값 기준 실측 거리 평균값을 계산한다(RightTop)
										 if(A2CirInEdgeCount!=0 &&A2CirOutEdgeCount!=0){
											 GrindMeaDis =0.0f, MinDis =10000.0f; GrindMarkOutCnt=0;
											 GrindMarkOutCnt = (int)(A2CirOutEdgeCount/2);
											 // 최단거리OUtCount기준 InData 최단거리 Count정보 Calc 
											 if(GrindMarkOutCnt!=0){
												 GrindMeaDis =0.0f, MinDis =10000.0f; GrindMarkInCnt=0;
												 for(int k=0; k<A2CirInEdgeCount; k++){
													 if(A2CirInPoint[k].x   ==0.0f             || A2CirInPoint[k].y                ==0.0f) continue;
													 if(A2CirOutPoint[GrindMarkOutCnt].x==0.0f || A2CirOutPoint[GrindMarkOutCnt].y ==0.0f) continue;

													 GrindMeaDis = Math.GetLength(A2CirOutPoint[GrindMarkOutCnt], A2CirInPoint[k]);
													 if(GrindMeaDis<MinDis){
														 MinDis = GrindMeaDis;
														 GrindMarkInCnt = k;
													 }
												 }
											 }

											 // GrindMark기준 수직 포인트 주변값 Avg산출한다 ==>연마량 측정(OutData,InData기준)
											 if((GrindMarkOutCnt!=0 && GrindMarkOutCnt>5) && (GrindMarkInCnt!=0 && GrindMarkInCnt>5)){
												 CircleCount=0,TotalCirDis=0.0f,GrindWidthDis=0.0f;
												 for(int k=-5; k<5; k++){
													 if(A2CirOutPoint[GrindMarkOutCnt+k].x==0.0f && A2CirOutPoint[GrindMarkOutCnt+k].y==0.0f) continue;
													 if(A2CirInPoint [GrindMarkInCnt +k].x==0.0f && A2CirInPoint [GrindMarkInCnt +k].y==0.0f) continue;
													 GrindWidthDis = Math.GetLength(A2CirInPoint[GrindMarkInCnt+k], A2CirOutPoint[GrindMarkOutCnt+k]);
													 TotalCirDis+=   GrindWidthDis;
													 CircleCount++;
												 }
												 if(TotalCirDis!=0.0f && CircleCount!=0){
													 A2CirGrindWd[2] = TotalCirDis/CircleCount;
													 A2CirGrindWd[2] = A2CirGrindWd[2]+0.5; //SubPixel
												 }
											 }
										 }
									 }
									 // FAVION Circle Fitting 결과물(RightTop)
									 SampleSize = A2CirInEdgeCount*0.75; //0.5~0.8이하로 입력할것
									 DistDevRatio = 0.15; //0.1~0.25 이하로 입력할것
									 CircleFit->OnRansac(A2CirInPoint,A2CirInEdgeCount,SampleSize,DistDevRatio,&ACircleFit2Center,&ACirFitDiameter2);
									 LogUnit.SetLog(L"RightTop_Mark_END");     


									 // Polygon 박리 검사 시퀀스(RightTop)
									 if(!IsMarkBtm && BrokenThresHold!=0){
// 										 RotateBrokenImg.SetSize(RotateImg.GetWidth(), RotateImg.GetHeight());
// 										 EasyImage::Oper(EArithmeticLogicOperation_Copy,&RotateImg,&RotateBrokenImg);
// 										 EasyImage::Threshold(&RotateImg,&RotateBrokenImg, BrokenThresHold);
										 Edge->GImage = &RotateBrokenImg;
										 Edge->SetEdgeType(0);

										 int DvCnt =0, DataCount=0;
										 double deg =0.0f; 
										 TFPoint Target(0.0f, 0.0f);

										 if(GrindMarkInCnt>GrindMarkOutCnt){
											 DvCnt = GrindMarkInCnt - GrindMarkOutCnt;
											 for(int k=0; k<A2CirOutEdgeCount; k++){
												 deg =0.0f, Target.x =0.0f, Target.y =0.0f;
												 if(((k+DvCnt)<A2CirInEdgeCount) && A2CirInPoint[k+DvCnt].x>0  && A2CirInPoint[k+DvCnt].y>0){
													 deg = Math.GetDegree(A2CirOutPoint[k],A2CirInPoint[k+DvCnt]);

													 Target  = Math.OnFindPerpendicularPointXY(A2CirOutPoint[k],-dEdgeToTrapLineDis,dEdgeToTrapLineDis,deg);
													 Edge->OnExecute(A2CirOutPoint[k],Target); // 연마외곽라인에서 Target까지 White Point Search 
													 if(Edge->GetResultEdgePointCount()>0){
														 A2CircleData[DataCount].Dis =0.0f;
														 A2CircleData[DataCount].Dv  =0.0f;
														 A2CircleData[DataCount].P   = Edge->GetResultEdgePoint(0);
														 A2CircleData[DataCount].P.y = A2CircleData[DataCount].P.y - ImageHeight; // Frame기준 단위좌표로 변경함  
														 DataCount++;
													 }
												 }
											 }
											 A2CirInCrackCount = DataCount;
										 }
										 else if(GrindMarkInCnt<GrindMarkOutCnt)   {
											 DvCnt = GrindMarkOutCnt - GrindMarkInCnt;
											 for(int k=DvCnt; k<A2CirOutEdgeCount; k++){
												 deg =0.0f, Target.x =0.0f, Target.y =0.0f;
												 if(((k-DvCnt)<A2CirInEdgeCount) && A2CirInPoint[k-DvCnt].x>0  && A2CirInPoint[k-DvCnt].y>0 && k-DvCnt>=0){
													 deg = Math.GetDegree(A2CirOutPoint[k],A2CirInPoint[k-DvCnt]);

													 Target  = Math.OnFindPerpendicularPointXY(A2CirOutPoint[k],-dEdgeToTrapLineDis,dEdgeToTrapLineDis,deg);
													 Edge->OnExecute(A2CirOutPoint[k],Target); // 연마외곽라인에서 Target까지 White Point Search 
													 if(Edge->GetResultEdgePointCount()>0){
														 A2CircleData[DataCount].Dis =0.0f;
														 A2CircleData[DataCount].Dv  =0.0f;
														 A2CircleData[DataCount].P   = Edge->GetResultEdgePoint(0);
														 A2CircleData[DataCount].P.y = A2CircleData[DataCount].P.y - ImageHeight; // Frame기준 단위좌표로 변경함  
														 DataCount++;
													 }
												 }
											 }
											 A2CirInCrackCount = DataCount;
										 }
									 }
									 LogUnit.SetLog(L"CellID:%d, CamID:%d ==>RightTop_Polygon_END",CellId,CamId);     
								 }
								 else if(FInspectMode==Insp_Mark){
									 LogUnit.SetLog(L"RightTop_Mark_START");     

									 // 자재의 외곽라인 교차점 기준 CirCenter 설정함 
									 if(ASideCircleWidth!=0.0f && ASideCircleHeight!=0.0f)  A2CirCenter.x = FRTPoint.x - ASideCircleWidth;  A2CirCenter.y = FRTPoint.y + ASideCircleHeight;  

									 // Circle Fitting 진행시 공통으로 사용하는 설정값
									 // Circle Fitting 진행시 공통으로 사용하는 설정값
									 Circle->SetSamplingStep(1)                              ; // A2Circle Edge 간격 

									 //A1 In Circle EdgePoint Data 추출 
									 // TrackLine or GrindMark기준 선택하여 가공량 측정 시퀀스는 코딩하지 않음
									 if(A2CirCenter.x!=0 && A2CirCenter.y!=0){
// 										 RotateBinaryImg.Save("D:\\ROTATE_IMG\\RightTop_원본.bmp");

										 // A_Side Circle 검사전 Median 필터 적용 
										 TPoint P1(0,0),P2(0,0),P3(0,0),P4(0,0);
										 P1.x = (int)(FRTPoint.x-ASideCircleWidth   );    P1.y =(int)(FRTPoint.y-20            );    P2.x = (int)(FRTPoint.x+20);    P2.y = (int)(P1.y);
										 P3.x = (int)(P1.x)                          ;    P3.y =(int)(P1.y+ASideCircleHeight+20);    P4.x = (int)(P2.x         );    P4.y = (int)(P3.y);
										 // Median Filter 적용 
										 if(P1.x<=0    || P1.y<=0    || (P2.x - P1.x)<=0    || (P3.y - P1.y)<=0   ) return false;
										 if(P1.x>=ImgW || P1.y>=ImgH || (P2.x - P1.x)>=ImgW || (P3.y - P1.y)>=ImgH) return false;
										 FilterROI.SetSize(int(P2.x - P1.x),int(P3.y - P1.y) )                 ;
										 FilterROI.Attach(&RotateBinaryImg)                                    ;
										 FilterROI.SetPlacement(P1.x, P1.y, int(P2.x - P1.x), int(P3.y - P1.y));
										 EasyImage::Median(&FilterROI, &FilterROI)                             ;
// 										 RotateBinaryImg.Save("D:\\ROTATE_IMG\\RightTop_필터.bmp");


										 if(ECThresHold==0) Circle->GImage = &RotateImg      ; //Org Image 넘겨줌 
										 else               Circle->GImage = &RotateBinaryImg; //Binary Image 넘겨줌 

										 Circle->SetCenterXY(A2CirCenter.x , A2CirCenter.y)  ; // Circle Center 좌표설정 
										 // 									 A2Diameter = ((ASideCircleWidth*2)+((ASideCircleWidth-OutToTrackLineDis)*2))/2;
										 A2Diameter = (ASideCircleWidth*2);

										 Circle->SetDiameter(A2Diameter)             ;
										 Circle->SetTolerance(60.0f )                ; // A1Circle Tolerance 
										 Circle->SetCircleChoice(1)                  ; // 0:From Begin, 1:From End, 2:Largest Amplitude 
										 Circle->SetCircleIndex (1)                  ; // Circle EdgePoint Index 
										 Circle->SetAngle(270+CirAngleMargin)        ; // Cirlce Angle 
										 Circle->SetAmplitude(90-(2*CirAngleMargin)) ; // Circle Amplitude

										 // Circle InData EdgePoint 
										 //////////////////////////////////////////////////////////////////////////////////////////////////////
										 Circle->SetCircleType(2)                    ; // 0:Black to White, 1:White to Black 2: Both Black, White 
										 Circle->OnExecute()                         ;

										 // Circle In Data 기준 새로운 Circle Center 좌표 받아옴 
										 // Euresys Circle Fitting Center 
										 RealA2CirCenter.x = Circle->FCP.x;
										 RealA2CirCenter.y = Circle->FCP.y;
										 ACirDiameter2     = (Circle->Diameter)/2.0;

										 // Circle In Data취합 
										 OrgA2CirInEdgeCount = Circle->FCirclePointCount;
										 if(OrgA2CirInEdgeCount>0){
											 if(OrgA2CirInPoint!=NULL) delete[] OrgA2CirInPoint;
											 OrgA2CirInPoint = new TFPoint[OrgA2CirInEdgeCount];

											 for(int k=0; k<OrgA2CirInEdgeCount; k++){
												 if(k>MAX_CIRCLE_EDGEPOINT) break;
												 OrgA2CirInPoint[k].x = Circle->FCirclePoint[k].x;
												 OrgA2CirInPoint[k].y = Circle->FCirclePoint[k].y;
												 if(OrgA2CirInPoint[k].x==0.0f && OrgA2CirInPoint[k].y==0.0f) A2CirInEdgeCount++;
											 }
										 }
										 //////////////////////////////////////////////////////////////////////////////////////////////////////

										 // Circle Out Data 다시 검사  
										 //////////////////////////////////////////////////////////////////////////////////////////////////////
										 Circle->SetTolerance(60.0f )      ; // Circle Tolerance 
										 Circle->SetDiameter (A2Diameter)  ; // Circle Diameter 
										 Circle->SetCircleChoice(1)        ; // 0:From Begin, 1:From End, 2:Largest Amplitude 
										 Circle->SetCircleType(2)          ; // 0:Black to White, 1:White to Black 2: Both Black, White 
										 Circle->SetCircleIndex (0)        ; // Circle EdgePoint Index 

										 Circle->OnExecute()               ;

										 // Circle Out Data취합 
										 OrgA2CirOutEdgeCount = Circle->FCirclePointCount;
										 if(OrgA2CirOutEdgeCount>0){
											 if(OrgA2CirOutPoint!=NULL) delete[] OrgA2CirOutPoint;
											 OrgA2CirOutPoint = new TFPoint[OrgA2CirOutEdgeCount];

											 for(int k=0; k<OrgA2CirOutEdgeCount; k++){
												 if(k>MAX_CIRCLE_EDGEPOINT) break;
												 OrgA2CirOutPoint[k].x = Circle->FCirclePoint[k].x;
												 OrgA2CirOutPoint[k].y = Circle->FCirclePoint[k].y;
												 // BTM영역 Circle을 제외한 영역 Defect검사 목적에 좌표계산 
												 if(k==0                     ) {TopEdgePoint[2].x = OrgA2CirOutPoint[k].x; TopEdgePoint[2].y = OrgA2CirOutPoint[k].y;}
												 if(k==OrgA2CirOutEdgeCount-1) {TopEdgePoint[3].x = OrgA2CirOutPoint[k].x; TopEdgePoint[3].y = OrgA2CirOutPoint[k].y;}
												 if(OrgA2CirOutPoint[k].x==0.0f && OrgA2CirOutPoint[k].y==0.0f) A2CirOutEdgeCount++;
											 }
										 }
										 // A2Circle Grind_Width Calculate (연마량 계산)
										 if(IsMarkBtm){ // LTPS경우 가공량 계산 ==> 연마량 계산 
											 if(OrgA2CirOutEdgeCount!=0 && OrgA2CirInEdgeCount!=0){// MarkMode경우 가공량 검사를 먼저 진행 후 연마량 산출  
												 GrindMeaDis =0.0f, MinDis =10000.0f; A2GrindMarkCount=0;
												 if(GrindMarkPoint[20].x!=0.0f && GrindMarkPoint[20].y!=0.0f){  // GrindMark 찾았을경우 
													 for(int k=0; k<OrgA2CirOutEdgeCount; k++){
														 if(OrgA2CirOutPoint[k].x==0.0f || OrgA2CirOutPoint[k].y==0.0f) continue;
														 if(GrindMarkPoint[20].x ==0.0f || GrindMarkPoint[20].y  ==0.0f) continue;

														 GrindMeaDis = Math.GetLength(GrindMarkPoint[20], OrgA2CirOutPoint[k]);
														 if(GrindMeaDis<MinDis){
															 MinDis = GrindMeaDis;
															 A2GrindMarkCount = k;
														 }
													 }

													 // GrindMark기준 수직 포인트 주변값 Avg산출한다 ==>가공량 측정 
													 if(A2GrindMarkCount!=0 && A2GrindMarkCount>5){
														 CircleCount=0,TotalCirDis=0.0f,GrindMeaDis=0.0f;
														 for(int k=A2GrindMarkCount-5; k<A2GrindMarkCount+5; k++){
															 if(OrgA2CirOutPoint[k].x==0.0f || OrgA2CirOutPoint[k].y==0.0f) continue;

															 GrindMeaDis = Math.GetLength(GrindMarkPoint[20], OrgA2CirOutPoint[k]);
															 TotalCirDis+= GrindMeaDis;
															 CircleCount++;
														 }
														 if(TotalCirDis!=0.0f && CircleCount!=0){
															 A2CirGrindMea[2] = TotalCirDis/CircleCount;
														 }
													 }

													 // GrindMark기준 수직 평균값 연마량 측정 
													 if(A2GrindMarkCount!=0 && A2GrindMarkCount>5){
														 CircleCount=0,TotalCirDis=0.0f,GrindWidthDis=0.0f;
														 for(int k=A2GrindMarkCount-5; k<A2GrindMarkCount+5; k++){
															 if(OrgA2CirOutPoint[k].x==0.0f && OrgA2CirOutPoint[k].y==0.0f) continue;
															 if(OrgA2CirInPoint [k].x==0.0f && OrgA2CirInPoint [k].y==0.0f) continue;
															 GrindWidthDis = Math.GetLength(OrgA2CirInPoint[k], OrgA2CirOutPoint[k]);
															 TotalCirDis+=   GrindWidthDis;
															 CircleCount++;
														 }
														 if(TotalCirDis!=0.0f && CircleCount!=0){
															 A2CirGrindWd[2] = TotalCirDis/CircleCount;
														 }
													 }
												 }
												 else { // GrindMark 못 찾았을 경우 
													 for(int k=0; k<OrgA2CirOutEdgeCount; k++){
														 if(OrgA2CirOutPoint[k].x==0.0f || OrgA2CirOutPoint[k].y==0.0f) continue;

														 AGrindMarkRectPoint2.x = GrindMarkRect[20].left + (GrindMarkRect[20].right  - GrindMarkRect[20].left)/2; 
														 AGrindMarkRectPoint2.y = GrindMarkRect[20].top  + (GrindMarkRect[20].bottom - GrindMarkRect[20].top )/2; 

														 GrindMeaDis = Math.GetLength(AGrindMarkRectPoint2, OrgA2CirOutPoint[k]);
														 if(GrindMeaDis<MinDis){
															 MinDis = GrindMeaDis;
															 A2GrindMarkCount = k;
														 }
													 }
													 // GrindMark기준 수직 평균값 연마량 측정 
													 if(A2GrindMarkCount!=0 && A2GrindMarkCount>5 && (A2GrindMarkCount+5<OrgA2CirOutEdgeCount)){
														 CircleCount=0,TotalCirDis=0.0f,GrindWidthDis=0.0f;
														 for(int k=A2GrindMarkCount-5; k<A2GrindMarkCount+5; k++){
															 if(OrgA2CirOutPoint[k].x==0.0f && OrgA2CirOutPoint[k].y==0.0f) continue;
															 if(OrgA2CirInPoint [k].x==0.0f && OrgA2CirInPoint [k].y==0.0f) continue;
															 GrindWidthDis = Math.GetLength(OrgA2CirInPoint[k], OrgA2CirOutPoint[k]);
															 TotalCirDis+=   GrindWidthDis;
															 CircleCount++;
														 }
														 if(TotalCirDis!=0.0f && CircleCount!=0){
															 A2CirGrindWd[2] = TotalCirDis/CircleCount;
														 }
													 }
												 }
											 }
										 }
										 else     { // MarkMode ==> EnCap경우 연마량만 계산한다 
											 if(OrgA2CirInEdgeCount==OrgA2CirOutEdgeCount){
												 double OutDis=0.0f, InDis=0.0f, TotalGrindWidth=0.0f, AvgGrindWidth=0.0f;A2GrindWidthCount=0;
												 for(int k=0; k<OrgA2CirInEdgeCount; k++){
													 if(OrgA2CirOutPoint[k].x==0.0f && OrgA2CirOutPoint[k].y==0.0f){
														 OutDis =0.0f;
													 }
													 else {
														 OutDis = Math.GetLengthFrPointToPoint(A2CirCenter,OrgA2CirOutPoint[k]);
													 }

													 if(OrgA2CirInPoint[k].x==0.0f && OrgA2CirInPoint[k].y==0.0f){
														 InDis =0.0f;
													 }
													 else {
														 InDis = Math.GetLengthFrPointToPoint(A2CirCenter,OrgA2CirInPoint[k]);
													 }

													 // CircleFitting 진행시 실제 EdgePoint 데이터가 존재 할 경우만 포함하여 계산한다
													 if(OutDis!=0.0f && InDis!=0.0f){
														 TotalGrindWidth+=(OutDis - InDis);
														 A2GrindWidthCount++;
													 }
												 }
												 if(A2GrindWidthCount!=0){
													 AvgGrindWidth = (TotalGrindWidth/A2GrindWidthCount);
													 A2CirGrindWd[2] = AvgGrindWidth;
												 }
											 }
										 }

										 //////////////////////////////////////////////////////////////////////////////////////////////////////
										 // Org Circle데이터중 유호하지 않은 값을 제외한 실제 존재하는 데이터 기준으로 동적 메모리 생성함
										 // Circle Defect검사에 필요한 Edge데이터 값
										 int Count=0;
										 if(OrgA2CirInEdgeCount>0){ // A2 CircleInData
											 A2CirInEdgeCount = OrgA2CirInEdgeCount - A2CirInEdgeCount;
											 if(A2CirInEdgeCount>0){
												 if(A2CirInPoint!=NULL) delete[] A2CirInPoint;
												 A2CirInPoint = new TFPoint[A2CirInEdgeCount];

												 for(int k=0; k<OrgA2CirInEdgeCount; k++){
													 if(k>MAX_CIRCLE_EDGEPOINT) break;
													 if(OrgA2CirInPoint[k].x==0.0f && OrgA2CirInPoint[k].y==0.0f) continue;
													 A2CirInPoint[Count].x = OrgA2CirInPoint[k].x;
													 A2CirInPoint[Count].y = OrgA2CirInPoint[k].y;
													 Count++;
												 }
											 }
											 // Circle 원본 데이터 메모리 삭제
											 if(OrgA2CirInPoint!=NULL) delete[] OrgA2CirInPoint;
										 }
										 // FAVION Circle Fitting 결과물 
										 SampleSize = A2CirInEdgeCount*0.75; //0.5~0.8이하로 입력할것
										 DistDevRatio = 0.15; //0.1~0.25 이하로 입력할것
										 CircleFit->OnRansac(A2CirInPoint,A2CirInEdgeCount,SampleSize,DistDevRatio,&ACircleFit2Center,&ACirFitDiameter2);

										 if(OrgA2CirOutEdgeCount>0){// A1 CircleOutData 
											 A2CirOutEdgeCount = OrgA2CirOutEdgeCount - A2CirOutEdgeCount;
											 Count =0;
											 if(A2CirOutEdgeCount>0){
												 if(A2CirOutPoint!=NULL) delete[] A2CirOutPoint;
												 A2CirOutPoint = new TFPoint[A2CirOutEdgeCount];

												 for(int k=0; k<OrgA2CirOutEdgeCount; k++){
													 if(k>MAX_CIRCLE_EDGEPOINT) break;
													 if(OrgA2CirOutPoint[k].x==0.0f && OrgA2CirOutPoint[k].y==0.0f) continue;
													 A2CirOutPoint[Count].x = OrgA2CirOutPoint[k].x;
													 A2CirOutPoint[Count].y = OrgA2CirOutPoint[k].y;
													 Count++;
												 }
											 }
											 // Circle 원본 데이터 메모리 삭제
											 if(OrgA2CirOutPoint!=NULL) delete[] OrgA2CirOutPoint;
										 }
										 // Circle 영역 꽃박리, 원형박리 검출 목적 시퀀스(EnCap)
										 // 정식 명칭은 몰라서.....일단 Crack으로 정함 
										 if(!IsMarkBtm && BrokenThresHold!=0){
											 if(ACirFitDiameter2!=0.0f && ACircleFit2Center.x!=0.0f && ACircleFit2Center.y!=0.0f){ // FAVION Circle Fitting 성공시 박리검사 진행 
												 Circle->GImage = &RotateBrokenImg;                                             //Binary Image 넘겨줌 

												 Circle->SetCenterXY(ACircleFit2Center.x,ACircleFit2Center.y);
												 // 											 Circle->SetTolerance(CirCrackMargin)                      ; // Circle Tolerance 
												 // 											 Circle->SetDiameter ((ACirFitDiameter2-CirCrackMargin)*2) ; // Circle Diameter 
												 Circle->SetTolerance((dEdgeToTrapLineDis/2)-CirOffsetMargin); // Circle Tolerance 
												 Circle->SetDiameter ((ACirFitDiameter2-(dEdgeToTrapLineDis/2))*2) ; // Circle Diameter 
												 Circle->SetCircleChoice(0)                                ; // 0:From Begin, 1:From End, 2:Largest Amplitude 
												 Circle->SetCircleType  (0)                                ; // 0:Black to White, 1:White to Black 2: Both Black, White 
												 Circle->SetCircleIndex (0)                                ; // Circle EdgePoint Index 
												 Circle->SetAngle(325)                                     ; // 패턴으로 인해서 오버킬 발생...범위를 좁혀준다 
												 Circle->SetAmplitude(25)                                  ; // 패턴으로 인해서 오버킬 발생...범위를 좁혀준다 
												 Circle->OnExecute(true)                                   ;
												 CrackACirDiameter2 = (ACirFitDiameter2-(dEdgeToTrapLineDis/2))+((dEdgeToTrapLineDis/2)-CirOffsetMargin);

												 A2CirInCrackCount = Circle->FCirclePointCount;

												 if(A2CirInCrackCount>0){
													 if(A2CirInCrackPoint!=NULL) delete[] A2CirInCrackPoint;
													 A2CirInCrackPoint = new TFPoint[A2CirInCrackCount];

													 for(int k=0; k<A2CirInCrackCount; k++){
														 if(k>MAX_CIRCLE_EDGEPOINT) break;
														 A2CirInCrackPoint[k].x = Circle->FCirclePoint[k].x;
														 A2CirInCrackPoint[k].y = Circle->FCirclePoint[k].y;
													 }
												 }
											 }
										 }
									 }
									 LogUnit.SetLog(L"RightTop_Mark_END");     
								 }
							 }
// 							 LogUnit.SetLog("shRectH_Rotate_RightTop_End");     
						 }
					 }
					 else if(FCompanyMode==COM_BMDT){ // Image회전 후 모자 검사 시퀀스(LeftLine,RightLine,TopLine,LeftTopLine,RightTopLine)
						 FLTPoint = Math.OnIntersect(Line[waLeftWall].FP0 , Line[waLeftWall].FP1 , Line[waTopWall].FP0, Line[waTopWall].FP1);
						 FRTPoint = Math.OnIntersect(Line[waRightWall].FP0, Line[waRightWall].FP1, Line[waTopWall].FP0, Line[waTopWall].FP1);

						 if(FP0.x!=0 && FP0.y!=0 && FP1.x!=0 && FP1.y!=0) ImgDegree = -(Math.GetDegree(FP0.x , FP0.y, FP1.x, FP1.y));

						 // 원본 RotateImg Size 설정 및 복사 
						 LogUnit.SetLog(L"shRectH_RotateImg_Start");     
						 RotateImg.SetSize(GImage->GetWidth(), GImage->GetHeight());
						 EasyImage::Oper(EArithmeticLogicOperation_Copy,GImage,&RotateImg);

						 // 원본 복사하여 이미지 회전 
						 EasyImage::ScaleRotate(GImage, (float)ImgW/2, (float)ImgH/2, (float)ImgW/2, (float)ImgH/2, 1.0f, 1.0f, ImgDegree, &RotateImg, 4);
						 CenterPoint.x = ImgW/2;
						 CenterPoint.y = ImgH/2;

// 						 RotateImg.Save("D:\\ROTATE_IMG\\BMDT_RotateImg회전_HAP.bmp");

						 // Binary RotateImg Size 설정 및 복사 
						 RotateBinaryImg.SetSize(RotateImg.GetWidth(), RotateImg.GetHeight());
						 EasyImage::Oper(EArithmeticLogicOperation_Copy,&RotateImg,&RotateBinaryImg);

						 // Grind Measure Corner, Circle 검사 목적 
						 RotateGrindBinaryImg.SetSize(RotateImg.GetWidth(), RotateImg.GetHeight());
						 EasyImage::Oper(EArithmeticLogicOperation_Copy,&RotateImg,&RotateGrindBinaryImg);
						 // 						 RotateBinaryImg.Save("D:\\ROTATE_IMG\\RotateBinaryImg회전_HAP.bmp");
						 LogUnit.SetLog(L"shRectH_RotateImg_End");     

						 // LeftLine 표면검사와 외관검사 동일 시퀀스(단,검출 Edge방향은 분류함)
						 if(FLeftWall){
							 EasyImage::Threshold(&RotateImg,&RotateBinaryImg, LeftEdgeThresHold);
							 if(LeftEdgeThresHold==0) {SingleLine->GImage = &RotateImg      ; SingleLine->FThreshold =5 ;}
							 else                     {SingleLine->GImage = &RotateBinaryImg; SingleLine->FThreshold =10;}

							 if(IsCircleTop){
								 SingleLine->IRoi->SetOrgX  (IRoi->GetOrgX()  );
								 SingleLine->IRoi->SetOrgY  (ASideCircleHeight+50);
								 SingleLine->IRoi->SetWidth (IRoi->GetWidth() );
								 SingleLine->IRoi->SetHeight(ImgH-(ASideCircleHeight+50));
								 SingleLine->SetIncrement(1 );
							 }
							 else {
								 SingleLine->IRoi->SetOrgX  (IRoi->GetOrgX()  );
								 SingleLine->IRoi->SetOrgY  (IRoi->GetOrgY()  );
								 SingleLine->IRoi->SetWidth (IRoi->GetWidth() );
								 SingleLine->IRoi->SetHeight(IRoi->GetHeight());
								 SingleLine->SetIncrement(5 );
							 }
							 SingleLine->SetOrientation(orWest);

							 SingleLine->SetFindLineId(0);

							 if(FInspectMode==Insp_Surface){
								 if(IsMarkBtm) SingleLine->SetEdgeType(1); // White to Black
								 else          SingleLine->SetEdgeType(1); // White to Black  
							 }
							 else             {
								 if(IsMarkBtm) SingleLine->SetEdgeType(0); // White to Black
								 else          SingleLine->SetEdgeType(0); // White to Black  
							 }

							 SingleLine->OnExecute();
							 Line[0].FP0 = SingleLine->GetResultP0();
							 Line[0].FP1 = SingleLine->GetResultP1();

							 // Btm,Top 상관없이 첫번째
							 // 비선형 아크영역으로 인해서 LeftLine 추가 조절해야함 
							 // 							 if(fabs(Line[0].FP0.x - Line[0].FP1.x)>2){
							 // 								 if(Line[0].FP0.x> Line[0].FP1.x) Line[0].FP0.x = Line[0].FP1.x;
							 // 								 if(Line[0].FP0.x< Line[0].FP1.x) Line[0].FP0.x = Line[0].FP1.x;
							 // 							 }
							 LeftOutLine[0].FP0.x = Line[0].FP0.x;
							 LeftOutLine[0].FP0.y = Line[0].FP0.y;
							 LeftOutLine[0].FP1.x = Line[0].FP1.x;
							 LeftOutLine[0].FP1.y = Line[0].FP1.y;

							 // LeftOutLine....make OutLine Data 
							 // 현재의 데이터를 넘겨준다 
							 // 검사중 기준라인을 찾지 못할경우 이전데이터 넘겨줘서 기준라인 생성함 
							 if(LeftOutLine[0].FP0.x!=0.0f && LeftOutLine[0].FP0.y!=0.0f && LeftOutLine[0].FP1.x!=0.0f && LeftOutLine[0].FP1.y!=0.0f){
								 PreLeftOutLine[0].FP0.x = LeftOutLine[0].FP0.x;    PreLeftOutLine[0].FP1.x = LeftOutLine[0].FP1.x;       
								 PreLeftOutLine[0].FP0.y = LeftOutLine[0].FP0.y;    PreLeftOutLine[0].FP1.y = LeftOutLine[0].FP1.y;       
							 } // 셀의 상단 시작부터 Broken 발생으로 데이터가 없는경우 
							 else if(LeftOutLine[0].FP0.x==0.0f || LeftOutLine[0].FP0.y==0.0f || LeftOutLine[0].FP1.x==0.0f || LeftOutLine[0].FP1.y==0.0f){
								 if(PreLeftOutLine[0].FP0.x==0.0f && PreLeftOutLine[0].FP0.y==0.0f && PreLeftOutLine[0].FP1.x==0.0f && PreLeftOutLine[0].FP1.y==0.0f){// 시작부분 Broken발생으로 데이터가 없는경우 
									 // Mark좌표를 기준으로 라인좌표값을 다시 설정함 
									 ROI_H = IRoi->GetHeight();
									 LeftOutLine[0].FP0.x = Line[0].FP0.x;    LeftOutLine[0].FP0.y = 0.0f        ;
									 LeftOutLine[0].FP1.x = Line[0].FP1.x;    LeftOutLine[0].FP1.y = (float)ROI_H;

									 //Line 데이터를 PreLine에 넘겨준다 
									 PreLeftOutLine[0].FP0.x = LeftOutLine[0].FP0.x;    PreLeftOutLine[0].FP1.x = LeftOutLine[0].FP1.x;       
									 PreLeftOutLine[0].FP0.y = LeftOutLine[0].FP0.y;    PreLeftOutLine[0].FP1.y = LeftOutLine[0].FP1.y;       
								 }
								 else { // 중간부분 Broken발생으로 데이터가 없는경우 
									 // PreLine 데이터를 넘겨줌 
									 LeftOutLine[0].FP0.x = PreLeftOutLine[0].FP0.x;  LeftOutLine[0].FP1.x = PreLeftOutLine[0].FP1.x;  
									 LeftOutLine[0].FP0.y = PreLeftOutLine[0].FP0.y;  LeftOutLine[0].FP1.y = PreLeftOutLine[0].FP1.y;  
								 }
							 }
						 }

						 // TopLine 표면검사와 외관검사 동일 시퀀스 
						 if(FTopWall ){
							 EasyImage::Threshold(&RotateImg,&RotateBinaryImg, TopEdgeThresHold);
							 if(TopEdgeThresHold==0)  {SingleLine->GImage = &RotateImg      ;  SingleLine->FThreshold = 5;}
							 else                     {SingleLine->GImage = &RotateBinaryImg;  SingleLine->FThreshold =10;}

							 SingleLine->IRoi->SetOrgX  (IRoi->GetOrgX());
							 SingleLine->IRoi->SetOrgY  (IRoi->GetOrgY());
							 SingleLine->IRoi->SetWidth (IRoi->GetWidth());
							 SingleLine->IRoi->SetHeight(IRoi->GetHeight());
							 if(IRoi->GetOrgX()<=0 || IRoi->GetWidth()<=0 || IRoi->GetHeight()<=0){
								 return false;
							 }

							 SingleLine->SetOrientation(orNorth);
							 SingleLine->FIncrement =100;
							 SingleLine->SetFindLineId(0);
							 SingleLine->FThreshold =5;

							 if(FInspectMode==Insp_Surface) SingleLine->SetEdgeType(1);  // White To Black 
							 else                           SingleLine->SetEdgeType(0);  // Black To White

							 SingleLine->OnExecute();
							 Line[1].FP0 = SingleLine->GetResultP0();
							 Line[1].FP1 = SingleLine->GetResultP1();
						 }

						 // RightLine 표면검사와 외관검사 동일 시퀀스(단,검출 Edge방향은 분류함)
						 if(FRightWall){
							 EasyImage::Threshold(&RotateImg,&RotateBinaryImg, RightEdgeThresHold);
							 if(LeftEdgeThresHold==0) {SingleLine->GImage = &RotateImg      ;  SingleLine->FThreshold =5 ;}
							 else                     {SingleLine->GImage = &RotateBinaryImg;  SingleLine->FThreshold =10;}

							 if(IsCircleTop){
								 SingleLine->IRoi->SetOrgX  (IRoi->GetOrgX()  );
								 SingleLine->IRoi->SetOrgY  (ASideCircleHeight+50);
								 SingleLine->IRoi->SetWidth (IRoi->GetWidth() );
								 SingleLine->IRoi->SetHeight(ImgH-(ASideCircleHeight+50));
								 SingleLine->SetIncrement(1 );
							 }
							 else {
								 SingleLine->IRoi->SetOrgX  (IRoi->GetOrgX()  );
								 SingleLine->IRoi->SetOrgY  (IRoi->GetOrgY()  );
								 SingleLine->IRoi->SetWidth (IRoi->GetWidth() );
								 SingleLine->IRoi->SetHeight(IRoi->GetHeight());
								 SingleLine->SetIncrement(5 );
							 }

							 SingleLine->SetOrientation(orEast);

							 SingleLine->SetFindLineId(0);
							 SingleLine->FThreshold =10;

							 if(FInspectMode==Insp_Surface){
								 if(IsMarkBtm) SingleLine->SetEdgeType(1); // White to Black  
								 else          SingleLine->SetEdgeType(1); // White to Black  
							 }
							 else             {
								 if(IsMarkBtm) SingleLine->SetEdgeType(0); // White to Black  
								 else          SingleLine->SetEdgeType(0); // White to Black  
							 }

							 SingleLine->OnExecute();
							 Line[2].FP0 = SingleLine->GetResultP0();
							 Line[2].FP1 = SingleLine->GetResultP1();

							 // Btm,Top 상관없이 첫번째
							 // 비선형 아크영역으로 인해서 LeftLine 추가 조절해야함 
							 // 							 if(fabs(Line[2].FP0.x - Line[2].FP1.x)>2){
							 // 								 if(Line[2].FP0.x> Line[2].FP1.x) Line[2].FP1.x = Line[2].FP0.x;
							 // 								 if(Line[2].FP0.x< Line[2].FP1.x) Line[2].FP0.x = Line[2].FP1.x;
							 // 							 }

							 RightOutLine[0].FP0.x = Line[2].FP0.x;
							 RightOutLine[0].FP0.y = Line[2].FP0.y;
							 RightOutLine[0].FP1.x = Line[2].FP1.x;
							 RightOutLine[0].FP1.y = Line[2].FP1.y;

							 // RightOutLine....make OutLine Data 
							 // 현재의 데이터를 넘겨준다 
							 // 검사중 기준라인을 찾지 못할경우 이전데이터 넘겨줘서 기준라인 생성함 
							 if(RightOutLine[0].FP0.x!=0.0f && RightOutLine[0].FP0.y!=0.0f && RightOutLine[0].FP1.x!=0.0f && RightOutLine[0].FP1.y!=0.0f){
								 PreRightOutLine[0].FP0.x = RightOutLine[0].FP0.x;    PreRightOutLine[0].FP1.x = RightOutLine[0].FP1.x;       
								 PreRightOutLine[0].FP0.y = RightOutLine[0].FP0.y;    PreRightOutLine[0].FP1.y = RightOutLine[0].FP1.y;       
							 } // 셀의 상단 시작부터 Broken 발생으로 데이터가 없는경우 
							 else if(RightOutLine[0].FP0.x==0.0f || RightOutLine[0].FP0.y==0.0f || RightOutLine[0].FP1.x==0.0f || RightOutLine[0].FP1.y==0.0f){
								 if(PreRightOutLine[0].FP0.x==0.0f && PreRightOutLine[0].FP0.y==0.0f && PreRightOutLine[0].FP1.x==0.0f && PreRightOutLine[0].FP1.y==0.0f){// 시작부분 Broken발생으로 데이터가 없는경우 
									 // Mark좌표를 기준으로 라인좌표값을 다시 설정함 
									 ROI_H = IRoi->GetHeight();
									 RightOutLine[0].FP0.x = Line[2].FP0.x;    RightOutLine[0].FP0.y = 0.0f        ;
									 RightOutLine[0].FP1.x = Line[2].FP1.x;    RightOutLine[0].FP1.y = (float)ROI_H;

									 //Line 데이터를 PreLine에 넘겨준다 
									 PreRightOutLine[0].FP0.x = RightOutLine[0].FP0.x;    PreRightOutLine[0].FP1.x = RightOutLine[0].FP1.x;       
									 PreRightOutLine[0].FP0.y = RightOutLine[0].FP0.y;    PreRightOutLine[0].FP1.y = RightOutLine[0].FP1.y;       
								 }
								 else { // 중간부분 Broken발생으로 데이터가 없는경우 
									 // PreLine 데이터를 넘겨줌 
									 RightOutLine[0].FP0.x = PreRightOutLine[0].FP0.x;  RightOutLine[0].FP1.x = PreRightOutLine[0].FP1.x;  
									 RightOutLine[0].FP0.y = PreRightOutLine[0].FP0.y;  RightOutLine[0].FP1.y = PreRightOutLine[0].FP1.y;  
								 }
							 }
						 }
						 // Org Image Rotate 후 교차점 다시 계산 
						 FLTPoint = Math.OnIntersect(Line[waLeftWall ].FP0, Line[waLeftWall ].FP1, Line[waTopWall].FP0, Line[waTopWall].FP1);
						 FRTPoint = Math.OnIntersect(Line[waRightWall].FP0, Line[waRightWall].FP1, Line[waTopWall].FP0, Line[waTopWall].FP1);

						 if(FLeftTop){ // 
							 if(FInspectMode==Insp_Surface){ // 표면검사 ==> 이미지 회전 각도 기준으로 AlignMark 회전함 
								 if(FP0.x!=0.0f && FP0.y!=0.0f && Line[1].FP0.x!=0.0f && Line[1].FP0.y!=0.0f && Line[1].FP1.x!=0.0f && Line[1].FP1.y!=0.0f ) {
									 FP0 = Math.OnRotate(CenterPoint,FP0, -ImgDegree);
								 }
								 if(FP1.x!=0.0f && FP1.y!=0.0f && Line[1].FP0.x!=0.0f && Line[1].FP0.y!=0.0f && Line[1].FP1.x!=0.0f && Line[1].FP1.y!=0.0f ) {
									 FP1 = Math.OnRotate(CenterPoint,FP1, -ImgDegree);
								 }

								 // A_Side(패드) 영역은 표면검사에서 제외한다 
								 // 즉, AlignMark기준으로 영역을 재 설정한다 
								 FLTPoint   = Math.OnIntersect(Line[waLeftWall].FP0 , Line[waLeftWall].FP1 , FP0, FP1);
								 FLTPoint.y = (FLTPoint.y+100) > ImgH ? FLTPoint.y:(FLTPoint.y+100);
								 FRTPoint = Math.OnIntersect(Line[waRightWall].FP0, Line[waRightWall].FP1, FP0, FP1);
								 FRTPoint.y = (FRTPoint.y+100) > ImgH ? FRTPoint.y:(FRTPoint.y+100);
							 }
							 else             {
								 LogUnit.SetLog(L"shRectH_Rotate_LeftTop_Start");     
								 EasyImage::Threshold(&RotateImg,&RotateBinaryImg, ECThresHold);
								 EasyImage::Threshold(&RotateImg,&RotateGrindBinaryImg, CorGrindMeaThresHold);

								 if(ECThresHold==0)  {SingleLine->GImage = &RotateImg      ;  SingleLine->FThreshold =5 ;}
								 else                {SingleLine->GImage = &RotateBinaryImg;  SingleLine->FThreshold =10;}

								 OrgPoint = Math.OnIntersect(Line[waLeftWall].FP0, Line[waLeftWall].FP1, Line[waTopWall].FP0, Line[waTopWall].FP1);
								 FLTPoint = OrgPoint;

								 // Left Mark To TopSide Height 
								 if(IsMarkBtm){
									 if(FP0.x!=0.0f && FP0.y!=0.0f && Line[1].FP0.x!=0.0f && Line[1].FP0.y!=0.0f && Line[1].FP1.x!=0.0f && Line[1].FP1.y!=0.0f ) {
										 FP0 = Math.OnRotate(CenterPoint,FP0, -ImgDegree);
										 LeftMarkToTopHeight = GetLengthFrLineToPoint(Line[1].FP0, Line[1].FP1, FP0);
										 // 								 LeftMarkToTopHeight = FP0.y - Line[1].FP0.y;
									 }
									 // Right Mark To TopSide Height 
									 if(FP1.x!=0.0f && FP1.y!=0.0f && Line[1].FP0.x!=0.0f && Line[1].FP0.y!=0.0f && Line[1].FP1.x!=0.0f && Line[1].FP1.y!=0.0f ) {
										 FP1 = Math.OnRotate(CenterPoint,FP1, -ImgDegree);
										 RightMarkToTopHeight = GetLengthFrLineToPoint(Line[1].FP0, Line[1].FP1, FP1);
										 // 								 RightMarkToTopHeight = FP1.y - Line[1].FP1.y;
									 }
									 // Center Mark To TopSide Height
									 if(LeftMarkToTopHeight!=0.0f && RightMarkToTopHeight!=0.0f){
										 CenMarkToTopHeight = ((FP0.y+FP1.y)/2.0) - ((Line[1].FP0.y+Line[1].FP1.y)/2.0);
									 }
								 }

								 if(IsCornerTop){ //코너 연마량 설정되어 있을경우 코너 검사진행함(Dx,Dy,R,GW,GM 측정함)
									 // Corner 연마 외곽라인 
									 SingleLine->IRoi->SetOrgX  ((int)OrgPoint.x-10    );
									 SingleLine->IRoi->SetOrgY  ((int)OrgPoint.y       );
									 SingleLine->IRoi->SetWidth ((int)LTCornerWidth+20 );
									 SingleLine->IRoi->SetHeight((int)LTCornerHeight   );

									 // 								 SingleLine->SetOrientation(orNorth);
									 SingleLine->SetOrientation(orWest);
									 SingleLine->FIncrement =1;
									 SingleLine->FThreshold =15;
									 SingleLine->SetFindLineId(0);
									 SingleLine->SetEdgeType(1);  //White To Black 
									 SingleLine->OnExecute();
									 // 									Line[waLeftTop].FP0 = SingleLine->GetResultP0();
									 // 									Line[waLeftTop].FP1 = SingleLine->GetResultP1();
									 Line[4].FP0 = SingleLine->GetResultP0();
									 Line[4].FP1 = SingleLine->GetResultP1();

									 // ORG 교차점 
									 FLTLPoint = Math.OnIntersect(SingleLine->GetResultP0(), SingleLine->GetResultP1(), Line[waLeftWall].FP0, Line[waLeftWall].FP1);
									 FLTTPoint = Math.OnIntersect(SingleLine->GetResultP0(), SingleLine->GetResultP1(), Line[waTopWall ].FP0, Line[waTopWall ].FP1);

									 if((FLTLPoint.x==0 || FLTLPoint.y==0 || FLTTPoint.x==0 || FLTTPoint.y==0) || (SingleLine->FEdgePointCount <30)){
										 LTDx = 0.0f;
										 LTDy = 0.0f;
										 //화면에 디스플레이 위해서 
										 FLTLPoint.x = FLTPoint.x;
										 FLTLPoint.y = FLTPoint.y;
										 FLTTPoint.x = FLTPoint.x;
										 FLTTPoint.y = FLTPoint.y;
									 }
									 else { 
										 LTDx = Math.GetLengthFrPointToPoint(FLTPoint, FLTTPoint);
										 LTDy = Math.GetLengthFrPointToPoint(FLTPoint, FLTLPoint);

										 // OutLine C1Corner Data 
										 if((SingleLine->FEdgePointCount) - (CornerMargin*2)>0){
											 if(C1Point!=NULL) delete[] C1Point;
											 C1Point  = new TFPoint [(SingleLine->FEdgePointCount) - (CornerMargin*2)];
											 C1EdgeCount = (SingleLine->FEdgePointCount) -(CornerMargin*2);

											 CornerCount =0;  
											 for(int k=CornerMargin; k<((SingleLine->FEdgePointCount)-CornerMargin); k++){
												 if(CornerCount>=MAX_CORNER_POINT) break;
												 C1Point[CornerCount].x = SingleLine->FEdgePoint[k].x;
												 C1Point[CornerCount].y = SingleLine->FEdgePoint[k].y;
												 CornerCount++;
											 }
										 }

										 // 다시 데이터 산출함 TEST목적
										 // 									 for(int k=0; k<C1EdgeCount; k++){
										 // 										 if(k==0              ) P1 = C1Point[k];
										 // 										 if(k==(C1EdgeCount-1)) P2 = C1Point[k];
										 // 									 }
										 // 									 if(P1.x!=0.0f && P1.y!=0.0f && P2.x!=0.0f && P2.y!=0.0f){
										 // 										 // ORG 교차점 
										 // 										 FLTLPoint = Math.OnIntersect(P1, P2, Line[waLeftWall].FP0, Line[waLeftWall].FP1);
										 // 										 FLTTPoint = Math.OnIntersect(P1, P2, Line[waTopWall ].FP0, Line[waTopWall ].FP1);
										 // 									 }

										 // Corner 기울기 완만하여 Edge찾을 경우 Defect 오버킬 발생함 
										 // 방향을 Top방향에서 다시 엣지를 찾음 (Corner Defect OverKill 감소 목적)
										 // 										if(LTCornerWidth >(LTCornerHeight*3)){
										 if(LTCornerWidth >(LTCornerHeight*1.5)){
											 SingleLine->IRoi->SetOrgX  ((int)FLTPoint.x );
											 SingleLine->IRoi->SetOrgY  ((int)FLTPoint.y );
											 SingleLine->IRoi->SetWidth ((int)((FLTTPoint.x - FLTLPoint.x+5 )));
											 SingleLine->IRoi->SetHeight((int)((FLTLPoint.y - FLTTPoint.y+10)));
											 // 										 SingleLine->IRoi->SetWidth ((int)((FLTTPoint.x - FLTLPoint.x+100)));
											 // 										 SingleLine->IRoi->SetHeight((int)((FLTLPoint.y - FLTTPoint.y+30 )));


											 if(FLTPoint.x<=0    || FLTPoint.y<=0    || (FLTTPoint.x - FLTLPoint.x)<=0    || (FLTLPoint.y - FLTTPoint.y)<=0   ) return false;
											 if(FLTPoint.x>=ImgW || FLTPoint.y>=ImgH || (FLTTPoint.x - FLTLPoint.x)>=ImgW || (FLTLPoint.y - FLTTPoint.y)>=ImgH) return false;

											 SingleLine->SetOrientation(orNorth);
											 SingleLine->FIncrement =2;
											 SingleLine->SetFindLineId(0);
											 SingleLine->SetEdgeType(0);  //Black To White 
											 SingleLine->OnExecute();

											 // InLine C1Corner Data 
											 if((SingleLine->FEdgePointCount) - (CornerMargin*2)>0){
												 if(C1InPoint!=NULL) delete[] C1InPoint;
												 C1InPoint  = new TFPoint [(SingleLine->FEdgePointCount) - (CornerMargin*2)];
												 C1InEdgeCount = (SingleLine->FEdgePointCount) -(CornerMargin*2);

												 CornerCount =0;  
												 for(int k=CornerMargin; k<((SingleLine->FEdgePointCount)-CornerMargin); k++){
													 if(CornerCount>=MAX_CORNER_POINT) break;
													 C1InPoint[CornerCount].x = SingleLine->FEdgePoint[k].x;
													 C1InPoint[CornerCount].y = SingleLine->FEdgePoint[k].y;
													 CornerCount++;
												 }
											 }
										 }
										 else {
											 // Corner 연마 안쪽라인 찾는다 
											 SingleLine->SetOrientation(orWest);
											 SingleLine->SetFindLineId(0);
											 SingleLine->FIncrement =1;
											 SingleLine->SetEdgeType(0);  //Black To White 
											 SingleLine->OnExecute();

											 // InLine C1Corner Data 
											 if((SingleLine->FEdgePointCount) - (CornerMargin*2)>0){
												 if(C1InPoint!=NULL) delete[] C1InPoint;
												 C1InPoint  = new TFPoint [(SingleLine->FEdgePointCount) - (CornerMargin*2)];
												 C1InEdgeCount = (SingleLine->FEdgePointCount) -(CornerMargin*2);

												 CornerCount =0;  
												 for(int k=CornerMargin; k<((SingleLine->FEdgePointCount)-CornerMargin); k++){
													 if(CornerCount>=MAX_CORNER_POINT) break;
													 C1InPoint[CornerCount].x = SingleLine->FEdgePoint[k].x;
													 C1InPoint[CornerCount].y = SingleLine->FEdgePoint[k].y;
													 CornerCount++;
												 }
											 }
										 }


										 //코너 연마안쪽라인 기준 새로운 교차점 생성 
										 FLTLInPoint = Math.OnIntersect(SingleLine->GetResultP0(), SingleLine->GetResultP1(), Line[waLeftWall].FP0, Line[waLeftWall].FP1);
										 FLTTInPoint = Math.OnIntersect(SingleLine->GetResultP0(), SingleLine->GetResultP1(), Line[waTopWall ].FP0, Line[waTopWall ].FP1);

										 //코너 연마폭 
										 double Dis =0.0f, AvgGrindWidth=0.0f, AvgGrindMea=0.0f, TotalGrindWidth=0.0f, TotalGrindMeasure=0.0f;
										 for(int k=0; k<C1InEdgeCount; k++){
											 Dis = Math.GetLengthFrLineToPoint(FLTLPoint, FLTTPoint, C1InPoint[k]);
											 TotalGrindWidth+=Dis;
										 }
										 if(C1InEdgeCount!=0){
											 AvgGrindWidth = (TotalGrindWidth/C1InEdgeCount);
											 C1CorGrindWd  = AvgGrindWidth;
										 }


										 if(CorGrindMeaThresHold!=0){ // Corner Grind ThresHold값이 설정되어 있을경우만 연마량 검사를 진행한다 
											 // 코너 연마량 기준 라인을 찾는다 
											 // ROI 영역 설정(3개의 흰색 점선 기준 라인을 찾는다)
											 if(CorGrindMeaThresHold==0){SingleLine->GImage = &RotateImg           ;  SingleLine->FThreshold =5 ;}
											 else                       {SingleLine->GImage = &RotateGrindBinaryImg;  SingleLine->FThreshold =10;}

											 // 										SingleLine->IRoi->SetOrgX  ((int)OrgPoint.x       );
											 // 										SingleLine->IRoi->SetOrgY  ((int)OrgPoint.y+20    );
											 // 										SingleLine->IRoi->SetWidth ((int)LTCornerWidth +50);
											 // 										SingleLine->IRoi->SetHeight((int)LTCornerHeight   );
											 // 존나 찝찝함....일단 스팩을 받기전까지 임시로 영역을 분류하여 CornerEdgePoint 찾자 
											 if(LTCornerWidth >(LTCornerHeight*1.5)){
												 // 											 SingleLine->IRoi->SetOrgX  ((int)OrgPoint.x       );
												 // 											 SingleLine->IRoi->SetOrgY  ((int)OrgPoint.y+15    );
												 // 											 SingleLine->IRoi->SetWidth (550                   );
												 // 											 SingleLine->IRoi->SetHeight((int)LTCornerHeight-20);

												 SingleLine->IRoi->SetOrgX  ((int)OrgPoint.x+500   );
												 SingleLine->IRoi->SetOrgY  ((int)OrgPoint.y       );
												 SingleLine->IRoi->SetWidth (450                   );
												 SingleLine->IRoi->SetHeight((int)LTCornerHeight-30);

												 SingleLine->SetOrientation(orNorth);
												 SingleLine->SetFindLineId(0);
												 SingleLine->FIncrement =1;
												 SingleLine->SetEdgeType(0);  //Black To White 
												 SingleLine->OnExecute();

												 // 											 P1 = SingleLine->GetResultP0();
												 // 											 P2 = SingleLine->GetResultP1();

												 //코너 연마량 기준 라인과 새로운 교차점 생성 
												 // 											 FLTLMeaPoint = Math.OnIntersect(SingleLine->GetResultP0(), SingleLine->GetResultP1(), Line[waLeftWall].FP0, Line[waLeftWall].FP1);
												 // 											 FLTTMeaPoint = Math.OnIntersect(SingleLine->GetResultP0(), SingleLine->GetResultP1(), Line[waTopWall ].FP0, Line[waTopWall ].FP1);

												 // C1Corner Grind Measure Stand Data 
												 if((SingleLine->FEdgePointCount)>0){
													 if(C1MeaPoint!=NULL) delete[] C1MeaPoint;
													 C1MeaPoint     = new TFPoint [(SingleLine->FEdgePointCount)];
													 C1MeaEdgeCount = (SingleLine->FEdgePointCount);

													 CornerCount =0;  
													 for(int k=0; k<(SingleLine->FEdgePointCount); k++){
														 if(CornerCount>=MAX_CORNER_POINT) break;
														 if(k==0               ) P1 = SingleLine->FEdgePoint[k];
														 if(k==C1MeaEdgeCount-1) P2 = SingleLine->FEdgePoint[k];
														 C1MeaPoint[CornerCount].x = SingleLine->FEdgePoint[k].x;
														 C1MeaPoint[CornerCount].y = SingleLine->FEdgePoint[k].y;
														 CornerCount++;
													 }
												 }

												 FLTLMeaPoint = Math.OnIntersect(P1, P2, Line[waLeftWall].FP0, Line[waLeftWall].FP1);
												 FLTTMeaPoint = Math.OnIntersect(P1, P2, Line[waTopWall ].FP0, Line[waTopWall ].FP1);


												 //코너 연마량 계산  
												 Dis =0.0f, AvgGrindMea=0.0f, TotalGrindMeasure=0.0f;
												 for(int k=0; k<C1EdgeCount; k++){
													 Dis = Math.GetLengthFrLineToPoint(FLTLMeaPoint, FLTTMeaPoint, C1Point[k]);
													 TotalGrindMeasure+=Dis;
												 }
												 if(C1EdgeCount!=0){
													 AvgGrindMea    = (TotalGrindMeasure/C1EdgeCount);
													 C1CorGrindMea  = AvgGrindMea;
												 }
											 }
											 else {
												 SingleLine->IRoi->SetOrgX  ((int)OrgPoint.x+15    );
												 SingleLine->IRoi->SetOrgY  ((int)OrgPoint.y+15    );
												 SingleLine->IRoi->SetWidth ((int)LTCornerWidth    );
												 SingleLine->IRoi->SetHeight((int)LTCornerHeight   );

												 // 											 SingleLine->IRoi->SetOrgX  ((int)OrgPoint.x       );
												 // 											 SingleLine->IRoi->SetOrgY  ((int)OrgPoint.y+15    );
												 // 											 SingleLine->IRoi->SetWidth ((int)LTCornerWidth -10);
												 // 											 SingleLine->IRoi->SetHeight((int)LTCornerHeight-15);

												 SingleLine->SetOrientation(orWest);
												 SingleLine->SetFindLineId(0);
												 SingleLine->FIncrement =1;
												 SingleLine->SetEdgeType(0);  //Black To White 
												 SingleLine->OnExecute();

												 P1 = SingleLine->GetResultP0();
												 P2 = SingleLine->GetResultP1();

												 //코너 연마량 기준 라인과 새로운 교차점 생성 
												 FLTLMeaPoint = Math.OnIntersect(SingleLine->GetResultP0(), SingleLine->GetResultP1(), Line[waLeftWall].FP0, Line[waLeftWall].FP1);
												 FLTTMeaPoint = Math.OnIntersect(SingleLine->GetResultP0(), SingleLine->GetResultP1(), Line[waTopWall ].FP0, Line[waTopWall ].FP1);

												 // C1Corner Grind Measure Stand Data 
												 if((SingleLine->FEdgePointCount)>0){
													 if(C1MeaPoint!=NULL) delete[] C1MeaPoint;
													 C1MeaPoint     = new TFPoint [(SingleLine->FEdgePointCount)];
													 C1MeaEdgeCount = (SingleLine->FEdgePointCount);

													 CornerCount =0;  
													 for(int k=0; k<(SingleLine->FEdgePointCount); k++){
														 if(CornerCount>=MAX_CORNER_POINT) break;
														 C1MeaPoint[CornerCount].x = SingleLine->FEdgePoint[k].x;
														 C1MeaPoint[CornerCount].y = SingleLine->FEdgePoint[k].y;
														 CornerCount++;
													 }
												 }
												 //코너 연마량 계산  
												 Dis =0.0f, AvgGrindMea=0.0f, TotalGrindMeasure=0.0f;
												 for(int k=0; k<C1EdgeCount; k++){
													 Dis = Math.GetLengthFrLineToPoint(FLTLMeaPoint, FLTTMeaPoint, C1Point[k]);
													 TotalGrindMeasure+=Dis;
												 }
												 if(C1EdgeCount!=0){
													 AvgGrindMea    = (TotalGrindMeasure/C1EdgeCount);
													 C1CorGrindMea  = AvgGrindMea;
												 }
												 // 											 Dis =0.0f, AvgGrindMea=0.0f, TotalGrindMeasure=0.0f;
												 // 											 for(int k=0; k<C1MeaEdgeCount; k++){
												 // 												 Dis = Math.GetLengthFrLineToPoint(FLTLPoint, FLTTPoint, C1MeaPoint[k]);
												 // 												 TotalGrindMeasure+=Dis;
												 // 											 }
												 // 											 if(C1MeaEdgeCount!=0){
												 // 												 AvgGrindMea    = (TotalGrindMeasure/C1MeaEdgeCount);
												 // 												 C1CorGrindMea  = AvgGrindMea;
												 // 											 }
											 }
										 }
									 }		
								 }
								 else if(IsRectTop){ // 코너 설정값이 없을경우 교차점 기준 검사 Rect검사  
									 LTDx = 0.0f;
									 LTDy = 0.0f;
									 //화면에 디스플레이 위해서 
									 FLTLPoint.x = FLTPoint.x;
									 FLTLPoint.y = FLTPoint.y;
									 FLTTPoint.x = FLTPoint.x;
									 FLTTPoint.y = FLTPoint.y;
								 }
								 else if(IsCircleTop){ // TOP영역 LeftTop Circle 검사 
									 //EasyImage::Threshold(&RotateImg,&RotateBinaryImg, (ECThresHold+5));
									 // TrackLine or GrindMark기준 선택하여 가공량 측정 시퀀스는 코딩하지 않음
									 // Org A1CircleData 
									 // 비선형 곡선 형태의 연마일경우 검사 시퀀스 TEST목적 
									 // BMDT 
									 int OrgA1CirInEdgeCount =0;		  
									 int OrgA1CirOutEdgeCount=0;	    
									 int A1GrindWidthCount   =0;		  
									 int A1GrindMarkCount    =0;
									 int A1Diameter          =0;
									 GrindRectWidth          =0;
									 GrindRectHeight         =0;

									 TFPoint *OrgA1CirInPoint =NULL;	 
									 TFPoint *OrgA1CirOutPoint=NULL;

									 TFPoint AGrindMarkRectPoint1(0.0f, 0.0f);

									 // Find Mark Search Start
									 ////////////////////////////////////////////////////////////////////////////
									 if(IsMarkBtm && FInspectMode!=Insp_Track){
										 if(FP0.x!=0.0f && FP0.y!=0.0f){
											 GrindMarkRect[25].left   = (FP0.x-AMarkToGrindMarkDvX)-40;
											 GrindMarkRect[25].top    = (FP0.y+AMarkToGrindMarkDvY)-40;
											 GrindMarkRect[25].right  = (GrindMarkRect[25].left + 80);
											 GrindMarkRect[25].bottom = (GrindMarkRect[25].top  + 80);

											 GrindRectWidth  = (GrindMarkRect[25].right  - GrindMarkRect[25].left);
											 GrindRectHeight = (GrindMarkRect[25].bottom - GrindMarkRect[25].top );
										 }
										 // 원본이미지에서 Mark 찾는다 
										 Find->OnLoad(true,FindDir,1)                   ;
										 Find->GImage = &RotateImg                      ;
										 // 									 Find->SetContrastMode(EFindContrastMode_Any)   ;
										 Find->SetContrastMode(EFindContrastMode_Normal);
										 // 									 Find->SetMinScore(0.8f)                        ;
										 Find->SetMinScore (GrindPadMarkMinScore)       ; // PatternrFind 검사 최소 Score
										 Find->SetZeroScore(GrindPadMarkMinScore)       ; // 검사 후 최소 Score 
										 // 									 Find->SetMinScore (0.75)                       ; // PatternrFind 검사 최소 Score
										 // 									 Find->SetZeroScore(0.75)                       ; // 검사 후 최소 Score 
										 Find->SetMaxInstances(1)                       ;
										 Find->SetAngleTolerance(20.0f)                  ;
										 Find->SetAngleBias(45.0f)                      ;
										 Find->SetScaleBias(1.00f)                      ;
										 Find->SetScaleTolerance(0.0f)                  ;
										 Find->Property.Ox = (float)ImgW/2              ;
										 Find->Property.Oy = (float)ImgH/2              ;

										 Find->IRoi->SetPlacement(GrindMarkRect[25].left,GrindMarkRect[25].top,GrindRectWidth,GrindRectHeight);
										 if(GrindMarkRect[25].left<=0 || GrindMarkRect[25].top<=0 || GrindRectWidth<=0 || GrindRectHeight<=0) return false;

										 // 검사 및 Match Pos 좌표 받어온다 
										 // Find 검사 성공시 데이터 받아옴 
										 if(Find->OnExecute()){
											 GrindMarkPoint[25].x = Find->Result[0].Px;
											 GrindMarkPoint[25].y = Find->Result[0].Py;
											 GrindMarkScore[25]   = Find->Result[0].Score;
										 }
										 // Contrast Gradient Pixel Value
										 GrindMarkGradient[25] = EasyImage::Focusing(Find->IRoi);
									 }
									 // Find Mark Search Start
									 ////////////////////////////////////////////////////////////////////////////


									 if(FInspectMode==Insp_Polygon){ // BMDT LeftTop 비선형 곡선 알고리즘 
// 										 RotateBinaryImg.Save("D:\\ROTATE_IMG\\Polygon_LeftTop_원본.bmp");
										 TPoint P1(0,0),P2(0,0),P3(0,0),P4(0,0);

										 P1.x = (int)(FLTPoint.x-20);    P1.y =(int)(FLTPoint.y-20            ); P2.x = (int)(P1.x+ASideCircleWidth+50);    P2.y = (int)(P1.y);
										 P3.x = (int)(FLTPoint.x-20);    P3.y =(int)(P1.y+ASideCircleHeight+50); P4.x = (int)(P2.x                    );    P4.y = (int)(P3.y);
										 int PixelCnt =0;

										 // Median Filter 적용 
										 if(P1.x<=0    || P1.y<=0    || (P2.x - P1.x)<=0    || (P3.y - P1.y)<=0   ) return false;
										 if(P1.x>=ImgW || P1.y>=ImgH || (P2.x - P1.x)>=ImgW || (P3.y - P1.y)>=ImgH) return false;
										 FilterROI.SetSize(int(P2.x - P1.x),int(P3.y - P1.y) )                 ;
										 FilterROI.Attach(&RotateBinaryImg)                                    ;
										 FilterROI.SetPlacement(P1.x, P1.y, int(P2.x - P1.x), int(P3.y - P1.y));
										 EasyImage::Median(&FilterROI, &FilterROI)                             ;

// 										 RotateBinaryImg.Save("D:\\ROTATE_IMG\\Polygon_LeftTop_필터.bmp");

										 Polygon->GImage = &RotateBinaryImg                          ;
										 Polygon->IWidth = ImgW                                      ;
										 Polygon->IHeight= ImgH                                      ;
										 Polygon->PoPa.FMinWidth  =300                               ;
										 Polygon->PoPa.FMaxWidth  =(int)((FRTPoint.x - FLTPoint.x)/2);
										 Polygon->PoPa.FMinHeight =50                                ;
										 Polygon->PoPa.FMaxHeight =1000                              ;
										 Polygon->PoPa.MinPxCnt   =100                               ;
										 Polygon->PoPa.MaxPxCnt   =20000                             ;
										 Polygon->PoPa.MaxBbCnt   =10                                ;
										 Polygon->PoPa.IsSeparate =true                              ;
										 Polygon->PoPa.IsInToOut  =false                             ;
										 Polygon->PoPa.HiThHold   = ECThresHold                      ;
										 Polygon->PoPa.LoThHold   = 0                                ;

										 if(P1.x!=0 && P1.y!=0 && P2.x!=0 && P2.y!=0 && P3.x!=0 && P3.y!=0 && P4.x!=0 && P4.y!=0){
											 Polygon->OnExecute(P1,P2,P3,P4);
										 }

										 // Polygon Algorithm InEdgeData/OutEdgeData Separate 
										 if(Polygon->BlobCount==1){
											 PolygonMarginCnt =5;
											 if(Polygon->Blob[0].InCnt>(PolygonMarginCnt*2)){
												 A1CirInEdgeCount=0;
												 A1CirInEdgeCount = (Polygon->Blob[0].InCnt - (PolygonMarginCnt*2));
												 if(A1CirInEdgeCount>0){
													 if(A1CirInPoint!=NULL) delete[] A1CirInPoint;
													 A1CirInPoint = new TFPoint[A1CirInEdgeCount];

													 PixelCnt=0;
													 for(int k=0; k<Polygon->Blob[0].InCnt; k++){
														 if(k<PolygonMarginCnt || k>=(Polygon->Blob[0].InCnt-PolygonMarginCnt)) continue;
														 A1CirInPoint[PixelCnt].x   = Polygon->Blob[0].InPoint[k].x ;
														 A1CirInPoint[PixelCnt].y   = Polygon->Blob[0].InPoint[k].y ;
														 PixelCnt++;
													 }
												 }
											 }

											 if(Polygon->Blob[0].OutCnt>(PolygonMarginCnt*2)){
												 A1CirOutEdgeCount=0;
												 A1CirOutEdgeCount = (Polygon->Blob[0].OutCnt - (PolygonMarginCnt*2));
												 if(A1CirOutEdgeCount>0){
													 if(A1CirOutPoint!=NULL) delete[] A1CirOutPoint;
													 A1CirOutPoint = new TFPoint[A1CirOutEdgeCount];

													 PixelCnt=0;
													 for(int k=0; k<Polygon->Blob[0].OutCnt; k++){
														 if(k<PolygonMarginCnt || k>=(Polygon->Blob[0].OutCnt-PolygonMarginCnt)) continue;
														 A1CirOutPoint[PixelCnt].x  = Polygon->Blob[0].OutPoint[k].x ;
														 A1CirOutPoint[PixelCnt].y  = Polygon->Blob[0].OutPoint[k].y ;
														 PixelCnt++;
													 }
												 }
											 }
										 }

										 // InEdgeData/OutEdgeData 기준 가공량 및 연마량 계산
										 // Polygon 알고리즘에서는 GrindMark기준 OutData,InData 최단거리 2개 Tag값 산출해야함 
										 if(IsMarkBtm){ // LTPS 가공량,연마량 계산 
											 if(A1CirOutEdgeCount!=0 && A1CirInEdgeCount!=0){ // MarkMode경우 가공량 검사를 먼저 진행 후 연마량 산출  
												 if(GrindMarkPoint[25].x!=0.0f && GrindMarkPoint[25].y!=0.0f){  //GrindMark 찾았을경우 
													 // GrindMark기준 OutData 최단거리 Count정보 Calc 
													 GrindMeaDis =0.0f, MinDis =10000.0f; GrindMarkOutCnt=0;
													 for(int k=0; k<A1CirOutEdgeCount; k++){
														 if(A1CirOutPoint[k].x  ==0.0f || A1CirOutPoint[k].y  ==0.0f) continue;
														 if(GrindMarkPoint[25].x==0.0f || GrindMarkPoint[25].y==0.0f) continue;

														 GrindMeaDis = Math.GetLength(GrindMarkPoint[25], A1CirOutPoint[k]);
														 if(GrindMeaDis<MinDis){
															 MinDis = GrindMeaDis;
															 GrindMarkOutCnt = k;
														 }
													 }
													 // GrindMark기준 InData 최단거리 Count정보 Calc 
													 GrindMeaDis =0.0f, MinDis =10000.0f; GrindMarkInCnt=0;
													 for(int k=0; k<A1CirInEdgeCount; k++){
														 if(A1CirInPoint[k].x   ==0.0f || A1CirInPoint[k].y    ==0.0f) continue;
														 if(GrindMarkPoint[25].x==0.0f || GrindMarkPoint[25].y ==0.0f) continue;

														 GrindMeaDis = Math.GetLength(GrindMarkPoint[25], A1CirInPoint[k]);
														 if(GrindMeaDis<MinDis){
															 MinDis = GrindMeaDis;
															 GrindMarkInCnt = k;
														 }
													 }

													 int Org1GrindMarkInCnt = GrindMarkInCnt;
													 TFPoint Org1, New1;
													 Org1.x  = A1CirInPoint[Org1GrindMarkInCnt].x;  Org1.y= A1CirInPoint[Org1GrindMarkInCnt].y;
													 // GrindMark기준 InData 최단거리 Count정보 Calc 
													 if(GrindMarkOutCnt!=0){
														 GrindMeaDis =0.0f, MinDis =10000.0f; GrindMarkInCnt=0;
														 for(int k=0; k<A1CirInEdgeCount; k++){
															 if(A1CirInPoint[k].x   ==0.0f             || A1CirInPoint[k].y                ==0.0f) continue;
															 if(A1CirOutPoint[GrindMarkOutCnt].x==0.0f || A1CirOutPoint[GrindMarkOutCnt].y ==0.0f) continue;

															 GrindMeaDis = Math.GetLength(A1CirOutPoint[GrindMarkOutCnt], A1CirInPoint[k]);
															 if(GrindMeaDis<MinDis){
																 MinDis = GrindMeaDis;
																 GrindMarkInCnt = k;
															 }
														 }
													 }
													 New1.x  = A1CirInPoint[GrindMarkInCnt].x;  New1.y= A1CirInPoint[GrindMarkInCnt].y;

													 // GrindMark기준 수직 포인트 주변값 Avg산출한다 ==>가공량 측정(OutData기준)
													 if(GrindMarkOutCnt!=0 && GrindMarkOutCnt>5){
														 CircleCount=0,TotalCirDis=0.0f,GrindMeaDis=0.0f;
														 for(int k=GrindMarkOutCnt-5; k<GrindMarkOutCnt+5; k++){
															 if(A1CirOutPoint[k].x==0.0f || A1CirOutPoint[k].y==0.0f) continue;

															 GrindMeaDis = Math.GetLength(GrindMarkPoint[25], A1CirOutPoint[k]);
															 TotalCirDis+= GrindMeaDis;
															 CircleCount++;
														 }
														 if(TotalCirDis!=0.0f && CircleCount!=0){
															 A1CirGrindMea[2] = TotalCirDis/CircleCount;
															 A1CirGrindMea[2] = A1CirGrindMea[2]+0.5; //SubPixel 
														 }
													 }

													 // GrindMark기준 수직 포인트 주변값 Avg산출한다 ==>연마량 측정(OutData,InData기준)
													 if((GrindMarkOutCnt!=0 && GrindMarkOutCnt>5) && (GrindMarkInCnt!=0 && GrindMarkInCnt>5)){
														 CircleCount=0,TotalCirDis=0.0f,GrindWidthDis=0.0f;
														 for(int k=-5; k<5; k++){
															 if(A1CirOutPoint[GrindMarkOutCnt+k].x==0.0f && A1CirOutPoint[GrindMarkOutCnt+k].y==0.0f) continue;
															 if(A1CirInPoint [GrindMarkInCnt +k].x==0.0f && A1CirInPoint [GrindMarkInCnt +k].y==0.0f) continue;
															 GrindWidthDis = Math.GetLength(A1CirInPoint[GrindMarkInCnt+k], A1CirOutPoint[GrindMarkOutCnt+k]);
															 TotalCirDis+=   GrindWidthDis;
															 CircleCount++;
														 }
														 if(TotalCirDis!=0.0f && CircleCount!=0){
															 A1CirGrindWd[2] = TotalCirDis/CircleCount;
															 A1CirGrindWd[2] = A1CirGrindWd[2]+0.5; //SubPixel
														 }
													 }
												 }
												 else {  //GrindMark 못 찾았을경우
													 // OutData기준 최소값 데이터 Count산출 
													 GrindMeaDis =0.0f, MinDis =10000.0f; GrindMarkOutCnt=0;
													 for(int k=0; k<A1CirOutEdgeCount; k++){
														 if(A1CirOutPoint[k].x==0.0f || A1CirOutPoint[k].y==0.0f) continue;

														 AGrindMarkRectPoint1.x = GrindMarkRect[25].left + (GrindMarkRect[25].right  - GrindMarkRect[25].left)/2; 
														 AGrindMarkRectPoint1.y = GrindMarkRect[25].top  + (GrindMarkRect[25].bottom - GrindMarkRect[25].top )/2; 

														 GrindMeaDis = Math.GetLength(AGrindMarkRectPoint1, A1CirOutPoint[k]);
														 if(GrindMeaDis<MinDis){
															 MinDis = GrindMeaDis;
															 GrindMarkOutCnt = k;
														 }
													 }

													 // 최단거리OUtCount기준 InData 최단거리 Count정보 Calc 
													 if(GrindMarkOutCnt!=0){
														 GrindMeaDis =0.0f, MinDis =10000.0f; GrindMarkInCnt=0;
														 for(int k=0; k<A1CirInEdgeCount; k++){
															 if(A1CirInPoint[k].x   ==0.0f             || A1CirInPoint[k].y                ==0.0f) continue;
															 if(A1CirOutPoint[GrindMarkOutCnt].x==0.0f || A1CirOutPoint[GrindMarkOutCnt].y ==0.0f) continue;

															 GrindMeaDis = Math.GetLength(A1CirOutPoint[GrindMarkOutCnt], A1CirInPoint[k]);
															 if(GrindMeaDis<MinDis){
																 MinDis = GrindMeaDis;
																 GrindMarkInCnt = k;
															 }
														 }
													 }

													 // GrindMark기준 수직 포인트 주변값 Avg산출한다 ==>연마량 측정(OutData,InData기준)
													 if((GrindMarkOutCnt!=0 && GrindMarkOutCnt>5) && (GrindMarkInCnt!=0 && GrindMarkInCnt>5)){
														 CircleCount=0,TotalCirDis=0.0f,GrindWidthDis=0.0f;
														 for(int k=-5; k<5; k++){
															 if(A1CirOutPoint[GrindMarkOutCnt+k].x==0.0f && A1CirOutPoint[GrindMarkOutCnt+k].y==0.0f) continue;
															 if(A1CirInPoint [GrindMarkInCnt +k].x==0.0f && A1CirInPoint [GrindMarkInCnt +k].y==0.0f) continue;
															 GrindWidthDis = Math.GetLength(A1CirInPoint[GrindMarkInCnt+k], A1CirOutPoint[GrindMarkOutCnt+k]);
															 TotalCirDis+=   GrindWidthDis;
															 CircleCount++;
														 }
														 if(TotalCirDis!=0.0f && CircleCount!=0){
															 A1CirGrindWd[2] = TotalCirDis/CircleCount;
															 A1CirGrindWd[2] = A1CirGrindWd[2]+0.5; //SubPixel
														 }
													 }
												 }
											 }
										 }
										 else         { // ENCAP 연마량 계산(Circle Center 좌표가 없다는 가정하에 계산한다)
											 if(A1CirInEdgeCount==A1CirOutEdgeCount){
												 double InDis=0.0f, TotalGrindWidth=0.0f, AvgGrindWidth=0.0f;A1GrindWidthCount=0;
												 for(int k=0; k<A1CirInEdgeCount; k++){
													 if(A1CirOutPoint[k].x==0.0f || A1CirOutPoint[k].y==0.0f || A1CirInPoint[k].x==0.0f || A1CirInPoint[k].y==0.0f) continue;
													 InDis = Math.GetLengthFrPointToPoint(A1CirOutPoint[k],A1CirInPoint[k]);

													 // CircleFitting 진행시 실제 EdgePoint 데이터가 존재 할 경우만 포함하여 계산한다
													 if(InDis!=0.0f){
														 TotalGrindWidth+=InDis;
														 A1GrindWidthCount++;
													 }
												 }
												 if(A1GrindWidthCount!=0){
													 AvgGrindWidth = (TotalGrindWidth/A1GrindWidthCount);
													 A1CirGrindWd[2] = AvgGrindWidth;
												 }
											 }
										 }
										 // FAVION Circle Fitting 결과물 
										 // 비선형 형태, 추후에 필요함
// 										 SampleSize = A1CirInEdgeCount*0.75; //0.5~0.8이하로 입력할것
// 										 DistDevRatio = 0.15; //0.1~0.25 이하로 입력할것
// 										 CircleFit->OnRansac(A1CirInPoint,A1CirInEdgeCount,SampleSize,DistDevRatio,&ACircleFit1Center,&ACirFitDiameter1);
// 										 LogUnit.SetLog("LeftTop_Polygon_END");     
									 }
									 else if(FInspectMode==Insp_Mark){
										 // 자재의 외곽라인 교차점 기준 CirCenter 설정함 
										 A1CirCenter.x = FLTPoint.x + ASideCircleWidth;  A1CirCenter.y = FLTPoint.y + ASideCircleHeight;  
										 // Circle Fitting 진행시 공통으로 사용하는 설정값
										 Circle->SetSamplingStep(1)                              ; // A1Circle Edge 간격 

										 //A1 In Circle EdgePoint Data 추출 
										 if(A1CirCenter.x!=0 && A1CirCenter.y!=0){
											 // A_Side Circle 검사전 Median 필터 적용 
											 TPoint P1(0,0),P2(0,0),P3(0,0),P4(0,0);
											 P1.x = (int)(FLTPoint.x-50);    P1.y =(int)(FLTPoint.y-50             ); P2.x = (int)(P1.x+ASideCircleWidth+100);    P2.y = (int)(P1.y);
											 P3.x = (int)(FLTPoint.x-50);    P3.y =(int)(P1.y+ASideCircleHeight+100); P4.x = (int)(P2.x                     );    P4.y = (int)(P3.y);
											 // Median Filter 적용 
											 if(P1.x<=0    || P1.y<=0    || (P2.x - P1.x)<=0    || (P3.y - P1.y)<=0   ) return false;
											 if(P1.x>=ImgW || P1.y>=ImgH || (P2.x - P1.x)>=ImgW || (P3.y - P1.y)>=ImgH) return false;
											 FilterROI.SetSize(int(P2.x - P1.x),int(P3.y - P1.y) )                 ;
											 FilterROI.Attach(&RotateBinaryImg)                                    ;
											 FilterROI.SetPlacement(P1.x, P1.y, int(P2.x - P1.x), int(P3.y - P1.y));
											 EasyImage::Median(&FilterROI, &FilterROI)                             ;

											 if(ECThresHold==0) Circle->GImage = &RotateImg      ; //Org Image 넘겨줌 
											 else               Circle->GImage = &RotateBinaryImg; //Binary Image 넘겨줌 

											 Circle->SetCenterXY(A1CirCenter.x , A1CirCenter.y)  ; // Circle Center 좌표설정 
											 // 									 A1Diameter = ((ASideCircleWidth*2)+((ASideCircleWidth-OutToTrackLineDis)*2))/2;
											 A1Diameter = (ASideCircleWidth*2);

											 Circle->SetDiameter(A1Diameter)             ;
											 Circle->SetTolerance(60.0f )                ; // A1Circle Tolerance 
											 Circle->SetCircleChoice(1)                  ; // 0:From Begin, 1:From End, 2:Largest Amplitude 
											 Circle->SetCircleIndex (1)                  ; // Circle EdgePoint Index 
											 Circle->SetAngle(180+CirAngleMargin)        ; // Cirlce Angle 
											 Circle->SetAmplitude(90-(2*CirAngleMargin)) ; // Circle Amplitude

											 // Circle InData EdgePoint 
											 //////////////////////////////////////////////////////////////////////////////////////////////////////
											 Circle->SetCircleType(2)                          ; // 0:Black to White, 1:White to Black 2: Both Black, White 
											 Circle->OnExecute()                               ;

											 // Circle In Data 기준 새로운 Circle Center 좌표 받아옴 
											 // Euresys Circle Fitting Center & Diameter  
											 RealA1CirCenter.x = Circle->FCP.x;
											 RealA1CirCenter.y = Circle->FCP.y;
											 ACirDiameter1     = (Circle->Diameter)/2.0;

											 // Circle In Data취합 
											 OrgA1CirInEdgeCount = Circle->FCirclePointCount;
											 if(OrgA1CirInEdgeCount>0){
												 if(OrgA1CirInPoint!=NULL) delete[] OrgA1CirInPoint;
												 OrgA1CirInPoint = new TFPoint[OrgA1CirInEdgeCount];

												 for(int k=0; k<OrgA1CirInEdgeCount; k++){
													 if(k>MAX_CIRCLE_EDGEPOINT) break;
													 OrgA1CirInPoint[k].x = Circle->FCirclePoint[k].x;
													 OrgA1CirInPoint[k].y = Circle->FCirclePoint[k].y;
													 if(OrgA1CirInPoint[k].x==0.0f && OrgA1CirInPoint[k].y==0.0f) A1CirInEdgeCount++;
												 }
											 }
											 //////////////////////////////////////////////////////////////////////////////////////////////////////

											 // Circle Out Data 다시 검사  
											 //////////////////////////////////////////////////////////////////////////////////////////////////////
											 Circle->SetTolerance(60.0f )      ; // Circle Tolerance 
											 Circle->SetDiameter (A1Diameter)  ; // Circle Diameter 
											 Circle->SetCircleChoice(1)        ; // 0:From Begin, 1:From End, 2:Largest Amplitude 
											 Circle->SetCircleType(2)          ; // 0:Black to White, 1:White to Black 2: Both Black, White 
											 Circle->SetCircleIndex (0)        ; // Circle EdgePoint Index 

											 Circle->OnExecute()               ;

											 // Circle Out Data취합 
											 OrgA1CirOutEdgeCount = Circle->FCirclePointCount;
											 if(OrgA1CirOutEdgeCount>0){
												 if(OrgA1CirOutPoint!=NULL) delete[] OrgA1CirOutPoint;
												 OrgA1CirOutPoint = new TFPoint[OrgA1CirOutEdgeCount];

												 for(int k=0; k<OrgA1CirOutEdgeCount; k++){
													 if(k>MAX_CIRCLE_EDGEPOINT) break;
													 OrgA1CirOutPoint[k].x = Circle->FCirclePoint[k].x;
													 OrgA1CirOutPoint[k].y = Circle->FCirclePoint[k].y;
													 // BTM영역 Circle을 제외한 영역 Defect검사 목적에 좌표계산 
													 if(k==0                     ) {TopEdgePoint[0].x = OrgA1CirOutPoint[k].x; TopEdgePoint[0].y = OrgA1CirOutPoint[k].y;}
													 if(k==OrgA1CirOutEdgeCount-1) {TopEdgePoint[1].x = OrgA1CirOutPoint[k].x; TopEdgePoint[1].y = OrgA1CirOutPoint[k].y;}
													 if(OrgA1CirOutPoint[k].x==0.0f && OrgA1CirOutPoint[k].y==0.0f) A1CirOutEdgeCount++;
												 }
											 }

											 // A1Circle Grind_Width Calculate (연마량 계산)
											 if(IsMarkBtm){ // LTPS경우 가공량 계산 ==> 연마량 계산 
												 if(OrgA1CirOutEdgeCount!=0 && OrgA1CirInEdgeCount!=0){ // MarkMode경우 가공량 검사를 먼저 진행 후 연마량 산출  
													 GrindMeaDis =0.0f, MinDis =10000.0f; A1GrindMarkCount=0;
													 if(GrindMarkPoint[25].x!=0.0f && GrindMarkPoint[25].y!=0.0f){  //GrindMark 찾았을경우 
														 for(int k=0; k<OrgA1CirOutEdgeCount; k++){
															 if(OrgA1CirOutPoint[k].x==0.0f || OrgA1CirOutPoint[k].y==0.0f) continue;
															 if(GrindMarkPoint[25].x  ==0.0f || GrindMarkPoint[25].y  ==0.0f) continue;

															 GrindMeaDis = Math.GetLength(GrindMarkPoint[25], OrgA1CirOutPoint[k]);
															 if(GrindMeaDis<MinDis){
																 MinDis = GrindMeaDis;
																 A1GrindMarkCount = k;
															 }
														 }
														 // GrindMark기준 수직 포인트 주변값 Avg산출한다 ==>가공량 측정 
														 if(A1GrindMarkCount!=0 && A1GrindMarkCount>5){
															 CircleCount=0,TotalCirDis=0.0f,GrindMeaDis=0.0f;
															 for(int k=A1GrindMarkCount-5; k<A1GrindMarkCount+5; k++){
																 if(OrgA1CirOutPoint[k].x==0.0f || OrgA1CirOutPoint[k].y==0.0f) continue;

																 GrindMeaDis = Math.GetLength(GrindMarkPoint[25], OrgA1CirOutPoint[k]);
																 TotalCirDis+= GrindMeaDis;
																 CircleCount++;
															 }
															 if(TotalCirDis!=0.0f && CircleCount!=0){
																 A1CirGrindMea[2] = TotalCirDis/CircleCount;
															 }
														 }

														 // GrindMark기준 수직 평균값 연마량 측정 
														 if(A1GrindMarkCount!=0 && A1GrindMarkCount>5){
															 CircleCount=0,TotalCirDis=0.0f,GrindWidthDis=0.0f;
															 for(int k=A1GrindMarkCount-5; k<A1GrindMarkCount+5; k++){
																 if(OrgA1CirOutPoint[k].x==0.0f && OrgA1CirOutPoint[k].y==0.0f) continue;
																 if(OrgA1CirInPoint [k].x==0.0f && OrgA1CirInPoint [k].y==0.0f) continue;
																 GrindWidthDis = Math.GetLength(OrgA1CirInPoint[k], OrgA1CirOutPoint[k]);
																 TotalCirDis+=   GrindWidthDis;
																 CircleCount++;
															 }
															 if(TotalCirDis!=0.0f && CircleCount!=0){
																 A1CirGrindWd[2] = TotalCirDis/CircleCount;
															 }
														 }
													 }
													 else {  //GrindMark 못 찾았을경우
														 for(int k=0; k<OrgA1CirOutEdgeCount; k++){
															 if(OrgA1CirOutPoint[k].x==0.0f || OrgA1CirOutPoint[k].y==0.0f) continue;

															 AGrindMarkRectPoint1.x = GrindMarkRect[25].left + (GrindMarkRect[25].right  - GrindMarkRect[25].left)/2; 
															 AGrindMarkRectPoint1.y = GrindMarkRect[25].top  + (GrindMarkRect[25].bottom - GrindMarkRect[25].top )/2; 

															 GrindMeaDis = Math.GetLength(AGrindMarkRectPoint1, OrgA1CirOutPoint[k]);
															 if(GrindMeaDis<MinDis){
																 MinDis = GrindMeaDis;
																 A1GrindMarkCount = k;
															 }
														 }
														 // GrindMark기준 수직 평균값 연마량 측정 
														 if(A1GrindMarkCount!=0 && A1GrindMarkCount>5 && (A1GrindMarkCount+5<OrgA1CirOutEdgeCount)){
															 CircleCount=0,TotalCirDis=0.0f,GrindWidthDis=0.0f;
															 for(int k=A1GrindMarkCount-5; k<A1GrindMarkCount+5; k++){
																 if(OrgA1CirOutPoint[k].x==0.0f && OrgA1CirOutPoint[k].y==0.0f) continue;
																 if(OrgA1CirInPoint [k].x==0.0f && OrgA1CirInPoint [k].y==0.0f) continue;
																 GrindWidthDis = Math.GetLength(OrgA1CirInPoint[k], OrgA1CirOutPoint[k]);
																 TotalCirDis+=   GrindWidthDis;
																 CircleCount++;
															 }
															 if(TotalCirDis!=0.0f && CircleCount!=0){
																 A1CirGrindWd[2] = TotalCirDis/CircleCount;
															 }
														 }
													 }
												 }
											 }
											 else     { // MarkMode ==> EnCap경우 연마량만 계산한다 
												 if(OrgA1CirInEdgeCount==OrgA1CirOutEdgeCount){
													 double OutDis=0.0f, InDis=0.0f, TotalGrindWidth=0.0f, AvgGrindWidth=0.0f;A1GrindWidthCount=0;
													 for(int k=0; k<OrgA1CirInEdgeCount; k++){
														 if(OrgA1CirOutPoint[k].x==0.0f && OrgA1CirOutPoint[k].y==0.0f){
															 OutDis =0.0f;
														 }
														 else {
															 OutDis = Math.GetLengthFrPointToPoint(A1CirCenter,OrgA1CirOutPoint[k]);
														 }

														 if(OrgA1CirInPoint[k].x==0.0f && OrgA1CirInPoint[k].y==0.0f){
															 InDis =0.0f;
														 }
														 else {
															 InDis = Math.GetLengthFrPointToPoint(A1CirCenter,OrgA1CirInPoint[k]);
														 }

														 // CircleFitting 진행시 실제 EdgePoint 데이터가 존재 할 경우만 포함하여 계산한다
														 if(OutDis!=0.0f && InDis!=0.0f){
															 TotalGrindWidth+=(OutDis - InDis);
															 A1GrindWidthCount++;
														 }
													 }
													 if(A1GrindWidthCount!=0){
														 AvgGrindWidth = (TotalGrindWidth/A1GrindWidthCount);
														 A1CirGrindWd[2] = AvgGrindWidth;
													 }
												 }
											 }

											 //////////////////////////////////////////////////////////////////////////////////////////////////////
											 // Org Circle데이터중 유호하지 않은 값을 제외한 실제 존재하는 데이터 기준으로 동적 메모리 생성함
											 // Circle Defect검사에 필요한 Edge데이터 값
											 int Count=0;
											 if(OrgA1CirInEdgeCount>0){ // A1 CircleInData
												 A1CirInEdgeCount = OrgA1CirInEdgeCount - A1CirInEdgeCount;
												 if(A1CirInEdgeCount>0){
													 if(A1CirInPoint!=NULL) delete[] A1CirInPoint;
													 A1CirInPoint = new TFPoint[A1CirInEdgeCount];

													 for(int k=0; k<OrgA1CirInEdgeCount; k++){
														 if(k>MAX_CIRCLE_EDGEPOINT) break;
														 if(OrgA1CirInPoint[k].x==0.0f && OrgA1CirInPoint[k].y==0.0f) continue;
														 A1CirInPoint[Count].x = OrgA1CirInPoint[k].x;
														 A1CirInPoint[Count].y = OrgA1CirInPoint[k].y;
														 Count++;
													 }
												 }
												 // Circle 원본 데이터 메모리 삭제
												 if(OrgA1CirInPoint!=NULL) delete[] OrgA1CirInPoint;
											 }
											 // FAVION Circle Fitting 결과물 
											 SampleSize = A1CirInEdgeCount*0.75; //0.5~0.8이하로 입력할것
											 DistDevRatio = 0.15; //0.1~0.25 이하로 입력할것
											 CircleFit->OnRansac(A1CirInPoint,A1CirInEdgeCount,SampleSize,DistDevRatio,&ACircleFit1Center,&ACirFitDiameter1);

											 if(OrgA1CirOutEdgeCount>0){// A1 CircleOutData 
												 A1CirOutEdgeCount = OrgA1CirOutEdgeCount - A1CirOutEdgeCount;
												 Count =0;
												 if(A1CirOutEdgeCount>0){
													 if(A1CirOutPoint!=NULL) delete[] A1CirOutPoint;
													 A1CirOutPoint = new TFPoint[A1CirOutEdgeCount];

													 for(int k=0; k<OrgA1CirOutEdgeCount; k++){
														 if(k>MAX_CIRCLE_EDGEPOINT) break;
														 if(OrgA1CirOutPoint[k].x==0.0f && OrgA1CirOutPoint[k].y==0.0f) continue;
														 A1CirOutPoint[Count].x = OrgA1CirOutPoint[k].x;
														 A1CirOutPoint[Count].y = OrgA1CirOutPoint[k].y;
														 Count++;
													 }
												 }
												 // Circle 원본 데이터 메모리 삭제
												 if(OrgA1CirOutPoint!=NULL) delete[] OrgA1CirOutPoint;
											 }
											 // Circle 영역 꽃박리, 원형박리 검출 목적 시퀀스(EnCap)
											 // 정식 명칭은 몰라서.....일단 Crack으로 정함 
											 if(!IsMarkBtm && BrokenThresHold!=0){
												 RotateBrokenImg.SetSize(RotateImg.GetWidth(), RotateImg.GetHeight());
												 EasyImage::Oper(EArithmeticLogicOperation_Copy,&RotateImg,&RotateBrokenImg);
												 EasyImage::Threshold(&RotateImg,&RotateBrokenImg, BrokenThresHold);
												 // 										 RotateBrokenImg.Save("D:\\ROTATE_IMG\\RotateBrokenImg_HAP.bmp");

												 if(ACirFitDiameter1!=0.0f && ACircleFit1Center.x!=0.0f && ACircleFit1Center.y!=0.0f){ // FAVION Circle Fitting 성공시 박리검사 진행 
													 Circle->GImage = &RotateBrokenImg;                                             //Binary Image 넘겨줌 

													 Circle->SetCenterXY(ACircleFit1Center.x,ACircleFit1Center.y);
													 // 											 Circle->SetTolerance(CirCrackMargin)                      ; // Circle Tolerance 
													 // 											 Circle->SetDiameter ((ACirFitDiameter1-CirCrackMargin)*2)  ; // Circle Diameter 
													 Circle->SetTolerance((dEdgeToTrapLineDis/2)-CirOffsetMargin)      ; // Circle Tolerance 
													 Circle->SetDiameter ((ACirFitDiameter1-(dEdgeToTrapLineDis/2))*2) ; // Circle Diameter 
													 Circle->SetCircleChoice(0)                                ; // 0:From Begin, 1:From End, 2:Largest Amplitude 
													 Circle->SetCircleType  (0)                                ; // 0:Black to White, 1:White to Black 2: Both Black, White 
													 Circle->SetCircleIndex (0)                                ; // Circle EdgePoint Index 
													 Circle->SetAmplitude(25)                                  ; // 패턴으로 인해서 오버킬 발생...범위를 좁혀준다 
													 Circle->OnExecute(true)                                   ;
													 CrackACirDiameter1 = (ACirFitDiameter1-(dEdgeToTrapLineDis/2))+((dEdgeToTrapLineDis/2)-CirOffsetMargin);

													 A1CirInCrackCount = Circle->FCirclePointCount;

													 if(A1CirInCrackCount>0){
														 if(A1CirInCrackPoint!=NULL) delete[] A1CirInCrackPoint;
														 A1CirInCrackPoint = new TFPoint[A1CirInCrackCount];

														 for(int k=0; k<A1CirInCrackCount; k++){
															 if(k>MAX_CIRCLE_EDGEPOINT) break;
															 A1CirInCrackPoint[k].x = Circle->FCirclePoint[k].x;
															 A1CirInCrackPoint[k].y = Circle->FCirclePoint[k].y;
														 }
													 }
												 }
											 }
										 }
									 }
								 }
								 LogUnit.SetLog(L"shRectH_Rotate_LeftTop_End");     
							 }
						 }

						 if(FRightTop){ // Only 외관검사 시퀀스 
							 if(FInspectMode!=Insp_Surface){
								 LogUnit.SetLog(L"shRectH_Rotate_RightTop_Start");     
								 EasyImage::Threshold(&RotateImg,&RotateBinaryImg, ECThresHold);
								 EasyImage::Threshold(&RotateImg,&RotateGrindBinaryImg, CorGrindMeaThresHold);
// 								 RotateBinaryImg.Save("D:\\ROTATE_IMG\\RotateBinaryImg회전_HAP.bmp");

								 if(ECThresHold==0)  {SingleLine->GImage = &RotateImg      ;  SingleLine->FThreshold =5 ;}
								 else                {SingleLine->GImage = &RotateBinaryImg;  SingleLine->FThreshold =10;}

								 OrgPoint = Math.OnIntersect(Line[waRightWall].FP0, Line[waRightWall].FP1, Line[waTopWall].FP0, Line[waTopWall].FP1);
								 FRTPoint = OrgPoint;

								 if(IsCornerTop){
									 SingleLine->IRoi->SetOrgX  ((int)(OrgPoint.x-RTCornerWidth));
									 SingleLine->IRoi->SetOrgY  ((int) OrgPoint.y               );
									 SingleLine->IRoi->SetWidth (RTCornerWidth +10              );
									 SingleLine->IRoi->SetHeight(RTCornerHeight                 );

									 // 								 SingleLine->SetOrientation(orNorth);
									 SingleLine->SetOrientation(orEast);
									 SingleLine->FIncrement =1;
									 SingleLine->FThreshold =15;
									 SingleLine->SetFindLineId(0);
									 SingleLine->SetEdgeType(1);  //White To Black 
									 SingleLine->OnExecute();
									 Line[waRightTop].FP0 = SingleLine->GetResultP0();
									 Line[waRightTop].FP1 = SingleLine->GetResultP1();

									 // ORG 
									 FRTRPoint = Math.OnIntersect(SingleLine->GetResultP0(), SingleLine->GetResultP1(), Line[waRightWall].FP0, Line[waRightWall].FP1);
									 FRTTPoint = Math.OnIntersect(SingleLine->GetResultP0(), SingleLine->GetResultP1(), Line[waTopWall  ].FP0, Line[waTopWall].FP1  );

									 if((FRTRPoint.x==0 || FRTRPoint.y==0 || FRTTPoint.x==0 || FRTTPoint.y==0) || (SingleLine->FEdgePointCount <30)){
										 RTDx = 0.0f;
										 RTDy = 0.0f;
										 //화면에 디스플레이 위해서 
										 FRTRPoint.x = FRTPoint.x;
										 FRTRPoint.y = FRTPoint.y;
										 FRTTPoint.x = FRTPoint.x;
										 FRTTPoint.y = FRTPoint.y;
									 }
									 else {
										 RTDx = Math.GetLengthFrPointToPoint(FRTPoint, FRTTPoint);
										 RTDy = Math.GetLengthFrPointToPoint(FRTPoint, FRTRPoint);

										 // OutLine C2Corner Data 
										 if((SingleLine->FEdgePointCount) - (CornerMargin*2)>0){
											 if(C2Point!=NULL) delete[] C2Point;
											 C2Point  = new TFPoint [(SingleLine->FEdgePointCount) - (CornerMargin*2)];
											 C2EdgeCount = (SingleLine->FEdgePointCount) -(CornerMargin*2);

											 CornerCount =0;  
											 for(int k=CornerMargin; k<((SingleLine->FEdgePointCount)-CornerMargin); k++){
												 if(CornerCount>=MAX_CORNER_POINT) break;
												 C2Point[CornerCount].x = SingleLine->FEdgePoint[k].x;
												 C2Point[CornerCount].y = SingleLine->FEdgePoint[k].y;
												 CornerCount++;
											 }
										 }

										 // Corner 기울기 완만하여 Edge찾을 경우 Defect 오버킬 발생함 
										 // 방향을 Top방향에서 다시 엣지를 찾음 (Corner Defect OverKill 감소 목적)
										 // 										if(RTCornerWidth >(RTCornerHeight*3)){
										 if(RTCornerWidth >(RTCornerHeight*1.5)){
											 if(FRTTPoint.x!=0.0f && FRTTPoint.y!=0.0f && FRTRPoint.x!=0.0f && FRTRPoint.y!=0.0f){
												 SingleLine->IRoi->SetOrgX  ((int)(OrgPoint.x-RTCornerWidth));
												 SingleLine->IRoi->SetOrgY  ((int) OrgPoint.y -10           );
												 SingleLine->IRoi->SetWidth (RTCornerWidth +10              );
												 SingleLine->IRoi->SetHeight(RTCornerHeight+10              );

												 if(FRTTPoint.x<=0    || FRTTPoint.y<=0    || (FRTRPoint.x - FRTTPoint.x)<=0    || (FRTRPoint.y - FRTTPoint.y)<=0   ) return false;
												 if(FRTTPoint.x>=ImgW || FRTTPoint.y>=ImgH || (FRTRPoint.x - FRTTPoint.x)>=ImgW || (FRTRPoint.y - FRTTPoint.y)>=ImgH) return false;

												 SingleLine->SetOrientation(orNorth);
												 SingleLine->FIncrement =2;
												 SingleLine->SetFindLineId(0);
												 SingleLine->SetEdgeType(0);  //Black To White 
												 SingleLine->OnExecute();

												 // InLine C2Corner Data 
												 if((SingleLine->FEdgePointCount) - (CornerMargin*2)>0){
													 if(C2InPoint!=NULL) delete[] C2InPoint;
													 C2InPoint  = new TFPoint [(SingleLine->FEdgePointCount) - (CornerMargin*2)];
													 C2InEdgeCount = (SingleLine->FEdgePointCount) -(CornerMargin*2);

													 CornerCount =0;  
													 for(int k=CornerMargin; k<((SingleLine->FEdgePointCount)-CornerMargin); k++){
														 if(CornerCount>=MAX_CORNER_POINT) break;
														 C2InPoint[CornerCount].x = SingleLine->FEdgePoint[k].x;
														 C2InPoint[CornerCount].y = SingleLine->FEdgePoint[k].y;
														 CornerCount++;
													 }
												 }
											 }
										 }
										 else {
											 // Corner 연마 안쪽라인 찾는다 
											 SingleLine->SetOrientation(orEast);
											 SingleLine->SetFindLineId(0);
											 SingleLine->FIncrement =1;
											 SingleLine->SetEdgeType(0);  //Black To White 
											 SingleLine->OnExecute();

											 // InLine C2Corner Data 
											 if((SingleLine->FEdgePointCount) - (CornerMargin*2)>0){
												 if(C2InPoint!=NULL) delete[] C2InPoint;
												 C2InPoint  = new TFPoint [(SingleLine->FEdgePointCount) - (CornerMargin*2)];
												 C2InEdgeCount = (SingleLine->FEdgePointCount) -(CornerMargin*2);

												 CornerCount =0;  
												 for(int k=CornerMargin; k<((SingleLine->FEdgePointCount)-CornerMargin); k++){
													 if(CornerCount>=MAX_CORNER_POINT) break;
													 C2InPoint[CornerCount].x = SingleLine->FEdgePoint[k].x;
													 C2InPoint[CornerCount].y = SingleLine->FEdgePoint[k].y;
													 CornerCount++;
												 }
											 }
										 }

										 //코너 연마안쪽라인 기준 새로운 교차점 생성 
										 FRTRInPoint = Math.OnIntersect(SingleLine->GetResultP0(), SingleLine->GetResultP1(), Line[waRightWall].FP0, Line[waRightWall].FP1);
										 FRTTInPoint = Math.OnIntersect(SingleLine->GetResultP0(), SingleLine->GetResultP1(), Line[waTopWall  ].FP0, Line[waTopWall].FP1  );

										 //코너 연마폭, 연마량 계산 
										 double Dis =0.0f, AvgGrindWidth=0.0f, AvgGrindMea=0.0f, TotalGrindWidth=0.0f, TotalGrindMeasure=0.0f;
										 for(int k=0; k<C2InEdgeCount; k++){
											 Dis = Math.GetLengthFrLineToPoint(FRTRPoint, FRTTPoint, C2InPoint[k]);
											 TotalGrindWidth+=Dis;
										 }
										 if(C2InEdgeCount!=0){
											 AvgGrindWidth = (TotalGrindWidth/C2InEdgeCount);
											 C2CorGrindWd  = AvgGrindWidth;
										 }

										 if(CorGrindMeaThresHold!=0){ // Corner Grind ThresHold값이 설정되어 있을경우만 연마량 검사를 진행한다 
											 // 코너 연마량 기준 라인을 찾는다 
											 // ROI 영역 설정 
											 if(CorGrindMeaThresHold==0){SingleLine->GImage = &RotateImg           ;  SingleLine->FThreshold =5 ;}
											 else                       {SingleLine->GImage = &RotateGrindBinaryImg;  SingleLine->FThreshold =10;}

											 // 										SingleLine->IRoi->SetOrgX  ((int) OrgPoint.x-RTCornerWidth-20 );
											 // 										SingleLine->IRoi->SetOrgY  ((int) OrgPoint.y+20               );
											 // 										SingleLine->IRoi->SetWidth (RTCornerWidth +20                 );
											 // 										SingleLine->IRoi->SetHeight(RTCornerHeight                    );

											 // 존나 찝찝함....일단 스팩을 받기전까지 임시로 영역을 분류하여 CornerEdgePoint 찾자 
											 if(RTCornerWidth >(RTCornerHeight*1.5)){
												 SingleLine->IRoi->SetOrgX  ((int) OrgPoint.x-RTCornerWidth    );
												 SingleLine->IRoi->SetOrgY  ((int) OrgPoint.y+15               );
												 SingleLine->IRoi->SetWidth (RTCornerWidth                     );
												 SingleLine->IRoi->SetHeight(RTCornerHeight-40                 );

												 SingleLine->SetOrientation(orNorth);
												 SingleLine->SetFindLineId(0);
												 SingleLine->FIncrement =1;
												 SingleLine->SetEdgeType(0);  //Black To White 
												 SingleLine->OnExecute();

												 P1 = SingleLine->GetResultP0();
												 P2 = SingleLine->GetResultP1();

												 //코너 연마안쪽라인 기준 새로운 교차점 생성 
												 FRTRMeaPoint = Math.OnIntersect(SingleLine->GetResultP0(), SingleLine->GetResultP1(), Line[waRightWall].FP0, Line[waRightWall].FP1);
												 FRTTMeaPoint = Math.OnIntersect(SingleLine->GetResultP0(), SingleLine->GetResultP1(), Line[waTopWall  ].FP0, Line[waTopWall].FP1  );

												 // C1Corner Grind Measure Stand Data 
												 if((SingleLine->FEdgePointCount)>0){
													 if(C2MeaPoint!=NULL) delete[] C2MeaPoint;
													 C2MeaPoint     = new TFPoint [(SingleLine->FEdgePointCount)];
													 C2MeaEdgeCount = (SingleLine->FEdgePointCount);

													 CornerCount =0;  
													 for(int k=0; k<(SingleLine->FEdgePointCount); k++){
														 if(CornerCount>=MAX_CORNER_POINT) break;
														 C2MeaPoint[CornerCount].x = SingleLine->FEdgePoint[k].x;
														 C2MeaPoint[CornerCount].y = SingleLine->FEdgePoint[k].y;
														 CornerCount++;
													 }
												 }
												 //코너 연마량 계산  
												 Dis =0.0f, AvgGrindMea=0.0f, TotalGrindMeasure=0.0f;
												 for(int k=0; k<C2EdgeCount; k++){
													 Dis = Math.GetLengthFrLineToPoint(FRTRMeaPoint, FRTTMeaPoint, C2Point[k]);
													 TotalGrindMeasure+=Dis;
												 }
												 if(C2EdgeCount!=0){
													 AvgGrindMea    = (TotalGrindMeasure/C2EdgeCount);
													 C2CorGrindMea  = AvgGrindMea;
												 }

												 // 											 for(int k=0; k<C2MeaEdgeCount; k++){
												 // 												 Dis = Math.GetLengthFrLineToPoint(FRTRPoint, FRTTPoint, C2MeaPoint[k]);
												 // 												 TotalGrindMeasure+=Dis;
												 // 											 }
												 // 											 if(C2MeaEdgeCount!=0){
												 // 												 AvgGrindMea    = (TotalGrindMeasure/C2MeaEdgeCount);
												 // 												 C2CorGrindMea  = AvgGrindMea;
												 // 											 }
											 }
											 else {
												 // 											 SingleLine->IRoi->SetOrgX  ((int) OrgPoint.x-RTCornerWidth    );
												 SingleLine->IRoi->SetOrgX  ((int) OrgPoint.x-RTCornerWidth+20 );
												 SingleLine->IRoi->SetOrgY  ((int) OrgPoint.y+15               );
												 SingleLine->IRoi->SetWidth (RTCornerWidth                     );
												 // 											 SingleLine->IRoi->SetHeight(RTCornerHeight                    );
												 SingleLine->IRoi->SetHeight(RTCornerHeight+10                 );

												 SingleLine->SetOrientation(orEast);
												 SingleLine->SetFindLineId(0);
												 SingleLine->FIncrement =1;
												 SingleLine->SetEdgeType(0);  //Black To White 
												 SingleLine->OnExecute();

												 P1 = SingleLine->GetResultP0();
												 P2 = SingleLine->GetResultP1();

												 //코너 연마안쪽라인 기준 새로운 교차점 생성 
												 FRTRMeaPoint = Math.OnIntersect(SingleLine->GetResultP0(), SingleLine->GetResultP1(), Line[waRightWall].FP0, Line[waRightWall].FP1);
												 FRTTMeaPoint = Math.OnIntersect(SingleLine->GetResultP0(), SingleLine->GetResultP1(), Line[waTopWall  ].FP0, Line[waTopWall].FP1  );

												 // C1Corner Grind Measure Stand Data 
												 if((SingleLine->FEdgePointCount)>0){
													 if(C2MeaPoint!=NULL) delete[] C2MeaPoint;
													 C2MeaPoint     = new TFPoint [(SingleLine->FEdgePointCount)];
													 C2MeaEdgeCount = (SingleLine->FEdgePointCount);

													 CornerCount =0;  
													 for(int k=0; k<(SingleLine->FEdgePointCount); k++){
														 if(CornerCount>=MAX_CORNER_POINT) break;
														 C2MeaPoint[CornerCount].x = SingleLine->FEdgePoint[k].x;
														 C2MeaPoint[CornerCount].y = SingleLine->FEdgePoint[k].y;
														 CornerCount++;
													 }
												 }
												 //코너 연마량 계산  
												 Dis =0.0f, AvgGrindMea=0.0f, TotalGrindMeasure=0.0f;
												 for(int k=0; k<C2EdgeCount; k++){
													 Dis = Math.GetLengthFrLineToPoint(FRTRMeaPoint, FRTTMeaPoint, C2Point[k]);
													 TotalGrindMeasure+=Dis;
												 }
												 if(C2EdgeCount!=0){
													 AvgGrindMea    = (TotalGrindMeasure/C2EdgeCount);
													 C2CorGrindMea  = AvgGrindMea;
												 }

												 // 											 Dis =0.0f, AvgGrindMea=0.0f, TotalGrindMeasure=0.0f;
												 // 											 for(int k=0; k<C2MeaEdgeCount; k++){
												 // 												 Dis = Math.GetLengthFrLineToPoint(FRTRPoint, FRTTPoint, C2MeaPoint[k]);
												 // 												 TotalGrindMeasure+=Dis;
												 // 											 }
												 // 											 if(C2MeaEdgeCount!=0){
												 // 												 AvgGrindMea    = (TotalGrindMeasure/C2MeaEdgeCount);
												 // 												 C2CorGrindMea  = AvgGrindMea;
												 // 											 }
											 }
										 }
									 }
								 }
								 else if(IsRectTop){
									 RTDx = 0.0f;
									 RTDy = 0.0f;
									 //화면에 디스플레이 위해서 
									 FRTRPoint.x = FRTPoint.x;
									 FRTRPoint.y = FRTPoint.y;
									 FRTTPoint.x = FRTPoint.x;
									 FRTTPoint.y = FRTPoint.y;
								 }
								 else if(IsCircleTop){ // TOP영역 RightTop Circle 검사  A2Circle 
									 // Org A1CircleData 
									 int OrgA2CirInEdgeCount =0;		  
									 int OrgA2CirOutEdgeCount=0;	    
									 int A2GrindWidthCount   =0;		  
									 int A2GrindMarkCount    =0;
									 int A2Diameter          =0;
									 GrindRectWidth          =0;
									 GrindRectHeight         =0;

									 TFPoint *OrgA2CirInPoint =NULL;	 
									 TFPoint *OrgA2CirOutPoint=NULL;

									 TFPoint AGrindMarkRectPoint2(0.0f, 0.0f);

									 // Find Mark Search Start
									 ////////////////////////////////////////////////////////////////////////////
									 if(IsMarkBtm && FInspectMode!=Insp_Track){
										 if(FP1.x!=0.0f && FP1.y!=0.0f){
											 GrindMarkRect[20].left   = (FP1.x+AMarkToGrindMarkDvX)-40;
											 GrindMarkRect[20].top    = (FP1.y+AMarkToGrindMarkDvY)-40;
											 GrindMarkRect[20].right  = (GrindMarkRect[20].left + 80);
											 GrindMarkRect[20].bottom = (GrindMarkRect[20].top  + 80);

											 GrindRectWidth  = (GrindMarkRect[20].right  - GrindMarkRect[20].left);
											 GrindRectHeight = (GrindMarkRect[20].bottom - GrindMarkRect[20].top );
										 }

										 Find->OnLoad(true,FindDir,1)                   ;
										 Find->GImage = &RotateImg                      ;
										 Find->SetContrastMode(EFindContrastMode_Normal);
										 // 									 Find->SetContrastMode(EFindContrastMode_Any    );
										 // 									 Find->SetMinScore(0.8f)                        ;
										 Find->SetMinScore (GrindPadMarkMinScore)       ; // PatternrFind 검사 최소 Score
										 Find->SetZeroScore(GrindPadMarkMinScore)       ; // 검사 후 최소 Score 
										 // 									 Find->SetMinScore (0.75)                       ; // PatternrFind 검사 최소 Score
										 // 									 Find->SetZeroScore(0.75)                       ; // 검사 후 최소 Score 
										 Find->SetMaxInstances(1)                       ;
										 Find->SetAngleTolerance(20.0f)                  ;
										 Find->SetAngleBias(135.0f)                     ;
										 Find->SetScaleBias(1.00f)                      ;
										 Find->SetScaleTolerance(0.0f)                  ;
										 Find->Property.Ox = (float)ImgW/2              ;
										 Find->Property.Oy = (float)ImgH/2              ;

										 Find->IRoi->SetPlacement(GrindMarkRect[20].left,GrindMarkRect[20].top,GrindRectWidth,GrindRectHeight);
										 if(GrindMarkRect[20].left<=0 || GrindMarkRect[20].top<=0 || GrindRectWidth<=0 || GrindRectHeight<=0) return false;

										 // 검사 및 Match Pos 좌표 받어온다 
										 // Find 검사 성공시 데이터 받아옴 
										 if(Find->OnExecute()){
											 GrindMarkPoint[20].x = Find->Result[0].Px;
											 GrindMarkPoint[20].y = Find->Result[0].Py;
											 GrindMarkScore[20]   = Find->Result[0].Score;
										 }
										 // Contrast Gradient Pixel Value
										 GrindMarkGradient[20] = EasyImage::Focusing(Find->IRoi);
									 }
									 // Find Mark Search Start
									 ////////////////////////////////////////////////////////////////////////////

									 // BMDT RightTop 비선형 검사 
									 if(FInspectMode==Insp_Polygon){
// 										 LogUnit.SetLog("RightTop_Polygon_START");     
// 										 RotateBinaryImg.Save("D:\\ROTATE_IMG\\Polygon_RightTop_원본.bmp");

										 TPoint P1(0,0),P2(0,0),P3(0,0),P4(0,0);
										 P1.x = (int)(FRTPoint.x-ASideCircleWidth-30);    P1.y =(int)(FRTPoint.y-20            );    P2.x = (int)(FRTPoint.x+20);    P2.y = (int)(P1.y);
										 P3.x = (int)(P1.x)                          ;    P3.y =(int)(P1.y+ASideCircleHeight+50);    P4.x = (int)(P2.x         );    P4.y = (int)(P3.y);
										 int PixelCnt =0;

										 // Median Filter 적용 
										 if(P1.x<=0    || P1.y<=0    || (P2.x - P1.x)<=0    || (P3.y - P1.y)<=0   ) return false;
										 if(P1.x>=ImgW || P1.y>=ImgH || (P2.x - P1.x)>=ImgW || (P3.y - P1.y)>=ImgH) return false;
										 FilterROI.SetSize(int(P2.x - P1.x),int(P3.y - P1.y) )                 ;
										 FilterROI.Attach(&RotateBinaryImg)                                    ;
										 FilterROI.SetPlacement(P1.x, P1.y, int(P2.x - P1.x), int(P3.y - P1.y));
										 EasyImage::Median(&FilterROI, &FilterROI)                             ;

// 										 RotateBinaryImg.Save("D:\\ROTATE_IMG\\Polygon_RightTop_필터.bmp");

										 Polygon->GImage = &RotateBinaryImg                          ;
										 Polygon->IWidth = ImgW                                      ;
										 Polygon->IHeight= ImgH                                      ;
										 Polygon->PoPa.FMinWidth  =300                               ;
										 Polygon->PoPa.FMaxWidth  =(int)((FRTPoint.x - FLTPoint.x)/2);
										 Polygon->PoPa.FMinHeight =50                                ;
										 Polygon->PoPa.FMaxHeight =1000                              ;
										 Polygon->PoPa.MinPxCnt   =100                               ;
										 Polygon->PoPa.MaxPxCnt   =20000                             ;
										 Polygon->PoPa.MaxBbCnt   =10                                ;
										 Polygon->PoPa.IsSeparate =true                              ;
										 Polygon->PoPa.IsInToOut  =false                             ;
										 Polygon->PoPa.HiThHold   = ECThresHold                      ;
										 Polygon->PoPa.LoThHold   = 0                                ;

										 if(P1.x!=0 && P1.y!=0 && P2.x!=0 && P2.y!=0 && P3.x!=0 && P3.y!=0 && P4.x!=0 && P4.y!=0){
											 Polygon->OnExecute(P1,P2,P3,P4);
										 }
										 // Polygon Algorithm InEdgeData/OutEdgeData Separate 
										 if(Polygon->BlobCount==1){
											 PolygonMarginCnt =5;
											 if(Polygon->Blob[0].InCnt>(PolygonMarginCnt*2)){
												 A2CirInEdgeCount=0;
												 A2CirInEdgeCount = (Polygon->Blob[0].InCnt - (PolygonMarginCnt*2));
												 if(A2CirInEdgeCount>0){
													 if(A2CirInPoint!=NULL) delete[] A2CirInPoint;
													 A2CirInPoint = new TFPoint[A2CirInEdgeCount];

													 PixelCnt=0;
													 for(int k=0; k<Polygon->Blob[0].InCnt; k++){
														 if(k<PolygonMarginCnt || k>=(Polygon->Blob[0].InCnt-PolygonMarginCnt)) continue;
														 A2CirInPoint[PixelCnt].x = Polygon->Blob[0].InPoint[k].x ;
														 A2CirInPoint[PixelCnt].y = Polygon->Blob[0].InPoint[k].y ;
														 PixelCnt++;
													 }
												 }
											 }

											 if(Polygon->Blob[0].OutCnt>(PolygonMarginCnt*2)){
												 A2CirOutEdgeCount=0;
												 A2CirOutEdgeCount = (Polygon->Blob[0].OutCnt - (PolygonMarginCnt*2));
												 if(A2CirOutEdgeCount>0){
													 if(A2CirOutPoint!=NULL) delete[] A2CirOutPoint;
													 A2CirOutPoint = new TFPoint[A2CirOutEdgeCount];

													 PixelCnt=0;
													 for(int k=0; k<Polygon->Blob[0].OutCnt; k++){
														 if(k<PolygonMarginCnt || k>=(Polygon->Blob[0].OutCnt-PolygonMarginCnt)) continue;
														 A2CirOutPoint[PixelCnt].x = Polygon->Blob[0].OutPoint[k].x ;
														 A2CirOutPoint[PixelCnt].y = Polygon->Blob[0].OutPoint[k].y ;
														 PixelCnt++;
													 }
												 }
											 }
										 }

										 // InEdgeData/OutEdgeData 기준 가공량 및 연마량 계산
										 if(IsMarkBtm){ // LTPS 가공량,연마량 계산 
											 if(A2CirOutEdgeCount!=0 && A2CirInEdgeCount!=0){ // MarkMode경우 가공량 검사를 먼저 진행 후 연마량 산출  
												 if(GrindMarkPoint[20].x!=0.0f && GrindMarkPoint[20].y!=0.0f){  //GrindMark 찾았을경우 
													 // GrindMark기준 OutData 최단거리 Count정보 Calc 
													 GrindMeaDis =0.0f, MinDis =10000.0f; GrindMarkOutCnt=0;
													 for(int k=0; k<A2CirOutEdgeCount; k++){
														 if(A2CirOutPoint[k].x  ==0.0f || A2CirOutPoint[k].y  ==0.0f) continue;
														 if(GrindMarkPoint[20].x==0.0f || GrindMarkPoint[20].y==0.0f) continue;

														 GrindMeaDis = Math.GetLength(GrindMarkPoint[20], A2CirOutPoint[k]);
														 if(GrindMeaDis<MinDis){
															 MinDis = GrindMeaDis;
															 GrindMarkOutCnt = k;
														 }
													 }
													 // GrindMark기준 InData 최단거리 Count정보 Calc 
													 GrindMeaDis =0.0f, MinDis =10000.0f; GrindMarkInCnt=0;
													 for(int k=0; k<A2CirInEdgeCount; k++){
														 if(A2CirInPoint[k].x   ==0.0f || A2CirInPoint[k].y    ==0.0f) continue;
														 if(GrindMarkPoint[20].x==0.0f || GrindMarkPoint[20].y ==0.0f) continue;

														 GrindMeaDis = Math.GetLength(GrindMarkPoint[20], A2CirInPoint[k]);
														 if(GrindMeaDis<MinDis){
															 MinDis = GrindMeaDis;
															 GrindMarkInCnt = k;
														 }
													 }
													 int Org2GrindMarkInCnt = GrindMarkInCnt;
													 TFPoint Org2, New2;
													 Org2.x  = A2CirInPoint[Org2GrindMarkInCnt].x;  Org2.y= A2CirInPoint[Org2GrindMarkInCnt].y;

													 if(GrindMarkOutCnt!=0){
														 // GrindMark기준 InData 최단거리 Count정보 Calc 
														 GrindMeaDis =0.0f, MinDis =10000.0f; GrindMarkInCnt=0;
														 for(int k=0; k<A2CirInEdgeCount; k++){
															 if(A2CirInPoint[k].x               ==0.0f || A2CirInPoint[k].y                ==0.0f) continue;
															 if(A2CirOutPoint[GrindMarkOutCnt].x==0.0f || A2CirOutPoint[GrindMarkOutCnt].y ==0.0f) continue;

															 GrindMeaDis = Math.GetLength(A2CirOutPoint[GrindMarkOutCnt], A2CirInPoint[k]);
															 if(GrindMeaDis<MinDis){
																 MinDis = GrindMeaDis;
																 GrindMarkInCnt = k;
															 }
														 }
													 }
													 New2.x  = A2CirInPoint[GrindMarkInCnt].x;  New2.y= A2CirInPoint[GrindMarkInCnt].y;

													 // GrindMark기준 수직 포인트 주변값 Avg산출한다 ==>가공량 측정(OutData기준)
													 if(GrindMarkOutCnt!=0 && GrindMarkOutCnt>5){
														 CircleCount=0,TotalCirDis=0.0f,GrindMeaDis=0.0f;
														 for(int k=GrindMarkOutCnt-5; k<GrindMarkOutCnt+5; k++){
															 if(A2CirOutPoint[k].x==0.0f || A2CirOutPoint[k].y==0.0f) continue;

															 GrindMeaDis = Math.GetLength(GrindMarkPoint[20], A2CirOutPoint[k]);
															 TotalCirDis+= GrindMeaDis;
															 CircleCount++;
														 }
														 if(TotalCirDis!=0.0f && CircleCount!=0){
															 A2CirGrindMea[2] = TotalCirDis/CircleCount;
															 A2CirGrindMea[2] = A2CirGrindMea[2]+0.5; //SubPixel 
														 }
													 }

													 // GrindMark기준 수직 포인트 주변값 Avg산출한다 ==>연마량 측정(OutData,InData기준)
													 if((GrindMarkOutCnt!=0 && GrindMarkOutCnt>5) && (GrindMarkInCnt!=0 && GrindMarkInCnt>5)){
														 CircleCount=0,TotalCirDis=0.0f,GrindWidthDis=0.0f;
														 for(int k=-5; k<5; k++){
															 if(A2CirOutPoint[GrindMarkOutCnt+k].x==0.0f && A2CirOutPoint[GrindMarkOutCnt+k].y==0.0f) continue;
															 if(A2CirInPoint [GrindMarkInCnt +k].x==0.0f && A2CirInPoint [GrindMarkInCnt +k].y==0.0f) continue;
															 GrindWidthDis = Math.GetLength(A2CirInPoint[GrindMarkInCnt+k], A2CirOutPoint[GrindMarkOutCnt+k]);
															 TotalCirDis+=   GrindWidthDis;
															 CircleCount++;
														 }
														 if(TotalCirDis!=0.0f && CircleCount!=0){
															 A2CirGrindWd[2] = TotalCirDis/CircleCount;
															 A2CirGrindWd[2] = A2CirGrindWd[2]+0.5; //SubPixel
														 }
													 }
												 }
												 else {  //GrindMark 못 찾았을경우
													 // OutData기준 최소값 데이터 Count산출 
													 GrindMeaDis =0.0f, MinDis =10000.0f; GrindMarkOutCnt=0;
													 for(int k=0; k<A2CirOutEdgeCount; k++){
														 if(A2CirOutPoint[k].x==0.0f || A2CirOutPoint[k].y==0.0f) continue;

														 AGrindMarkRectPoint2.x = GrindMarkRect[20].left + (GrindMarkRect[20].right  - GrindMarkRect[20].left)/2; 
														 AGrindMarkRectPoint2.y = GrindMarkRect[20].top  + (GrindMarkRect[20].bottom - GrindMarkRect[20].top )/2; 

														 GrindMeaDis = Math.GetLength(AGrindMarkRectPoint2, A2CirOutPoint[k]);
														 if(GrindMeaDis<MinDis){
															 MinDis = GrindMeaDis;
															 GrindMarkOutCnt = k;
														 }
													 }

													 // 최단거리OUtCount기준 InData 최단거리 Count정보 Calc 
													 if(GrindMarkOutCnt!=0){
														 GrindMeaDis =0.0f, MinDis =10000.0f; GrindMarkInCnt=0;
														 for(int k=0; k<A2CirInEdgeCount; k++){
															 if(A2CirInPoint[k].x   ==0.0f             || A2CirInPoint[k].y                ==0.0f) continue;
															 if(A2CirOutPoint[GrindMarkOutCnt].x==0.0f || A2CirOutPoint[GrindMarkOutCnt].y ==0.0f) continue;

															 GrindMeaDis = Math.GetLength(A2CirOutPoint[GrindMarkOutCnt], A2CirInPoint[k]);
															 if(GrindMeaDis<MinDis){
																 MinDis = GrindMeaDis;
																 GrindMarkInCnt = k;
															 }
														 }
													 }

													 // GrindMark기준 수직 포인트 주변값 Avg산출한다 ==>연마량 측정(OutData,InData기준)
													 if((GrindMarkOutCnt!=0 && GrindMarkOutCnt>5) && (GrindMarkInCnt!=0 && GrindMarkInCnt>5)){
														 CircleCount=0,TotalCirDis=0.0f,GrindWidthDis=0.0f;
														 for(int k=-5; k<5; k++){
															 if(A2CirOutPoint[GrindMarkOutCnt+k].x==0.0f && A2CirOutPoint[GrindMarkOutCnt+k].y==0.0f) continue;
															 if(A2CirInPoint [GrindMarkInCnt +k].x==0.0f && A2CirInPoint [GrindMarkInCnt +k].y==0.0f) continue;
															 GrindWidthDis = Math.GetLength(A2CirInPoint[GrindMarkInCnt+k], A2CirOutPoint[GrindMarkOutCnt+k]);
															 TotalCirDis+=   GrindWidthDis;
															 CircleCount++;
														 }
														 if(TotalCirDis!=0.0f && CircleCount!=0){
															 A2CirGrindWd[2] = TotalCirDis/CircleCount;
															 A2CirGrindWd[2] = A2CirGrindWd[2]+0.5; //SubPixel
														 }
													 }
												 }
											 }
										 }
										 else         { // ENCAP 연마량 계산(Circle Center 좌표가 없다는 가정하에 계산한다)
											 if(A2CirInEdgeCount==A2CirOutEdgeCount){
												 double InDis=0.0f, TotalGrindWidth=0.0f, AvgGrindWidth=0.0f;A2GrindWidthCount=0;
												 for(int k=0; k<A2CirInEdgeCount; k++){
													 if(A2CirOutPoint[k].x==0.0f || A2CirOutPoint[k].y==0.0f || A2CirInPoint[k].x==0.0f || A2CirInPoint[k].y==0.0f) continue;
													 InDis = Math.GetLengthFrPointToPoint(A2CirOutPoint[k],A2CirInPoint[k]);

													 // CircleFitting 진행시 실제 EdgePoint 데이터가 존재 할 경우만 포함하여 계산한다
													 if(InDis!=0.0f){
														 TotalGrindWidth+=InDis;
														 A2GrindWidthCount++;
													 }
												 }
												 if(A2GrindWidthCount!=0){
													 AvgGrindWidth = (TotalGrindWidth/A2GrindWidthCount);
													 A2CirGrindWd[2] = AvgGrindWidth;
												 }
											 }
										 }
										 // FAVION Circle Fitting 결과물 
										 // 비선형 형태, 당장 필요하지 않음 
// 										 SampleSize = A2CirInEdgeCount*0.75; //0.5~0.8이하로 입력할것
// 										 DistDevRatio = 0.15; //0.1~0.25 이하로 입력할것
// 										 CircleFit->OnRansac(A2CirInPoint,A2CirInEdgeCount,SampleSize,DistDevRatio,&ACircleFit2Center,&ACirFitDiameter2);
// 										 LogUnit.SetLog("RightTop_Mark_END");     
									 }
									 else if(FInspectMode==Insp_Mark){
										 // 자재의 외곽라인 교차점 기준 CirCenter 설정함 
										 A2CirCenter.x = FRTPoint.x - ASideCircleWidth;  A2CirCenter.y = FRTPoint.y + ASideCircleHeight;  

										 // Circle Fitting 진행시 공통으로 사용하는 설정값
										 // Circle Fitting 진행시 공통으로 사용하는 설정값
										 Circle->SetSamplingStep(1)                              ; // A2Circle Edge 간격 

										 //A1 In Circle EdgePoint Data 추출 
										 // TrackLine or GrindMark기준 선택하여 가공량 측정 시퀀스는 코딩하지 않음
										 if(A2CirCenter.x!=0 && A2CirCenter.y!=0){
											 // A_Side Circle 검사전 Median 필터 적용 
											 TPoint P1(0,0),P2(0,0),P3(0,0),P4(0,0);
											 P1.x = (int)(FRTPoint.x-ASideCircleWidth-50);    P1.y =(int)(FRTPoint.y-50             );    P2.x = (int)(FRTPoint.x+50);    P2.y = (int)(P1.y);
											 P3.x = (int)(P1.x)                          ;    P3.y =(int)(P1.y+ASideCircleHeight+100);    P4.x = (int)(P2.x         );    P4.y = (int)(P3.y);
											 // Median Filter 적용 
											 if(P1.x<=0    || P1.y<=0    || (P2.x - P1.x)<=0    || (P3.y - P1.y)<=0   ) return false;
											 if(P1.x>=ImgW || P1.y>=ImgH || (P2.x - P1.x)>=ImgW || (P3.y - P1.y)>=ImgH) return false;
											 FilterROI.SetSize(int(P2.x - P1.x),int(P3.y - P1.y) )                 ;
											 FilterROI.Attach(&RotateBinaryImg)                                    ;
											 FilterROI.SetPlacement(P1.x, P1.y, int(P2.x - P1.x), int(P3.y - P1.y));
											 EasyImage::Median(&FilterROI, &FilterROI)                             ;

											 if(ECThresHold==0) Circle->GImage = &RotateImg      ; //Org Image 넘겨줌 
											 else               Circle->GImage = &RotateBinaryImg; //Binary Image 넘겨줌 

											 Circle->SetCenterXY(A2CirCenter.x , A2CirCenter.y)  ; // Circle Center 좌표설정 
											 // 									 A2Diameter = ((ASideCircleWidth*2)+((ASideCircleWidth-OutToTrackLineDis)*2))/2;
											 A2Diameter = (ASideCircleWidth*2);

											 Circle->SetDiameter(A2Diameter)             ;
											 Circle->SetTolerance(60.0f )                ; // A1Circle Tolerance 
											 Circle->SetCircleChoice(1)                  ; // 0:From Begin, 1:From End, 2:Largest Amplitude 
											 Circle->SetCircleIndex (1)                  ; // Circle EdgePoint Index 
											 Circle->SetAngle(270+CirAngleMargin)        ; // Cirlce Angle 
											 Circle->SetAmplitude(90-(2*CirAngleMargin)) ; // Circle Amplitude

											 // Circle InData EdgePoint 
											 //////////////////////////////////////////////////////////////////////////////////////////////////////
											 Circle->SetCircleType(2)                    ; // 0:Black to White, 1:White to Black 2: Both Black, White 
											 Circle->OnExecute()                         ;

											 // Circle In Data 기준 새로운 Circle Center 좌표 받아옴 
											 // Euresys Circle Fitting Center 
											 RealA2CirCenter.x = Circle->FCP.x;
											 RealA2CirCenter.y = Circle->FCP.y;
											 ACirDiameter2     = (Circle->Diameter)/2.0;

											 // Circle In Data취합 
											 OrgA2CirInEdgeCount = Circle->FCirclePointCount;
											 if(OrgA2CirInEdgeCount>0){
												 if(OrgA2CirInPoint!=NULL) delete[] OrgA2CirInPoint;
												 OrgA2CirInPoint = new TFPoint[OrgA2CirInEdgeCount];

												 for(int k=0; k<OrgA2CirInEdgeCount; k++){
													 if(k>MAX_CIRCLE_EDGEPOINT) break;
													 OrgA2CirInPoint[k].x = Circle->FCirclePoint[k].x;
													 OrgA2CirInPoint[k].y = Circle->FCirclePoint[k].y;
													 if(OrgA2CirInPoint[k].x==0.0f && OrgA2CirInPoint[k].y==0.0f) A2CirInEdgeCount++;
												 }
											 }
											 //////////////////////////////////////////////////////////////////////////////////////////////////////

											 // Circle Out Data 다시 검사  
											 //////////////////////////////////////////////////////////////////////////////////////////////////////
											 Circle->SetTolerance(60.0f )      ; // Circle Tolerance 
											 Circle->SetDiameter (A2Diameter)  ; // Circle Diameter 
											 Circle->SetCircleChoice(1)        ; // 0:From Begin, 1:From End, 2:Largest Amplitude 
											 Circle->SetCircleType(2)          ; // 0:Black to White, 1:White to Black 2: Both Black, White 
											 Circle->SetCircleIndex (0)        ; // Circle EdgePoint Index 

											 Circle->OnExecute()               ;

											 // Circle Out Data취합 
											 OrgA2CirOutEdgeCount = Circle->FCirclePointCount;
											 if(OrgA2CirOutEdgeCount>0){
												 if(OrgA2CirOutPoint!=NULL) delete[] OrgA2CirOutPoint;
												 OrgA2CirOutPoint = new TFPoint[OrgA2CirOutEdgeCount];

												 for(int k=0; k<OrgA2CirOutEdgeCount; k++){
													 if(k>MAX_CIRCLE_EDGEPOINT) break;
													 OrgA2CirOutPoint[k].x = Circle->FCirclePoint[k].x;
													 OrgA2CirOutPoint[k].y = Circle->FCirclePoint[k].y;
													 // BTM영역 Circle을 제외한 영역 Defect검사 목적에 좌표계산 
													 if(k==0                     ) {TopEdgePoint[2].x = OrgA2CirOutPoint[k].x; TopEdgePoint[2].y = OrgA2CirOutPoint[k].y;}
													 if(k==OrgA2CirOutEdgeCount-1) {TopEdgePoint[3].x = OrgA2CirOutPoint[k].x; TopEdgePoint[3].y = OrgA2CirOutPoint[k].y;}
													 if(OrgA2CirOutPoint[k].x==0.0f && OrgA2CirOutPoint[k].y==0.0f) A2CirOutEdgeCount++;
												 }
											 }
											 // A2Circle Grind_Width Calculate (연마량 계산)
											 if(IsMarkBtm){ // LTPS경우 가공량 계산 ==> 연마량 계산 
												 if(OrgA2CirOutEdgeCount!=0 && OrgA2CirInEdgeCount!=0){// MarkMode경우 가공량 검사를 먼저 진행 후 연마량 산출  
													 GrindMeaDis =0.0f, MinDis =10000.0f; A2GrindMarkCount=0;
													 if(GrindMarkPoint[20].x!=0.0f && GrindMarkPoint[20].y!=0.0f){  // GrindMark 찾았을경우 
														 for(int k=0; k<OrgA2CirOutEdgeCount; k++){
															 if(OrgA2CirOutPoint[k].x==0.0f || OrgA2CirOutPoint[k].y==0.0f) continue;
															 if(GrindMarkPoint[20].x ==0.0f || GrindMarkPoint[20].y  ==0.0f) continue;

															 GrindMeaDis = Math.GetLength(GrindMarkPoint[20], OrgA2CirOutPoint[k]);
															 if(GrindMeaDis<MinDis){
																 MinDis = GrindMeaDis;
																 A2GrindMarkCount = k;
															 }
														 }

														 // GrindMark기준 수직 포인트 주변값 Avg산출한다 ==>가공량 측정 
														 if(A2GrindMarkCount!=0 && A2GrindMarkCount>5){
															 CircleCount=0,TotalCirDis=0.0f,GrindMeaDis=0.0f;
															 for(int k=A2GrindMarkCount-5; k<A2GrindMarkCount+5; k++){
																 if(OrgA2CirOutPoint[k].x==0.0f || OrgA2CirOutPoint[k].y==0.0f) continue;

																 GrindMeaDis = Math.GetLength(GrindMarkPoint[20], OrgA2CirOutPoint[k]);
																 TotalCirDis+= GrindMeaDis;
																 CircleCount++;
															 }
															 if(TotalCirDis!=0.0f && CircleCount!=0){
																 A2CirGrindMea[2] = TotalCirDis/CircleCount;
															 }
														 }

														 // GrindMark기준 수직 평균값 연마량 측정 
														 if(A2GrindMarkCount!=0 && A2GrindMarkCount>5){
															 CircleCount=0,TotalCirDis=0.0f,GrindWidthDis=0.0f;
															 for(int k=A2GrindMarkCount-5; k<A2GrindMarkCount+5; k++){
																 if(OrgA2CirOutPoint[k].x==0.0f && OrgA2CirOutPoint[k].y==0.0f) continue;
																 if(OrgA2CirInPoint [k].x==0.0f && OrgA2CirInPoint [k].y==0.0f) continue;
																 GrindWidthDis = Math.GetLength(OrgA2CirInPoint[k], OrgA2CirOutPoint[k]);
																 TotalCirDis+=   GrindWidthDis;
																 CircleCount++;
															 }
															 if(TotalCirDis!=0.0f && CircleCount!=0){
																 A2CirGrindWd[2] = TotalCirDis/CircleCount;
															 }
														 }
													 }
													 else { // GrindMark 못 찾았을 경우 
														 for(int k=0; k<OrgA2CirOutEdgeCount; k++){
															 if(OrgA2CirOutPoint[k].x==0.0f || OrgA2CirOutPoint[k].y==0.0f) continue;

															 AGrindMarkRectPoint2.x = GrindMarkRect[20].left + (GrindMarkRect[20].right  - GrindMarkRect[20].left)/2; 
															 AGrindMarkRectPoint2.y = GrindMarkRect[20].top  + (GrindMarkRect[20].bottom - GrindMarkRect[20].top )/2; 

															 GrindMeaDis = Math.GetLength(AGrindMarkRectPoint2, OrgA2CirOutPoint[k]);
															 if(GrindMeaDis<MinDis){
																 MinDis = GrindMeaDis;
																 A2GrindMarkCount = k;
															 }
														 }
														 // GrindMark기준 수직 평균값 연마량 측정 
														 if(A2GrindMarkCount!=0 && A2GrindMarkCount>5 && (A2GrindMarkCount+5<OrgA2CirOutEdgeCount)){
															 CircleCount=0,TotalCirDis=0.0f,GrindWidthDis=0.0f;
															 for(int k=A2GrindMarkCount-5; k<A2GrindMarkCount+5; k++){
																 if(OrgA2CirOutPoint[k].x==0.0f && OrgA2CirOutPoint[k].y==0.0f) continue;
																 if(OrgA2CirInPoint [k].x==0.0f && OrgA2CirInPoint [k].y==0.0f) continue;
																 GrindWidthDis = Math.GetLength(OrgA2CirInPoint[k], OrgA2CirOutPoint[k]);
																 TotalCirDis+=   GrindWidthDis;
																 CircleCount++;
															 }
															 if(TotalCirDis!=0.0f && CircleCount!=0){
																 A2CirGrindWd[2] = TotalCirDis/CircleCount;
															 }
														 }
													 }
												 }
											 }
											 else     { // MarkMode ==> EnCap경우 연마량만 계산한다 
												 if(OrgA2CirInEdgeCount==OrgA2CirOutEdgeCount){
													 double OutDis=0.0f, InDis=0.0f, TotalGrindWidth=0.0f, AvgGrindWidth=0.0f;A2GrindWidthCount=0;
													 for(int k=0; k<OrgA2CirInEdgeCount; k++){
														 if(OrgA2CirOutPoint[k].x==0.0f && OrgA2CirOutPoint[k].y==0.0f){
															 OutDis =0.0f;
														 }
														 else {
															 OutDis = Math.GetLengthFrPointToPoint(A2CirCenter,OrgA2CirOutPoint[k]);
														 }

														 if(OrgA2CirInPoint[k].x==0.0f && OrgA2CirInPoint[k].y==0.0f){
															 InDis =0.0f;
														 }
														 else {
															 InDis = Math.GetLengthFrPointToPoint(A2CirCenter,OrgA2CirInPoint[k]);
														 }

														 // CircleFitting 진행시 실제 EdgePoint 데이터가 존재 할 경우만 포함하여 계산한다
														 if(OutDis!=0.0f && InDis!=0.0f){
															 TotalGrindWidth+=(OutDis - InDis);
															 A2GrindWidthCount++;
														 }
													 }
													 if(A2GrindWidthCount!=0){
														 AvgGrindWidth = (TotalGrindWidth/A2GrindWidthCount);
														 A2CirGrindWd[2] = AvgGrindWidth;
													 }
												 }
											 }

											 //////////////////////////////////////////////////////////////////////////////////////////////////////
											 // Org Circle데이터중 유호하지 않은 값을 제외한 실제 존재하는 데이터 기준으로 동적 메모리 생성함
											 // Circle Defect검사에 필요한 Edge데이터 값
											 int Count=0;
											 if(OrgA2CirInEdgeCount>0){ // A2 CircleInData
												 A2CirInEdgeCount = OrgA2CirInEdgeCount - A2CirInEdgeCount;
												 if(A2CirInEdgeCount>0){
													 if(A2CirInPoint!=NULL) delete[] A2CirInPoint;
													 A2CirInPoint = new TFPoint[A2CirInEdgeCount];

													 for(int k=0; k<OrgA2CirInEdgeCount; k++){
														 if(k>MAX_CIRCLE_EDGEPOINT) break;
														 if(OrgA2CirInPoint[k].x==0.0f && OrgA2CirInPoint[k].y==0.0f) continue;
														 A2CirInPoint[Count].x = OrgA2CirInPoint[k].x;
														 A2CirInPoint[Count].y = OrgA2CirInPoint[k].y;
														 Count++;
													 }
												 }
												 // Circle 원본 데이터 메모리 삭제
												 if(OrgA2CirInPoint!=NULL) delete[] OrgA2CirInPoint;
											 }
											 // FAVION Circle Fitting 결과물 
											 SampleSize = A2CirInEdgeCount*0.75; //0.5~0.8이하로 입력할것
											 DistDevRatio = 0.15; //0.1~0.25 이하로 입력할것
											 CircleFit->OnRansac(A2CirInPoint,A2CirInEdgeCount,SampleSize,DistDevRatio,&ACircleFit2Center,&ACirFitDiameter2);

											 if(OrgA2CirOutEdgeCount>0){// A1 CircleOutData 
												 A2CirOutEdgeCount = OrgA2CirOutEdgeCount - A2CirOutEdgeCount;
												 Count =0;
												 if(A2CirOutEdgeCount>0){
													 if(A2CirOutPoint!=NULL) delete[] A2CirOutPoint;
													 A2CirOutPoint = new TFPoint[A2CirOutEdgeCount];

													 for(int k=0; k<OrgA2CirOutEdgeCount; k++){
														 if(k>MAX_CIRCLE_EDGEPOINT) break;
														 if(OrgA2CirOutPoint[k].x==0.0f && OrgA2CirOutPoint[k].y==0.0f) continue;
														 A2CirOutPoint[Count].x = OrgA2CirOutPoint[k].x;
														 A2CirOutPoint[Count].y = OrgA2CirOutPoint[k].y;
														 Count++;
													 }
												 }
												 // Circle 원본 데이터 메모리 삭제
												 if(OrgA2CirOutPoint!=NULL) delete[] OrgA2CirOutPoint;
											 }
											 // Circle 영역 꽃박리, 원형박리 검출 목적 시퀀스(EnCap)
											 // 정식 명칭은 몰라서.....일단 Crack으로 정함 
											 if(!IsMarkBtm && BrokenThresHold!=0){
												 if(ACirFitDiameter2!=0.0f && ACircleFit2Center.x!=0.0f && ACircleFit2Center.y!=0.0f){ // FAVION Circle Fitting 성공시 박리검사 진행 
													 Circle->GImage = &RotateBrokenImg;                                             //Binary Image 넘겨줌 

													 Circle->SetCenterXY(ACircleFit2Center.x,ACircleFit2Center.y);
													 // 											 Circle->SetTolerance(CirCrackMargin)                      ; // Circle Tolerance 
													 // 											 Circle->SetDiameter ((ACirFitDiameter2-CirCrackMargin)*2) ; // Circle Diameter 
													 Circle->SetTolerance((dEdgeToTrapLineDis/2)-CirOffsetMargin); // Circle Tolerance 
													 Circle->SetDiameter ((ACirFitDiameter2-(dEdgeToTrapLineDis/2))*2) ; // Circle Diameter 
													 Circle->SetCircleChoice(0)                                ; // 0:From Begin, 1:From End, 2:Largest Amplitude 
													 Circle->SetCircleType  (0)                                ; // 0:Black to White, 1:White to Black 2: Both Black, White 
													 Circle->SetCircleIndex (0)                                ; // Circle EdgePoint Index 
													 Circle->SetAngle(325)                                     ; // 패턴으로 인해서 오버킬 발생...범위를 좁혀준다 
													 Circle->SetAmplitude(25)                                  ; // 패턴으로 인해서 오버킬 발생...범위를 좁혀준다 
													 Circle->OnExecute(true)                                   ;
													 CrackACirDiameter2 = (ACirFitDiameter2-(dEdgeToTrapLineDis/2))+((dEdgeToTrapLineDis/2)-CirOffsetMargin);

													 A2CirInCrackCount = Circle->FCirclePointCount;

													 if(A2CirInCrackCount>0){
														 if(A2CirInCrackPoint!=NULL) delete[] A2CirInCrackPoint;
														 A2CirInCrackPoint = new TFPoint[A2CirInCrackCount];

														 for(int k=0; k<A2CirInCrackCount; k++){
															 if(k>MAX_CIRCLE_EDGEPOINT) break;
															 A2CirInCrackPoint[k].x = Circle->FCirclePoint[k].x;
															 A2CirInCrackPoint[k].y = Circle->FCirclePoint[k].y;
														 }
													 }
												 }
											 }
										 }
									 }
								 }
								 LogUnit.SetLog(L"shRectH_Rotate_RightTop_End");     
							 }
						 }
					 }
				 }
				 if(FShape==shRectC ){
					 // Circle 검사에 필요한 로컬변수 초기화 
					 const int GrindMarkRange =40;    const int GrindMarkLength=80;
					 int OrgC1CirInEdgeCount=0;		  int OrgC1CirOutEdgeCount=0;	    int OrgC1CirStandEdgeCount=0;
					 int OrgC2CirInEdgeCount=0;		  int OrgC2CirOutEdgeCount=0;	    int OrgC2CirStandEdgeCount=0;
					 int OrgC3CirInEdgeCount=0;		  int OrgC3CirOutEdgeCount=0;	    int OrgC3CirStandEdgeCount=0;
					 int OrgC4CirInEdgeCount=0;		  int OrgC4CirOutEdgeCount=0;	    int OrgC4CirStandEdgeCount=0;
					 int OrgC5CirInEdgeCount=0;		  int OrgC5CirOutEdgeCount=0;	    int OrgC5CirStandEdgeCount=0;
					 int OrgC6CirInEdgeCount=0;		  int OrgC6CirOutEdgeCount=0;	    int OrgC6CirStandEdgeCount=0;

					 int OrgBtm1InEdgeCount =0;		  int OrgBtm3InEdgeCount =0;	    int OrgBtm5InEdgeCount =0;
					 int OrgBtm1OutEdgeCount=0;		  int OrgBtm3OutEdgeCount=0;	    int OrgBtm5OutEdgeCount=0;
					 int Btm1GrindMarkCount =0;       int Btm3GrindMarkCount =0;        int Btm5GrindMarkCount =0;

					 int C1GrindWidthCount=0;		  int C1GrindMeasureCount=0;
					 int C2GrindWidthCount=0;		  int C2GrindMeasureCount=0;
					 int C3GrindWidthCount=0;		  int C3GrindMeasureCount=0;
					 int C4GrindWidthCount=0;		  int C4GrindMeasureCount=0;
					 int C5GrindWidthCount=0;		  int C5GrindMeasureCount=0;
					 int C6GrindWidthCount=0;		  int C6GrindMeasureCount=0;

					 int C1GrindMarkCount =0;         int C2GrindMarkCount =0;
					 int C3GrindMarkCount =0;         int C4GrindMarkCount =0;
					 int C5GrindMarkCount =0;         int C6GrindMarkCount =0;

					 // Circle Diameter 
					 int C1Diameter       =0;         int C2Diameter         =0; 
					 int C3Diameter       =0;         int C4Diameter         =0; 
					 int C5Diameter       =0;         int C6Diameter         =0; 

					 // Circle In Coordinate Data     // Circle Out Coordinate Data     // Circle(Grind_Measure) Stand Edge Coordinate Data
					 TFPoint *OrgC1CirInPoint=NULL;	  TFPoint *OrgC1CirOutPoint=NULL;	TFPoint *OrgC1CirStandPoint=NULL;
					 TFPoint *OrgC2CirInPoint=NULL;	  TFPoint *OrgC2CirOutPoint=NULL;	TFPoint *OrgC2CirStandPoint=NULL;
					 TFPoint *OrgC3CirInPoint=NULL;	  TFPoint *OrgC3CirOutPoint=NULL;	TFPoint *OrgC3CirStandPoint=NULL;
					 TFPoint *OrgC4CirInPoint=NULL;	  TFPoint *OrgC4CirOutPoint=NULL;	TFPoint *OrgC4CirStandPoint=NULL;
					 TFPoint *OrgC5CirInPoint=NULL;	  TFPoint *OrgC5CirOutPoint=NULL;	TFPoint *OrgC5CirStandPoint=NULL;
					 TFPoint *OrgC6CirInPoint=NULL;	  TFPoint *OrgC6CirOutPoint=NULL;	TFPoint *OrgC6CirStandPoint=NULL;

					 // Notch 직선영영 데이터 취합에 필요함 
					 TFPoint *OrgBtm1InPoint =NULL;	  TFPoint *OrgBtm3InPoint =NULL;	TFPoint *OrgBtm5InPoint =NULL;
					 TFPoint *OrgBtm1OutPoint=NULL;	  TFPoint *OrgBtm3OutPoint=NULL;	TFPoint *OrgBtm5OutPoint=NULL;

					 TFPoint PreC1CirStandPoint[1];   TFPoint PreC4CirStandPoint[1];
					 TFPoint PreC2CirStandPoint[1];	  TFPoint PreC5CirStandPoint[1];
					 TFPoint PreC3CirStandPoint[1];	  TFPoint PreC6CirStandPoint[1];

					 // Polygon Value 
					 int PixelCnt =0;
					 CRect PolyRect[6];
					 if(FInspectMode==Insp_Polygon){
						 for(int k=0; k<6; k++){
							 PolyRect[k].left   =0;
							 PolyRect[k].top    =0;
							 PolyRect[k].right  =0;
							 PolyRect[k].bottom =0;
						 }
					 }

					 if(FCompanyMode==COM_KWON){
						 if(FLBPoint.x!=0 && FLBPoint.y!=0 && FRBPoint.x!=0 && FRBPoint.y!=0) ImgDegree = -(Math.GetDegree(FLBPoint.x , FLBPoint.y, FRBPoint.x, FRBPoint.y));
						 if(ImgDegree!=0.0f){
							 // 원본 RotateImg Size 설정 및 복사 
							 RotateImg.SetSize(GImage->GetWidth(), GImage->GetHeight());
							 EasyImage::Oper(EArithmeticLogicOperation_Copy,GImage,&RotateImg);
							 // 						 GImage->Save("D:\\ROTATE_IMG\\GImage원본_CUP.bmp");
							 // 						 RotateImg.Save("D:\\ROTATE_IMG\\RotateImg원본_CUP.bmp");

							 // 원본 복사하여 이미지 회전 
							 EasyImage::ScaleRotate(GImage, (float)ImgW/2, (float)ImgH/2, (float)ImgW/2, (float)ImgH/2, 1.0f, 1.0f, ImgDegree, &RotateImg, 0);
							 CenterPoint.x = ImgW/2;
							 CenterPoint.y = ImgH/2;
							 // 						 RotateImg.Save("D:\\ROTATE_IMG\\RotateImg회전_CUP.bmp");

							 // Binary RotateImg Size 설정 및 복사 
							 RotateBinaryImg.SetSize(RotateImg.GetWidth(), RotateImg.GetHeight());
							 EasyImage::Oper(EArithmeticLogicOperation_Copy,&RotateImg,&RotateBinaryImg);
							 // 						 RotateBinaryImg.Save("D:\\ROTATE_IMG\\RotateBinaryImg회전_CUP.bmp");

							 if(FLeftWall){
								 EasyImage::Threshold(&RotateImg,&RotateBinaryImg, LeftEdgeThresHold);
								 if(LeftEdgeThresHold==0) {SingleLine->GImage = &RotateImg      ; SingleLine->FThreshold =5 ;}
								 else                     {SingleLine->GImage = &RotateBinaryImg; SingleLine->FThreshold =10;}

								 SingleLine->IRoi->SetOrgX  (IRoi->GetOrgX());
								 SingleLine->IRoi->SetOrgY  (IRoi->GetOrgY());
								 SingleLine->IRoi->SetWidth (IRoi->GetWidth());
								 SingleLine->IRoi->SetHeight(IRoi->GetHeight());

								 SingleLine->SetOrientation(orWest);

								 if(IRoi->GetHeight()<350) SingleLine->SetIncrement(5 );
								 else                      SingleLine->SetIncrement(10);
								 SingleLine->SetFindLineId(0);
								 //SingleLine->FThreshold =10;
								 SingleLine->OnExecute();
								 Line[0].FP0 = SingleLine->GetResultP0(); // 기본 외곽라인 찾는다 
								 Line[0].FP1 = SingleLine->GetResultP1(); // 기본 외곽라인 찾는다 
							 }
							 if(FBottomWall){
								 EasyImage::Threshold(&RotateImg,&RotateBinaryImg, BtmEdgeThresHold);
								 if(BtmEdgeThresHold==0)    {SingleLine->GImage = &RotateImg      ; SingleLine->FThreshold =5 ;}
								 else                       {SingleLine->GImage = &RotateBinaryImg; SingleLine->FThreshold =10;}

								 SingleLine->IRoi->SetOrgX  (IRoi->GetOrgX());
								 SingleLine->IRoi->SetOrgY  (IRoi->GetOrgY());
								 SingleLine->IRoi->SetWidth (IRoi->GetWidth());
								 SingleLine->IRoi->SetHeight(IRoi->GetHeight());

								 SingleLine->SetOrientation(orSouth);
								 SingleLine->FIncrement =10;
								 SingleLine->SetFindLineId(0);
								 SingleLine->FThreshold =5;
								 SingleLine->OnExecute();
								 Line[waBottomWall].FP0 = SingleLine->GetResultP0();
								 Line[waBottomWall].FP1 = SingleLine->GetResultP1();

								 if(BtmOffset!=0 && BtmBmLineThresHold!=0){
									 EasyImage::Threshold(&RotateImg,&RotateBinaryImg, BtmBmLineThresHold);

									 SingleLine->GImage = &RotateBinaryImg;

									 // 영역설정 
									 if(fabs(Line[3].FP0.x - Line[3].FP1.x) > 3){
										 LSP.x = 
											 LSP.y = (Line[3].FP0.y + Line[3].FP1.y)/2;
									 }
									 else {
										 LSP = Math.OnIntersect(Line[3].FP0, Line[3].FP1, LT, LB);
									 }

									 SingleLine->IRoi->SetOrgX  (IRoi->GetOrgX()        );
									 SingleLine->IRoi->SetOrgY  ((int)(LSP.y-BMHeight)  );
									 SingleLine->IRoi->SetWidth (IRoi->GetWidth()       );
									 SingleLine->IRoi->SetHeight(BMHeight               );

									 // EdgeType Check 
									 // 								 if(IsMarkBtm) {
									 // 									 if(BtmBMLineDir==0) SingleLine->SetEdgeType(0); // Black To White 
									 // 									 else                SingleLine->SetEdgeType(1); // White To Black  
									 // 								 }
									 // 								 else          {
									 // 									 if(BtmBMLineDir==0) SingleLine->SetEdgeType(0); // Black To White 
									 // 									 else                SingleLine->SetEdgeType(1); // White To Black  
									 // 								 }

									 // EdgeType Check 
									 if(IsMarkBtm) SingleLine->SetEdgeType(0); 
									 else          SingleLine->SetEdgeType(1); 


									 if((LSP.y-2)<0) return false;

									 SingleLine->SetOrientation(orSouth);
									 SingleLine->FIncrement =10;
									 SingleLine->SetFindLineId(0);
									 SingleLine->OnExecute();
									 BtmBMLine[0].FP0 = SingleLine->GetResultP0();
									 BtmBMLine[0].FP1 = SingleLine->GetResultP1();

									 // SingleLine Org Parameter 
									 SingleLine->SetEdgeType(2);
								 }
							 }
							 if(FRightWall){
								 EasyImage::Threshold(&RotateImg,&RotateBinaryImg, RightEdgeThresHold);
								 if(RightEdgeThresHold==0)  {SingleLine->GImage = &RotateImg      ; SingleLine->FThreshold =5 ;}
								 else                       {SingleLine->GImage = &RotateBinaryImg; SingleLine->FThreshold =10;}

								 SingleLine->IRoi->SetOrgX  (IRoi->GetOrgX());
								 SingleLine->IRoi->SetOrgY  (IRoi->GetOrgY());
								 SingleLine->IRoi->SetWidth (IRoi->GetWidth());
								 SingleLine->IRoi->SetHeight(IRoi->GetHeight());

								 SingleLine->SetOrientation(orEast);
								 SingleLine->FIncrement =10;
								 SingleLine->SetFindLineId(0);
								 SingleLine->FThreshold =5;
								 SingleLine->OnExecute();
								 Line[2].FP0 = SingleLine->GetResultP0();
								 Line[2].FP1 = SingleLine->GetResultP1();

								 // RightLineData 
								 RightLineData = (float)((Line[waRightWall].FP0.x + Line[waRightWall].FP1.x)/2.0);

							 }
							 if(FLeftBottom ){
								 if(ECThresHold==0) {SingleLine->GImage = &RotateImg; SingleLine->FThreshold =5 ;}
								 else               {
									 EasyImage::Threshold(&RotateImg,&RotateBinaryImg, ECThresHold);
									 SingleLine->GImage = &RotateBinaryImg; SingleLine->FThreshold =10;
								 }

								 //CornerHeight = 45;
								 SingleLine->FIncrement =1;
								 SingleLine->SetFindLineId(0);

								 OrgPoint = Math.OnIntersect(Line[waLeftWall].FP0, Line[waLeftWall].FP1, Line[waBottomWall].FP0, Line[waBottomWall].FP1);
								 FLBPoint = OrgPoint;

							 }
							 if(FRightBottom){
								 if(ECThresHold==0) {SingleLine->GImage = &RotateImg; SingleLine->FThreshold =5 ;}
								 else               {
									 EasyImage::Threshold(&RotateImg,&RotateBinaryImg, ECThresHold);
									 SingleLine->GImage = &RotateBinaryImg; SingleLine->FThreshold =10;
								 }

								 //CornerHeight = 45;
								 SingleLine->FIncrement =1;
								 SingleLine->SetFindLineId(0);

								 OrgPoint = Math.OnIntersect(Line[waRightWall].FP0, Line[waRightWall].FP1, Line[waBottomWall].FP0, Line[waBottomWall].FP1);
								 FRBPoint = OrgPoint;

							 }
						 }
					 }
				     else if(FCompanyMode==COM_NOTCH){ // shRectC Image Rotate Sequence 
						 // Image Roate 전 원본이미지 기준 교차점 산출 
						 FLBPoint = Math.OnIntersect(Line[0].FP0 , Line[0].FP1 , Line[3].FP0, Line[3].FP1);
						 FRBPoint = Math.OnIntersect(Line[2].FP0 , Line[2].FP1 , Line[3].FP0, Line[3].FP1);

// 						 FLBPoint = Math.OnIntersect(Line[waLeftWall].FP0 , Line[waLeftWall].FP1 , Line[waBottomWall].FP0, Line[waBottomWall].FP1);
// 						 FRBPoint = Math.OnIntersect(Line[waRightWall].FP0, Line[waRightWall].FP1, Line[waBottomWall].FP0, Line[waBottomWall].FP1);

						 if(FLBPoint.x!=0 && FLBPoint.y!=0 && FRBPoint.x!=0 && FRBPoint.y!=0) ImgDegree = -(Math.GetDegree(FLBPoint.x , FLBPoint.y, FRBPoint.x, FRBPoint.y));

						 // Left_Mark와 Right_Mark각도가 정확히 0도인경우 발생하여 조건을 바꿈
// 						 if(ImgDegree!=0.0f){ // 원본이미지 교차점 기준 Align틀어졌을경우 이미지 회전 
						 if(FLBPoint.x!=0 && FLBPoint.y!=0 && FRBPoint.x!=0 && FRBPoint.y!=0){ // 원본이미지 교차점 기준 Align틀어졌을경우 이미지 회전 
						 // 원본 RotateImg Size 설정 및 복사 
// 							 LogUnit.SetLog("shRectC_RotateImg_Start");     
							 RotateImg.SetSize(GImage->GetWidth(), GImage->GetHeight());
							 EasyImage::Oper(EArithmeticLogicOperation_Copy,GImage,&RotateImg);

							 // 원본 복사하여 이미지 회전 
							 EasyImage::ScaleRotate(GImage, (float)ImgW/2, (float)ImgH/2, (float)ImgW/2, (float)ImgH/2, 1.0f, 1.0f, ImgDegree, &RotateImg, 4);
							 CenterPoint.x = ImgW/2;
							 CenterPoint.y = ImgH/2;
							 //EasyImage::ScaleRotate(GImage, (float)ImgW/2, (float)ImgH/2, (float)ImgW/2, (float)ImgH/2, 1.0f, 0.2f, ImgDegree, &RotateImg, 0);
							 //EasyImage::ScaleRotate(GImage, (float)ImgW/2, (float)ImgH/2, (float)ImgW/2, (float)ImgH/2, 1.0f, 1.0f, ImgDegree, &RotateImg, 0);
							 //GImage->Save   ("D:\\ROTATE_IMG\\GImage_CUP.bmp");
							 //RotateImg.Save("D:\\ROTATE_IMG\\RotateImg회전_CUP.bmp");

							 // Binary RotateImg Size 설정 및 복사 
							 RotateBinaryImg.SetSize(RotateImg.GetWidth(), RotateImg.GetHeight());
							 EasyImage::Oper(EArithmeticLogicOperation_Copy,&RotateImg,&RotateBinaryImg);
// 							 RotateBinaryImg.Save("D:\\ROTATE_IMG\\RotateImg_CUP_원본.bmp");

							 // Circle Grind In EdgePoint 검출목적 이미지 
							 RotateGrindInBinaryImg.SetSize(RotateImg.GetWidth(), RotateImg.GetHeight());
							 EasyImage::Oper(EArithmeticLogicOperation_Copy,&RotateImg,&RotateGrindInBinaryImg);

							 // Grind Measure Corner, Circle 검사 목적 
							 RotateGrindBinaryImg.SetSize(RotateImg.GetWidth(), RotateImg.GetHeight());
							 EasyImage::Oper(EArithmeticLogicOperation_Copy,&RotateImg,&RotateGrindBinaryImg);
//							 RotateImg.Save("D:\\ROTATE_IMG\\RotateImg회전_CUP.bmp");
// 							 LogUnit.SetLog("shRectC_RotateImg_End");    

						 // TEST 
						 // 						 FLBPoint    = Math.OnRotate(CenterPoint, FLBPoint     , -(ImgDegree));
							 //								 FRBPoint    = Math.OnRotate(CenterPoint, FRBPoint     , -(ImgDegree));

							 if(FLeftWall){ // shRectC Image Rotate Sequence  
							     EasyImage::Threshold(&RotateImg,&RotateBinaryImg, LeftEdgeThresHold);
								 if(LeftEdgeThresHold==0) {SingleLine->GImage = &RotateImg      ;  SingleLine->FThreshold =5 ;}
								 else                     {SingleLine->GImage = &RotateBinaryImg;  SingleLine->FThreshold =10;}


								 SingleLine->IRoi->SetOrgX  (IRoi->GetOrgX()          );
								 SingleLine->IRoi->SetOrgY  (IRoi->GetOrgY()          );
								 SingleLine->IRoi->SetWidth (IRoi->GetWidth()         );
								 // ChamberCut VS Circle VS Rect경우에 따라서 Left영역 Fitting구간 높이가 달라짐 
								 if(IsCornerBtm) SingleLine->IRoi->SetHeight(FEndLine-LBCornerHeight   );
								 else            SingleLine->IRoi->SetHeight(FEndLine-CSideCircleHeight);
								 
								 SingleLine->SetIncrement(5 );

								 SingleLine->SetOrientation(orWest);

								 SingleLine->SetFindLineId(0);
								 // 							 SingleLine->SetEdgeType(0);  //Black To White  

								 // TEST 
								 if(IsMarkBtm) SingleLine->SetEdgeType(0); // Black to White 
								 else          SingleLine->SetEdgeType(1); // White to Black  

								 SingleLine->OnExecute();
								 Line[0].FP0 = SingleLine->GetResultP0();
								 Line[0].FP1 = SingleLine->GetResultP1();

								 if((fabs(Line[0].FP0.x - Line[0].FP1.x)>2) && (Line[0].FP1.x >Line[0].FP0.x)) Line[0].FP1.x = Line[0].FP0.x;

								 // Btm,Top 상관없이 첫번째
								 LeftOutLine[0].FP0.x = Line[0].FP0.x;
								 LeftOutLine[0].FP0.y = Line[0].FP0.y;
								 LeftOutLine[0].FP1.x = Line[0].FP1.x;
								 LeftOutLine[0].FP1.y = Line[0].FP1.y;

								 if(fabs(LeftOutLine[0].FP0.x - LeftOutLine[0].FP1.x)>=0.5){
									 LeftOutLine[0].FP0.x = (LeftOutLine[0].FP0.x+LeftOutLine[0].FP1.x)/2.0;
									 LeftOutLine[0].FP1.x = (LeftOutLine[0].FP0.x+LeftOutLine[0].FP1.x)/2.0;
								 }

								 // LeftOutLine....make OutLine Data 
								 // 현재의 데이터를 넘겨준다 
								 // 검사중 기준라인을 찾지 못할경우 이전데이터 넘겨줘서 기준라인 생성함 
								 if(LeftOutLine[0].FP0.x!=0.0f && LeftOutLine[0].FP0.y!=0.0f && LeftOutLine[0].FP1.x!=0.0f && LeftOutLine[0].FP1.y!=0.0f){
									 PreLeftOutLine[0].FP0.x = LeftOutLine[0].FP0.x;    PreLeftOutLine[0].FP1.x = LeftOutLine[0].FP1.x;       
									 PreLeftOutLine[0].FP0.y = LeftOutLine[0].FP0.y;    PreLeftOutLine[0].FP1.y = LeftOutLine[0].FP1.y;       
								 } // 셀의 상단 시작부터 Broken 발생으로 데이터가 없는경우 
								 else if(LeftOutLine[0].FP0.x==0.0f || LeftOutLine[0].FP0.y==0.0f || LeftOutLine[0].FP1.x==0.0f || LeftOutLine[0].FP1.y==0.0f){
									 if(PreLeftOutLine[0].FP0.x==0.0f && PreLeftOutLine[0].FP0.y==0.0f && PreLeftOutLine[0].FP1.x==0.0f && PreLeftOutLine[0].FP1.y==0.0f){// 시작부분 Broken발생으로 데이터가 없는경우 
										 // Mark좌표를 기준으로 라인좌표값을 다시 설정함 
										 ROI_H = IRoi->GetHeight();
										 LeftOutLine[0].FP0.x = Line[0].FP0.x;    LeftOutLine[0].FP0.y = 0.0f        ;
										 LeftOutLine[0].FP1.x = Line[0].FP1.x;    LeftOutLine[0].FP1.y = (float)ROI_H;

										 //Line 데이터를 PreLine에 넘겨준다 
										 PreLeftOutLine[0].FP0.x = LeftOutLine[0].FP0.x;    PreLeftOutLine[0].FP1.x = LeftOutLine[0].FP1.x;       
										 PreLeftOutLine[0].FP0.y = LeftOutLine[0].FP0.y;    PreLeftOutLine[0].FP1.y = LeftOutLine[0].FP1.y;       
									 }
									 else { // 중간부분 Broken발생으로 데이터가 없는경우 
										 // PreLine 데이터를 넘겨줌 
										 LeftOutLine[0].FP0.x = PreLeftOutLine[0].FP0.x;  LeftOutLine[0].FP1.x = PreLeftOutLine[0].FP1.x;  
										 LeftOutLine[0].FP0.y = PreLeftOutLine[0].FP0.y;  LeftOutLine[0].FP1.y = PreLeftOutLine[0].FP1.y;  
									 }
								 }

								 if(IsAllGrind){ 
									 if(IsMarkBtm){ //LeftInLine, LeftTrackLine Search, Data생성 
										 // LeftInLine Search Start 
										 EasyImage::Threshold(&RotateImg,&RotateBinaryImg, LeftEdgeThresHold);
										 if(LeftEdgeThresHold==0) {SingleLine->GImage = &RotateImg      ;  SingleLine->FThreshold =5 ;}
										 else                     {SingleLine->GImage = &RotateBinaryImg;  SingleLine->FThreshold =10;}

										 // 영역설정 
										 if(fabs(LeftOutLine[0].FP0.x - LeftOutLine[0].FP1.x) > 3){
											 LSP.x = (LeftOutLine[0].FP0.x + LeftOutLine[0].FP1.x)/2;
											 LSP.y = 0.0f;
										 }
										 else {
											 LSP = Math.OnIntersect(LeftOutLine[0].FP0, LeftOutLine[0].FP1, LT, RT);
										 }

										 SingleLine->IRoi->SetOrgX  ((int)LSP.x+3 );
										 SingleLine->IRoi->SetOrgY  (0            );
										 SingleLine->IRoi->SetWidth (100          );
										 SingleLine->IRoi->SetHeight(ImgH         );
										 SingleLine->SetIncrement(5 );

										 if(((LSP.x+3)<=0) || ImgH<=0) return false;

										 // 									 if(IRoi->GetHeight()<300) SingleLine->SetIncrement(5 );
										 // 									 else                      SingleLine->SetIncrement(10);

										 // 연마량 측정 OutLine
										 SingleLine->SetFindLineId(0);
										 SingleLine->SetOrientation(orWest);
										 SingleLine->SetEdgeType(0); // Black to White 
										 SingleLine->OnExecute();
										 LeftInLine[0].FP0 = SingleLine->GetResultP0();
										 LeftInLine[0].FP1 = SingleLine->GetResultP1();

										 SingleLine->SetEdgeType(2); // Line Search Org 

										 // LeftInLine None....make InLine Data 
										 // 현재의 데이터를 넘겨준다 
										 if(LeftInLine[0].FP0.x!=0.0f && LeftInLine[0].FP0.y!=0.0f && LeftInLine[0].FP1.x!=0.0f && LeftInLine[0].FP1.y!=0.0f){
											 PreLeftInLine[0].FP0.x = LeftInLine[0].FP0.x;    PreLeftInLine[0].FP1.x = LeftInLine[0].FP1.x;       
											 PreLeftInLine[0].FP0.y = LeftInLine[0].FP0.y;    PreLeftInLine[0].FP1.y = LeftInLine[0].FP1.y;       
										 }
										 else if(LeftInLine[0].FP0.x==0.0f || LeftInLine[0].FP0.y==0.0f || LeftInLine[0].FP1.x==0.0f || LeftInLine[0].FP1.y==0.0f){
											 if(PreLeftInLine[0].FP0.x==0.0f && PreLeftInLine[0].FP0.y==0.0f && PreLeftInLine[0].FP1.x==0.0f && PreLeftInLine[0].FP1.y==0.0f){// 시작부분 Broken발생으로 데이터가 없는경우 
												 // Mark좌표를 기준으로 라인좌표값을 다시 설정함 
												 ROI_H = IRoi->GetHeight();
												 ROI_L = IRoi->GetOrgX()  ;
												 LeftInLine[0].FP0.x = ROI_L;   LeftInLine[0].FP0.y = 0.0f        ;
												 LeftInLine[0].FP1.x = ROI_L;   LeftInLine[0].FP1.y = (float)ROI_H;

												 //Line 데이터를 PreLine에 넘겨준다 
												 PreLeftInLine[0].FP0.x = LeftInLine[0].FP0.x;    PreLeftInLine[0].FP1.x = LeftInLine[0].FP1.x;       
												 PreLeftInLine[0].FP0.y = LeftInLine[0].FP0.y;    PreLeftInLine[0].FP1.y = LeftInLine[0].FP1.y;       
											 }
											 else {                                                                                                    // 중간부분 Broken발생으로 데이터가 없는경우 
												 // PreLine 데이터를 넘겨줌 
												 LeftInLine[0].FP0.x = PreLeftInLine[0].FP0.x;  LeftInLine[0].FP1.x = PreLeftInLine[0].FP1.x;  
												 LeftInLine[0].FP0.y = PreLeftInLine[0].FP0.y;  LeftInLine[0].FP1.y = PreLeftInLine[0].FP1.y;  
											 }
										 }
										 // NOTCH CELL Btm 검사에서만 연마폭 측정함 
										 Left_Grind_Width =(float)(Math.GetLengthFrLineToPoint (LeftOutLine[0].FP0,LeftOutLine[0].FP1, LeftInLine[0].FP0 ));
										 ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////


										 // LeftTrackLine Search Start 
										 EasyImage::Threshold(&RotateImg,&RotateBinaryImg, CirGrindMeaThresHold);

										 // LeftInLine기준 LeftTrackLine 검출  
										 if(CirGrindMeaThresHold==0) {SingleLine->GImage = &RotateImg      ;  SingleLine->FThreshold =5 ;}
										 else                        {SingleLine->GImage = &RotateBinaryImg;  SingleLine->FThreshold =10;}

										 // 영역설정 
										 if(fabs(LeftInLine[0].FP0.x - LeftInLine[0].FP1.x) > 3){
											 LSP.x = (LeftInLine[0].FP0.x + LeftInLine[0].FP1.x)/2;
											 LSP.y = 0.0f;
										 }
										 else {
											 LSP = Math.OnIntersect(LeftInLine[0].FP0, LeftInLine[0].FP1, LT, RT);
										 }

										 SingleLine->IRoi->SetOrgX  ((int)LSP.x+3 );
										 SingleLine->IRoi->SetOrgY  (0            );
										 SingleLine->IRoi->SetWidth (100          );
										 SingleLine->IRoi->SetHeight(ImgH         );
										 SingleLine->SetIncrement(5 );

										 if(((LSP.x+3)<=0) || ImgH<=0) return false;

										 // 									 if(IRoi->GetHeight()<300) SingleLine->SetIncrement(5 );
										 // 									 else                      SingleLine->SetIncrement(10);

										 // Left Track Line Search 
										 SingleLine->SetFindLineId(0);
										 SingleLine->SetOrientation(orWest);
										 SingleLine->SetEdgeType(1); // White To Black  
										 SingleLine->OnExecute();
										 LeftTrackLine[0].FP0 = SingleLine->GetResultP0();
										 LeftTrackLine[0].FP1 = SingleLine->GetResultP1();

										 SingleLine->SetEdgeType(2); // Line Search Type Normal 

										 // LeftTrackLine....make OutLine Data 
										 // 현재의 데이터를 넘겨준다 
										 // 검사중 기준라인을 찾지 못할경우 이전데이터 넘겨줘서 기준라인 생성함 
										 if(LeftTrackLine[0].FP0.x!=0.0f && LeftTrackLine[0].FP0.y!=0.0f && LeftTrackLine[0].FP1.x!=0.0f && LeftTrackLine[0].FP1.y!=0.0f){
											 PreLeftTrackLine[0].FP0.x = LeftTrackLine[0].FP0.x;    PreLeftTrackLine[0].FP1.x = LeftTrackLine[0].FP1.x;       
											 PreLeftTrackLine[0].FP0.y = LeftTrackLine[0].FP0.y;    PreLeftTrackLine[0].FP1.y = LeftTrackLine[0].FP1.y;       
										 } // 셀의 상단 시작부터 Broken 발생으로 데이터가 없는경우 
										 else if(LeftTrackLine[0].FP0.x==0.0f || LeftTrackLine[0].FP0.y==0.0f || LeftTrackLine[0].FP1.x==0.0f || LeftTrackLine[0].FP1.y==0.0f){
											 if(PreLeftTrackLine[0].FP0.x==0.0f && PreLeftTrackLine[0].FP0.y==0.0f && PreLeftTrackLine[0].FP1.x==0.0f && PreLeftTrackLine[0].FP1.y==0.0f){// 시작부분 Broken발생으로 데이터가 없는경우 
												 // Mark좌표를 기준으로 라인좌표값을 다시 설정함 
												 ROI_H = IRoi->GetHeight();
												 ROI_L = IRoi->GetOrgX()  ;
												 LeftTrackLine[0].FP0.x = ROI_L;    LeftTrackLine[0].FP0.y = 0.0f        ;
												 LeftTrackLine[0].FP1.x = ROI_L;    LeftTrackLine[0].FP1.y = (float)ROI_H;

												 //LeftTrackLine 데이터를 PreLeftTrackLine에 넘겨준다 
												 PreLeftTrackLine[0].FP0.x = LeftTrackLine[0].FP0.x;    PreLeftTrackLine[0].FP1.x = LeftTrackLine[0].FP1.x;       
												 PreLeftTrackLine[0].FP0.y = LeftTrackLine[0].FP0.y;    PreLeftTrackLine[0].FP1.y = LeftTrackLine[0].FP1.y;       
											 }
											 else { // 중간부분 Broken발생으로 데이터가 없는경우 
												 // PreLeftTrackLine 데이터를 넘겨줌 
												 LeftTrackLine[0].FP0.x = PreLeftTrackLine[0].FP0.x;  LeftTrackLine[0].FP1.x = PreLeftTrackLine[0].FP1.x;  
												 LeftTrackLine[0].FP0.y = PreLeftTrackLine[0].FP0.y;  LeftTrackLine[0].FP1.y = PreLeftTrackLine[0].FP1.y;  
											 }
										 }
										 // NOTCH CELL Btm 검사에서만 연마폭 측정함 
										 Left_Grind_Mea =(float)(Math.GetLengthFrLineToPoint (LeftOutLine[0].FP0,LeftOutLine[0].FP1, LeftTrackLine[0].FP0 ));

										 // 마크라인에서 부터 LeftTrackLine 까지 거리 산출 
										 // LeftTrackLine Data 존재할 경우 거리 측정함 
										 if(LeftTrackLine[0].FP0.x!=0.0f && LeftTrackLine[0].FP0.y!=0.0f && LeftTrackLine[0].FP1.x!=0.0f && LeftTrackLine[0].FP1.y!=0.0f){
// 											 LeftTrackLine[0].FP0.y = LeftTrackLine[0].FP0.y + ImageHeight; //전체 이미지 기준 y좌표
// 											 LeftTrackLine[0].FP1.y = LeftTrackLine[0].FP1.y + ImageHeight; //전체 이미지 기준 y좌표
// 
// 											 MarkToTrackLineDis1 = Math.GetLengthFrLineToPoint(LeftMarkSta, LeftMarkEnd, LeftTrackLine[0].FP0);//Mark라인에서 TrackLine거리 
// 											 MarkToTrackLineDis2 = Math.GetLengthFrLineToPoint(LeftMarkSta, LeftMarkEnd, LeftTrackLine[0].FP1);//Mark라인에서 TrackLine거리 
// 
// 											 TotalLeftTrackDis  +=  (int)((MarkToTrackLineDis1 + MarkToTrackLineDis2)/2.0); //Mark라인에서 TrackLine거리 누적                   
// 											 LeftTrackLineCount++; //누적 카운트 증가
// 
// 											 // Org Data 
// 											 LeftTrackLine[0].FP0.y = LeftTrackLine[0].FP0.y - ImageHeight; //Frame 이미지 기준 y좌표 원복
// 											 LeftTrackLine[0].FP1.y = LeftTrackLine[0].FP1.y - ImageHeight; //Frame 이미지 기준 y좌표 원복 
										 }
										 ///////////////////////////////////////////////////////////////////////////////////////////////////////
									 }
									 else { //LeftInLine Search, LeftTrackLine Data Overlap 
										 // LeftInLine Search Start 
										 EasyImage::Threshold(&RotateImg,&RotateBinaryImg, LeftEdgeThresHold);
										 if(LeftEdgeThresHold==0) {SingleLine->GImage = &RotateImg      ;  SingleLine->FThreshold =5 ;}
										 else                     {SingleLine->GImage = &RotateBinaryImg;  SingleLine->FThreshold =10;}

										 // 영역설정 
										 if(fabs(LeftOutLine[0].FP0.x - LeftOutLine[0].FP1.x) > 3){
											 LSP.x = (LeftOutLine[0].FP0.x + LeftOutLine[0].FP1.x)/2;
											 LSP.y = 0.0f;
										 }
										 else {
											 LSP = Math.OnIntersect(LeftOutLine[0].FP0, LeftOutLine[0].FP1, LT, RT);
										 }

										 SingleLine->IRoi->SetOrgX  ((int)LSP.x+3 );
										 SingleLine->IRoi->SetOrgY  (0            );
										 SingleLine->IRoi->SetWidth (100          );
										 SingleLine->IRoi->SetHeight(ImgH         );
										 SingleLine->SetIncrement(5 );

										 if(((LSP.x+3)<=0) || ImgH<=0) return false;

										 // 									 if(IRoi->GetHeight()<300) SingleLine->SetIncrement(5 );
										 // 									 else                      SingleLine->SetIncrement(10);

										 // 연마량 측정 OutLine
										 SingleLine->SetFindLineId(0);
										 SingleLine->SetOrientation(orWest);
										 SingleLine->SetEdgeType(0); // Black to White 
										 SingleLine->OnExecute();
										 LeftInLine[0].FP0 = SingleLine->GetResultP0();
										 LeftInLine[0].FP1 = SingleLine->GetResultP1();

										 SingleLine->SetEdgeType(2); // Line Search Org 

										 // LeftInLine None....make InLine Data 
										 // 현재의 데이터를 넘겨준다 
										 if(LeftInLine[0].FP0.x!=0.0f && LeftInLine[0].FP0.y!=0.0f && LeftInLine[0].FP1.x!=0.0f && LeftInLine[0].FP1.y!=0.0f){
											 PreLeftInLine[0].FP0.x = LeftInLine[0].FP0.x;    PreLeftInLine[0].FP1.x = LeftInLine[0].FP1.x;       
											 PreLeftInLine[0].FP0.y = LeftInLine[0].FP0.y;    PreLeftInLine[0].FP1.y = LeftInLine[0].FP1.y;       
										 }
										 else if(LeftInLine[0].FP0.x==0.0f || LeftInLine[0].FP0.y==0.0f || LeftInLine[0].FP1.x==0.0f || LeftInLine[0].FP1.y==0.0f){
											 if(PreLeftInLine[0].FP0.x==0.0f && PreLeftInLine[0].FP0.y==0.0f && PreLeftInLine[0].FP1.x==0.0f && PreLeftInLine[0].FP1.y==0.0f){// 시작부분 Broken발생으로 데이터가 없는경우 
												 // Mark좌표를 기준으로 라인좌표값을 다시 설정함 
												 ROI_H = IRoi->GetHeight();
												 ROI_L = IRoi->GetOrgX()  ;
												 LeftInLine[0].FP0.x = ROI_L;   LeftInLine[0].FP0.y = 0.0f        ;
												 LeftInLine[0].FP1.x = ROI_L;   LeftInLine[0].FP1.y = (float)ROI_H;

												 //Line 데이터를 PreLine에 넘겨준다 
												 PreLeftInLine[0].FP0.x = LeftInLine[0].FP0.x;    PreLeftInLine[0].FP1.x = LeftInLine[0].FP1.x;       
												 PreLeftInLine[0].FP0.y = LeftInLine[0].FP0.y;    PreLeftInLine[0].FP1.y = LeftInLine[0].FP1.y;       
											 }
											 else {                                                                                                    // 중간부분 Broken발생으로 데이터가 없는경우 
												 // PreLine 데이터를 넘겨줌 
												 LeftInLine[0].FP0.x = PreLeftInLine[0].FP0.x;  LeftInLine[0].FP1.x = PreLeftInLine[0].FP1.x;  
												 LeftInLine[0].FP0.y = PreLeftInLine[0].FP0.y;  LeftInLine[0].FP1.y = PreLeftInLine[0].FP1.y;  
											 }
										 }
										 // NOTCH CELL Btm 검사에서만 연마폭 측정함 
										 Left_Grind_Width =(float)(Math.GetLengthFrLineToPoint (LeftOutLine[0].FP0,LeftOutLine[0].FP1, LeftInLine[0].FP0 ));
										 ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////

										 // LeftTrackLine Data Overlap 
										 if(AvgLeftTrackLineDis!=0){
// 											 LeftOutLine[0].FP0.y = LeftOutLine[0].FP0.y + ImageHeight; //전체 이미지 기준 y좌표
// 											 LeftOutLine[0].FP1.y = LeftOutLine[0].FP1.y + ImageHeight; //전체 이미지 기준 y좌표
// 
// 											 MarkToTrackLineDis1 = Math.GetLengthFrLineToPoint(LeftMarkSta, LeftMarkEnd, LeftOutLine[0].FP0);//Mark라인에서 OutLine까지 거리 
// 											 MarkToTrackLineDis2 = Math.GetLengthFrLineToPoint(LeftMarkSta, LeftMarkEnd, LeftOutLine[0].FP1);//Mark라인에서 OutLine까지 거리 
// 
// 											 if(MarkToTrackLineDis1>AvgLeftTrackLineDis) LeftTrackLine[0].FP0.x = LeftOutLine[0].FP0.x+(MarkToTrackLineDis1 - AvgLeftTrackLineDis);
// 											 if(MarkToTrackLineDis2>AvgLeftTrackLineDis) LeftTrackLine[0].FP1.x = LeftOutLine[0].FP1.x+(MarkToTrackLineDis2 - AvgLeftTrackLineDis);
// 
// 											 // LeftOutLine Data 원본 
// 											 LeftOutLine[0].FP0.y = LeftOutLine[0].FP0.y - ImageHeight; 
// 											 LeftOutLine[0].FP1.y = LeftOutLine[0].FP1.y - ImageHeight; 
// 
// 											 LeftTrackLine[0].FP0.y = LeftOutLine[0].FP0.y;
// 											 LeftTrackLine[0].FP1.y = LeftOutLine[0].FP1.y;
										 }
									 }
								 }
								 else {
									 if(IsMarkBtm){ //LeftTrackLine Search,Data생성
										 if(FInspectMode==Insp_Track){
											 // LeftTrackLine Search Start 
											 EasyImage::Threshold(&RotateImg,&RotateBinaryImg, CirGrindMeaThresHold);
											 if(CirGrindMeaThresHold==0) {SingleLine->GImage = &RotateImg      ;  SingleLine->FThreshold =5 ;}
											 else                        {SingleLine->GImage = &RotateBinaryImg;  SingleLine->FThreshold =10;}

											 // 영역설정 
											 if(fabs(LeftOutLine[0].FP0.x - LeftOutLine[0].FP1.x) > 3){
												 LSP.x = (LeftOutLine[0].FP0.x + LeftOutLine[0].FP1.x)/2;
												 LSP.y = 0.0f;
											 }
											 else {
												 LSP = Math.OnIntersect(LeftOutLine[0].FP0, LeftOutLine[0].FP1, LT, RT);
											 }

											 SingleLine->IRoi->SetOrgX  ((int)LSP.x+3             );
											 SingleLine->IRoi->SetOrgY  (0                        );
											 SingleLine->IRoi->SetWidth (100                      );
											 SingleLine->IRoi->SetHeight(FEndLine-CSideCircleHeight);
											 SingleLine->SetIncrement( 1);

											 if(((LSP.x+3)<=0) || ImgH<=0) return false;

											 // 									 if(IRoi->GetHeight()<300) SingleLine->SetIncrement(5 );
											 // 									 else                      SingleLine->SetIncrement(10);

											 // Left Track Line Search 
											 SingleLine->SetFindLineId(0);
											 SingleLine->SetOrientation(orWest);
											 SingleLine->SetEdgeType(1); // White To Black  
											 SingleLine->OnExecute();
											 LeftTrackLine[0].FP0 = SingleLine->GetResultP0();
											 LeftTrackLine[0].FP1 = SingleLine->GetResultP1();

											 if(fabs(LeftTrackLine[0].FP0.x - LeftTrackLine[0].FP1.x)>=0.5){
												 LeftTrackLine[0].FP0.x = (LeftTrackLine[0].FP0.x+LeftTrackLine[0].FP1.x)/2.0;
												 LeftTrackLine[0].FP1.x = (LeftTrackLine[0].FP0.x+LeftTrackLine[0].FP1.x)/2.0;
											 }

											 SingleLine->SetEdgeType(2); // Line Search Type Normal 

											 // LeftTrackLine....Make OutLine Data 
											 // 현재의 데이터를 넘겨준다 
											 // 검사중 기준라인을 찾지 못할경우 이전데이터 넘겨줘서 기준라인 생성함 
											 if(LeftTrackLine[0].FP0.x!=0.0f && LeftTrackLine[0].FP0.y!=0.0f && LeftTrackLine[0].FP1.x!=0.0f && LeftTrackLine[0].FP1.y!=0.0f){
												 PreLeftTrackLine[0].FP0.x = LeftTrackLine[0].FP0.x;    PreLeftTrackLine[0].FP1.x = LeftTrackLine[0].FP1.x;       
												 PreLeftTrackLine[0].FP0.y = LeftTrackLine[0].FP0.y;    PreLeftTrackLine[0].FP1.y = LeftTrackLine[0].FP1.y;       
											 } // 셀의 상단 시작부터 Broken 발생으로 데이터가 없는경우 
											 else if(LeftTrackLine[0].FP0.x==0.0f || LeftTrackLine[0].FP0.y==0.0f || LeftTrackLine[0].FP1.x==0.0f || LeftTrackLine[0].FP1.y==0.0f){
												 if(PreLeftTrackLine[0].FP0.x==0.0f && PreLeftTrackLine[0].FP0.y==0.0f && PreLeftTrackLine[0].FP1.x==0.0f && PreLeftTrackLine[0].FP1.y==0.0f){// 시작부분 Broken발생으로 데이터가 없는경우 
													 // Mark좌표를 기준으로 라인좌표값을 다시 설정함 
													 ROI_H = IRoi->GetHeight();
													 ROI_L = IRoi->GetOrgX()  ;
													 LeftTrackLine[0].FP0.x = ROI_L;    LeftTrackLine[0].FP0.y = 0.0f        ;
													 LeftTrackLine[0].FP1.x = ROI_L;    LeftTrackLine[0].FP1.y = (float)ROI_H;

													 //LeftTrackLine 데이터를 PreLeftTrackLine에 넘겨준다 
													 PreLeftTrackLine[0].FP0.x = LeftTrackLine[0].FP0.x;    PreLeftTrackLine[0].FP1.x = LeftTrackLine[0].FP1.x;       
													 PreLeftTrackLine[0].FP0.y = LeftTrackLine[0].FP0.y;    PreLeftTrackLine[0].FP1.y = LeftTrackLine[0].FP1.y;       
												 }
												 else { // 중간부분 Broken발생으로 데이터가 없는경우 
													 // PreLeftTrackLine 데이터를 넘겨줌 
													 LeftTrackLine[0].FP0.x = PreLeftTrackLine[0].FP0.x;  LeftTrackLine[0].FP1.x = PreLeftTrackLine[0].FP1.x;  
													 LeftTrackLine[0].FP0.y = PreLeftTrackLine[0].FP0.y;  LeftTrackLine[0].FP1.y = PreLeftTrackLine[0].FP1.y;  
												 }
											 }

											 // 마크라인에서 부터 LeftTrackLine 까지 거리 산출 
											 // LeftTrackLine Data 존재할 경우 거리 측정함 
											 // Image Rotate 있음 
											 // 외곽라인 기준 EnCap에 필요한 데이터 생성 
											 if(LeftTrackLine[0].FP0.x!=0.0f && LeftTrackLine[0].FP0.y!=0.0f && LeftTrackLine[0].FP1.x!=0.0f && LeftTrackLine[0].FP1.y!=0.0f){
												 if(LeftOutLine[0].FP0.x!=0.0f && LeftOutLine[0].FP0.y!=0.0f && LeftOutLine[0].FP1.x!=0.0f && LeftOutLine[0].FP1.y!=0.0f){
													 LeftToTrackLineDis1 = Math.GetLengthFrLineToPoint(LeftOutLine[0].FP0, LeftOutLine[0].FP1, LeftTrackLine[0].FP0);//외곽라인에서 TrackLine거리 
													 LeftToTrackLineDis2 = Math.GetLengthFrLineToPoint(LeftOutLine[0].FP0, LeftOutLine[0].FP1, LeftTrackLine[0].FP1);//외곽라인에서 TrackLine거리 

													 TotalLeftTrackDis  +=  (int)((LeftToTrackLineDis1 + LeftToTrackLineDis2)/2.0); //Mark라인에서 TrackLine거리 누적                   
													 LeftTrackLineCount++; //누적 카운트 증가
												 }
											 }
										 }
									 }
									 else {  //LeftTrackLine Data Overlap
										 // LeftTrackLine Data Overlap 
										 if(AvgLeftTrackLineDis!=0){
											 if(FInspectMode==Insp_Track){ // Mark기준 
												 if(LeftOutLine[0].FP0.x!=0.0f && LeftOutLine[0].FP0.y!=0.0f && LeftOutLine[0].FP1.x!=0.0f && LeftOutLine[0].FP1.y!=0.0f){
													 // TOP영역 LeftTrackLine x좌표 
													 LeftTrackLine[0].FP0.x = LeftOutLine[0].FP0.x+AvgLeftTrackLineDis;
													 LeftTrackLine[0].FP1.x = LeftOutLine[0].FP1.x+AvgLeftTrackLineDis;

													 // TOP영역 LeftTrackLine y좌표 
													 LeftTrackLine[0].FP0.y = LeftOutLine[0].FP0.y;
													 LeftTrackLine[0].FP1.y = LeftOutLine[0].FP1.y;
												 }
											 }
										 }
									 }
								 }
							 }
							 if(FRightWall){ // Image Rotate 적용 
								 EasyImage::Threshold(&RotateImg,&RotateBinaryImg, RightEdgeThresHold);
								 if(RightEdgeThresHold==0) {SingleLine->GImage = &RotateImg      ;  SingleLine->FThreshold =5 ;}
								 else                      {SingleLine->GImage = &RotateBinaryImg;  SingleLine->FThreshold =10;}

								 SingleLine->IRoi->SetOrgX  (IRoi->GetOrgX()           );
								 SingleLine->IRoi->SetOrgY  (IRoi->GetOrgY()           );
								 SingleLine->IRoi->SetWidth (IRoi->GetWidth()          );
								 // ChamberCut VS Circle VS Rect경우에 따라서 Left영역 Fitting구간 높이가 달라짐 
								 if(IsCornerBtm) SingleLine->IRoi->SetHeight(FEndLine-RBCornerHeight   );
								 else            SingleLine->IRoi->SetHeight(FEndLine-CSideCircleHeight);
								 SingleLine->SetIncrement(5 );

								 int OrgX  = IRoi->GetOrgX();
								 int OrgY  = IRoi->GetOrgX();
								 int Width = IRoi->GetOrgX();
								 int Height= IRoi->GetOrgX();

								 SingleLine->SetOrientation(orEast);
// 								 if(IRoi->GetHeight()<350) SingleLine->SetIncrement(5 );
// 								 else                      SingleLine->SetIncrement(10);

								 SingleLine->SetFindLineId(0);
								 SingleLine->FThreshold =10;
// 								 SingleLine->SetEdgeType(0);  //Black To White  

								 // TEST 
								 if(IsMarkBtm) SingleLine->SetEdgeType(0); // Black to White 
								 else          SingleLine->SetEdgeType(1); // White to Black  

								 SingleLine->OnExecute();
								 Line[2].FP0 = SingleLine->GetResultP0();
								 Line[2].FP1 = SingleLine->GetResultP1();

								 if((fabs(Line[2].FP0.x - Line[2].FP1.x)>2) && (Line[2].FP1.x <Line[2].FP0.x)) Line[2].FP1.x = Line[2].FP0.x;

								 // Btm,Top 상관없이 첫번째
								 RightOutLine[0].FP0.x = Line[2].FP0.x;
								 RightOutLine[0].FP0.y = Line[2].FP0.y;
								 RightOutLine[0].FP1.x = Line[2].FP1.x;
								 RightOutLine[0].FP1.y = Line[2].FP1.y;

								 if(fabs(RightOutLine[0].FP0.x - RightOutLine[0].FP1.x)>=0.5){
									 RightOutLine[0].FP0.x = (RightOutLine[0].FP0.x+RightOutLine[0].FP1.x)/2.0;
									 RightOutLine[0].FP1.x = (RightOutLine[0].FP0.x+RightOutLine[0].FP1.x)/2.0;
								 }

								 // LeftOutLine....make OutLine Data 
								 // 현재의 데이터를 넘겨준다 
								 // 검사중 기준라인을 찾지 못할경우 이전데이터 넘겨줘서 기준라인 생성함 
								 if(RightOutLine[0].FP0.x!=0.0f && RightOutLine[0].FP0.y!=0.0f && RightOutLine[0].FP1.x!=0.0f && RightOutLine[0].FP1.y!=0.0f){
									 PreRightOutLine[0].FP0.x = RightOutLine[0].FP0.x;    PreRightOutLine[0].FP1.x = RightOutLine[0].FP1.x;       
									 PreRightOutLine[0].FP0.y = RightOutLine[0].FP0.y;    PreRightOutLine[0].FP1.y = RightOutLine[0].FP1.y;       
								 } // 셀의 상단 시작부터 Broken 발생으로 데이터가 없는경우 
								 else if(RightOutLine[0].FP0.x==0.0f || RightOutLine[0].FP0.y==0.0f || RightOutLine[0].FP1.x==0.0f || RightOutLine[0].FP1.y==0.0f){
									 if(PreRightOutLine[0].FP0.x==0.0f && PreRightOutLine[0].FP0.y==0.0f && PreRightOutLine[0].FP1.x==0.0f && PreRightOutLine[0].FP1.y==0.0f){// 시작부분 Broken발생으로 데이터가 없는경우 
										 // Mark좌표를 기준으로 라인좌표값을 다시 설정함 
										 ROI_H = IRoi->GetHeight();
										 RightOutLine[0].FP0.x = Line[2].FP0.x;    RightOutLine[0].FP0.y = 0.0f        ;
										 RightOutLine[0].FP1.x = Line[2].FP1.x;    RightOutLine[0].FP1.y = (float)ROI_H;

										 //Line 데이터를 PreLine에 넘겨준다 
										 PreRightOutLine[0].FP0.x = RightOutLine[0].FP0.x;    PreRightOutLine[0].FP1.x = RightOutLine[0].FP1.x;       
										 PreRightOutLine[0].FP0.y = RightOutLine[0].FP0.y;    PreRightOutLine[0].FP1.y = RightOutLine[0].FP1.y;       
									 }
									 else { // 중간부분 Broken발생으로 데이터가 없는경우 
										 // PreLine 데이터를 넘겨줌 
										 RightOutLine[0].FP0.x = PreRightOutLine[0].FP0.x;  RightOutLine[0].FP1.x = PreRightOutLine[0].FP1.x;  
										 RightOutLine[0].FP0.y = PreRightOutLine[0].FP0.y;  RightOutLine[0].FP1.y = PreRightOutLine[0].FP1.y;  
									 }
								 }

								 if(IsAllGrind){ 
									 if(IsMarkBtm){ //RightInLine, RightTrackLine Search, Data생성 
										 // RightInLine Search Start 
										 EasyImage::Threshold(&RotateImg,&RotateBinaryImg, RightEdgeThresHold);
										 //RightOutLine기준 RightInLine 검출
										 if(RightEdgeThresHold==0) {SingleLine->GImage = &RotateImg      ;  SingleLine->FThreshold =5 ;}
										 else                      {SingleLine->GImage = &RotateBinaryImg;  SingleLine->FThreshold =10;}

										 // 영역설정 
										 if(fabs(RightOutLine[0].FP0.x - RightOutLine[0].FP1.x) > 3){
											 LSP.x = (RightOutLine[0].FP0.x + RightOutLine[0].FP1.x)/2;
											 LSP.y = 0.0f;
										 }
										 else {
											 LSP = Math.OnIntersect(RightOutLine[0].FP0, RightOutLine[0].FP1, LT, RT);
										 }

										 SingleLine->IRoi->SetOrgX  ((int)LSP.x-100);
										 SingleLine->IRoi->SetOrgY  (0             );
										 SingleLine->IRoi->SetWidth (97            );
										 SingleLine->IRoi->SetHeight(ImgH          );
										 SingleLine->SetIncrement(5 );

										 if(((LSP.x+3)<=0) || ImgH<=0) return false;

// 										 if(IRoi->GetHeight()<300) SingleLine->SetIncrement(5 );
// 										 else                      SingleLine->SetIncrement(10);

										 // 연마량 측정 OutLine
										 SingleLine->SetFindLineId(0);
										 SingleLine->SetOrientation(orEast);
										 SingleLine->SetEdgeType(0); // Black to White 
										 SingleLine->OnExecute();
										 RightInLine[0].FP0 = SingleLine->GetResultP0();
										 RightInLine[0].FP1 = SingleLine->GetResultP1();

										 SingleLine->SetEdgeType(2); // Line Search Org 

										 // RightInLine None....make InLine Data 
										 // 현재의 데이터를 넘겨준다 
										 if(RightInLine[0].FP0.x!=0.0f && RightInLine[0].FP0.y!=0.0f && RightInLine[0].FP1.x!=0.0f && RightInLine[0].FP1.y!=0.0f){
											 PreRightInLine[0].FP0.x = RightInLine[0].FP0.x;    PreRightInLine[0].FP1.x = RightInLine[0].FP1.x;       
											 PreRightInLine[0].FP0.y = RightInLine[0].FP0.y;    PreRightInLine[0].FP1.y = RightInLine[0].FP1.y;       
										 }
										 else if(RightInLine[0].FP0.x==0.0f || RightInLine[0].FP0.y==0.0f || RightInLine[0].FP1.x==0.0f || RightInLine[0].FP1.y==0.0f){
											 if(PreRightInLine[0].FP0.x==0.0f && PreRightInLine[0].FP0.y==0.0f && PreRightInLine[0].FP1.x==0.0f && PreRightInLine[0].FP1.y==0.0f){// 시작부분 Broken발생으로 데이터가 없는경우 
												 // Mark좌표를 기준으로 라인좌표값을 다시 설정함 
												 ROI_H = IRoi->GetHeight();
												 ROI_L = IRoi->GetOrgX()  ;
												 RightInLine[0].FP0.x = ROI_L;   RightInLine[0].FP0.y = 0.0f        ;
												 RightInLine[0].FP1.x = ROI_L;   RightInLine[0].FP1.y = (float)ROI_H;

												 //Line 데이터를 PreLine에 넘겨준다 
												 PreRightInLine[0].FP0.x = RightInLine[0].FP0.x;    PreRightInLine[0].FP1.x = RightInLine[0].FP1.x;       
												 PreRightInLine[0].FP0.y = RightInLine[0].FP0.y;    PreRightInLine[0].FP1.y = RightInLine[0].FP1.y;       
											 }
											 else {                                                                                                    // 중간부분 Broken발생으로 데이터가 없는경우 
												 // PreLine 데이터를 넘겨줌 
												 RightInLine[0].FP0.x = PreRightInLine[0].FP0.x;  RightInLine[0].FP1.x = PreRightInLine[0].FP1.x;  
												 RightInLine[0].FP0.y = PreRightInLine[0].FP0.y;  RightInLine[0].FP1.y = PreRightInLine[0].FP1.y;  
											 }
										 }
										 // NOTCH CELL Btm 검사에서만 연마폭 측정함 
										 Right_Grind_Width =(float)(Math.GetLengthFrLineToPoint (RightOutLine[0].FP0,RightOutLine[0].FP1, RightInLine[0].FP0 ));
										 /////////////////////////////////////////////////////////////////////////////////////////////


										 // Right TrackLine Search 
										 /////////////////////////////////////////////////////////////////////////////////////////////
										 // 									 BinaryImg.SetSize(GImage->GetWidth(), GImage->GetHeight());
										 // 									 EasyImage::Oper(EArithmeticLogicOperation_Copy,GImage,&BinaryImg);
										 EasyImage::Threshold(&RotateImg,&RotateBinaryImg, CirGrindMeaThresHold);
										 //RightInLine기준 RightTrackLine 검출
										 if(CirGrindMeaThresHold==0) {SingleLine->GImage = &RotateImg      ;  SingleLine->FThreshold =5 ;}
										 else                        {SingleLine->GImage = &RotateBinaryImg;  SingleLine->FThreshold =10;}


										 // 영역설정 
										 if(fabs(RightInLine[0].FP0.x - RightInLine[0].FP1.x) > 3){
											 LSP.x = (RightInLine[0].FP0.x + RightInLine[0].FP1.x)/2;
											 LSP.y = 0.0f;
										 }
										 else {
											 LSP = Math.OnIntersect(RightInLine[0].FP0, RightInLine[0].FP1, LT, RT);
										 }

										 SingleLine->IRoi->SetOrgX  ((int)LSP.x-100);
										 SingleLine->IRoi->SetOrgY  (0             );
										 SingleLine->IRoi->SetWidth (97            );
										 SingleLine->IRoi->SetHeight(ImgH          );
										 SingleLine->SetIncrement(5 );

										 if(((LSP.x+3)<=0) || ImgH<=0) return false;

// 										 if(IRoi->GetHeight()<300) SingleLine->SetIncrement(5 );
// 										 else                      SingleLine->SetIncrement(10);

										 // 연마량 측정 OutLine
										 SingleLine->SetFindLineId(0);
										 SingleLine->SetOrientation(orEast);
										 SingleLine->SetEdgeType(1); // White To Black  
										 SingleLine->OnExecute();
										 RightTrackLine[0].FP0 = SingleLine->GetResultP0();
										 RightTrackLine[0].FP1 = SingleLine->GetResultP1();

										 SingleLine->SetEdgeType(2); // Line Search Org 

										 // RightTrackLine....make OutLine Data 
										 // 현재의 데이터를 넘겨준다 
										 // 검사중 기준라인을 찾지 못할경우 이전데이터 넘겨줘서 기준라인 생성함 
										 if(RightTrackLine[0].FP0.x!=0.0f && RightTrackLine[0].FP0.y!=0.0f && RightTrackLine[0].FP1.x!=0.0f && RightTrackLine[0].FP1.y!=0.0f){
											 PreRightTrackLine[0].FP0.x = RightTrackLine[0].FP0.x;    PreRightTrackLine[0].FP1.x = RightTrackLine[0].FP1.x;       
											 PreRightTrackLine[0].FP0.y = RightTrackLine[0].FP0.y;    PreRightTrackLine[0].FP1.y = RightTrackLine[0].FP1.y;       
										 } // 셀의 상단 시작부터 Broken 발생으로 데이터가 없는경우 
										 else if(RightTrackLine[0].FP0.x==0.0f || RightTrackLine[0].FP0.y==0.0f || RightTrackLine[0].FP1.x==0.0f || RightTrackLine[0].FP1.y==0.0f){
											 if(PreRightTrackLine[0].FP0.x==0.0f && PreRightTrackLine[0].FP0.y==0.0f && PreRightTrackLine[0].FP1.x==0.0f && PreRightTrackLine[0].FP1.y==0.0f){// 시작부분 Broken발생으로 데이터가 없는경우 
												 // Mark좌표를 기준으로 라인좌표값을 다시 설정함 
												 ROI_H = IRoi->GetHeight();
												 ROI_L = IRoi->GetOrgX()  ;
												 RightTrackLine[0].FP0.x = ROI_L;    RightTrackLine[0].FP0.y = 0.0f        ;
												 RightTrackLine[0].FP1.x = ROI_L;    RightTrackLine[0].FP1.y = (float)ROI_H;

												 //RightTrackLine 데이터를 PreRightTrackLine에 넘겨준다 
												 PreRightTrackLine[0].FP0.x = RightTrackLine[0].FP0.x;    PreRightTrackLine[0].FP1.x = RightTrackLine[0].FP1.x;       
												 PreRightTrackLine[0].FP0.y = RightTrackLine[0].FP0.y;    PreRightTrackLine[0].FP1.y = RightTrackLine[0].FP1.y;       
											 }
											 else { // 중간부분 Broken발생으로 데이터가 없는경우 
												 // PreRightTrackLine 데이터를 넘겨줌 
												 RightTrackLine[0].FP0.x = PreRightTrackLine[0].FP0.x;  RightTrackLine[0].FP1.x = PreRightTrackLine[0].FP1.x;  
												 RightTrackLine[0].FP0.y = PreRightTrackLine[0].FP0.y;  RightTrackLine[0].FP1.y = PreRightTrackLine[0].FP1.y;  
											 }
										 }
										 // NOTCH CELL Btm 검사에서만 연마폭 측정함 
										 Right_Grind_Mea =(float)(Math.GetLengthFrLineToPoint (RightOutLine[0].FP0,RightOutLine[0].FP1,RightTrackLine[0].FP0));

										 // 마크라인에서 부터 RightTrackLine 까지 거리 산출 
										 // RightTrackLine Data 존재할 경우 거리 측정함 
										 if(RightTrackLine[0].FP0.x!=0.0f && RightTrackLine[0].FP0.y!=0.0f && RightTrackLine[0].FP1.x!=0.0f && RightTrackLine[0].FP1.y!=0.0f){
// 											 RightTrackLine[0].FP0.y = RightTrackLine[0].FP0.y + ImageHeight; //전체 이미지 기준 y좌표
// 											 RightTrackLine[0].FP1.y = RightTrackLine[0].FP1.y + ImageHeight; //전체 이미지 기준 y좌표
// 
// 											 MarkToTrackLineDis1 = Math.GetLengthFrLineToPoint(RightMarkSta, RightMarkEnd, RightTrackLine[0].FP0);//Mark라인에서 TrackLine거리 
// 											 MarkToTrackLineDis2 = Math.GetLengthFrLineToPoint(RightMarkSta, RightMarkEnd, RightTrackLine[0].FP1);//Mark라인에서 TrackLine거리 
// 
// 											 TotalRightTrackDis  +=  (int)((MarkToTrackLineDis1 + MarkToTrackLineDis2)/2.0); //Mark라인에서 TrackLine거리 누적                   
// 											 RightTrackLineCount++; //누적 카운트 증가
// 
// 											 // Org Data 
// 											 RightTrackLine[0].FP0.y = RightTrackLine[0].FP0.y - ImageHeight; //Frame 이미지 기준 y좌표 원복
// 											 RightTrackLine[0].FP1.y = RightTrackLine[0].FP1.y - ImageHeight; //Frame 이미지 기준 y좌표 원복 
										 }
									 }
									 else { //RightInLine Search, RightTrackLine Data Overlap 
										 // RightInLine Search Start 
										 EasyImage::Threshold(&RotateImg,&RotateBinaryImg, RightEdgeThresHold);
										 //RightOutLine기준 RightInLine 검출
										 if(RightEdgeThresHold==0) {SingleLine->GImage = &RotateImg      ;  SingleLine->FThreshold =5 ;}
										 else                      {SingleLine->GImage = &RotateBinaryImg;  SingleLine->FThreshold =10;}

										 // 영역설정 
										 if(fabs(RightOutLine[0].FP0.x - RightOutLine[0].FP1.x) > 3){
											 LSP.x = (RightOutLine[0].FP0.x + RightOutLine[0].FP1.x)/2;
											 LSP.y = 0.0f;
										 }
										 else {
											 LSP = Math.OnIntersect(RightOutLine[0].FP0, RightOutLine[0].FP1, LT, RT);
										 }

										 SingleLine->IRoi->SetOrgX  ((int)LSP.x-100);
										 SingleLine->IRoi->SetOrgY  (0             );
										 SingleLine->IRoi->SetWidth (97            );
										 SingleLine->IRoi->SetHeight(ImgH          );
                                         SingleLine->SetIncrement(5 );

										 if(((LSP.x+3)<=0) || ImgH<=0) return false;

// 										 if(IRoi->GetHeight()<300) SingleLine->SetIncrement(5 );
// 										 else                      SingleLine->SetIncrement(10);

										 // 연마량 측정 OutLine
										 SingleLine->SetFindLineId(0);
										 SingleLine->SetOrientation(orEast);
										 SingleLine->SetEdgeType(0); // Black to White 
										 SingleLine->OnExecute();
										 RightInLine[0].FP0 = SingleLine->GetResultP0();
										 RightInLine[0].FP1 = SingleLine->GetResultP1();

										 SingleLine->SetEdgeType(2); // Line Search Org 

										 // RightInLine None....make InLine Data 
										 // 현재의 데이터를 넘겨준다 
										 if(RightInLine[0].FP0.x!=0.0f && RightInLine[0].FP0.y!=0.0f && RightInLine[0].FP1.x!=0.0f && RightInLine[0].FP1.y!=0.0f){
											 PreRightInLine[0].FP0.x = RightInLine[0].FP0.x;    PreRightInLine[0].FP1.x = RightInLine[0].FP1.x;       
											 PreRightInLine[0].FP0.y = RightInLine[0].FP0.y;    PreRightInLine[0].FP1.y = RightInLine[0].FP1.y;       
										 }
										 else if(RightInLine[0].FP0.x==0.0f || RightInLine[0].FP0.y==0.0f || RightInLine[0].FP1.x==0.0f || RightInLine[0].FP1.y==0.0f){
											 if(PreRightInLine[0].FP0.x==0.0f && PreRightInLine[0].FP0.y==0.0f && PreRightInLine[0].FP1.x==0.0f && PreRightInLine[0].FP1.y==0.0f){// 시작부분 Broken발생으로 데이터가 없는경우 
												 // Mark좌표를 기준으로 라인좌표값을 다시 설정함 
												 ROI_H = IRoi->GetHeight();
												 ROI_L = IRoi->GetOrgX()  ;
												 RightInLine[0].FP0.x = ROI_L;   RightInLine[0].FP0.y = 0.0f        ;
												 RightInLine[0].FP1.x = ROI_L;   RightInLine[0].FP1.y = (float)ROI_H;

												 //Line 데이터를 PreLine에 넘겨준다 
												 PreRightInLine[0].FP0.x = RightInLine[0].FP0.x;    PreRightInLine[0].FP1.x = RightInLine[0].FP1.x;       
												 PreRightInLine[0].FP0.y = RightInLine[0].FP0.y;    PreRightInLine[0].FP1.y = RightInLine[0].FP1.y;       
											 }
											 else {                                                                                                    // 중간부분 Broken발생으로 데이터가 없는경우 
												 // PreLine 데이터를 넘겨줌 
												 RightInLine[0].FP0.x = PreRightInLine[0].FP0.x;  RightInLine[0].FP1.x = PreRightInLine[0].FP1.x;  
												 RightInLine[0].FP0.y = PreRightInLine[0].FP0.y;  RightInLine[0].FP1.y = PreRightInLine[0].FP1.y;  
											 }
										 }
										 // NOTCH CELL Btm 검사에서만 연마폭 측정함 
										 Right_Grind_Width =(float)(Math.GetLengthFrLineToPoint (RightOutLine[0].FP0,RightOutLine[0].FP1, RightInLine[0].FP0 ));
										 /////////////////////////////////////////////////////////////////////////////////////////////

										 // RightTrackLine Data Overlap
										 if(AvgRightTrackLineDis!=0){
// 											 RightOutLine[0].FP0.y = RightOutLine[0].FP0.y + ImageHeight; //전체 이미지 기준 y좌표
// 											 RightOutLine[0].FP1.y = RightOutLine[0].FP1.y + ImageHeight; //전체 이미지 기준 y좌표
// 
// 											 MarkToTrackLineDis1 = Math.GetLengthFrLineToPoint(RightMarkSta, RightMarkEnd, RightOutLine[0].FP0);//Mark라인에서 OutLine까지 거리 
// 											 MarkToTrackLineDis2 = Math.GetLengthFrLineToPoint(RightMarkSta, RightMarkEnd, RightOutLine[0].FP1);//Mark라인에서 OutLine까지 거리 
// 
// 											 if(MarkToTrackLineDis1>AvgRightTrackLineDis) RightTrackLine[0].FP0.x = RightOutLine[0].FP0.x-(MarkToTrackLineDis1 - AvgRightTrackLineDis);
// 											 if(MarkToTrackLineDis2>AvgRightTrackLineDis) RightTrackLine[0].FP1.x = RightOutLine[0].FP1.x-(MarkToTrackLineDis2 - AvgRightTrackLineDis);
// 
// 											 // RightOutLine Data 원본 
// 											 RightOutLine[0].FP0.y = RightOutLine[0].FP0.y - ImageHeight; 
// 											 RightOutLine[0].FP1.y = RightOutLine[0].FP1.y - ImageHeight; 
// 
// 											 RightTrackLine[0].FP0.y = RightOutLine[0].FP0.y;
// 											 RightTrackLine[0].FP1.y = RightOutLine[0].FP1.y;
										 }
									 }
								 }
								 else {
									 if(IsMarkBtm){ //RightTrackLine Search,Data생성 
										 if(FInspectMode==Insp_Track){
											 // Right TrackLine Search 
											 /////////////////////////////////////////////////////////////////////////////////////////////
											 // 									 BinaryImg.SetSize(GImage->GetWidth(), GImage->GetHeight());
											 // 									 EasyImage::Oper(EArithmeticLogicOperation_Copy,GImage,&BinaryImg);
											 EasyImage::Threshold(&RotateImg,&RotateBinaryImg, CirGrindMeaThresHold);
											 //RightInLine기준 RightTrackLine 검출
											 if(CirGrindMeaThresHold==0) {SingleLine->GImage = &RotateImg      ;  SingleLine->FThreshold =5 ;}
											 else                        {SingleLine->GImage = &RotateBinaryImg;  SingleLine->FThreshold =10;}

											 // 영역설정 
											 if(fabs(RightOutLine[0].FP0.x - RightOutLine[0].FP1.x) > 3){
												 LSP.x = (RightOutLine[0].FP0.x + RightOutLine[0].FP1.x)/2;
												 LSP.y = 0.0f;
											 }
											 else {
												 LSP = Math.OnIntersect(RightOutLine[0].FP0, RightOutLine[0].FP1, LT, RT);
											 }

											 SingleLine->IRoi->SetOrgX  ((int)LSP.x-50            );
											 SingleLine->IRoi->SetOrgY  (0                        );
											 SingleLine->IRoi->SetWidth (47                       );
											 SingleLine->IRoi->SetHeight(FEndLine-CSideCircleHeight);
											 SingleLine->SetIncrement(1 );

											 if(((LSP.x+3)<=0) || ImgH<=0) return false;

											 // 										 if(IRoi->GetHeight()<300) SingleLine->SetIncrement(5 );
											 // 										 else                      SingleLine->SetIncrement(10);

											 // 연마량 측정 OutLine
											 SingleLine->SetFindLineId(0);
											 SingleLine->SetOrientation(orEast);
											 SingleLine->SetEdgeType(1); // White To Black  
											 SingleLine->OnExecute();
											 RightTrackLine[0].FP0 = SingleLine->GetResultP0();
											 RightTrackLine[0].FP1 = SingleLine->GetResultP1();

											 if(fabs(RightTrackLine[0].FP0.x - RightTrackLine[0].FP1.x)>=0.5){
												 RightTrackLine[0].FP0.x = (RightTrackLine[0].FP0.x+RightTrackLine[0].FP1.x)/2.0;
												 RightTrackLine[0].FP1.x = (RightTrackLine[0].FP0.x+RightTrackLine[0].FP1.x)/2.0;
											 }


											 SingleLine->SetEdgeType(2); // Line Search Org 

											 // RightTrackLine....make OutLine Data 
											 // 현재의 데이터를 넘겨준다 
											 // 검사중 기준라인을 찾지 못할경우 이전데이터 넘겨줘서 기준라인 생성함 
											 if(RightTrackLine[0].FP0.x!=0.0f && RightTrackLine[0].FP0.y!=0.0f && RightTrackLine[0].FP1.x!=0.0f && RightTrackLine[0].FP1.y!=0.0f){
												 PreRightTrackLine[0].FP0.x = RightTrackLine[0].FP0.x;    PreRightTrackLine[0].FP1.x = RightTrackLine[0].FP1.x;       
												 PreRightTrackLine[0].FP0.y = RightTrackLine[0].FP0.y;    PreRightTrackLine[0].FP1.y = RightTrackLine[0].FP1.y;       
											 } // 셀의 상단 시작부터 Broken 발생으로 데이터가 없는경우 
											 else if(RightTrackLine[0].FP0.x==0.0f || RightTrackLine[0].FP0.y==0.0f || RightTrackLine[0].FP1.x==0.0f || RightTrackLine[0].FP1.y==0.0f){
												 if(PreRightTrackLine[0].FP0.x==0.0f && PreRightTrackLine[0].FP0.y==0.0f && PreRightTrackLine[0].FP1.x==0.0f && PreRightTrackLine[0].FP1.y==0.0f){// 시작부분 Broken발생으로 데이터가 없는경우 
													 // Mark좌표를 기준으로 라인좌표값을 다시 설정함 
													 ROI_H = IRoi->GetHeight();
													 ROI_L = IRoi->GetOrgX()  ;
													 RightTrackLine[0].FP0.x = ROI_L;    RightTrackLine[0].FP0.y = 0.0f        ;
													 RightTrackLine[0].FP1.x = ROI_L;    RightTrackLine[0].FP1.y = (float)ROI_H;

													 //RightTrackLine 데이터를 PreRightTrackLine에 넘겨준다 
													 PreRightTrackLine[0].FP0.x = RightTrackLine[0].FP0.x;    PreRightTrackLine[0].FP1.x = RightTrackLine[0].FP1.x;       
													 PreRightTrackLine[0].FP0.y = RightTrackLine[0].FP0.y;    PreRightTrackLine[0].FP1.y = RightTrackLine[0].FP1.y;       
												 }
												 else { // 중간부분 Broken발생으로 데이터가 없는경우 
													 // PreRightTrackLine 데이터를 넘겨줌 
													 RightTrackLine[0].FP0.x = PreRightTrackLine[0].FP0.x;  RightTrackLine[0].FP1.x = PreRightTrackLine[0].FP1.x;  
													 RightTrackLine[0].FP0.y = PreRightTrackLine[0].FP0.y;  RightTrackLine[0].FP1.y = PreRightTrackLine[0].FP1.y;  
												 }
											 }

											 // 마크라인에서 부터 RightTrackLine 까지 거리 산출 
											 // RightTrackLine Data 존재할 경우 거리 측정함 
											 // Image Rotate 있음 
											 if(RightTrackLine[0].FP0.x!=0.0f && RightTrackLine[0].FP0.y!=0.0f && RightTrackLine[0].FP1.x!=0.0f && RightTrackLine[0].FP1.y!=0.0f){ // Mark기준 
												 if(RightOutLine[0].FP0.x!=0.0f && RightOutLine[0].FP0.y!=0.0f && RightOutLine[0].FP1.x!=0.0f && RightOutLine[0].FP1.y!=0.0f){
													 RightToTrackLineDis1 = Math.GetLengthFrLineToPoint(RightOutLine[0].FP0, RightOutLine[0].FP1, RightTrackLine[0].FP0);//외곽라인에서 TrackLine거리 
													 RightToTrackLineDis2 = Math.GetLengthFrLineToPoint(RightOutLine[0].FP0, RightOutLine[0].FP1, RightTrackLine[0].FP1);//외곽라인에서 TrackLine거리 

													 TotalRightTrackDis  +=  (int)((RightToTrackLineDis1 + RightToTrackLineDis2)/2.0); //Mark라인에서 TrackLine거리 누적                   
													 RightTrackLineCount++; //누적 카운트 증가
												 }
											 }
										 }
									 }
									 else { //RightTrackLine Data Overlap
										 if(AvgRightTrackLineDis!=0){
											 if(FInspectMode==Insp_Track){ //Mark기준 
												 if(RightOutLine[0].FP0.x!=0.0f && RightOutLine[0].FP0.y!=0.0f && RightOutLine[0].FP1.x!=0.0f && RightOutLine[0].FP1.y!=0.0f){
													 // TOP영역 LeftTrackLine x좌표 
													 RightTrackLine[0].FP0.x = RightOutLine[0].FP0.x - AvgRightTrackLineDis;
													 RightTrackLine[0].FP1.x = RightOutLine[0].FP1.x - AvgRightTrackLineDis;

													 // TOP영역 LeftTrackLine y좌표 
													 RightTrackLine[0].FP0.y = RightOutLine[0].FP0.y;
													 RightTrackLine[0].FP1.y = RightOutLine[0].FP1.y;
												 }
											 }
										 }
									 }
								 }
							 }
							 if(FBottomWall ){
								 EasyImage::Threshold(&RotateImg,&RotateBinaryImg, BtmEdgeThresHold);
								 if(BtmEdgeThresHold==0)    {SingleLine->GImage = &RotateImg      ;  SingleLine->FThreshold =5 ;}
								 else                       {SingleLine->GImage = &RotateBinaryImg;  SingleLine->FThreshold =10;}

								 SingleLine->IRoi->SetOrgX  (IRoi->GetOrgX());
								 SingleLine->IRoi->SetOrgY  (FEndLine-100   );
								 SingleLine->IRoi->SetWidth (IRoi->GetWidth());
								 SingleLine->IRoi->SetHeight(200             );

								 SingleLine->SetOrientation(orSouth);
								 SingleLine->FIncrement =20;
								 SingleLine->SetFindLineId(0);
								 SingleLine->FThreshold =5;

								 if(IsMarkBtm) SingleLine->SetEdgeType(1);  //White To Black
								 else          SingleLine->SetEdgeType(1);  //White To Black

								 SingleLine->OnExecute();
// 								 Line[waBottomWall].FP0 = SingleLine->GetResultP0();
// 								 Line[waBottomWall].FP1 = SingleLine->GetResultP1();
								 Line[3].FP0 = SingleLine->GetResultP0();
								 Line[3].FP1 = SingleLine->GetResultP1();

								 // Image Roate 후 기준 데이터 다시 산출 
								 FLBPoint = Math.OnIntersect(LeftOutLine [0].FP0 , LeftOutLine [0].FP1 , Line[3].FP0, Line[3].FP1);
								 FRBPoint = Math.OnIntersect(RightOutLine[0].FP0 , RightOutLine[0].FP1 , Line[3].FP0, Line[3].FP1);


								 // Btm TrackLine Search Only LTCell ==> Btm 검사시 
								 if(IsMarkBtm && IsCircleBtm && FInspectMode==Insp_Track){

									 EasyImage::Threshold(&RotateImg,&RotateBinaryImg, CirGrindMeaThresHold);
									 if(CirGrindMeaThresHold==0) {SingleLine->GImage = &RotateImg      ;  SingleLine->FThreshold =5 ;}
									 else                        {SingleLine->GImage = &RotateBinaryImg;  SingleLine->FThreshold =10;}

									 SingleLine->IRoi->SetOrgX  (IRoi->GetOrgX());
									 SingleLine->IRoi->SetOrgY  (FEndLine-100   );
									 SingleLine->IRoi->SetWidth (IRoi->GetWidth());
									 SingleLine->IRoi->SetHeight(200             );

// 									 SingleLine->IRoi->SetOrgX  (FLBPoint.x+CSideCircleWidth                               );
// 									 SingleLine->IRoi->SetOrgY  (FEndLine-100                                             );
// 									 SingleLine->IRoi->SetWidth ((FRBPoint.x-CSideCircleWidth)-(FLBPoint.x+CSideCircleWidth));
// 									 SingleLine->IRoi->SetHeight(200                                                      );

									 if((FEndLine-100<=0)|| (FEndLine-100>=ImgW)) return false;

									 SingleLine->SetOrientation(orSouth);
									 SingleLine->FIncrement =50;
									 SingleLine->SetFindLineId(0);
									 SingleLine->FThreshold =5;

									 SingleLine->SetEdgeType(1);  //White To Black 

									 SingleLine->OnExecute();
									 BtmTrackLine[0].FP0 = SingleLine->GetResultP0();
									 BtmTrackLine[0].FP1 = SingleLine->GetResultP1();

									 if(fabs(BtmTrackLine[0].FP0.y - BtmTrackLine[0].FP1.y)>=1){
										 BtmTrackLine[0].FP0.y = (BtmTrackLine[0].FP0.y+BtmTrackLine[0].FP1.y)/2.0;
										 BtmTrackLine[0].FP1.y = (BtmTrackLine[0].FP0.y+BtmTrackLine[0].FP1.y)/2.0;
									 }

									 // TrackLine CrossPoint Calculate (Org Data)
									 FTRLBPoint = Math.OnIntersect(LeftTrackLine [0].FP0, LeftTrackLine [0].FP1, BtmTrackLine[0].FP0 , BtmTrackLine[0].FP1);
									 FTRRBPoint = Math.OnIntersect(RightTrackLine[0].FP0, RightTrackLine[0].FP1, BtmTrackLine[0].FP0 , BtmTrackLine[0].FP1);

									 if(TotalLeftTrackDis!=0  && LeftTrackLineCount!=0){ //LeftTrackLine 거리편차 평균값 
										 AvgLeftTrackLineDis  = (int)(TotalLeftTrackDis/LeftTrackLineCount);
									 }
									 if(TotalRightTrackDis!=0 && RightTrackLineCount!=0){//RightTrackLine 거리편차 평균값 
										 AvgRightTrackLineDis = (int)(TotalRightTrackDis/RightTrackLineCount);
									 }

									 // LeftBtmTrackLine, RightBtmTrackLine Dis Calculate 
									 // TrackLine에서 Mark까지 거리를 개별 계산함 
									 // Image Rotate 있음 
									 if(FInspectMode==Insp_Track){ // 외곽라인 기준 
										 if(BtmTrackLine[0].FP0.x!=0 && BtmTrackLine[0].FP0.y!=0 && BtmTrackLine[0].FP1.x!=0 && BtmTrackLine[0].FP1.y!=0){
											 // 상단에 마크기준으로 거리값을 계산시 이미지 회전으로 인해서 정확성 떨어짐....
											 if(Line[3].FP0.x!=0 && Line[3].FP0.y!=0 && Line[3].FP1.x!=0 && Line[3].FP1.y!=0){
												 AvgLeftBtmTrackLineDis = Math.GetLengthFrLineToPoint(Line[3].FP0, Line[3].FP1, BtmTrackLine[0].FP0);//외곽라인에서 TrackLine거리 
												 AvgRightBtmTrackLineDis= Math.GetLengthFrLineToPoint(Line[3].FP0, Line[3].FP1, BtmTrackLine[0].FP1);//외곽라인에서 TrackLine거리 
											 }
										 }
									 }
								 }
								 else if(!IsMarkBtm && IsCircleBtm && FInspectMode==Insp_Track){ // EnCap Cell 검사시 TrackLine 데이터 만들어 준다 
									 if(AvgLeftBtmTrackLineDis!=0 && AvgRightBtmTrackLineDis!=0){
									     BtmTrackLine[0].FP0.y = Line[3].FP0.y - AvgLeftBtmTrackLineDis ;
										 BtmTrackLine[0].FP1.y = Line[3].FP1.y - AvgRightBtmTrackLineDis;

										 BtmTrackLine[0].FP0.x = Line[3].FP0.x;
										 BtmTrackLine[0].FP1.x = Line[3].FP1.x;
									 }
									 // EnCap영역에 TrackLine 교차점을 LT영역 데이터를 이용하여 가상으로 생성해준다 
									 // Image Rotate 있음 
									 if(LeftTrackLine[0].FP0.x!=0.0f && LeftTrackLine[0].FP0.y!=0.0f && RightTrackLine[0].FP0.x!=0.0f && RightTrackLine[0].FP0.y!=0.0f&&
										 LeftTrackLine[0].FP1.x!=0.0f && LeftTrackLine[0].FP1.y!=0.0f && RightTrackLine[0].FP1.x!=0.0f && RightTrackLine[0].FP1.y!=0.0f){
									     if(BtmTrackLine[0].FP0.x!=0.0f && BtmTrackLine[0].FP0.y!=0.0f && BtmTrackLine[0].FP1.x!=0.0f && BtmTrackLine[0].FP1.y!=0.0f){
										     FTRLBPoint = Math.OnIntersect(LeftTrackLine [0].FP0, LeftTrackLine [0].FP1, BtmTrackLine[0].FP0 , BtmTrackLine[0].FP1);
											 FTRRBPoint = Math.OnIntersect(RightTrackLine[0].FP0, RightTrackLine[0].FP1, BtmTrackLine[0].FP0 , BtmTrackLine[0].FP1);
									     }
									 }
								 }
								 else if(IsCornerBtm){ // Btm영역이 Corner일경우 
									 // 3Point 패턴 기준으로 연마량,가공량 측정 
									 if(GrindRectSpec[1].DvX==0.0f && GrindRectSpec[1].DvY==0.0f){
										 double Dis =0.0f, AvgGrindWidth=0.0f, AvgGrindMea=0.0f, TotalGrindWidth=0.0f, TotalGrindMeasure=0.0f;

										 EasyImage::Threshold(&RotateImg,&RotateBinaryImg, ECThresHold);               // Corner Out GinrdThresHold 
										 EasyImage::Threshold(&RotateImg,&RotateGrindBinaryImg, CorGrindMeaThresHold); // Corner Measure GrindThresHold(3Point)

										 if(ECThresHold==0)    {SingleLine->GImage = &RotateImg      ;  SingleLine->FThreshold =5 ;}
										 else                  {SingleLine->GImage = &RotateBinaryImg;  SingleLine->FThreshold =10;}

										 // LEFTBTM START 
										 ///////////////////////////////////////////////////////////////////////////////////////////////////
										 SingleLine->IRoi->SetOrgX  ((int)FLBPoint.x-10            );
										 SingleLine->IRoi->SetOrgY  ((int)FLBPoint.y-LBCornerHeight);
										 SingleLine->IRoi->SetWidth ((int)LBCornerWidth+20         );
										 SingleLine->IRoi->SetHeight((int)LBCornerHeight           );

										 SingleLine->SetOrientation(orWest);
										 SingleLine->FIncrement =1;
										 SingleLine->FThreshold =15;
										 SingleLine->SetFindLineId(0);
										 SingleLine->SetEdgeType(1);  //White To Black 
										 SingleLine->OnExecute();

										 Line[7].FP0 = SingleLine->GetResultP0();
										 Line[7].FP1 = SingleLine->GetResultP1();

										 // ORG 
										 FLBLPoint = Math.OnIntersect(SingleLine->GetResultP0(), SingleLine->GetResultP1(), Line[waLeftWall].FP0   , Line[waLeftWall].FP1);
										 FLBBPoint = Math.OnIntersect(SingleLine->GetResultP0(), SingleLine->GetResultP1(), Line[waBottomWall ].FP0, Line[waBottomWall ].FP1);

										 if((FLBLPoint.x==0 || FLBLPoint.y==0 || FLBBPoint.x==0 || FLBBPoint.y==0) || (SingleLine->FEdgePointCount <30)){
											 LBDx = 0.0f;
											 LBDy = 0.0f;
											 //화면에 디스플레이 위해서 
											 FLBLPoint.x = FLBPoint.x;
											 FLBLPoint.y = FLBPoint.y;
											 FLBBPoint.x = FLBPoint.x;
											 FLBBPoint.y = FLBPoint.y;
										 }
										 else { 
											 LBDx = Math.GetLengthFrPointToPoint(FLBPoint, FLBBPoint);
											 LBDy = Math.GetLengthFrPointToPoint(FLBPoint, FLBLPoint);

											 // OutLine C3Corner Data 
											 if((SingleLine->FEdgePointCount) - (CornerMargin*2)>0){
												 if(C3Point!=NULL) delete[] C3Point;
												 C3Point  = new TFPoint [(SingleLine->FEdgePointCount) - (CornerMargin*2)];
												 C3EdgeCount = (SingleLine->FEdgePointCount) -(CornerMargin*2);

												 CornerCount =0;  
												 for(int k=CornerMargin; k<((SingleLine->FEdgePointCount)-CornerMargin); k++){
													 if(CornerCount>=MAX_CORNER_POINT) break;
													 C3Point[CornerCount].x = SingleLine->FEdgePoint[k].x;
													 C3Point[CornerCount].y = SingleLine->FEdgePoint[k].y;
													 CornerCount++;
												 }
											 }

											 // Corner 연마 안쪽라인 
											 if(CorGrindInThresHold!=0){
												 EasyImage::Threshold(&RotateImg,&RotateBinaryImg, CorGrindInThresHold);
												 SingleLine->GImage = &RotateBinaryImg;  SingleLine->FThreshold =10;

												 // Corner 기울기 완만하여 Edge찾을 경우 Defect 오버킬 발생함 
												 // 방향을 Top방향에서 다시 엣지를 찾음 (Corner Defect OverKill 감소 목적)
												 if(LBCornerWidth >(LBCornerHeight*1.5)){
													 SingleLine->IRoi->SetOrgX  ((int)FLBPoint.x );
													 SingleLine->IRoi->SetOrgY  ((int)FLBPoint.y - LBCornerHeight    );
													 SingleLine->IRoi->SetWidth ((int)((FLBBPoint.x - FLBPoint.x)+20));
													 SingleLine->IRoi->SetHeight((int)((FLBPoint.y  - FLBLPoint.y)  ));

													 if(FLBPoint.x<=0    || FLBPoint.y - LBCornerHeight<=0    || (FLBBPoint.x - FLBPoint.x )<=0    || ((FLBPoint.y  - FLBLPoint.y)+20)<=0   ) return false;
													 if(FLBPoint.x>=ImgW || FLBPoint.y - LBCornerHeight>=ImgH || (FLBBPoint.x - FLBPoint.x )>=ImgW || ((FLBPoint.y  - FLBLPoint.y)+20)>=ImgH) return false;

													 SingleLine->SetOrientation(orSouth);
													 SingleLine->FIncrement =1;
													 SingleLine->SetFindLineId(0);
													 SingleLine->SetEdgeType(0);  //Black To White 
													 SingleLine->OnExecute();

													 // InLine C3Corner Data 
													 if((SingleLine->FEdgePointCount) - (CornerMargin*2)>0){
														 if(C3InPoint!=NULL) delete[] C3InPoint;
														 C3InPoint  = new TFPoint [(SingleLine->FEdgePointCount) - (CornerMargin*2)];
														 C3InEdgeCount = (SingleLine->FEdgePointCount) -(CornerMargin*2);

														 CornerCount =0;  
														 for(int k=CornerMargin; k<((SingleLine->FEdgePointCount)-CornerMargin); k++){
															 if(CornerCount>=MAX_CORNER_POINT) break;
															 C3InPoint[CornerCount].x = SingleLine->FEdgePoint[k].x;
															 C3InPoint[CornerCount].y = SingleLine->FEdgePoint[k].y;
															 CornerCount++;
														 }
													 }
												 }
												 else {
													 // Corner 연마 안쪽라인 찾는다 
													 SingleLine->SetOrientation(orWest);
													 SingleLine->SetFindLineId(0);
													 SingleLine->SetEdgeType(0);  //Black To White 
													 SingleLine->OnExecute();

													 // InLine C1Corner Data 
													 if((SingleLine->FEdgePointCount) - (CornerMargin*2)>0){
														 if(C3InPoint!=NULL) delete[] C3InPoint;
														 C3InPoint  = new TFPoint [(SingleLine->FEdgePointCount) - (CornerMargin*2)];
														 C3InEdgeCount = (SingleLine->FEdgePointCount) -(CornerMargin*2);

														 CornerCount =0;  
														 for(int k=CornerMargin; k<((SingleLine->FEdgePointCount)-CornerMargin); k++){
															 if(CornerCount>=MAX_CORNER_POINT) break;
															 C3InPoint[CornerCount].x = SingleLine->FEdgePoint[k].x;
															 C3InPoint[CornerCount].y = SingleLine->FEdgePoint[k].y;
															 CornerCount++;
														 }
													 }
												 }

												 //코너 연마안쪽라인 기준 새로운 교차점 생성 
												 FLBLInPoint = Math.OnIntersect(SingleLine->GetResultP0(), SingleLine->GetResultP1(), Line[waLeftWall].FP0   , Line[waLeftWall].FP1);
												 FLBBInPoint = Math.OnIntersect(SingleLine->GetResultP0(), SingleLine->GetResultP1(), Line[waBottomWall ].FP0, Line[waBottomWall ].FP1);

												 //코너 연마폭 
												 Dis =0.0f, AvgGrindWidth=0.0f, AvgGrindMea=0.0f, TotalGrindWidth=0.0f, TotalGrindMeasure=0.0f;
												 for(int k=0; k<C3InEdgeCount; k++){
													 Dis = Math.GetLengthFrLineToPoint(FLBLPoint, FLBBPoint, C3InPoint[k]);
													 TotalGrindWidth+=Dis;
												 }
												 if(C3InEdgeCount!=0){
													 AvgGrindWidth = (TotalGrindWidth/C3InEdgeCount);
													 C3CorGrindWd  = AvgGrindWidth;
												 }
											 }
											 // 코너 연마량 기준 라인을 찾는다 
											 // ROI 영역 설정(3개의 흰색 점선 기준 라인을 찾는다)
											 if(CorGrindMeaThresHold!=0){
												 if(CorGrindMeaThresHold==0){SingleLine->GImage = &RotateImg           ;  SingleLine->FThreshold =5 ;}
												 else                       {SingleLine->GImage = &RotateGrindBinaryImg;  SingleLine->FThreshold =10;}

												 SingleLine->IRoi->SetOrgX  ((int)FLBPoint.x                   );
												 SingleLine->IRoi->SetOrgY  ((int)FLBPoint.y-LBCornerHeight +20);
												 SingleLine->IRoi->SetWidth ((int)LBCornerWidth +50            );
												 SingleLine->IRoi->SetHeight((int)LBCornerHeight               );

												 SingleLine->SetOrientation(orWest);
												 SingleLine->SetFindLineId(0);
												 SingleLine->SetEdgeType(0);  //Black To White 
												 SingleLine->OnExecute();

												 P1 = SingleLine->GetResultP0();
												 P2 = SingleLine->GetResultP1();

												 //코너 연마량 기준 라인과 새로운 교차점 생성 
												 FLBLMeaPoint = Math.OnIntersect(SingleLine->GetResultP0(), SingleLine->GetResultP1(), Line[waLeftWall].FP0   , Line[waLeftWall].FP1);
												 FLBBMeaPoint = Math.OnIntersect(SingleLine->GetResultP0(), SingleLine->GetResultP1(), Line[waBottomWall ].FP0, Line[waBottomWall ].FP1);

												 // C3Corner Grind Measure Stand Data 
												 if((SingleLine->FEdgePointCount)>0){
													 if(C3MeaPoint!=NULL) delete[] C3MeaPoint;
													 C3MeaPoint     = new TFPoint [(SingleLine->FEdgePointCount)];
													 C3MeaEdgeCount = (SingleLine->FEdgePointCount);

													 CornerCount =0;  
													 for(int k=0; k<(SingleLine->FEdgePointCount); k++){
														 if(CornerCount>=MAX_CORNER_POINT) break;
														 C3MeaPoint[CornerCount].x = SingleLine->FEdgePoint[k].x;
														 C3MeaPoint[CornerCount].y = SingleLine->FEdgePoint[k].y;
														 CornerCount++;
													 }
												 }
												 //코너 연마량 계산  
												 Dis =0.0f, AvgGrindMea=0.0f, TotalGrindMeasure=0.0f;
												 for(int k=0; k<C3MeaEdgeCount; k++){
													 Dis = Math.GetLengthFrLineToPoint(FLBLPoint, FLBBPoint, C3MeaPoint[k]);
													 TotalGrindMeasure+=Dis;
												 }
												 if(C3MeaEdgeCount!=0){
													 AvgGrindMea    = (TotalGrindMeasure/C3MeaEdgeCount);
													 C3CorGrindMea  = AvgGrindMea;
												 }
											 }
										 }	
										 // LEFTBTM END 
										 ///////////////////////////////////////////////////////////////////////////////////////////////////


										 // RIGHTBTOM START 
										 ///////////////////////////////////////////////////////////////////////////////////////////////////
										 EasyImage::Threshold(&RotateImg,&RotateBinaryImg, ECThresHold);               // Corner Out GinrdThresHold 
										 EasyImage::Threshold(&RotateImg,&RotateGrindBinaryImg, CorGrindMeaThresHold); // Corner Measure GrindThresHold(3Point)

										 if(ECThresHold==0)    {SingleLine->GImage = &RotateImg      ;  SingleLine->FThreshold =5 ;}
										 else                  {SingleLine->GImage = &RotateBinaryImg;  SingleLine->FThreshold =10;}

										 SingleLine->IRoi->SetOrgX  ((int)FRBPoint.x-RBCornerWidth );
										 SingleLine->IRoi->SetOrgY  ((int)FRBPoint.y-RBCornerHeight);
										 SingleLine->IRoi->SetWidth ((int)RBCornerWidth+10         );
										 SingleLine->IRoi->SetHeight((int)RBCornerHeight           );

										 SingleLine->SetOrientation(orEast);
										 SingleLine->FIncrement =1;
										 SingleLine->FThreshold =15;
										 SingleLine->SetFindLineId(0);
										 SingleLine->SetEdgeType(1);  //White To Black 
										 SingleLine->OnExecute();

										 Line[6].FP0 = SingleLine->GetResultP0();
										 Line[6].FP1 = SingleLine->GetResultP1();

										 // ORG 
										 FRBRPoint = Math.OnIntersect(SingleLine->GetResultP0(), SingleLine->GetResultP1(), Line[waRightWall ].FP0, Line[waRightWall] .FP1);
										 FRBBPoint = Math.OnIntersect(SingleLine->GetResultP0(), SingleLine->GetResultP1(), Line[waBottomWall].FP0, Line[waBottomWall].FP1);

										 if((FRBRPoint.x==0 || FRBRPoint.y==0 || FRBBPoint.x==0 || FRBBPoint.y==0) || (SingleLine->FEdgePointCount <30)){
											 RBDx = 0.0f;
											 RBDy = 0.0f;
											 //화면에 디스플레이 위해서 
											 FRBRPoint.x = FRBPoint.x;
											 FRBRPoint.y = FRBPoint.y;
											 FRBBPoint.x = FRBPoint.x;
											 FRBBPoint.y = FRBPoint.y;
										 }
										 else { 
											 RBDx = Math.GetLengthFrPointToPoint(FRBPoint, FRBBPoint);
											 RBDy = Math.GetLengthFrPointToPoint(FRBPoint, FRBRPoint);

											 // OutLine C4Corner Data 
											 if((SingleLine->FEdgePointCount) - (CornerMargin*2)>0){
												 if(C4Point!=NULL) delete[] C4Point;
												 C4Point  = new TFPoint [(SingleLine->FEdgePointCount) - (CornerMargin*2)];
												 C4EdgeCount = (SingleLine->FEdgePointCount) -(CornerMargin*2);

												 CornerCount =0;  
												 for(int k=CornerMargin; k<((SingleLine->FEdgePointCount)-CornerMargin); k++){
													 if(CornerCount>=MAX_CORNER_POINT) break;
													 C4Point[CornerCount].x = SingleLine->FEdgePoint[k].x;
													 C4Point[CornerCount].y = SingleLine->FEdgePoint[k].y;
													 CornerCount++;
												 }
											 }

											 // Corner 기울기 완만하여 Edge찾을 경우 Defect 오버킬 발생함 
											 // 방향을 Top방향에서 다시 엣지를 찾음 (Corner Defect OverKill 감소 목적)
											 if(CorGrindInThresHold!=0){
												 EasyImage::Threshold(&RotateImg,&RotateBinaryImg, CorGrindInThresHold);
												 SingleLine->GImage = &RotateBinaryImg;  SingleLine->FThreshold =10;

												 if(RBCornerWidth >(RBCornerHeight*1.5)){
													 SingleLine->IRoi->SetOrgX  ((int)FRBBPoint.x                 ) ;
													 SingleLine->IRoi->SetOrgY  ((int)FRBBPoint.y - RBCornerHeight) ;
													 SingleLine->IRoi->SetWidth ((int)(RBCornerWidth+10           ));
													 SingleLine->IRoi->SetHeight((int)(RBCornerHeight             ));

													 if(FRBBPoint.x<=0    || FRBBPoint.y - RBCornerHeight<=0    || RBCornerWidth+10<=0    || RBCornerHeight+10 <=0    ) return false;
													 if(FRBBPoint.x>=ImgW || FRBBPoint.y - RBCornerHeight>=ImgH || RBCornerWidth+10>=ImgW || RBCornerHeight+10 >=ImgH ) return false;

													 SingleLine->SetOrientation(orSouth);
													 SingleLine->FIncrement =1;
													 SingleLine->SetFindLineId(0);
													 SingleLine->SetEdgeType(0);  //Black To White 
													 SingleLine->OnExecute();

													 // InLine C4Corner Data 
													 if((SingleLine->FEdgePointCount) - (CornerMargin*2)>0){
														 if(C4InPoint!=NULL) delete[] C4InPoint;
														 C4InPoint  = new TFPoint [(SingleLine->FEdgePointCount) - (CornerMargin*2)];
														 C4InEdgeCount = (SingleLine->FEdgePointCount) -(CornerMargin*2);

														 CornerCount =0;  
														 for(int k=CornerMargin; k<((SingleLine->FEdgePointCount)-CornerMargin); k++){
															 if(CornerCount>=MAX_CORNER_POINT) break;
															 C4InPoint[CornerCount].x = SingleLine->FEdgePoint[k].x;
															 C4InPoint[CornerCount].y = SingleLine->FEdgePoint[k].y;
															 CornerCount++;
														 }
													 }
												 }
												 else {
													 // Corner 연마 안쪽라인 찾는다 
													 SingleLine->SetOrientation(orEast);
													 SingleLine->SetFindLineId(0);
													 SingleLine->SetEdgeType(0);  //Black To White 
													 SingleLine->OnExecute();

													 // InLine C4Corner Data 
													 if((SingleLine->FEdgePointCount) - (CornerMargin*2)>0){
														 if(C4InPoint!=NULL) delete[] C4InPoint;
														 C4InPoint  = new TFPoint [(SingleLine->FEdgePointCount) - (CornerMargin*2)];
														 C4InEdgeCount = (SingleLine->FEdgePointCount) -(CornerMargin*2);

														 CornerCount =0;  
														 for(int k=CornerMargin; k<((SingleLine->FEdgePointCount)-CornerMargin); k++){
															 if(CornerCount>=MAX_CORNER_POINT) break;
															 C4InPoint[CornerCount].x = SingleLine->FEdgePoint[k].x;
															 C4InPoint[CornerCount].y = SingleLine->FEdgePoint[k].y;
															 CornerCount++;
														 }
													 }
												 }

												 //코너 연마안쪽라인 기준 새로운 교차점 생성 
												 FRBRInPoint = Math.OnIntersect(SingleLine->GetResultP0(), SingleLine->GetResultP1(), Line[waRightWall ].FP0, Line[waRightWall ].FP1);
												 FRBBInPoint = Math.OnIntersect(SingleLine->GetResultP0(), SingleLine->GetResultP1(), Line[waBottomWall].FP0, Line[waBottomWall].FP1);

												 //코너 연마폭 
												 Dis =0.0f, AvgGrindWidth=0.0f, AvgGrindMea=0.0f, TotalGrindWidth=0.0f, TotalGrindMeasure=0.0f;
												 for(int k=0; k<C4InEdgeCount; k++){
													 Dis = Math.GetLengthFrLineToPoint(FLBLPoint, FLBBPoint, C4InPoint[k]);
													 TotalGrindWidth+=Dis;
												 }
												 if(C4InEdgeCount!=0){
													 AvgGrindWidth = (TotalGrindWidth/C4InEdgeCount);
													 C4CorGrindWd  = AvgGrindWidth;
												 }
											 }

											 // 코너 연마량 기준 라인을 찾는다 
											 // ROI 영역 설정(3개의 흰색 점선 기준 라인을 찾는다)
											 if(CorGrindMeaThresHold!=0){
												 if(CorGrindMeaThresHold==0){SingleLine->GImage = &RotateImg           ;  SingleLine->FThreshold =5 ;}
												 else                       {SingleLine->GImage = &RotateGrindBinaryImg;  SingleLine->FThreshold =10;}

												 SingleLine->IRoi->SetOrgX  ((int)FRBPoint.x -RBCornerWidth -20 );
												 SingleLine->IRoi->SetOrgY  ((int)FRBPoint.y -RBCornerHeight +20);
												 SingleLine->IRoi->SetWidth ((int)RBCornerWidth                 );
												 SingleLine->IRoi->SetHeight((int)RBCornerHeight                );

												 SingleLine->SetOrientation(orEast);
												 SingleLine->SetFindLineId(0);
												 SingleLine->SetEdgeType(0);  //Black To White 
												 SingleLine->OnExecute();

												 P1 = SingleLine->GetResultP0();
												 P2 = SingleLine->GetResultP1();

												 //코너 연마량 기준 라인과 새로운 교차점 생성 
												 FRBRMeaPoint = Math.OnIntersect(SingleLine->GetResultP0(), SingleLine->GetResultP1(), Line[waRightWall ].FP0, Line[waRightWall ].FP1);
												 FRBBMeaPoint = Math.OnIntersect(SingleLine->GetResultP0(), SingleLine->GetResultP1(), Line[waBottomWall].FP0, Line[waBottomWall].FP1);

												 // C4Corner Grind Measure Stand Data 
												 if((SingleLine->FEdgePointCount)>0){
													 if(C4MeaPoint!=NULL) delete[] C4MeaPoint;
													 C4MeaPoint     = new TFPoint [(SingleLine->FEdgePointCount)];
													 C4MeaEdgeCount = (SingleLine->FEdgePointCount);

													 CornerCount =0;  
													 for(int k=0; k<(SingleLine->FEdgePointCount); k++){
														 if(CornerCount>=MAX_CORNER_POINT) break;
														 C4MeaPoint[CornerCount].x = SingleLine->FEdgePoint[k].x;
														 C4MeaPoint[CornerCount].y = SingleLine->FEdgePoint[k].y;
														 CornerCount++;
													 }
												 }
												 //코너 연마량 계산  
												 Dis =0.0f, AvgGrindMea=0.0f, TotalGrindMeasure=0.0f;
												 for(int k=0; k<C4MeaEdgeCount; k++){
													 Dis = Math.GetLengthFrLineToPoint(FRBRPoint, FRBBPoint, C4MeaPoint[k]);
													 TotalGrindMeasure+=Dis;
												 }
												 if(C4MeaEdgeCount!=0){
													 AvgGrindMea    = (TotalGrindMeasure/C4MeaEdgeCount);
													 C4CorGrindMea  = AvgGrindMea;
												 }
											 }
										 }	
										 // RightBottom End 
										 ///////////////////////////////////////////////////////////////////////////////////////////////////
									 }
									 else { // GrindMark 기준으로 연마량,가공량 측정 
										 double Dis =0.0f, AvgGrindWidth=0.0f, AvgGrindMea=0.0f, TotalGrindWidth=0.0f, TotalGrindMeasure=0.0f;

										 EasyImage::Threshold(&RotateImg,&RotateBinaryImg, ECThresHold);               // Corner Out GinrdThresHold 
										 EasyImage::Threshold(&RotateImg,&RotateGrindBinaryImg, CorGrindMeaThresHold); // Corner Measure GrindThresHold(3Point)

										 if(ECThresHold==0)    {SingleLine->GImage = &RotateImg      ;  SingleLine->FThreshold =5 ;}
										 else                  {SingleLine->GImage = &RotateBinaryImg;  SingleLine->FThreshold =10;}

										 // LEFTBTM START 
										 ///////////////////////////////////////////////////////////////////////////////////////////////////
										 SingleLine->IRoi->SetOrgX  ((int)FLBPoint.x-10            );
										 SingleLine->IRoi->SetOrgY  ((int)FLBPoint.y-LBCornerHeight);
										 SingleLine->IRoi->SetWidth ((int)LBCornerWidth+20         );
										 SingleLine->IRoi->SetHeight((int)LBCornerHeight           );

										 SingleLine->SetOrientation(orWest);
										 SingleLine->FIncrement =1;
										 SingleLine->FThreshold =15;
										 SingleLine->SetFindLineId(0);
										 SingleLine->SetEdgeType(1);  //White To Black 
										 SingleLine->OnExecute();

										 Line[7].FP0 = SingleLine->GetResultP0();
										 Line[7].FP1 = SingleLine->GetResultP1();

										 // ORG 
										 FLBLPoint = Math.OnIntersect(SingleLine->GetResultP0(), SingleLine->GetResultP1(), Line[waLeftWall].FP0   , Line[waLeftWall].FP1);
										 FLBBPoint = Math.OnIntersect(SingleLine->GetResultP0(), SingleLine->GetResultP1(), Line[waBottomWall ].FP0, Line[waBottomWall ].FP1);

										 if((FLBLPoint.x==0 || FLBLPoint.y==0 || FLBBPoint.x==0 || FLBBPoint.y==0) || (SingleLine->FEdgePointCount <30)){
											 LBDx = 0.0f;
											 LBDy = 0.0f;
											 //화면에 디스플레이 위해서 
											 FLBLPoint.x = FLBPoint.x;
											 FLBLPoint.y = FLBPoint.y;
											 FLBBPoint.x = FLBPoint.x;
											 FLBBPoint.y = FLBPoint.y;
										 }
										 else { 
											 LBDx = Math.GetLengthFrPointToPoint(FLBPoint, FLBBPoint);
											 LBDy = Math.GetLengthFrPointToPoint(FLBPoint, FLBLPoint);

											 // OutLine C3Corner Data 
											 if((SingleLine->FEdgePointCount) - (CornerMargin*2)>0){
												 if(C3Point!=NULL) delete[] C3Point;
												 C3Point  = new TFPoint [(SingleLine->FEdgePointCount) - (CornerMargin*2)];
												 C3EdgeCount = (SingleLine->FEdgePointCount) -(CornerMargin*2);

												 CornerCount =0;  
												 for(int k=CornerMargin; k<((SingleLine->FEdgePointCount)-CornerMargin); k++){
													 if(CornerCount>=MAX_CORNER_POINT) break;
													 C3Point[CornerCount].x = SingleLine->FEdgePoint[k].x;
													 C3Point[CornerCount].y = SingleLine->FEdgePoint[k].y;
													 CornerCount++;
												 }
											 }

											 // Corner 연마 안쪽라인 
											 if(CorGrindInThresHold!=0){
												 EasyImage::Threshold(&RotateImg,&RotateBinaryImg, CorGrindInThresHold);
												 SingleLine->GImage = &RotateBinaryImg;  SingleLine->FThreshold =10;

												 // Corner 기울기 완만하여 Edge찾을 경우 Defect 오버킬 발생함 
												 // 방향을 Top방향에서 다시 엣지를 찾음 (Corner Defect OverKill 감소 목적)
												 if(LBCornerWidth >(LBCornerHeight*1.5)){
													 SingleLine->IRoi->SetOrgX  ((int)FLBPoint.x );
													 SingleLine->IRoi->SetOrgY  ((int)FLBPoint.y - LBCornerHeight    );
													 SingleLine->IRoi->SetWidth ((int)((FLBBPoint.x - FLBPoint.x)+20));
													 SingleLine->IRoi->SetHeight((int)((FLBPoint.y  - FLBLPoint.y)  ));

													 if(FLBPoint.x<=0    || FLBPoint.y - LBCornerHeight<=0    || (FLBBPoint.x - FLBPoint.x )<=0    || ((FLBPoint.y  - FLBLPoint.y)+20)<=0   ) return false;
													 if(FLBPoint.x>=ImgW || FLBPoint.y - LBCornerHeight>=ImgH || (FLBBPoint.x - FLBPoint.x )>=ImgW || ((FLBPoint.y  - FLBLPoint.y)+20)>=ImgH) return false;

													 SingleLine->SetOrientation(orSouth);
													 SingleLine->FIncrement =1;
													 SingleLine->SetFindLineId(0);
													 SingleLine->SetEdgeType(0);  //Black To White 
													 SingleLine->OnExecute();

													 // InLine C3Corner Data 
													 if((SingleLine->FEdgePointCount) - (CornerMargin*2)>0){
														 if(C3InPoint!=NULL) delete[] C3InPoint;
														 C3InPoint  = new TFPoint [(SingleLine->FEdgePointCount) - (CornerMargin*2)];
														 C3InEdgeCount = (SingleLine->FEdgePointCount) -(CornerMargin*2);

														 CornerCount =0;  
														 for(int k=CornerMargin; k<((SingleLine->FEdgePointCount)-CornerMargin); k++){
															 if(CornerCount>=MAX_CORNER_POINT) break;
															 C3InPoint[CornerCount].x = SingleLine->FEdgePoint[k].x;
															 C3InPoint[CornerCount].y = SingleLine->FEdgePoint[k].y;
															 CornerCount++;
														 }
													 }
												 }
												 else {
													 // Corner 연마 안쪽라인 찾는다 
													 SingleLine->SetOrientation(orWest);
													 SingleLine->SetFindLineId(0);
													 SingleLine->SetEdgeType(0);  //Black To White 
													 SingleLine->OnExecute();

													 // InLine C1Corner Data 
													 if((SingleLine->FEdgePointCount) - (CornerMargin*2)>0){
														 if(C3InPoint!=NULL) delete[] C3InPoint;
														 C3InPoint  = new TFPoint [(SingleLine->FEdgePointCount) - (CornerMargin*2)];
														 C3InEdgeCount = (SingleLine->FEdgePointCount) -(CornerMargin*2);

														 CornerCount =0;  
														 for(int k=CornerMargin; k<((SingleLine->FEdgePointCount)-CornerMargin); k++){
															 if(CornerCount>=MAX_CORNER_POINT) break;
															 C3InPoint[CornerCount].x = SingleLine->FEdgePoint[k].x;
															 C3InPoint[CornerCount].y = SingleLine->FEdgePoint[k].y;
															 CornerCount++;
														 }
													 }
												 }

												 //코너 연마안쪽라인 기준 새로운 교차점 생성 
												 FLBLInPoint = Math.OnIntersect(SingleLine->GetResultP0(), SingleLine->GetResultP1(), Line[waLeftWall].FP0   , Line[waLeftWall].FP1);
												 FLBBInPoint = Math.OnIntersect(SingleLine->GetResultP0(), SingleLine->GetResultP1(), Line[waBottomWall ].FP0, Line[waBottomWall ].FP1);
											 }

											 // GrindMark기준 연마량,가공량 측정함 
											 // LeftBtm Corner Mark Find 
											 if(GrindRectSpec[1].DvX!=0.0f && GrindRectSpec[1].DvY!=0.0f){
												 GrindMarkRect[1].left = (FLBPoint.x + GrindRectSpec[1].DvX) -GrindMarkRange;
												 GrindMarkRect[1].top  = (FLBPoint.y - GrindRectSpec[1].DvY) -GrindMarkRange;
												 GrindMarkRect[1].right  = GrindMarkRect[1].left+GrindMarkLength;
												 GrindMarkRect[1].bottom = GrindMarkRect[1].top +GrindMarkLength;

												 // 원본이미지에서 Mark 찾는다 
												 Find->OnLoad(true,FindDir)                     ;
												 Find->GImage = &RotateImg                      ;
												 Find->SetContrastMode(EFindContrastMode_Normal);
												 Find->SetMinScore (GrindPadMarkMinScore)       ; // PatternrFind 검사 최소 Score
												 Find->SetZeroScore(GrindPadMarkMinScore)       ; // 검사 후 최소 Score 
												 Find->SetMaxInstances(1)                       ;
												 Find->SetAngleTolerance(20.0f)                 ;
												 Find->SetAngleBias(45.0f)                      ;
												 Find->SetScaleBias(1.00f)                      ;
												 Find->SetScaleTolerance(0.0f)                  ;
												 Find->Property.Ox = (float)ImgW/2              ;
												 Find->Property.Oy = (float)ImgH/2              ;

												 GrindRectWidth  = (GrindMarkRect[1].right  - GrindMarkRect[1].left);
												 GrindRectHeight = (GrindMarkRect[1].bottom - GrindMarkRect[1].top );
												 Find->IRoi->SetPlacement(GrindMarkRect[1].left,GrindMarkRect[1].top,GrindRectWidth,GrindRectHeight);
												 if(GrindMarkRect[1].left<=0    || GrindMarkRect[1].top<=0    || GrindRectWidth<=0    || GrindRectHeight<=0   ) return false;
												 if(GrindMarkRect[1].left>=ImgW || GrindMarkRect[1].top>=ImgH || GrindRectWidth>=ImgW || GrindRectHeight>=ImgH) return false;

												 // 검사 및 Match Pos 좌표 받어온다 
												 // Find 검사 성공시 데이터 받아옴 
												 if(Find->OnExecute()){
													 GrindMarkPoint[1].x = Find->Result[0].Px;
													 GrindMarkPoint[1].y = Find->Result[0].Py;
													 GrindMarkScore[1]   = Find->Result[0].Score;
												 }
												 // Contrast Gradient Pixel Value
												 GrindMarkGradient[1] = EasyImage::Focusing(Find->IRoi);

												 // Left CellSize 측정 목적 
												 ///////////////////////////////////////////////////////////////////////////////////
												 GrindMarkRect[2].left = (FLBPoint.x + GrindRectSpec[2].DvX) -GrindMarkRange;
												 GrindMarkRect[2].top  = (FLBPoint.y - GrindRectSpec[2].DvY) -GrindMarkRange;
												 GrindMarkRect[2].right  = GrindMarkRect[2].left+GrindMarkLength;
												 GrindMarkRect[2].bottom = GrindMarkRect[2].top +GrindMarkLength;

												 GrindRectWidth  = (GrindMarkRect[2].right  - GrindMarkRect[2].left);
												 GrindRectHeight = (GrindMarkRect[2].bottom - GrindMarkRect[2].top );
												 Find->IRoi->SetPlacement(GrindMarkRect[2].left,GrindMarkRect[2].top,GrindRectWidth,GrindRectHeight);
												 if(GrindMarkRect[2].left<=0    || GrindMarkRect[2].top<=0    || GrindRectWidth<=0    || GrindRectHeight<=0   ) return false;
												 if(GrindMarkRect[2].left>=ImgW || GrindMarkRect[2].top>=ImgH || GrindRectWidth>=ImgW || GrindRectHeight>=ImgH) return false;

												 // 검사 및 Match Pos 좌표 받어온다 
												 // Find 검사 성공시 데이터 받아옴 
												 Find->SetAngleBias(0.0f);
												 if(Find->OnExecute()){
													 GrindMarkPoint[2].x = Find->Result[0].Px;
													 GrindMarkPoint[2].y = Find->Result[0].Py;
													 GrindMarkScore[2]   = Find->Result[0].Score;

													 // Chamber CUt 기준 Cell Size 측정 
													 if(Line[3].FP0.x!=0.0f && Line[3].FP0.y!=0.0f && Line[3].FP1.x!=0.0f && Line[3].FP1.y!=0.0f){
														 BtmGrindMeasure1 = Math.GetLengthFrLineToPoint(Line[3].FP0, Line[3].FP1, GrindMarkPoint[2]);
													 }
												 }
												 ///////////////////////////////////////////////////////////////////////////////////
											 }

											 // GrindMakr찾을경우 연마량,가공량 측정함
											 if(GrindMarkPoint[1].x!=0.0f && GrindMarkPoint[1].y!=0.0f){
												 // GrindMark기준 OutData 최단거리 Count정보 Calc 
												 GrindMeaDis =0.0f, MinDis =10000.0f; GrindMarkOutCnt=0;
												 for(int k=0; k<C3EdgeCount; k++){
													 if(C3Point[k].x  ==0.0f       || C3Point[k].y       ==0.0f) continue;
													 if(GrindMarkPoint[1].x==0.0f  || GrindMarkPoint[1].y==0.0f) continue;

													 GrindMeaDis = Math.GetLength(GrindMarkPoint[1], C3Point[k]);
													 if(GrindMeaDis<MinDis){
														 MinDis = GrindMeaDis;
														 GrindMarkOutCnt = k;
													 }
												 }
												 // OutData기준 InData 최단거리 Count정보 Calc 
												 if(GrindMarkOutCnt!=0){
													 GrindMeaDis =0.0f, MinDis =10000.0f; GrindMarkInCnt=0;
													 for(int k=0; k<C3InEdgeCount; k++){
														 if(C3InPoint[k].x   ==0.0f          || C3InPoint[k].y             ==0.0f) continue;
														 if(C3Point[GrindMarkOutCnt].x==0.0f || C3Point[GrindMarkOutCnt].y ==0.0f) continue;

														 GrindMeaDis = Math.GetLength(C3Point[GrindMarkOutCnt], C3InPoint[k]);
														 if(GrindMeaDis<MinDis){
															 MinDis = GrindMeaDis;
															 GrindMarkInCnt = k;
														 }
													 }
												 }

												 // GrindMark기준 수직 포인트 주변값 Avg산출한다 ==>가공량 측정(OutData기준)
												 if(GrindMarkOutCnt!=0 && GrindMarkOutCnt>5){
													 CircleCount=0,TotalCirDis=0.0f,GrindMeaDis=0.0f;
													 for(int k=GrindMarkOutCnt-5; k<GrindMarkOutCnt+5; k++){
														 if(C3Point[k].x==0.0f || C3Point[k].y==0.0f) continue;
														 if(k>=C3EdgeCount                          ) continue;
 
														 GrindMeaDis = Math.GetLength(GrindMarkPoint[1], C3Point[k]);
														 TotalCirDis+= GrindMeaDis;
														 CircleCount++;
													 }
													 if(TotalCirDis!=0.0f && CircleCount!=0){
														 C3CorGrindMea = TotalCirDis/CircleCount;
													 }
												 }

												 // GrindMark기준 수직 포인트 주변값 Avg산출한다 ==>연마량 측정(OutData,InData기준)
												 if((GrindMarkOutCnt!=0 && GrindMarkOutCnt>5) && (GrindMarkInCnt!=0 && GrindMarkInCnt>5)){
													 CircleCount=0,TotalCirDis=0.0f,GrindWidthDis=0.0f;
													 for(int k=-5; k<5; k++){
														 if(C3Point  [GrindMarkOutCnt+k].x==0.0f && C3Point  [GrindMarkOutCnt+k].y==0.0f) continue;
														 if(C3InPoint[GrindMarkInCnt +k].x==0.0f && C3InPoint[GrindMarkInCnt +k].y==0.0f) continue;
														 if((GrindMarkOutCnt+k)>=C3EdgeCount                                            ) continue;
														 if((GrindMarkInCnt +k)>=C3InEdgeCount                                          ) continue;

														 GrindWidthDis = Math.GetLength(C3InPoint[GrindMarkInCnt+k], C3Point[GrindMarkOutCnt+k]);
														 TotalCirDis+=   GrindWidthDis;
														 CircleCount++;
													 }
													 if(TotalCirDis!=0.0f && CircleCount!=0){
														 C3CorGrindWd  = TotalCirDis/CircleCount;
													 }
												 }
											 }
											 else { // GrindMrk 못찾을경우 연마량만 측정함 
												 // OutData기준 최소값 데이터 Count산출 
												 GrindMeaDis =0.0f, MinDis =10000.0f; GrindMarkOutCnt=0;
												 for(int k=0; k<C3EdgeCount; k++){
													 if(C3Point[k].x==0.0f || C3Point[k].y==0.0f) continue;

													 GrindMarkRectCenter[1].x = GrindMarkRect[1].left + (GrindMarkRect[1].right  - GrindMarkRect[1].left)/2; 
													 GrindMarkRectCenter[1].y = GrindMarkRect[1].top  + (GrindMarkRect[1].bottom - GrindMarkRect[1].top )/2; 

													 GrindMeaDis = Math.GetLength(GrindMarkRectCenter[1], C3Point[k]);
													 if(GrindMeaDis<MinDis){
														 MinDis = GrindMeaDis;
														 GrindMarkOutCnt = k;
													 }
												 }

												 // 최단거리OUtCount기준 InData 최단거리 Count정보 Calc 
												 if(GrindMarkOutCnt!=0){
													 GrindMeaDis =0.0f, MinDis =10000.0f; GrindMarkInCnt=0;
													 for(int k=0; k<C3InEdgeCount; k++){
														 if(C3InPoint[k].x            ==0.0f || C3InPoint[k].y             ==0.0f) continue;
														 if(C3Point[GrindMarkOutCnt].x==0.0f || C3Point[GrindMarkOutCnt].y ==0.0f) continue;

														 GrindMeaDis = Math.GetLength(C3Point[GrindMarkOutCnt], C3InPoint[k]);
														 if(GrindMeaDis<MinDis){
															 MinDis = GrindMeaDis;
															 GrindMarkInCnt = k;
														 }
													 }
												 }

												 // GrindMark기준 수직 포인트 주변값 Avg산출한다 ==>연마량 측정(OutData,InData기준)
												 if((GrindMarkOutCnt!=0 && GrindMarkOutCnt>5) && (GrindMarkInCnt!=0 && GrindMarkInCnt>5)){
													 CircleCount=0,TotalCirDis=0.0f,GrindWidthDis=0.0f;
													 for(int k=-5; k<5; k++){
														 if(C3Point  [GrindMarkOutCnt+k].x==0.0f && C3Point  [GrindMarkOutCnt+k].y==0.0f) continue;
														 if(C3InPoint[GrindMarkInCnt +k].x==0.0f && C3InPoint[GrindMarkInCnt +k].y==0.0f) continue;
														 if((GrindMarkOutCnt+k)>=C3EdgeCount                                            ) continue;
														 if((GrindMarkInCnt +k)>=C3InEdgeCount                                          ) continue;

														 GrindWidthDis = Math.GetLength(C3InPoint[GrindMarkInCnt+k], C3Point[GrindMarkOutCnt+k]);
														 TotalCirDis+=   GrindWidthDis;
														 CircleCount++;
													 }
													 if(TotalCirDis!=0.0f && CircleCount!=0){
														 C3CorGrindWd = TotalCirDis/CircleCount;
													 }
												 }
											 }
										 }	
										 // LEFTBTM END 
										 ///////////////////////////////////////////////////////////////////////////////////////////////////


										 // RIGHTBTOM START 
										 ///////////////////////////////////////////////////////////////////////////////////////////////////
										 EasyImage::Threshold(&RotateImg,&RotateBinaryImg, ECThresHold);               // Corner Out GinrdThresHold 
										 EasyImage::Threshold(&RotateImg,&RotateGrindBinaryImg, CorGrindMeaThresHold); // Corner Measure GrindThresHold(3Point)

										 if(ECThresHold==0)    {SingleLine->GImage = &RotateImg      ;  SingleLine->FThreshold =5 ;}
										 else                  {SingleLine->GImage = &RotateBinaryImg;  SingleLine->FThreshold =10;}

										 SingleLine->IRoi->SetOrgX  ((int)FRBPoint.x-RBCornerWidth );
										 SingleLine->IRoi->SetOrgY  ((int)FRBPoint.y-RBCornerHeight);
										 SingleLine->IRoi->SetWidth ((int)RBCornerWidth+10         );
										 SingleLine->IRoi->SetHeight((int)RBCornerHeight           );

										 SingleLine->SetOrientation(orEast);
										 SingleLine->FIncrement =1;
										 SingleLine->FThreshold =15;
										 SingleLine->SetFindLineId(0);
										 SingleLine->SetEdgeType(1);  //White To Black 
										 SingleLine->OnExecute();

										 Line[6].FP0 = SingleLine->GetResultP0();
										 Line[6].FP1 = SingleLine->GetResultP1();

										 // ORG 
										 FRBRPoint = Math.OnIntersect(SingleLine->GetResultP0(), SingleLine->GetResultP1(), Line[waRightWall ].FP0, Line[waRightWall] .FP1);
										 FRBBPoint = Math.OnIntersect(SingleLine->GetResultP0(), SingleLine->GetResultP1(), Line[waBottomWall].FP0, Line[waBottomWall].FP1);

										 if((FRBRPoint.x==0 || FRBRPoint.y==0 || FRBBPoint.x==0 || FRBBPoint.y==0) || (SingleLine->FEdgePointCount <30)){
											 RBDx = 0.0f;
											 RBDy = 0.0f;
											 //화면에 디스플레이 위해서 
											 FRBRPoint.x = FRBPoint.x;
											 FRBRPoint.y = FRBPoint.y;
											 FRBBPoint.x = FRBPoint.x;
											 FRBBPoint.y = FRBPoint.y;
										 }
										 else { 
											 RBDx = Math.GetLengthFrPointToPoint(FRBPoint, FRBBPoint);
											 RBDy = Math.GetLengthFrPointToPoint(FRBPoint, FRBRPoint);

											 // OutLine C4Corner Data 
											 if((SingleLine->FEdgePointCount) - (CornerMargin*2)>0){
												 if(C4Point!=NULL) delete[] C4Point;
												 C4Point  = new TFPoint [(SingleLine->FEdgePointCount) - (CornerMargin*2)];
												 C4EdgeCount = (SingleLine->FEdgePointCount) -(CornerMargin*2);

												 CornerCount =0;  
												 for(int k=CornerMargin; k<((SingleLine->FEdgePointCount)-CornerMargin); k++){
													 if(CornerCount>=MAX_CORNER_POINT) break;
													 C4Point[CornerCount].x = SingleLine->FEdgePoint[k].x;
													 C4Point[CornerCount].y = SingleLine->FEdgePoint[k].y;
													 CornerCount++;
												 }
											 }

											 // Corner 기울기 완만하여 Edge찾을 경우 Defect 오버킬 발생함 
											 // 방향을 Top방향에서 다시 엣지를 찾음 (Corner Defect OverKill 감소 목적)
											 if(CorGrindInThresHold!=0){
												 EasyImage::Threshold(&RotateImg,&RotateBinaryImg, CorGrindInThresHold);
												 SingleLine->GImage = &RotateBinaryImg;  SingleLine->FThreshold =10;

												 if(RBCornerWidth >(RBCornerHeight*1.5)){
													 SingleLine->IRoi->SetOrgX  ((int)FRBBPoint.x                 ) ;
													 SingleLine->IRoi->SetOrgY  ((int)FRBBPoint.y - RBCornerHeight) ;
													 SingleLine->IRoi->SetWidth ((int)(RBCornerWidth+10           ));
													 SingleLine->IRoi->SetHeight((int)(RBCornerHeight             ));

													 if(FRBBPoint.x<=0    || FRBBPoint.y - RBCornerHeight<=0    || RBCornerWidth+10<=0    || RBCornerHeight+10 <=0    ) return false;
													 if(FRBBPoint.x>=ImgW || FRBBPoint.y - RBCornerHeight>=ImgH || RBCornerWidth+10>=ImgW || RBCornerHeight+10 >=ImgH ) return false;

													 SingleLine->SetOrientation(orSouth);
													 SingleLine->FIncrement =1;
													 SingleLine->SetFindLineId(0);
													 SingleLine->SetEdgeType(0);  //Black To White 
													 SingleLine->OnExecute();

													 // InLine C4Corner Data 
													 if((SingleLine->FEdgePointCount) - (CornerMargin*2)>0){
														 if(C4InPoint!=NULL) delete[] C4InPoint;
														 C4InPoint  = new TFPoint [(SingleLine->FEdgePointCount) - (CornerMargin*2)];
														 C4InEdgeCount = (SingleLine->FEdgePointCount) -(CornerMargin*2);

														 CornerCount =0;  
														 for(int k=CornerMargin; k<((SingleLine->FEdgePointCount)-CornerMargin); k++){
															 if(CornerCount>=MAX_CORNER_POINT) break;
															 C4InPoint[CornerCount].x = SingleLine->FEdgePoint[k].x;
															 C4InPoint[CornerCount].y = SingleLine->FEdgePoint[k].y;
															 CornerCount++;
														 }
													 }
												 }
												 else {
													 // Corner 연마 안쪽라인 찾는다 
													 SingleLine->SetOrientation(orEast);
													 SingleLine->SetFindLineId(0);
													 SingleLine->SetEdgeType(0);  //Black To White 
													 SingleLine->OnExecute();

													 // InLine C4Corner Data 
													 if((SingleLine->FEdgePointCount) - (CornerMargin*2)>0){
														 if(C4InPoint!=NULL) delete[] C4InPoint;
														 C4InPoint  = new TFPoint [(SingleLine->FEdgePointCount) - (CornerMargin*2)];
														 C4InEdgeCount = (SingleLine->FEdgePointCount) -(CornerMargin*2);

														 CornerCount =0;  
														 for(int k=CornerMargin; k<((SingleLine->FEdgePointCount)-CornerMargin); k++){
															 if(CornerCount>=MAX_CORNER_POINT) break;
															 C4InPoint[CornerCount].x = SingleLine->FEdgePoint[k].x;
															 C4InPoint[CornerCount].y = SingleLine->FEdgePoint[k].y;
															 CornerCount++;
														 }
													 }
												 }

												 //코너 연마안쪽라인 기준 새로운 교차점 생성 
												 FRBRInPoint = Math.OnIntersect(SingleLine->GetResultP0(), SingleLine->GetResultP1(), Line[waRightWall ].FP0, Line[waRightWall ].FP1);
												 FRBBInPoint = Math.OnIntersect(SingleLine->GetResultP0(), SingleLine->GetResultP1(), Line[waBottomWall].FP0, Line[waBottomWall].FP1);
											 }

											 // GrindMark기준 연마량,가공량 측정함 
											 // RightBtm Corner Mark Find 
											 if(GrindRectSpec[1].DvX!=0.0f && GrindRectSpec[1].DvY!=0.0f){
												 GrindMarkRect[17].left = (FRBPoint.x - GrindRectSpec[1].DvX) -GrindMarkRange;
												 GrindMarkRect[17].top  = (FRBPoint.y - GrindRectSpec[1].DvY) -GrindMarkRange;
												 GrindMarkRect[17].right  = GrindMarkRect[17].left+GrindMarkLength;
												 GrindMarkRect[17].bottom = GrindMarkRect[17].top +GrindMarkLength;

												 // 원본이미지에서 Mark 찾는다 
												 Find->OnLoad(true,FindDir)                     ;
												 Find->GImage = &RotateImg                      ;
												 Find->SetContrastMode(EFindContrastMode_Normal);
												 Find->SetMinScore (GrindPadMarkMinScore)       ; // PatternrFind 검사 최소 Score
												 Find->SetZeroScore(GrindPadMarkMinScore)       ; // 검사 후 최소 Score 
												 Find->SetMaxInstances(1)                       ;
												 Find->SetAngleTolerance(20.0f)                 ;
												 Find->SetAngleBias(315.0f)                     ;
												 Find->SetScaleBias(1.00f)                      ;
												 Find->SetScaleTolerance(0.0f)                  ;
												 Find->Property.Ox = (float)ImgW/2              ;
												 Find->Property.Oy = (float)ImgH/2              ;

												 GrindRectWidth  = (GrindMarkRect[17].right  - GrindMarkRect[17].left);
												 GrindRectHeight = (GrindMarkRect[17].bottom - GrindMarkRect[17].top );
												 Find->IRoi->SetPlacement(GrindMarkRect[17].left,GrindMarkRect[17].top,GrindRectWidth,GrindRectHeight);
												 if(GrindMarkRect[17].left<=0    || GrindMarkRect[17].top<=0    || GrindRectWidth<=0    || GrindRectHeight<=0   ) return false;
												 if(GrindMarkRect[17].left>=ImgW || GrindMarkRect[17].top>=ImgH || GrindRectWidth>=ImgW || GrindRectHeight>=ImgH) return false;

												 // 검사 및 Match Pos 좌표 받어온다 
												 // Find 검사 성공시 데이터 받아옴 
												 if(Find->OnExecute()){
													 GrindMarkPoint[17].x = Find->Result[0].Px;
													 GrindMarkPoint[17].y = Find->Result[0].Py;
													 GrindMarkScore[17]   = Find->Result[0].Score;
												 }
												 // Contrast Gradient Pixel Value
												 GrindMarkGradient[17] = EasyImage::Focusing(Find->IRoi);

												 // Right CellSize 측정 목적 
												 ///////////////////////////////////////////////////////////////////////////////////
												 GrindMarkRect[16].left = (FRBPoint.x - GrindRectSpec[2].DvX) -GrindMarkRange;
												 GrindMarkRect[16].top  = (FRBPoint.y - GrindRectSpec[2].DvY) -GrindMarkRange;
												 GrindMarkRect[16].right  = GrindMarkRect[16].left+GrindMarkLength;
												 GrindMarkRect[16].bottom = GrindMarkRect[16].top +GrindMarkLength;

												 GrindRectWidth  = (GrindMarkRect[16].right  - GrindMarkRect[16].left);
												 GrindRectHeight = (GrindMarkRect[16].bottom - GrindMarkRect[16].top );
												 Find->IRoi->SetPlacement(GrindMarkRect[16].left,GrindMarkRect[16].top,GrindRectWidth,GrindRectHeight);
												 if(GrindMarkRect[16].left<=0    || GrindMarkRect[16].top<=0    || GrindRectWidth<=0    || GrindRectHeight<=0   ) return false;
												 if(GrindMarkRect[16].left>=ImgW || GrindMarkRect[16].top>=ImgH || GrindRectWidth>=ImgW || GrindRectHeight>=ImgH) return false;

												 // 검사 및 Match Pos 좌표 받어온다 
												 // Find 검사 성공시 데이터 받아옴 
												 Find->SetAngleBias(0.0f);
												 if(Find->OnExecute()){
													 GrindMarkPoint[16].x = Find->Result[0].Px;
													 GrindMarkPoint[16].y = Find->Result[0].Py;
													 GrindMarkScore[16]   = Find->Result[0].Score;

													 // Chamber CUt 기준 Cell Size 측정 
													 if(Line[3].FP0.x!=0.0f && Line[3].FP0.y!=0.0f && Line[3].FP1.x!=0.0f && Line[3].FP1.y!=0.0f){
														 BtmGrindMeasure9 = Math.GetLengthFrLineToPoint(Line[3].FP0, Line[3].FP1, GrindMarkPoint[16]);
													 }
												 }
											 }

											 // GrindMakr찾을경우 연마량,가공량 측정함
											 if(GrindMarkPoint[17].x!=0.0f && GrindMarkPoint[17].y!=0.0f){
												 // GrindMark기준 OutData 최단거리 Count정보 Calc 
												 GrindMeaDis =0.0f, MinDis =10000.0f; GrindMarkOutCnt=0;
												 for(int k=0; k<C4EdgeCount; k++){
													 if(C4Point[k].x  ==0.0f       || C4Point[k].y        ==0.0f) continue;
													 if(GrindMarkPoint[17].x==0.0f || GrindMarkPoint[17].y==0.0f) continue;

													 GrindMeaDis = Math.GetLength(GrindMarkPoint[17], C4Point[k]);
													 if(GrindMeaDis<MinDis){
														 MinDis = GrindMeaDis;
														 GrindMarkOutCnt = k;
													 }
												 }
												 // OutData기준 InData 최단거리 Count정보 Calc 
												 if(GrindMarkOutCnt!=0){
													 GrindMeaDis =0.0f, MinDis =10000.0f; GrindMarkInCnt=0;
													 for(int k=0; k<C4InEdgeCount; k++){
														 if(C4InPoint[k].x   ==0.0f          || C4InPoint[k].y             ==0.0f) continue;
														 if(C4Point[GrindMarkOutCnt].x==0.0f || C4Point[GrindMarkOutCnt].y ==0.0f) continue;

														 GrindMeaDis = Math.GetLength(C4Point[GrindMarkOutCnt], C4InPoint[k]);
														 if(GrindMeaDis<MinDis){
															 MinDis = GrindMeaDis;
															 GrindMarkInCnt = k;
														 }
													 }
												 }

												 // GrindMark기준 수직 포인트 주변값 Avg산출한다 ==>가공량 측정(OutData기준)
												 if(GrindMarkOutCnt!=0 && GrindMarkOutCnt>5){
													 CircleCount=0,TotalCirDis=0.0f,GrindMeaDis=0.0f;
													 for(int k=GrindMarkOutCnt-5; k<GrindMarkOutCnt+5; k++){
														 if(C4Point[k].x==0.0f || C4Point[k].y==0.0f) continue;
														 if(k>=C4EdgeCount                          ) continue;

														 GrindMeaDis = Math.GetLength(GrindMarkPoint[17], C4Point[k]);
														 TotalCirDis+= GrindMeaDis;
														 CircleCount++;
													 }
													 if(TotalCirDis!=0.0f && CircleCount!=0){
														 C4CorGrindMea = TotalCirDis/CircleCount;
													 }
												 }

												 // GrindMark기준 수직 포인트 주변값 Avg산출한다 ==>연마량 측정(OutData,InData기준)
												 if((GrindMarkOutCnt!=0 && GrindMarkOutCnt>5) && (GrindMarkInCnt!=0 && GrindMarkInCnt>5)){
													 CircleCount=0,TotalCirDis=0.0f,GrindWidthDis=0.0f;
													 for(int k=-5; k<5; k++){
														 if(C4Point  [GrindMarkOutCnt+k].x==0.0f && C4Point  [GrindMarkOutCnt+k].y==0.0f) continue;
														 if(C4InPoint[GrindMarkInCnt +k].x==0.0f && C4InPoint[GrindMarkInCnt +k].y==0.0f) continue;
														 if((GrindMarkOutCnt+k)>=C4EdgeCount                                            ) continue;
														 if((GrindMarkInCnt +k)>=C4InEdgeCount                                          ) continue;

														 GrindWidthDis = Math.GetLength(C4InPoint[GrindMarkInCnt+k], C4Point[GrindMarkOutCnt+k]);
														 TotalCirDis+=   GrindWidthDis;
														 CircleCount++;
													 }
													 if(TotalCirDis!=0.0f && CircleCount!=0){
														 C4CorGrindWd  = TotalCirDis/CircleCount;
													 }
												 }
											 }
											 else { // GrindMrk 못찾을경우 연마량만 측정함 
												 // OutData기준 최소값 데이터 Count산출 
												 GrindMeaDis =0.0f, MinDis =10000.0f; GrindMarkOutCnt=0;
												 for(int k=0; k<C4EdgeCount; k++){
													 if(C4Point[k].x==0.0f || C4Point[k].y==0.0f) continue;

													 GrindMarkRectCenter[17].x = GrindMarkRect[17].left + (GrindMarkRect[17].right  - GrindMarkRect[17].left)/2; 
													 GrindMarkRectCenter[17].y = GrindMarkRect[17].top  + (GrindMarkRect[17].bottom - GrindMarkRect[17].top )/2; 

													 GrindMeaDis = Math.GetLength(GrindMarkRectCenter[17], C4Point[k]);
													 if(GrindMeaDis<MinDis){
														 MinDis = GrindMeaDis;
														 GrindMarkOutCnt = k;
													 }
												 }

												 // 최단거리OUtCount기준 InData 최단거리 Count정보 Calc 
												 if(GrindMarkOutCnt!=0){
													 GrindMeaDis =0.0f, MinDis =10000.0f; GrindMarkInCnt=0;
													 for(int k=0; k<C4InEdgeCount; k++){
														 if(C4InPoint[k].x            ==0.0f || C4InPoint[k].y             ==0.0f) continue;
														 if(C4Point[GrindMarkOutCnt].x==0.0f || C4Point[GrindMarkOutCnt].y ==0.0f) continue;

														 GrindMeaDis = Math.GetLength(C4Point[GrindMarkOutCnt], C4InPoint[k]);
														 if(GrindMeaDis<MinDis){
															 MinDis = GrindMeaDis;
															 GrindMarkInCnt = k;
														 }
													 }
												 }

												 // GrindMark기준 수직 포인트 주변값 Avg산출한다 ==>연마량 측정(OutData,InData기준)
												 if((GrindMarkOutCnt!=0 && GrindMarkOutCnt>5) && (GrindMarkInCnt!=0 && GrindMarkInCnt>5)){
													 CircleCount=0,TotalCirDis=0.0f,GrindWidthDis=0.0f;
													 for(int k=-5; k<5; k++){
														 if(C4Point  [GrindMarkOutCnt+k].x==0.0f && C4Point  [GrindMarkOutCnt+k].y==0.0f) continue;
														 if(C4InPoint[GrindMarkInCnt +k].x==0.0f && C4InPoint[GrindMarkInCnt +k].y==0.0f) continue;
														 if((GrindMarkOutCnt+k)>=C4EdgeCount                                            ) continue;
														 if((GrindMarkInCnt +k)>=C4InEdgeCount                                          ) continue;

														 GrindWidthDis = Math.GetLength(C4InPoint[GrindMarkInCnt+k], C4Point[GrindMarkOutCnt+k]);
														 TotalCirDis+=   GrindWidthDis;
														 CircleCount++;
													 }
													 if(TotalCirDis!=0.0f && CircleCount!=0){
														 C4CorGrindWd = TotalCirDis/CircleCount;
													 }
												 }
											 }
										 }	
									 }
								 }
								 else if(IsRectBtm){ // Btm영역이 Rect일경우 
									 LBDx = 0.0f;
									 LBDy = 0.0f;
									 RBDx = 0.0f;
									 RBDy = 0.0f;

									 //화면에 디스플레이 위해서 
									 FLBLPoint.x = FLBPoint.x;
									 FLBLPoint.y = FLBPoint.y;
									 FLBBPoint.x = FLBPoint.x;
									 FLBBPoint.y = FLBPoint.y;

									 FRBRPoint.x = FRBPoint.x;
									 FRBRPoint.y = FRBPoint.y;
									 FRBBPoint.x = FRBPoint.x;
									 FRBBPoint.y = FRBPoint.y;
								 }
							 }
						 }
						 // Image 회전 후 FLBPoint, FRBPoint 기준 BTM 6개의 기준 포인트 및 Circle_Point 기준으로 치수 측정(Circle Dx,Dy,R) 및 데이터 산출 
						 // Corner 교차점 기준 스팩 Dx, Dy만큼 이동하여 Circle Center 설정시(Sawing 편차+Cutting 편차+Grind 편차) 정확성 떨어짐...ㅜ.ㅜ;;
						 // TrackLine EdgePoint 기준 Circle_Fitting하여 Center설정시 교차점 기준보다는 정확성 높아짐 
						 // TrackLine 교차점 기준 스팩 Dx, Dy만큼 이동하여 Circle Center 설정시????
						 // Btm 검사시 Circle 형태일경우만 검사 진행함 
						 if(FLBPoint.x!=0 && FLBPoint.y!=0 && FRBPoint.x!=0 && FRBPoint.y!=0 && IsCircleBtm==1){
						     // 6개의 Circle Center Point 산출 
							 // Cell의 R크기 및 Center부분의 깊이에 따라서 개별 CenterPoint가 변경된다....규칙을 찾아야 한다??......
							 // 외곽라인 기준 Circle Center 설정함 
							 // 연마라인이 불규칙함 이로인해서 CircleEdge 못찾더라도 원본데이터는 가지고 있어야함 
							 // Circle In_Edge Point Count    // Circle Out_Edge Point Count    // Circle(Grind_Measure) Stand Edge Point Count

							 //자재의 외곽라인 교차점 기준 CirCenter 설정함 
							 if(CSideCircleWidth!=0.0f && CSideCircleHeight!=0.0f){
								 C1CirCenter.x = FLBPoint.x + CSideCircleWidth + dCirOffsetX;  C1CirCenter.y = FLBPoint.y -  CSideCircleHeight - dCirOffsetY;  
								 C6CirCenter.x = FRBPoint.x - CSideCircleWidth - dCirOffsetX;  C6CirCenter.y = FRBPoint.y -  CSideCircleHeight              ;  
							 }

							 if(CenterCircleWidth!=0.0f && CenterCircleHeight!=0.0f){ 
								 C2CirCenter.x = FLBPoint.x + CELL_E - CELL_F               ;  C2CirCenter.y = FLBPoint.y -  CenterCircleHeight             ;  
								 C3CirCenter.x = FLBPoint.x + CELL_E                        ;  C3CirCenter.y = FLBPoint.y -  CELL_D+(CenterCircleHeight)    ;  
								 C4CirCenter.x = FRBPoint.x - CELL_E                        ;  C4CirCenter.y = FRBPoint.y -  CELL_D+(CenterCircleHeight)    ;  
								 C5CirCenter.x = FRBPoint.x - CELL_E + CELL_F               ;  C5CirCenter.y = FRBPoint.y -  CenterCircleHeight             ;  
							 }

							 if(FInspectMode==Insp_Track){ //TrackMode TrackLine교자점 기준으로 Circle 센터 좌표 계산함 
								 TrackC1CirCenter.x = FTRLBPoint.x + TrackCircleWidth + dCirOffsetX     ;  TrackC1CirCenter.y = FTRLBPoint.y - TrackCircleHeight - dCirOffsetY                ;  
								 TrackC2CirCenter.x = FTRLBPoint.x + CELL_E - CELL_F - OutToTrackLineDis;  TrackC2CirCenter.y = FTRLBPoint.y - CenterCircleHeight+OutToTrackLineDis           ;  
								 TrackC3CirCenter.x = FTRLBPoint.x + CELL_E - OutToTrackLineDis         ;  TrackC3CirCenter.y = FTRLBPoint.y - CELL_D + (CenterCircleHeight)+OutToTrackLineDis;  
								 TrackC4CirCenter.x = FTRRBPoint.x - CELL_E + OutToTrackLineDis         ;  TrackC4CirCenter.y = FTRRBPoint.y - CELL_D + (CenterCircleHeight)+OutToTrackLineDis;  
								 TrackC5CirCenter.x = FTRRBPoint.x - CELL_E + CELL_F + OutToTrackLineDis;  TrackC5CirCenter.y = FTRRBPoint.y - CenterCircleHeight+OutToTrackLineDis           ;  
								 TrackC6CirCenter.x = FTRRBPoint.x - TrackCircleWidth - dCirOffsetX     ;  TrackC6CirCenter.y = FTRRBPoint.y - TrackCircleHeight - dCirOffsetY                ;
							 }

							 // 비선형 곡선 알고리즘에 필요한 영역 설정 
							 if(FInspectMode==Insp_Polygon){
								 if(CSideCircleWidth!=0.0f && CSideCircleHeight!=0.0f  ){ // Notch부 좌우 영역설정 
									 PolyRect[0].left  = (long)(FLBPoint.x                 );  PolyRect[0].top    = (long)(FLBPoint.y - CSideCircleHeight);
									 PolyRect[0].right = (long)(FLBPoint.x+CSideCircleWidth);  PolyRect[0].bottom = (long)(FLBPoint.y                    );
									 PolyRect[5].left  = (long)(FRBPoint.x-CSideCircleWidth);  PolyRect[5].top    = (long)(FRBPoint.y - CSideCircleHeight);
									 PolyRect[5].right = (long)(FRBPoint.x                 );  PolyRect[5].bottom = (long)(FLBPoint.y                    );
								 }

								 if(CenterCircleWidth!=0.0f && CenterCircleHeight!=0.0f){ // Trench부 영역설정
									 if(Center1CircleWidth==0.0f && Center2CircleWidth==0.0f){ // 
										 PolyRect[1].left  = (long)(FLBPoint.x+CELL_E-CELL_F                  ); PolyRect[1].top    = (long)(FLBPoint.y - CenterCircleHeight   );
										 PolyRect[1].right = (long)(PolyRect[1].left+CenterCircleWidth        ); PolyRect[1].bottom = (long)(PolyRect[1].top+CenterCircleHeight);

										 PolyRect[2].left  = (long)(FLBPoint.x+CELL_E-CenterCircleWidth       ); PolyRect[2].top    = (long)(FLBPoint.y - CELL_D               );
										 PolyRect[2].right = (long)(PolyRect[2].left+CenterCircleWidth        ); PolyRect[2].bottom = (long)(PolyRect[2].top+CenterCircleHeight);

										 PolyRect[3].left  = (long)(FRBPoint.x-CELL_E                         ); PolyRect[3].top    = (long)(FRBPoint.y - CELL_D               );
										 PolyRect[3].right = (long)(PolyRect[3].left+CenterCircleWidth        ); PolyRect[3].bottom = (long)(PolyRect[3].top+CenterCircleHeight);

										 PolyRect[4].left  = (long)(FRBPoint.x-CELL_E+CELL_F-CenterCircleWidth); PolyRect[4].top    = (long)(FRBPoint.y - CenterCircleHeight   );
										 PolyRect[4].right = (long)(PolyRect[4].left+CenterCircleWidth        ); PolyRect[4].bottom = (long)(PolyRect[4].top+CenterCircleHeight);
									 }
									 else                                                    {
										 PolyRect[1].left  = (long)(FLBPoint.x+CELL_E-CELL_F                   ); PolyRect[1].top    = (long)(FLBPoint.y - CenterCircleHeight   );
										 PolyRect[1].right = (long)(PolyRect[1].left+Center1CircleWidth        ); PolyRect[1].bottom = (long)(PolyRect[1].top+CenterCircleHeight);
																											   
										 PolyRect[2].left  = (long)(FLBPoint.x+CELL_E-Center2CircleWidth       ); PolyRect[2].top    = (long)(FLBPoint.y - CELL_D               );
										 PolyRect[2].right = (long)(PolyRect[2].left+Center2CircleWidth        ); PolyRect[2].bottom = (long)(PolyRect[2].top+CELL_D            );
																											   
										 PolyRect[3].left  = (long)(FRBPoint.x-CELL_E                          ); PolyRect[3].top    = (long)(FRBPoint.y - CELL_D               );
										 PolyRect[3].right = (long)(PolyRect[3].left+Center2CircleWidth        ); PolyRect[3].bottom = (long)(PolyRect[3].top+CELL_D            );

										 PolyRect[4].left  = (long)(FRBPoint.x-CELL_E+CELL_F-Center1CircleWidth); PolyRect[4].top    = (long)(FRBPoint.y - CenterCircleHeight   );
										 PolyRect[4].right = (long)(PolyRect[4].left+Center1CircleWidth        ); PolyRect[4].bottom = (long)(PolyRect[4].top+CenterCircleHeight);
									 }
								 }
							 }

							 // 자재의 외곽라인 교차점 기준 GrindMark Match 영역 설정 및 Match 검사 시퀀스 
							 if(IsMarkBtm && FInspectMode!=Insp_Track){
								 // Match 알고리즘 적용한 검사 시퀀스 
								 double OrgDis=0.0f, MatchDis=0.0f, DvDis=0.0f, AvgDvDis=0.0f, MinDvDis=100000.0f; 
								 // Find 알고리즘 적용한 검사 시퀀스 
								 // GrindMarkRect영역 설정 (Find)
								 // 화면에 설정값을 최소화 목적으로 영역설정값을 다시 계산함
								 for(int k=0; k<19; k++){
									 // 특정 포인트는 현재 GrindMark없음...
// 									 if(k==0 || k==3 || k==4|| k==6 || k==8 || k==10|| k==12 ||k==14|| k==15 || k==18) continue;
									 if(k<9)    {
										 if(GrindRectSpec[k].DvX==0.0f || GrindRectSpec[k].DvY==0.0f)  continue;
									 }
									 else if(k>9){
										 if(GrindRectSpec[18 -k].DvX==0.0f || GrindRectSpec[18 -k].DvY==0.0f)  continue;
									 }


									 if(k<9){ // Left 영역 
										 GrindMarkRect[k].left = (FLBPoint.x + GrindRectSpec[k].DvX) -GrindMarkRange;
										 GrindMarkRect[k].top  = (FLBPoint.y - GrindRectSpec[k].DvY) -GrindMarkRange;
									 }
									 else if(k==9 && CenterCircleHeight!=0.0f && CenterCircleWidth!=0.0f){																	      
										 GrindMarkRect[k].left   = (FLBPoint.x + ((FRBPoint.x -FLBPoint.x)/2) -GrindMarkRange);
										 GrindMarkRect[k].top    = (FLBPoint.y - CELL_D - OutToGrindMarkDis1  -GrindMarkRange);
									 }																				      
									 else if(k>9){ //Right 영역 
										 GrindMarkRect[k].left = (FRBPoint.x - GrindRectSpec[18 -k].DvX) -GrindMarkRange;
										 GrindMarkRect[k].top  = (FRBPoint.y - GrindRectSpec[18 -k].DvY) -GrindMarkRange;
									 }
									 // GrindMarkRect Right/Bottom 영역 좌표 계산 
									 GrindMarkRect[k].right  = GrindMarkRect[k].left+GrindMarkLength;
									 GrindMarkRect[k].bottom = GrindMarkRect[k].top +GrindMarkLength;
								 }

								 // Match 검사시 기본 설정 
// 								 if(IsMarkBtm) Find->OnLoad(true,FindDir  );
// 								 else          Find->OnLoad(true,FindDir,1);
								 LogUnit.SetLog(L"CellID:%d, CamID:%d ==>GindMark_Find_Circle_Start",CellId,CamId);     
								 Find->OnLoad(true,FindDir  )                   ;
								 Find->GImage = &RotateImg                      ;
// 								 Find->SetContrastMode(EFindContrastMode_Any)   ;
								 Find->SetContrastMode(EFindContrastMode_Normal);
// 								 Find->SetMinScore(0.8f)                        ;
								 Find->SetMinScore (GrindMarkMinScore)          ; // PatternrFind 검사 최소 Score
								 Find->SetZeroScore(GrindMarkMinScore)          ; // 검사 후 최소 Score 
								 Find->SetMaxInstances(1)                       ;
								 Find->SetAngleTolerance(20.0f)                 ;
								 Find->SetScaleBias(1.00f)                      ;
								 Find->SetScaleTolerance(0.0f)                  ;
								 Find->Property.Ox = (float)ImgW/2              ;
								 Find->Property.Oy = (float)ImgH/2              ;

// 								 int GrindRectWidth=0, GrindRectHeight=0;
								 GrindRectWidth=0, GrindRectHeight=0;
								 // Math 검사 진행 및 ㅏ Mark 중심좌표 산출 
// 								 for(int k=0; k<MAX_FIND_MARK_COUNT; k++){
								 for(int k=0; k<19; k++){ 
									 // 특정 포인트는 현재 GrindMark없음...
// 									 if(k==0 || k==3 || k==4|| k==6 || k==8 || k==10|| k==12 ||k==14|| k==15 || k==18) continue;

									 if(k<9)    {
										 if(GrindRectSpec[k].DvX==0.0f || GrindRectSpec[k].DvY==0.0f)  continue;
									 }
									 else if(k>9){
										 if(GrindRectSpec[18 -k].DvX==0.0f || GrindRectSpec[18 -k].DvY==0.0f)  continue;
									 }


									 GrindRectWidth  = (GrindMarkRect[k].right  - GrindMarkRect[k].left);
									 GrindRectHeight = (GrindMarkRect[k].bottom - GrindMarkRect[k].top );
									 Find->IRoi->SetPlacement(GrindMarkRect[k].left,GrindMarkRect[k].top,GrindRectWidth,GrindRectHeight);
									 if(GrindMarkRect[k].left<=0    || GrindMarkRect[k].top<=0    || GrindRectWidth<=0    || GrindRectHeight<=0   ) continue;
									 if(GrindMarkRect[k].left>=ImgW || GrindMarkRect[k].top>=ImgH || GrindRectWidth>=ImgW || GrindRectHeight>=ImgH) continue;

									 if     (k==0 ) Find->SetAngleBias(60.0f ); //LHJ Add 
									 else if(k==1 ) Find->SetAngleBias(45.0f );
									 else if(k==2 ) Find->SetAngleBias(0.0f  );
									 else if(k==4 ) Find->SetAngleBias(0.0f  );
									 else if(k==5 ) Find->SetAngleBias(315.0f);
									 else if(k==7 ) Find->SetAngleBias(315.0f);
									 else if(k==8 ) Find->SetAngleBias(315.0f);
									 else if(k==9 ) Find->SetAngleBias(0.0f  );
									 else if(k==10) Find->SetAngleBias(45.0f );
									 else if(k==11) Find->SetAngleBias(45.0f );
									 else if(k==13) Find->SetAngleBias(45.0f );
									 else if(k==14) Find->SetAngleBias(0.0f  );
									 else if(k==16) Find->SetAngleBias(0.0f  );
									 else if(k==17) Find->SetAngleBias(315.0f);
									 else if(k==18) Find->SetAngleBias(300.0f); //LHJ Add 
									 // 검사 및 Match Pos 좌표 받어온다 
									 // Find 검사 성공시 데이터 받아옴 
									 if(Find->OnExecute()){
										 GrindMarkPoint[k].x = Find->Result[0].Px;
										 GrindMarkPoint[k].y = Find->Result[0].Py;
										 GrindMarkScore[k]   = Find->Result[0].Score;// 실제 Pattern Finder Score Value
									 }
									 // Contrast Gradient Pixel Value
// 									 GrindMarkGradient[k] = EasyImage::Focusing(Find->IRoi);
								 }
								 LogUnit.SetLog(L"CellID:%d, CamID:%d ==>GindMark_Find_Circle_End",CellId,CamId);     
							 }

							 // 각각의 CirCenter_Point 기준 Circle_Fitting 및 검사진행 
							 if(FBottomWall){
								 EasyImage::Threshold(&RotateImg,&RotateBinaryImg       , BtmEdgeThresHold    ); // Circle Grind Edge
								 EasyImage::Threshold(&RotateImg,&RotateGrindBinaryImg  , CirGrindMeaThresHold); // Circle Grind Measure 측정 기준 패턴Edge(Circle Track Line)
								 EasyImage::Threshold(&RotateImg,&RotateGrindInBinaryImg, CirGrindInThresHold ); // Circle Grind In_EdgePoint 측정 목적

//								 RotateImg.Save             ("D:\\ROTATE_IMG\\RotateImage회전_CUP.bmp");
// 								 RotateBinaryImg.Save       ("D:\\ROTATE_IMG\\RotateBinaryImg회전_CUP.bmp");
// 								 RotateGrindBinaryImg.Save  ("D:\\ROTATE_IMG\\RotateGrindBinaryImg회전_CUP.bmp");
// 								 RotateGrindInBinaryImg.Save("D:\\ROTATE_IMG\\RotateGrindInBinaryImg회전_CUP.bmp");

								 if(FInspectMode==Insp_Polygon){
									 LogUnit.SetLog(L"CellID:%d, CamID:%d ==>Polygon_Insp_Start",CellId,CamId);
									 TPoint P1(0,0),P2(0,0),P3(0,0),P4(0,0);
									 // Polygon Algorithm Setting 
									 Polygon->IWidth          = ImgW;
									 Polygon->IHeight         = ImgH;
									 Polygon->PoPa.MinPxCnt   =300  ;
									 Polygon->PoPa.MaxPxCnt   =20000;
									 Polygon->PoPa.MaxBbCnt   =10   ;
// 									 Polygon->PoPa.FMinWidth  =300  ;
// 									 Polygon->PoPa.FMinHeight =100  ;

									 // 첫번째 Polygon, Circle 1
									if(PolyRect[0].left!=0 && PolyRect[0].top!=0 && PolyRect[0].right!=0 && PolyRect[0].bottom!=0){
									     P1.x=0, P1.y=0, P2.x=0, P2.y=0, P3.x=0, P3.y=0, P4.x=0, P4.y=0;
										 LogUnit.SetLog(L"CellID:%d, CamID:%d ==>Polygon1_Insp_Start",CellId,CamId);

// 										 P1.x = (PolyRect[0].left-30); P1.y =(PolyRect[0].top-20          ); P2.x = (P1.x+PolyRect[0].Width()+60); P2.y = (P1.y);
// 										 P3.x = (PolyRect[0].left-30); P3.y =(P1.y+PolyRect[0].Height()+40); P4.x = (P2.x                       ); P4.y = (P3.y);

// 										 P1.x = (PolyRect[0].left-50); P1.y =(PolyRect[0].top             ); P2.x = (P1.x+PolyRect[0].Width()); P2.y = (P1.y);
// 										 P3.x = (PolyRect[0].left-50); P3.y =(P1.y+PolyRect[0].Height()+50); P4.x = (P2.x                    ); P4.y = (P3.y);

										 P1.x = (PolyRect[0].left); P1.y =(PolyRect[0].top             ); P2.x = (P1.x+PolyRect[0].Width()); P2.y = (P1.y);
										 P3.x = (PolyRect[0].left); P3.y =(P1.y+PolyRect[0].Height()+50); P4.x = (P2.x                    ); P4.y = (P3.y);

										 // Median Filter 적용 
										 if(P1.x<=0    || P1.y<=0    || (P2.x - P1.x)<=0    || (P3.y - P1.y)<=0   ) return false;
										 if(P1.x>=ImgW || P1.y>=ImgH || (P2.x - P1.x)>=ImgW || (P3.y - P1.y)>=ImgH) return false;
										 FilterROI.SetSize(int(P2.x - P1.x),int(P3.y - P1.y) )                 ;
										 FilterROI.Attach(&RotateBinaryImg)                                    ;
										 FilterROI.SetPlacement(P1.x, P1.y, int(P2.x - P1.x), int(P3.y - P1.y));
										 EasyImage::Median(&FilterROI, &FilterROI)                             ;
// 										 RotateBinaryImg.Save("D:\\ROTATE_IMG\\Polygon_BinaryImg_필터1.bmp");

										 Polygon->GImage          = &RotateBinaryImg           ;
										 Polygon->PoPa.FMaxWidth  =(int)(CSideCircleWidth+100 );
										 Polygon->PoPa.FMaxHeight =(int)(CSideCircleHeight+100);
										 Polygon->PoPa.IsSeparate =true                        ;
										 Polygon->PoPa.IsInToOut  =true                        ;
										 Polygon->PoPa.HiThHold   = BtmEdgeThresHold           ;
										 Polygon->PoPa.LoThHold   = 0                          ;
										 Polygon->PoPa.FMinWidth  =(int)(CSideCircleWidth/2)   ;
										 Polygon->PoPa.FMinHeight =(int)(CSideCircleHeight/2)  ;


										 if(P1.x!=0 && P1.y!=0 && P2.x!=0 && P2.y!=0 && P3.x!=0 && P3.y!=0 && P4.x!=0 && P4.y!=0){
											 Polygon->OnExecute(P1,P2,P3,P4);
										 }

										 // Polygon Algorithm InEdgeData/OutEdgeData Separate 및 데이터 추출 
										 if(Polygon->BlobCount==1){
											 PolygonMarginCnt =10;
											 if(Polygon->Blob[0].InCnt>(PolygonMarginCnt*2)){
												 C1CirInEdgeCount=0;
												 C1CirInEdgeCount = (Polygon->Blob[0].InCnt - (PolygonMarginCnt*2));
												 if(C1CirInEdgeCount>0){
													 if(C1CirInPoint!=NULL){
														 delete[] C1CirInPoint;
													 }
													 C1CirInPoint = new TFPoint[C1CirInEdgeCount];

													 PixelCnt=0;
													 for(int k=0; k<Polygon->Blob[0].InCnt; k++){
														 if(k<PolygonMarginCnt || k>=(Polygon->Blob[0].InCnt-PolygonMarginCnt)) continue;
														 C1CirInPoint[PixelCnt].x   = Polygon->Blob[0].InPoint[k].x ;
														 C1CirInPoint[PixelCnt].y   = Polygon->Blob[0].InPoint[k].y ;
														 PixelCnt++;
													 }
												 }
											 }

											 if(Polygon->Blob[0].OutCnt>(PolygonMarginCnt*2)){
												 C1CirOutEdgeCount=0;
												 C1CirOutEdgeCount = (Polygon->Blob[0].OutCnt - (PolygonMarginCnt*2));
												 if(C1CirOutEdgeCount>0){
													 if(C1CirOutPoint!=NULL) delete[] C1CirOutPoint;
													 C1CirOutPoint = new TFPoint[C1CirOutEdgeCount];

													 PixelCnt=0;
													 for(int k=0; k<Polygon->Blob[0].OutCnt; k++){
														 if(k<PolygonMarginCnt || k>=(Polygon->Blob[0].OutCnt-PolygonMarginCnt)) continue;
														 C1CirOutPoint[PixelCnt].x  = Polygon->Blob[0].OutPoint[k].x ;
														 C1CirOutPoint[PixelCnt].y  = Polygon->Blob[0].OutPoint[k].y ;
														 if(k==(Polygon->Blob[0].OutCnt-PolygonMarginCnt-1)){ // 직선구간에 필요한 시작점 데이터 좌료 
															 BtmEdgePoint[0].x = C1CirOutPoint[PixelCnt].x;
															 BtmEdgePoint[0].y = C1CirOutPoint[PixelCnt].y;
														 }
														 PixelCnt++;
													 }
												 }
											 }
											 // Polygon Data Clear
//                                              Polygon->ClearData();
										 }
										 // Polygon Data Clear
// 										 Polygon->ClearData();
										 /////////////////////////////////////////////////////////////////////////////////////////////

										 // InEdgeData/OutEdgeData 기준 가공량 및 연마량 계산
										 // Polygon 알고리즘에서는 GrindMark기준 OutData,InData 최단거리 2개 Tag값 산출해야함 
										 if(IsMarkBtm){ // LTPS 가공량,연마량 계산 
											 if(C1CirOutEdgeCount!=0 && C1CirInEdgeCount!=0){ // MarkMode경우 가공량 검사를 먼저 진행 후 연마량 산출

												 // GrindMark[0] 기준으로 연마량,가공량 측정 시퀀스 
												 //////////////////////////////////////////////////////////////////////////////////////
												 if(GrindMarkPoint[0].x!=0.0f && GrindMarkPoint[0].y!=0.0f){  //GrindMark 찾았을경우 
													 // GrindMark기준 OutData 최단거리 Count정보 Calc 
													 GrindMeaDis =0.0f, MinDis =10000.0f; GrindMarkOutCnt=0;
													 for(int k=0; k<C1CirOutEdgeCount; k++){
														 if(C1CirOutPoint[k].x ==0.0f || C1CirOutPoint[k].y ==0.0f) continue;
														 if(GrindMarkPoint[0].x==0.0f || GrindMarkPoint[0].y==0.0f) continue;

														 GrindMeaDis = Math.GetLength(GrindMarkPoint[0], C1CirOutPoint[k]);
														 if(GrindMeaDis<MinDis){
															 MinDis = GrindMeaDis;
															 GrindMarkOutCnt = k;
														 }
													 }

													 // GrindMark기준 InData 최단거리 Count정보 Calc 
													 if(GrindMarkOutCnt!=0){
														 GrindMeaDis =0.0f, MinDis =10000.0f; GrindMarkInCnt=0;
														 for(int k=0; k<C1CirInEdgeCount; k++){
															 if(C1CirInPoint[k].x   ==0.0f             || C1CirInPoint[k].y                ==0.0f) continue;
															 if(C1CirOutPoint[GrindMarkOutCnt].x==0.0f || C1CirOutPoint[GrindMarkOutCnt].y ==0.0f) continue;

															 GrindMeaDis = Math.GetLength(C1CirOutPoint[GrindMarkOutCnt], C1CirInPoint[k]);
															 if(GrindMeaDis<MinDis){
																 MinDis = GrindMeaDis;
																 GrindMarkInCnt = k;
															 }
														 }
													 }

													 // GrindMark기준 수직 포인트 주변값 Avg산출한다 ==>가공량 측정(OutData기준)
													 if(GrindMarkOutCnt!=0 && GrindMarkOutCnt>5){
														 CircleCount=0,TotalCirDis=0.0f,GrindMeaDis=0.0f;
														 for(int k=GrindMarkOutCnt-5; k<GrindMarkOutCnt+5; k++){
															 if(C1CirOutPoint[k].x==0.0f || C1CirOutPoint[k].y==0.0f) continue;
															 if(k>=C1CirOutEdgeCount                                ) continue;

															 GrindMeaDis = Math.GetLength(GrindMarkPoint[0], C1CirOutPoint[k]);
															 TotalCirDis+= GrindMeaDis;
															 CircleCount++;
														 }
														 if(TotalCirDis!=0.0f && CircleCount!=0){
															 C0CirGrindMea = TotalCirDis/CircleCount;
															 C0CirGrindMea = C0CirGrindMea+0.5; //SubPixel 
														 }
													 }

													 // GrindMark기준 수직 포인트 주변값 Avg산출한다 ==>연마량 측정(OutData,InData기준)
													 if((GrindMarkOutCnt!=0 && GrindMarkOutCnt>5) && (GrindMarkInCnt!=0 && GrindMarkInCnt>5)){
														 CircleCount=0,TotalCirDis=0.0f,GrindWidthDis=0.0f;
														 for(int k=-5; k<5; k++){
															 if(C1CirOutPoint[GrindMarkOutCnt+k].x==0.0f && C1CirOutPoint[GrindMarkOutCnt+k].y==0.0f) continue;
															 if(C1CirInPoint [GrindMarkInCnt +k].x==0.0f && C1CirInPoint [GrindMarkInCnt +k].y==0.0f) continue;
															 if((GrindMarkOutCnt+k)>=C1CirOutEdgeCount                                              ) continue;
															 if((GrindMarkInCnt +k)>=C1CirInEdgeCount                                               ) continue;

															 GrindWidthDis = Math.GetLength(C1CirInPoint[GrindMarkInCnt+k], C1CirOutPoint[GrindMarkOutCnt+k]);
															 TotalCirDis+=   GrindWidthDis;
															 CircleCount++;
														 }
														 if(TotalCirDis!=0.0f && CircleCount!=0){
															 C0CirGrindWd = TotalCirDis/CircleCount;
															 C0CirGrindWd = C0CirGrindWd+0.5; //SubPixel
														 }
													 }
												 }
												 else if(GrindMarkRect[0].left!=0 && GrindMarkRect[0].top!=0 && GrindMarkRect[0].right!=0 &&GrindMarkRect[0].bottom!=0) {  //GrindMark 못 찾았을경우
													 // OutData기준 최소값 데이터 Count산출 
													 GrindMeaDis =0.0f, MinDis =10000.0f; GrindMarkOutCnt=0;
													 for(int k=0; k<C1CirOutEdgeCount; k++){
														 if(C1CirOutPoint[k].x==0.0f || C1CirOutPoint[k].y==0.0f) continue;

														 GrindMarkRectCenter[0].x = GrindMarkRect[0].left + (GrindMarkRect[0].right  - GrindMarkRect[0].left)/2; 
														 GrindMarkRectCenter[0].y = GrindMarkRect[0].top  + (GrindMarkRect[0].bottom - GrindMarkRect[0].top )/2; 

														 GrindMeaDis = Math.GetLength(GrindMarkRectCenter[0], C1CirOutPoint[k]);
														 if(GrindMeaDis<MinDis){
															 MinDis = GrindMeaDis;
															 GrindMarkOutCnt = k;
														 }
													 }

													 // 최단거리OUtCount기준 InData 최단거리 Count정보 Calc 
													 if(GrindMarkOutCnt!=0){
														 GrindMeaDis =0.0f, MinDis =10000.0f; GrindMarkInCnt=0;
														 for(int k=0; k<C1CirInEdgeCount; k++){
															 if(C1CirInPoint[k].x   ==0.0f             || C1CirInPoint[k].y                ==0.0f) continue;
															 if(C1CirOutPoint[GrindMarkOutCnt].x==0.0f || C1CirOutPoint[GrindMarkOutCnt].y ==0.0f) continue;

															 GrindMeaDis = Math.GetLength(C1CirOutPoint[GrindMarkOutCnt], C1CirInPoint[k]);
															 if(GrindMeaDis<MinDis){
																 MinDis = GrindMeaDis;
																 GrindMarkInCnt = k;
															 }
														 }
													 }

													 // GrindMark기준 수직 포인트 주변값 Avg산출한다 ==>연마량 측정(OutData,InData기준)
													 if((GrindMarkOutCnt!=0 && GrindMarkOutCnt>5) && (GrindMarkInCnt!=0 && GrindMarkInCnt>5)){
														 CircleCount=0,TotalCirDis=0.0f,GrindWidthDis=0.0f;
														 for(int k=-5; k<5; k++){
															 if(C1CirOutPoint[GrindMarkOutCnt+k].x==0.0f && C1CirOutPoint[GrindMarkOutCnt+k].y==0.0f) continue;
															 if(C1CirInPoint [GrindMarkInCnt +k].x==0.0f && C1CirInPoint [GrindMarkInCnt +k].y==0.0f) continue;
															 if((GrindMarkOutCnt+k)>=C1CirOutEdgeCount                                              ) continue;
															 if((GrindMarkInCnt +k)>=C1CirInEdgeCount                                               ) continue;

															 GrindWidthDis = Math.GetLength(C1CirInPoint[GrindMarkInCnt+k], C1CirOutPoint[GrindMarkOutCnt+k]);
															 TotalCirDis+=   GrindWidthDis;
															 CircleCount++;
														 }
														 if(TotalCirDis!=0.0f && CircleCount!=0){
															 C0CirGrindWd = TotalCirDis/CircleCount;
															 C0CirGrindWd = C0CirGrindWd+0.5; //SubPixel
														 }
													 }
												 }

												 // GrindMark[1] 기준으로 연마량,가공량 측정 시퀀스 
												 //////////////////////////////////////////////////////////////////////////////////////
												 if(GrindMarkPoint[1].x!=0.0f && GrindMarkPoint[1].y!=0.0f){  //GrindMark 찾았을경우 
													 // GrindMark기준 OutData 최단거리 Count정보 Calc 
													 GrindMeaDis =0.0f, MinDis =10000.0f; GrindMarkOutCnt=0;
													 for(int k=0; k<C1CirOutEdgeCount; k++){
														 if(C1CirOutPoint[k].x ==0.0f || C1CirOutPoint[k].y ==0.0f) continue;
														 if(GrindMarkPoint[1].x==0.0f || GrindMarkPoint[1].y==0.0f) continue;

														 GrindMeaDis = Math.GetLength(GrindMarkPoint[1], C1CirOutPoint[k]);
														 if(GrindMeaDis<MinDis){
															 MinDis = GrindMeaDis;
															 GrindMarkOutCnt = k;
														 }
													 }

													 // GrindMark기준 InData 최단거리 Count정보 Calc 
													 if(GrindMarkOutCnt!=0){
														 GrindMeaDis =0.0f, MinDis =10000.0f; GrindMarkInCnt=0;
														 for(int k=0; k<C1CirInEdgeCount; k++){
															 if(C1CirInPoint[k].x   ==0.0f             || C1CirInPoint[k].y                ==0.0f) continue;
															 if(C1CirOutPoint[GrindMarkOutCnt].x==0.0f || C1CirOutPoint[GrindMarkOutCnt].y ==0.0f) continue;

															 GrindMeaDis = Math.GetLength(C1CirOutPoint[GrindMarkOutCnt], C1CirInPoint[k]);
															 if(GrindMeaDis<MinDis){
																 MinDis = GrindMeaDis;
																 GrindMarkInCnt = k;
															 }
														 }
													 }

													 // GrindMark기준 수직 포인트 주변값 Avg산출한다 ==>가공량 측정(OutData기준)
													 if(GrindMarkOutCnt!=0 && GrindMarkOutCnt>5){
														 CircleCount=0,TotalCirDis=0.0f,GrindMeaDis=0.0f;
														 for(int k=GrindMarkOutCnt-5; k<GrindMarkOutCnt+5; k++){
															 if(C1CirOutPoint[k].x==0.0f || C1CirOutPoint[k].y==0.0f) continue;
															 if(k>=C1CirOutEdgeCount                                ) continue;

															 GrindMeaDis = Math.GetLength(GrindMarkPoint[1], C1CirOutPoint[k]);
															 TotalCirDis+= GrindMeaDis;
															 CircleCount++;
														 }
														 if(TotalCirDis!=0.0f && CircleCount!=0){
															 C1CirGrindMea = TotalCirDis/CircleCount;
															 C1CirGrindMea = C1CirGrindMea+0.5; //SubPixel 
														 }
													 }

													 // GrindMark기준 수직 포인트 주변값 Avg산출한다 ==>연마량 측정(OutData,InData기준)
													 if((GrindMarkOutCnt!=0 && GrindMarkOutCnt>5) && (GrindMarkInCnt!=0 && GrindMarkInCnt>5)){
														 CircleCount=0,TotalCirDis=0.0f,GrindWidthDis=0.0f;
														 for(int k=-5; k<5; k++){
															 if(C1CirOutPoint[GrindMarkOutCnt+k].x==0.0f && C1CirOutPoint[GrindMarkOutCnt+k].y==0.0f) continue;
															 if(C1CirInPoint [GrindMarkInCnt +k].x==0.0f && C1CirInPoint [GrindMarkInCnt +k].y==0.0f) continue;
															 if((GrindMarkOutCnt+k)>=C1CirOutEdgeCount                                              ) continue;
															 if((GrindMarkInCnt +k)>=C1CirInEdgeCount                                               ) continue;

															 GrindWidthDis = Math.GetLength(C1CirInPoint[GrindMarkInCnt+k], C1CirOutPoint[GrindMarkOutCnt+k]);
															 TotalCirDis+=   GrindWidthDis;
															 CircleCount++;
														 }
														 if(TotalCirDis!=0.0f && CircleCount!=0){
															 C1CirGrindWd = TotalCirDis/CircleCount;
															 C1CirGrindWd = C1CirGrindWd+0.5; //SubPixel
														 }
													 }
												 }
												 else if(GrindMarkRect[1].left!=0 && GrindMarkRect[1].top!=0 && GrindMarkRect[1].right!=0 &&GrindMarkRect[1].bottom!=0){  //GrindMark 못 찾았을경우
													 // OutData기준 최소값 데이터 Count산출 
													 GrindMeaDis =0.0f, MinDis =10000.0f; GrindMarkOutCnt=0;
													 for(int k=0; k<C1CirOutEdgeCount; k++){
														 if(C1CirOutPoint[k].x==0.0f || C1CirOutPoint[k].y==0.0f) continue;

														 GrindMarkRectCenter[1].x = GrindMarkRect[1].left + (GrindMarkRect[1].right  - GrindMarkRect[1].left)/2; 
														 GrindMarkRectCenter[1].y = GrindMarkRect[1].top  + (GrindMarkRect[1].bottom - GrindMarkRect[1].top )/2; 

														 GrindMeaDis = Math.GetLength(GrindMarkRectCenter[1], C1CirOutPoint[k]);
														 if(GrindMeaDis<MinDis){
															 MinDis = GrindMeaDis;
															 GrindMarkOutCnt = k;
														 }
													 }

													 // 최단거리OUtCount기준 InData 최단거리 Count정보 Calc 
													 if(GrindMarkOutCnt!=0){
														 GrindMeaDis =0.0f, MinDis =10000.0f; GrindMarkInCnt=0;
														 for(int k=0; k<C1CirInEdgeCount; k++){
															 if(C1CirInPoint[k].x   ==0.0f             || C1CirInPoint[k].y                ==0.0f) continue;
															 if(C1CirOutPoint[GrindMarkOutCnt].x==0.0f || C1CirOutPoint[GrindMarkOutCnt].y ==0.0f) continue;

															 GrindMeaDis = Math.GetLength(C1CirOutPoint[GrindMarkOutCnt], C1CirInPoint[k]);
															 if(GrindMeaDis<MinDis){
																 MinDis = GrindMeaDis;
																 GrindMarkInCnt = k;
															 }
														 }
													 }

													 // GrindMark기준 수직 포인트 주변값 Avg산출한다 ==>연마량 측정(OutData,InData기준)
													 if((GrindMarkOutCnt!=0 && GrindMarkOutCnt>5) && (GrindMarkInCnt!=0 && GrindMarkInCnt>5)){
														 CircleCount=0,TotalCirDis=0.0f,GrindWidthDis=0.0f;
														 for(int k=-5; k<5; k++){
															 if(C1CirOutPoint[GrindMarkOutCnt+k].x==0.0f && C1CirOutPoint[GrindMarkOutCnt+k].y==0.0f) continue;
															 if(C1CirInPoint [GrindMarkInCnt +k].x==0.0f && C1CirInPoint [GrindMarkInCnt +k].y==0.0f) continue;
															 if((GrindMarkOutCnt+k)>=C1CirOutEdgeCount                                              ) continue;
															 if((GrindMarkInCnt +k)>=C1CirInEdgeCount                                               ) continue;

															 GrindWidthDis = Math.GetLength(C1CirInPoint[GrindMarkInCnt+k], C1CirOutPoint[GrindMarkOutCnt+k]);
															 TotalCirDis+=   GrindWidthDis;
															 CircleCount++;
														 }
														 if(TotalCirDis!=0.0f && CircleCount!=0){
															 C1CirGrindWd = TotalCirDis/CircleCount;
															 C1CirGrindWd = C1CirGrindWd+0.5; //SubPixel
														 }
													 }
												 }
											 }
										 }
										 else         { //Polygon EnCap 계산시 OutPoint 중간값 기준 실측 거리 평균값을 계산한다(LeftTop) 
											 if(C1CirInEdgeCount!=0 && C1CirOutEdgeCount!=0){
												 GrindMeaDis =0.0f, MinDis =10000.0f; GrindMarkOutCnt=0;
												 GrindMarkOutCnt = (int)(C1CirOutEdgeCount/2);
												 // 최단거리OUtCount기준 InData 최단거리 Count정보 Calc 
												 if(GrindMarkOutCnt!=0){
													 GrindMeaDis =0.0f, MinDis =10000.0f; GrindMarkInCnt=0;
													 for(int k=0; k<C1CirInEdgeCount; k++){
														 if(C1CirInPoint[k].x   ==0.0f             || C1CirInPoint[k].y                ==0.0f) continue;
														 if(C1CirOutPoint[GrindMarkOutCnt].x==0.0f || C1CirOutPoint[GrindMarkOutCnt].y ==0.0f) continue;

														 GrindMeaDis = Math.GetLength(C1CirOutPoint[GrindMarkOutCnt], C1CirInPoint[k]);
														 if(GrindMeaDis<MinDis){
															 MinDis = GrindMeaDis;
															 GrindMarkInCnt = k;
														 }
													 }
												 }

												 // GrindMark기준 수직 포인트 주변값 Avg산출한다 ==>연마량 측정(OutData,InData기준)
												 if((GrindMarkOutCnt!=0 && GrindMarkOutCnt>5) && (GrindMarkInCnt!=0 && GrindMarkInCnt>5)){
													 CircleCount=0,TotalCirDis=0.0f,GrindWidthDis=0.0f;
													 for(int k=-5; k<5; k++){
														 if(C1CirOutPoint[GrindMarkOutCnt+k].x==0.0f && C1CirOutPoint[GrindMarkOutCnt+k].y==0.0f) continue;
														 if(C1CirInPoint [GrindMarkInCnt +k].x==0.0f && C1CirInPoint [GrindMarkInCnt +k].y==0.0f) continue;
														 if((GrindMarkOutCnt+k)>=C1CirOutEdgeCount                                              ) continue;
														 if((GrindMarkInCnt +k)>=C1CirInEdgeCount                                               ) continue;

														 GrindWidthDis = Math.GetLength(C1CirInPoint[GrindMarkInCnt+k], C1CirOutPoint[GrindMarkOutCnt+k]);
														 TotalCirDis+=   GrindWidthDis;
														 CircleCount++;
													 }
													 if(TotalCirDis!=0.0f && CircleCount!=0){
														 C1CirGrindWd = TotalCirDis/CircleCount;
														 C1CirGrindWd = C1CirGrindWd+0.5; //SubPixel
													 }
												 }
											 }
										 }
										 ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
										 // FAVION Circle Fitting 결과물(Circle_1)
										 SampleSize   = C1CirInEdgeCount*0.75; //0.5~0.8이하로 입력할것
										 DistDevRatio = 0.15                 ; //0.1~0.25 이하로 입력할것
										 CircleFit->OnRansac(C1CirInPoint,C1CirInEdgeCount,SampleSize,DistDevRatio,&CircleFit1Center,&CirFitDiameter1);

										 // Polygon 박리 검사 시퀀스 
										 if(!IsMarkBtm && BrokenThresHold!=0){
											 RotateBrokenImg.SetSize(RotateImg.GetWidth(), RotateImg.GetHeight());
											 EasyImage::Oper(EArithmeticLogicOperation_Copy,&RotateImg,&RotateBrokenImg);
											 EasyImage::Threshold(&RotateImg,&RotateBrokenImg, BrokenThresHold);
											 Edge->GImage = &RotateBrokenImg;
											 Edge->SetEdgeType(0);
// 											 RotateBrokenImg.Save("D:\\ROTATE_IMG\\Polygon_박리.bmp");

											 int DvCnt =0, DataCount=0;
											 double deg =0.0f; 
											 TFPoint Target(0.0f, 0.0f);

											 if(GrindMarkInCnt>GrindMarkOutCnt){
												 DvCnt = GrindMarkInCnt - GrindMarkOutCnt;
												 for(int k=0; k<C1CirOutEdgeCount; k++){
													 deg =0.0f, Target.x =0.0f, Target.y =0.0f;
													 if(((k+DvCnt)<C1CirInEdgeCount) && C1CirInPoint[k+DvCnt].x>0  && C1CirInPoint[k+DvCnt].y>0){
														 deg = Math.GetDegree(C1CirOutPoint[k],C1CirInPoint[k+DvCnt]);

														 Target  = Math.OnFindPerpendicularPointXY(C1CirOutPoint[k],dEdgeToTrapLineDis,-dEdgeToTrapLineDis,deg);
														 Edge->OnExecute(C1CirOutPoint[k],Target); // 연마외곽라인에서 Target까지 White Point Search 
														 if(Edge->GetResultEdgePointCount()>0){
															 C1CircleData[DataCount].Dis =0.0f;
															 C1CircleData[DataCount].Dv  =0.0f;
															 C1CircleData[DataCount].P   = Edge->GetResultEdgePoint(0);
															 C1CircleData[DataCount].P.y = C1CircleData[DataCount].P.y - ImageHeight; // Frame기준 단위좌표로 변경함  
															 DataCount++;
														 }
													 }
												 }
												 C1CirInCrackCount = DataCount;
											 }
											 else if(GrindMarkInCnt<GrindMarkOutCnt)   {
												 DvCnt = GrindMarkOutCnt - GrindMarkInCnt;
												 for(int k=DvCnt; k<C1CirOutEdgeCount; k++){
													 deg =0.0f, Target.x =0.0f, Target.y =0.0f;
													 if(((k-DvCnt)<C1CirInEdgeCount) && C1CirInPoint[k-DvCnt].x>0  && C1CirInPoint[k-DvCnt].y>0 && k-DvCnt>=0){
														 deg = Math.GetDegree(C1CirOutPoint[k],C1CirInPoint[k-DvCnt]);

														 Target  = Math.OnFindPerpendicularPointXY(C1CirOutPoint[k],dEdgeToTrapLineDis,-dEdgeToTrapLineDis,deg);
														 Edge->OnExecute(C1CirOutPoint[k],Target); // 연마외곽라인에서 Target까지 White Point Search 
														 if(Edge->GetResultEdgePointCount()>0){
															 C1CircleData[DataCount].Dis =0.0f;
															 C1CircleData[DataCount].Dv  =0.0f;
															 C1CircleData[DataCount].P   = Edge->GetResultEdgePoint(0);
															 C1CircleData[DataCount].P.y = C1CircleData[DataCount].P.y - ImageHeight; // Frame기준 단위좌표로 변경함  
															 DataCount++;
														 }
													 }
												 }
												 C1CirInCrackCount = DataCount;
											 }
										 }
										 LogUnit.SetLog(L"CellID:%d, CamID:%d ==>Polygon1_Insp_End",CellId,CamId);
									 }

									 // 두번째 Polygon, Circle 1
									 if(PolyRect[1].left!=0 && PolyRect[1].top!=0 && PolyRect[1].right!=0 && PolyRect[1].bottom!=0){
										 P1.x=0, P1.y=0, P2.x=0, P2.y=0, P3.x=0, P3.y=0, P4.x=0, P4.y=0;
										 LogUnit.SetLog(L"CellID:%d, CamID:%d ==>Polygon2_Insp_Start",CellId,CamId);


// 										 P1.x = (PolyRect[1].left); P1.y =(PolyRect[1].top             ); P2.x = (P1.x+PolyRect[1].Width()+50); P2.y = (P1.y);
// 										 P3.x = (PolyRect[1].left); P3.y =(P1.y+PolyRect[1].Height()+50); P4.x = (P2.x                       ); P4.y = (P3.y);

										 P1.x = (PolyRect[1].left); P1.y =(PolyRect[1].top             ); P2.x = (P1.x+PolyRect[1].Width()); P2.y = (P1.y);
										 P3.x = (PolyRect[1].left); P3.y =(P1.y+PolyRect[1].Height()+20); P4.x = (P2.x                    ); P4.y = (P3.y);


										 // Median Filter 적용 
										 if(P1.x<=0    || P1.y<=0    || (P2.x - P1.x)<=0    || (P3.y - P1.y)<=0   ) return false;
										 if(P1.x>=ImgW || P1.y>=ImgH || (P2.x - P1.x)>=ImgW || (P3.y - P1.y)>=ImgH) return false;
										 FilterROI.SetSize(int(P2.x - P1.x),int(P3.y - P1.y) )                 ;
										 FilterROI.Attach(&RotateBinaryImg)                                    ;
										 FilterROI.SetPlacement(P1.x, P1.y, int(P2.x - P1.x), int(P3.y - P1.y));
										 EasyImage::Median(&FilterROI, &FilterROI)                             ;
// 										 RotateBinaryImg.Save("D:\\ROTATE_IMG\\Polygon2_필터.bmp");



										 Polygon->GImage          = &RotateBinaryImg            ;
										 Polygon->PoPa.FMaxWidth  =(int)(CenterCircleWidth +200);
										 Polygon->PoPa.FMaxHeight =(int)(CenterCircleHeight+200);
										 Polygon->PoPa.IsSeparate =true                         ;
										 Polygon->PoPa.IsInToOut  =true                         ;
										 Polygon->PoPa.HiThHold   = BtmEdgeThresHold            ;
										 Polygon->PoPa.LoThHold   = 0                           ;
										 Polygon->PoPa.FMinWidth  =(int)(CenterCircleWidth /3)  ;
										 Polygon->PoPa.FMinHeight =(int)(CenterCircleHeight/3)  ;


										 if(P1.x!=0 && P1.y!=0 && P2.x!=0 && P2.y!=0 && P3.x!=0 && P3.y!=0 && P4.x!=0 && P4.y!=0){
											 Polygon->OnExecute(P1,P2,P3,P4);
										 }

										 // Polygon Algorithm InEdgeData/OutEdgeData Separate 및 데이터 추출 
										 if(Polygon->BlobCount==1){
											 PolygonMarginCnt =10;
											 if(Polygon->Blob[0].InCnt>(PolygonMarginCnt*2)){
												 C2CirInEdgeCount=0;
												 C2CirInEdgeCount = (Polygon->Blob[0].InCnt - (PolygonMarginCnt*2));
												 if(C2CirInEdgeCount>0){
													 if(C2CirInPoint!=NULL){
														 delete[] C2CirInPoint;
													 }
													 C2CirInPoint = new TFPoint[C2CirInEdgeCount];

													 PixelCnt=0;
													 for(int k=0; k<Polygon->Blob[0].InCnt; k++){
														 if(k<PolygonMarginCnt || k>=(Polygon->Blob[0].InCnt-PolygonMarginCnt)) continue;
														 C2CirInPoint[PixelCnt].x   = Polygon->Blob[0].InPoint[k].x ;
														 C2CirInPoint[PixelCnt].y   = Polygon->Blob[0].InPoint[k].y ;
														 PixelCnt++;
													 }
												 }
											 }

											 if(Polygon->Blob[0].OutCnt>(PolygonMarginCnt*2)){
												 C2CirOutEdgeCount=0;
												 C2CirOutEdgeCount = (Polygon->Blob[0].OutCnt - (PolygonMarginCnt*2));
												 if(C2CirOutEdgeCount>0){
													 if(C2CirOutPoint!=NULL) delete[] C2CirOutPoint;
													 C2CirOutPoint = new TFPoint[C2CirOutEdgeCount];

													 PixelCnt=0;
													 for(int k=0; k<Polygon->Blob[0].OutCnt; k++){
														 if(k<PolygonMarginCnt || k>=(Polygon->Blob[0].OutCnt-PolygonMarginCnt)) continue;
														 C2CirOutPoint[PixelCnt].x  = Polygon->Blob[0].OutPoint[k].x ;
														 C2CirOutPoint[PixelCnt].y  = Polygon->Blob[0].OutPoint[k].y ;

														 if(k==PolygonMarginCnt)                              { //직선구간에 필요한 시작점  
															 BtmEdgePoint[1].x = C2CirOutPoint[PixelCnt].x;
															 BtmEdgePoint[1].y = C2CirOutPoint[PixelCnt].y;
														 }
														 if(k==(Polygon->Blob[0].OutCnt-(PolygonMarginCnt+1))){ //직선구간에 필요한 끝점 
															 BtmEdgePoint[2].x = C2CirOutPoint[PixelCnt].x;
															 BtmEdgePoint[2].y = C2CirOutPoint[PixelCnt].y;
														 }
														 PixelCnt++;
													 }
												 }
											 }
											 // Polygon Data Clear
// 											 Polygon->ClearData();
										 }
										 /////////////////////////////////////////////////////////////////////////////////////////////

										 // InEdgeData/OutEdgeData 기준 가공량 및 연마량 계산
										 // Polygon 알고리즘에서는 GrindMark기준 OutData,InData 최단거리 2개 Tag값 산출해야함 
										 if(IsMarkBtm){ // LTPS 가공량,연마량 계산 
											 if(C2CirOutEdgeCount!=0 && C2CirInEdgeCount!=0){ // MarkMode경우 가공량 검사를 먼저 진행 후 연마량 산출  
												 // 가공량,연마량 측정 전 데이터 존재시 가상GrindMark 생성한다 
												 if(GrindMarkPoint[5].x!=0.0f && GrindMarkPoint[5].y!=0.0f && GrindRectSpec[6].DvX!=0.0f && GrindRectSpec[6].DvY!=0.0f){
													 GrindMarkPoint[6].x     = GrindMarkPoint[5].x + GrindRectSpec[6].DvX;
													 GrindMarkPoint[6].y     = GrindMarkPoint[5].y - GrindRectSpec[6].DvY;
													 GrindMarkRect [6].left  = GrindMarkPoint[6].x    - GrindMarkRange  ;  
													 GrindMarkRect [6].top   = GrindMarkPoint[6].y    - GrindMarkRange  ;  
													 GrindMarkRect [6].right = GrindMarkRect [6].left + GrindMarkLength ;  
													 GrindMarkRect [6].bottom= GrindMarkRect [6].top  + GrindMarkLength ;  
												 }

												 if(GrindMarkPoint[5].x!=0.0f && GrindMarkPoint[5].y!=0.0f){  //GrindMark 찾았을경우 
													 // GrindMark기준 OutData 최단거리 Count정보 Calc 
													 GrindMeaDis =0.0f, MinDis =10000.0f; GrindMarkOutCnt=0;
													 for(int k=0; k<C2CirOutEdgeCount; k++){
														 if(C2CirOutPoint[k].x ==0.0f || C2CirOutPoint[k].y ==0.0f) continue;
														 if(GrindMarkPoint[5].x==0.0f || GrindMarkPoint[5].y==0.0f) continue;

														 GrindMeaDis = Math.GetLength(GrindMarkPoint[5], C2CirOutPoint[k]);
														 if(GrindMeaDis<MinDis){
															 MinDis = GrindMeaDis;
															 GrindMarkOutCnt = k;
														 }
													 }

													 // GrindMark기준 InData 최단거리 Count정보 Calc 
													 if(GrindMarkOutCnt!=0){
														 GrindMeaDis =0.0f, MinDis =10000.0f; GrindMarkInCnt=0;
														 for(int k=0; k<C2CirInEdgeCount; k++){
															 if(C2CirInPoint[k].x   ==0.0f             || C2CirInPoint[k].y                ==0.0f) continue;
															 if(C2CirOutPoint[GrindMarkOutCnt].x==0.0f || C2CirOutPoint[GrindMarkOutCnt].y ==0.0f) continue;

															 GrindMeaDis = Math.GetLength(C2CirOutPoint[GrindMarkOutCnt], C2CirInPoint[k]);
															 if(GrindMeaDis<MinDis){
																 MinDis = GrindMeaDis;
																 GrindMarkInCnt = k;
															 }
														 }
													 }

													 // GrindMark기준 수직 포인트 주변값 Avg산출한다 ==>가공량 측정(OutData기준)
													 if(GrindMarkOutCnt!=0 && GrindMarkOutCnt>5){
														 CircleCount=0,TotalCirDis=0.0f,GrindMeaDis=0.0f;
														 for(int k=GrindMarkOutCnt-5; k<GrindMarkOutCnt+5; k++){
															 if(C2CirOutPoint[k].x==0.0f || C2CirOutPoint[k].y==0.0f) continue;
															 if(k>=C2CirOutEdgeCount                                ) continue;

															 GrindMeaDis = Math.GetLength(GrindMarkPoint[5], C2CirOutPoint[k]);
															 TotalCirDis+= GrindMeaDis;
															 CircleCount++;
														 }
														 if(TotalCirDis!=0.0f && CircleCount!=0){
															 C2CirGrindMea = TotalCirDis/CircleCount;
															 C2CirGrindMea = C2CirGrindMea+0.5; //SubPixel 
														 }
													 }

													 // GrindMark기준 수직 포인트 주변값 Avg산출한다 ==>연마량 측정(OutData,InData기준)
													 if((GrindMarkOutCnt!=0 && GrindMarkOutCnt>5) && (GrindMarkInCnt!=0 && GrindMarkInCnt>5)){
														 CircleCount=0,TotalCirDis=0.0f,GrindWidthDis=0.0f;
														 for(int k=-5; k<5; k++){
															 if(C2CirOutPoint[GrindMarkOutCnt+k].x==0.0f && C2CirOutPoint[GrindMarkOutCnt+k].y==0.0f) continue;
															 if(C2CirInPoint [GrindMarkInCnt +k].x==0.0f && C2CirInPoint [GrindMarkInCnt +k].y==0.0f) continue;
															 if((GrindMarkOutCnt+k)>=C2CirOutEdgeCount                                              ) continue;
															 if((GrindMarkInCnt +k)>=C2CirInEdgeCount                                               ) continue;

															 GrindWidthDis = Math.GetLength(C2CirInPoint[GrindMarkInCnt+k], C2CirOutPoint[GrindMarkOutCnt+k]);
															 TotalCirDis+=   GrindWidthDis;
															 CircleCount++;
														 }
														 if(TotalCirDis!=0.0f && CircleCount!=0){
															 C2CirGrindWd = TotalCirDis/CircleCount;
															 C2CirGrindWd = C2CirGrindWd+0.5; //SubPixel
														 }
													 }
												 }
												 else if(GrindMarkRect[5].left!=0 && GrindMarkRect[5].top!=0 && GrindMarkRect[5].right!=0 &&GrindMarkRect[5].bottom!=0){  //GrindMark 못 찾았을경우
													 // OutData기준 최소값 데이터 Count산출 
													 GrindMeaDis =0.0f, MinDis =10000.0f; GrindMarkOutCnt=0;
													 for(int k=0; k<C2CirOutEdgeCount; k++){
														 if(C2CirOutPoint[k].x==0.0f || C2CirOutPoint[k].y==0.0f) continue;

														 GrindMarkRectCenter[5].x = GrindMarkRect[5].left + (GrindMarkRect[5].right  - GrindMarkRect[5].left)/2; 
														 GrindMarkRectCenter[5].y = GrindMarkRect[5].top  + (GrindMarkRect[5].bottom - GrindMarkRect[5].top )/2; 

														 GrindMeaDis = Math.GetLength(GrindMarkRectCenter[5], C2CirOutPoint[k]);
														 if(GrindMeaDis<MinDis){
															 MinDis = GrindMeaDis;
															 GrindMarkOutCnt = k;
														 }
													 }

													 // 최단거리OUtCount기준 InData 최단거리 Count정보 Calc 
													 if(GrindMarkOutCnt!=0){
														 GrindMeaDis =0.0f, MinDis =10000.0f; GrindMarkInCnt=0;
														 for(int k=0; k<C2CirInEdgeCount; k++){
															 if(C2CirInPoint[k].x   ==0.0f             || C2CirInPoint[k].y                ==0.0f) continue;
															 if(C2CirOutPoint[GrindMarkOutCnt].x==0.0f || C2CirOutPoint[GrindMarkOutCnt].y ==0.0f) continue;

															 GrindMeaDis = Math.GetLength(C2CirOutPoint[GrindMarkOutCnt], C2CirInPoint[k]);
															 if(GrindMeaDis<MinDis){
																 MinDis = GrindMeaDis;
																 GrindMarkInCnt = k;
															 }
														 }
													 }

													 // GrindMark기준 수직 포인트 주변값 Avg산출한다 ==>연마량 측정(OutData,InData기준)
													 if((GrindMarkOutCnt!=0 && GrindMarkOutCnt>5) && (GrindMarkInCnt!=0 && GrindMarkInCnt>5)){
														 CircleCount=0,TotalCirDis=0.0f,GrindWidthDis=0.0f;
														 for(int k=-5; k<5; k++){
															 if(C2CirOutPoint[GrindMarkOutCnt+k].x==0.0f && C2CirOutPoint[GrindMarkOutCnt+k].y==0.0f) continue;
															 if(C2CirInPoint [GrindMarkInCnt +k].x==0.0f && C2CirInPoint [GrindMarkInCnt +k].y==0.0f) continue;
															 if((GrindMarkOutCnt+k)>=C2CirOutEdgeCount                                              ) continue;
															 if((GrindMarkInCnt +k)>=C2CirInEdgeCount                                               ) continue;

															 GrindWidthDis = Math.GetLength(C2CirInPoint[GrindMarkInCnt+k], C2CirOutPoint[GrindMarkOutCnt+k]);
															 TotalCirDis+=   GrindWidthDis;
															 CircleCount++;
														 }
														 if(TotalCirDis!=0.0f && CircleCount!=0){
															 C2CirGrindWd = TotalCirDis/CircleCount;
															 C2CirGrindWd = C2CirGrindWd+0.5; //SubPixel
														 }
													 }
												 }

												 // Grind Mark[6] 가상 마크 데이터 생성 
												 if(GrindMarkPoint[6].x!=0.0f && GrindMarkPoint[6].y!=0.0f){  //GrindMark 찾았을경우 
													 // GrindMark기준 OutData 최단거리 Count정보 Calc 
													 GrindMeaDis =0.0f, MinDis =10000.0f; GrindMarkOutCnt=0;
													 for(int k=0; k<C2CirOutEdgeCount; k++){
														 if(C2CirOutPoint[k].x ==0.0f || C2CirOutPoint[k].y ==0.0f) continue;
														 if(GrindMarkPoint[6].x==0.0f || GrindMarkPoint[6].y==0.0f) continue;

														 GrindMeaDis = Math.GetLength(GrindMarkPoint[6], C2CirOutPoint[k]);
														 if(GrindMeaDis<MinDis){
															 MinDis = GrindMeaDis;
															 GrindMarkOutCnt = k;
														 }
													 }

													 // GrindMark기준 InData 최단거리 Count정보 Calc 
													 if(GrindMarkOutCnt!=0){
														 GrindMeaDis =0.0f, MinDis =10000.0f; GrindMarkInCnt=0;
														 for(int k=0; k<C2CirInEdgeCount; k++){
															 if(C2CirInPoint[k].x   ==0.0f             || C2CirInPoint[k].y                ==0.0f) continue;
															 if(C2CirOutPoint[GrindMarkOutCnt].x==0.0f || C2CirOutPoint[GrindMarkOutCnt].y ==0.0f) continue;

															 GrindMeaDis = Math.GetLength(C2CirOutPoint[GrindMarkOutCnt], C2CirInPoint[k]);
															 if(GrindMeaDis<MinDis){
																 MinDis = GrindMeaDis;
																 GrindMarkInCnt = k;
															 }
														 }
													 }

													 // GrindMark기준 수직 포인트 주변값 Avg산출한다 ==>가공량 측정(OutData기준)
													 if(GrindMarkOutCnt!=0 && GrindMarkOutCnt>5){
														 CircleCount=0,TotalCirDis=0.0f,GrindMeaDis=0.0f;
														 for(int k=GrindMarkOutCnt-5; k<GrindMarkOutCnt+5; k++){
															 if(C2CirOutPoint[k].x==0.0f || C2CirOutPoint[k].y==0.0f) continue;
															 if(k>=C2CirOutEdgeCount                                ) continue;

															 GrindMeaDis = Math.GetLength(GrindMarkPoint[6], C2CirOutPoint[k]);
															 TotalCirDis+= GrindMeaDis;
															 CircleCount++;
														 }
														 if(TotalCirDis!=0.0f && CircleCount!=0){
															 TrenchLeftGrindMea = TotalCirDis/CircleCount;
															 TrenchLeftGrindMea = TrenchLeftGrindMea+0.5; //SubPixel 
														 }
													 }

													 // GrindMark기준 수직 포인트 주변값 Avg산출한다 ==>연마량 측정(OutData,InData기준)
													 if((GrindMarkOutCnt!=0 && GrindMarkOutCnt>5) && (GrindMarkInCnt!=0 && GrindMarkInCnt>5)){
														 CircleCount=0,TotalCirDis=0.0f,GrindWidthDis=0.0f;
														 for(int k=-5; k<5; k++){
															 if(C2CirOutPoint[GrindMarkOutCnt+k].x==0.0f && C2CirOutPoint[GrindMarkOutCnt+k].y==0.0f) continue;
															 if(C2CirInPoint [GrindMarkInCnt +k].x==0.0f && C2CirInPoint [GrindMarkInCnt +k].y==0.0f) continue;
															 if((GrindMarkOutCnt+k)>=C2CirOutEdgeCount                                              ) continue;
															 if((GrindMarkInCnt +k)>=C2CirInEdgeCount                                               ) continue;

															 GrindWidthDis = Math.GetLength(C2CirInPoint[GrindMarkInCnt+k], C2CirOutPoint[GrindMarkOutCnt+k]);
															 TotalCirDis+=   GrindWidthDis;
															 CircleCount++;
														 }
														 if(TotalCirDis!=0.0f && CircleCount!=0){
															 TrenchLeftGrindWd = TotalCirDis/CircleCount;
															 TrenchLeftGrindWd = TrenchLeftGrindWd+0.5; //SubPixel
														 }
													 }
												 }
												 else if(GrindMarkRect[6].left!=0 && GrindMarkRect[6].top!=0 && GrindMarkRect[6].right!=0 &&GrindMarkRect[6].bottom!=0){  //GrindMark 못 찾았을경우
													 // OutData기준 최소값 데이터 Count산출 
													 if(GrindRectSpec[6].DvX!=0.0f && GrindRectSpec[6].DvY!=0.0f){
														 GrindMeaDis =0.0f, MinDis =10000.0f; GrindMarkOutCnt=0;
														 for(int k=0; k<C2CirOutEdgeCount; k++){
															 if(C2CirOutPoint[k].x==0.0f || C2CirOutPoint[k].y==0.0f) continue;

															 if(k==0){
																 GrindMarkRectCenter[6].x     =  GrindMarkRectCenter[5].x + GrindRectSpec[6].DvX;
																 GrindMarkRectCenter[6].y     =  GrindMarkRectCenter[5].y - GrindRectSpec[6].DvY;

																 GrindMarkRect [6].left  = GrindMarkRectCenter[6].x  - GrindMarkRange  ;  
																 GrindMarkRect [6].top   = GrindMarkRectCenter[6].y  - GrindMarkRange  ;  
																 GrindMarkRect [6].right = GrindMarkRect [6].left + GrindMarkLength ;  
																 GrindMarkRect [6].bottom= GrindMarkRect [6].top  + GrindMarkLength ;  
															 }

															 GrindMeaDis = Math.GetLength(GrindMarkRectCenter[6], C2CirOutPoint[k]);
															 if(GrindMeaDis<MinDis){
																 MinDis = GrindMeaDis;
																 GrindMarkOutCnt = k;
															 }
														 }

														 // 최단거리OUtCount기준 InData 최단거리 Count정보 Calc 
														 if(GrindMarkOutCnt!=0){
															 GrindMeaDis =0.0f, MinDis =10000.0f; GrindMarkInCnt=0;
															 for(int k=0; k<C2CirInEdgeCount; k++){
																 if(C2CirInPoint[k].x   ==0.0f             || C2CirInPoint[k].y                ==0.0f) continue;
																 if(C2CirOutPoint[GrindMarkOutCnt].x==0.0f || C2CirOutPoint[GrindMarkOutCnt].y ==0.0f) continue;

																 GrindMeaDis = Math.GetLength(C2CirOutPoint[GrindMarkOutCnt], C2CirInPoint[k]);
																 if(GrindMeaDis<MinDis){
																	 MinDis = GrindMeaDis;
																	 GrindMarkInCnt = k;
																 }
															 }
														 }

														 // GrindMark기준 수직 포인트 주변값 Avg산출한다 ==>연마량 측정(OutData,InData기준)
														 if((GrindMarkOutCnt!=0 && GrindMarkOutCnt>5) && (GrindMarkInCnt!=0 && GrindMarkInCnt>5)){
															 CircleCount=0,TotalCirDis=0.0f,GrindWidthDis=0.0f;
															 for(int k=-5; k<5; k++){
																 if(C2CirOutPoint[GrindMarkOutCnt+k].x==0.0f && C2CirOutPoint[GrindMarkOutCnt+k].y==0.0f) continue;
																 if(C2CirInPoint [GrindMarkInCnt +k].x==0.0f && C2CirInPoint [GrindMarkInCnt +k].y==0.0f) continue;
																 if((GrindMarkOutCnt+k)>=C2CirOutEdgeCount                                              ) continue;
																 if((GrindMarkInCnt +k)>=C2CirInEdgeCount                                               ) continue;

																 GrindWidthDis = Math.GetLength(C2CirInPoint[GrindMarkInCnt+k], C2CirOutPoint[GrindMarkOutCnt+k]);
																 TotalCirDis+=   GrindWidthDis;
																 CircleCount++;
															 }
															 if(TotalCirDis!=0.0f && CircleCount!=0){
																 TrenchLeftGrindWd = TotalCirDis/CircleCount;
																 TrenchLeftGrindWd = TrenchLeftGrindWd+0.5; //SubPixel
															 }
														 }
													 }
												 }
											 }
										 }
										 else         { //Polygon EnCap 계산시 OutPoint 중간값 기준 실측 거리 평균값을 계산한다(LeftTop) 
											 if(C2CirInEdgeCount!=0 && C2CirOutEdgeCount!=0){
												 GrindMeaDis =0.0f, MinDis =10000.0f; GrindMarkOutCnt=0;
												 GrindMarkOutCnt = (int)(C2CirOutEdgeCount/2);
												 // 최단거리OUtCount기준 InData 최단거리 Count정보 Calc 
												 if(GrindMarkOutCnt!=0){
													 GrindMeaDis =0.0f, MinDis =10000.0f; GrindMarkInCnt=0;
													 for(int k=0; k<C2CirInEdgeCount; k++){
														 if(C2CirInPoint[k].x   ==0.0f             || C2CirInPoint[k].y                ==0.0f) continue;
														 if(C2CirOutPoint[GrindMarkOutCnt].x==0.0f || C2CirOutPoint[GrindMarkOutCnt].y ==0.0f) continue;

														 GrindMeaDis = Math.GetLength(C2CirOutPoint[GrindMarkOutCnt], C2CirInPoint[k]);
														 if(GrindMeaDis<MinDis){
															 MinDis = GrindMeaDis;
															 GrindMarkInCnt = k;
														 }
													 }
												 }

												 // GrindMark기준 수직 포인트 주변값 Avg산출한다 ==>연마량 측정(OutData,InData기준)
												 if((GrindMarkOutCnt!=0 && GrindMarkOutCnt>5) && (GrindMarkInCnt!=0 && GrindMarkInCnt>5)){
													 CircleCount=0,TotalCirDis=0.0f,GrindWidthDis=0.0f;
													 for(int k=-5; k<5; k++){
														 if(C2CirOutPoint[GrindMarkOutCnt+k].x==0.0f && C2CirOutPoint[GrindMarkOutCnt+k].y==0.0f) continue;
														 if(C2CirInPoint [GrindMarkInCnt +k].x==0.0f && C2CirInPoint [GrindMarkInCnt +k].y==0.0f) continue;
														 if((GrindMarkOutCnt+k)>=C2CirOutEdgeCount                                              ) continue;
														 if((GrindMarkInCnt +k)>=C2CirInEdgeCount                                               ) continue;

														 GrindWidthDis = Math.GetLength(C2CirInPoint[GrindMarkInCnt+k], C2CirOutPoint[GrindMarkOutCnt+k]);
														 TotalCirDis+=   GrindWidthDis;
														 CircleCount++;
													 }
													 if(TotalCirDis!=0.0f && CircleCount!=0){
														 C2CirGrindWd = TotalCirDis/CircleCount;
														 C2CirGrindWd = C2CirGrindWd+0.5; //SubPixel
													 }
												 }
											 }
										 }
										 ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
										 // FAVION Circle Fitting 결과물(Circle_1)
										 SampleSize   = C2CirInEdgeCount*0.75; //0.5~0.8이하로 입력할것
										 DistDevRatio = 0.15                 ; //0.1~0.25 이하로 입력할것
										 CircleFit->OnRansac(C2CirInPoint,C2CirInEdgeCount,SampleSize,DistDevRatio,&CircleFit2Center,&CirFitDiameter2);

										 // Polygon 박리 검사 시퀀스 
										 if(!IsMarkBtm && BrokenThresHold!=0){
											 RotateBrokenImg.SetSize(RotateImg.GetWidth(), RotateImg.GetHeight());
											 EasyImage::Oper(EArithmeticLogicOperation_Copy,&RotateImg,&RotateBrokenImg);
											 EasyImage::Threshold(&RotateImg,&RotateBrokenImg, BrokenThresHold);
											 Edge->GImage = &RotateBrokenImg;
											 Edge->SetEdgeType(0);

											 int DvCnt =0, DataCount=0;
											 double deg =0.0f; 
											 TFPoint Target(0.0f, 0.0f);

											 if(GrindMarkInCnt>GrindMarkOutCnt){
												 DvCnt = GrindMarkInCnt - GrindMarkOutCnt;
												 for(int k=0; k<C2CirOutEdgeCount; k++){
													 deg =0.0f, Target.x =0.0f, Target.y =0.0f;
													 if(((k+DvCnt)<C2CirInEdgeCount) && C2CirInPoint[k+DvCnt].x>0  && C2CirInPoint[k+DvCnt].y>0){
														 deg = Math.GetDegree(C2CirOutPoint[k],C2CirInPoint[k+DvCnt]);

														 Target  = Math.OnFindPerpendicularPointXY(C2CirOutPoint[k],-dEdgeToTrapLineDis,-dEdgeToTrapLineDis,deg);
														 Edge->OnExecute(C2CirOutPoint[k],Target); // 연마외곽라인에서 Target까지 White Point Search 
														 if(Edge->GetResultEdgePointCount()>0){
															 C2CircleData[DataCount].Dis =0.0f;
															 C2CircleData[DataCount].Dv  =0.0f;
															 C2CircleData[DataCount].P   = Edge->GetResultEdgePoint(0);
															 C2CircleData[DataCount].P.y = C2CircleData[DataCount].P.y - ImageHeight; // Frame기준 단위좌표로 변경함  
															 DataCount++;
														 }
													 }
												 }
												 C2CirInCrackCount = DataCount;
											 }
											 else if(GrindMarkInCnt<GrindMarkOutCnt)   {
												 DvCnt = GrindMarkOutCnt - GrindMarkInCnt;
												 for(int k=DvCnt; k<C2CirOutEdgeCount; k++){
													 deg =0.0f, Target.x =0.0f, Target.y =0.0f;
													 if(((k-DvCnt)<C2CirInEdgeCount) && C2CirInPoint[k-DvCnt].x>0  && C2CirInPoint[k-DvCnt].y>0 && k-DvCnt>=0){
														 deg = Math.GetDegree(C2CirOutPoint[k],C2CirInPoint[k-DvCnt]);

														 Target  = Math.OnFindPerpendicularPointXY(C2CirOutPoint[k],-dEdgeToTrapLineDis,-dEdgeToTrapLineDis,deg);
														 Edge->OnExecute(C2CirOutPoint[k],Target); // 연마외곽라인에서 Target까지 White Point Search 
														 if(Edge->GetResultEdgePointCount()>0){
															 C2CircleData[DataCount].Dis =0.0f;
															 C2CircleData[DataCount].Dv  =0.0f;
															 C2CircleData[DataCount].P   = Edge->GetResultEdgePoint(0);
															 C2CircleData[DataCount].P.y = C2CircleData[DataCount].P.y - ImageHeight; // Frame기준 단위좌표로 변경함  
															 DataCount++;
														 }
													 }
												 }
												 C2CirInCrackCount = DataCount;
											 }
										 }
										 LogUnit.SetLog(L"CellID:%d, CamID:%d ==>Polygon2_Insp_End",CellId,CamId);
									 }

									 // 세번째 Polygon, Circle 1
									 if(PolyRect[2].left!=0 && PolyRect[2].top!=0 && PolyRect[2].right!=0 && PolyRect[2].bottom!=0){
										 P1.x=0, P1.y=0, P2.x=0, P2.y=0, P3.x=0, P3.y=0, P4.x=0, P4.y=0;
										 LogUnit.SetLog(L"CellID:%d, CamID:%d ==>Polygon3_Insp_Start",CellId,CamId);

// 										 P1.x = (PolyRect[2].left-50); P1.y =(PolyRect[2].top-50          ); P2.x = (P1.x+PolyRect[2].Width()+50); P2.y = (P1.y);
// 										 P3.x = (PolyRect[2].left-50); P3.y =(P1.y+PolyRect[2].Height()+50); P4.x = (P2.x                       ); P4.y = (P3.y);

										 P1.x = (PolyRect[2].left); P1.y =(PolyRect[2].top-20          ); P2.x = (P1.x+PolyRect[2].Width()); P2.y = (P1.y);
										 P3.x = (PolyRect[2].left); P3.y =(P1.y+PolyRect[2].Height()+20); P4.x = (P2.x                    ); P4.y = (P3.y);


										 // Median Filter 적용 
										 if(P1.x<=0    || P1.y<=0    || (P2.x - P1.x)<=0    || (P3.y - P1.y)<=0   ) return false;
										 if(P1.x>=ImgW || P1.y>=ImgH || (P2.x - P1.x)>=ImgW || (P3.y - P1.y)>=ImgH) return false;
										 FilterROI.SetSize(int(P2.x - P1.x),int(P3.y - P1.y) )                      ;
										 FilterROI.Attach(&RotateBinaryImg)                                    ;
										 FilterROI.SetPlacement(P1.x, P1.y, int(P2.x - P1.x), int(P3.y - P1.y));
										 EasyImage::Median(&FilterROI, &FilterROI)                             ;
// 										 RotateBinaryImg.Save("D:\\ROTATE_IMG\\Polygon3_필터.bmp")             ;



										 Polygon->GImage          = &RotateBinaryImg            ;
										 Polygon->PoPa.FMaxWidth  =(int)(CenterCircleWidth +200);
										 Polygon->PoPa.FMaxHeight =(int)(CenterCircleHeight+200);
										 Polygon->PoPa.IsSeparate =true                         ;
										 Polygon->PoPa.IsInToOut  =true                         ;
										 Polygon->PoPa.HiThHold   = BtmEdgeThresHold            ;
										 Polygon->PoPa.LoThHold   = 0                           ;
										 Polygon->PoPa.FMinWidth  =(int)(CenterCircleWidth /3)  ;
										 Polygon->PoPa.FMinHeight =(int)(CenterCircleHeight/3)  ;

										 if(P1.x!=0 && P1.y!=0 && P2.x!=0 && P2.y!=0 && P3.x!=0 && P3.y!=0 && P4.x!=0 && P4.y!=0){
											 Polygon->OnExecute(P1,P2,P3,P4);
										 }

										 // Polygon Algorithm InEdgeData/OutEdgeData Separate 및 데이터 추출 
										 if(Polygon->BlobCount==1){
											 PolygonMarginCnt =10;
											 if(Polygon->Blob[0].InCnt>(PolygonMarginCnt*2)){
												 C3CirInEdgeCount=0;
												 C3CirInEdgeCount = (Polygon->Blob[0].InCnt - (PolygonMarginCnt*2));
												 if(C3CirInEdgeCount>0){
													 if(C3CirInPoint!=NULL) {
														 delete[] C3CirInPoint;
													 }
													 C3CirInPoint = new TFPoint[C3CirInEdgeCount];

													 PixelCnt=0;
													 for(int k=0; k<Polygon->Blob[0].InCnt; k++){
														 if(k<PolygonMarginCnt || k>=(Polygon->Blob[0].InCnt-PolygonMarginCnt)) continue;
														 C3CirInPoint[PixelCnt].x   = Polygon->Blob[0].InPoint[k].x ;
														 C3CirInPoint[PixelCnt].y   = Polygon->Blob[0].InPoint[k].y ;
														 PixelCnt++;
													 }
												 }
											 }

											 if(Polygon->Blob[0].OutCnt>(PolygonMarginCnt*2)){
												 C3CirOutEdgeCount=0;
												 C3CirOutEdgeCount = (Polygon->Blob[0].OutCnt - (PolygonMarginCnt*2));
												 if(C3CirOutEdgeCount>0){
													 if(C3CirOutPoint!=NULL) delete[] C3CirOutPoint;
													 C3CirOutPoint = new TFPoint[C3CirOutEdgeCount];

													 PixelCnt=0;
													 for(int k=0; k<Polygon->Blob[0].OutCnt; k++){
														 if(k<PolygonMarginCnt || k>=(Polygon->Blob[0].OutCnt-PolygonMarginCnt)) continue;
														 C3CirOutPoint[PixelCnt].x  = Polygon->Blob[0].OutPoint[k].x ;
														 C3CirOutPoint[PixelCnt].y  = Polygon->Blob[0].OutPoint[k].y ;

														 if(k==PolygonMarginCnt)                              { //직선구간에 필요한 시작점  
															 BtmEdgePoint[3].x = C3CirOutPoint[PixelCnt].x;
															 BtmEdgePoint[3].y = C3CirOutPoint[PixelCnt].y;
														 }
														 if(k==(Polygon->Blob[0].OutCnt-(PolygonMarginCnt+1))){ //직선구간에 필요한 끝점 
															 BtmEdgePoint[4].x = C3CirOutPoint[PixelCnt].x;
															 BtmEdgePoint[4].y = C3CirOutPoint[PixelCnt].y;
														 }
														 PixelCnt++;
													 }
												 }
											 }
											 // Polygon Data Clear
// 											 Polygon->ClearData();
										 }
										 /////////////////////////////////////////////////////////////////////////////////////////////

										 // InEdgeData/OutEdgeData 기준 가공량 및 연마량 계산
										 // Polygon 알고리즘에서는 GrindMark기준 OutData,InData 최단거리 2개 Tag값 산출해야함 
										 if(IsMarkBtm){ // LTPS 가공량,연마량 계산 
											 if(C3CirOutEdgeCount!=0 && C3CirInEdgeCount!=0){ // MarkMode경우 가공량 검사를 먼저 진행 후 연마량 산출  
												 if(GrindMarkPoint[7].x!=0.0f && GrindMarkPoint[7].y!=0.0f){  //GrindMark 찾았을경우 
													 // GrindMark기준 OutData 최단거리 Count정보 Calc 
													 GrindMeaDis =0.0f, MinDis =10000.0f; GrindMarkOutCnt=0;
													 for(int k=0; k<C3CirOutEdgeCount; k++){
														 if(C3CirOutPoint[k].x ==0.0f || C3CirOutPoint[k].y ==0.0f) continue;
														 if(GrindMarkPoint[7].x==0.0f || GrindMarkPoint[7].y==0.0f) continue;

														 GrindMeaDis = Math.GetLength(GrindMarkPoint[7], C3CirOutPoint[k]);
														 if(GrindMeaDis<MinDis){
															 MinDis = GrindMeaDis;
															 GrindMarkOutCnt = k;
														 }
													 }

													 // GrindMark기준 InData 최단거리 Count정보 Calc 
													 if(GrindMarkOutCnt!=0){
														 GrindMeaDis =0.0f, MinDis =10000.0f; GrindMarkInCnt=0;
														 for(int k=0; k<C3CirInEdgeCount; k++){
															 if(C3CirInPoint[k].x   ==0.0f             || C3CirInPoint[k].y                ==0.0f) continue;
															 if(C3CirOutPoint[GrindMarkOutCnt].x==0.0f || C3CirOutPoint[GrindMarkOutCnt].y ==0.0f) continue;

															 GrindMeaDis = Math.GetLength(C3CirOutPoint[GrindMarkOutCnt], C3CirInPoint[k]);
															 if(GrindMeaDis<MinDis){
																 MinDis = GrindMeaDis;
																 GrindMarkInCnt = k;
															 }
														 }
													 }

													 // GrindMark기준 수직 포인트 주변값 Avg산출한다 ==>가공량 측정(OutData기준)
													 if(GrindMarkOutCnt!=0 && GrindMarkOutCnt>5){
														 CircleCount=0,TotalCirDis=0.0f,GrindMeaDis=0.0f;
														 for(int k=GrindMarkOutCnt-5; k<GrindMarkOutCnt+5; k++){
															 if(C3CirOutPoint[k].x==0.0f || C3CirOutPoint[k].y==0.0f) continue;
															 if(k>=C3CirOutEdgeCount                                ) continue;

															 GrindMeaDis = Math.GetLength(GrindMarkPoint[7], C3CirOutPoint[k]);
															 TotalCirDis+= GrindMeaDis;
															 CircleCount++;
														 }
														 if(TotalCirDis!=0.0f && CircleCount!=0){
															 C3CirGrindMea = TotalCirDis/CircleCount;
															 C3CirGrindMea = C3CirGrindMea+0.5; //SubPixel 
														 }
													 }

													 // GrindMark기준 수직 포인트 주변값 Avg산출한다 ==>연마량 측정(OutData,InData기준)
													 if((GrindMarkOutCnt!=0 && GrindMarkOutCnt>5) && (GrindMarkInCnt!=0 && GrindMarkInCnt>5)){
														 CircleCount=0,TotalCirDis=0.0f,GrindWidthDis=0.0f;
														 for(int k=-5; k<5; k++){
															 if(C3CirOutPoint[GrindMarkOutCnt+k].x==0.0f && C3CirOutPoint[GrindMarkOutCnt+k].y==0.0f) continue;
															 if(C3CirInPoint [GrindMarkInCnt +k].x==0.0f && C3CirInPoint [GrindMarkInCnt +k].y==0.0f) continue;
															 if((GrindMarkOutCnt+k)>=C3CirOutEdgeCount                                              ) continue;
															 if((GrindMarkInCnt +k)>=C3CirInEdgeCount                                               ) continue;

															 GrindWidthDis = Math.GetLength(C3CirInPoint[GrindMarkInCnt+k], C3CirOutPoint[GrindMarkOutCnt+k]);
															 TotalCirDis+=   GrindWidthDis;
															 CircleCount++;
														 }
														 if(TotalCirDis!=0.0f && CircleCount!=0){
															 C3CirGrindWd = TotalCirDis/CircleCount;
															 C3CirGrindWd = C3CirGrindWd+0.5; //SubPixel
														 }
													 }
												 }
												 else if(GrindMarkRect[7].left!=0 && GrindMarkRect[7].top!=0 && GrindMarkRect[7].right!=0 &&GrindMarkRect[7].bottom!=0){  //GrindMark 못 찾았을경우
													 // OutData기준 최소값 데이터 Count산출 
													 GrindMeaDis =0.0f, MinDis =10000.0f; GrindMarkOutCnt=0;
													 for(int k=0; k<C3CirOutEdgeCount; k++){
														 if(C3CirOutPoint[k].x==0.0f || C3CirOutPoint[k].y==0.0f) continue;

														 GrindMarkRectCenter[7].x = GrindMarkRect[7].left + (GrindMarkRect[7].right  - GrindMarkRect[7].left)/2; 
														 GrindMarkRectCenter[7].y = GrindMarkRect[7].top  + (GrindMarkRect[7].bottom - GrindMarkRect[7].top )/2; 

														 GrindMeaDis = Math.GetLength(GrindMarkRectCenter[7], C3CirOutPoint[k]);
														 if(GrindMeaDis<MinDis){
															 MinDis = GrindMeaDis;
															 GrindMarkOutCnt = k;
														 }
													 }

													 // 최단거리OUtCount기준 InData 최단거리 Count정보 Calc 
													 if(GrindMarkOutCnt!=0){
														 GrindMeaDis =0.0f, MinDis =10000.0f; GrindMarkInCnt=0;
														 for(int k=0; k<C3CirInEdgeCount; k++){
															 if(C3CirInPoint[k].x   ==0.0f             || C3CirInPoint[k].y                ==0.0f) continue;
															 if(C3CirOutPoint[GrindMarkOutCnt].x==0.0f || C3CirOutPoint[GrindMarkOutCnt].y ==0.0f) continue;

															 GrindMeaDis = Math.GetLength(C3CirOutPoint[GrindMarkOutCnt], C3CirInPoint[k]);
															 if(GrindMeaDis<MinDis){
																 MinDis = GrindMeaDis;
																 GrindMarkInCnt = k;
															 }
														 }
													 }

													 // GrindMark기준 수직 포인트 주변값 Avg산출한다 ==>연마량 측정(OutData,InData기준)
													 if((GrindMarkOutCnt!=0 && GrindMarkOutCnt>5) && (GrindMarkInCnt!=0 && GrindMarkInCnt>5)){
														 CircleCount=0,TotalCirDis=0.0f,GrindWidthDis=0.0f;
														 for(int k=-5; k<5; k++){
															 if(C3CirOutPoint[GrindMarkOutCnt+k].x==0.0f && C3CirOutPoint[GrindMarkOutCnt+k].y==0.0f) continue;
															 if(C3CirInPoint [GrindMarkInCnt +k].x==0.0f && C3CirInPoint [GrindMarkInCnt +k].y==0.0f) continue;
															 if((GrindMarkOutCnt+k)>=C3CirOutEdgeCount                                              ) continue;
															 if((GrindMarkInCnt +k)>=C3CirInEdgeCount                                               ) continue;

															 GrindWidthDis = Math.GetLength(C3CirInPoint[GrindMarkInCnt+k], C3CirOutPoint[GrindMarkOutCnt+k]);
															 TotalCirDis+=   GrindWidthDis;
															 CircleCount++;
														 }
														 if(TotalCirDis!=0.0f && CircleCount!=0){
															 C3CirGrindWd = TotalCirDis/CircleCount;
															 C3CirGrindWd = C3CirGrindWd+0.5; //SubPixel
														 }
													 }
												 }
											 }
										 }
										 else         { //Polygon EnCap 계산시 OutPoint 중간값 기준 실측 거리 평균값을 계산한다(LeftTop) 
											 if(C3CirInEdgeCount!=0 && C3CirOutEdgeCount!=0){
												 GrindMeaDis =0.0f, MinDis =10000.0f; GrindMarkOutCnt=0;
												 GrindMarkOutCnt = (int)(C3CirOutEdgeCount/2);
												 // 최단거리OUtCount기준 InData 최단거리 Count정보 Calc 
												 if(GrindMarkOutCnt!=0){
													 GrindMeaDis =0.0f, MinDis =10000.0f; GrindMarkInCnt=0;
													 for(int k=0; k<C3CirInEdgeCount; k++){
														 if(C3CirInPoint[k].x   ==0.0f             || C3CirInPoint[k].y                ==0.0f) continue;
														 if(C3CirOutPoint[GrindMarkOutCnt].x==0.0f || C3CirOutPoint[GrindMarkOutCnt].y ==0.0f) continue;

														 GrindMeaDis = Math.GetLength(C3CirOutPoint[GrindMarkOutCnt], C3CirInPoint[k]);
														 if(GrindMeaDis<MinDis){
															 MinDis = GrindMeaDis;
															 GrindMarkInCnt = k;
														 }
													 }
												 }

												 // GrindMark기준 수직 포인트 주변값 Avg산출한다 ==>연마량 측정(OutData,InData기준)
												 if((GrindMarkOutCnt!=0 && GrindMarkOutCnt>5) && (GrindMarkInCnt!=0 && GrindMarkInCnt>5)){
													 CircleCount=0,TotalCirDis=0.0f,GrindWidthDis=0.0f;
													 for(int k=-5; k<5; k++){
														 if(C3CirOutPoint[GrindMarkOutCnt+k].x==0.0f && C3CirOutPoint[GrindMarkOutCnt+k].y==0.0f) continue;
														 if(C3CirInPoint [GrindMarkInCnt +k].x==0.0f && C3CirInPoint [GrindMarkInCnt +k].y==0.0f) continue;
														 if((GrindMarkOutCnt+k)>=C3CirOutEdgeCount                                              ) continue;
														 if((GrindMarkInCnt +k)>=C3CirInEdgeCount                                               ) continue;

														 GrindWidthDis = Math.GetLength(C3CirInPoint[GrindMarkInCnt+k], C3CirOutPoint[GrindMarkOutCnt+k]);
														 TotalCirDis+=   GrindWidthDis;
														 CircleCount++;
													 }
													 if(TotalCirDis!=0.0f && CircleCount!=0){
														 C3CirGrindWd = TotalCirDis/CircleCount;
														 C3CirGrindWd = C3CirGrindWd+0.5; //SubPixel
													 }
												 }
											 }
										 }
										 ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
										 // FAVION Circle Fitting 결과물(Circle_1)
										 SampleSize   = C3CirInEdgeCount*0.75; //0.5~0.8이하로 입력할것
										 DistDevRatio = 0.15                 ; //0.1~0.25 이하로 입력할것
										 CircleFit->OnRansac(C3CirInPoint,C3CirInEdgeCount,SampleSize,DistDevRatio,&CircleFit3Center,&CirFitDiameter3);

										 // Polygon 박리 검사 시퀀스 
										 if(!IsMarkBtm && BrokenThresHold!=0){
											 RotateBrokenImg.SetSize(RotateImg.GetWidth(), RotateImg.GetHeight());
											 EasyImage::Oper(EArithmeticLogicOperation_Copy,&RotateImg,&RotateBrokenImg);
											 EasyImage::Threshold(&RotateImg,&RotateBrokenImg, BrokenThresHold);
											 Edge->GImage = &RotateBrokenImg;
											 Edge->SetEdgeType(0);
// 											 RotateBrokenImg.Save("D:\\ROTATE_IMG\\Polygon_박리.bmp");

											 int DvCnt =0, DataCount=0;
											 double deg =0.0f; 
											 TFPoint Target(0.0f, 0.0f);

											 if(GrindMarkInCnt>GrindMarkOutCnt){
												 DvCnt = GrindMarkInCnt - GrindMarkOutCnt;
												 for(int k=0; k<C3CirOutEdgeCount; k++){
													 deg =0.0f, Target.x =0.0f, Target.y =0.0f;
													 if(((k+DvCnt)<C3CirInEdgeCount) && C3CirInPoint[k+DvCnt].x>0  && C3CirInPoint[k+DvCnt].y>0){
														 deg = Math.GetDegree(C3CirOutPoint[k],C3CirInPoint[k+DvCnt]);

														 Target  = Math.OnFindPerpendicularPointXY(C3CirOutPoint[k],-dEdgeToTrapLineDis,-dEdgeToTrapLineDis,deg);
														 Edge->OnExecute(C3CirOutPoint[k],Target); // 연마외곽라인에서 Target까지 White Point Search 
														 if(Edge->GetResultEdgePointCount()>0){
															 C3CircleData[DataCount].Dis =0.0f;
															 C3CircleData[DataCount].Dv  =0.0f;
															 C3CircleData[DataCount].P   = Edge->GetResultEdgePoint(0);
															 C3CircleData[DataCount].P.y = C3CircleData[DataCount].P.y - ImageHeight; // Frame기준 단위좌표로 변경함  
															 DataCount++;
														 }
													 }
												 }
												 C3CirInCrackCount = DataCount;
											 }
											 else if(GrindMarkInCnt<GrindMarkOutCnt)   {
												 DvCnt = GrindMarkOutCnt - GrindMarkInCnt;
												 for(int k=DvCnt; k<C3CirOutEdgeCount; k++){
													 deg =0.0f, Target.x =0.0f, Target.y =0.0f;
													 if(((k-DvCnt)<C3CirInEdgeCount) && C3CirInPoint[k-DvCnt].x>0  && C3CirInPoint[k-DvCnt].y>0 && k-DvCnt>=0){
														 deg = Math.GetDegree(C3CirOutPoint[k],C3CirInPoint[k-DvCnt]);

														 Target  = Math.OnFindPerpendicularPointXY(C3CirOutPoint[k],-dEdgeToTrapLineDis,-dEdgeToTrapLineDis,deg);
														 Edge->OnExecute(C3CirOutPoint[k],Target); // 연마외곽라인에서 Target까지 White Point Search 
														 if(Edge->GetResultEdgePointCount()>0){
															 C3CircleData[DataCount].Dis =0.0f;
															 C3CircleData[DataCount].Dv  =0.0f;
															 C3CircleData[DataCount].P   = Edge->GetResultEdgePoint(0);
															 C3CircleData[DataCount].P.y = C3CircleData[DataCount].P.y - ImageHeight; // Frame기준 단위좌표로 변경함  
															 DataCount++;
														 }
													 }
												 }
												 C3CirInCrackCount = DataCount;
											 }
										 }
										 LogUnit.SetLog(L"CellID:%d, CamID:%d ==>Polygon3_Insp_End",CellId,CamId);
									 }

									 // 네번째 Polygon, Circle 1
									 if(PolyRect[3].left!=0 && PolyRect[3].top!=0 && PolyRect[3].right!=0 && PolyRect[3].bottom!=0){
										 P1.x=0, P1.y=0, P2.x=0, P2.y=0, P3.x=0, P3.y=0, P4.x=0, P4.y=0;
										 LogUnit.SetLog(L"CellID:%d, CamID:%d ==>Polygon4_Insp_Start",CellId,CamId);

// 										 P1.x = (PolyRect[3].left); P1.y =(PolyRect[3].top-50          ); P2.x = (P1.x+PolyRect[3].Width()+50); P2.y = (P1.y);
// 										 P3.x = (PolyRect[3].left); P3.y =(P1.y+PolyRect[3].Height()+50); P4.x = (P2.x                       ); P4.y = (P3.y);

										 P1.x = (PolyRect[3].left); P1.y =(PolyRect[3].top-20          ); P2.x = (P1.x+PolyRect[3].Width()); P2.y = (P1.y);
										 P3.x = (PolyRect[3].left); P3.y =(P1.y+PolyRect[3].Height()+20); P4.x = (P2.x                    ); P4.y = (P3.y);

										 // Median Filter 적용 
										 if(P1.x<=0    || P1.y<=0    || (P2.x - P1.x)<=0    || (P3.y - P1.y)<=0   ) return false;
										 if(P1.x>=ImgW || P1.y>=ImgH || (P2.x - P1.x)>=ImgW || (P3.y - P1.y)>=ImgH) return false;
										 FilterROI.SetSize(int(P2.x - P1.x),int(P3.y - P1.y) )                      ;
										 FilterROI.Attach(&RotateBinaryImg)                                    ;
										 FilterROI.SetPlacement(P1.x, P1.y, int(P2.x - P1.x), int(P3.y - P1.y));
										 EasyImage::Median(&FilterROI, &FilterROI)                             ;
// 										 RotateBinaryImg.Save("D:\\ROTATE_IMG\\Polygon4_필터.bmp")             ;



										 Polygon->GImage          = &RotateBinaryImg            ;
										 Polygon->PoPa.FMaxWidth  =(int)(CenterCircleWidth +200);
										 Polygon->PoPa.FMaxHeight =(int)(CenterCircleHeight+200);
										 Polygon->PoPa.IsSeparate =true                         ;
										 Polygon->PoPa.IsInToOut  =true                         ;
										 Polygon->PoPa.HiThHold   = BtmEdgeThresHold            ;
										 Polygon->PoPa.LoThHold   = 0                           ;
										 Polygon->PoPa.FMinWidth  =(int)(CenterCircleWidth /3)  ;
										 Polygon->PoPa.FMinHeight =(int)(CenterCircleHeight/3)  ;

										 if(P1.x!=0 && P1.y!=0 && P2.x!=0 && P2.y!=0 && P3.x!=0 && P3.y!=0 && P4.x!=0 && P4.y!=0){
											 Polygon->OnExecute(P1,P2,P3,P4);
										 }

										 // Polygon Algorithm InEdgeData/OutEdgeData Separate 및 데이터 추출 
										 if(Polygon->BlobCount==1){
											 PolygonMarginCnt =10;
											 if(Polygon->Blob[0].InCnt>(PolygonMarginCnt*2)){
												 C4CirInEdgeCount=0;
												 C4CirInEdgeCount = (Polygon->Blob[0].InCnt - (PolygonMarginCnt*2));
												 if(C4CirInEdgeCount>0){
													 if(C4CirInPoint!=NULL) {
														 delete[] C4CirInPoint;
													 }
													 C4CirInPoint = new TFPoint[C4CirInEdgeCount];

													 PixelCnt=0;
													 for(int k=0; k<Polygon->Blob[0].InCnt; k++){
														 if(k<PolygonMarginCnt || k>=(Polygon->Blob[0].InCnt-PolygonMarginCnt)) continue;
														 C4CirInPoint[PixelCnt].x   = Polygon->Blob[0].InPoint[k].x ;
														 C4CirInPoint[PixelCnt].y   = Polygon->Blob[0].InPoint[k].y ;
														 PixelCnt++;
													 }
												 }
											 }

											 if(Polygon->Blob[0].OutCnt>(PolygonMarginCnt*2)){
												 C4CirOutEdgeCount=0;
												 C4CirOutEdgeCount = (Polygon->Blob[0].OutCnt - (PolygonMarginCnt*2));
												 if(C4CirOutEdgeCount>0){
													 if(C4CirOutPoint!=NULL) delete[] C4CirOutPoint;
													 C4CirOutPoint = new TFPoint[C4CirOutEdgeCount];

													 PixelCnt=0;
													 for(int k=0; k<Polygon->Blob[0].OutCnt; k++){
														 if(k<PolygonMarginCnt || k>=(Polygon->Blob[0].OutCnt-PolygonMarginCnt)) continue;
														 C4CirOutPoint[PixelCnt].x  = Polygon->Blob[0].OutPoint[k].x ;
														 C4CirOutPoint[PixelCnt].y  = Polygon->Blob[0].OutPoint[k].y ;

														 if(k==PolygonMarginCnt)                              { //직선구간에 필요한 시작점  
															 BtmEdgePoint[5].x =C4CirOutPoint[PixelCnt].x;
															 BtmEdgePoint[5].y =C4CirOutPoint[PixelCnt].y;
														 }
														 if(k==(Polygon->Blob[0].OutCnt-(PolygonMarginCnt+1))){ //직선구간에 필요한 끝점 
															 BtmEdgePoint[6].x =C4CirOutPoint[PixelCnt].x;
															 BtmEdgePoint[6].y =C4CirOutPoint[PixelCnt].y;
														 }
														 PixelCnt++;
													 }
												 }
											 }
											 // Polygon Data Clear
// 											 Polygon->ClearData();
										 }
										 /////////////////////////////////////////////////////////////////////////////////////////////

										 // InEdgeData/OutEdgeData 기준 가공량 및 연마량 계산
										 // Polygon 알고리즘에서는 GrindMark기준 OutData,InData 최단거리 2개 Tag값 산출해야함 
										 if(IsMarkBtm){ // LTPS 가공량,연마량 계산 
											 if(C4CirOutEdgeCount!=0 && C4CirInEdgeCount!=0){ // MarkMode경우 가공량 검사를 먼저 진행 후 연마량 산출  
												 if(GrindMarkPoint[11].x!=0.0f && GrindMarkPoint[11].y!=0.0f){  //GrindMark 찾았을경우 
													 // GrindMark기준 OutData 최단거리 Count정보 Calc 
													 GrindMeaDis =0.0f, MinDis =10000.0f; GrindMarkOutCnt=0;
													 for(int k=0; k<C4CirOutEdgeCount; k++){
														 if(C4CirOutPoint[k].x ==0.0f || C4CirOutPoint[k].y ==0.0f) continue;
														 if(GrindMarkPoint[11].x==0.0f || GrindMarkPoint[11].y==0.0f) continue;

														 GrindMeaDis = Math.GetLength(GrindMarkPoint[11], C4CirOutPoint[k]);
														 if(GrindMeaDis<MinDis){
															 MinDis = GrindMeaDis;
															 GrindMarkOutCnt = k;
														 }
													 }

													 // GrindMark기준 InData 최단거리 Count정보 Calc 
													 if(GrindMarkOutCnt!=0){
														 GrindMeaDis =0.0f, MinDis =10000.0f; GrindMarkInCnt=0;
														 for(int k=0; k<C4CirInEdgeCount; k++){
															 if(C4CirInPoint[k].x   ==0.0f             || C4CirInPoint[k].y                ==0.0f) continue;
															 if(C4CirOutPoint[GrindMarkOutCnt].x==0.0f || C4CirOutPoint[GrindMarkOutCnt].y ==0.0f) continue;

															 GrindMeaDis = Math.GetLength(C4CirOutPoint[GrindMarkOutCnt], C4CirInPoint[k]);
															 if(GrindMeaDis<MinDis){
																 MinDis = GrindMeaDis;
																 GrindMarkInCnt = k;
															 }
														 }
													 }

													 // GrindMark기준 수직 포인트 주변값 Avg산출한다 ==>가공량 측정(OutData기준)
													 if(GrindMarkOutCnt!=0 && GrindMarkOutCnt>5){
														 CircleCount=0,TotalCirDis=0.0f,GrindMeaDis=0.0f;
														 for(int k=GrindMarkOutCnt-5; k<GrindMarkOutCnt+5; k++){
															 if(C4CirOutPoint[k].x==0.0f || C4CirOutPoint[k].y==0.0f) continue;
															 if(k>=C4CirOutEdgeCount                                ) continue;

															 GrindMeaDis = Math.GetLength(GrindMarkPoint[11], C4CirOutPoint[k]);
															 TotalCirDis+= GrindMeaDis;
															 CircleCount++;
														 }
														 if(TotalCirDis!=0.0f && CircleCount!=0){
															 C4CirGrindMea = TotalCirDis/CircleCount;
															 C4CirGrindMea = C4CirGrindMea+0.5; //SubPixel 
														 }
													 }

													 // GrindMark기준 수직 포인트 주변값 Avg산출한다 ==>연마량 측정(OutData,InData기준)
													 if((GrindMarkOutCnt!=0 && GrindMarkOutCnt>5) && (GrindMarkInCnt!=0 && GrindMarkInCnt>5)){
														 CircleCount=0,TotalCirDis=0.0f,GrindWidthDis=0.0f;
														 for(int k=-5; k<5; k++){
															 if(C4CirOutPoint[GrindMarkOutCnt+k].x==0.0f && C4CirOutPoint[GrindMarkOutCnt+k].y==0.0f) continue;
															 if(C4CirInPoint [GrindMarkInCnt +k].x==0.0f && C4CirInPoint [GrindMarkInCnt +k].y==0.0f) continue;
															 if((GrindMarkOutCnt+k)>=C4CirOutEdgeCount                                              ) continue;
															 if((GrindMarkInCnt +k)>=C4CirInEdgeCount                                               ) continue;

															 GrindWidthDis = Math.GetLength(C4CirInPoint[GrindMarkInCnt+k], C4CirOutPoint[GrindMarkOutCnt+k]);
															 TotalCirDis+=   GrindWidthDis;
															 CircleCount++;
														 }
														 if(TotalCirDis!=0.0f && CircleCount!=0){
															 C4CirGrindWd = TotalCirDis/CircleCount;
															 C4CirGrindWd = C4CirGrindWd+0.5; //SubPixel
														 }
													 }
												 }
												 else if(GrindMarkRect[11].left!=0 && GrindMarkRect[11].top!=0 && GrindMarkRect[11].right!=0 &&GrindMarkRect[11].bottom!=0){  //GrindMark 못 찾았을경우
													 // OutData기준 최소값 데이터 Count산출 
													 GrindMeaDis =0.0f, MinDis =10000.0f; GrindMarkOutCnt=0;
													 for(int k=0; k<C4CirOutEdgeCount; k++){
														 if(C4CirOutPoint[k].x==0.0f || C4CirOutPoint[k].y==0.0f) continue;

														 GrindMarkRectCenter[11].x = GrindMarkRect[11].left + (GrindMarkRect[11].right  - GrindMarkRect[11].left)/2; 
														 GrindMarkRectCenter[11].y = GrindMarkRect[11].top  + (GrindMarkRect[11].bottom - GrindMarkRect[11].top )/2; 

														 GrindMeaDis = Math.GetLength(GrindMarkRectCenter[11], C4CirOutPoint[k]);
														 if(GrindMeaDis<MinDis){
															 MinDis = GrindMeaDis;
															 GrindMarkOutCnt = k;
														 }
													 }

													 // 최단거리OUtCount기준 InData 최단거리 Count정보 Calc 
													 if(GrindMarkOutCnt!=0){
														 GrindMeaDis =0.0f, MinDis =10000.0f; GrindMarkInCnt=0;
														 for(int k=0; k<C4CirInEdgeCount; k++){
															 if(C4CirInPoint[k].x   ==0.0f             || C4CirInPoint[k].y                ==0.0f) continue;
															 if(C4CirOutPoint[GrindMarkOutCnt].x==0.0f || C4CirOutPoint[GrindMarkOutCnt].y ==0.0f) continue;

															 GrindMeaDis = Math.GetLength(C4CirOutPoint[GrindMarkOutCnt], C4CirInPoint[k]);
															 if(GrindMeaDis<MinDis){
																 MinDis = GrindMeaDis;
																 GrindMarkInCnt = k;
															 }
														 }
													 }

													 // GrindMark기준 수직 포인트 주변값 Avg산출한다 ==>연마량 측정(OutData,InData기준)
													 if((GrindMarkOutCnt!=0 && GrindMarkOutCnt>5) && (GrindMarkInCnt!=0 && GrindMarkInCnt>5)){
														 CircleCount=0,TotalCirDis=0.0f,GrindWidthDis=0.0f;
														 for(int k=-5; k<5; k++){
															 if(C4CirOutPoint[GrindMarkOutCnt+k].x==0.0f && C4CirOutPoint[GrindMarkOutCnt+k].y==0.0f) continue;
															 if(C4CirInPoint [GrindMarkInCnt +k].x==0.0f && C4CirInPoint [GrindMarkInCnt +k].y==0.0f) continue;
															 if((GrindMarkOutCnt+k)>=C4CirOutEdgeCount                                              ) continue;
															 if((GrindMarkInCnt +k)>=C4CirInEdgeCount                                               ) continue;

															 GrindWidthDis = Math.GetLength(C4CirInPoint[GrindMarkInCnt+k], C4CirOutPoint[GrindMarkOutCnt+k]);
															 TotalCirDis+=   GrindWidthDis;
															 CircleCount++;
														 }
														 if(TotalCirDis!=0.0f && CircleCount!=0){
															 C4CirGrindWd = TotalCirDis/CircleCount;
															 C4CirGrindWd = C4CirGrindWd+0.5; //SubPixel
														 }
													 }
												 }
											 }
										 }
										 else         { //Polygon EnCap 계산시 OutPoint 중간값 기준 실측 거리 평균값을 계산한다(LeftTop) 
											 if(C4CirInEdgeCount!=0 && C4CirOutEdgeCount!=0){
												 GrindMeaDis =0.0f, MinDis =10000.0f; GrindMarkOutCnt=0;
												 GrindMarkOutCnt = (int)(C4CirOutEdgeCount/2);
												 // 최단거리OUtCount기준 InData 최단거리 Count정보 Calc 
												 if(GrindMarkOutCnt!=0){
													 GrindMeaDis =0.0f, MinDis =10000.0f; GrindMarkInCnt=0;
													 for(int k=0; k<C4CirInEdgeCount; k++){
														 if(C4CirInPoint[k].x   ==0.0f             || C4CirInPoint[k].y                ==0.0f) continue;
														 if(C4CirOutPoint[GrindMarkOutCnt].x==0.0f || C4CirOutPoint[GrindMarkOutCnt].y ==0.0f) continue;

														 GrindMeaDis = Math.GetLength(C4CirOutPoint[GrindMarkOutCnt], C4CirInPoint[k]);
														 if(GrindMeaDis<MinDis){
															 MinDis = GrindMeaDis;
															 GrindMarkInCnt = k;
														 }
													 }
												 }

												 // GrindMark기준 수직 포인트 주변값 Avg산출한다 ==>연마량 측정(OutData,InData기준)
												 if((GrindMarkOutCnt!=0 && GrindMarkOutCnt>5) && (GrindMarkInCnt!=0 && GrindMarkInCnt>5)){
													 CircleCount=0,TotalCirDis=0.0f,GrindWidthDis=0.0f;
													 for(int k=-5; k<5; k++){
														 if(C4CirOutPoint[GrindMarkOutCnt+k].x==0.0f && C4CirOutPoint[GrindMarkOutCnt+k].y==0.0f) continue;
														 if(C4CirInPoint [GrindMarkInCnt +k].x==0.0f && C4CirInPoint [GrindMarkInCnt +k].y==0.0f) continue;
														 if((GrindMarkOutCnt+k)>=C4CirOutEdgeCount                                              ) continue;
														 if((GrindMarkInCnt +k)>=C4CirInEdgeCount                                               ) continue;

														 GrindWidthDis = Math.GetLength(C4CirInPoint[GrindMarkInCnt+k], C4CirOutPoint[GrindMarkOutCnt+k]);
														 TotalCirDis+=   GrindWidthDis;
														 CircleCount++;
													 }
													 if(TotalCirDis!=0.0f && CircleCount!=0){
														 C4CirGrindWd = TotalCirDis/CircleCount;
														 C4CirGrindWd = C4CirGrindWd+0.5; //SubPixel
													 }
												 }
											 }
										 }
										 ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
										 // FAVION Circle Fitting 결과물(Circle_1)
										 SampleSize   = C4CirInEdgeCount*0.75; //0.5~0.8이하로 입력할것
										 DistDevRatio = 0.15                 ; //0.1~0.25 이하로 입력할것
										 CircleFit->OnRansac(C4CirInPoint,C4CirInEdgeCount,SampleSize,DistDevRatio,&CircleFit4Center,&CirFitDiameter4);

										 // Polygon 박리 검사 시퀀스 
										 if(!IsMarkBtm && BrokenThresHold!=0){
											 RotateBrokenImg.SetSize(RotateImg.GetWidth(), RotateImg.GetHeight());
											 EasyImage::Oper(EArithmeticLogicOperation_Copy,&RotateImg,&RotateBrokenImg);
											 EasyImage::Threshold(&RotateImg,&RotateBrokenImg, BrokenThresHold);
											 Edge->GImage = &RotateBrokenImg;
											 Edge->SetEdgeType(0);
// 											 RotateBrokenImg.Save("D:\\ROTATE_IMG\\Polygon_박리.bmp");

											 int DvCnt =0, DataCount=0;
											 double deg =0.0f; 
											 TFPoint Target(0.0f, 0.0f);

											 if(GrindMarkInCnt>GrindMarkOutCnt){
												 DvCnt = GrindMarkInCnt - GrindMarkOutCnt;
												 for(int k=0; k<C4CirOutEdgeCount; k++){
													 deg =0.0f, Target.x =0.0f, Target.y =0.0f;
													 if(((k+DvCnt)<C4CirInEdgeCount) && C4CirInPoint[k+DvCnt].x>0  && C4CirInPoint[k+DvCnt].y>0){
														 deg = Math.GetDegree(C4CirOutPoint[k],C4CirInPoint[k+DvCnt]);

														 Target  = Math.OnFindPerpendicularPointXY(C4CirOutPoint[k],-dEdgeToTrapLineDis,dEdgeToTrapLineDis,deg);
														 Edge->OnExecute(C4CirOutPoint[k],Target); // 연마외곽라인에서 Target까지 White Point Search 
														 if(Edge->GetResultEdgePointCount()>0){
															 C4CircleData[DataCount].Dis =0.0f;
															 C4CircleData[DataCount].Dv  =0.0f;
															 C4CircleData[DataCount].P   = Edge->GetResultEdgePoint(0);
															 C4CircleData[DataCount].P.y = C4CircleData[DataCount].P.y - ImageHeight; // Frame기준 단위좌표로 변경함  
															 DataCount++;
														 }
													 }
												 }
												 C4CirInCrackCount = DataCount;
											 }
											 else if(GrindMarkInCnt<GrindMarkOutCnt)   {
												 DvCnt = GrindMarkOutCnt - GrindMarkInCnt;
												 for(int k=DvCnt; k<C4CirOutEdgeCount; k++){
													 deg =0.0f, Target.x =0.0f, Target.y =0.0f;
													 if(((k-DvCnt)<C4CirInEdgeCount) && C4CirInPoint[k-DvCnt].x>0  && C4CirInPoint[k-DvCnt].y>0 && k-DvCnt>=0){
														 deg = Math.GetDegree(C4CirOutPoint[k],C4CirInPoint[k-DvCnt]);

														 Target  = Math.OnFindPerpendicularPointXY(C4CirOutPoint[k],-dEdgeToTrapLineDis,dEdgeToTrapLineDis,deg);
														 Edge->OnExecute(C4CirOutPoint[k],Target); // 연마외곽라인에서 Target까지 White Point Search 
														 if(Edge->GetResultEdgePointCount()>0){
															 C4CircleData[DataCount].Dis =0.0f;
															 C4CircleData[DataCount].Dv  =0.0f;
															 C4CircleData[DataCount].P   = Edge->GetResultEdgePoint(0);
															 C4CircleData[DataCount].P.y = C4CircleData[DataCount].P.y - ImageHeight; // Frame기준 단위좌표로 변경함  
															 DataCount++;
														 }
													 }
												 }
												 C4CirInCrackCount = DataCount;
											 }
										 }
										 LogUnit.SetLog(L"CellID:%d, CamID:%d ==>Polygon4_Insp_End",CellId,CamId);
									 }

									 // 다섯번째 Polygon, Circle 1
									 if(PolyRect[4].left!=0 && PolyRect[4].top!=0 && PolyRect[4].right!=0 && PolyRect[4].bottom!=0){
										 P1.x=0, P1.y=0, P2.x=0, P2.y=0, P3.x=0, P3.y=0, P4.x=0, P4.y=0;
										 LogUnit.SetLog(L"CellID:%d, CamID:%d ==>Polygon5_Insp_Start",CellId,CamId);

// 										 P1.x = (PolyRect[4].left-50); P1.y =(PolyRect[4].top             ); P2.x = (P1.x+PolyRect[4].Width()+50); P2.y = (P1.y);
// 										 P3.x = (PolyRect[4].left-50); P3.y =(P1.y+PolyRect[4].Height()+50); P4.x = (P2.x                       ); P4.y = (P3.y);

										 P1.x = (PolyRect[4].left); P1.y =(PolyRect[4].top-20          ); P2.x = (P1.x+PolyRect[4].Width()); P2.y = (P1.y);
										 P3.x = (PolyRect[4].left); P3.y =(P1.y+PolyRect[4].Height()+20); P4.x = (P2.x                    ); P4.y = (P3.y);

										 // Median Filter 적용 
										 if(P1.x<=0    || P1.y<=0    || (P2.x - P1.x)<=0    || (P3.y - P1.y)<=0   ) return false;
										 if(P1.x>=ImgW || P1.y>=ImgH || (P2.x - P1.x)>=ImgW || (P3.y - P1.y)>=ImgH) return false;
										 FilterROI.SetSize(int(P2.x - P1.x),int(P3.y - P1.y) )                      ;
										 FilterROI.Attach(&RotateBinaryImg)                                    ;
										 FilterROI.SetPlacement(P1.x, P1.y, int(P2.x - P1.x), int(P3.y - P1.y));
										 EasyImage::Median(&FilterROI, &FilterROI)                             ;
// 										 RotateBinaryImg.Save("D:\\ROTATE_IMG\\Polygon5_필터.bmp")             ;


										 Polygon->GImage          = &RotateBinaryImg            ;
										 Polygon->PoPa.FMaxWidth  =(int)(CenterCircleWidth +200);
										 Polygon->PoPa.FMaxHeight =(int)(CenterCircleHeight+200);
										 Polygon->PoPa.IsSeparate =true                         ;
										 Polygon->PoPa.IsInToOut  =true                         ;
										 Polygon->PoPa.HiThHold   = BtmEdgeThresHold            ;
										 Polygon->PoPa.LoThHold   = 0                           ;
										 Polygon->PoPa.FMinWidth  =(int)(CenterCircleWidth /3)  ;
										 Polygon->PoPa.FMinHeight =(int)(CenterCircleHeight/3)  ;

										 if(P1.x!=0 && P1.y!=0 && P2.x!=0 && P2.y!=0 && P3.x!=0 && P3.y!=0 && P4.x!=0 && P4.y!=0){
											 Polygon->OnExecute(P1,P2,P3,P4);
										 }

										 // Polygon Algorithm InEdgeData/OutEdgeData Separate 및 데이터 추출 
										 if(Polygon->BlobCount==1){
											 PolygonMarginCnt =10;
											 if(Polygon->Blob[0].InCnt>(PolygonMarginCnt*2)){
												 C5CirInEdgeCount=0;
												 C5CirInEdgeCount = (Polygon->Blob[0].InCnt - (PolygonMarginCnt*2));
												 if(C5CirInEdgeCount>0){
													 if(C5CirInPoint!=NULL) {
														 delete[] C5CirInPoint;
													 }
													 C5CirInPoint = new TFPoint[C5CirInEdgeCount];

													 PixelCnt=0;
													 for(int k=0; k<Polygon->Blob[0].InCnt; k++){
														 if(k<PolygonMarginCnt || k>=(Polygon->Blob[0].InCnt-PolygonMarginCnt)) continue;
														 C5CirInPoint[PixelCnt].x   = Polygon->Blob[0].InPoint[k].x ;
														 C5CirInPoint[PixelCnt].y   = Polygon->Blob[0].InPoint[k].y ;
														 PixelCnt++;
													 }
												 }
											 }

											 if(Polygon->Blob[0].OutCnt>(PolygonMarginCnt*2)){
												 C5CirOutEdgeCount=0;
												 C5CirOutEdgeCount = (Polygon->Blob[0].OutCnt - (PolygonMarginCnt*2));
												 if(C5CirOutEdgeCount>0){
													 if(C5CirOutPoint!=NULL) delete[] C5CirOutPoint;
													 C5CirOutPoint = new TFPoint[C5CirOutEdgeCount];

													 PixelCnt=0;
													 for(int k=0; k<Polygon->Blob[0].OutCnt; k++){
														 if(k<PolygonMarginCnt || k>=(Polygon->Blob[0].OutCnt-PolygonMarginCnt)) continue;
														 C5CirOutPoint[PixelCnt].x  = Polygon->Blob[0].OutPoint[k].x ;
														 C5CirOutPoint[PixelCnt].y  = Polygon->Blob[0].OutPoint[k].y ;

														 if(k==PolygonMarginCnt)                              { //직선구간에 필요한 시작점  
															 BtmEdgePoint[7].x = C5CirOutPoint[PixelCnt].x;
															 BtmEdgePoint[7].y = C5CirOutPoint[PixelCnt].y;
														 }
														 if(k==(Polygon->Blob[0].OutCnt-(PolygonMarginCnt+1))){ //직선구간에 필요한 끝점 
															 BtmEdgePoint[8].x = C5CirOutPoint[PixelCnt].x;
															 BtmEdgePoint[8].y = C5CirOutPoint[PixelCnt].y;
														 }
														 PixelCnt++;
													 }
												 }
											 }
											 // Polygon Data Clear
// 											 Polygon->ClearData();
										 }
										 /////////////////////////////////////////////////////////////////////////////////////////////

										 // InEdgeData/OutEdgeData 기준 가공량 및 연마량 계산
										 // Polygon 알고리즘에서는 GrindMark기준 OutData,InData 최단거리 2개 Tag값 산출해야함 
										 if(IsMarkBtm){ // LTPS 가공량,연마량 계산 
											 if(C5CirOutEdgeCount!=0 && C5CirInEdgeCount!=0){ // MarkMode경우 가공량 검사를 먼저 진행 후 연마량 산출  
												 // 가공량,연마량 측정 전 데이터 존재시 가상GrindMark 생성한다 
												 if(GrindMarkPoint[13].x!=0.0f && GrindMarkPoint[13].y!=0.0f && GrindRectSpec[6].DvX!=0.0f && GrindRectSpec[6].DvY!=0.0f){
													 GrindMarkPoint[12].x     = GrindMarkPoint[13].x - GrindRectSpec[6].DvX;
													 GrindMarkPoint[12].y     = GrindMarkPoint[13].y - GrindRectSpec[6].DvY;
													 GrindMarkRect [12].left  = GrindMarkPoint[12].x    - GrindMarkRange   ;  
													 GrindMarkRect [12].top   = GrindMarkPoint[12].y    - GrindMarkRange   ;  
													 GrindMarkRect [12].right = GrindMarkRect [12].left + GrindMarkLength  ;  
													 GrindMarkRect [12].bottom= GrindMarkRect [12].top  + GrindMarkLength  ;  
												 }

												 // GrindMarkPoint[12] 가상 마크 생성 시퀀스 
												 if(GrindMarkPoint[12].x!=0.0f && GrindMarkPoint[12].y!=0.0f){  //GrindMark 찾았을경우 
													 // GrindMark기준 OutData 최단거리 Count정보 Calc 
													 GrindMeaDis =0.0f, MinDis =10000.0f; GrindMarkOutCnt=0;
													 for(int k=0; k<C5CirOutEdgeCount; k++){
														 if(C5CirOutPoint[k].x ==0.0f || C5CirOutPoint[k].y ==0.0f) continue;
														 if(GrindMarkPoint[12].x==0.0f || GrindMarkPoint[12].y==0.0f) continue;

														 GrindMeaDis = Math.GetLength(GrindMarkPoint[12], C5CirOutPoint[k]);
														 if(GrindMeaDis<MinDis){
															 MinDis = GrindMeaDis;
															 GrindMarkOutCnt = k;
														 }
													 }

													 // GrindMark기준 InData 최단거리 Count정보 Calc 
													 if(GrindMarkOutCnt!=0){
														 GrindMeaDis =0.0f, MinDis =10000.0f; GrindMarkInCnt=0;
														 for(int k=0; k<C5CirInEdgeCount; k++){
															 if(C5CirInPoint[k].x   ==0.0f             || C5CirInPoint[k].y                ==0.0f) continue;
															 if(C5CirOutPoint[GrindMarkOutCnt].x==0.0f || C5CirOutPoint[GrindMarkOutCnt].y ==0.0f) continue;

															 GrindMeaDis = Math.GetLength(C5CirOutPoint[GrindMarkOutCnt], C5CirInPoint[k]);
															 if(GrindMeaDis<MinDis){
																 MinDis = GrindMeaDis;
																 GrindMarkInCnt = k;
															 }
														 }
													 }

													 // GrindMark기준 수직 포인트 주변값 Avg산출한다 ==>가공량 측정(OutData기준)
													 if(GrindMarkOutCnt!=0 && GrindMarkOutCnt>5){
														 CircleCount=0,TotalCirDis=0.0f,GrindMeaDis=0.0f;
														 for(int k=GrindMarkOutCnt-5; k<GrindMarkOutCnt+5; k++){
															 if(C5CirOutPoint[k].x==0.0f || C5CirOutPoint[k].y==0.0f) continue;
															 if(k>=C5CirOutEdgeCount                                ) continue;

															 GrindMeaDis = Math.GetLength(GrindMarkPoint[12], C5CirOutPoint[k]);
															 TotalCirDis+= GrindMeaDis;
															 CircleCount++;
														 }
														 if(TotalCirDis!=0.0f && CircleCount!=0){
															 TrenchRightGrindMea = TotalCirDis/CircleCount;
															 TrenchRightGrindMea = TrenchRightGrindMea+0.5; //SubPixel 
														 }
													 }

													 // GrindMark기준 수직 포인트 주변값 Avg산출한다 ==>연마량 측정(OutData,InData기준)
													 if((GrindMarkOutCnt!=0 && GrindMarkOutCnt>5) && (GrindMarkInCnt!=0 && GrindMarkInCnt>5)){
														 CircleCount=0,TotalCirDis=0.0f,GrindWidthDis=0.0f;
														 for(int k=-5; k<5; k++){
															 if(C5CirOutPoint[GrindMarkOutCnt+k].x==0.0f && C5CirOutPoint[GrindMarkOutCnt+k].y==0.0f) continue;
															 if(C5CirInPoint [GrindMarkInCnt +k].x==0.0f && C5CirInPoint [GrindMarkInCnt +k].y==0.0f) continue;
															 if((GrindMarkOutCnt+k)>=C5CirOutEdgeCount                                              ) continue;
															 if((GrindMarkInCnt +k)>=C5CirInEdgeCount                                               ) continue;

															 GrindWidthDis = Math.GetLength(C5CirInPoint[GrindMarkInCnt+k], C5CirOutPoint[GrindMarkOutCnt+k]);
															 TotalCirDis+=   GrindWidthDis;
															 CircleCount++;
														 }
														 if(TotalCirDis!=0.0f && CircleCount!=0){
															 TrenchRightGrindWd = TotalCirDis/CircleCount;
															 TrenchRightGrindWd = TrenchRightGrindWd+0.5; //SubPixel
														 }
													 }
												 }
												 else if(GrindMarkRect[12].left!=0 && GrindMarkRect[12].top!=0 && GrindMarkRect[12].right!=0 &&GrindMarkRect[12].bottom!=0){  //GrindMark 못 찾았을경우
													 // OutData기준 최소값 데이터 Count산출 
													 if(GrindRectSpec[6].DvX!=0.0f && GrindRectSpec[6].DvY!=0.0f){
														 GrindMeaDis =0.0f, MinDis =10000.0f; GrindMarkOutCnt=0;
														 for(int k=0; k<C5CirOutEdgeCount; k++){
															 if(C5CirOutPoint[k].x==0.0f || C5CirOutPoint[k].y==0.0f) continue;

															 if(k==0){
																 GrindMarkRectCenter[13].x = GrindMarkRect[13].left + (GrindMarkRect[13].right  - GrindMarkRect[13].left)/2; 
																 GrindMarkRectCenter[13].y = GrindMarkRect[13].top  + (GrindMarkRect[13].bottom - GrindMarkRect[13].top )/2; 

																 GrindMarkRectCenter[12].x = GrindMarkRectCenter[13].x - GrindRectSpec[6].DvX;
																 GrindMarkRectCenter[12].y = GrindMarkRectCenter[13].y - GrindRectSpec[6].DvY;

																 GrindMarkRect [12].left  =  GrindMarkRectCenter[12].x   - GrindMarkRange   ;  
																 GrindMarkRect [12].top   =  GrindMarkRectCenter[12].y   - GrindMarkRange   ;  
																 GrindMarkRect [12].right =  GrindMarkRect [12].left + GrindMarkLength  ;  
																 GrindMarkRect [12].bottom=  GrindMarkRect [12].top  + GrindMarkLength  ;  
															 }

															 GrindMeaDis = Math.GetLength(GrindMarkRectCenter[12], C5CirOutPoint[k]);
															 if(GrindMeaDis<MinDis){
																 MinDis = GrindMeaDis;
																 GrindMarkOutCnt = k;
															 }
														 }

														 // 최단거리OUtCount기준 InData 최단거리 Count정보 Calc 
														 if(GrindMarkOutCnt!=0){
															 GrindMeaDis =0.0f, MinDis =10000.0f; GrindMarkInCnt=0;
															 for(int k=0; k<C5CirInEdgeCount; k++){
																 if(C5CirInPoint[k].x   ==0.0f             || C5CirInPoint[k].y                ==0.0f) continue;
																 if(C5CirOutPoint[GrindMarkOutCnt].x==0.0f || C5CirOutPoint[GrindMarkOutCnt].y ==0.0f) continue;

																 GrindMeaDis = Math.GetLength(C5CirOutPoint[GrindMarkOutCnt], C5CirInPoint[k]);
																 if(GrindMeaDis<MinDis){
																	 MinDis = GrindMeaDis;
																	 GrindMarkInCnt = k;
																 }
															 }
														 }

														 // GrindMark기준 수직 포인트 주변값 Avg산출한다 ==>연마량 측정(OutData,InData기준)
														 if((GrindMarkOutCnt!=0 && GrindMarkOutCnt>5) && (GrindMarkInCnt!=0 && GrindMarkInCnt>5)){
															 CircleCount=0,TotalCirDis=0.0f,GrindWidthDis=0.0f;
															 for(int k=-5; k<5; k++){
																 if(C5CirOutPoint[GrindMarkOutCnt+k].x==0.0f && C5CirOutPoint[GrindMarkOutCnt+k].y==0.0f) continue;
																 if(C5CirInPoint [GrindMarkInCnt +k].x==0.0f && C5CirInPoint [GrindMarkInCnt +k].y==0.0f) continue;
																 if((GrindMarkOutCnt+k)>=C5CirOutEdgeCount                                              ) continue;
																 if((GrindMarkInCnt +k)>=C5CirInEdgeCount                                               ) continue;

																 GrindWidthDis = Math.GetLength(C5CirInPoint[GrindMarkInCnt+k], C5CirOutPoint[GrindMarkOutCnt+k]);
																 TotalCirDis+=   GrindWidthDis;
																 CircleCount++;
															 }
															 if(TotalCirDis!=0.0f && CircleCount!=0){
																 TrenchRightGrindWd = TotalCirDis/CircleCount;
																 TrenchRightGrindWd = TrenchRightGrindWd+0.5; //SubPixel
															 }
														 }
													 }
												 }


												 if(GrindMarkPoint[13].x!=0.0f && GrindMarkPoint[13].y!=0.0f){  //GrindMark 찾았을경우 
													 // GrindMark기준 OutData 최단거리 Count정보 Calc 
													 GrindMeaDis =0.0f, MinDis =10000.0f; GrindMarkOutCnt=0;
													 for(int k=0; k<C5CirOutEdgeCount; k++){
														 if(C5CirOutPoint[k].x ==0.0f || C5CirOutPoint[k].y ==0.0f) continue;
														 if(GrindMarkPoint[13].x==0.0f || GrindMarkPoint[13].y==0.0f) continue;

														 GrindMeaDis = Math.GetLength(GrindMarkPoint[13], C5CirOutPoint[k]);
														 if(GrindMeaDis<MinDis){
															 MinDis = GrindMeaDis;
															 GrindMarkOutCnt = k;
														 }
													 }

													 // GrindMark기준 InData 최단거리 Count정보 Calc 
													 if(GrindMarkOutCnt!=0){
														 GrindMeaDis =0.0f, MinDis =10000.0f; GrindMarkInCnt=0;
														 for(int k=0; k<C5CirInEdgeCount; k++){
															 if(C5CirInPoint[k].x   ==0.0f             || C5CirInPoint[k].y                ==0.0f) continue;
															 if(C5CirOutPoint[GrindMarkOutCnt].x==0.0f || C5CirOutPoint[GrindMarkOutCnt].y ==0.0f) continue;

															 GrindMeaDis = Math.GetLength(C5CirOutPoint[GrindMarkOutCnt], C5CirInPoint[k]);
															 if(GrindMeaDis<MinDis){
																 MinDis = GrindMeaDis;
																 GrindMarkInCnt = k;
															 }
														 }
													 }

													 // GrindMark기준 수직 포인트 주변값 Avg산출한다 ==>가공량 측정(OutData기준)
													 if(GrindMarkOutCnt!=0 && GrindMarkOutCnt>5){
														 CircleCount=0,TotalCirDis=0.0f,GrindMeaDis=0.0f;
														 for(int k=GrindMarkOutCnt-5; k<GrindMarkOutCnt+5; k++){
															 if(C5CirOutPoint[k].x==0.0f || C5CirOutPoint[k].y==0.0f) continue;
															 if(k>=C5CirOutEdgeCount                                ) continue;

															 GrindMeaDis = Math.GetLength(GrindMarkPoint[13], C5CirOutPoint[k]);
															 TotalCirDis+= GrindMeaDis;
															 CircleCount++;
														 }
														 if(TotalCirDis!=0.0f && CircleCount!=0){
															 C5CirGrindMea = TotalCirDis/CircleCount;
															 C5CirGrindMea = C5CirGrindMea+0.5; //SubPixel 
														 }
													 }

													 // GrindMark기준 수직 포인트 주변값 Avg산출한다 ==>연마량 측정(OutData,InData기준)
													 if((GrindMarkOutCnt!=0 && GrindMarkOutCnt>5) && (GrindMarkInCnt!=0 && GrindMarkInCnt>5)){
														 CircleCount=0,TotalCirDis=0.0f,GrindWidthDis=0.0f;
														 for(int k=-5; k<5; k++){
															 if(C5CirOutPoint[GrindMarkOutCnt+k].x==0.0f && C5CirOutPoint[GrindMarkOutCnt+k].y==0.0f) continue;
															 if(C5CirInPoint [GrindMarkInCnt +k].x==0.0f && C5CirInPoint [GrindMarkInCnt +k].y==0.0f) continue;
															 if((GrindMarkOutCnt+k)>=C5CirOutEdgeCount                                              ) continue;
															 if((GrindMarkInCnt +k)>=C5CirInEdgeCount                                               ) continue;

															 GrindWidthDis = Math.GetLength(C5CirInPoint[GrindMarkInCnt+k], C5CirOutPoint[GrindMarkOutCnt+k]);
															 TotalCirDis+=   GrindWidthDis;
															 CircleCount++;
														 }
														 if(TotalCirDis!=0.0f && CircleCount!=0){
															 C5CirGrindWd = TotalCirDis/CircleCount;
															 C5CirGrindWd = C5CirGrindWd+0.5; //SubPixel
														 }
													 }
												 }
												 else if(GrindMarkRect[13].left!=0 && GrindMarkRect[13].top!=0 && GrindMarkRect[13].right!=0 &&GrindMarkRect[13].bottom!=0){  //GrindMark 못 찾았을경우
													 // OutData기준 최소값 데이터 Count산출 
													 GrindMeaDis =0.0f, MinDis =10000.0f; GrindMarkOutCnt=0;
													 for(int k=0; k<C5CirOutEdgeCount; k++){
														 if(C5CirOutPoint[k].x==0.0f || C5CirOutPoint[k].y==0.0f) continue;

														 GrindMarkRectCenter[13].x = GrindMarkRect[13].left + (GrindMarkRect[13].right  - GrindMarkRect[13].left)/2; 
														 GrindMarkRectCenter[13].y = GrindMarkRect[13].top  + (GrindMarkRect[13].bottom - GrindMarkRect[13].top )/2; 

														 GrindMeaDis = Math.GetLength(GrindMarkRectCenter[13], C5CirOutPoint[k]);
														 if(GrindMeaDis<MinDis){
															 MinDis = GrindMeaDis;
															 GrindMarkOutCnt = k;
														 }
													 }

													 // 최단거리OUtCount기준 InData 최단거리 Count정보 Calc 
													 if(GrindMarkOutCnt!=0){
														 GrindMeaDis =0.0f, MinDis =10000.0f; GrindMarkInCnt=0;
														 for(int k=0; k<C5CirInEdgeCount; k++){
															 if(C5CirInPoint[k].x   ==0.0f             || C5CirInPoint[k].y                ==0.0f) continue;
															 if(C5CirOutPoint[GrindMarkOutCnt].x==0.0f || C5CirOutPoint[GrindMarkOutCnt].y ==0.0f) continue;

															 GrindMeaDis = Math.GetLength(C5CirOutPoint[GrindMarkOutCnt], C5CirInPoint[k]);
															 if(GrindMeaDis<MinDis){
																 MinDis = GrindMeaDis;
																 GrindMarkInCnt = k;
															 }
														 }
													 }

													 // GrindMark기준 수직 포인트 주변값 Avg산출한다 ==>연마량 측정(OutData,InData기준)
													 if((GrindMarkOutCnt!=0 && GrindMarkOutCnt>5) && (GrindMarkInCnt!=0 && GrindMarkInCnt>5)){
														 CircleCount=0,TotalCirDis=0.0f,GrindWidthDis=0.0f;
														 for(int k=-5; k<5; k++){
															 if(C5CirOutPoint[GrindMarkOutCnt+k].x==0.0f && C5CirOutPoint[GrindMarkOutCnt+k].y==0.0f) continue;
															 if(C5CirInPoint [GrindMarkInCnt +k].x==0.0f && C5CirInPoint [GrindMarkInCnt +k].y==0.0f) continue;
															 if((GrindMarkOutCnt+k)>=C5CirOutEdgeCount                                              ) continue;
															 if((GrindMarkInCnt +k)>=C5CirInEdgeCount                                               ) continue;

															 GrindWidthDis = Math.GetLength(C5CirInPoint[GrindMarkInCnt+k], C5CirOutPoint[GrindMarkOutCnt+k]);
															 TotalCirDis+=   GrindWidthDis;
															 CircleCount++;
														 }
														 if(TotalCirDis!=0.0f && CircleCount!=0){
															 C5CirGrindWd = TotalCirDis/CircleCount;
															 C5CirGrindWd = C5CirGrindWd+0.5; //SubPixel
														 }
													 }
												 }
											 }
										 }
										 else         { //Polygon EnCap 계산시 OutPoint 중간값 기준 실측 거리 평균값을 계산한다(LeftTop) 
											 if(C5CirInEdgeCount!=0 && C5CirOutEdgeCount!=0){
												 GrindMeaDis =0.0f, MinDis =10000.0f; GrindMarkOutCnt=0;
												 GrindMarkOutCnt = (int)(C5CirOutEdgeCount/2);
												 // 최단거리OUtCount기준 InData 최단거리 Count정보 Calc 
												 if(GrindMarkOutCnt!=0){
													 GrindMeaDis =0.0f, MinDis =10000.0f; GrindMarkInCnt=0;
													 for(int k=0; k<C5CirInEdgeCount; k++){
														 if(C5CirInPoint[k].x   ==0.0f             || C5CirInPoint[k].y                ==0.0f) continue;
														 if(C5CirOutPoint[GrindMarkOutCnt].x==0.0f || C5CirOutPoint[GrindMarkOutCnt].y ==0.0f) continue;

														 GrindMeaDis = Math.GetLength(C5CirOutPoint[GrindMarkOutCnt], C5CirInPoint[k]);
														 if(GrindMeaDis<MinDis){
															 MinDis = GrindMeaDis;
															 GrindMarkInCnt = k;
														 }
													 }
												 }

												 // GrindMark기준 수직 포인트 주변값 Avg산출한다 ==>연마량 측정(OutData,InData기준)
												 if((GrindMarkOutCnt!=0 && GrindMarkOutCnt>5) && (GrindMarkInCnt!=0 && GrindMarkInCnt>5)){
													 CircleCount=0,TotalCirDis=0.0f,GrindWidthDis=0.0f;
													 for(int k=-5; k<5; k++){
														 if(C5CirOutPoint[GrindMarkOutCnt+k].x==0.0f && C5CirOutPoint[GrindMarkOutCnt+k].y==0.0f) continue;
														 if(C5CirInPoint [GrindMarkInCnt +k].x==0.0f && C5CirInPoint [GrindMarkInCnt +k].y==0.0f) continue;
														 if((GrindMarkOutCnt+k)>=C5CirOutEdgeCount                                              ) continue;
														 if((GrindMarkInCnt +k)>=C5CirInEdgeCount                                               ) continue;

														 GrindWidthDis = Math.GetLength(C5CirInPoint[GrindMarkInCnt+k], C5CirOutPoint[GrindMarkOutCnt+k]);
														 TotalCirDis+=   GrindWidthDis;
														 CircleCount++;
													 }
													 if(TotalCirDis!=0.0f && CircleCount!=0){
														 C5CirGrindWd = TotalCirDis/CircleCount;
														 C5CirGrindWd = C5CirGrindWd+0.5; //SubPixel
													 }
												 }
											 }
										 }
										 ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
										 // FAVION Circle Fitting 결과물(Circle_1)
										 SampleSize   = C5CirInEdgeCount*0.75; //0.5~0.8이하로 입력할것
										 DistDevRatio = 0.15                 ; //0.1~0.25 이하로 입력할것
										 CircleFit->OnRansac(C5CirInPoint,C5CirInEdgeCount,SampleSize,DistDevRatio,&CircleFit5Center,&CirFitDiameter5);

										 // Polygon 박리 검사 시퀀스 
										 if(!IsMarkBtm && BrokenThresHold!=0){
											 RotateBrokenImg.SetSize(RotateImg.GetWidth(), RotateImg.GetHeight());
											 EasyImage::Oper(EArithmeticLogicOperation_Copy,&RotateImg,&RotateBrokenImg);
											 EasyImage::Threshold(&RotateImg,&RotateBrokenImg, BrokenThresHold);
											 Edge->GImage = &RotateBrokenImg;
											 Edge->SetEdgeType(0);

											 int DvCnt =0, DataCount=0;
											 double deg =0.0f; 
											 TFPoint Target(0.0f, 0.0f);

											 if(GrindMarkInCnt>GrindMarkOutCnt){
												 DvCnt = GrindMarkInCnt - GrindMarkOutCnt;
												 for(int k=0; k<C5CirOutEdgeCount; k++){
													 deg =0.0f, Target.x =0.0f, Target.y =0.0f;
													 if(((k+DvCnt)<C5CirInEdgeCount) && C5CirInPoint[k+DvCnt].x>0  && C5CirInPoint[k+DvCnt].y>0){
														 deg = Math.GetDegree(C5CirOutPoint[k],C5CirInPoint[k+DvCnt]);

														 Target  = Math.OnFindPerpendicularPointXY(C5CirOutPoint[k],dEdgeToTrapLineDis,dEdgeToTrapLineDis,deg);
														 Edge->OnExecute(C5CirOutPoint[k],Target); // 연마외곽라인에서 Target까지 White Point Search 
														 if(Edge->GetResultEdgePointCount()>0){
															 C5CircleData[DataCount].Dis =0.0f;
															 C5CircleData[DataCount].Dv  =0.0f;
															 C5CircleData[DataCount].P   = Edge->GetResultEdgePoint(0);
															 C5CircleData[DataCount].P.y = C5CircleData[DataCount].P.y - ImageHeight; // Frame기준 단위좌표로 변경함  
															 DataCount++;
														 }
													 }
												 }
												 C5CirInCrackCount = DataCount;
											 }
											 else if(GrindMarkInCnt<GrindMarkOutCnt)   {
												 DvCnt = GrindMarkOutCnt - GrindMarkInCnt;
												 for(int k=DvCnt; k<C5CirOutEdgeCount; k++){
													 deg =0.0f, Target.x =0.0f, Target.y =0.0f;
													 if(((k-DvCnt)<C5CirInEdgeCount) && C5CirInPoint[k-DvCnt].x>0  && C5CirInPoint[k-DvCnt].y>0 && k-DvCnt>=0){
														 deg = Math.GetDegree(C5CirOutPoint[k],C5CirInPoint[k-DvCnt]);

														 Target  = Math.OnFindPerpendicularPointXY(C5CirOutPoint[k],dEdgeToTrapLineDis,dEdgeToTrapLineDis,deg);
														 Edge->OnExecute(C5CirOutPoint[k],Target); // 연마외곽라인에서 Target까지 White Point Search 
														 if(Edge->GetResultEdgePointCount()>0){
															 C5CircleData[DataCount].Dis =0.0f;
															 C5CircleData[DataCount].Dv  =0.0f;
															 C5CircleData[DataCount].P   = Edge->GetResultEdgePoint(0);
															 C5CircleData[DataCount].P.y = C5CircleData[DataCount].P.y - ImageHeight; // Frame기준 단위좌표로 변경함  
															 DataCount++;
														 }
													 }
												 }
												 C5CirInCrackCount = DataCount;
											 }
										 }
										 LogUnit.SetLog(L"CellID:%d, CamID:%d ==>Polygon5_Insp_End",CellId,CamId);
									 }
									 
									 // 여섯번째 Polygon, Circle 6
									 if(PolyRect[5].left!=0 && PolyRect[5].top!=0 && PolyRect[5].right!=0 && PolyRect[5].bottom!=0){
										 P1.x=0, P1.y=0, P2.x=0, P2.y=0, P3.x=0, P3.y=0, P4.x=0, P4.y=0;
										 LogUnit.SetLog(L"CellID:%d, CamID:%d ==>Polygon6_Insp_Start",CellId,CamId);

// 										 P1.x = (PolyRect[5].left-30); P1.y =(PolyRect[5].top-20          ); P2.x = (P1.x+PolyRect[5].Width()+60); P2.y = (P1.y);
// 										 P3.x = (PolyRect[5].left-30); P3.y =(P1.y+PolyRect[5].Height()+40); P4.x = (P2.x                       ); P4.y = (P3.y);

// 										 P1.x = (PolyRect[5].left+50); P1.y =(PolyRect[5].top             ); P2.x = (P1.x+PolyRect[5].Width()); P2.y = (P1.y);
// 										 P3.x = (PolyRect[5].left+50); P3.y =(P1.y+PolyRect[5].Height()+50); P4.x = (P2.x                    ); P4.y = (P3.y);

										 P1.x = (PolyRect[5].left); P1.y =(PolyRect[5].top             ); P2.x = (P1.x+PolyRect[5].Width()); P2.y = (P1.y);
										 P3.x = (PolyRect[5].left); P3.y =(P1.y+PolyRect[5].Height()+50); P4.x = (P2.x                    ); P4.y = (P3.y);


										 // Median Filter 적용 
										 if(P1.x<=0    || P1.y<=0    || (P2.x - P1.x)<=0    || (P3.y - P1.y)<=0   ) return false;
										 if(P1.x>=ImgW || P1.y>=ImgH || (P2.x - P1.x)>=ImgW || (P3.y - P1.y)>=ImgH) return false;
										 FilterROI.SetSize(int(P2.x - P1.x),int(P3.y - P1.y) )                      ;
										 FilterROI.Attach(&RotateBinaryImg)                                    ;
										 FilterROI.SetPlacement(P1.x, P1.y, int(P2.x - P1.x), int(P3.y - P1.y));
										 EasyImage::Median(&FilterROI, &FilterROI)                             ;

										 Polygon->GImage          = &RotateBinaryImg           ;
										 Polygon->PoPa.FMaxWidth  =(int)(CSideCircleWidth+100 );
										 Polygon->PoPa.FMaxHeight =(int)(CSideCircleHeight+100);
										 Polygon->PoPa.IsSeparate =true                        ;
										 Polygon->PoPa.IsInToOut  =true                        ;
										 Polygon->PoPa.HiThHold   = BtmEdgeThresHold           ;
										 Polygon->PoPa.LoThHold   = 0                          ;
										 Polygon->PoPa.FMinWidth  =(int)(CSideCircleWidth /2)  ;
										 Polygon->PoPa.FMinHeight =(int)(CSideCircleHeight/2)  ;

										 if(P1.x!=0 && P1.y!=0 && P2.x!=0 && P2.y!=0 && P3.x!=0 && P3.y!=0 && P4.x!=0 && P4.y!=0){
											 Polygon->OnExecute(P1,P2,P3,P4);
										 }

										 // Polygon Algorithm InEdgeData/OutEdgeData Separate 및 데이터 추출 
										 if(Polygon->BlobCount==1){
											 PolygonMarginCnt =10;
											 if(Polygon->Blob[0].InCnt>(PolygonMarginCnt*2)){
												 C6CirInEdgeCount=0;
												 C6CirInEdgeCount = (Polygon->Blob[0].InCnt - (PolygonMarginCnt*2));
												 if(C6CirInEdgeCount>0){
													 if(C6CirInPoint!=NULL) {
														 delete[] C6CirInPoint;
													 }
													 C6CirInPoint = new TFPoint[C6CirInEdgeCount];

													 PixelCnt=0;
													 for(int k=0; k<Polygon->Blob[0].InCnt; k++){
														 if(k<PolygonMarginCnt || k>=(Polygon->Blob[0].InCnt-PolygonMarginCnt)) continue;
														 C6CirInPoint[PixelCnt].x   = Polygon->Blob[0].InPoint[k].x ;
														 C6CirInPoint[PixelCnt].y   = Polygon->Blob[0].InPoint[k].y ;
														 PixelCnt++;
													 }
												 }
											 }

											 if(Polygon->Blob[0].OutCnt>(PolygonMarginCnt*2)){
												 C6CirOutEdgeCount=0;
												 C6CirOutEdgeCount = (Polygon->Blob[0].OutCnt - (PolygonMarginCnt*2));
												 if(C6CirOutEdgeCount>0){
													 if(C6CirOutPoint!=NULL) delete[] C6CirOutPoint;
													 C6CirOutPoint = new TFPoint[C6CirOutEdgeCount];

													 PixelCnt=0;
													 for(int k=0; k<Polygon->Blob[0].OutCnt; k++){
														 if(k<PolygonMarginCnt || k>=(Polygon->Blob[0].OutCnt-PolygonMarginCnt)) continue;
														 C6CirOutPoint[PixelCnt].x  = Polygon->Blob[0].OutPoint[k].x ;
														 C6CirOutPoint[PixelCnt].y  = Polygon->Blob[0].OutPoint[k].y ;

														 if(k==PolygonMarginCnt){ //직선구간에 필요한 시작점  
															 BtmEdgePoint[9].x = C6CirOutPoint[PixelCnt].x;
															 BtmEdgePoint[9].y = C6CirOutPoint[PixelCnt].y;
														 }
														 PixelCnt++;
													 }
												 }
											 }
											 // Polygon Data Clear
// 											 Polygon->ClearData();
										 }
										 /////////////////////////////////////////////////////////////////////////////////////////////

										 // InEdgeData/OutEdgeData 기준 가공량 및 연마량 계산
										 // Polygon 알고리즘에서는 GrindMark기준 OutData,InData 최단거리 2개 Tag값 산출해야함 
										 if(IsMarkBtm){ // LTPS 가공량,연마량 계산 
											 if(C6CirOutEdgeCount!=0 && C6CirInEdgeCount!=0){ // MarkMode경우 가공량 검사를 먼저 진행 후 연마량 산출 

												 // GrindMark[17]기준 연마량,가공량 측정 시퀀스 
												 ////////////////////////////////////////////////////////////////////////////////////
												 if(GrindMarkPoint[17].x!=0.0f && GrindMarkPoint[17].y!=0.0f){  //GrindMark 찾았을경우 
													 // GrindMark기준 OutData 최단거리 Count정보 Calc 
													 GrindMeaDis =0.0f, MinDis =10000.0f; GrindMarkOutCnt=0;
													 for(int k=0; k<C6CirOutEdgeCount; k++){
														 if(C6CirOutPoint[k].x  ==0.0f || C6CirOutPoint[k].y ==0.0f ) continue;
														 if(GrindMarkPoint[17].x==0.0f || GrindMarkPoint[17].y==0.0f) continue;

														 GrindMeaDis = Math.GetLength(GrindMarkPoint[17], C6CirOutPoint[k]);
														 if(GrindMeaDis<MinDis){
															 MinDis = GrindMeaDis;
															 GrindMarkOutCnt = k;
														 }
													 }

													 // GrindMark기준 InData 최단거리 Count정보 Calc 
													 if(GrindMarkOutCnt!=0){
														 GrindMeaDis =0.0f, MinDis =10000.0f; GrindMarkInCnt=0;
														 for(int k=0; k<C6CirInEdgeCount; k++){
															 if(C6CirInPoint[k].x   ==0.0f             || C6CirInPoint[k].y                ==0.0f) continue;
															 if(C6CirOutPoint[GrindMarkOutCnt].x==0.0f || C6CirOutPoint[GrindMarkOutCnt].y ==0.0f) continue;

															 GrindMeaDis = Math.GetLength(C6CirOutPoint[GrindMarkOutCnt], C6CirInPoint[k]);
															 if(GrindMeaDis<MinDis){
																 MinDis = GrindMeaDis;
																 GrindMarkInCnt = k;
															 }
														 }
													 }

													 // GrindMark기준 수직 포인트 주변값 Avg산출한다 ==>가공량 측정(OutData기준)
													 if(GrindMarkOutCnt!=0 && GrindMarkOutCnt>5){
														 CircleCount=0,TotalCirDis=0.0f,GrindMeaDis=0.0f;
														 for(int k=GrindMarkOutCnt-5; k<GrindMarkOutCnt+5; k++){
															 if(C6CirOutPoint[k].x==0.0f || C6CirOutPoint[k].y==0.0f) continue;
															 if(k>=C6CirOutEdgeCount                                ) continue;

															 GrindMeaDis = Math.GetLength(GrindMarkPoint[17], C6CirOutPoint[k]);
															 TotalCirDis+= GrindMeaDis;
															 CircleCount++;
														 }
														 if(TotalCirDis!=0.0f && CircleCount!=0){
															 C6CirGrindMea = TotalCirDis/CircleCount;
															 C6CirGrindMea = C6CirGrindMea+0.5; //SubPixel 
														 }
													 }

													 // GrindMark기준 수직 포인트 주변값 Avg산출한다 ==>연마량 측정(OutData,InData기준)
													 if((GrindMarkOutCnt!=0 && GrindMarkOutCnt>5) && (GrindMarkInCnt!=0 && GrindMarkInCnt>5)){
														 CircleCount=0,TotalCirDis=0.0f,GrindWidthDis=0.0f;
														 for(int k=-5; k<5; k++){
															 if(C6CirOutPoint[GrindMarkOutCnt+k].x==0.0f && C6CirOutPoint[GrindMarkOutCnt+k].y==0.0f) continue;
															 if(C6CirInPoint [GrindMarkInCnt +k].x==0.0f && C6CirInPoint [GrindMarkInCnt +k].y==0.0f) continue;
															 if((GrindMarkOutCnt+k)>=C6CirOutEdgeCount                                              ) continue;
															 if((GrindMarkInCnt +k)>=C6CirInEdgeCount                                               ) continue;

															 GrindWidthDis = Math.GetLength(C6CirInPoint[GrindMarkInCnt+k], C6CirOutPoint[GrindMarkOutCnt+k]);
															 TotalCirDis+=   GrindWidthDis;
															 CircleCount++;
														 }
														 if(TotalCirDis!=0.0f && CircleCount!=0){
															 C6CirGrindWd = TotalCirDis/CircleCount;
															 C6CirGrindWd = C6CirGrindWd+0.5; //SubPixel
														 }
													 }
												 }
												 else if(GrindMarkRect[17].left!=0 && GrindMarkRect[17].top!=0 && GrindMarkRect[17].right!=0 &&GrindMarkRect[17].bottom!=0){  //GrindMark 못 찾았을경우
													 // OutData기준 최소값 데이터 Count산출 
													 GrindMeaDis =0.0f, MinDis =10000.0f; GrindMarkOutCnt=0;
													 for(int k=0; k<C6CirOutEdgeCount; k++){
														 if(C6CirOutPoint[k].x==0.0f || C6CirOutPoint[k].y==0.0f) continue;

														 GrindMarkRectCenter[17].x = GrindMarkRect[17].left + (GrindMarkRect[17].right  - GrindMarkRect[17].left)/2; 
														 GrindMarkRectCenter[17].y = GrindMarkRect[17].top  + (GrindMarkRect[17].bottom - GrindMarkRect[17].top )/2; 

														 GrindMeaDis = Math.GetLength(GrindMarkRectCenter[17], C6CirOutPoint[k]);
														 if(GrindMeaDis<MinDis){
															 MinDis = GrindMeaDis;
															 GrindMarkOutCnt = k;
														 }
													 }

													 // 최단거리OUtCount기준 InData 최단거리 Count정보 Calc 
													 if(GrindMarkOutCnt!=0){
														 GrindMeaDis =0.0f, MinDis =10000.0f; GrindMarkInCnt=0;
														 for(int k=0; k<C6CirInEdgeCount; k++){
															 if(C6CirInPoint[k].x   ==0.0f             || C6CirInPoint[k].y                ==0.0f) continue;
															 if(C6CirOutPoint[GrindMarkOutCnt].x==0.0f || C6CirOutPoint[GrindMarkOutCnt].y ==0.0f) continue;

															 GrindMeaDis = Math.GetLength(C6CirOutPoint[GrindMarkOutCnt], C6CirInPoint[k]);
															 if(GrindMeaDis<MinDis){
																 MinDis = GrindMeaDis;
																 GrindMarkInCnt = k;
															 }
														 }
													 }

													 // GrindMark기준 수직 포인트 주변값 Avg산출한다 ==>연마량 측정(OutData,InData기준)
													 if((GrindMarkOutCnt!=0 && GrindMarkOutCnt>5) && (GrindMarkInCnt!=0 && GrindMarkInCnt>5)){
														 CircleCount=0,TotalCirDis=0.0f,GrindWidthDis=0.0f;
														 for(int k=-5; k<5; k++){
															 if(C6CirOutPoint[GrindMarkOutCnt+k].x==0.0f && C6CirOutPoint[GrindMarkOutCnt+k].y==0.0f) continue;
															 if(C6CirInPoint [GrindMarkInCnt +k].x==0.0f && C6CirInPoint [GrindMarkInCnt +k].y==0.0f) continue;
															 if((GrindMarkOutCnt+k)>=C6CirOutEdgeCount                                              ) continue;
															 if((GrindMarkInCnt +k)>=C6CirInEdgeCount                                               ) continue;

															 GrindWidthDis = Math.GetLength(C6CirInPoint[GrindMarkInCnt+k], C6CirOutPoint[GrindMarkOutCnt+k]);
															 TotalCirDis+=   GrindWidthDis;
															 CircleCount++;
														 }
														 if(TotalCirDis!=0.0f && CircleCount!=0){
															 C6CirGrindWd = TotalCirDis/CircleCount;
															 C6CirGrindWd = C6CirGrindWd+0.5; //SubPixel
														 }
													 }
												 }

												 // GrindMark[18]기준 연마량,가공량 측정 시퀀스 
												 ////////////////////////////////////////////////////////////////////////////////////
												 if(GrindMarkPoint[18].x!=0.0f && GrindMarkPoint[18].y!=0.0f){  //GrindMark 찾았을경우 
													 // GrindMark기준 OutData 최단거리 Count정보 Calc 
													 GrindMeaDis =0.0f, MinDis =10000.0f; GrindMarkOutCnt=0;
													 for(int k=0; k<C6CirOutEdgeCount; k++){
														 if(C6CirOutPoint[k].x  ==0.0f || C6CirOutPoint[k].y ==0.0f ) continue;
														 if(GrindMarkPoint[18].x==0.0f || GrindMarkPoint[18].y==0.0f) continue;

														 GrindMeaDis = Math.GetLength(GrindMarkPoint[18], C6CirOutPoint[k]);
														 if(GrindMeaDis<MinDis){
															 MinDis = GrindMeaDis;
															 GrindMarkOutCnt = k;
														 }
													 }

													 // GrindMark기준 InData 최단거리 Count정보 Calc 
													 if(GrindMarkOutCnt!=0){
														 GrindMeaDis =0.0f, MinDis =10000.0f; GrindMarkInCnt=0;
														 for(int k=0; k<C6CirInEdgeCount; k++){
															 if(C6CirInPoint[k].x   ==0.0f             || C6CirInPoint[k].y                ==0.0f) continue;
															 if(C6CirOutPoint[GrindMarkOutCnt].x==0.0f || C6CirOutPoint[GrindMarkOutCnt].y ==0.0f) continue;

															 GrindMeaDis = Math.GetLength(C6CirOutPoint[GrindMarkOutCnt], C6CirInPoint[k]);
															 if(GrindMeaDis<MinDis){
																 MinDis = GrindMeaDis;
																 GrindMarkInCnt = k;
															 }
														 }
													 }

													 // GrindMark기준 수직 포인트 주변값 Avg산출한다 ==>가공량 측정(OutData기준)
													 if(GrindMarkOutCnt!=0 && GrindMarkOutCnt>5){
														 CircleCount=0,TotalCirDis=0.0f,GrindMeaDis=0.0f;
														 for(int k=GrindMarkOutCnt-5; k<GrindMarkOutCnt+5; k++){
															 if(C6CirOutPoint[k].x==0.0f || C6CirOutPoint[k].y==0.0f) continue;
															 if(k>=C6CirOutEdgeCount                                ) continue;

															 GrindMeaDis = Math.GetLength(GrindMarkPoint[18], C6CirOutPoint[k]);
															 TotalCirDis+= GrindMeaDis;
															 CircleCount++;
														 }
														 if(TotalCirDis!=0.0f && CircleCount!=0){
															 C7CirGrindMea = TotalCirDis/CircleCount;
															 C7CirGrindMea = C7CirGrindMea+0.5; //SubPixel 
														 }
													 }

													 // GrindMark기준 수직 포인트 주변값 Avg산출한다 ==>연마량 측정(OutData,InData기준)
													 if((GrindMarkOutCnt!=0 && GrindMarkOutCnt>5) && (GrindMarkInCnt!=0 && GrindMarkInCnt>5)){
														 CircleCount=0,TotalCirDis=0.0f,GrindWidthDis=0.0f;
														 for(int k=-5; k<5; k++){
															 if(C6CirOutPoint[GrindMarkOutCnt+k].x==0.0f && C6CirOutPoint[GrindMarkOutCnt+k].y==0.0f) continue;
															 if(C6CirInPoint [GrindMarkInCnt +k].x==0.0f && C6CirInPoint [GrindMarkInCnt +k].y==0.0f) continue;
															 if((GrindMarkOutCnt+k)>=C6CirOutEdgeCount                                              ) continue;
															 if((GrindMarkInCnt +k)>=C6CirInEdgeCount                                               ) continue;

															 GrindWidthDis = Math.GetLength(C6CirInPoint[GrindMarkInCnt+k], C6CirOutPoint[GrindMarkOutCnt+k]);
															 TotalCirDis+=   GrindWidthDis;
															 CircleCount++;
														 }
														 if(TotalCirDis!=0.0f && CircleCount!=0){
															 C7CirGrindWd = TotalCirDis/CircleCount;
															 C7CirGrindWd = C7CirGrindWd+0.5; //SubPixel
														 }
													 }
												 }
												 else if(GrindMarkRect[18].left!=0 && GrindMarkRect[18].top!=0 && GrindMarkRect[18].right!=0 && GrindMarkRect[18].bottom!=0) {  //GrindMark 못 찾았을경우
													 // OutData기준 최소값 데이터 Count산출 
													 GrindMeaDis =0.0f, MinDis =10000.0f; GrindMarkOutCnt=0;
													 for(int k=0; k<C6CirOutEdgeCount; k++){
														 if(C6CirOutPoint[k].x==0.0f || C6CirOutPoint[k].y==0.0f) continue;

														 GrindMarkRectCenter[18].x = GrindMarkRect[18].left + (GrindMarkRect[18].right  - GrindMarkRect[18].left)/2; 
														 GrindMarkRectCenter[18].y = GrindMarkRect[18].top  + (GrindMarkRect[18].bottom - GrindMarkRect[18].top )/2; 

														 GrindMeaDis = Math.GetLength(GrindMarkRectCenter[18], C6CirOutPoint[k]);
														 if(GrindMeaDis<MinDis){
															 MinDis = GrindMeaDis;
															 GrindMarkOutCnt = k;
														 }
													 }

													 // 최단거리OUtCount기준 InData 최단거리 Count정보 Calc 
													 if(GrindMarkOutCnt!=0){
														 GrindMeaDis =0.0f, MinDis =10000.0f; GrindMarkInCnt=0;
														 for(int k=0; k<C6CirInEdgeCount; k++){
															 if(C6CirInPoint[k].x   ==0.0f             || C6CirInPoint[k].y                ==0.0f) continue;
															 if(C6CirOutPoint[GrindMarkOutCnt].x==0.0f || C6CirOutPoint[GrindMarkOutCnt].y ==0.0f) continue;

															 GrindMeaDis = Math.GetLength(C6CirOutPoint[GrindMarkOutCnt], C6CirInPoint[k]);
															 if(GrindMeaDis<MinDis){
																 MinDis = GrindMeaDis;
																 GrindMarkInCnt = k;
															 }
														 }
													 }

													 // GrindMark기준 수직 포인트 주변값 Avg산출한다 ==>연마량 측정(OutData,InData기준)
													 if((GrindMarkOutCnt!=0 && GrindMarkOutCnt>5) && (GrindMarkInCnt!=0 && GrindMarkInCnt>5)){
														 CircleCount=0,TotalCirDis=0.0f,GrindWidthDis=0.0f;
														 for(int k=-5; k<5; k++){
															 if(C6CirOutPoint[GrindMarkOutCnt+k].x==0.0f && C6CirOutPoint[GrindMarkOutCnt+k].y==0.0f) continue;
															 if(C6CirInPoint [GrindMarkInCnt +k].x==0.0f && C6CirInPoint [GrindMarkInCnt +k].y==0.0f) continue;
															 if((GrindMarkOutCnt+k)>=C6CirOutEdgeCount                                              ) continue;
															 if((GrindMarkInCnt +k)>=C6CirInEdgeCount                                               ) continue;

															 GrindWidthDis = Math.GetLength(C6CirInPoint[GrindMarkInCnt+k], C6CirOutPoint[GrindMarkOutCnt+k]);
															 TotalCirDis+=   GrindWidthDis;
															 CircleCount++;
														 }
														 if(TotalCirDis!=0.0f && CircleCount!=0){
															 C7CirGrindWd = TotalCirDis/CircleCount;
															 C7CirGrindWd = C7CirGrindWd+0.5; //SubPixel
														 }
													 }
												 }
											 }
										 }
										 else         { //Polygon EnCap 계산시 OutPoint 중간값 기준 실측 거리 평균값을 계산한다(LeftTop) 
											 if(C6CirInEdgeCount!=0 && C6CirOutEdgeCount!=0){
												 GrindMeaDis =0.0f, MinDis =10000.0f; GrindMarkOutCnt=0;
												 GrindMarkOutCnt = (int)(C6CirOutEdgeCount/2);
												 // 최단거리OUtCount기준 InData 최단거리 Count정보 Calc 
												 if(GrindMarkOutCnt!=0){
													 GrindMeaDis =0.0f, MinDis =10000.0f; GrindMarkInCnt=0;
													 for(int k=0; k<C6CirInEdgeCount; k++){
														 if(C6CirInPoint[k].x   ==0.0f             || C6CirInPoint[k].y                ==0.0f) continue;
														 if(C6CirOutPoint[GrindMarkOutCnt].x==0.0f || C6CirOutPoint[GrindMarkOutCnt].y ==0.0f) continue;

														 GrindMeaDis = Math.GetLength(C6CirOutPoint[GrindMarkOutCnt], C6CirInPoint[k]);
														 if(GrindMeaDis<MinDis){
															 MinDis = GrindMeaDis;
															 GrindMarkInCnt = k;
														 }
													 }
												 }

												 // GrindMark기준 수직 포인트 주변값 Avg산출한다 ==>연마량 측정(OutData,InData기준)
												 if((GrindMarkOutCnt!=0 && GrindMarkOutCnt>5) && (GrindMarkInCnt!=0 && GrindMarkInCnt>5)){
													 CircleCount=0,TotalCirDis=0.0f,GrindWidthDis=0.0f;
													 for(int k=-5; k<5; k++){
														 if(C6CirOutPoint[GrindMarkOutCnt+k].x==0.0f && C6CirOutPoint[GrindMarkOutCnt+k].y==0.0f) continue;
														 if(C6CirInPoint [GrindMarkInCnt +k].x==0.0f && C6CirInPoint [GrindMarkInCnt +k].y==0.0f) continue;
														 if((GrindMarkOutCnt+k)>=C6CirOutEdgeCount                                              ) continue;
														 if((GrindMarkInCnt +k)>=C6CirInEdgeCount                                               ) continue;

														 GrindWidthDis = Math.GetLength(C6CirInPoint[GrindMarkInCnt+k], C6CirOutPoint[GrindMarkOutCnt+k]);
														 TotalCirDis+=   GrindWidthDis;
														 CircleCount++;
													 }
													 if(TotalCirDis!=0.0f && CircleCount!=0){
														 C6CirGrindWd = TotalCirDis/CircleCount;
														 C6CirGrindWd = C6CirGrindWd+0.5; //SubPixel
													 }
												 }
											 }
										 }
										 ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
										 // FAVION Circle Fitting 결과물(Circle_1)
										 SampleSize   = C6CirInEdgeCount*0.75; //0.5~0.8이하로 입력할것
										 DistDevRatio = 0.15                 ; //0.1~0.25 이하로 입력할것
										 CircleFit->OnRansac(C6CirInPoint,C6CirInEdgeCount,SampleSize,DistDevRatio,&CircleFit6Center,&CirFitDiameter6);

										 // Polygon 박리 검사 시퀀스 
										 if(!IsMarkBtm && BrokenThresHold!=0){
											 RotateBrokenImg.SetSize(RotateImg.GetWidth(), RotateImg.GetHeight());
											 EasyImage::Oper(EArithmeticLogicOperation_Copy,&RotateImg,&RotateBrokenImg);
											 EasyImage::Threshold(&RotateImg,&RotateBrokenImg, BrokenThresHold);
// 											 RotateBrokenImg.Save("D:\\ROTATE_IMG\\Polygon_하단박리.bmp");
											 Edge->GImage = &RotateBrokenImg;
											 Edge->SetEdgeType(0);

											 int DvCnt =0, DataCount=0;
											 double deg =0.0f; 
											 TFPoint Target(0.0f, 0.0f);

											 if(GrindMarkInCnt>GrindMarkOutCnt){
												 DvCnt = GrindMarkInCnt - GrindMarkOutCnt;
												 for(int k=0; k<C6CirOutEdgeCount; k++){
													 deg =0.0f, Target.x =0.0f, Target.y =0.0f;
													 if(((k+DvCnt)<C6CirInEdgeCount) && C6CirInPoint[k+DvCnt].x>0  && C6CirInPoint[k+DvCnt].y>0){
														 deg = Math.GetDegree(C6CirOutPoint[k],C6CirInPoint[k+DvCnt]);

														 Target  = Math.OnFindPerpendicularPointXY(C6CirOutPoint[k],-dEdgeToTrapLineDis,-dEdgeToTrapLineDis,deg);
														 Edge->OnExecute(C6CirOutPoint[k],Target); // 연마외곽라인에서 Target까지 White Point Search 
														 if(Edge->GetResultEdgePointCount()>0){
															 C6CircleData[DataCount].Dis =0.0f;
															 C6CircleData[DataCount].Dv  =0.0f;
															 C6CircleData[DataCount].P   = Edge->GetResultEdgePoint(0);
															 C6CircleData[DataCount].P.y = C6CircleData[DataCount].P.y - ImageHeight; // Frame기준 단위좌표로 변경함  
															 DataCount++;
														 }
													 }
												 }
												 C6CirInCrackCount = DataCount;
											 }
											 else if(GrindMarkInCnt<GrindMarkOutCnt)   {
												 DvCnt = GrindMarkOutCnt - GrindMarkInCnt;
												 for(int k=DvCnt; k<C6CirOutEdgeCount; k++){
													 deg =0.0f, Target.x =0.0f, Target.y =0.0f;
													 if(((k-DvCnt)<C6CirInEdgeCount) && C6CirInPoint[k-DvCnt].x>0  && C6CirInPoint[k-DvCnt].y>0 && k-DvCnt>=0){
														 deg = Math.GetDegree(C6CirOutPoint[k],C6CirInPoint[k-DvCnt]);

														 Target  = Math.OnFindPerpendicularPointXY(C6CirOutPoint[k],-dEdgeToTrapLineDis,-dEdgeToTrapLineDis,deg);
														 Edge->OnExecute(C6CirOutPoint[k],Target); // 연마외곽라인에서 Target까지 White Point Search 
														 if(Edge->GetResultEdgePointCount()>0){
															 C6CircleData[DataCount].Dis =0.0f;
															 C6CircleData[DataCount].Dv  =0.0f;
															 C6CircleData[DataCount].P   = Edge->GetResultEdgePoint(0);
															 C6CircleData[DataCount].P.y = C6CircleData[DataCount].P.y - ImageHeight; // Frame기준 단위좌표로 변경함  
															 DataCount++;
														 }
													 }
												 }
												 C6CirInCrackCount = DataCount;
											 }
										 }
										 LogUnit.SetLog(L"CellID:%d, CamID:%d ==>Polygon6_Insp_End",CellId,CamId);
									 }

									 // 비선형 곡선 영역을 제외한 직선 영역 검사 시퀀스 
									 // 첫번째 직선 영역 
									 if(BtmEdgePoint[0].x!=0 && BtmEdgePoint[0].y!=0 && BtmEdgePoint[1].x!=0 && BtmEdgePoint[1].y!=0 ){
										 P1.x=0, P1.y=0, P2.x=0, P2.y=0, P3.x=0, P3.y=0, P4.x=0, P4.y=0;
										 LogUnit.SetLog(L"CellID:%d, CamID:%d ==>Straight1_Insp_Start",CellId,CamId);

										 P1.x = (BtmEdgePoint[0].x); P1.y =(BtmEdgePoint[0].y-30); P2.x = (P1.x+(BtmEdgePoint[1].x - BtmEdgePoint[0].x )); P2.y = (P1.y);
										 P3.x = (BtmEdgePoint[0].x); P3.y =(BtmEdgePoint[0].y+30); P4.x = (P2.x                                         ); P4.y = (P3.y);

										 // Median Filter 적용 
										 if(P1.x<=0    || P1.y<=0    || (P2.x - P1.x)<=0    || (P3.y - P1.y)<=0   ) return false;
										 if(P1.x>=ImgW || P1.y>=ImgH || (P2.x - P1.x)>=ImgW || (P3.y - P1.y)>=ImgH) return false;
										 FilterROI.SetSize(int(P2.x - P1.x),int(P3.y - P1.y) )                      ;
										 FilterROI.Attach(&RotateBinaryImg)                                    ;
										 FilterROI.SetPlacement(P1.x, P1.y, int(P2.x - P1.x), int(P3.y - P1.y));
										 EasyImage::Median(&FilterROI, &FilterROI)                             ;

										 Polygon->PoPa.FMinHeight = 5                          ;
										 Polygon->GImage          = &RotateBinaryImg           ;
										 Polygon->PoPa.FMaxWidth  =(int)(P2.x - P1.x)+100      ;
										 Polygon->PoPa.FMaxHeight =(int)(P3.y - P1.y)          ;
										 Polygon->PoPa.FMinWidth  =(int)(P2.x - P1.x)-100      ; 
										 Polygon->PoPa.IsSeparate =true                        ;
										 Polygon->PoPa.IsInToOut  =true                        ;
										 Polygon->PoPa.HiThHold   = BtmEdgeThresHold           ;
										 Polygon->PoPa.LoThHold   = 0                          ;

										 if(P1.x!=0 && P1.y!=0 && P2.x!=0 && P2.y!=0 && P3.x!=0 && P3.y!=0 && P4.x!=0 && P4.y!=0){
											 Polygon->OnExecute(P1,P2,P3,P4);
										 }

										 // Polygon Algorithm InEdgeData/OutEdgeData Separate 및 데이터 추출 
										 if(Polygon->BlobCount==1){
											 PolygonMarginCnt =10;
											 if(Polygon->Blob[0].InCnt>(PolygonMarginCnt*2)){
												 OrgBtm1InEdgeCount=0;
												 OrgBtm1InEdgeCount = (Polygon->Blob[0].InCnt - (PolygonMarginCnt*2));
												 if(OrgBtm1InEdgeCount>0){
													 if(OrgBtm1InPoint!=NULL) delete[] OrgBtm1InPoint;
													 OrgBtm1InPoint = new TFPoint[OrgBtm1InEdgeCount];

													 PixelCnt=0;
													 for(int k=0; k<Polygon->Blob[0].InCnt; k++){
														 if(k<PolygonMarginCnt || k>=(Polygon->Blob[0].InCnt-PolygonMarginCnt)) continue;
														 OrgBtm1InPoint[PixelCnt].x   = Polygon->Blob[0].InPoint[k].x ;
														 OrgBtm1InPoint[PixelCnt].y   = Polygon->Blob[0].InPoint[k].y ;
														 PixelCnt++;
													 }
												 }
												 // Org Data 
												 BtmInLine[0].FP0 = OrgBtm1InPoint[0];
												 BtmInLine[0].FP1 = OrgBtm1InPoint[PixelCnt-1];
											 }

											 if(Polygon->Blob[0].OutCnt>(PolygonMarginCnt*2)){
												 OrgBtm1OutEdgeCount=0;
												 OrgBtm1OutEdgeCount = (Polygon->Blob[0].OutCnt - (PolygonMarginCnt*2));
												 if(OrgBtm1OutEdgeCount>0){
													 if(OrgBtm1OutPoint!=NULL) delete[] OrgBtm1OutPoint;
													 OrgBtm1OutPoint = new TFPoint[OrgBtm1OutEdgeCount];

													 PixelCnt=0;
													 for(int k=0; k<Polygon->Blob[0].OutCnt; k++){
														 if(k<PolygonMarginCnt || k>=(Polygon->Blob[0].OutCnt-PolygonMarginCnt)) continue;
														 OrgBtm1OutPoint[PixelCnt].x  = Polygon->Blob[0].OutPoint[k].x ;
														 OrgBtm1OutPoint[PixelCnt].y  = Polygon->Blob[0].OutPoint[k].y ;
														 PixelCnt++;
													 }
												 }
												 // Org Data 
												 BtmOutLine[0].FP0 = OrgBtm1OutPoint[0];
												 BtmOutLine[0].FP1 = OrgBtm1OutPoint[PixelCnt-1];
											 }
											 // Polygon Data Clear
// 											 Polygon->ClearData();
										 }

										 // 연마량 측정 및 가공량 측정 (비선형)
										 if(IsMarkBtm){
											 if(OrgBtm1InEdgeCount>10 && OrgBtm1OutEdgeCount>10){
												 // 가공량,연마량 측정 전 데이터 존재시 가상GrindMark 생성한다 
												 if(GrindMarkPoint[2].x!=0.0f && GrindMarkPoint[2].y!=0.0f && GrindRectSpec[4].DvX==0.0f && GrindRectSpec[4].DvY==0.0f &&!IsNarrowTrench){
													 GrindMarkPoint[4].x     = OrgBtm1InPoint[OrgBtm1InEdgeCount-10].x ;
													 GrindMarkPoint[4].y     = GrindMarkPoint[2].y                     ;
													 GrindMarkRect [4].left  = GrindMarkPoint[4].x    - GrindMarkRange ;  
													 GrindMarkRect [4].top   = GrindMarkPoint[4].y    - GrindMarkRange ;  
													 GrindMarkRect [4].right = GrindMarkRect [4].left + GrindMarkLength;  
													 GrindMarkRect [4].bottom= GrindMarkRect [4].top  + GrindMarkLength;  
												 }
												 // GrindMark[2] 가공량,연마량 측정 
												 ////////////////////////////////////////////////////////////////////////////////////////////////////
												 if(GrindMarkPoint[2].x!=0.0f && GrindMarkPoint[2].y!=0.0f) { 
													 // GrindMark기준 OutData 최단거리 Count정보 Calc 
													 GrindMeaDis =0.0f, MinDis =10000.0f;  GrindMarkOutCnt=0;
													 for(int k=0; k<OrgBtm1OutEdgeCount; k++){
														 if(OrgBtm1OutPoint[k].x==0.0f || OrgBtm1OutPoint[k].y==0.0f) continue;
														 if(GrindMarkPoint[2].x ==0.0f || GrindMarkPoint[2].y ==0.0f) continue;

														 GrindMeaDis = Math.GetLength(GrindMarkPoint[2], OrgBtm1OutPoint[k]);
														 if(GrindMeaDis<MinDis){
															 MinDis = GrindMeaDis;
															 GrindMarkOutCnt = k;
														 }
													 }

													 // GrindMark기준 InData 최단거리 Count정보 Calc 
													 if(GrindMarkOutCnt!=0){
														 GrindMeaDis =0.0f, MinDis =10000.0f; GrindMarkInCnt=0;
														 for(int k=0; k<OrgBtm1InEdgeCount; k++){
															 if(OrgBtm1InPoint[k].x   ==0.0f             || OrgBtm1InPoint[k].y                ==0.0f) continue;
															 if(OrgBtm1OutPoint[GrindMarkOutCnt].x==0.0f || OrgBtm1OutPoint[GrindMarkOutCnt].y ==0.0f) continue;

															 GrindMeaDis = Math.GetLength(OrgBtm1OutPoint[GrindMarkOutCnt], OrgBtm1InPoint[k]);
															 if(GrindMeaDis<MinDis){
																 MinDis = GrindMeaDis;
																 GrindMarkInCnt = k;
															 }
														 }
													 }

													 // GrindMark기준 수직 포인트 주변값 Avg산출한다 ==>가공량 측정(OutData기준)
													 if(GrindMarkOutCnt!=0 && GrindMarkOutCnt>5){
														 CircleCount=0,TotalCirDis=0.0f,GrindMeaDis=0.0f;
														 for(int k=GrindMarkOutCnt-5; k<GrindMarkOutCnt+5; k++){
															 if(OrgBtm1OutPoint[k].x==0.0f || OrgBtm1OutPoint[k].y==0.0f) continue;
															 if(k>=OrgBtm1OutEdgeCount                                  ) continue;

															 GrindMeaDis = Math.GetLength(GrindMarkPoint[2], OrgBtm1OutPoint[k]);
															 TotalCirDis+= GrindMeaDis;
															 CircleCount++;
														 }
														 if(TotalCirDis!=0.0f && CircleCount!=0){
															 BtmGrindMeasure1 = TotalCirDis/CircleCount;
															 BtmGrindMeasure1 = BtmGrindMeasure1+0.5; //SubPixel 
														 }
													 }

													 // GrindMark기준 수직 포인트 주변값 Avg산출한다 ==>연마량 측정(OutData,InData기준)
													 if((GrindMarkOutCnt!=0 && GrindMarkOutCnt>5) && (GrindMarkInCnt!=0 && GrindMarkInCnt>5)){
														 CircleCount=0,TotalCirDis=0.0f,GrindWidthDis=0.0f;
														 for(int k=-5; k<5; k++){
															 if(OrgBtm1OutPoint[GrindMarkOutCnt+k].x==0.0f && OrgBtm1OutPoint[GrindMarkOutCnt+k].y==0.0f) continue;
															 if(OrgBtm1InPoint [GrindMarkInCnt +k].x==0.0f && OrgBtm1InPoint [GrindMarkInCnt +k].y==0.0f) continue;
															 if((GrindMarkOutCnt+k)>=OrgBtm1OutEdgeCount                                                ) continue;
															 if((GrindMarkInCnt +k)>=OrgBtm1InEdgeCount                                                 ) continue;

															 GrindWidthDis = Math.GetLength(OrgBtm1InPoint[GrindMarkInCnt+k], OrgBtm1OutPoint[GrindMarkOutCnt+k]);
															 TotalCirDis+=   GrindWidthDis;
															 CircleCount++;
														 }
														 if(TotalCirDis!=0.0f && CircleCount!=0){
															 BtmGrindWidth1 = TotalCirDis/CircleCount;
															 BtmGrindWidth1 = BtmGrindWidth1+0.5; //SubPixel
														 }
													 }
												 }
												 else if(GrindMarkRect[2].left!=0 && GrindMarkRect[2].top!=0 && GrindMarkRect[2].right!=0 && GrindMarkRect[2].bottom!=0) {  //GrindMark 못 찾았을경우
													 // OutData기준 최소값 데이터 Count산출 
													 GrindMeaDis =0.0f, MinDis =10000.0f; GrindMarkOutCnt=0;
													 for(int k=0; k<OrgBtm1OutEdgeCount; k++){
														 if(OrgBtm1OutPoint[k].x==0.0f || OrgBtm1OutPoint[k].y==0.0f) continue;

														 GrindMarkRectCenter[2].x = GrindMarkRect[2].left + (GrindMarkRect[2].right  - GrindMarkRect[2].left)/2; 
														 GrindMarkRectCenter[2].y = GrindMarkRect[2].top  + (GrindMarkRect[2].bottom - GrindMarkRect[2].top )/2; 

														 GrindMeaDis = Math.GetLength(GrindMarkRectCenter[2], OrgBtm1OutPoint[k]);
														 if(GrindMeaDis<MinDis){
															 MinDis = GrindMeaDis;
															 GrindMarkOutCnt = k;
														 }
													 }

													 // 최단거리OUtCount기준 InData 최단거리 Count정보 Calc 
													 if(GrindMarkOutCnt!=0){
														 GrindMeaDis =0.0f, MinDis =10000.0f; GrindMarkInCnt=0;
														 for(int k=0; k<OrgBtm1InEdgeCount; k++){
															 if(OrgBtm1InPoint[k].x              ==0.0f  || OrgBtm1InPoint[k].y                ==0.0f) continue;
															 if(OrgBtm1OutPoint[GrindMarkOutCnt].x==0.0f || OrgBtm1OutPoint[GrindMarkOutCnt].y ==0.0f) continue;

															 GrindMeaDis = Math.GetLength(OrgBtm1OutPoint[GrindMarkOutCnt], OrgBtm1InPoint[k]);
															 if(GrindMeaDis<MinDis){
																 MinDis = GrindMeaDis;
																 GrindMarkInCnt = k;
															 }
														 }
													 }

													 // GrindMark기준 수직 포인트 주변값 Avg산출한다 ==>연마량 측정(OutData,InData기준)
													 if((GrindMarkOutCnt!=0 && GrindMarkOutCnt>5) && (GrindMarkInCnt!=0 && GrindMarkInCnt>5)){
														 CircleCount=0,TotalCirDis=0.0f,GrindWidthDis=0.0f;
														 for(int k=-5; k<5; k++){
															 if(OrgBtm1OutPoint[GrindMarkOutCnt+k].x==0.0f && OrgBtm1OutPoint[GrindMarkOutCnt+k].y==0.0f) continue;
															 if(OrgBtm1InPoint [GrindMarkInCnt +k].x==0.0f && OrgBtm1InPoint [GrindMarkInCnt +k].y==0.0f) continue;
															 if((GrindMarkOutCnt+k)>=OrgBtm1OutEdgeCount                                                ) continue;
															 if((GrindMarkInCnt +k)>=OrgBtm1InEdgeCount                                                 ) continue;

															 GrindWidthDis = Math.GetLength(OrgBtm1InPoint[GrindMarkInCnt+k], OrgBtm1OutPoint[GrindMarkOutCnt+k]);
															 TotalCirDis+=   GrindWidthDis;
															 CircleCount++;
														 }
														 if(TotalCirDis!=0.0f && CircleCount!=0){
															 BtmGrindWidth1 = TotalCirDis/CircleCount;
															 BtmGrindWidth1 = BtmGrindWidth1+0.5; //SubPixel
														 }
													 }
												 }

												 // GrindMark[4] 가공량,연마량 측정 
												 ////////////////////////////////////////////////////////////////////////////////////////////////////
												 if(GrindMarkPoint[4].x!=0.0f && GrindMarkPoint[4].y!=0.0f){ 
													 // GrindMark기준 OutData 최단거리 Count정보 Calc 
													 GrindMeaDis =0.0f, MinDis =10000.0f;  GrindMarkOutCnt=0;
													 for(int k=0; k<OrgBtm1OutEdgeCount; k++){
														 if(OrgBtm1OutPoint[k].x==0.0f || OrgBtm1OutPoint[k].y==0.0f) continue;
														 if(GrindMarkPoint[4].x ==0.0f || GrindMarkPoint[4].y ==0.0f) continue;

														 GrindMeaDis = Math.GetLength(GrindMarkPoint[4], OrgBtm1OutPoint[k]);
														 if(GrindMeaDis<MinDis){
															 MinDis = GrindMeaDis;
															 GrindMarkOutCnt = k;
														 }
													 }

													 // GrindMark기준 InData 최단거리 Count정보 Calc 
													 if(GrindMarkOutCnt!=0){
														 GrindMeaDis =0.0f, MinDis =10000.0f; GrindMarkInCnt=0;
														 for(int k=0; k<OrgBtm1InEdgeCount; k++){
															 if(OrgBtm1InPoint[k].x   ==0.0f             || OrgBtm1InPoint[k].y                ==0.0f) continue;
															 if(OrgBtm1OutPoint[GrindMarkOutCnt].x==0.0f || OrgBtm1OutPoint[GrindMarkOutCnt].y ==0.0f) continue;

															 GrindMeaDis = Math.GetLength(OrgBtm1OutPoint[GrindMarkOutCnt], OrgBtm1InPoint[k]);
															 if(GrindMeaDis<MinDis){
																 MinDis = GrindMeaDis;
																 GrindMarkInCnt = k;
															 }
														 }
													 }

													 // GrindMark기준 수직 포인트 주변값 Avg산출한다 ==>가공량 측정(OutData기준)
													 if(GrindMarkOutCnt!=0 && GrindMarkOutCnt>5){
														 CircleCount=0,TotalCirDis=0.0f,GrindMeaDis=0.0f;
														 for(int k=GrindMarkOutCnt-5; k<GrindMarkOutCnt+5; k++){
															 if(OrgBtm1OutPoint[k].x==0.0f || OrgBtm1OutPoint[k].y==0.0f) continue;
															 if(k>=OrgBtm1OutEdgeCount                                  ) continue;

															 GrindMeaDis = Math.GetLength(GrindMarkPoint[4], OrgBtm1OutPoint[k]);
															 TotalCirDis+= GrindMeaDis;
															 CircleCount++;
														 }
														 if(TotalCirDis!=0.0f && CircleCount!=0){
															 BtmGrindMeasure3 = TotalCirDis/CircleCount;
															 BtmGrindMeasure3 = BtmGrindMeasure3+0.5; //SubPixel 
														 }
													 }

													 // GrindMark기준 수직 포인트 주변값 Avg산출한다 ==>연마량 측정(OutData,InData기준)
													 if((GrindMarkOutCnt!=0 && GrindMarkOutCnt>5) && (GrindMarkInCnt!=0 && GrindMarkInCnt>5)){
														 CircleCount=0,TotalCirDis=0.0f,GrindWidthDis=0.0f;
														 for(int k=-5; k<5; k++){
															 if(OrgBtm1OutPoint[GrindMarkOutCnt+k].x==0.0f && OrgBtm1OutPoint[GrindMarkOutCnt+k].y==0.0f) continue;
															 if(OrgBtm1InPoint [GrindMarkInCnt +k].x==0.0f && OrgBtm1InPoint [GrindMarkInCnt +k].y==0.0f) continue;
															 if((GrindMarkOutCnt+k)>=OrgBtm1OutEdgeCount                                                ) continue;
															 if((GrindMarkInCnt +k)>=OrgBtm1InEdgeCount                                                 ) continue;

															 GrindWidthDis = Math.GetLength(OrgBtm1InPoint[GrindMarkInCnt+k], OrgBtm1OutPoint[GrindMarkOutCnt+k]);
															 TotalCirDis+=   GrindWidthDis;
															 CircleCount++;
														 }
														 if(TotalCirDis!=0.0f && CircleCount!=0){
															 BtmGrindWidth3 = TotalCirDis/CircleCount;
															 BtmGrindWidth3 = BtmGrindWidth3+0.5; //SubPixel
														 }
													 }
												 }
												 else if(GrindMarkRect[4].left!=0 && GrindMarkRect[4].top!=0 && GrindMarkRect[4].right!=0 && GrindMarkRect[4].bottom!=0) {  //GrindMark 못 찾았을경우
													 // OutData기준 최소값 데이터 Count산출 
													 GrindMeaDis =0.0f, MinDis =10000.0f; GrindMarkOutCnt=0;
													 for(int k=0; k<OrgBtm1OutEdgeCount; k++){
														 if(OrgBtm1OutPoint[k].x==0.0f || OrgBtm1OutPoint[k].y==0.0f) continue;

														 // 가상마크 사용 유무에 따라서 데이터 다르게 생성함 
														 if(k==0 && GrindRectSpec[4].DvX==0.0f && GrindRectSpec[4].DvY==0.0f){// 가상마크 사용 
															 GrindMarkRectCenter[4].x     =  OrgBtm1InPoint[OrgBtm1InEdgeCount-10].x;
															 GrindMarkRectCenter[4].y     =  GrindMarkRectCenter[2].y               ;

															 GrindMarkRect [4].left  = GrindMarkRectCenter[4].x  - GrindMarkRange  ;  
															 GrindMarkRect [4].top   = GrindMarkRectCenter[4].y  - GrindMarkRange  ;  
															 GrindMarkRect [4].right = GrindMarkRect [4].left    + GrindMarkLength ;  
															 GrindMarkRect [4].bottom= GrindMarkRect [4].top     + GrindMarkLength ;  
														 }
														 else if(k==0 && GrindRectSpec[4].DvX!=0.0f && GrindRectSpec[4].DvY!=0.0f){ //진성마크 사용 
															 GrindMarkRectCenter[4].x = GrindMarkRect[4].left + (GrindMarkRect[4].right  - GrindMarkRect[4].left)/2; 
															 GrindMarkRectCenter[4].y = GrindMarkRect[4].top  + (GrindMarkRect[4].bottom - GrindMarkRect[4].top )/2; 
														 }

														 GrindMeaDis = Math.GetLength(GrindMarkRectCenter[4], OrgBtm1OutPoint[k]);
														 if(GrindMeaDis<MinDis){
															 MinDis = GrindMeaDis;
															 GrindMarkOutCnt = k;
														 }
													 }

													 // 최단거리OUtCount기준 InData 최단거리 Count정보 Calc 
													 if(GrindMarkOutCnt!=0){
														 GrindMeaDis =0.0f, MinDis =10000.0f; GrindMarkInCnt=0;
														 for(int k=0; k<OrgBtm1InEdgeCount; k++){
															 if(OrgBtm1InPoint[k].x              ==0.0f  || OrgBtm1InPoint[k].y                ==0.0f) continue;
															 if(OrgBtm1OutPoint[GrindMarkOutCnt].x==0.0f || OrgBtm1OutPoint[GrindMarkOutCnt].y ==0.0f) continue;

															 GrindMeaDis = Math.GetLength(OrgBtm1OutPoint[GrindMarkOutCnt], OrgBtm1InPoint[k]);
															 if(GrindMeaDis<MinDis){
																 MinDis = GrindMeaDis;
																 GrindMarkInCnt = k;
															 }
														 }
													 }

													 // GrindMark기준 수직 포인트 주변값 Avg산출한다 ==>연마량 측정(OutData,InData기준)
													 if((GrindMarkOutCnt!=0 && GrindMarkOutCnt>5) && (GrindMarkInCnt!=0 && GrindMarkInCnt>5)){
														 CircleCount=0,TotalCirDis=0.0f,GrindWidthDis=0.0f;
														 for(int k=-5; k<5; k++){
															 if(OrgBtm1OutPoint[GrindMarkOutCnt+k].x==0.0f && OrgBtm1OutPoint[GrindMarkOutCnt+k].y==0.0f) continue;
															 if(OrgBtm1InPoint [GrindMarkInCnt +k].x==0.0f && OrgBtm1InPoint [GrindMarkInCnt +k].y==0.0f) continue;
															 if((GrindMarkOutCnt+k)>=OrgBtm1OutEdgeCount                                                ) continue;
															 if((GrindMarkInCnt +k)>=OrgBtm1InEdgeCount                                                 ) continue;

															 GrindWidthDis = Math.GetLength(OrgBtm1InPoint[GrindMarkInCnt+k], OrgBtm1OutPoint[GrindMarkOutCnt+k]);
															 TotalCirDis+=   GrindWidthDis;
															 CircleCount++;
														 }
														 if(TotalCirDis!=0.0f && CircleCount!=0){
															 BtmGrindWidth3 = TotalCirDis/CircleCount;
															 BtmGrindWidth3 = BtmGrindWidth3+0.5; //SubPixel
														 }
													 }
												 }
											 }
										 }
										 else { // ENCAP 연마량 데이터만 계측함
											 if(BtmOutLine[0].FP0.x!=0.0f && BtmOutLine[0].FP0.y!=0.0f && BtmOutLine[0].FP1.x!=0.0f && BtmOutLine[0].FP1.y!=0.0f &&
												 BtmInLine [0].FP0.x!=0.0f && BtmInLine [0].FP0.y!=0.0f && BtmInLine [0].FP1.x!=0.0f && BtmInLine [0].FP1.y!=0.0f ){
													 // 연마량 계산  
													 if((fabs(BtmOutLine[0].FP0.y - BtmOutLine[0].FP1.y))>1
														 ||(fabs(BtmInLine[0].FP0.y - BtmInLine[0].FP1.y))>1){
															 BtmGrindWidth1 = BtmOutLine[0].FP0.y - BtmInLine[0].FP0.y; 
													 }
													 else{
														 BtmGrindWidth1 = Math.GetLengthFrLineToPoint(BtmOutLine[0].FP0, BtmOutLine[0].FP1, BtmInLine[0].FP0);
													 }
											 }
										 }
										 // 동적 생성한 데이터를 지운다 
										 if(OrgBtm1InPoint !=NULL) delete[] OrgBtm1InPoint;
										 if(OrgBtm1OutPoint!=NULL) delete[] OrgBtm1OutPoint;
										 LogUnit.SetLog(L"CellID:%d, CamID:%d ==>Straight1_Insp_End",CellId,CamId);
									 }

									 // 비선형 곡선 영역을 제외한 직선 영역 검사 시퀀스 
									 // 세번째 직선 영역 
									 if(BtmEdgePoint[4].x!=0 && BtmEdgePoint[4].y!=0 && BtmEdgePoint[5].x!=0 && BtmEdgePoint[5].y!=0 ){
										 P1.x=0, P1.y=0, P2.x=0, P2.y=0, P3.x=0, P3.y=0, P4.x=0, P4.y=0;
										 LogUnit.SetLog(L"CellID:%d, CamID:%d ==>Straight3_Insp_Start",CellId,CamId);

										 // Trench 내측부 Circle형태 ROI영역 설정 (NarrowTrench)
										 if((GrindRectSpec[8].DvX!=0.0f && GrindRectSpec[8].DvY!=0.0f) ||(IsNarrowTrench)){
											 if(GrindMarkRect[9].left!=0 && GrindMarkRect[9].top!=0 && GrindMarkRect[9].right!=0 && GrindMarkRect[9].bottom!=0){// LTPS
												 GrindMarkRectCenter[9].y = GrindMarkRect[9].top  + (GrindMarkRect[9].bottom - GrindMarkRect[9].top )/2; 
												 if(BtmEdgePoint[4].y>GrindMarkRectCenter[9].y){
													 P1.x = (BtmEdgePoint[4].x);                             P1.y =(BtmEdgePoint[4].y-(BtmEdgePoint[4].y-GrindMarkRectCenter[9].y)); 
													 P2.x = (P1.x+(BtmEdgePoint[5].x - BtmEdgePoint[4].x )); P2.y =(P1.y);
													 P3.x = (BtmEdgePoint[4].x);                             P3.y =(BtmEdgePoint[4].y+30); 
													 P4.x = (P2.x                                         ); P4.y =(P3.y);
												 }
											 }
											 else { // EnCap
												 P1.x = (BtmEdgePoint[4].x);                             P1.y =(BtmEdgePoint[4].y-(int)(CELL_D/2)); 
												 P2.x = (P1.x+(BtmEdgePoint[5].x - BtmEdgePoint[4].x )); P2.y =(P1.y);
												 P3.x = (BtmEdgePoint[4].x);                             P3.y =(BtmEdgePoint[4].y+30); 
												 P4.x = (P2.x                                         ); P4.y =(P3.y);
											 }
										 }
										 else { // Trench 내측부 직선형태 ROI영역 설정 
											 P1.x = (BtmEdgePoint[4].x); P1.y =(BtmEdgePoint[4].y-30); P2.x = (P1.x+(BtmEdgePoint[5].x - BtmEdgePoint[4].x )); P2.y = (P1.y);
											 P3.x = (BtmEdgePoint[4].x); P3.y =(BtmEdgePoint[4].y+30); P4.x = (P2.x                                         ); P4.y = (P3.y);
										 }

										 // Median Filter 적용 
										 if(P1.x<=0    || P1.y<=0    || (P2.x - P1.x)<=0    || (P3.y - P1.y)<=0   ) return false;
										 if(P1.x>=ImgW || P1.y>=ImgH || (P2.x - P1.x)>=ImgW || (P3.y - P1.y)>=ImgH) return false;
										 FilterROI.SetSize(int(P2.x - P1.x),int(P3.y - P1.y) )                      ;
										 FilterROI.Attach(&RotateBinaryImg)                                    ;
										 FilterROI.SetPlacement(P1.x, P1.y, int(P2.x - P1.x), int(P3.y - P1.y));
										 EasyImage::Median(&FilterROI, &FilterROI)                             ;
// 										 RotateBinaryImg.Save("D:\\ROTATE_IMG\\Polygon직선영역_필터.bmp")      ;


										 Polygon->GImage          = &RotateBinaryImg      ;
										 Polygon->PoPa.FMaxWidth  =(int)(P2.x - P1.x)+100 ;
										 Polygon->PoPa.FMaxHeight =(int)(P3.y - P1.y)+100 ;
										 Polygon->PoPa.FMinWidth  =(int)(P2.x - P1.x)-100 ; 
										 Polygon->PoPa.IsSeparate =true                   ;
										 Polygon->PoPa.IsInToOut  =true                   ;
										 Polygon->PoPa.HiThHold   = BtmEdgeThresHold      ;
										 Polygon->PoPa.LoThHold   = 0                     ;

										 if(P1.x!=0 && P1.y!=0 && P2.x!=0 && P2.y!=0 && P3.x!=0 && P3.y!=0 && P4.x!=0 && P4.y!=0){
											 Polygon->OnExecute(P1,P2,P3,P4);
										 }

										 // Polygon Algorithm InEdgeData/OutEdgeData Separate 및 데이터 추출 
										 if(Polygon->BlobCount==1){
											 PolygonMarginCnt =10;
											 if(IsNarrowTrench){ // Narrow Trench(비선형 곡선 형태)
												 if(Polygon->Blob[0].InCnt>(PolygonMarginCnt*2)){
													 Btm3InEdgeCount=0;
													 Btm3InEdgeCount = (Polygon->Blob[0].InCnt - (PolygonMarginCnt*2));
													 if(Btm3InEdgeCount>0){
														 if(Btm3InPoint!=NULL) delete[] Btm3InPoint;
														 Btm3InPoint = new TFPoint[Btm3InEdgeCount];

														 PixelCnt=0;
														 for(int k=0; k<Polygon->Blob[0].InCnt; k++){
															 if(k<PolygonMarginCnt || k>=(Polygon->Blob[0].InCnt-PolygonMarginCnt)) continue;
															 Btm3InPoint[PixelCnt].x    = Polygon->Blob[0].InPoint[k].x ;
															 Btm3InPoint[PixelCnt].y    = Polygon->Blob[0].InPoint[k].y ;
															 PixelCnt++;
														 }
													 }
												 }

												 if(Polygon->Blob[0].OutCnt>(PolygonMarginCnt*2)){
													 Btm3OutEdgeCount=0;
													 Btm3OutEdgeCount = (Polygon->Blob[0].OutCnt - (PolygonMarginCnt*2));
													 if(Btm3OutEdgeCount>0){
														 if(Btm3OutPoint!=NULL) delete[] Btm3OutPoint;
														 Btm3OutPoint = new TFPoint[Btm3OutEdgeCount];

														 PixelCnt=0;
														 for(int k=0; k<Polygon->Blob[0].OutCnt; k++){
															 if(k<PolygonMarginCnt || k>=(Polygon->Blob[0].OutCnt-PolygonMarginCnt)) continue;
															 Btm3OutPoint[PixelCnt].x   = Polygon->Blob[0].OutPoint[k].x ;
															 Btm3OutPoint[PixelCnt].y   = Polygon->Blob[0].OutPoint[k].y ;
															 PixelCnt++;
														 }
													 }
												 }
											 }
											 else              { // Normal Trench(직선 형태)
												 if(Polygon->Blob[0].InCnt>(PolygonMarginCnt*2)){
													 OrgBtm3InEdgeCount=0;
													 OrgBtm3InEdgeCount = (Polygon->Blob[0].InCnt - (PolygonMarginCnt*2));
													 if(OrgBtm3InEdgeCount>0){
														 if(OrgBtm3InPoint!=NULL) delete[] OrgBtm3InPoint;
														 OrgBtm3InPoint = new TFPoint[OrgBtm3InEdgeCount];

														 PixelCnt=0;
														 for(int k=0; k<Polygon->Blob[0].InCnt; k++){
															 if(k<PolygonMarginCnt || k>=(Polygon->Blob[0].InCnt-PolygonMarginCnt)) continue;
															 OrgBtm3InPoint[PixelCnt].x   = Polygon->Blob[0].InPoint[k].x ;
															 OrgBtm3InPoint[PixelCnt].y   = Polygon->Blob[0].InPoint[k].y ;
															 PixelCnt++;
														 }
													 }
													 // Org Data 
													 BtmInLine[2].FP0 = OrgBtm3InPoint[0];
													 BtmInLine[2].FP1 = OrgBtm3InPoint[PixelCnt-1];
												 }

												 if(Polygon->Blob[0].OutCnt>(PolygonMarginCnt*2)){
													 OrgBtm3OutEdgeCount=0;
													 OrgBtm3OutEdgeCount = (Polygon->Blob[0].OutCnt - (PolygonMarginCnt*2));
													 if(OrgBtm3OutEdgeCount>0){
														 if(OrgBtm3OutPoint!=NULL) delete[] OrgBtm3OutPoint;
														 OrgBtm3OutPoint = new TFPoint[OrgBtm3OutEdgeCount];

														 PixelCnt=0;
														 for(int k=0; k<Polygon->Blob[0].OutCnt; k++){
															 if(k<PolygonMarginCnt || k>=(Polygon->Blob[0].OutCnt-PolygonMarginCnt)) continue;
															 OrgBtm3OutPoint[PixelCnt].x  = Polygon->Blob[0].OutPoint[k].x ;
															 OrgBtm3OutPoint[PixelCnt].y  = Polygon->Blob[0].OutPoint[k].y ;
															 PixelCnt++;
														 }
													 }
													 // Org Data 
													 BtmOutLine[2].FP0 = OrgBtm3OutPoint[0];
													 BtmOutLine[2].FP1 = OrgBtm3OutPoint[PixelCnt-1];
												 }
											 }
											 // Polygon Data Clear
// 											 Polygon->ClearData();
										 }

										 // 연마량 측정 및 가공량 측정 (비선형)
										 if(IsNarrowTrench){ // Trench 내측부 비선형 곡선일 경우 
											 if(IsMarkBtm){
												 if(Btm3InEdgeCount>10 && Btm3OutEdgeCount>10){
													 // GrindMark[8] 가공량,연마량 측정 
													 ////////////////////////////////////////////////////////////////////////////////////////////////////
													 if(GrindMarkPoint[8].x!=0.0f && GrindMarkPoint[8].y!=0.0f) { 
														 // GrindMark기준 OutData 최단거리 Count정보 Calc 
														 GrindMeaDis =0.0f, MinDis =10000.0f;  GrindMarkOutCnt=0;
														 for(int k=0; k<Btm3OutEdgeCount; k++){
															 if(Btm3OutPoint  [k].x ==0.0f || Btm3OutPoint  [k].y ==0.0f) continue;
															 if(GrindMarkPoint[8].x ==0.0f || GrindMarkPoint[8].y ==0.0f) continue;

															 GrindMeaDis = Math.GetLength(GrindMarkPoint[8], Btm3OutPoint[k]);
															 if(GrindMeaDis<MinDis){
																 MinDis = GrindMeaDis;
																 GrindMarkOutCnt = k;
															 }
														 }

														 // GrindMark기준 InData 최단거리 Count정보 Calc 
														 if(GrindMarkOutCnt!=0){
															 GrindMeaDis =0.0f, MinDis =10000.0f; GrindMarkInCnt=0;
															 for(int k=0; k<Btm3InEdgeCount; k++){
																 if(Btm3InPoint[k].x   ==0.0f             || Btm3InPoint[k].y                ==0.0f) continue;
																 if(Btm3OutPoint[GrindMarkOutCnt].x==0.0f || Btm3OutPoint[GrindMarkOutCnt].y ==0.0f) continue;

																 GrindMeaDis = Math.GetLength(Btm3OutPoint[GrindMarkOutCnt], Btm3InPoint[k]);
																 if(GrindMeaDis<MinDis){
																	 MinDis = GrindMeaDis;
																	 GrindMarkInCnt = k;
																 }
															 }
														 }

														 // GrindMark기준 수직 포인트 주변값 Avg산출한다 ==>가공량 측정(OutData기준)
														 if(GrindMarkOutCnt!=0 && GrindMarkOutCnt>5){
															 CircleCount=0,TotalCirDis=0.0f,GrindMeaDis=0.0f;
															 for(int k=GrindMarkOutCnt-5; k<GrindMarkOutCnt+5; k++){
																 if(Btm3OutPoint[k].x==0.0f || Btm3OutPoint[k].y==0.0f) continue;
																 if(k>=Btm3OutEdgeCount                               ) continue;

																 GrindMeaDis = Math.GetLength(GrindMarkPoint[8], Btm3OutPoint[k]);
																 TotalCirDis+= GrindMeaDis;
																 CircleCount++;
															 }
															 if(TotalCirDis!=0.0f && CircleCount!=0){
																 BtmGrindMeasure4 = TotalCirDis/CircleCount;
																 BtmGrindMeasure4 = BtmGrindMeasure4+0.5; //SubPixel 
															 }
														 }

														 // GrindMark기준 수직 포인트 주변값 Avg산출한다 ==>연마량 측정(OutData,InData기준)
														 if((GrindMarkOutCnt!=0 && GrindMarkOutCnt>5) && (GrindMarkInCnt!=0 && GrindMarkInCnt>5)){
															 CircleCount=0,TotalCirDis=0.0f,GrindWidthDis=0.0f;
															 for(int k=-5; k<5; k++){
																 if(Btm3OutPoint[GrindMarkOutCnt+k].x==0.0f && Btm3OutPoint[GrindMarkOutCnt+k].y==0.0f) continue;
																 if(Btm3InPoint [GrindMarkInCnt +k].x==0.0f && Btm3InPoint [GrindMarkInCnt +k].y==0.0f) continue;
																 if((GrindMarkOutCnt+k)>=Btm3OutEdgeCount                                             ) continue;
																 if((GrindMarkInCnt +k)>=Btm3InEdgeCount                                              ) continue;

																 GrindWidthDis = Math.GetLength(Btm3InPoint[GrindMarkInCnt+k], Btm3OutPoint[GrindMarkOutCnt+k]);
																 TotalCirDis+=   GrindWidthDis;
																 CircleCount++;
															 }
															 if(TotalCirDis!=0.0f && CircleCount!=0){
																 BtmGrindWidth4 = TotalCirDis/CircleCount;
																 BtmGrindWidth4 = BtmGrindWidth4+0.5; //SubPixel
															 }
														 }
													 }
													 else if(GrindMarkRect[8].left!=0 && GrindMarkRect[8].top!=0 && GrindMarkRect[8].right!=0 && GrindMarkRect[8].bottom!=0) {  //GrindMark 못 찾았을경우
														 // OutData기준 최소값 데이터 Count산출 
														 GrindMeaDis =0.0f, MinDis =10000.0f; GrindMarkOutCnt=0;
														 for(int k=0; k<Btm3OutEdgeCount; k++){
															 if(Btm3OutPoint[k].x==0.0f || Btm3OutPoint[k].y==0.0f) continue;

															 if(k==0 && GrindRectSpec[8].DvX!=0.0f && GrindRectSpec[8].DvY!=0.0f){ //진성마크 
																 GrindMarkRectCenter[8].x = GrindMarkRect[8].left + (GrindMarkRect[8].right  - GrindMarkRect[8].left)/2; 
																 GrindMarkRectCenter[8].y = GrindMarkRect[8].top  + (GrindMarkRect[8].bottom - GrindMarkRect[8].top )/2; 
															 }

															 GrindMeaDis = Math.GetLength(GrindMarkRectCenter[8], Btm3OutPoint[k]);
															 if(GrindMeaDis<MinDis){
																 MinDis = GrindMeaDis;
																 GrindMarkOutCnt = k;
															 }
														 }

														 // 최단거리OUtCount기준 InData 최단거리 Count정보 Calc 
														 if(GrindMarkOutCnt!=0){
															 GrindMeaDis =0.0f, MinDis =10000.0f; GrindMarkInCnt=0;
															 for(int k=0; k<Btm3InEdgeCount; k++){
																 if(Btm3InPoint[k].x              ==0.0f  || Btm3InPoint[k].y                ==0.0f) continue;
																 if(Btm3OutPoint[GrindMarkOutCnt].x==0.0f || Btm3OutPoint[GrindMarkOutCnt].y ==0.0f) continue;

																 GrindMeaDis = Math.GetLength(Btm3OutPoint[GrindMarkOutCnt], Btm3InPoint[k]);
																 if(GrindMeaDis<MinDis){
																	 MinDis = GrindMeaDis;
																	 GrindMarkInCnt = k;
																 }
															 }
														 }

														 // GrindMark기준 수직 포인트 주변값 Avg산출한다 ==>연마량 측정(OutData,InData기준)
														 if((GrindMarkOutCnt!=0 && GrindMarkOutCnt>5) && (GrindMarkInCnt!=0 && GrindMarkInCnt>5)){
															 CircleCount=0,TotalCirDis=0.0f,GrindWidthDis=0.0f;
															 for(int k=-5; k<5; k++){
																 if(Btm3OutPoint[GrindMarkOutCnt+k].x==0.0f && Btm3OutPoint[GrindMarkOutCnt+k].y==0.0f) continue;
																 if(Btm3InPoint [GrindMarkInCnt +k].x==0.0f && Btm3InPoint [GrindMarkInCnt +k].y==0.0f) continue;
																 if((GrindMarkOutCnt+k)>=Btm3OutEdgeCount                                             ) continue;
																 if((GrindMarkInCnt +k)>=Btm3InEdgeCount                                              ) continue;

																 GrindWidthDis = Math.GetLength(Btm3InPoint[GrindMarkInCnt+k], Btm3OutPoint[GrindMarkOutCnt+k]);
																 TotalCirDis+=   GrindWidthDis;
																 CircleCount++;
															 }
															 if(TotalCirDis!=0.0f && CircleCount!=0){
																 BtmGrindWidth4 = TotalCirDis/CircleCount;
																 BtmGrindWidth4 = BtmGrindWidth4+0.5; //SubPixel
															 }
														 }
													 }

													 // GrindMark[9] 가공량,연마량 측정 
													 ////////////////////////////////////////////////////////////////////////////////////////////////////
													 if(GrindMarkPoint[9].x!=0.0f && GrindMarkPoint[9].y!=0.0f) { 
														 // GrindMark기준 OutData 최단거리 Count정보 Calc 
														 GrindMeaDis =0.0f, MinDis =10000.0f;  GrindMarkOutCnt=0;
														 for(int k=0; k<Btm3OutEdgeCount; k++){
															 if(Btm3OutPoint[k].x   ==0.0f || Btm3OutPoint[k].y   ==0.0f) continue;
															 if(GrindMarkPoint[9].x ==0.0f || GrindMarkPoint[9].y ==0.0f) continue;

															 GrindMeaDis = Math.GetLength(GrindMarkPoint[9], Btm3OutPoint[k]);
															 if(GrindMeaDis<MinDis){
																 MinDis = GrindMeaDis;
																 GrindMarkOutCnt = k;
															 }
														 }

														 // GrindMark기준 InData 최단거리 Count정보 Calc 
														 if(GrindMarkOutCnt!=0){
															 GrindMeaDis =0.0f, MinDis =10000.0f; GrindMarkInCnt=0;
															 for(int k=0; k<Btm3InEdgeCount; k++){
																 if(Btm3InPoint[k].x               ==0.0f || Btm3InPoint[k].y                ==0.0f) continue;
																 if(Btm3OutPoint[GrindMarkOutCnt].x==0.0f || Btm3OutPoint[GrindMarkOutCnt].y ==0.0f) continue;

																 GrindMeaDis = Math.GetLength(Btm3OutPoint[GrindMarkOutCnt], Btm3InPoint[k]);
																 if(GrindMeaDis<MinDis){
																	 MinDis = GrindMeaDis;
																	 GrindMarkInCnt = k;
																 }
															 }
														 }

														 // GrindMark기준 수직 포인트 주변값 Avg산출한다 ==>가공량 측정(OutData기준)
														 if(GrindMarkOutCnt!=0 && GrindMarkOutCnt>5){
															 CircleCount=0,TotalCirDis=0.0f,GrindMeaDis=0.0f;
															 for(int k=GrindMarkOutCnt-5; k<GrindMarkOutCnt+5; k++){
																 if(Btm3OutPoint[k].x==0.0f || Btm3OutPoint[k].y==0.0f) continue;
																 if(k>=Btm3OutEdgeCount                               ) continue;

																 GrindMeaDis = Math.GetLength(GrindMarkPoint[9], Btm3OutPoint[k]);
																 TotalCirDis+= GrindMeaDis;
																 CircleCount++;
															 }
															 if(TotalCirDis!=0.0f && CircleCount!=0){
																 BtmGrindMeasure5 = TotalCirDis/CircleCount;
																 BtmGrindMeasure5 = BtmGrindMeasure5+0.5; //SubPixel 
															 }
														 }

														 // GrindMark기준 수직 포인트 주변값 Avg산출한다 ==>연마량 측정(OutData,InData기준)
														 if((GrindMarkOutCnt!=0 && GrindMarkOutCnt>5) && (GrindMarkInCnt!=0 && GrindMarkInCnt>5)){
															 CircleCount=0,TotalCirDis=0.0f,GrindWidthDis=0.0f;
															 for(int k=-5; k<5; k++){
																 if(Btm3OutPoint[GrindMarkOutCnt+k].x==0.0f && Btm3OutPoint[GrindMarkOutCnt+k].y==0.0f) continue;
																 if(Btm3InPoint [GrindMarkInCnt +k].x==0.0f && Btm3InPoint [GrindMarkInCnt +k].y==0.0f) continue;
																 if((GrindMarkOutCnt+k)>=Btm3OutEdgeCount                                             ) continue;
																 if((GrindMarkInCnt +k)>=Btm3InEdgeCount                                              ) continue;

																 GrindWidthDis = Math.GetLength(Btm3InPoint[GrindMarkInCnt+k], Btm3OutPoint[GrindMarkOutCnt+k]);
																 TotalCirDis+=   GrindWidthDis;
																 CircleCount++;
															 }
															 if(TotalCirDis!=0.0f && CircleCount!=0){
																 BtmGrindWidth5 = TotalCirDis/CircleCount;
																 BtmGrindWidth5 = BtmGrindWidth5+0.5; //SubPixel
															 }
														 }
													 }
													 else if(GrindMarkRect[9].left!=0 && GrindMarkRect[9].top!=0 && GrindMarkRect[9].right!=0 && GrindMarkRect[9].bottom!=0) { //GrindMark 못 찾았을경우
														 // OutData기준 최소값 데이터 Count산출 
														 GrindMeaDis =0.0f, MinDis =10000.0f; GrindMarkOutCnt=0;
														 for(int k=0; k<Btm3OutEdgeCount; k++){
															 if(Btm3OutPoint[k].x==0.0f || Btm3OutPoint[k].y==0.0f) continue;

															 if(k==0){ // 순서상 9번이 없는경우 
																 GrindMarkRectCenter[9].x = GrindMarkRect[9].left + (GrindMarkRect[9].right  - GrindMarkRect[9].left)/2; 
																 GrindMarkRectCenter[9].y = GrindMarkRect[9].top  + (GrindMarkRect[9].bottom - GrindMarkRect[9].top )/2; 
															 }

															 GrindMeaDis = Math.GetLength(GrindMarkRectCenter[9], Btm3OutPoint[k]);
															 if(GrindMeaDis<MinDis){
																 MinDis = GrindMeaDis;
																 GrindMarkOutCnt = k;
															 }
														 }

														 // 최단거리OUtCount기준 InData 최단거리 Count정보 Calc 
														 if(GrindMarkOutCnt!=0){
															 GrindMeaDis =0.0f, MinDis =10000.0f; GrindMarkInCnt=0;
															 for(int k=0; k<Btm3InEdgeCount; k++){
																 if(Btm3InPoint[k].x               ==0.0f || Btm3InPoint[k].y                ==0.0f) continue;
																 if(Btm3OutPoint[GrindMarkOutCnt].x==0.0f || Btm3OutPoint[GrindMarkOutCnt].y ==0.0f) continue;

																 GrindMeaDis = Math.GetLength(Btm3OutPoint[GrindMarkOutCnt], Btm3InPoint[k]);
																 if(GrindMeaDis<MinDis){
																	 MinDis = GrindMeaDis;
																	 GrindMarkInCnt = k;
																 }
															 }
														 }

														 // GrindMark기준 수직 포인트 주변값 Avg산출한다 ==>연마량 측정(OutData,InData기준)
														 if((GrindMarkOutCnt!=0 && GrindMarkOutCnt>5) && (GrindMarkInCnt!=0 && GrindMarkInCnt>5)){
															 CircleCount=0,TotalCirDis=0.0f,GrindWidthDis=0.0f;
															 for(int k=-5; k<5; k++){
																 if(Btm3OutPoint[GrindMarkOutCnt+k].x==0.0f && Btm3OutPoint[GrindMarkOutCnt+k].y==0.0f) continue;
																 if(Btm3InPoint [GrindMarkInCnt +k].x==0.0f && Btm3InPoint [GrindMarkInCnt +k].y==0.0f) continue;
																 if((GrindMarkOutCnt+k)>=Btm3OutEdgeCount                                             ) continue;
																 if((GrindMarkInCnt +k)>=Btm3InEdgeCount                                              ) continue;

																 GrindWidthDis = Math.GetLength(Btm3InPoint[GrindMarkInCnt+k], Btm3OutPoint[GrindMarkOutCnt+k]);
																 TotalCirDis+=   GrindWidthDis;
																 CircleCount++;
															 }
															 if(TotalCirDis!=0.0f && CircleCount!=0){
																 BtmGrindWidth5 = TotalCirDis/CircleCount;
																 BtmGrindWidth5 = BtmGrindWidth5+0.5; //SubPixel
															 }
														 }
													 }

													 // GrindMark[10] 가공량,연마량 측정 
													 ////////////////////////////////////////////////////////////////////////////////////////////////////
													 if(GrindMarkPoint[10].x!=0.0f && GrindMarkPoint[10].y!=0.0f) { 
														 // GrindMark기준 OutData 최단거리 Count정보 Calc 
														 GrindMeaDis =0.0f, MinDis =10000.0f;  GrindMarkOutCnt=0;
														 for(int k=0; k<Btm3OutEdgeCount; k++){
															 if(Btm3OutPoint[k].x    ==0.0f || Btm3OutPoint[k].y    ==0.0f) continue;
															 if(GrindMarkPoint[10].x ==0.0f || GrindMarkPoint[10].y ==0.0f) continue;

															 GrindMeaDis = Math.GetLength(GrindMarkPoint[10], Btm3OutPoint[k]);
															 if(GrindMeaDis<MinDis){
																 MinDis = GrindMeaDis;
																 GrindMarkOutCnt = k;
															 }
														 }

														 // GrindMark기준 InData 최단거리 Count정보 Calc 
														 if(GrindMarkOutCnt!=0){
															 GrindMeaDis =0.0f, MinDis =10000.0f; GrindMarkInCnt=0;
															 for(int k=0; k<Btm3InEdgeCount; k++){
																 if(Btm3InPoint [k].x              ==0.0f || Btm3InPoint[k].y                ==0.0f) continue;
																 if(Btm3OutPoint[GrindMarkOutCnt].x==0.0f || Btm3OutPoint[GrindMarkOutCnt].y ==0.0f) continue;

																 GrindMeaDis = Math.GetLength(Btm3OutPoint[GrindMarkOutCnt], Btm3InPoint[k]);
																 if(GrindMeaDis<MinDis){
																	 MinDis = GrindMeaDis;
																	 GrindMarkInCnt = k;
																 }
															 }
														 }

														 // GrindMark기준 수직 포인트 주변값 Avg산출한다 ==>가공량 측정(OutData기준)
														 if(GrindMarkOutCnt!=0 && GrindMarkOutCnt>5){
															 CircleCount=0,TotalCirDis=0.0f,GrindMeaDis=0.0f;
															 for(int k=GrindMarkOutCnt-5; k<GrindMarkOutCnt+5; k++){
																 if(Btm3OutPoint[k].x==0.0f || Btm3OutPoint[k].y==0.0f) continue;
																 if(k>=Btm3OutEdgeCount                               ) continue;

																 GrindMeaDis = Math.GetLength(GrindMarkPoint[10], Btm3OutPoint[k]);
																 TotalCirDis+= GrindMeaDis;
																 CircleCount++;
															 }
															 if(TotalCirDis!=0.0f && CircleCount!=0){
																 BtmGrindMeasure6 = TotalCirDis/CircleCount;
																 BtmGrindMeasure6 = BtmGrindMeasure6+0.5; //SubPixel 
															 }
														 }

														 // GrindMark기준 수직 포인트 주변값 Avg산출한다 ==>연마량 측정(OutData,InData기준)
														 if((GrindMarkOutCnt!=0 && GrindMarkOutCnt>5) && (GrindMarkInCnt!=0 && GrindMarkInCnt>5)){
															 CircleCount=0,TotalCirDis=0.0f,GrindWidthDis=0.0f;
															 for(int k=-5; k<5; k++){
																 if(Btm3OutPoint[GrindMarkOutCnt+k].x==0.0f && Btm3OutPoint[GrindMarkOutCnt+k].y==0.0f) continue;
																 if(Btm3InPoint [GrindMarkInCnt +k].x==0.0f && Btm3InPoint [GrindMarkInCnt +k].y==0.0f) continue;
																 if((GrindMarkOutCnt+k)>=Btm3OutEdgeCount                                             ) continue;
																 if((GrindMarkInCnt +k)>=Btm3InEdgeCount                                              ) continue;

																 GrindWidthDis = Math.GetLength(Btm3InPoint[GrindMarkInCnt+k], Btm3OutPoint[GrindMarkOutCnt+k]);
																 TotalCirDis+=   GrindWidthDis;
																 CircleCount++;
															 }
															 if(TotalCirDis!=0.0f && CircleCount!=0){
																 BtmGrindWidth6 = TotalCirDis/CircleCount;
																 BtmGrindWidth6 = BtmGrindWidth6+0.5; //SubPixel
															 }
														 }
													 }
													 else if(GrindMarkRect[10].left!=0 && GrindMarkRect[10].top!=0 && GrindMarkRect[10].right!=0 && GrindMarkRect[10].bottom!=0) {  //GrindMark 못 찾았을경우
														 // OutData기준 최소값 데이터 Count산출 
														 GrindMeaDis =0.0f, MinDis =10000.0f; GrindMarkOutCnt=0;
														 for(int k=0; k<Btm3OutEdgeCount; k++){
															 if(Btm3OutPoint[k].x==0.0f || Btm3OutPoint[k].y==0.0f) continue;

															 if(k==0 && GrindRectSpec[8].DvX!=0.0f && GrindRectSpec[8].DvY!=0.0f){ //진성마크 
																 GrindMarkRectCenter[10].x = GrindMarkRect[10].left + (GrindMarkRect[10].right  - GrindMarkRect[10].left)/2; 
																 GrindMarkRectCenter[10].y = GrindMarkRect[10].top  + (GrindMarkRect[10].bottom - GrindMarkRect[10].top )/2; 
															 }

															 GrindMeaDis = Math.GetLength(GrindMarkRectCenter[10], Btm3OutPoint[k]);
															 if(GrindMeaDis<MinDis){
																 MinDis = GrindMeaDis;
																 GrindMarkOutCnt = k;
															 }
														 }

														 // 최단거리OUtCount기준 InData 최단거리 Count정보 Calc 
														 if(GrindMarkOutCnt!=0){
															 GrindMeaDis =0.0f, MinDis =10000.0f; GrindMarkInCnt=0;
															 for(int k=0; k<Btm3InEdgeCount; k++){
																 if(Btm3InPoint[k].x              ==0.0f  || Btm3InPoint[k].y                ==0.0f) continue;
																 if(Btm3OutPoint[GrindMarkOutCnt].x==0.0f || Btm3OutPoint[GrindMarkOutCnt].y ==0.0f) continue;

																 GrindMeaDis = Math.GetLength(Btm3OutPoint[GrindMarkOutCnt], Btm3InPoint[k]);
																 if(GrindMeaDis<MinDis){
																	 MinDis = GrindMeaDis;
																	 GrindMarkInCnt = k;
																 }
															 }
														 }

														 // GrindMark기준 수직 포인트 주변값 Avg산출한다 ==>연마량 측정(OutData,InData기준)
														 if((GrindMarkOutCnt!=0 && GrindMarkOutCnt>5) && (GrindMarkInCnt!=0 && GrindMarkInCnt>5)){
															 CircleCount=0,TotalCirDis=0.0f,GrindWidthDis=0.0f;
															 for(int k=-5; k<5; k++){
																 if(Btm3OutPoint[GrindMarkOutCnt+k].x==0.0f && Btm3OutPoint[GrindMarkOutCnt+k].y==0.0f) continue;
																 if(Btm3InPoint [GrindMarkInCnt +k].x==0.0f && Btm3InPoint [GrindMarkInCnt +k].y==0.0f) continue;
																 if((GrindMarkOutCnt+k)>=Btm3OutEdgeCount                                             ) continue;
																 if((GrindMarkInCnt +k)>=Btm3InEdgeCount                                              ) continue;

																 GrindWidthDis = Math.GetLength(Btm3InPoint[GrindMarkInCnt+k], Btm3OutPoint[GrindMarkOutCnt+k]);
																 TotalCirDis+=   GrindWidthDis;
																 CircleCount++;
															 }
															 if(TotalCirDis!=0.0f && CircleCount!=0){
																 BtmGrindWidth6 = TotalCirDis/CircleCount;
																 BtmGrindWidth6 = BtmGrindWidth6+0.5; //SubPixel
															 }
														 }
													 }
												 }
											 }
											 else { //  Narrow Trench ENCAP 연마량 데이터만 계측함
												 if(Btm3InEdgeCount!=0 && Btm3OutEdgeCount!=0){
													 GrindMeaDis =0.0f, MinDis =10000.0f; GrindMarkOutCnt=0;
													 GrindMarkOutCnt = (int)(Btm3OutEdgeCount/2);
													 // 최단거리OUtCount기준 InData 최단거리 Count정보 Calc 
													 if(GrindMarkOutCnt!=0){
														 GrindMeaDis =0.0f, MinDis =10000.0f; GrindMarkInCnt=0;
														 for(int k=0; k<Btm3InEdgeCount; k++){
															 if(Btm3InPoint [k].x              ==0.0f || Btm3InPoint [k].y               ==0.0f) continue;
															 if(Btm3OutPoint[GrindMarkOutCnt].x==0.0f || Btm3OutPoint[GrindMarkOutCnt].y ==0.0f) continue;

															 GrindMeaDis = Math.GetLength(Btm3OutPoint[GrindMarkOutCnt], Btm3InPoint[k]);
															 if(GrindMeaDis<MinDis){
																 MinDis = GrindMeaDis;
																 GrindMarkInCnt = k;
															 }
														 }
													 }

													 // GrindMark기준 수직 포인트 주변값 Avg산출한다 ==>연마량 측정(OutData,InData기준)
													 if((GrindMarkOutCnt!=0 && GrindMarkOutCnt>5) && (GrindMarkInCnt!=0 && GrindMarkInCnt>5)){
														 CircleCount=0,TotalCirDis=0.0f,GrindWidthDis=0.0f;
														 for(int k=-5; k<5; k++){
															 if(Btm3InPoint [GrindMarkOutCnt+k].x==0.0f && Btm3InPoint [GrindMarkOutCnt+k].y==0.0f) continue;
															 if(Btm3OutPoint[GrindMarkInCnt +k].x==0.0f && Btm3OutPoint[GrindMarkInCnt +k].y==0.0f) continue;
															 if((GrindMarkOutCnt+k)>=Btm3OutEdgeCount                                             ) continue;
															 if((GrindMarkInCnt +k)>=Btm3InEdgeCount                                              ) continue;

															 GrindWidthDis = Math.GetLength(Btm3InPoint[GrindMarkInCnt+k], Btm3OutPoint[GrindMarkOutCnt+k]);
															 TotalCirDis+=   GrindWidthDis;
															 CircleCount++;
														 }
														 if(TotalCirDis!=0.0f && CircleCount!=0){
															 BtmGrindWidth5 = TotalCirDis/CircleCount;
															 BtmGrindWidth5 = BtmGrindWidth4+0.5; //SubPixel
														 }
													 }
												 }
											 }
											 ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
											 // FAVION Circle Fitting 결과물(Btm3CircleFitting)
											 SampleSize   = Btm3OutEdgeCount*0.75; //0.5~0.8이하로 입력할것
											 DistDevRatio = 0.15                 ; //0.1~0.25 이하로 입력할것
											 CircleFit->OnRansac(Btm3OutPoint,Btm3OutEdgeCount,SampleSize,DistDevRatio,&CircleFitBtm3Center,&CirFitDiameterBtm3);

											 // Polygon 박리 검사 시퀀스 
											 if(!IsMarkBtm && BrokenThresHold!=0 && IsNarrowTrench){
												 RotateBrokenImg.SetSize(RotateImg.GetWidth(), RotateImg.GetHeight());
												 EasyImage::Oper(EArithmeticLogicOperation_Copy,&RotateImg,&RotateBrokenImg);
												 EasyImage::Threshold(&RotateImg,&RotateBrokenImg, BrokenThresHold);
												 Edge->GImage = &RotateBrokenImg;
												 Edge->SetEdgeType(0);

												 int DvCnt =0, DataCount=0;
												 double deg =0.0f; 
												 TFPoint Target(0.0f, 0.0f);

												 if(GrindMarkInCnt>GrindMarkOutCnt){
													 DvCnt = GrindMarkInCnt - GrindMarkOutCnt;
													 for(int k=0; k<Btm3OutEdgeCount; k++){
														 deg =0.0f, Target.x =0.0f, Target.y =0.0f;
														 if(((k+DvCnt)<Btm3InEdgeCount) && Btm3InPoint[k+DvCnt].x>0  && Btm3InPoint[k+DvCnt].y>0){
															 deg = Math.GetDegree(Btm3OutPoint[k],Btm3InPoint[k+DvCnt]);

															 Target  = Math.OnFindPerpendicularPointXY(Btm3OutPoint[k],-dEdgeToTrapLineDis,-dEdgeToTrapLineDis,deg);
															 Edge->OnExecute(Btm3OutPoint[k],Target); // 연마외곽라인에서 Target까지 White Point Search 
															 if(Edge->GetResultEdgePointCount()>0){
																 Btm3CircleData[DataCount].Dis =0.0f;
																 Btm3CircleData[DataCount].Dv  =0.0f;
																 Btm3CircleData[DataCount].P   = Edge->GetResultEdgePoint(0);
																 Btm3CircleData[DataCount].P.y = Btm3CircleData[DataCount].P.y - ImageHeight; // Frame기준 단위좌표로 변경함  
																 DataCount++;
															 }
														 }
													 }
													 Btm3CirInCrackCount = DataCount;
												 }
												 else if(GrindMarkInCnt<GrindMarkOutCnt)   {
													 DvCnt = GrindMarkOutCnt - GrindMarkInCnt;
													 for(int k=DvCnt; k<Btm3OutEdgeCount; k++){
														 deg =0.0f, Target.x =0.0f, Target.y =0.0f;
														 if(((k-DvCnt)<Btm3InEdgeCount) && Btm3InPoint[k-DvCnt].x>0  && Btm3InPoint[k-DvCnt].y>0 && k-DvCnt>=0){
															 deg = Math.GetDegree(Btm3OutPoint[k],Btm3InPoint[k-DvCnt]);

															 Target  = Math.OnFindPerpendicularPointXY(Btm3OutPoint[k],-dEdgeToTrapLineDis,-dEdgeToTrapLineDis,deg);
															 Edge->OnExecute(Btm3OutPoint[k],Target); // 연마외곽라인에서 Target까지 White Point Search 
															 if(Edge->GetResultEdgePointCount()>0){
																 Btm3CircleData[DataCount].Dis =0.0f;
																 Btm3CircleData[DataCount].Dv  =0.0f;
																 Btm3CircleData[DataCount].P   = Edge->GetResultEdgePoint(0);
																 Btm3CircleData[DataCount].P.y = Btm3CircleData[DataCount].P.y - ImageHeight; // Frame기준 단위좌표로 변경함  
																 DataCount++;
															 }
														 }
													 }
													 Btm3CirInCrackCount = DataCount;
												 }
											 }
										 }
										 else              { // Trench 내측부 직선일 경우 
											 if(IsMarkBtm){
												 if(OrgBtm3InEdgeCount>10 && OrgBtm3OutEdgeCount>10){
													 // 가공량,연마량 측정 전 데이터 존재시 가상GrindMark 생성한다 
													 if(GrindMarkPoint[9].x!=0.0f && GrindMarkPoint[9].y!=0.0f && GrindRectSpec[8].DvX==0.0f && GrindRectSpec[8].DvY==0.0f){ //가상마크
														 // GrindMark 8
														 GrindMarkPoint[8].x     = OrgBtm3InPoint[10].x ;
														 GrindMarkPoint[8].y     = GrindMarkPoint[9 ].y                     ;
														 GrindMarkRect [8].left  = GrindMarkPoint[8 ].x    - GrindMarkRange ;  
														 GrindMarkRect [8].top   = GrindMarkPoint[8 ].y    - GrindMarkRange ;  
														 GrindMarkRect [8].right = GrindMarkRect [8 ].left + GrindMarkLength;  
														 GrindMarkRect [8].bottom= GrindMarkRect [8 ].top  + GrindMarkLength;  

														 // GrindMark 9
														 GrindMarkPoint[10].x     = OrgBtm3InPoint[OrgBtm3InEdgeCount-10].x  ;
														 GrindMarkPoint[10].y     = GrindMarkPoint[9 ].y                     ;
														 GrindMarkRect [10].left  = GrindMarkPoint[10].x    - GrindMarkRange ;  
														 GrindMarkRect [10].top   = GrindMarkPoint[10].y    - GrindMarkRange ;  
														 GrindMarkRect [10].right = GrindMarkRect [10].left + GrindMarkLength;  
														 GrindMarkRect [10].bottom= GrindMarkRect [10].top  + GrindMarkLength;  
													 }

													 // GrindMark[8] 가공량,연마량 측정 
													 ////////////////////////////////////////////////////////////////////////////////////////////////////
													 if(GrindMarkPoint[8].x!=0.0f && GrindMarkPoint[8].y!=0.0f) { 
														 // GrindMark기준 OutData 최단거리 Count정보 Calc 
														 GrindMeaDis =0.0f, MinDis =10000.0f;  GrindMarkOutCnt=0;
														 for(int k=0; k<OrgBtm3OutEdgeCount; k++){
															 if(OrgBtm3OutPoint[k].x==0.0f || OrgBtm3OutPoint[k].y==0.0f) continue;
															 if(GrindMarkPoint[8].x ==0.0f || GrindMarkPoint[8].y ==0.0f) continue;

															 GrindMeaDis = Math.GetLength(GrindMarkPoint[8], OrgBtm3OutPoint[k]);
															 if(GrindMeaDis<MinDis){
																 MinDis = GrindMeaDis;
																 GrindMarkOutCnt = k;
															 }
														 }

														 // GrindMark기준 InData 최단거리 Count정보 Calc 
														 if(GrindMarkOutCnt!=0){
															 GrindMeaDis =0.0f, MinDis =10000.0f; GrindMarkInCnt=0;
															 for(int k=0; k<OrgBtm3InEdgeCount; k++){
																 if(OrgBtm3InPoint[k].x   ==0.0f             || OrgBtm3InPoint[k].y                ==0.0f) continue;
																 if(OrgBtm3OutPoint[GrindMarkOutCnt].x==0.0f || OrgBtm3OutPoint[GrindMarkOutCnt].y ==0.0f) continue;

																 GrindMeaDis = Math.GetLength(OrgBtm3OutPoint[GrindMarkOutCnt], OrgBtm3InPoint[k]);
																 if(GrindMeaDis<MinDis){
																	 MinDis = GrindMeaDis;
																	 GrindMarkInCnt = k;
																 }
															 }
														 }

														 // GrindMark기준 수직 포인트 주변값 Avg산출한다 ==>가공량 측정(OutData기준)
														 if(GrindMarkOutCnt!=0 && GrindMarkOutCnt>5){
															 CircleCount=0,TotalCirDis=0.0f,GrindMeaDis=0.0f;
															 for(int k=GrindMarkOutCnt-5; k<GrindMarkOutCnt+5; k++){
																 if(OrgBtm3OutPoint[k].x==0.0f || OrgBtm3OutPoint[k].y==0.0f) continue;
																 if(k>=OrgBtm3OutEdgeCount                                  ) continue;

																 GrindMeaDis = Math.GetLength(GrindMarkPoint[8], OrgBtm3OutPoint[k]);
																 TotalCirDis+= GrindMeaDis;
																 CircleCount++;
															 }
															 if(TotalCirDis!=0.0f && CircleCount!=0){
																 BtmGrindMeasure4 = TotalCirDis/CircleCount;
																 BtmGrindMeasure4 = BtmGrindMeasure4+0.5; //SubPixel 
															 }
														 }

														 // GrindMark기준 수직 포인트 주변값 Avg산출한다 ==>연마량 측정(OutData,InData기준)
														 if((GrindMarkOutCnt!=0 && GrindMarkOutCnt>5) && (GrindMarkInCnt!=0 && GrindMarkInCnt>5)){
															 CircleCount=0,TotalCirDis=0.0f,GrindWidthDis=0.0f;
															 for(int k=-5; k<5; k++){
																 if(OrgBtm3OutPoint[GrindMarkOutCnt+k].x==0.0f && OrgBtm3OutPoint[GrindMarkOutCnt+k].y==0.0f) continue;
																 if(OrgBtm3InPoint [GrindMarkInCnt +k].x==0.0f && OrgBtm3InPoint [GrindMarkInCnt +k].y==0.0f) continue;
																 if((GrindMarkOutCnt+k)>=OrgBtm3OutEdgeCount                                                ) continue;
																 if((GrindMarkInCnt +k)>=OrgBtm3InEdgeCount                                                 ) continue;

																 GrindWidthDis = Math.GetLength(OrgBtm3InPoint[GrindMarkInCnt+k], OrgBtm3OutPoint[GrindMarkOutCnt+k]);
																 TotalCirDis+=   GrindWidthDis;
																 CircleCount++;
															 }
															 if(TotalCirDis!=0.0f && CircleCount!=0){
																 BtmGrindWidth4 = TotalCirDis/CircleCount;
																 BtmGrindWidth4 = BtmGrindWidth4+0.5; //SubPixel
															 }
														 }
													 }
													 else if(GrindMarkRect[8].left!=0 && GrindMarkRect[8].top!=0 && GrindMarkRect[8].right!=0 && GrindMarkRect[8].bottom!=0) {  //GrindMark 못 찾았을경우
														 // OutData기준 최소값 데이터 Count산출 
														 GrindMeaDis =0.0f, MinDis =10000.0f; GrindMarkOutCnt=0;
														 for(int k=0; k<OrgBtm3OutEdgeCount; k++){
															 if(OrgBtm3OutPoint[k].x==0.0f || OrgBtm3OutPoint[k].y==0.0f) continue;

															 if(k==0 && GrindRectSpec[8].DvX==0.0f && GrindRectSpec[8].DvY==0.0f){ // 가상마크  
																 GrindMarkRectCenter[9].x = GrindMarkRect[9].left + (GrindMarkRect[9].right  - GrindMarkRect[9].left)/2; 
																 GrindMarkRectCenter[9].y = GrindMarkRect[9].top  + (GrindMarkRect[9].bottom - GrindMarkRect[9].top )/2; 

																 GrindMarkRectCenter[8].x = OrgBtm3InPoint[10].x     ;
																 GrindMarkRectCenter[8].y = GrindMarkRectCenter[9].y; 

																 GrindMarkRect [8].left  = GrindMarkRectCenter[8].x    - GrindMarkRange ;  
																 GrindMarkRect [8].top   = GrindMarkRectCenter[8].y    - GrindMarkRange ;  
																 GrindMarkRect [8].right = GrindMarkRect [8].left      + GrindMarkLength;  
																 GrindMarkRect [8].bottom= GrindMarkRect [8].top       + GrindMarkLength;  
															 }
															 else if(k==0 && GrindRectSpec[8].DvX!=0.0f && GrindRectSpec[8].DvY!=0.0f){ //진성마크 
																 GrindMarkRectCenter[8].x = GrindMarkRect[8].left + (GrindMarkRect[8].right  - GrindMarkRect[8].left)/2; 
																 GrindMarkRectCenter[8].y = GrindMarkRect[8].top  + (GrindMarkRect[8].bottom - GrindMarkRect[8].top )/2; 
															 }

															 GrindMeaDis = Math.GetLength(GrindMarkRectCenter[8], OrgBtm3OutPoint[k]);
															 if(GrindMeaDis<MinDis){
																 MinDis = GrindMeaDis;
																 GrindMarkOutCnt = k;
															 }
														 }

														 // 최단거리OUtCount기준 InData 최단거리 Count정보 Calc 
														 if(GrindMarkOutCnt!=0){
															 GrindMeaDis =0.0f, MinDis =10000.0f; GrindMarkInCnt=0;
															 for(int k=0; k<OrgBtm3InEdgeCount; k++){
																 if(OrgBtm3InPoint[k].x              ==0.0f  || OrgBtm3InPoint[k].y                ==0.0f) continue;
																 if(OrgBtm3OutPoint[GrindMarkOutCnt].x==0.0f || OrgBtm3OutPoint[GrindMarkOutCnt].y ==0.0f) continue;

																 GrindMeaDis = Math.GetLength(OrgBtm3OutPoint[GrindMarkOutCnt], OrgBtm3InPoint[k]);
																 if(GrindMeaDis<MinDis){
																	 MinDis = GrindMeaDis;
																	 GrindMarkInCnt = k;
																 }
															 }
														 }

														 // GrindMark기준 수직 포인트 주변값 Avg산출한다 ==>연마량 측정(OutData,InData기준)
														 if((GrindMarkOutCnt!=0 && GrindMarkOutCnt>5) && (GrindMarkInCnt!=0 && GrindMarkInCnt>5)){
															 CircleCount=0,TotalCirDis=0.0f,GrindWidthDis=0.0f;
															 for(int k=-5; k<5; k++){
																 if(OrgBtm3OutPoint[GrindMarkOutCnt+k].x==0.0f && OrgBtm3OutPoint[GrindMarkOutCnt+k].y==0.0f) continue;
																 if(OrgBtm3InPoint [GrindMarkInCnt +k].x==0.0f && OrgBtm3InPoint [GrindMarkInCnt +k].y==0.0f) continue;
																 if((GrindMarkOutCnt+k)>=OrgBtm3OutEdgeCount                                                ) continue;
																 if((GrindMarkInCnt +k)>=OrgBtm3InEdgeCount                                                 ) continue;

																 GrindWidthDis = Math.GetLength(OrgBtm3InPoint[GrindMarkInCnt+k], OrgBtm3OutPoint[GrindMarkOutCnt+k]);
																 TotalCirDis+=   GrindWidthDis;
																 CircleCount++;
															 }
															 if(TotalCirDis!=0.0f && CircleCount!=0){
																 BtmGrindWidth4 = TotalCirDis/CircleCount;
																 BtmGrindWidth4 = BtmGrindWidth4+0.5; //SubPixel
															 }
														 }
													 }

													 // GrindMark[9] 가공량,연마량 측정 
													 ////////////////////////////////////////////////////////////////////////////////////////////////////
													 if(GrindMarkPoint[9].x!=0.0f && GrindMarkPoint[9].y!=0.0f) { 
														 // GrindMark기준 OutData 최단거리 Count정보 Calc 
														 GrindMeaDis =0.0f, MinDis =10000.0f;  GrindMarkOutCnt=0;
														 for(int k=0; k<OrgBtm3OutEdgeCount; k++){
															 if(OrgBtm3OutPoint[k].x==0.0f || OrgBtm3OutPoint[k].y==0.0f) continue;
															 if(GrindMarkPoint[9].x ==0.0f || GrindMarkPoint[9].y ==0.0f) continue;

															 GrindMeaDis = Math.GetLength(GrindMarkPoint[9], OrgBtm3OutPoint[k]);
															 if(GrindMeaDis<MinDis){
																 MinDis = GrindMeaDis;
																 GrindMarkOutCnt = k;
															 }
														 }

														 // GrindMark기준 InData 최단거리 Count정보 Calc 
														 if(GrindMarkOutCnt!=0){
															 GrindMeaDis =0.0f, MinDis =10000.0f; GrindMarkInCnt=0;
															 for(int k=0; k<OrgBtm3InEdgeCount; k++){
																 if(OrgBtm3InPoint[k].x   ==0.0f             || OrgBtm3InPoint[k].y                ==0.0f) continue;
																 if(OrgBtm3OutPoint[GrindMarkOutCnt].x==0.0f || OrgBtm3OutPoint[GrindMarkOutCnt].y ==0.0f) continue;

																 GrindMeaDis = Math.GetLength(OrgBtm3OutPoint[GrindMarkOutCnt], OrgBtm3InPoint[k]);
																 if(GrindMeaDis<MinDis){
																	 MinDis = GrindMeaDis;
																	 GrindMarkInCnt = k;
																 }
															 }
														 }

														 // GrindMark기준 수직 포인트 주변값 Avg산출한다 ==>가공량 측정(OutData기준)
														 if(GrindMarkOutCnt!=0 && GrindMarkOutCnt>5){
															 CircleCount=0,TotalCirDis=0.0f,GrindMeaDis=0.0f;
															 for(int k=GrindMarkOutCnt-5; k<GrindMarkOutCnt+5; k++){
																 if(OrgBtm3OutPoint[k].x==0.0f || OrgBtm3OutPoint[k].y==0.0f) continue;
																 if(k>=OrgBtm3OutEdgeCount                                  ) continue;

																 GrindMeaDis = Math.GetLength(GrindMarkPoint[9], OrgBtm3OutPoint[k]);
																 TotalCirDis+= GrindMeaDis;
																 CircleCount++;
															 }
															 if(TotalCirDis!=0.0f && CircleCount!=0){
																 BtmGrindMeasure5 = TotalCirDis/CircleCount;
																 BtmGrindMeasure5 = BtmGrindMeasure5+0.5; //SubPixel 
															 }
														 }

														 // GrindMark기준 수직 포인트 주변값 Avg산출한다 ==>연마량 측정(OutData,InData기준)
														 if((GrindMarkOutCnt!=0 && GrindMarkOutCnt>5) && (GrindMarkInCnt!=0 && GrindMarkInCnt>5)){
															 CircleCount=0,TotalCirDis=0.0f,GrindWidthDis=0.0f;
															 for(int k=-5; k<5; k++){
																 if(OrgBtm3OutPoint[GrindMarkOutCnt+k].x==0.0f && OrgBtm3OutPoint[GrindMarkOutCnt+k].y==0.0f) continue;
																 if(OrgBtm3InPoint [GrindMarkInCnt +k].x==0.0f && OrgBtm3InPoint [GrindMarkInCnt +k].y==0.0f) continue;
																 if((GrindMarkOutCnt+k)>=OrgBtm3OutEdgeCount                                                ) continue;
																 if((GrindMarkInCnt +k)>=OrgBtm3InEdgeCount                                                 ) continue;

																 GrindWidthDis = Math.GetLength(OrgBtm3InPoint[GrindMarkInCnt+k], OrgBtm3OutPoint[GrindMarkOutCnt+k]);
																 TotalCirDis+=   GrindWidthDis;
																 CircleCount++;
															 }
															 if(TotalCirDis!=0.0f && CircleCount!=0){
																 BtmGrindWidth5 = TotalCirDis/CircleCount;
																 BtmGrindWidth5 = BtmGrindWidth5+0.5; //SubPixel
															 }
														 }
													 }
													 else if(GrindMarkRect[9].left!=0 && GrindMarkRect[9].top!=0 && GrindMarkRect[9].right!=0 && GrindMarkRect[9].bottom!=0) {  //GrindMark 못 찾았을경우
														 // OutData기준 최소값 데이터 Count산출 
														 GrindMeaDis =0.0f, MinDis =10000.0f; GrindMarkOutCnt=0;
														 for(int k=0; k<OrgBtm3OutEdgeCount; k++){
															 if(OrgBtm3OutPoint[k].x==0.0f || OrgBtm3OutPoint[k].y==0.0f) continue;

															 if(k==0){ // 순서상 9번이 없는경우 
																 GrindMarkRectCenter[9].x = GrindMarkRect[9].left + (GrindMarkRect[9].right  - GrindMarkRect[9].left)/2; 
																 GrindMarkRectCenter[9].y = GrindMarkRect[9].top  + (GrindMarkRect[9].bottom - GrindMarkRect[9].top )/2; 
															 }

															 GrindMeaDis = Math.GetLength(GrindMarkRectCenter[9], OrgBtm3OutPoint[k]);
															 if(GrindMeaDis<MinDis){
																 MinDis = GrindMeaDis;
																 GrindMarkOutCnt = k;
															 }
														 }

														 // 최단거리OUtCount기준 InData 최단거리 Count정보 Calc 
														 if(GrindMarkOutCnt!=0){
															 GrindMeaDis =0.0f, MinDis =10000.0f; GrindMarkInCnt=0;
															 for(int k=0; k<OrgBtm3InEdgeCount; k++){
																 if(OrgBtm3InPoint[k].x              ==0.0f  || OrgBtm3InPoint[k].y                ==0.0f) continue;
																 if(OrgBtm3OutPoint[GrindMarkOutCnt].x==0.0f || OrgBtm3OutPoint[GrindMarkOutCnt].y ==0.0f) continue;

																 GrindMeaDis = Math.GetLength(OrgBtm3OutPoint[GrindMarkOutCnt], OrgBtm3InPoint[k]);
																 if(GrindMeaDis<MinDis){
																	 MinDis = GrindMeaDis;
																	 GrindMarkInCnt = k;
																 }
															 }
														 }

														 // GrindMark기준 수직 포인트 주변값 Avg산출한다 ==>연마량 측정(OutData,InData기준)
														 if((GrindMarkOutCnt!=0 && GrindMarkOutCnt>5) && (GrindMarkInCnt!=0 && GrindMarkInCnt>5)){
															 CircleCount=0,TotalCirDis=0.0f,GrindWidthDis=0.0f;
															 for(int k=-5; k<5; k++){
																 if(OrgBtm3OutPoint[GrindMarkOutCnt+k].x==0.0f && OrgBtm3OutPoint[GrindMarkOutCnt+k].y==0.0f) continue;
																 if(OrgBtm3InPoint [GrindMarkInCnt +k].x==0.0f && OrgBtm3InPoint [GrindMarkInCnt +k].y==0.0f) continue;
																 if((GrindMarkOutCnt+k)>=OrgBtm3OutEdgeCount                                                ) continue;
																 if((GrindMarkInCnt +k)>=OrgBtm3InEdgeCount                                                 ) continue;

																 GrindWidthDis = Math.GetLength(OrgBtm3InPoint[GrindMarkInCnt+k], OrgBtm3OutPoint[GrindMarkOutCnt+k]);
																 TotalCirDis+=   GrindWidthDis;
																 CircleCount++;
															 }
															 if(TotalCirDis!=0.0f && CircleCount!=0){
																 BtmGrindWidth5 = TotalCirDis/CircleCount;
																 BtmGrindWidth5 = BtmGrindWidth5+0.5; //SubPixel
															 }
														 }
													 }

													 // GrindMark[10] 가공량,연마량 측정 
													 ////////////////////////////////////////////////////////////////////////////////////////////////////
													 if(GrindMarkPoint[10].x!=0.0f && GrindMarkPoint[10].y!=0.0f) { 
														 // GrindMark기준 OutData 최단거리 Count정보 Calc 
														 GrindMeaDis =0.0f, MinDis =10000.0f;  GrindMarkOutCnt=0;
														 for(int k=0; k<OrgBtm3OutEdgeCount; k++){
															 if(OrgBtm3OutPoint[k].x==0.0f || OrgBtm3OutPoint[k].y==0.0f) continue;
															 if(GrindMarkPoint[10].x ==0.0f || GrindMarkPoint[10].y ==0.0f) continue;

															 GrindMeaDis = Math.GetLength(GrindMarkPoint[10], OrgBtm3OutPoint[k]);
															 if(GrindMeaDis<MinDis){
																 MinDis = GrindMeaDis;
																 GrindMarkOutCnt = k;
															 }
														 }

														 // GrindMark기준 InData 최단거리 Count정보 Calc 
														 if(GrindMarkOutCnt!=0){
															 GrindMeaDis =0.0f, MinDis =10000.0f; GrindMarkInCnt=0;
															 for(int k=0; k<OrgBtm3InEdgeCount; k++){
																 if(OrgBtm3InPoint[k].x   ==0.0f             || OrgBtm3InPoint[k].y                ==0.0f) continue;
																 if(OrgBtm3OutPoint[GrindMarkOutCnt].x==0.0f || OrgBtm3OutPoint[GrindMarkOutCnt].y ==0.0f) continue;

																 GrindMeaDis = Math.GetLength(OrgBtm3OutPoint[GrindMarkOutCnt], OrgBtm3InPoint[k]);
																 if(GrindMeaDis<MinDis){
																	 MinDis = GrindMeaDis;
																	 GrindMarkInCnt = k;
																 }
															 }
														 }

														 // GrindMark기준 수직 포인트 주변값 Avg산출한다 ==>가공량 측정(OutData기준)
														 if(GrindMarkOutCnt!=0 && GrindMarkOutCnt>5){
															 CircleCount=0,TotalCirDis=0.0f,GrindMeaDis=0.0f;
															 for(int k=GrindMarkOutCnt-5; k<GrindMarkOutCnt+5; k++){
																 if(OrgBtm3OutPoint[k].x==0.0f || OrgBtm3OutPoint[k].y==0.0f) continue;
																 if(k>=OrgBtm3OutEdgeCount                                  ) continue;

																 GrindMeaDis = Math.GetLength(GrindMarkPoint[10], OrgBtm3OutPoint[k]);
																 TotalCirDis+= GrindMeaDis;
																 CircleCount++;
															 }
															 if(TotalCirDis!=0.0f && CircleCount!=0){
																 BtmGrindMeasure6 = TotalCirDis/CircleCount;
																 BtmGrindMeasure6 = BtmGrindMeasure6+0.5; //SubPixel 
															 }
														 }

														 // GrindMark기준 수직 포인트 주변값 Avg산출한다 ==>연마량 측정(OutData,InData기준)
														 if((GrindMarkOutCnt!=0 && GrindMarkOutCnt>5) && (GrindMarkInCnt!=0 && GrindMarkInCnt>5)){
															 CircleCount=0,TotalCirDis=0.0f,GrindWidthDis=0.0f;
															 for(int k=-5; k<5; k++){
																 if(OrgBtm3OutPoint[GrindMarkOutCnt+k].x==0.0f && OrgBtm3OutPoint[GrindMarkOutCnt+k].y==0.0f) continue;
																 if(OrgBtm3InPoint [GrindMarkInCnt +k].x==0.0f && OrgBtm3InPoint [GrindMarkInCnt +k].y==0.0f) continue;
																 if((GrindMarkOutCnt+k)>=OrgBtm3OutEdgeCount                                                ) continue;
																 if((GrindMarkInCnt +k)>=OrgBtm3InEdgeCount                                                 ) continue;

																 GrindWidthDis = Math.GetLength(OrgBtm3InPoint[GrindMarkInCnt+k], OrgBtm3OutPoint[GrindMarkOutCnt+k]);
																 TotalCirDis+=   GrindWidthDis;
																 CircleCount++;
															 }
															 if(TotalCirDis!=0.0f && CircleCount!=0){
																 BtmGrindWidth6 = TotalCirDis/CircleCount;
																 BtmGrindWidth6 = BtmGrindWidth6+0.5; //SubPixel
															 }
														 }
													 }
													 else if(GrindMarkRect[10].left!=0 && GrindMarkRect[10].top!=0 && GrindMarkRect[10].right!=0 && GrindMarkRect[10].bottom!=0) {  //GrindMark 못 찾았을경우
														 // OutData기준 최소값 데이터 Count산출 
														 GrindMeaDis =0.0f, MinDis =10000.0f; GrindMarkOutCnt=0;
														 for(int k=0; k<OrgBtm3OutEdgeCount; k++){
															 if(OrgBtm3OutPoint[k].x==0.0f || OrgBtm3OutPoint[k].y==0.0f) continue;

															 if(k==0 && GrindRectSpec[8].DvX==0.0f && GrindRectSpec[8].DvY==0.0f){ //가상마크 
																 GrindMarkRectCenter[10].x = OrgBtm3InPoint[OrgBtm3InEdgeCount-10].x ;
																 GrindMarkRectCenter[10].y = GrindMarkRectCenter[9].y               ; 

																 GrindMarkRect [10].left  = GrindMarkRectCenter[10].x - GrindMarkRange ;  
																 GrindMarkRect [10].top   = GrindMarkRectCenter[10].y - GrindMarkRange ;  
																 GrindMarkRect [10].right = GrindMarkRect [10].left   + GrindMarkLength;  
																 GrindMarkRect [10].bottom= GrindMarkRect [10].top    + GrindMarkLength;  
															 }
															 else if(k==0 && GrindRectSpec[8].DvX!=0.0f && GrindRectSpec[8].DvY!=0.0f){ //진성마크 
																 GrindMarkRectCenter[10].x = GrindMarkRect[10].left + (GrindMarkRect[10].right  - GrindMarkRect[10].left)/2; 
																 GrindMarkRectCenter[10].y = GrindMarkRect[10].top  + (GrindMarkRect[10].bottom - GrindMarkRect[10].top )/2; 
															 }

															 GrindMeaDis = Math.GetLength(GrindMarkRectCenter[10], OrgBtm3OutPoint[k]);
															 if(GrindMeaDis<MinDis){
																 MinDis = GrindMeaDis;
																 GrindMarkOutCnt = k;
															 }
														 }

														 // 최단거리OUtCount기준 InData 최단거리 Count정보 Calc 
														 if(GrindMarkOutCnt!=0){
															 GrindMeaDis =0.0f, MinDis =10000.0f; GrindMarkInCnt=0;
															 for(int k=0; k<OrgBtm3InEdgeCount; k++){
																 if(OrgBtm3InPoint[k].x              ==0.0f  || OrgBtm3InPoint[k].y                ==0.0f) continue;
																 if(OrgBtm3OutPoint[GrindMarkOutCnt].x==0.0f || OrgBtm3OutPoint[GrindMarkOutCnt].y ==0.0f) continue;

																 GrindMeaDis = Math.GetLength(OrgBtm3OutPoint[GrindMarkOutCnt], OrgBtm3InPoint[k]);
																 if(GrindMeaDis<MinDis){
																	 MinDis = GrindMeaDis;
																	 GrindMarkInCnt = k;
																 }
															 }
														 }

														 // GrindMark기준 수직 포인트 주변값 Avg산출한다 ==>연마량 측정(OutData,InData기준)
														 if((GrindMarkOutCnt!=0 && GrindMarkOutCnt>5) && (GrindMarkInCnt!=0 && GrindMarkInCnt>5)){
															 CircleCount=0,TotalCirDis=0.0f,GrindWidthDis=0.0f;
															 for(int k=-5; k<5; k++){
																 if(OrgBtm3OutPoint[GrindMarkOutCnt+k].x==0.0f && OrgBtm3OutPoint[GrindMarkOutCnt+k].y==0.0f) continue;
																 if(OrgBtm3InPoint [GrindMarkInCnt +k].x==0.0f && OrgBtm3InPoint [GrindMarkInCnt +k].y==0.0f) continue;
																 if((GrindMarkOutCnt+k)>=OrgBtm3OutEdgeCount                                                ) continue;
																 if((GrindMarkInCnt +k)>=OrgBtm3InEdgeCount                                                 ) continue;

																 GrindWidthDis = Math.GetLength(OrgBtm3InPoint[GrindMarkInCnt+k], OrgBtm3OutPoint[GrindMarkOutCnt+k]);
																 TotalCirDis+=   GrindWidthDis;
																 CircleCount++;
															 }
															 if(TotalCirDis!=0.0f && CircleCount!=0){
																 BtmGrindWidth6 = TotalCirDis/CircleCount;
																 BtmGrindWidth6 = BtmGrindWidth6+0.5; //SubPixel
															 }
														 }
													 }
												 }
											 }
											 else { // ENCAP 연마량 데이터만 계측함
												 if(BtmOutLine[2].FP0.x!=0.0f && BtmOutLine[2].FP0.y!=0.0f && BtmOutLine[2].FP1.x!=0.0f && BtmOutLine[2].FP1.y!=0.0f &&
													 BtmInLine [2].FP0.x!=0.0f && BtmInLine [2].FP0.y!=0.0f && BtmInLine [2].FP1.x!=0.0f && BtmInLine [2].FP1.y!=0.0f ){
												     // 연마량 계산  
												     if((fabs(BtmOutLine[2].FP0.y - BtmOutLine[2].FP1.y))>1
												     	||(fabs(BtmInLine[2].FP0.y - BtmInLine[2].FP1.y))>1){
												         BtmGrindWidth4 = BtmOutLine[2].FP0.y - BtmInLine[2].FP0.y; 
												     }
												     else{
												         BtmGrindWidth4 = Math.GetLengthFrLineToPoint(BtmOutLine[2].FP0, BtmOutLine[2].FP1, BtmInLine[2].FP0);
												     }
												 }
											 }
										 }
										 // 동적 생성한 데이터를 지운다 
										 if(OrgBtm3InPoint !=NULL) delete[] OrgBtm3InPoint;
										 if(OrgBtm3OutPoint!=NULL) delete[] OrgBtm3OutPoint;
										 LogUnit.SetLog(L"CellID:%d, CamID:%d ==>Straight1_Insp_End",CellId,CamId);
									 }


									 // 비선형 곡선 영역을 제외한 직선 영역 검사 시퀀스 
									 // 다섯번째 직선 영역 
									 if(BtmEdgePoint[8].x!=0 && BtmEdgePoint[8].y!=0 && BtmEdgePoint[9].x!=0 && BtmEdgePoint[9].y!=0 ){
										 P1.x=0, P1.y=0, P2.x=0, P2.y=0, P3.x=0, P3.y=0, P4.x=0, P4.y=0;
										 LogUnit.SetLog(L"CellID:%d, CamID:%d ==>Straight5_Insp_Start",CellId,CamId);

										 P1.x = (BtmEdgePoint[8].x); P1.y =(BtmEdgePoint[8].y-30); P2.x = (P1.x+(BtmEdgePoint[9].x - BtmEdgePoint[8].x )); P2.y = (P1.y);
										 P3.x = (BtmEdgePoint[8].x); P3.y =(BtmEdgePoint[8].y+30); P4.x = (P2.x                                         ); P4.y = (P3.y);

										 // Median Filter 적용 
										 if(P1.x<=0    || P1.y<=0    || (P2.x - P1.x)<=0    || (P3.y - P1.y)<=0   ) return false;
										 if(P1.x>=ImgW || P1.y>=ImgH || (P2.x - P1.x)>=ImgW || (P3.y - P1.y)>=ImgH) return false;
										 FilterROI.SetSize(int(P2.x - P1.x),int(P3.y - P1.y) )                      ;
										 FilterROI.Attach(&RotateBinaryImg)                                    ;
										 FilterROI.SetPlacement(P1.x, P1.y, int(P2.x - P1.x), int(P3.y - P1.y));
										 EasyImage::Median(&FilterROI, &FilterROI)                             ;

										 Polygon->GImage          = &RotateBinaryImg           ;
										 Polygon->PoPa.FMaxWidth  =(int)(P2.x - P1.x)+100      ;
										 Polygon->PoPa.FMaxHeight =(int)(P3.y - P1.y)          ;
										 Polygon->PoPa.FMinWidth  =(int)(P2.x - P1.x)-100      ; 
										 Polygon->PoPa.IsSeparate =true                        ;
										 Polygon->PoPa.IsInToOut  =true                        ;
										 Polygon->PoPa.HiThHold   = BtmEdgeThresHold           ;
										 Polygon->PoPa.LoThHold   = 0                          ;

										 if(P1.x!=0 && P1.y!=0 && P2.x!=0 && P2.y!=0 && P3.x!=0 && P3.y!=0 && P4.x!=0 && P4.y!=0){
											 Polygon->OnExecute(P1,P2,P3,P4);
										 }

										 // Polygon Algorithm InEdgeData/OutEdgeData Separate 및 데이터 추출 
										 if(Polygon->BlobCount==1){
											 PolygonMarginCnt =10;
											 if(Polygon->Blob[0].InCnt>(PolygonMarginCnt*2)){
												 OrgBtm5InEdgeCount=0;
												 OrgBtm5InEdgeCount = (Polygon->Blob[0].InCnt - (PolygonMarginCnt*2));
												 if(OrgBtm5InEdgeCount>0){
													 if(OrgBtm5InPoint!=NULL) delete[] OrgBtm5InPoint;
													 OrgBtm5InPoint = new TFPoint[OrgBtm5InEdgeCount];

													 PixelCnt=0;
													 for(int k=0; k<Polygon->Blob[0].InCnt; k++){
														 if(k<PolygonMarginCnt || k>=(Polygon->Blob[0].InCnt-PolygonMarginCnt)) continue;
														 OrgBtm5InPoint[PixelCnt].x   = Polygon->Blob[0].InPoint[k].x ;
														 OrgBtm5InPoint[PixelCnt].y   = Polygon->Blob[0].InPoint[k].y ;
														 PixelCnt++;
													 }
												 }
												 // Org Data 
												 BtmInLine[4].FP0 = OrgBtm5InPoint[0];
												 BtmInLine[4].FP1 = OrgBtm5InPoint[PixelCnt-1];
											 }

											 if(Polygon->Blob[0].OutCnt>(PolygonMarginCnt*2)){
												 OrgBtm5OutEdgeCount=0;
												 OrgBtm5OutEdgeCount = (Polygon->Blob[0].OutCnt - (PolygonMarginCnt*2));
												 if(OrgBtm5OutEdgeCount>0){
													 if(OrgBtm5OutPoint!=NULL) delete[] OrgBtm5OutPoint;
													 OrgBtm5OutPoint = new TFPoint[OrgBtm5OutEdgeCount];

													 PixelCnt=0;
													 for(int k=0; k<Polygon->Blob[0].OutCnt; k++){
														 if(k<PolygonMarginCnt || k>=(Polygon->Blob[0].OutCnt-PolygonMarginCnt)) continue;
														 OrgBtm5OutPoint[PixelCnt].x  = Polygon->Blob[0].OutPoint[k].x ;
														 OrgBtm5OutPoint[PixelCnt].y  = Polygon->Blob[0].OutPoint[k].y ;
														 PixelCnt++;
													 }
												 }
												 // Org Data 
												 BtmOutLine[4].FP0 = OrgBtm5OutPoint[0];
												 BtmOutLine[4].FP1 = OrgBtm5OutPoint[PixelCnt-1];
											 }


										 }

										 // 연마량 측정 및 가공량 측정 (비선형)
										 if(IsMarkBtm){
											 if(OrgBtm5InEdgeCount>10 && OrgBtm5OutEdgeCount>10){
												 // 가공량,연마량 측정 전 데이터 존재시 가상GrindMark 생성한다 
												 if(GrindMarkPoint[16].x!=0.0f && GrindMarkPoint[16].y!=0.0f && GrindRectSpec[4].DvX==0.0f && GrindRectSpec[4].DvY==0.0f &&!IsNarrowTrench){
													 GrindMarkPoint[14].x     = OrgBtm5InPoint[10].x                     ;
													 GrindMarkPoint[14].y     = GrindMarkPoint[16].y                     ;
													 GrindMarkRect [14].left  = GrindMarkPoint[14].x    - GrindMarkRange ;  
													 GrindMarkRect [14].top   = GrindMarkPoint[14].y    - GrindMarkRange ;  
													 GrindMarkRect [14].right = GrindMarkRect [14].left + GrindMarkLength;  
													 GrindMarkRect [14].bottom= GrindMarkRect [14].top  + GrindMarkLength;  
												 }
												 // GrindMark[14] 가공량,연마량 측정 
												 ////////////////////////////////////////////////////////////////////////////////////////////////////
												 if(GrindMarkPoint[14].x!=0.0f && GrindMarkPoint[14].y!=0.0f) { 
													 // GrindMark기준 OutData 최단거리 Count정보 Calc 
													 GrindMeaDis =0.0f, MinDis =10000.0f;  GrindMarkOutCnt=0;
													 for(int k=0; k<OrgBtm5OutEdgeCount; k++){
														 if(OrgBtm5OutPoint[k].x==0.0f || OrgBtm5OutPoint[k].y==0.0f) continue;
														 if(GrindMarkPoint[14].x ==0.0f || GrindMarkPoint[14].y ==0.0f) continue;

														 GrindMeaDis = Math.GetLength(GrindMarkPoint[14], OrgBtm5OutPoint[k]);
														 if(GrindMeaDis<MinDis){
															 MinDis = GrindMeaDis;
															 GrindMarkOutCnt = k;
														 }
													 }

													 // GrindMark기준 InData 최단거리 Count정보 Calc 
													 if(GrindMarkOutCnt!=0){
														 GrindMeaDis =0.0f, MinDis =10000.0f; GrindMarkInCnt=0;
														 for(int k=0; k<OrgBtm5InEdgeCount; k++){
															 if(OrgBtm5InPoint[k].x   ==0.0f             || OrgBtm5InPoint[k].y                ==0.0f) continue;
															 if(OrgBtm5OutPoint[GrindMarkOutCnt].x==0.0f || OrgBtm5OutPoint[GrindMarkOutCnt].y ==0.0f) continue;

															 GrindMeaDis = Math.GetLength(OrgBtm5OutPoint[GrindMarkOutCnt], OrgBtm5InPoint[k]);
															 if(GrindMeaDis<MinDis){
																 MinDis = GrindMeaDis;
																 GrindMarkInCnt = k;
															 }
														 }
													 }

													 // GrindMark기준 수직 포인트 주변값 Avg산출한다 ==>가공량 측정(OutData기준)
													 if(GrindMarkOutCnt!=0 && GrindMarkOutCnt>5){
														 CircleCount=0,TotalCirDis=0.0f,GrindMeaDis=0.0f;
														 for(int k=GrindMarkOutCnt-5; k<GrindMarkOutCnt+5; k++){
															 if(OrgBtm5OutPoint[k].x==0.0f || OrgBtm5OutPoint[k].y==0.0f) continue;
															 if(k>=OrgBtm5OutEdgeCount                                  ) continue;

															 GrindMeaDis = Math.GetLength(GrindMarkPoint[14], OrgBtm5OutPoint[k]);
															 TotalCirDis+= GrindMeaDis;
															 CircleCount++;
														 }
														 if(TotalCirDis!=0.0f && CircleCount!=0){
															 BtmGrindMeasure7 = TotalCirDis/CircleCount;
															 BtmGrindMeasure7 = BtmGrindMeasure7+0.5; //SubPixel 
														 }
													 }

													 // GrindMark기준 수직 포인트 주변값 Avg산출한다 ==>연마량 측정(OutData,InData기준)
													 if((GrindMarkOutCnt!=0 && GrindMarkOutCnt>5) && (GrindMarkInCnt!=0 && GrindMarkInCnt>5)){
														 CircleCount=0,TotalCirDis=0.0f,GrindWidthDis=0.0f;
														 for(int k=-5; k<5; k++){
															 if(OrgBtm5OutPoint[GrindMarkOutCnt+k].x==0.0f && OrgBtm5OutPoint[GrindMarkOutCnt+k].y==0.0f) continue;
															 if(OrgBtm5InPoint [GrindMarkInCnt +k].x==0.0f && OrgBtm5InPoint [GrindMarkInCnt +k].y==0.0f) continue;
															 if((GrindMarkOutCnt+k)>=OrgBtm5OutEdgeCount                                                ) continue;
															 if((GrindMarkInCnt +k)>=OrgBtm5InEdgeCount                                                 ) continue;

															 GrindWidthDis = Math.GetLength(OrgBtm5InPoint[GrindMarkInCnt+k], OrgBtm5OutPoint[GrindMarkOutCnt+k]);
															 TotalCirDis+=   GrindWidthDis;
															 CircleCount++;
														 }
														 if(TotalCirDis!=0.0f && CircleCount!=0){
															 BtmGrindWidth7 = TotalCirDis/CircleCount;
															 BtmGrindWidth7 = BtmGrindWidth7+0.5; //SubPixel
														 }
													 }
												 }
												 else if(GrindMarkRect[14].left!=0 && GrindMarkRect[14].top!=0 && GrindMarkRect[14].right!=0 && GrindMarkRect[14].bottom!=0) {  //GrindMark 못 찾았을경우
													 // OutData기준 최소값 데이터 Count산출 
													 GrindMeaDis =0.0f, MinDis =10000.0f; GrindMarkOutCnt=0;
													 for(int k=0; k<OrgBtm5OutEdgeCount; k++){
														 if(OrgBtm5OutPoint[k].x==0.0f || OrgBtm5OutPoint[k].y==0.0f) continue;

														 if(k==0 && GrindRectSpec[4].DvX==0.0f && GrindRectSpec[4].DvY==0.0f){ //가상마크 
															 GrindMarkRectCenter[16].x = GrindMarkRect[16].left + (GrindMarkRect[16].right  - GrindMarkRect[16].left)/2; 
															 GrindMarkRectCenter[16].y = GrindMarkRect[16].top  + (GrindMarkRect[16].bottom - GrindMarkRect[16].top )/2; 

															 GrindMarkRectCenter[14].x     = OrgBtm5InPoint     [10].x                     ;
															 GrindMarkRectCenter[14].y     = GrindMarkRectCenter[16].y                     ;
															 GrindMarkRect      [14].left  = GrindMarkRectCenter[14].x    - GrindMarkRange ;  
															 GrindMarkRect      [14].top   = GrindMarkRectCenter[14].y    - GrindMarkRange ;  
															 GrindMarkRect      [14].right = GrindMarkRect      [14].left + GrindMarkLength;  
															 GrindMarkRect      [14].bottom= GrindMarkRect      [14].top  + GrindMarkLength;  
														 }
														 else if(k==0 && GrindRectSpec[4].DvX!=0.0f && GrindRectSpec[4].DvY!=0.0f){// 진성 마크 
															 GrindMarkRectCenter[14].x = GrindMarkRect[14].left + (GrindMarkRect[14].right  - GrindMarkRect[14].left)/2; 
															 GrindMarkRectCenter[14].y = GrindMarkRect[14].top  + (GrindMarkRect[14].bottom - GrindMarkRect[14].top )/2; 
														 }

														 GrindMeaDis = Math.GetLength(GrindMarkRectCenter[14], OrgBtm5OutPoint[k]);
														 if(GrindMeaDis<MinDis){
															 MinDis = GrindMeaDis;
															 GrindMarkOutCnt = k;
														 }
													 }

													 // 최단거리OUtCount기준 InData 최단거리 Count정보 Calc 
													 if(GrindMarkOutCnt!=0){
														 GrindMeaDis =0.0f, MinDis =10000.0f; GrindMarkInCnt=0;
														 for(int k=0; k<OrgBtm5InEdgeCount; k++){
															 if(OrgBtm5InPoint[k].x              ==0.0f  || OrgBtm5InPoint[k].y                ==0.0f) continue;
															 if(OrgBtm5OutPoint[GrindMarkOutCnt].x==0.0f || OrgBtm5OutPoint[GrindMarkOutCnt].y ==0.0f) continue;

															 GrindMeaDis = Math.GetLength(OrgBtm5OutPoint[GrindMarkOutCnt], OrgBtm5InPoint[k]);
															 if(GrindMeaDis<MinDis){
																 MinDis = GrindMeaDis;
																 GrindMarkInCnt = k;
															 }
														 }
													 }

													 // GrindMark기준 수직 포인트 주변값 Avg산출한다 ==>연마량 측정(OutData,InData기준)
													 if((GrindMarkOutCnt!=0 && GrindMarkOutCnt>5) && (GrindMarkInCnt!=0 && GrindMarkInCnt>5)){
														 CircleCount=0,TotalCirDis=0.0f,GrindWidthDis=0.0f;
														 for(int k=-5; k<5; k++){
															 if(OrgBtm5OutPoint[GrindMarkOutCnt+k].x==0.0f && OrgBtm5OutPoint[GrindMarkOutCnt+k].y==0.0f) continue;
															 if(OrgBtm5InPoint [GrindMarkInCnt +k].x==0.0f && OrgBtm5InPoint [GrindMarkInCnt +k].y==0.0f) continue;
															 if((GrindMarkOutCnt+k)>=OrgBtm5OutEdgeCount                                                ) continue;
															 if((GrindMarkInCnt +k)>=OrgBtm5InEdgeCount                                                 ) continue;

															 GrindWidthDis = Math.GetLength(OrgBtm5InPoint[GrindMarkInCnt+k], OrgBtm5OutPoint[GrindMarkOutCnt+k]);
															 TotalCirDis+=   GrindWidthDis;
															 CircleCount++;
														 }
														 if(TotalCirDis!=0.0f && CircleCount!=0){
															 BtmGrindWidth7 = TotalCirDis/CircleCount;
															 BtmGrindWidth7 = BtmGrindWidth7+0.5; //SubPixel
														 }
													 }
												 }

												 // GrindMark[16] 가공량,연마량 측정 
												 ////////////////////////////////////////////////////////////////////////////////////////////////////
												 if(GrindMarkPoint[16].x!=0.0f && GrindMarkPoint[16].y!=0.0f){ 
													 // GrindMark기준 OutData 최단거리 Count정보 Calc 
													 GrindMeaDis =0.0f, MinDis =10000.0f;  GrindMarkOutCnt=0;
													 for(int k=0; k<OrgBtm5OutEdgeCount; k++){
														 if(OrgBtm5OutPoint[k].x==0.0f || OrgBtm5OutPoint[k].y==0.0f) continue;
														 if(GrindMarkPoint[16].x ==0.0f || GrindMarkPoint[16].y ==0.0f) continue;

														 GrindMeaDis = Math.GetLength(GrindMarkPoint[16], OrgBtm5OutPoint[k]);
														 if(GrindMeaDis<MinDis){
															 MinDis = GrindMeaDis;
															 GrindMarkOutCnt = k;
														 }
													 }

													 // GrindMark기준 InData 최단거리 Count정보 Calc 
													 if(GrindMarkOutCnt!=0){
														 GrindMeaDis =0.0f, MinDis =10000.0f; GrindMarkInCnt=0;
														 for(int k=0; k<OrgBtm5InEdgeCount; k++){
															 if(OrgBtm5InPoint[k].x   ==0.0f             || OrgBtm5InPoint[k].y                ==0.0f) continue;
															 if(OrgBtm5OutPoint[GrindMarkOutCnt].x==0.0f || OrgBtm5OutPoint[GrindMarkOutCnt].y ==0.0f) continue;

															 GrindMeaDis = Math.GetLength(OrgBtm5OutPoint[GrindMarkOutCnt], OrgBtm5InPoint[k]);
															 if(GrindMeaDis<MinDis){
																 MinDis = GrindMeaDis;
																 GrindMarkInCnt = k;
															 }
														 }
													 }

													 // GrindMark기준 수직 포인트 주변값 Avg산출한다 ==>가공량 측정(OutData기준)
													 if(GrindMarkOutCnt!=0 && GrindMarkOutCnt>5){
														 CircleCount=0,TotalCirDis=0.0f,GrindMeaDis=0.0f;
														 for(int k=GrindMarkOutCnt-5; k<GrindMarkOutCnt+5; k++){
															 if(OrgBtm5OutPoint[k].x==0.0f || OrgBtm5OutPoint[k].y==0.0f) continue;
															 if(k>=OrgBtm5OutEdgeCount                                  ) continue;

															 GrindMeaDis = Math.GetLength(GrindMarkPoint[16], OrgBtm5OutPoint[k]);
															 TotalCirDis+= GrindMeaDis;
															 CircleCount++;
														 }
														 if(TotalCirDis!=0.0f && CircleCount!=0){
															 BtmGrindMeasure9 = TotalCirDis/CircleCount;
															 BtmGrindMeasure9 = BtmGrindMeasure9+0.5; //SubPixel 
														 }
													 }

													 // GrindMark기준 수직 포인트 주변값 Avg산출한다 ==>연마량 측정(OutData,InData기준)
													 if((GrindMarkOutCnt!=0 && GrindMarkOutCnt>5) && (GrindMarkInCnt!=0 && GrindMarkInCnt>5)){
														 CircleCount=0,TotalCirDis=0.0f,GrindWidthDis=0.0f;
														 for(int k=-5; k<5; k++){
															 if(OrgBtm5OutPoint[GrindMarkOutCnt+k].x==0.0f && OrgBtm5OutPoint[GrindMarkOutCnt+k].y==0.0f) continue;
															 if(OrgBtm5InPoint [GrindMarkInCnt +k].x==0.0f && OrgBtm5InPoint [GrindMarkInCnt +k].y==0.0f) continue;
															 if((GrindMarkOutCnt+k)>=OrgBtm5OutEdgeCount                                                ) continue;
															 if((GrindMarkInCnt +k)>=OrgBtm5InEdgeCount                                                 ) continue;

															 GrindWidthDis = Math.GetLength(OrgBtm5InPoint[GrindMarkInCnt+k], OrgBtm5OutPoint[GrindMarkOutCnt+k]);
															 TotalCirDis+=   GrindWidthDis;
															 CircleCount++;
														 }
														 if(TotalCirDis!=0.0f && CircleCount!=0){
															 BtmGrindWidth9 = TotalCirDis/CircleCount;
															 BtmGrindWidth9 = BtmGrindWidth9+0.5; //SubPixel
														 }
													 }
												 }
												 else if(GrindMarkRect[16].left!=0 && GrindMarkRect[16].top!=0 && GrindMarkRect[16].right!=0 && GrindMarkRect[16].bottom!=0) {  //GrindMark 못 찾았을경우
													 // OutData기준 최소값 데이터 Count산출 
													 GrindMeaDis =0.0f, MinDis =10000.0f; GrindMarkOutCnt=0;
													 for(int k=0; k<OrgBtm5OutEdgeCount; k++){
														 if(OrgBtm5OutPoint[k].x==0.0f || OrgBtm5OutPoint[k].y==0.0f) continue;

														 if(k==0){
															 GrindMarkRectCenter[16].x = GrindMarkRect[16].left + (GrindMarkRect[16].right  - GrindMarkRect[16].left)/2; 
															 GrindMarkRectCenter[16].y = GrindMarkRect[16].top  + (GrindMarkRect[16].bottom - GrindMarkRect[16].top )/2; 
														 }
														 GrindMeaDis = Math.GetLength(GrindMarkRectCenter[16], OrgBtm5OutPoint[k]);
														 if(GrindMeaDis<MinDis){
															 MinDis = GrindMeaDis;
															 GrindMarkOutCnt = k;
														 }
													 }

													 // 최단거리OUtCount기준 InData 최단거리 Count정보 Calc 
													 if(GrindMarkOutCnt!=0){
														 GrindMeaDis =0.0f, MinDis =10000.0f; GrindMarkInCnt=0;
														 for(int k=0; k<OrgBtm5InEdgeCount; k++){
															 if(OrgBtm5InPoint[k].x              ==0.0f  || OrgBtm5InPoint[k].y                ==0.0f) continue;
															 if(OrgBtm5OutPoint[GrindMarkOutCnt].x==0.0f || OrgBtm5OutPoint[GrindMarkOutCnt].y ==0.0f) continue;

															 GrindMeaDis = Math.GetLength(OrgBtm5OutPoint[GrindMarkOutCnt], OrgBtm5InPoint[k]);
															 if(GrindMeaDis<MinDis){
																 MinDis = GrindMeaDis;
																 GrindMarkInCnt = k;
															 }
														 }
													 }

													 // GrindMark기준 수직 포인트 주변값 Avg산출한다 ==>연마량 측정(OutData,InData기준)
													 if((GrindMarkOutCnt!=0 && GrindMarkOutCnt>5) && (GrindMarkInCnt!=0 && GrindMarkInCnt>5)){
														 CircleCount=0,TotalCirDis=0.0f,GrindWidthDis=0.0f;
														 for(int k=-5; k<5; k++){
															 if(OrgBtm5OutPoint[GrindMarkOutCnt+k].x==0.0f && OrgBtm5OutPoint[GrindMarkOutCnt+k].y==0.0f) continue;
															 if(OrgBtm5InPoint [GrindMarkInCnt +k].x==0.0f && OrgBtm5InPoint [GrindMarkInCnt +k].y==0.0f) continue;
															 if((GrindMarkOutCnt+k)>=OrgBtm1OutEdgeCount                                                ) continue;
															 if((GrindMarkInCnt +k)>=OrgBtm1InEdgeCount                                                 ) continue;

															 GrindWidthDis = Math.GetLength(OrgBtm5InPoint[GrindMarkInCnt+k], OrgBtm5OutPoint[GrindMarkOutCnt+k]);
															 TotalCirDis+=   GrindWidthDis;
															 CircleCount++;
														 }
														 if(TotalCirDis!=0.0f && CircleCount!=0){
															 BtmGrindWidth9 = TotalCirDis/CircleCount;
															 BtmGrindWidth9 = BtmGrindWidth9+0.5; //SubPixel
														 }
													 }
												 }
											 }
										 }
										 else { // ENCAP 연마량 데이터만 계측함
											 if(BtmOutLine[0].FP0.x!=0.0f && BtmOutLine[0].FP0.y!=0.0f && BtmOutLine[0].FP1.x!=0.0f && BtmOutLine[0].FP1.y!=0.0f &&
												 BtmInLine [0].FP0.x!=0.0f && BtmInLine [0].FP0.y!=0.0f && BtmInLine [0].FP1.x!=0.0f && BtmInLine [0].FP1.y!=0.0f ){
													 // 연마량 계산  
													 if((fabs(BtmOutLine[0].FP0.y - BtmOutLine[0].FP1.y))>1
														 ||(fabs(BtmInLine[0].FP0.y - BtmInLine[0].FP1.y))>1){
															 BtmGrindWidth9 = BtmOutLine[0].FP0.y - BtmInLine[0].FP0.y; 
													 }
													 else{
														 BtmGrindWidth9 = Math.GetLengthFrLineToPoint(BtmOutLine[0].FP0, BtmOutLine[0].FP1, BtmInLine[0].FP0);
													 }
											 }
										 }
										 // 동적 생성한 데이터를 지운다 
										 if(OrgBtm5InPoint !=NULL) delete[] OrgBtm5InPoint;
										 if(OrgBtm5OutPoint!=NULL) delete[] OrgBtm5OutPoint;
										 LogUnit.SetLog(L"CellID:%d, CamID:%d ==>Straight5_Insp_End",CellId,CamId);
									 }

									 // 4_Round Cell 시퀀스 
									 //Notch부 Side만 Arc가공이 존재할 경우 (Polygon_Mode)
									 // 연마량,가공량 측정 없이 Defect 검사만 진행함 
									 if(CenterCircleWidth==0.0f && CenterCircleHeight==0.0f){
										 if(BtmEdgePoint[0].x!=0 && BtmEdgePoint[0].y!=0 && BtmEdgePoint[9].x!=0 && BtmEdgePoint[9].y!=0 ){ // BTM
											 P1.x=0, P1.y=0, P2.x=0, P2.y=0, P3.x=0, P3.y=0, P4.x=0, P4.y=0;

											 P1.x = (BtmEdgePoint[0].x); P1.y =(BtmEdgePoint[0].y-30); P2.x = (P1.x+(BtmEdgePoint[9].x - BtmEdgePoint[0].x )); P2.y = (P1.y);
											 P3.x = (BtmEdgePoint[0].x); P3.y =(BtmEdgePoint[0].y+30); P4.x = (P2.x                                         ); P4.y = (P3.y);

											 // Median Filter 적용 
											 if(P1.x<=0    || P1.y<=0    || (P2.x - P1.x)<=0    || (P3.y - P1.y)<=0   ) return false;
											 if(P1.x>=ImgW || P1.y>=ImgH || (P2.x - P1.x)>=ImgW || (P3.y - P1.y)>=ImgH) return false;
											 FilterROI.SetSize(int(P2.x - P1.x),int(P3.y - P1.y) )                      ;
											 FilterROI.Attach(&RotateBinaryImg)                                    ;
											 FilterROI.SetPlacement(P1.x, P1.y, int(P2.x - P1.x), int(P3.y - P1.y));
											 EasyImage::Median(&FilterROI, &FilterROI)                             ;

											 Polygon->PoPa.FMinHeight = 5                          ;
											 Polygon->GImage          = &RotateBinaryImg           ;
											 Polygon->PoPa.FMaxWidth  =(int)(P2.x - P1.x)+100      ;
											 Polygon->PoPa.FMaxHeight =(int)(P3.y - P1.y)          ;
											 Polygon->PoPa.IsSeparate =true                        ;
											 Polygon->PoPa.IsInToOut  =true                        ;
											 Polygon->PoPa.HiThHold   = BtmEdgeThresHold           ;
											 Polygon->PoPa.LoThHold   = 0                          ;

											 if(P1.x!=0 && P1.y!=0 && P2.x!=0 && P2.y!=0 && P3.x!=0 && P3.y!=0 && P4.x!=0 && P4.y!=0){
												 Polygon->OnExecute(P1,P2,P3,P4);
											 }

											 // Polygon Algorithm InEdgeData/OutEdgeData Separate 및 데이터 추출 
											 if(Polygon->BlobCount==1){
												 PolygonMarginCnt =10;
												 if(Polygon->Blob[0].InCnt>(PolygonMarginCnt*2)){
													 OrgBtm1InEdgeCount=0;
													 OrgBtm1InEdgeCount = (Polygon->Blob[0].InCnt - (PolygonMarginCnt*2));
													 if(OrgBtm1InEdgeCount>0){
														 if(OrgBtm1InPoint!=NULL) delete[] OrgBtm1InPoint;
														 OrgBtm1InPoint = new TFPoint[OrgBtm1InEdgeCount];

														 PixelCnt=0;
														 for(int k=0; k<Polygon->Blob[0].InCnt; k++){
															 if(k<PolygonMarginCnt || k>=(Polygon->Blob[0].InCnt-PolygonMarginCnt)) continue;
															 OrgBtm1InPoint[PixelCnt].x   = Polygon->Blob[0].InPoint[k].x ;
															 OrgBtm1InPoint[PixelCnt].y   = Polygon->Blob[0].InPoint[k].y ;
															 PixelCnt++;
														 }
													 }
													 // Org Data 
													 BtmInLine[0].FP0 = OrgBtm1InPoint[0];
													 BtmInLine[0].FP1 = OrgBtm1InPoint[PixelCnt-1];
												 }

												 if(Polygon->Blob[0].OutCnt>(PolygonMarginCnt*2)){
													 OrgBtm1OutEdgeCount=0;
													 OrgBtm1OutEdgeCount = (Polygon->Blob[0].OutCnt - (PolygonMarginCnt*2));
													 if(OrgBtm1OutEdgeCount>0){
														 if(OrgBtm1OutPoint!=NULL) delete[] OrgBtm1OutPoint;
														 OrgBtm1OutPoint = new TFPoint[OrgBtm1OutEdgeCount];

														 PixelCnt=0;
														 for(int k=0; k<Polygon->Blob[0].OutCnt; k++){
															 if(k<PolygonMarginCnt || k>=(Polygon->Blob[0].OutCnt-PolygonMarginCnt)) continue;
															 OrgBtm1OutPoint[PixelCnt].x  = Polygon->Blob[0].OutPoint[k].x ;
															 OrgBtm1OutPoint[PixelCnt].y  = Polygon->Blob[0].OutPoint[k].y ;
															 PixelCnt++;
														 }
													 }
													 // Org Data 
													 BtmOutLine[0].FP0 = OrgBtm1OutPoint[0];
													 BtmOutLine[0].FP1 = OrgBtm1OutPoint[PixelCnt-1];
												 }
												 // Polygon Data Clear
// 												 Polygon->ClearData();
											 }

											 // Size 측정 목적으로 가공량만 산출한다 
											 if(GrindMarkPoint[2].x!=0.0f && GrindMarkPoint[2].y!=0.0f) { 
												 // GrindMark기준 OutData 최단거리 Count정보 Calc 
												 GrindMeaDis =0.0f, MinDis =10000.0f;  GrindMarkOutCnt=0;
												 for(int k=0; k<OrgBtm1OutEdgeCount; k++){
													 if(OrgBtm1OutPoint[k].x==0.0f || OrgBtm1OutPoint[k].y==0.0f) continue;
													 if(GrindMarkPoint[2].x ==0.0f || GrindMarkPoint[2].y ==0.0f) continue;

													 GrindMeaDis = Math.GetLength(GrindMarkPoint[2], OrgBtm1OutPoint[k]);
													 if(GrindMeaDis<MinDis){
														 MinDis = GrindMeaDis;
														 GrindMarkOutCnt = k;
													 }
												 }

												 // GrindMark기준 수직 포인트 주변값 Avg산출한다 ==>가공량 측정(OutData기준)
												 if(GrindMarkOutCnt!=0 && GrindMarkOutCnt>5){
													 CircleCount=0,TotalCirDis=0.0f,GrindMeaDis=0.0f;
													 for(int k=GrindMarkOutCnt-5; k<GrindMarkOutCnt+5; k++){
														 if(OrgBtm1OutPoint[k].x==0.0f || OrgBtm1OutPoint[k].y==0.0f) continue;
														 if(k>=OrgBtm1OutEdgeCount                                  ) continue;

														 GrindMeaDis = Math.GetLength(GrindMarkPoint[2], OrgBtm1OutPoint[k]);
														 TotalCirDis+= GrindMeaDis;
														 CircleCount++;
													 }
													 if(TotalCirDis!=0.0f && CircleCount!=0){
														 BtmGrindMeasure1 = TotalCirDis/CircleCount;
														 BtmGrindMeasure1 = BtmGrindMeasure1+0.5; //SubPixel 
													 }
												 }
											 }

											 // Size 측정 목적으로 가공량만 산출한다 
											 if(GrindMarkPoint[16].x!=0.0f && GrindMarkPoint[16].y!=0.0f) { 
												 // GrindMark기준 OutData 최단거리 Count정보 Calc 
												 GrindMeaDis =0.0f, MinDis =10000.0f;  GrindMarkOutCnt=0;
												 for(int k=0; k<OrgBtm1OutEdgeCount; k++){
													 if(OrgBtm1OutPoint[k].x==0.0f || OrgBtm1OutPoint[k].y==0.0f) continue;
													 if(GrindMarkPoint[16].x ==0.0f || GrindMarkPoint[16].y ==0.0f) continue;

													 GrindMeaDis = Math.GetLength(GrindMarkPoint[16], OrgBtm1OutPoint[k]);
													 if(GrindMeaDis<MinDis){
														 MinDis = GrindMeaDis;
														 GrindMarkOutCnt = k;
													 }
												 }

												 // GrindMark기준 수직 포인트 주변값 Avg산출한다 ==>가공량 측정(OutData기준)
												 if(GrindMarkOutCnt!=0 && GrindMarkOutCnt>5){
													 CircleCount=0,TotalCirDis=0.0f,GrindMeaDis=0.0f;
													 for(int k=GrindMarkOutCnt-5; k<GrindMarkOutCnt+5; k++){
														 if(OrgBtm1OutPoint[k].x==0.0f || OrgBtm1OutPoint[k].y==0.0f) continue;
														 if(k>=OrgBtm1OutEdgeCount                                  ) continue;

														 GrindMeaDis = Math.GetLength(GrindMarkPoint[16], OrgBtm1OutPoint[k]);
														 TotalCirDis+= GrindMeaDis;
														 CircleCount++;
													 }
													 if(TotalCirDis!=0.0f && CircleCount!=0){
														 BtmGrindMeasure9 = TotalCirDis/CircleCount;
														 BtmGrindMeasure9 = BtmGrindMeasure9+0.5; //SubPixel 
													 }
												 }
											 }
											 // 동적 생성한 데이터를 지운다 
											 if(OrgBtm1InPoint !=NULL) delete[] OrgBtm1InPoint;
											 if(OrgBtm1OutPoint!=NULL) delete[] OrgBtm1OutPoint;
										 }
									 }
									 LogUnit.SetLog(L"CellID:%d, CamID:%d ==>Polygon_Insp_End",CellId,CamId);
								 } // NOTCH shRectC
								 else if(FInspectMode==Insp_Mark || FInspectMode==Insp_Track){ // 연마안쪽,연마외곽 검출기준을 각각 ThresHold값 적용하여 진행함 
									 Circle->SetSamplingStep(1)                            ; // Circle Edge 간격 

									 // 첫번째 Circle EdgePoint Data 추출 
									 if(C1CirCenter.x!=0 && C1CirCenter.y!=0){
										 LogUnit.SetLog(L"Circle_1_Insp_Start");

										 // 									 if(BtmEdgeThresHold==0) Circle->GImage = &RotateImg      ; //Org Image 넘겨줌 
										 // 									 else                    Circle->GImage = &RotateBinaryImg; //Binary Image 넘겨줌 

										 if(CirGrindInThresHold==0) Circle->GImage = &RotateImg             ; //Org Image 넘겨줌 
										 else                       Circle->GImage = &RotateGrindInBinaryImg; //Binary Image 넘겨줌 

										 if      (FInspectMode==Insp_Track) Circle->SetCenterXY(TrackC1CirCenter.x , TrackC1CirCenter.y); // TrackLine 교차점 기준 센터 
										 else if (FInspectMode==Insp_Mark ) Circle->SetCenterXY(C1CirCenter.x      , C1CirCenter.y     ); // 외곽라인 교차점 기준 센터 

										 // Diameter 계산함(OutCircle과 TrackCircle 중간값 기준)
										 // 									 C1Diameter = ((CSideCircleWidth*2)+(TrackCircleWidth*2))/2;
										 C1Diameter = (CSideCircleWidth*2);
										 // 									 C1Diameter = (CSideCircleWidth*2);
										 // 검사 영역으로 인해서 불량 미검출 발생할수 있음....LTPS와 EnCap분류함
										 if(IsMarkBtm) Circle->SetTolerance(60.0f);
										 else          Circle->SetTolerance(80.0f);
										 // 									 Circle->SetTolerance(40.0f )                              ; // Circle Tolerance 
										 Circle->SetDiameter (C1Diameter)                          ; // Circle Diameter 
										 // 									 Circle->SetCircleChoice(0)                                ; // 0:From Begin, 1:From End, 2:Largest Amplitude 
										 // 									 Circle->SetCircleIndex (0)                                ; // Circle EdgePoint Index 
										 Circle->SetCircleChoice(1)                                ; // 0:From Begin, 1:From End, 2:Largest Amplitude 
										 Circle->SetCircleType  (2)                                ; // 0:Black to White, 1:White to Black 2: Both Black, White 
										 Circle->SetCircleIndex (1)                                ; // Circle EdgePoint Index 

										 // Angle 및 Amplitude 설정 
										 if(SideCirDeg>=0){
											 Circle->SetAngle    (90+CirAngleMargin          );  // Circle Fitting 시작점 각도
											 Circle->SetAmplitude(SideCirDeg-2*CirAngleMargin);  // Circle Fitting 시작점 부터 검사 범위 
										 }

										 // Circle1 InData EdgePoint 
										 //////////////////////////////////////////////////////////////////////////////////////////////////////
										 Circle->OnExecute()                               ;

										 // Circle In Data 기준 새로운 Circle Center 좌표 받아옴 
										 RealC1CirCenter.x = Circle->FCP.x;
										 RealC1CirCenter.y = Circle->FCP.y;
										 CirDiameter1      = (Circle->Diameter)/2.0;

										 // Circle In Data취합 
										 OrgC1CirInEdgeCount = Circle->FCirclePointCount;
										 if(OrgC1CirInEdgeCount>0){
											 if(OrgC1CirInPoint!=NULL) delete[] OrgC1CirInPoint;
											 OrgC1CirInPoint = new TFPoint[OrgC1CirInEdgeCount];

											 for(int k=0; k<OrgC1CirInEdgeCount; k++){
												 if(k>MAX_CIRCLE_EDGEPOINT) break;
												 OrgC1CirInPoint[k].x = Circle->FCirclePoint[k].x;
												 OrgC1CirInPoint[k].y = Circle->FCirclePoint[k].y;
												 if(OrgC1CirInPoint[k].x==0.0f && OrgC1CirInPoint[k].y==0.0f) C1CirInEdgeCount++;
												 // BTM영역 Circle을 제외한 영역 Defect검사 목적에 좌표계산 
												 // 											 if(k==0) {BtmEdgePoint1.x = C1CirInPoint[k].x; BtmEdgePoint1.y = C1CirInPoint[k].y;}
											 }
										 }
										 //////////////////////////////////////////////////////////////////////////////////////////////////////

										 // Circle Out Data 다시 검사  
										 //////////////////////////////////////////////////////////////////////////////////////////////////////
										 if(BtmEdgeThresHold==0) Circle->GImage = &RotateImg      ; //Org Image 넘겨줌 
										 else                    Circle->GImage = &RotateBinaryImg; //Binary Image 넘겨줌 

										 // 검사 영역으로 인해서 불량 미검출 발생할수 있음....LTPS와 EnCap분류함
										 if(IsMarkBtm) Circle->SetTolerance(60.0f);
										 else          Circle->SetTolerance(80.0f);
										 // 									Circle->SetTolerance(40.0f )      ; // Circle Tolerance 
										 Circle->SetDiameter (C1Diameter)  ; // Circle Diameter 
										 Circle->SetCircleChoice(1)        ; // 0:From Begin, 1:From End, 2:Largest Amplitude 
										 Circle->SetCircleType(2)          ; // 0:Black to White, 1:White to Black 2: Both Black, White 
										 Circle->SetCircleIndex (0)        ; // Circle EdgePoint Index 
										 // Circle1 OutData EdgePoint 
										 /////////////////////////////////////////////////////////////////////////////////////////////////////////
										 Circle->OnExecute()               ;

										 // Circle Out Data취합 
										 OrgC1CirOutEdgeCount = Circle->FCirclePointCount;
										 if(OrgC1CirOutEdgeCount>0){
											 if(OrgC1CirOutPoint!=NULL) delete[] OrgC1CirOutPoint;
											 OrgC1CirOutPoint = new TFPoint[OrgC1CirOutEdgeCount];

											 for(int k=0; k<OrgC1CirOutEdgeCount; k++){
												 if(k>MAX_CIRCLE_EDGEPOINT) break;
												 OrgC1CirOutPoint[k].x = Circle->FCirclePoint[k].x;
												 OrgC1CirOutPoint[k].y = Circle->FCirclePoint[k].y;
												 // BTM영역 Circle을 제외한 영역 Defect검사 목적에 좌표계산 
												 if(k==0) {BtmEdgePoint[0].x = OrgC1CirOutPoint[k].x; BtmEdgePoint[0].y = OrgC1CirOutPoint[k].y;}
												 if(OrgC1CirOutPoint[k].x==0.0f && OrgC1CirOutPoint[k].y==0.0f) C1CirOutEdgeCount++;
											 }
										 }
										 // C1Circle Grind_Width Calculate 
										 // TrackMode CirInEdgePoint 기준과 CirOutEdgePoint 수직거리 산출
										 if(FInspectMode==Insp_Track){
											 // 연마량 계산 
											 if(OrgC1CirInEdgeCount==OrgC1CirOutEdgeCount){
												 double OutDis=0.0f, InDis=0.0f, TotalGrindWidth=0.0f, AvgGrindWidth=0.0f;C1GrindWidthCount=0;
												 for(int k=0; k<OrgC1CirInEdgeCount; k++){
													 if(OrgC1CirOutPoint[k].x==0.0f && OrgC1CirOutPoint[k].y==0.0f){
														 OutDis =0.0f;
													 }
													 else {
														 OutDis = Math.GetLengthFrPointToPoint(C1CirCenter,OrgC1CirOutPoint[k]);
													 }

													 if(OrgC1CirInPoint[k].x==0.0f && OrgC1CirInPoint[k].y==0.0f){
														 InDis =0.0f;
													 }
													 else {
														 InDis = Math.GetLengthFrPointToPoint(C1CirCenter,OrgC1CirInPoint[k]);
													 }

													 // CircleFitting 진행시 실제 EdgePoint 데이터가 존재 할 경우만 포함하여 계산한다
													 if(OutDis!=0.0f && InDis!=0.0f){
														 TotalGrindWidth+=(OutDis - InDis);
														 C1GrindWidthCount++;
													 }
												 }
												 if(C1GrindWidthCount!=0){
													 AvgGrindWidth = (TotalGrindWidth/C1GrindWidthCount);
													 C1CirGrindWd = AvgGrindWidth;
												 }
											 }
											 if(IsMarkBtm){ // 가공량 계산(TrackMode)==>LTPS
												 if(CirGrindMeaThresHold!=0){
													 Circle->GImage = &RotateGrindBinaryImg    ; //Binary Image 넘겨줌 
													 Circle->SetCircleChoice(1)                ; // 0:From Begin, 1:From End, 2:Largest Amplitude 
													 Circle->SetCircleType(2)                  ; // 0:Black to White, 1:White to Black 2: Both Black, White 
													 Circle->SetCircleIndex (1)                ; // Circle EdgePoint Index 
													 Circle->SetTolerance(40.0f )              ; // Circle Tolerance 
													 Circle->SetDiameter (C1Diameter)          ; // Circle Diameter 
													 Circle->OnExecute()                       ;

													 // Circle TrackLine Data 기준 새로운 Circle Center 좌표 받아옴 
													 // Circle Defect검사시 필요한 기준데이터 좌표 
													 RealC1CirCenter.x = Circle->FCP.x;
													 RealC1CirCenter.y = Circle->FCP.y;

													 OrgC1CirStandEdgeCount = Circle->FCirclePointCount;
													 if(OrgC1CirStandEdgeCount>0){
														 if(OrgC1CirStandPoint!=NULL) delete[] OrgC1CirStandPoint;
														 OrgC1CirStandPoint = new TFPoint[OrgC1CirStandEdgeCount];

														 PreC1CirStandPoint[0].x=0.0f; PreC1CirStandPoint[0].y=0.0f; 
														 for(int k=0; k<OrgC1CirStandEdgeCount; k++){
															 if(k>MAX_CIRCLE_EDGEPOINT) break;
															 OrgC1CirStandPoint[k].x = Circle->FCirclePoint[k].x;
															 OrgC1CirStandPoint[k].y = Circle->FCirclePoint[k].y;
															 if(OrgC1CirStandPoint[k].x==0.0f && OrgC1CirStandPoint[k].y==0.0f) C1CirStandEdgeCount++;
															 // TrackLine 자재 상태에 따라서 잘못된 EdgePoint를 찾을경우 대비하여 이전데이터 기준 데이터 복원 
															 if(OrgC1CirStandPoint[k].x!=0.0f && OrgC1CirStandPoint[k].y!=0.0f){
																 // 첫번째는 무조건 데이터 넘겨줌 
																 if(PreC1CirStandPoint[0].x==0.0f && PreC1CirStandPoint[0].y==0.0f){
																	 PreC1CirStandPoint[0].x = OrgC1CirStandPoint[k].x; 
																	 PreC1CirStandPoint[0].y = OrgC1CirStandPoint[k].y; 
																 }
																 else {
																	 if(fabs(OrgC1CirStandPoint[k].x-PreC1CirStandPoint[0].x)>TrackLineMargin ||
																		 fabs(OrgC1CirStandPoint[k].y-PreC1CirStandPoint[0].y)>TrackLineMargin   ){
																			 OrgC1CirStandPoint[k].x = PreC1CirStandPoint[0].x-0.5;
																			 OrgC1CirStandPoint[k].y = PreC1CirStandPoint[0].y-0.5;

																			 PreC1CirStandPoint[0].x = OrgC1CirStandPoint[k].x; 
																			 PreC1CirStandPoint[0].y = OrgC1CirStandPoint[k].y; 
																	 }
																	 else {
																		 PreC1CirStandPoint[0].x = OrgC1CirStandPoint[k].x; 
																		 PreC1CirStandPoint[0].y = OrgC1CirStandPoint[k].y; 
																	 }
																 }
															 }
														 }
														 //C1Circle Grind_Measure Calculate 
														 if(OrgC1CirOutEdgeCount==OrgC1CirStandEdgeCount){
															 double GrindMeaDis=0.0f, TotalGrindMeasure=0.0f, AvgGrindMeasure=0.0f;C1GrindMeasureCount=0;
															 double Degree =0.0f;
															 for(int k=0; k<OrgC1CirStandEdgeCount; k++){
																 if(OrgC1CirOutPoint[k].x==0.0f || OrgC1CirOutPoint[k].y==0.0f || OrgC1CirStandPoint[k].x==0.0f || OrgC1CirStandPoint[k].y==0.0f){
																	 GrindMeaDis =0.0f;
																 }
																 else {
																	 Degree = Math.GetDegree(OrgC1CirStandPoint[k],OrgC1CirOutPoint[k]);
																	 GrindMeaDis = Math.GetLengthFrPointToPoint(OrgC1CirStandPoint[k],OrgC1CirOutPoint[k]);
																 }

																 if(GrindMeaDis!=0.0f){
																	 TotalGrindMeasure+= GrindMeaDis;
																	 C1GrindMeasureCount++;
																 }
															 }
															 if(C1GrindMeasureCount!=0){
																 AvgGrindMeasure = (TotalGrindMeasure/C1GrindMeasureCount);
																 C1CirGrindMea= AvgGrindMeasure;
															 }
														 }
														 else if(OrgC1CirStandEdgeCount>OrgC1CirOutEdgeCount) { // 연마가 적게되어 실제 TrackLine보다 EdgePoint데이터가 적을경우 
															 double GrindMeaDis=0.0f, TotalGrindMeasure=0.0f, AvgGrindMeasure=0.0f;C1GrindMeasureCount=0;
															 for(int k=0; k<OrgC1CirOutEdgeCount; k++){
																 if(OrgC1CirOutPoint[k].x==0.0f || OrgC1CirOutPoint[k].y==0.0f || OrgC1CirStandPoint[k].x==0.0f || OrgC1CirStandPoint[k].y==0.0f ){
																	 GrindMeaDis =0.0f;
																 }
																 else {
																	 GrindMeaDis = Math.GetLengthFrPointToPoint(OrgC1CirStandPoint[k],OrgC1CirOutPoint[k]);
																 }

																 if(GrindMeaDis!=0.0f){
																	 TotalGrindMeasure+= GrindMeaDis;
																	 C1GrindMeasureCount++;
																 }
															 }
															 if(C1GrindMeasureCount!=0){
																 AvgGrindMeasure = (TotalGrindMeasure/C1GrindMeasureCount);
																 C1CirGrindMea= AvgGrindMeasure;
															 }
														 }
														 else if(OrgC1CirStandEdgeCount<OrgC1CirOutEdgeCount){
															 double GrindMeaDis=0.0f, TotalGrindMeasure=0.0f, AvgGrindMeasure=0.0f;C1GrindMeasureCount=0;
															 // test 
															 double OutDegree=0.0f, TrackDegree=0.0f;
															 for(int k=0; k<OrgC1CirStandEdgeCount; k++){
																 if(OrgC1CirOutPoint[k].x==0.0f || OrgC1CirOutPoint[k].y==0.0f || OrgC1CirStandPoint[k].x==0.0f || OrgC1CirStandPoint[k].y==0.0f ){
																	 GrindMeaDis =0.0f;
																 }
																 else {
																	 OutDegree   = Math.GetDegree(TrackC1CirCenter, OrgC1CirOutPoint[k]  );
																	 TrackDegree = Math.GetDegree(TrackC1CirCenter, OrgC1CirStandPoint[k]); 
																	 GrindMeaDis = Math.GetLengthFrPointToPoint(OrgC1CirStandPoint[k],OrgC1CirOutPoint[k]);
																 }

																 if(GrindMeaDis!=0.0f){
																	 TotalGrindMeasure+= GrindMeaDis;
																	 C1GrindMeasureCount++;
																 }
															 }
															 if(C1GrindMeasureCount!=0){
																 AvgGrindMeasure = (TotalGrindMeasure/C1GrindMeasureCount);
																 C1CirGrindMea= AvgGrindMeasure;
															 }
														 }
													 }
												 }
											 }
										 }
										 else if(FInspectMode==Insp_Mark){ // MarkMode 
											 if(IsMarkBtm){ // LTPS경우 가공량 계산 ==> 연마량 계산 
												 if(OrgC1CirOutEdgeCount!=0 && OrgC1CirInEdgeCount!=0) { // MarkMode경우 가공량 검사를 먼저 진행 후 연마량 산출  
													 GrindMeaDis =0.0f, MinDis =10000.0f;C1GrindMarkCount=0;
													 if(GrindMarkPoint[1].x!=0.0f && GrindMarkPoint[1].y!=0.0f){ // Grind Mark 찾았을경우 
														 for(int k=0; k<OrgC1CirOutEdgeCount; k++){
															 if(OrgC1CirOutPoint[k].x==0.0f || OrgC1CirOutPoint[k].y==0.0f) continue;
															 if(GrindMarkPoint[1].x  ==0.0f || GrindMarkPoint[1].y  ==0.0f) continue;

															 GrindMeaDis = Math.GetLength(GrindMarkPoint[1], OrgC1CirOutPoint[k]);
															 if(GrindMeaDis<MinDis){
																 MinDis = GrindMeaDis;
																 C1GrindMarkCount = k;
															 }
														 }
														 // GrindMark기준 수직 포인트 주변값 Avg산출한다 ==>가공량 측정 
														 if(C1GrindMarkCount!=0 && C1GrindMarkCount>5){
															 CircleCount=0,TotalCirDis=0.0f,GrindMeaDis=0.0f;
															 for(int k=C1GrindMarkCount-5; k<C1GrindMarkCount+5; k++){
																 if(OrgC1CirOutPoint[k].x==0.0f || OrgC1CirOutPoint[k].y==0.0f) continue;
																 GrindMeaDis = Math.GetLength(GrindMarkPoint[1], OrgC1CirOutPoint[k]);
																 TotalCirDis+= GrindMeaDis;
																 CircleCount++;
															 }
															 if(TotalCirDis!=0.0f && CircleCount!=0){
																 C1CirGrindMea = TotalCirDis/CircleCount;
															 }
														 }

														 // GrindMark기준 수직 평균값 연마량 측정 
														 if(C1GrindMarkCount!=0 && C1GrindMarkCount>5){
															 CircleCount=0,TotalCirDis=0.0f,GrindWidthDis=0.0f;
															 for(int k=C1GrindMarkCount-5; k<C1GrindMarkCount+5; k++){
																 if(OrgC1CirOutPoint[k].x==0.0f && OrgC1CirOutPoint[k].y==0.0f) continue;
																 if(OrgC1CirInPoint [k].x==0.0f && OrgC1CirInPoint [k].y==0.0f) continue;

																 GrindWidthDis = Math.GetLength(OrgC1CirInPoint[k], OrgC1CirOutPoint[k]);
																 TotalCirDis+=   GrindWidthDis;
																 CircleCount++;
															 }
															 if(TotalCirDis!=0.0f && CircleCount!=0){
																 C1CirGrindWd = TotalCirDis/CircleCount;
															 }
														 }
													 }
													 else { // Grind Mark 못 찾았을경우 (가공량 0, 연마량 계산함)
														 for(int k=0; k<OrgC1CirOutEdgeCount; k++){
															 if(OrgC1CirOutPoint[k].x==0.0f || OrgC1CirOutPoint[k].y==0.0f) continue;

															 GrindMarkRectCenter[1].x = GrindMarkRect[1].left + (GrindMarkRect[1].right  - GrindMarkRect[1].left)/2; 
															 GrindMarkRectCenter[1].y = GrindMarkRect[1].top  + (GrindMarkRect[1].bottom - GrindMarkRect[1].top )/2; 

															 GrindMeaDis = Math.GetLength(GrindMarkRectCenter[1], OrgC1CirOutPoint[k]);
															 if(GrindMeaDis<MinDis){
																 MinDis = GrindMeaDis;
																 C1GrindMarkCount = k;
															 }
														 }
														 // GrindMark기준 수직 평균값 연마량 측정 
														 if(C1GrindMarkCount!=0 && C1GrindMarkCount>5){
															 CircleCount=0,TotalCirDis=0.0f,GrindWidthDis=0.0f;
															 for(int k=C1GrindMarkCount-5; k<C1GrindMarkCount+5; k++){
																 if(OrgC1CirOutPoint[k].x==0.0f && OrgC1CirOutPoint[k].y==0.0f) continue;
																 if(OrgC1CirInPoint [k].x==0.0f && OrgC1CirInPoint [k].y==0.0f) continue;
																 GrindWidthDis = Math.GetLength(OrgC1CirInPoint[k], OrgC1CirOutPoint[k]);
																 TotalCirDis+=   GrindWidthDis;
																 CircleCount++;
															 }
															 if(TotalCirDis!=0.0f && CircleCount!=0){
																 C1CirGrindWd = TotalCirDis/CircleCount;
															 }
														 }
													 }
												 }
											 }
											 else     { // MarkMode ==> EnCap경우 연마량만 계산한다 
												 if(OrgC1CirInEdgeCount==OrgC1CirOutEdgeCount){
													 double OutDis=0.0f, InDis=0.0f, TotalGrindWidth=0.0f, AvgGrindWidth=0.0f;C1GrindWidthCount=0;
													 for(int k=0; k<OrgC1CirInEdgeCount; k++){
														 if(OrgC1CirOutPoint[k].x==0.0f && OrgC1CirOutPoint[k].y==0.0f){
															 OutDis =0.0f;
														 }
														 else {
															 OutDis = Math.GetLengthFrPointToPoint(C1CirCenter,OrgC1CirOutPoint[k]);
														 }

														 if(OrgC1CirInPoint[k].x==0.0f && OrgC1CirInPoint[k].y==0.0f){
															 InDis =0.0f;
														 }
														 else {
															 InDis = Math.GetLengthFrPointToPoint(C1CirCenter,OrgC1CirInPoint[k]);
														 }

														 // CircleFitting 진행시 실제 EdgePoint 데이터가 존재 할 경우만 포함하여 계산한다
														 if(OutDis!=0.0f && InDis!=0.0f){
															 TotalGrindWidth+=(OutDis - InDis);
															 C1GrindWidthCount++;
														 }
													 }
													 if(C1GrindWidthCount!=0){
														 AvgGrindWidth = (TotalGrindWidth/C1GrindWidthCount);
														 C1CirGrindWd = AvgGrindWidth;
													 }
												 }
											 }
										 }
										 // C1 Grind Mark 기준 가공량 측정 시퀀스 종료  
										 //////////////////////////////////////////////////////////////////////////////////////////////////////

										 // Org Circle데이터중 유호하지 않은 값을 제외한 실제 존재하는 데이터 기준으로 동적 메모리 생성함
										 // Circle Defect검사에 필요한 Edge데이터 값
										 int Count=0;
										 if(OrgC1CirInEdgeCount>0){
											 C1CirInEdgeCount = OrgC1CirInEdgeCount - C1CirInEdgeCount;
											 // 										 C1CirInEdgeCount = OrgC1CirInEdgeCount;
											 if(C1CirInEdgeCount>0){
												 if(C1CirInPoint!=NULL) delete[] C1CirInPoint;
												 C1CirInPoint = new TFPoint[C1CirInEdgeCount];

												 for(int k=0; k<OrgC1CirInEdgeCount; k++){
													 if(k>MAX_CIRCLE_EDGEPOINT) break;
													 if(OrgC1CirInPoint[k].x==0.0f && OrgC1CirInPoint[k].y==0.0f) continue;
													 C1CirInPoint[Count].x = OrgC1CirInPoint[k].x;
													 C1CirInPoint[Count].y = OrgC1CirInPoint[k].y;
													 Count++;
												 }
											 }
											 // Circle 원본 데이터 메모리 삭제
											 if(OrgC1CirInPoint!=NULL) delete[] OrgC1CirInPoint;
										 }
										 // FAVION Circle Fitting 결과물 
										 SampleSize = C1CirInEdgeCount*0.75; //0.5~0.8이하로 입력할것
										 DistDevRatio = 0.15;                //0.1~0.25 이하로 입력할것
										 CircleFit->OnRansac(C1CirInPoint,C1CirInEdgeCount,SampleSize,DistDevRatio,&CircleFit1Center,&CirFitDiameter1);

										 if(OrgC1CirOutEdgeCount>0){
											 C1CirOutEdgeCount = OrgC1CirOutEdgeCount - C1CirOutEdgeCount;
											 C1CirOutEdgeCount = OrgC1CirOutEdgeCount;
											 Count =0;
											 if(C1CirOutEdgeCount>0){
												 if(C1CirOutPoint!=NULL) delete[] C1CirOutPoint;
												 C1CirOutPoint = new TFPoint[C1CirOutEdgeCount];

												 for(int k=0; k<OrgC1CirOutEdgeCount; k++){
													 if(k>MAX_CIRCLE_EDGEPOINT) break;
													 if(OrgC1CirOutPoint[k].x==0.0f && OrgC1CirOutPoint[k].y==0.0f) continue;
													 C1CirOutPoint[Count].x = OrgC1CirOutPoint[k].x;
													 C1CirOutPoint[Count].y = OrgC1CirOutPoint[k].y;
													 Count++;
												 }
											 }
											 // Circle 원본 데이터 메모리 삭제
											 if(OrgC1CirOutPoint!=NULL) delete[] OrgC1CirOutPoint;
										 }
										 if(OrgC1CirStandEdgeCount>0){
											 C1CirStandEdgeCount = OrgC1CirStandEdgeCount - C1CirStandEdgeCount;
											 // 										 C1CirStandEdgeCount = OrgC1CirStandEdgeCount;
											 Count =0;
											 if(C1CirStandEdgeCount>0){
												 if(C1CirStandPoint!=NULL) delete[] C1CirStandPoint;
												 C1CirStandPoint = new TFPoint[C1CirStandEdgeCount];

												 for(int k=0; k<OrgC1CirStandEdgeCount; k++){
													 if(k>MAX_CIRCLE_EDGEPOINT) break;
													 if(OrgC1CirStandPoint[k].x==0.0f && OrgC1CirStandPoint[k].y==0.0f) continue;
													 C1CirStandPoint[Count].x = OrgC1CirStandPoint[k].x;
													 C1CirStandPoint[Count].y = OrgC1CirStandPoint[k].y;
													 Count++;
												 }
											 }
											 // Circle 원본 데이터 메모리 삭제
											 if(OrgC1CirStandPoint!=NULL) delete[] OrgC1CirStandPoint;
										 }
										 LogUnit.SetLog(L"Circle_1_Insp_End");

										 // Circle 영역 꽃박리, 원형박리 검출 목적 시퀀스(EnCap)
										 // 정식 명칭은 몰라서.....일단 Crack으로 정함 
										 if(!IsMarkBtm && BrokenThresHold!=0){
											 RotateBrokenImg.SetSize(RotateImg.GetWidth(), RotateImg.GetHeight());
											 EasyImage::Oper(EArithmeticLogicOperation_Copy,&RotateImg,&RotateBrokenImg);

											 EasyImage::Threshold(&RotateImg,&RotateBrokenImg,BrokenThresHold);                 //박리 검사 목적 이미지 변환
											 //										 RotateBrokenImg.Save("D:\\ROTATE_IMG\\RotateBrokenImg_CUP.bmp");

											 if(CirFitDiameter1!=0.0f && CircleFit1Center.x!=0.0f && CircleFit1Center.y!=0.0f){ // FAVION Circle Fitting 성공시 박리검사 진행 
												 Circle->GImage = &RotateBrokenImg;                                             //Binary Image 넘겨줌 

												 Circle->SetCenterXY(CircleFit1Center.x,CircleFit1Center.y)      ;
												 Circle->SetTolerance((dEdgeToTrapLineDis/2)-CirOffsetMargin)    ; // Circle Tolerance 
												 Circle->SetDiameter ((CirFitDiameter1-(dEdgeToTrapLineDis/2))*2); // Circle Diameter 
												 Circle->SetCircleChoice(0)                                      ; // 0:From Begin, 1:From End, 2:Largest Amplitude 
												 Circle->SetCircleType  (2)                                      ; // 0:Black to White, 1:White to Black 2: Both Black, White 
												 Circle->SetCircleIndex (0)                                      ; // Circle EdgePoint Index 
												 Circle->OnExecute(true)                                         ;
												 CrackCirDiameter1 = (CirFitDiameter1-(dEdgeToTrapLineDis/2))+((dEdgeToTrapLineDis/2)-CirOffsetMargin);

												 C1CirInCrackCount = Circle->FCirclePointCount;

												 if(C1CirInCrackCount>0){
													 if(C1CirInCrackPoint!=NULL) delete[] C1CirInCrackPoint;
													 C1CirInCrackPoint = new TFPoint[C1CirInCrackCount];

													 for(int k=0; k<C1CirInCrackCount; k++){
														 if(k>MAX_CIRCLE_EDGEPOINT) break;
														 C1CirInCrackPoint[k].x = Circle->FCirclePoint[k].x;
														 C1CirInCrackPoint[k].y = Circle->FCirclePoint[k].y;
													 }
												 }
											 }
										 }
									 }

									 // 두번째 Circle EdgePoint Data 추출 
									 if(C2CirCenter.x!=0 && C2CirCenter.y!=0){
										 LogUnit.SetLog(L"Circle_2_Insp_Start");

										 // 									 if(BtmEdgeThresHold==0) Circle->GImage = &RotateImg      ; //Org Image 넘겨줌 
										 // 									 else                    Circle->GImage = &RotateBinaryImg; //Binary Image 넘겨줌 
										 if(CirGrindInThresHold==0) Circle->GImage = &RotateImg             ; //Org Image 넘겨줌 
										 else                       Circle->GImage = &RotateGrindInBinaryImg; //Binary Image 넘겨줌 

										 if      (FInspectMode==Insp_Track) Circle->SetCenterXY(TrackC2CirCenter.x , TrackC2CirCenter.y); // TrackLine 교차점 기준 센터 
										 else if (FInspectMode==Insp_Mark ) Circle->SetCenterXY(C2CirCenter.x      , C2CirCenter.y     ); // 외곽라인 교차점 기준 센터 

										 // Diameter 계산함(OutCircle과 TrackCircle 중간값 기준)
										 // 									 C2Diameter = (CenterCircleHeight*2);
										 C2Diameter = ((CenterCircleHeight*2)+((CenterCircleHeight-OutToTrackLineDis)*2))/2;
										 // 검사 영역으로 인해서 불량 미검출 발생할수 있음....LTPS와 EnCap분류함
										 if(IsMarkBtm) Circle->SetTolerance(60.0f);
										 else          Circle->SetTolerance(80.0f);
										 // 									 Circle->SetTolerance(40.0f )                      ; // Circle Tolerance 
										 Circle->SetDiameter (C2Diameter)                  ; // Circle Diameter 
										 Circle->SetCircleChoice(1)                        ; // 0:From Begin, 1:From End, 2:Largest Amplitude 
										 Circle->SetCircleType  (2)                        ; // 0:Black to White, 1:White to Black 2: Both Black, White 
										 Circle->SetCircleIndex (1)                        ; // Circle EdgePoint Index 

										 if(CenterCirDeg>=0){
											 CenterCirDeg = (CenterCirDeg==0)? 90:CenterCirDeg;
											 // 										 if(90-CenterCirDeg>=0) Circle->SetAngle    (90-CenterCirDeg+CirAngleMargin);   // Circle Fitting 시작점 각도
											 // 										                        Circle->SetAmplitude(CenterCirDeg-2*CirAngleMargin );  // Circle Fitting 시작점 부터 검사 범위 
											 if(90-CenterCirDeg>=0) Circle->SetAngle    (90-CenterCirDeg);   // Circle Fitting 시작점 각도
											 Circle->SetAmplitude(CenterCirDeg   );  // Circle Fitting 시작점 부터 검사 범위 

										 }
										 // 									 Circle->SetCircleType(1)                          ; // 0:Black to White, 1:White to Black 2: Both Black, White 
										 Circle->OnExecute()                               ;

										 // Circle In Data 기준 새로운 Circle Center 좌표 받아옴 
										 RealC2CirCenter.x = Circle->FCP.x   ;
										 RealC2CirCenter.y = Circle->FCP.y   ;
										 CirDiameter2      = (Circle->Diameter)/2.0;

										 // Circle In Data취합 
										 OrgC2CirInEdgeCount = Circle->FCirclePointCount;
										 if(OrgC2CirInEdgeCount>0){
											 if(OrgC2CirInPoint!=NULL) delete[] OrgC2CirInPoint;
											 OrgC2CirInPoint = new TFPoint[OrgC2CirInEdgeCount];

											 for(int k=0; k<OrgC2CirInEdgeCount; k++){
												 if(k>MAX_CIRCLE_EDGEPOINT) break;
												 OrgC2CirInPoint[k].x = Circle->FCirclePoint[k].x;
												 OrgC2CirInPoint[k].y = Circle->FCirclePoint[k].y;
												 if(OrgC2CirInPoint[k].x==0.0f && OrgC2CirInPoint[k].y==0.0f) C2CirInEdgeCount++;
												 // BTM영역 Circle을 제외한 영역 Defect검사 목적에 좌표계산 
												 // 											 if(k==0) {BtmEdgePoint1.x = C1CirInPoint[k].x; BtmEdgePoint1.y = C1CirInPoint[k].y;}
											 }
										 }

										 // Circle Out Data목적 다시 검사  
										 if(BtmEdgeThresHold==0) Circle->GImage = &RotateImg      ; //Org Image 넘겨줌 
										 else                    Circle->GImage = &RotateBinaryImg; //Binary Image 넘겨줌 

										 // 검사 영역으로 인해서 불량 미검출 발생할수 있음....LTPS와 EnCap분류함
										 if(IsMarkBtm) Circle->SetTolerance(60.0f);
										 else          Circle->SetTolerance(80.0f);
										 // 									Circle->SetTolerance(40.0f )                      ; // Circle Tolerance 
										 Circle->SetDiameter (C2Diameter)                  ; // Circle Diameter 
										 Circle->SetCircleChoice(1)                        ; // 0:From Begin, 1:From End, 2:Largest Amplitude 
										 Circle->SetCircleType  (2)                        ; // 0:Black to White, 1:White to Black 2: Both Black, White 
										 Circle->SetCircleIndex (0)                        ; // Circle EdgePoint Index 
										 Circle->OnExecute()                               ;

										 // Circle Out Data취합 
										 OrgC2CirOutEdgeCount = Circle->FCirclePointCount;
										 if(OrgC2CirOutEdgeCount>0){
											 if(OrgC2CirOutPoint!=NULL) delete[] OrgC2CirOutPoint;
											 OrgC2CirOutPoint = new TFPoint[OrgC2CirOutEdgeCount];

											 for(int k=0; k<OrgC2CirOutEdgeCount; k++){
												 if(k>MAX_CIRCLE_EDGEPOINT) break;
												 OrgC2CirOutPoint[k].x = Circle->FCirclePoint[k].x;
												 OrgC2CirOutPoint[k].y = Circle->FCirclePoint[k].y;
												 // BTM영역 Circle을 제외한 영역 Defect검사 목적에 좌표계산 
												 if(k==(OrgC2CirOutEdgeCount-1)) {BtmEdgePoint[1].x = OrgC2CirOutPoint[k].x; BtmEdgePoint[1].y = OrgC2CirOutPoint[k].y;}
												 if(k==0                       ) {BtmEdgePoint[2].x = OrgC2CirOutPoint[k].x; BtmEdgePoint[2].y = OrgC2CirOutPoint[k].y;}
												 if(OrgC2CirOutPoint[k].x==0.0f && OrgC2CirOutPoint[k].y==0.0f) C2CirOutEdgeCount++;
											 }
										 }
										 // C2Circle Grind_Width, Grind_Measure 
										 // C2Circle 연마량 가공량 검사 시퀀스(TrackMode VS MarkMode)
										 if(FInspectMode==Insp_Track){
											 if(OrgC2CirInEdgeCount==OrgC2CirOutEdgeCount){// 연마량 계산(LTPS, EnCap)
												 double OutDis=0.0f, InDis=0.0f, TotalGrindWidth=0.0f, AvgGrindWidth=0.0f;C2GrindWidthCount=0;
												 for(int k=0; k<OrgC2CirInEdgeCount; k++){
													 if(OrgC2CirOutPoint[k].x==0.0f && OrgC2CirOutPoint[k].y==0.0f){
														 OutDis =0.0f;
													 }
													 else {
														 OutDis = Math.GetLengthFrPointToPoint(C2CirCenter,OrgC2CirOutPoint[k]);
													 }

													 if(OrgC2CirInPoint[k].x==0.0f && OrgC2CirInPoint[k].y==0.0f){
														 InDis =0.0f;
													 }
													 else {
														 InDis = Math.GetLengthFrPointToPoint(C2CirCenter,OrgC2CirInPoint[k]);
													 }

													 if(OutDis!=0.0f && InDis!=0.0f){
														 TotalGrindWidth+=(OutDis - InDis);
														 C2GrindWidthCount++;
													 }
												 }
												 if(C2GrindWidthCount!=0){
													 AvgGrindWidth = (TotalGrindWidth/C2GrindWidthCount);
													 C2CirGrindWd = AvgGrindWidth;
												 }
											 }
											 if(IsMarkBtm){ // LTPS일경우만 가공량 계산 
												 if(CirGrindMeaThresHold!=0){
													 Circle->GImage = &RotateGrindBinaryImg; //Binary Image 넘겨줌 
													 Circle->SetCircleChoice(1)                ; // 0:From Begin, 1:From End, 2:Largest Amplitude 
													 Circle->SetCircleType(2)                  ; // 0:Black to White, 1:White to Black 2: Both Black, White 
													 Circle->SetCircleIndex (1)                ; // Circle EdgePoint Index 
													 Circle->SetTolerance(40.0f )              ; // Circle Tolerance 
													 Circle->SetDiameter (C2Diameter)          ; // Circle Diameter 
													 Circle->OnExecute()                       ;

													 // Circle In Data 기준 새로운 Circle Center 좌표 받아옴 
													 RealC2CirCenter.x = Circle->FCP.x;
													 RealC2CirCenter.y = Circle->FCP.y;

													 OrgC2CirStandEdgeCount = Circle->FCirclePointCount;
													 if(OrgC2CirStandEdgeCount>0){
														 if(OrgC2CirStandPoint!=NULL) delete[] OrgC2CirStandPoint;
														 OrgC2CirStandPoint = new TFPoint[OrgC2CirStandEdgeCount];

														 PreC2CirStandPoint[0].x=0.0f; PreC2CirStandPoint[0].y=0.0f;
														 for(int k=0; k<OrgC2CirStandEdgeCount; k++){
															 if(k>MAX_CIRCLE_EDGEPOINT) break;
															 OrgC2CirStandPoint[k].x = Circle->FCirclePoint[k].x;
															 OrgC2CirStandPoint[k].y = Circle->FCirclePoint[k].y;
															 if(OrgC2CirStandPoint[k].x==0.0f && OrgC2CirStandPoint[k].y==0.0f)C2CirStandEdgeCount++;
															 // TrackLine 자재 상태에 따라서 잘못된 EdgePoint를 찾을경우 대비하여 이전데이터 기준 데이터 복원 
															 if(OrgC2CirStandPoint[k].x!=0.0f && OrgC2CirStandPoint[k].y!=0.0f){
																 // 첫번째는 무조건 데이터 넘겨줌 
																 if(PreC2CirStandPoint[0].x==0.0f && PreC2CirStandPoint[0].y==0.0f){
																	 PreC2CirStandPoint[0].x = OrgC2CirStandPoint[k].x; 
																	 PreC2CirStandPoint[0].y = OrgC2CirStandPoint[k].y; 
																 }
																 else {
																	 if(fabs (OrgC2CirStandPoint[k].x-PreC2CirStandPoint[0].x)>TrackLineMargin ||
																		 fabs(OrgC2CirStandPoint[k].y-PreC2CirStandPoint[0].y)>TrackLineMargin   ){
																			 OrgC2CirStandPoint[k].x = PreC2CirStandPoint[0].x-0.5;
																			 OrgC2CirStandPoint[k].y = PreC2CirStandPoint[0].y+0.5;

																			 PreC2CirStandPoint[0].x = OrgC2CirStandPoint[k].x; 
																			 PreC2CirStandPoint[0].y = OrgC2CirStandPoint[k].y; 
																	 }
																	 else {
																		 PreC2CirStandPoint[0].x = OrgC2CirStandPoint[k].x; 
																		 PreC2CirStandPoint[0].y = OrgC2CirStandPoint[k].y; 
																	 }
																 }
															 }
														 }
														 //C1Circle Grind_Measure Calculate 
														 if(OrgC2CirOutEdgeCount==OrgC2CirStandEdgeCount){
															 double GrindMeaDis=0.0f, TotalGrindMeasure=0.0f, AvgGrindMeasure=0.0f;C2GrindMeasureCount=0;
															 for(int k=0; k<OrgC2CirStandEdgeCount; k++){
																 if(OrgC2CirOutPoint[k].x==0.0f || OrgC2CirOutPoint[k].y==0.0f || OrgC2CirStandPoint[k].x==0.0f || OrgC2CirStandPoint[k].y==0.0f){
																	 GrindMeaDis =0.0f;
																 }
																 else {
																	 GrindMeaDis = Math.GetLengthFrPointToPoint(OrgC2CirStandPoint[k],OrgC2CirOutPoint[k]);
																 }

																 if(GrindMeaDis!=0.0f){
																	 TotalGrindMeasure+= GrindMeaDis;
																	 C2GrindMeasureCount++;
																 }
															 }
															 if(C2GrindMeasureCount!=0){
																 AvgGrindMeasure = (TotalGrindMeasure/C2GrindMeasureCount);
																 C2CirGrindMea= AvgGrindMeasure;
															 }
														 }
														 else if(OrgC2CirStandEdgeCount>OrgC2CirOutEdgeCount) { // 연마가 적게되어 실제 TrackLine보다 EdgePoint데이터가 적을경우 
															 double GrindMeaDis=0.0f, TotalGrindMeasure=0.0f, AvgGrindMeasure=0.0f;C2GrindMeasureCount=0;
															 for(int k=0; k<OrgC2CirOutEdgeCount; k++){
																 if(OrgC2CirOutPoint[k].x==0.0f || OrgC2CirOutPoint[k].y==0.0f || OrgC2CirStandPoint[k].x==0.0f || OrgC2CirStandPoint[k].y==0.0f ){
																	 GrindMeaDis =0.0f;
																 }
																 else {
																	 GrindMeaDis = Math.GetLengthFrPointToPoint(OrgC2CirStandPoint[k],OrgC2CirOutPoint[k]);
																 }

																 if(GrindMeaDis!=0.0f){
																	 TotalGrindMeasure+= GrindMeaDis;
																	 C2GrindMeasureCount++;
																 }
															 }
															 if(C2GrindMeasureCount!=0){
																 AvgGrindMeasure = (TotalGrindMeasure/C2GrindMeasureCount);
																 C2CirGrindMea= AvgGrindMeasure;
															 }
														 }
														 else if(OrgC2CirStandEdgeCount<OrgC2CirOutEdgeCount){
															 double GrindMeaDis=0.0f, TotalGrindMeasure=0.0f, AvgGrindMeasure=0.0f;C2GrindMeasureCount=0;
															 for(int k=0; k<OrgC2CirStandEdgeCount; k++){
																 if(OrgC2CirOutPoint[k].x==0.0f || OrgC2CirOutPoint[k].y==0.0f || OrgC2CirStandPoint[k].x==0.0f || OrgC2CirStandPoint[k].y==0.0f ){
																	 GrindMeaDis =0.0f;
																 }
																 else {
																	 GrindMeaDis = Math.GetLengthFrPointToPoint(OrgC2CirStandPoint[k],OrgC2CirOutPoint[k]);
																 }

																 if(GrindMeaDis!=0.0f){
																	 TotalGrindMeasure+= GrindMeaDis;
																	 C2GrindMeasureCount++;
																 }
															 }
															 if(C2GrindMeasureCount!=0){
																 AvgGrindMeasure = (TotalGrindMeasure/C2GrindMeasureCount);
																 C2CirGrindMea= AvgGrindMeasure;
															 }
														 }
													 }
												 }
											 }
										 }
										 else if(FInspectMode==Insp_Mark){ // MarkMode 
											 if(IsMarkBtm){ // LTPS 가공량 계산 ==> 연마량 계산 
												 if(OrgC2CirOutEdgeCount!=0 && OrgC2CirInEdgeCount!=0){ // 연마량이 존재할경우 가공량 검사를 진행함 
													 // 가공량,연마량 측정 전 데이터 존재시 가상GrindMark 생성한다 
													 if(GrindMarkPoint[5].x!=0.0f && GrindMarkPoint[5].y!=0.0f){
														 GrindMarkPoint[6].x     = GrindMarkPoint[5].x + GrindRectSpec[6].DvX;
														 GrindMarkPoint[6].y     = GrindMarkPoint[5].y - GrindRectSpec[6].DvY;
														 GrindMarkRect [6].left  = GrindMarkPoint[6].x    - GrindMarkRange  ;  
														 GrindMarkRect [6].top   = GrindMarkPoint[6].y    - GrindMarkRange  ;  
														 GrindMarkRect [6].right = GrindMarkRect [6].left + GrindMarkLength ;  
														 GrindMarkRect [6].bottom= GrindMarkRect [6].top  + GrindMarkLength ;  
													 }

													 // GrindMarkPoint5 Calc 진행함(연마량,가공량)
													 if(GrindMarkPoint[5].x!=0.0f && GrindMarkPoint[5].y!=0.0f){
														 GrindMeaDis =0.0f, MinDis =10000.0f;C2GrindMarkCount=0;
														 for(int k=0; k<OrgC2CirOutEdgeCount; k++){
															 if(OrgC2CirOutPoint[k].x==0.0f || OrgC2CirOutPoint[k].y==0.0f) continue;
															 if(GrindMarkPoint[5].x  ==0.0f || GrindMarkPoint[5].y  ==0.0f) continue;

															 GrindMeaDis = Math.GetLength(GrindMarkPoint[5], OrgC2CirOutPoint[k]);
															 if(GrindMeaDis<MinDis){
																 MinDis = GrindMeaDis;
																 C2GrindMarkCount = k;
															 }
														 }
														 // GrindMark기준 수직 포인트 주변값 Avg산출한다 
														 if(C2GrindMarkCount!=0 && C2GrindMarkCount>5){
															 CircleCount=0,TotalCirDis=0.0f,GrindMeaDis=0.0f;
															 for(int k=C2GrindMarkCount-5; k<C2GrindMarkCount+5; k++){
																 if(OrgC2CirOutPoint[k].x==0.0f || OrgC2CirOutPoint[k].y==0.0f) continue;

																 GrindMeaDis = Math.GetLength(GrindMarkPoint[5], OrgC2CirOutPoint[k]);
																 TotalCirDis+= GrindMeaDis;
																 CircleCount++;
															 }
															 if(TotalCirDis!=0.0f && CircleCount!=0){
																 C2CirGrindMea = TotalCirDis/CircleCount;
															 }
														 }
														 // GrindMark기준 수직 평균값 연마량 측정 
														 if(C2GrindMarkCount!=0 && C2GrindMarkCount>5){
															 CircleCount=0,TotalCirDis=0.0f,GrindWidthDis=0.0f;
															 for(int k=C2GrindMarkCount-5; k<C2GrindMarkCount+5; k++){
																 if(OrgC2CirOutPoint[k].x==0.0f && OrgC2CirOutPoint[k].y==0.0f) continue;
																 if(OrgC2CirInPoint [k].x==0.0f && OrgC2CirInPoint [k].y==0.0f) continue;
																 GrindWidthDis = Math.GetLength(OrgC2CirInPoint[k], OrgC2CirOutPoint[k]);
																 TotalCirDis+=   GrindWidthDis;
																 CircleCount++;
															 }
															 if(TotalCirDis!=0.0f && CircleCount!=0){
																 C2CirGrindWd = TotalCirDis/CircleCount;
															 }
														 }
													 }
													 else { // Grind Mark 못 찾았을경우 (가공량 0, 연마량 계산함)
														 GrindMeaDis =0.0f, MinDis =10000.0f;C2GrindMarkCount=0;
														 for(int k=0; k<OrgC2CirOutEdgeCount; k++){
															 if(OrgC2CirOutPoint[k].x==0.0f || OrgC2CirOutPoint[k].y==0.0f) continue;

															 GrindMarkRectCenter[5].x = GrindMarkRect[5].left + (GrindMarkRect[5].right  - GrindMarkRect[5].left)/2; 
															 GrindMarkRectCenter[5].y = GrindMarkRect[5].top  + (GrindMarkRect[5].bottom - GrindMarkRect[5].top )/2; 

															 GrindMeaDis = Math.GetLength(GrindMarkRectCenter[5], OrgC2CirOutPoint[k]);
															 if(GrindMeaDis<MinDis){
																 MinDis = GrindMeaDis;
																 C2GrindMarkCount = k;
															 }
														 }
														 // GrindMark기준 수직 평균값 연마량 측정 
														 if(C2GrindMarkCount!=0 && C2GrindMarkCount>5){
															 CircleCount=0,TotalCirDis=0.0f,GrindWidthDis=0.0f;
															 for(int k=C2GrindMarkCount-5; k<C2GrindMarkCount+5; k++){
																 if(OrgC2CirOutPoint[k].x==0.0f && OrgC2CirOutPoint[k].y==0.0f) continue;
																 if(OrgC2CirInPoint [k].x==0.0f && OrgC2CirInPoint [k].y==0.0f) continue;
																 GrindWidthDis = Math.GetLength(OrgC2CirInPoint[k], OrgC2CirOutPoint[k]);
																 TotalCirDis+=   GrindWidthDis;
																 CircleCount++;
															 }
															 if(TotalCirDis!=0.0f && CircleCount!=0){
																 C2CirGrindWd = TotalCirDis/CircleCount;
															 }
														 }
													 }

													 // GrindMarkPoint6 Calc 진행함(연마량,가공량)
													 if(GrindMarkPoint[6].x!=0.0f && GrindMarkPoint[6].y!=0.0f){
														 GrindMeaDis =0.0f, MinDis =10000.0f;C2GrindMarkCount=0;
														 for(int k=0; k<OrgC2CirOutEdgeCount; k++){
															 if(OrgC2CirOutPoint[k].x==0.0f || OrgC2CirOutPoint[k].y==0.0f) continue;
															 if(GrindMarkPoint[6].x  ==0.0f || GrindMarkPoint[6].y  ==0.0f) continue;

															 GrindMeaDis = Math.GetLength(GrindMarkPoint[6], OrgC2CirOutPoint[k]);
															 if(GrindMeaDis<MinDis){
																 MinDis = GrindMeaDis;
																 C2GrindMarkCount = k;
															 }
														 }
														 // GrindMark기준 수직 포인트 주변값 Avg산출한다 
														 if(C2GrindMarkCount!=0 && C2GrindMarkCount>5 && (C2GrindMarkCount+5)<OrgC2CirOutEdgeCount){
															 CircleCount=0,TotalCirDis=0.0f,GrindMeaDis=0.0f;
															 for(int k=C2GrindMarkCount-5; k<C2GrindMarkCount+5; k++){
																 if(OrgC2CirOutPoint[k].x==0.0f || OrgC2CirOutPoint[k].y==0.0f) continue;

																 GrindMeaDis = Math.GetLength(GrindMarkPoint[6], OrgC2CirOutPoint[k]);
																 TotalCirDis+= GrindMeaDis;
																 CircleCount++;
															 }
															 if(TotalCirDis!=0.0f && CircleCount!=0){
																 TrenchLeftGrindMea = TotalCirDis/CircleCount;
															 }
														 }
														 // GrindMark기준 수직 평균값 연마량 측정 
														 if(C2GrindMarkCount!=0 && C2GrindMarkCount>5 && (C2GrindMarkCount+5)<OrgC2CirOutEdgeCount){
															 CircleCount=0,TotalCirDis=0.0f,GrindWidthDis=0.0f;
															 for(int k=C2GrindMarkCount-5; k<C2GrindMarkCount+5; k++){
																 if(OrgC2CirOutPoint[k].x==0.0f && OrgC2CirOutPoint[k].y==0.0f) continue;
																 if(OrgC2CirInPoint [k].x==0.0f && OrgC2CirInPoint [k].y==0.0f) continue;
																 GrindWidthDis = Math.GetLength(OrgC2CirInPoint[k], OrgC2CirOutPoint[k]);
																 TotalCirDis+=   GrindWidthDis;
																 CircleCount++;
															 }
															 if(TotalCirDis!=0.0f && CircleCount!=0){
																 TrenchLeftGrindWd = TotalCirDis/CircleCount;
															 }
														 }
													 }
													 else { // Grind Mark 못 찾았을경우 (가공량 0, 연마량 계산함)
														 GrindMeaDis =0.0f, MinDis =10000.0f;C2GrindMarkCount=0;
														 for(int k=0; k<OrgC2CirOutEdgeCount; k++){
															 if(OrgC2CirOutPoint[k].x==0.0f || OrgC2CirOutPoint[k].y==0.0f) continue;

															 if(k==0){
															     GrindMarkRectCenter[6].x     =  GrindMarkRectCenter[5].x + GrindRectSpec[6].DvX;
																 GrindMarkRectCenter[6].y     =  GrindMarkRectCenter[5].y - GrindRectSpec[6].DvY;

																 GrindMarkRect [6].left  = GrindMarkRectCenter[6].x  - GrindMarkRange  ;  
																 GrindMarkRect [6].top   = GrindMarkRectCenter[6].y  - GrindMarkRange  ;  
																 GrindMarkRect [6].right = GrindMarkRect [6].left + GrindMarkLength ;  
																 GrindMarkRect [6].bottom= GrindMarkRect [6].top  + GrindMarkLength ;  
															 }

															 // 														GrindMarkRectPoint2.x = GrindMarkRect[6].left + (GrindMarkRect[6].right  - GrindMarkRect[6].left)/2; 
															 // 														GrindMarkRectPoint2.y = GrindMarkRect[6].top  + (GrindMarkRect[6].bottom - GrindMarkRect[6].top )/2; 

															 GrindMeaDis = Math.GetLength(GrindMarkRectCenter[6], OrgC2CirOutPoint[k]);
															 if(GrindMeaDis<MinDis){
																 MinDis = GrindMeaDis;
																 C2GrindMarkCount = k;
															 }
														 }
														 // GrindMark기준 수직 평균값 연마량 측정 
														 if(C2GrindMarkCount!=0 && C2GrindMarkCount>5 && (C2GrindMarkCount+5)<OrgC2CirOutEdgeCount){
															 CircleCount=0,TotalCirDis=0.0f,GrindWidthDis=0.0f;
															 for(int k=C2GrindMarkCount-5; k<C2GrindMarkCount+5; k++){
																 if(OrgC2CirOutPoint[k].x==0.0f && OrgC2CirOutPoint[k].y==0.0f) continue;
																 if(OrgC2CirInPoint [k].x==0.0f && OrgC2CirInPoint [k].y==0.0f) continue;
																 GrindWidthDis = Math.GetLength(OrgC2CirInPoint[k], OrgC2CirOutPoint[k]);
																 TotalCirDis+=   GrindWidthDis;
																 CircleCount++;
															 }
															 if(TotalCirDis!=0.0f && CircleCount!=0){
																 TrenchLeftGrindWd = TotalCirDis/CircleCount;
															 }
														 }
													 }
												 }
											 }
											 else         { // EnCap 연마량만 계산 
												 if(OrgC2CirInEdgeCount==OrgC2CirOutEdgeCount){
													 double OutDis=0.0f, InDis=0.0f, TotalGrindWidth=0.0f, AvgGrindWidth=0.0f;C2GrindWidthCount=0;
													 for(int k=0; k<OrgC2CirInEdgeCount; k++){
														 if(OrgC2CirOutPoint[k].x==0.0f && OrgC2CirOutPoint[k].y==0.0f){
															 OutDis =0.0f;
														 }
														 else {
															 OutDis = Math.GetLengthFrPointToPoint(C2CirCenter,OrgC2CirOutPoint[k]);
														 }

														 if(OrgC2CirInPoint[k].x==0.0f && OrgC2CirInPoint[k].y==0.0f){
															 InDis =0.0f;
														 }
														 else {
															 InDis = Math.GetLengthFrPointToPoint(C2CirCenter,OrgC2CirInPoint[k]);
														 }

														 if(OutDis!=0.0f && InDis!=0.0f){
															 TotalGrindWidth+=(OutDis - InDis);
															 C2GrindWidthCount++;
														 }
													 }
													 if(C2GrindWidthCount!=0){
														 AvgGrindWidth = (TotalGrindWidth/C2GrindWidthCount);
														 C2CirGrindWd = AvgGrindWidth;
													 }
												 }
											 }
										 }

										 // Org Circle데이터중 유호하지 않은 값을 제외한 실제 존재하는 데이터 기준으로 동적 메모리 생성함
										 // Circle Defect검사에 필요한 Edge데이터 값
										 int Count=0;
										 if(OrgC2CirInEdgeCount>0){
											 C2CirInEdgeCount = OrgC2CirInEdgeCount - C2CirInEdgeCount;
											 // 										C2CirInEdgeCount = OrgC2CirInEdgeCount;
											 if(C2CirInEdgeCount>0){
												 if(C2CirInPoint!=NULL) delete[] C2CirInPoint;
												 C2CirInPoint = new TFPoint[C2CirInEdgeCount];

												 for(int k=0; k<OrgC2CirInEdgeCount; k++){
													 if(k>MAX_CIRCLE_EDGEPOINT) break;
													 if(OrgC2CirInPoint[k].x==0.0f && OrgC2CirInPoint[k].y==0.0f) continue;
													 C2CirInPoint[Count].x = OrgC2CirInPoint[k].x;
													 C2CirInPoint[Count].y = OrgC2CirInPoint[k].y;
													 Count++;
												 }
											 }
											 // Circle 원본 데이터 메모리 삭제
											 if(OrgC2CirInPoint!=NULL) delete[] OrgC2CirInPoint;
										 }
										 // Circle Fitting 결과물 
										 SampleSize = C2CirInEdgeCount*0.75; //0.5~0.8이하로 입력할것
										 DistDevRatio = 0.15; //0.1~0.25 이하로 입력할것
										 // 									Radius = 0;
										 CircleFit->OnRansac(C2CirInPoint,C2CirInEdgeCount,SampleSize,DistDevRatio,&CircleFit2Center,&CirFitDiameter2);

										 if(OrgC2CirOutEdgeCount>0){
											 C2CirOutEdgeCount = OrgC2CirOutEdgeCount - C2CirOutEdgeCount;
											 Count =0;
											 if(C2CirOutEdgeCount>0){
												 if(C2CirOutPoint!=NULL) delete[] C2CirOutPoint;
												 C2CirOutPoint = new TFPoint[C2CirOutEdgeCount];

												 for(int k=0; k<OrgC2CirOutEdgeCount; k++){
													 if(k>MAX_CIRCLE_EDGEPOINT) break;
													 if(OrgC2CirOutPoint[k].x==0.0f && OrgC2CirOutPoint[k].y==0.0f) continue;
													 C2CirOutPoint[Count].x = OrgC2CirOutPoint[k].x;
													 C2CirOutPoint[Count].y = OrgC2CirOutPoint[k].y;
													 Count++;
												 }
											 }
											 // Circle 원본 데이터 메모리 삭제
											 if(OrgC2CirOutPoint!=NULL) delete[] OrgC2CirOutPoint;
										 }
										 if(OrgC2CirStandEdgeCount>0){
											 C2CirStandEdgeCount = OrgC2CirStandEdgeCount - C2CirStandEdgeCount;
											 // 										C2CirStandEdgeCount = OrgC2CirStandEdgeCount;
											 Count =0;
											 if(C2CirStandEdgeCount>0){
												 if(C2CirStandPoint!=NULL) delete[] C2CirStandPoint;
												 C2CirStandPoint = new TFPoint[C2CirStandEdgeCount];

												 for(int k=0; k<OrgC2CirStandEdgeCount; k++){
													 if(k>MAX_CIRCLE_EDGEPOINT) break;
													 if(OrgC2CirStandPoint[k].x==0.0f && OrgC2CirStandPoint[k].y==0.0f) continue;
													 C2CirStandPoint[Count].x = OrgC2CirStandPoint[k].x;
													 C2CirStandPoint[Count].y = OrgC2CirStandPoint[k].y;
													 Count++;
												 }
											 }
											 // Circle 원본 데이터 메모리 삭제
											 if(OrgC2CirStandPoint!=NULL) delete[] OrgC2CirStandPoint;
										 }
										 LogUnit.SetLog(L"Circle_2_Insp_End");

										 // Circle 영역 꽃박리, 원형박리 검출 목적 시퀀스(EnCap)
										 // 정식 명칭은 몰라서.....일단 Crack으로 정함 
										 if(!IsMarkBtm && BrokenThresHold!=0){
											 if(CirFitDiameter2!=0.0f && CircleFit2Center.x!=0.0f && CircleFit2Center.y!=0.0f){ // FAVION Circle Fitting 성공시 박리검사 진행 
												 Circle->GImage = &RotateBrokenImg;                                             //Binary Image 넘겨줌 

												 Circle->SetCenterXY(CircleFit2Center.x,CircleFit2Center.y);
												 Circle->SetTolerance((dEdgeToTrapLineDis/2)-CirOffsetMargin)    ; // Circle Tolerance 
												 Circle->SetDiameter ((CirFitDiameter2-(dEdgeToTrapLineDis/2))*2); // Circle Diameter 
												 Circle->SetCircleChoice(0)                                      ; // 0:From Begin, 1:From End, 2:Largest Amplitude 
												 Circle->SetCircleType  (2)                                      ; // 0:Black to White, 1:White to Black 2: Both Black, White 
												 Circle->SetCircleIndex (0)                                      ; // Circle EdgePoint Index 
												 Circle->OnExecute(true)                                         ;
												 CrackCirDiameter2 = (CirFitDiameter2-(dEdgeToTrapLineDis/2))+((dEdgeToTrapLineDis/2)-CirOffsetMargin);

												 C2CirInCrackCount = Circle->FCirclePointCount;

												 if(C2CirInCrackCount>0){
													 if(C2CirInCrackPoint!=NULL) delete[] C2CirInCrackPoint;
													 C2CirInCrackPoint = new TFPoint[C2CirInCrackCount];

													 for(int k=0; k<C2CirInCrackCount; k++){
														 if(k>MAX_CIRCLE_EDGEPOINT) break;
														 C2CirInCrackPoint[k].x = Circle->FCirclePoint[k].x;
														 C2CirInCrackPoint[k].y = Circle->FCirclePoint[k].y;
													 }
												 }
											 }
										 }
									 }

									 // 세번째 Circle EdgePoint Data 추출 
									 if(C3CirCenter.x!=0 && C3CirCenter.y!=0){
										 LogUnit.SetLog(L"Circle_3_Insp_Start");

										 if(BtmEdgeThresHold==0) Circle->GImage = &RotateImg      ; //Org Image 넘겨줌 
										 else                    Circle->GImage = &RotateBinaryImg; //Binary Image 넘겨줌 

										 if      (FInspectMode==Insp_Track) Circle->SetCenterXY(TrackC3CirCenter.x , TrackC3CirCenter.y); // TrackLine 교차점 기준 센터 
										 else if (FInspectMode==Insp_Mark ) Circle->SetCenterXY(C3CirCenter.x      , C3CirCenter.y     ); // 외곽라인 교차점 기준 센터 
										 // Diameter 계산함(OutCircle과 TrackCircle 중간값 기준)
										 C3Diameter = ((CenterCircleHeight*2)+((CenterCircleHeight+OutToTrackLineDis)*2))/2;
										 // 									 C3Diameter = (CenterCircleHeight*2);
										 if(IsMarkBtm) Circle->SetTolerance(60.0f);
										 else          Circle->SetTolerance(80.0f);
										 // 									 Circle->SetTolerance(60.0f )              ; // Circle Tolerance 
										 Circle->SetDiameter (C3Diameter)          ; // Circle Diameter 
										 Circle->SetCircleChoice(0)                ; // 0:From Begin, 1:From End, 2:Largest Amplitude 
										 Circle->SetCircleIndex (0)                ; // Circle EdgePoint Index 
										 if(CenterCirDeg>=0){
											 CenterCirDeg = (CenterCirDeg==0)? 90:CenterCirDeg;
											 // 										 if(270-CenterCirDeg>=0) Circle->SetAngle(270-CenterCirDeg+CirAngleMargin);   // Circle Fitting 시작점 각도
											 // 										                         Circle->SetAmplitude(CenterCirDeg-2*CirAngleMargin);  // Circle Fitting 시작점 부터 검사 범위 
											 if(270-CenterCirDeg>=0) Circle->SetAngle(270-CenterCirDeg);   // Circle Fitting 시작점 각도
											 Circle->SetAmplitude(CenterCirDeg);  // Circle Fitting 시작점 부터 검사 범위 
										 }
										 Circle->SetCircleType(1)                          ; // 0:Black to White, 1:White to Black 2: Both Black, White 
										 Circle->OnExecute()                               ;

										 // Circle Out Data취합 
										 OrgC3CirOutEdgeCount = Circle->FCirclePointCount;
										 if(OrgC3CirOutEdgeCount>0){
											 if(OrgC3CirOutPoint!=NULL) delete[] OrgC3CirOutPoint;
											 OrgC3CirOutPoint = new TFPoint[OrgC3CirOutEdgeCount];

											 for(int k=0; k<OrgC3CirOutEdgeCount; k++){
												 if(k>MAX_CIRCLE_EDGEPOINT) break;
												 OrgC3CirOutPoint[k].x = Circle->FCirclePoint[k].x;
												 OrgC3CirOutPoint[k].y = Circle->FCirclePoint[k].y;

												 // BTM영역 Circle을 제외한 영역 Defect검사 목적에 좌표계산
												 // Circle2에서 TrenchWidth 가로길이 기준점을 찾지 못할경우 Circle3에서 새로운 좌표를 넘겨준다 
												 if(k==0 && (BtmEdgePoint[2].x==0 || BtmEdgePoint[2].y==0)){BtmEdgePoint[2].x = OrgC3CirOutPoint[k].x; BtmEdgePoint[2].y = OrgC3CirOutPoint[k].y;}
												 if(k==(OrgC3CirOutEdgeCount-1))                           {BtmEdgePoint[4].x = OrgC3CirOutPoint[k].x; BtmEdgePoint[4].y = OrgC3CirOutPoint[k].y;}
												 if(OrgC3CirOutPoint[k].x==0.0f && OrgC3CirOutPoint[k].y==0.0f) C3CirOutEdgeCount++;
											 }
										 }

										 // Circle In Data목적 다시 검사  
										 // Cell외곽에서 안쪽으로 들어가면서 Circle 찾을경우 오버킬 발생빈도 높음
										 if(CirGrindInThresHold==0) Circle->GImage = &RotateImg             ; //Org Image 넘겨줌 
										 else                       Circle->GImage = &RotateGrindInBinaryImg; //Binary Image 넘겨줌 
										 // 									if(BtmEdgeThresHold==0) Circle->GImage = &RotateImg      ; //Org Image 넘겨줌 
										 // 									else                    Circle->GImage = &RotateBinaryImg; //Binary Image 넘겨줌 

										 if(IsMarkBtm) Circle->SetTolerance(60.0f);
										 else          Circle->SetTolerance(80.0f);
										 // 									Circle->SetTolerance(60.0f )      ; // Circle Tolerance 
										 Circle->SetDiameter (C3Diameter)  ; // Circle Diameter 
										 Circle->SetCircleChoice(0)        ; // 0:From Begin, 1:From End, 2:Largest Amplitude 
										 Circle->SetCircleIndex (0)        ; // Circle EdgePoint Index 
										 Circle->SetCircleType(0)          ; // 0:Black to White, 1:White to Black 2: Both Black, White 
										 Circle->OnExecute()               ;

										 // Circle In Data 기준 새로운 Circle Center 좌표 받아옴 
										 RealC3CirCenter.x = Circle->FCP.x;
										 RealC3CirCenter.y = Circle->FCP.y;
										 CirDiameter3      = (Circle->Diameter)/2.0;

										 // Circle In Data취합 
										 OrgC3CirInEdgeCount = Circle->FCirclePointCount;
										 if(OrgC3CirInEdgeCount>0){
											 if(OrgC3CirInPoint!=NULL) delete[] OrgC3CirInPoint;
											 OrgC3CirInPoint = new TFPoint[OrgC3CirInEdgeCount];

											 for(int k=0; k<OrgC3CirInEdgeCount; k++){
												 if(k>MAX_CIRCLE_EDGEPOINT) break;
												 OrgC3CirInPoint[k].x = Circle->FCirclePoint[k].x;
												 OrgC3CirInPoint[k].y = Circle->FCirclePoint[k].y;
												 if(OrgC3CirInPoint[k].x==0.0f && OrgC3CirInPoint[k].y==0.0f) C3CirInEdgeCount++;
											 }
										 }

										 // C3Circle Grind_Width, Grind_Measure 
										 // C3Circle 연마량 가공량 검사 시퀀스 시작(TrackMode VS MarkMode)
										 if(FInspectMode==Insp_Track){
											 if(OrgC3CirInEdgeCount==OrgC3CirOutEdgeCount){// 연마량 계산
												 double OutDis=0.0f, InDis=0.0f, TotalGrindWidth=0.0f, AvgGrindWidth=0.0f;C3GrindWidthCount=0;
												 for(int k=0; k<OrgC3CirInEdgeCount; k++){
													 if(OrgC3CirOutPoint[k].x==0.0f && OrgC3CirOutPoint[k].y==0.0f){
														 OutDis =0.0f;
													 }
													 else {
														 OutDis = Math.GetLengthFrPointToPoint(C3CirCenter,OrgC3CirOutPoint[k]);
													 }

													 if(OrgC3CirInPoint[k].x==0.0f && OrgC3CirInPoint[k].y==0.0f){
														 InDis =0.0f;
													 }
													 else {
														 InDis = Math.GetLengthFrPointToPoint(C3CirCenter,OrgC3CirInPoint[k]);
													 }

													 if(OutDis!=0.0f && InDis!=0.0f){
														 TotalGrindWidth+=(InDis - OutDis);
														 C3GrindWidthCount++;
													 }
												 }
												 if(C3GrindWidthCount!=0){
													 AvgGrindWidth = (TotalGrindWidth/C3GrindWidthCount);
													 C3CirGrindWd = AvgGrindWidth;
												 }
											 }
											 if(IsMarkBtm){ // LTPS일경우만 가공량 계산 
												 if(CirGrindMeaThresHold!=0){
													 Circle->GImage = &RotateGrindBinaryImg; //Binary Image 넘겨줌 
													 Circle->SetTolerance(40.0f )          ; // Circle Tolerance 
													 Circle->SetDiameter (C3Diameter)      ; // Circle Diameter 
													 Circle->SetCircleType(1)              ; // 0:Black to White, 1:White to Black 2: Both Black, White 
													 Circle->OnExecute()                   ;

													 // Circle In Data 기준 새로운 Circle Center 좌표 받아옴 
													 RealC3CirCenter.x = Circle->FCP.x;
													 RealC3CirCenter.y = Circle->FCP.y;

													 OrgC3CirStandEdgeCount = Circle->FCirclePointCount;
													 if(OrgC3CirStandEdgeCount>0){
														 if(OrgC3CirStandPoint!=NULL) delete[] OrgC3CirStandPoint;
														 OrgC3CirStandPoint = new TFPoint[OrgC3CirStandEdgeCount];

														 PreC3CirStandPoint[0].x=0.0f; PreC3CirStandPoint[0].y=0.0f;
														 for(int k=0; k<OrgC3CirStandEdgeCount; k++){
															 if(k>MAX_CIRCLE_EDGEPOINT) break;
															 OrgC3CirStandPoint[k].x = Circle->FCirclePoint[k].x;
															 OrgC3CirStandPoint[k].y = Circle->FCirclePoint[k].y;
															 if(OrgC3CirStandPoint[k].x==0.0f && OrgC3CirStandPoint[k].y==0.0f)C3CirStandEdgeCount++;
															 // TrackLine 자재 상태에 따라서 잘못된 EdgePoint를 찾을경우 대비하여 이전데이터 기준 데이터 복원 
															 if(OrgC3CirStandPoint[k].x!=0.0f && OrgC3CirStandPoint[k].y!=0.0f){
																 // 첫번째는 무조건 데이터 넘겨줌 
																 if(PreC3CirStandPoint[0].x==0.0f && PreC3CirStandPoint[0].y==0.0f){
																	 PreC3CirStandPoint[0].x = OrgC3CirStandPoint[k].x; 
																	 PreC3CirStandPoint[0].y = OrgC3CirStandPoint[k].y; 
																 }
																 else {
																	 if(fabs (OrgC3CirStandPoint[k].x-PreC3CirStandPoint[0].x)>TrackLineMargin ||
																		 fabs(OrgC3CirStandPoint[k].y-PreC3CirStandPoint[0].y)>TrackLineMargin   ){
																			 OrgC3CirStandPoint[k].x = PreC3CirStandPoint[0].x+0.5;
																			 OrgC3CirStandPoint[k].y = PreC3CirStandPoint[0].y-0.5;

																			 PreC3CirStandPoint[0].x = OrgC3CirStandPoint[k].x; 
																			 PreC3CirStandPoint[0].y = OrgC3CirStandPoint[k].y; 
																	 }
																	 else {
																		 PreC3CirStandPoint[0].x = OrgC3CirStandPoint[k].x; 
																		 PreC3CirStandPoint[0].y = OrgC3CirStandPoint[k].y; 
																	 }
																 }
															 }
														 }
														 //C1Circle Grind_Measure Calculate 
														 if(OrgC3CirOutEdgeCount==OrgC3CirStandEdgeCount){
															 double GrindMeaDis=0.0f, TotalGrindMeasure=0.0f, AvgGrindMeasure=0.0f; C3GrindMeasureCount=0;
															 for(int k=0; k<OrgC3CirInEdgeCount; k++){
																 if(OrgC3CirOutPoint[k].x==0.0f || OrgC3CirOutPoint[k].y==0.0f || OrgC3CirStandPoint[k].x==0.0f || OrgC3CirStandPoint[k].y==0.0f){
																	 GrindMeaDis =0.0f;
																 }
																 else {
																	 GrindMeaDis = Math.GetLengthFrPointToPoint(OrgC3CirStandPoint[k],OrgC3CirOutPoint[k]);
																 }

																 if(GrindMeaDis!=0.0f){
																	 TotalGrindMeasure+= GrindMeaDis;
																	 C3GrindMeasureCount++;
																 }
															 }
															 if(C3GrindMeasureCount!=0){
																 AvgGrindMeasure = (TotalGrindMeasure/C3GrindMeasureCount);
																 C3CirGrindMea= AvgGrindMeasure;
															 }
														 }
														 else if(OrgC3CirStandEdgeCount>OrgC3CirOutEdgeCount) { // 연마가 적게되어 실제 TrackLine보다 EdgePoint데이터가 적을경우 
															 double GrindMeaDis=0.0f, TotalGrindMeasure=0.0f, AvgGrindMeasure=0.0f;C3GrindMeasureCount=0;
															 for(int k=0; k<OrgC3CirOutEdgeCount; k++){
																 if(OrgC3CirOutPoint[k].x==0.0f || OrgC3CirOutPoint[k].y==0.0f || OrgC3CirStandPoint[k].x==0.0f || OrgC3CirStandPoint[k].y==0.0f ){
																	 GrindMeaDis =0.0f;
																 }
																 else {
																	 GrindMeaDis = Math.GetLengthFrPointToPoint(OrgC3CirStandPoint[k],OrgC3CirOutPoint[k]);
																 }

																 if(GrindMeaDis!=0.0f){
																	 TotalGrindMeasure+= GrindMeaDis;
																	 C3GrindMeasureCount++;
																 }
															 }
															 if(C3GrindMeasureCount!=0){
																 AvgGrindMeasure = (TotalGrindMeasure/C3GrindMeasureCount);
																 C3CirGrindMea= AvgGrindMeasure;
															 }
														 }
														 else if(OrgC3CirStandEdgeCount<OrgC3CirOutEdgeCount){
															 double GrindMeaDis=0.0f, TotalGrindMeasure=0.0f, AvgGrindMeasure=0.0f;C3GrindMeasureCount=0;
															 for(int k=0; k<OrgC3CirStandEdgeCount; k++){
																 if(OrgC3CirOutPoint[k].x==0.0f || OrgC3CirOutPoint[k].y==0.0f || OrgC3CirStandPoint[k].x==0.0f || OrgC3CirStandPoint[k].y==0.0f ){
																	 GrindMeaDis =0.0f;
																 }
																 else {
																	 GrindMeaDis = Math.GetLengthFrPointToPoint(OrgC3CirStandPoint[k],OrgC3CirOutPoint[k]);
																 }

																 if(GrindMeaDis!=0.0f){
																	 TotalGrindMeasure+= GrindMeaDis;
																	 C3GrindMeasureCount++;
																 }
															 }
															 if(C3GrindMeasureCount!=0){
																 AvgGrindMeasure = (TotalGrindMeasure/C3GrindMeasureCount);
																 C3CirGrindMea= AvgGrindMeasure;
															 }
														 }
													 }
												 }
											 }
										 }
										 else if(FInspectMode==Insp_Mark){ // MarkMode 시퀀스 
											 if(IsMarkBtm){ // LTPS 가공량계산 ==> 연마량 계산 
												 if(OrgC3CirOutEdgeCount!=0 && OrgC3CirInEdgeCount!=0){ // 연마량이 존재할경우 가공량 검사를 진행함 
													 GrindMeaDis =0.0f, MinDis =10000.0f; C3GrindMarkCount=0;
													 if(GrindMarkPoint[7].x!=0.0f && GrindMarkPoint[7].y!=0.0f){
														 for(int k=0; k<OrgC3CirOutEdgeCount; k++){
															 if(OrgC3CirOutPoint[k].x==0.0f || OrgC3CirOutPoint[k].y==0.0f) continue;
															 if(GrindMarkPoint[7].x  ==0.0f || GrindMarkPoint[7].y  ==0.0f) continue;

															 GrindMeaDis = Math.GetLength(GrindMarkPoint[7], OrgC3CirOutPoint[k]);
															 if(GrindMeaDis<MinDis){
																 MinDis = GrindMeaDis;
																 C3GrindMarkCount = k;
															 }
														 }
														 // GrindMark기준 수직 포인트 주변값 Avg산출한다 
														 if(C3GrindMarkCount!=0 && C3GrindMarkCount>5){
															 CircleCount=0,TotalCirDis=0.0f,GrindMeaDis=0.0f;
															 for(int k=C3GrindMarkCount-5; k<C3GrindMarkCount+5; k++){
																 if(OrgC3CirOutPoint[k].x==0.0f || OrgC3CirOutPoint[k].y==0.0f) continue;

																 GrindMeaDis = Math.GetLength(GrindMarkPoint[7], OrgC3CirOutPoint[k]);
																 TotalCirDis+= GrindMeaDis;
																 CircleCount++;
															 }
															 if(TotalCirDis!=0.0f && CircleCount!=0){
																 C3CirGrindMea = TotalCirDis/CircleCount;
															 }
														 }
														 // GrindMark기준 수직 평균값 연마량 측정 
														 if(C3GrindMarkCount!=0 && C3GrindMarkCount>5){
															 CircleCount=0,TotalCirDis=0.0f,GrindWidthDis=0.0f;
															 for(int k=C3GrindMarkCount-5; k<C3GrindMarkCount+5; k++){
																 if(OrgC3CirInPoint [k].x==0.0f && OrgC3CirInPoint [k].y==0.0f) continue;
																 GrindWidthDis = Math.GetLength(OrgC3CirInPoint[k], OrgC3CirOutPoint[k]);
																 TotalCirDis+=   GrindWidthDis;
																 CircleCount++;
															 }
															 if(TotalCirDis!=0.0f && CircleCount!=0){
																 C3CirGrindWd = TotalCirDis/CircleCount;
															 }
														 }
													 }
													 else { // Grind Mark 못 찾았을경우 (가공량 0, 연마량 계산함)
														 for(int k=0; k<OrgC3CirOutEdgeCount; k++){
															 if(OrgC3CirOutPoint[k].x==0.0f || OrgC3CirOutPoint[k].y==0.0f) continue;

															 GrindMarkRectCenter[7].x = GrindMarkRect[7].left + (GrindMarkRect[7].right  - GrindMarkRect[7].left)/2; 
															 GrindMarkRectCenter[7].y = GrindMarkRect[7].top  + (GrindMarkRect[7].bottom - GrindMarkRect[7].top )/2; 

															 GrindMeaDis = Math.GetLength(GrindMarkRectCenter[7], OrgC3CirOutPoint[k]);
															 if(GrindMeaDis<MinDis){
																 MinDis = GrindMeaDis;
																 C3GrindMarkCount = k;
															 }
														 }
														 // GrindMark기준 수직 평균값 연마량 측정 
														 if(C3GrindMarkCount!=0 && C3GrindMarkCount>5){
															 CircleCount=0,TotalCirDis=0.0f,GrindWidthDis=0.0f;
															 for(int k=C3GrindMarkCount-5; k<C3GrindMarkCount+5; k++){
																 if(OrgC3CirOutPoint[k].x==0.0f && OrgC3CirOutPoint[k].y==0.0f) continue;
																 if(OrgC3CirInPoint [k].x==0.0f && OrgC3CirInPoint [k].y==0.0f) continue;
																 GrindWidthDis = Math.GetLength(OrgC3CirInPoint[k], OrgC3CirOutPoint[k]);
																 TotalCirDis+=   GrindWidthDis;
																 CircleCount++;
															 }
															 if(TotalCirDis!=0.0f && CircleCount!=0){
																 C3CirGrindWd = TotalCirDis/CircleCount;
															 }
														 }
													 }
												 }
											 }
											 else         { // EnCAP 연마량만 계산 
												 if(OrgC3CirInEdgeCount==OrgC3CirOutEdgeCount){
													 double OutDis=0.0f, InDis=0.0f, TotalGrindWidth=0.0f, AvgGrindWidth=0.0f;C3GrindWidthCount=0;
													 for(int k=0; k<OrgC3CirInEdgeCount; k++){
														 if(OrgC3CirOutPoint[k].x==0.0f && OrgC3CirOutPoint[k].y==0.0f){
															 OutDis =0.0f;
														 }
														 else {
															 OutDis = Math.GetLengthFrPointToPoint(C3CirCenter,OrgC3CirOutPoint[k]);
														 }

														 if(OrgC3CirInPoint[k].x==0.0f && OrgC3CirInPoint[k].y==0.0f){
															 InDis =0.0f;
														 }
														 else {
															 InDis = Math.GetLengthFrPointToPoint(C3CirCenter,OrgC3CirInPoint[k]);
														 }

														 if(OutDis!=0.0f && InDis!=0.0f){
															 TotalGrindWidth+=(InDis - OutDis);
															 C3GrindWidthCount++;
														 }
													 }
													 if(C3GrindWidthCount!=0){
														 AvgGrindWidth = (TotalGrindWidth/C3GrindWidthCount);
														 C3CirGrindWd = AvgGrindWidth;
													 }
												 }
											 }
										 }
										 // C3Circle 연마량 가공량 검사 시퀀스 종료(TrackMode VS MarkMode)
										 //////////////////////////////////////////////////////////////////////////////////////////////////////


										 // Org Circle데이터중 유호하지 않은 값을 제외한 실제 존재하는 데이터 기준으로 동적 메모리 생성함
										 // Circle Defect검사에 필요한 Edge데이터 값
										 int Count=0;
										 if(OrgC3CirInEdgeCount>0){
											 C3CirInEdgeCount = OrgC3CirInEdgeCount - C3CirInEdgeCount;
											 // 										C3CirInEdgeCount = OrgC3CirInEdgeCount;
											 if(C3CirInEdgeCount>0){
												 if(C3CirInPoint!=NULL) delete[] C3CirInPoint;
												 C3CirInPoint = new TFPoint[C3CirInEdgeCount];

												 for(int k=0; k<OrgC3CirInEdgeCount; k++){
													 if(k>MAX_CIRCLE_EDGEPOINT) break;
													 if(OrgC3CirInPoint[k].x==0.0f && OrgC3CirInPoint[k].y==0.0f) continue;
													 C3CirInPoint[Count].x = OrgC3CirInPoint[k].x;
													 C3CirInPoint[Count].y = OrgC3CirInPoint[k].y;
													 Count++;
												 }
											 }
											 // Circle 원본 데이터 메모리 삭제
											 if(OrgC3CirInPoint!=NULL) delete[] OrgC3CirInPoint;
										 }
										 // Circle Fitting 결과물 
										 SampleSize = C3CirInEdgeCount*0.75; //0.5~0.8이하로 입력할것
										 DistDevRatio = 0.15; //0.1~0.25 이하로 입력할것
										 // 									Radius = 0;
										 CircleFit->OnRansac(C3CirInPoint,C3CirInEdgeCount,SampleSize,DistDevRatio,&CircleFit3Center,&CirFitDiameter3);

										 if(OrgC3CirOutEdgeCount>0){
											 C3CirOutEdgeCount = OrgC3CirOutEdgeCount - C3CirOutEdgeCount;
											 Count =0;
											 if(C3CirOutEdgeCount>0){
												 if(C3CirOutPoint!=NULL) delete[] C3CirOutPoint;
												 C3CirOutPoint = new TFPoint[C3CirOutEdgeCount];

												 for(int k=0; k<OrgC3CirOutEdgeCount; k++){
													 if(k>MAX_CIRCLE_EDGEPOINT) break;
													 if(OrgC3CirOutPoint[k].x==0.0f && OrgC3CirOutPoint[k].y==0.0f) continue;
													 C3CirOutPoint[Count].x = OrgC3CirOutPoint[k].x;
													 C3CirOutPoint[Count].y = OrgC3CirOutPoint[k].y;
													 Count++;
												 }
											 }
											 // Circle 원본 데이터 메모리 삭제
											 if(OrgC3CirOutPoint!=NULL) delete[] OrgC3CirOutPoint;
										 }
										 if(OrgC3CirStandEdgeCount>0){
											 C3CirStandEdgeCount = OrgC3CirStandEdgeCount - C3CirStandEdgeCount;
											 // 										C3CirStandEdgeCount = OrgC3CirStandEdgeCount;
											 Count =0;
											 if(C3CirStandEdgeCount>0){
												 if(C3CirStandPoint!=NULL) delete[] C3CirStandPoint;
												 C3CirStandPoint = new TFPoint[C3CirStandEdgeCount];

												 for(int k=0; k<OrgC3CirStandEdgeCount; k++){
													 if(k>MAX_CIRCLE_EDGEPOINT) break;
													 if(OrgC3CirStandPoint[k].x==0.0f && OrgC3CirStandPoint[k].y==0.0f) continue;
													 C3CirStandPoint[Count].x = OrgC3CirStandPoint[k].x;
													 C3CirStandPoint[Count].y = OrgC3CirStandPoint[k].y;
													 Count++;
												 }
											 }
											 // Circle 원본 데이터 메모리 삭제
											 if(OrgC3CirStandPoint!=NULL) delete[] OrgC3CirStandPoint;
										 }
										 LogUnit.SetLog(L"Circle_3_Insp_End");
										 // Circle 영역 꽃박리, 원형박리 검출 목적 시퀀스(EnCap)
										 // 정식 명칭은 몰라서.....일단 Crack으로 정함 
										 if(!IsMarkBtm && BrokenThresHold!=0){
											 if(CirFitDiameter3!=0.0f && CircleFit3Center.x!=0.0f && CircleFit3Center.y!=0.0f){ // FAVION Circle Fitting 성공시 박리검사 진행 
												 Circle->GImage = &RotateBrokenImg;                                             //Binary Image 넘겨줌 

												 Circle->SetCenterXY(CircleFit3Center.x,CircleFit3Center.y)      ;
												 Circle->SetTolerance((dEdgeToTrapLineDis/2)-CirOffsetMargin)    ; // Circle Tolerance 
												 Circle->SetDiameter ((CirFitDiameter3+(dEdgeToTrapLineDis/2))*2); // Circle Diameter 
												 Circle->SetCircleChoice(0)                                      ; // 0:From Begin, 1:From End, 2:Largest Amplitude 
												 Circle->SetCircleType  (2)                                      ; // 0:Black to White, 1:White to Black 2: Both Black, White 
												 Circle->SetCircleIndex (0)                                      ; // Circle EdgePoint Index 
												 Circle->OnExecute(true)							                ;
												 CrackCirDiameter3 = (CirFitDiameter3+(dEdgeToTrapLineDis/2)) - (dEdgeToTrapLineDis/2)-CirOffsetMargin;

												 C3CirInCrackCount = Circle->FCirclePointCount;

												 if(C3CirInCrackCount>0){
													 if(C3CirInCrackPoint!=NULL) delete[] C3CirInCrackPoint;
													 C3CirInCrackPoint = new TFPoint[C3CirInCrackCount];

													 for(int k=0; k<C3CirInCrackCount; k++){
														 if(k>MAX_CIRCLE_EDGEPOINT) break;
														 C3CirInCrackPoint[k].x = Circle->FCirclePoint[k].x;
														 C3CirInCrackPoint[k].y = Circle->FCirclePoint[k].y;
													 }
												 }
											 }
										 }
									 }

									 // 네번째 Circle EdgePoint Data 추출 
									 if(C4CirCenter.x!=0 && C4CirCenter.y!=0){
										 LogUnit.SetLog(L"Circle_4_Insp_Start");

										 if(BtmEdgeThresHold==0) Circle->GImage = &RotateImg      ; //Org Image 넘겨줌 
										 else                    Circle->GImage = &RotateBinaryImg; //Binary Image 넘겨줌 

										 if      (FInspectMode==Insp_Track) Circle->SetCenterXY(TrackC4CirCenter.x , TrackC4CirCenter.y); // TrackLine 교차점 기준 센터 
										 else if (FInspectMode==Insp_Mark ) Circle->SetCenterXY(C4CirCenter.x      , C4CirCenter.y     ); // 외곽라인 교차점 기준 센터 
										 // Diameter 계산함(OutCircle과 TrackCircle 중간값 기준)
										 C4Diameter = ((CenterCircleHeight*2)+((CenterCircleHeight+OutToTrackLineDis)*2))/2;
										 // 									 C4Diameter = (CenterCircleHeight*2);
										 if(IsMarkBtm) Circle->SetTolerance(60.0f);
										 else          Circle->SetTolerance(80.0f);
										 // 									 Circle->SetTolerance(60.0f )              ; // Circle Tolerance 
										 Circle->SetDiameter (C4Diameter)          ; // Circle Diameter 
										 Circle->SetCircleChoice(0)                ; // 0:From Begin, 1:From End, 2:Largest Amplitude 
										 Circle->SetCircleIndex (0)                ; // Circle EdgePoint Index 
										 if(CenterCirDeg>=0){
											 CenterCirDeg = (CenterCirDeg==0)? 90:CenterCirDeg;
											 // 										 Circle->SetAngle(270+CirAngleMargin               );               // Circle Fitting 시작점 각도
											 // 										 Circle->SetAmplitude(CenterCirDeg-2*CirAngleMargin);  // Circle Fitting 시작점 부터 검사 범위 
											 Circle->SetAngle(270             );               // Circle Fitting 시작점 각도
											 Circle->SetAmplitude(CenterCirDeg);  // Circle Fitting 시작점 부터 검사 범위 
										 }

										 Circle->SetCircleType(1)                          ; // 0:Black to White, 1:White to Black 2: Both Black, White 
										 Circle->OnExecute()                               ;

										 // Circle Out Data취합 
										 OrgC4CirOutEdgeCount = Circle->FCirclePointCount;
										 if(OrgC4CirOutEdgeCount>0){
											 if(OrgC4CirOutPoint!=NULL) delete[] OrgC4CirOutPoint;
											 OrgC4CirOutPoint = new TFPoint[OrgC4CirOutEdgeCount];

											 for(int k=0; k<OrgC4CirOutEdgeCount; k++){
												 if(k>MAX_CIRCLE_EDGEPOINT) break;
												 OrgC4CirOutPoint[k].x = Circle->FCirclePoint[k].x;
												 OrgC4CirOutPoint[k].y = Circle->FCirclePoint[k].y;
												 // BTM영역 Circle을 제외한 영역 Defect검사 목적에 좌표계산 
												 if(k==0)                        {BtmEdgePoint[5].x = OrgC4CirOutPoint[k].x; BtmEdgePoint[5].y = OrgC4CirOutPoint[k].y;}
												 if(k==(OrgC4CirOutEdgeCount-1)) {BtmEdgePoint[7].x = OrgC4CirOutPoint[k].x; BtmEdgePoint[7].y = OrgC4CirOutPoint[k].y;}

												 if(OrgC4CirOutPoint[k].x==0.0f && OrgC4CirOutPoint[k].y==0.0f) C4CirOutEdgeCount++;
											 }
										 }

										 // Circle Out Data목적 다시 검사  
										 if(CirGrindInThresHold==0) Circle->GImage = &RotateImg             ; //Org Image 넘겨줌 
										 else                       Circle->GImage = &RotateGrindInBinaryImg; //Binary Image 넘겨줌 
										 // 									 if(BtmEdgeThresHold==0) Circle->GImage = &RotateImg      ; //Org Image 넘겨줌 
										 // 									 else                    Circle->GImage = &RotateBinaryImg; //Binary Image 넘겨줌 

										 if(IsMarkBtm) Circle->SetTolerance(60.0f);
										 else          Circle->SetTolerance(80.0f);
										 // 									 Circle->SetTolerance(60.0f )      ; // Circle Tolerance 
										 Circle->SetDiameter (C4Diameter)  ; // Circle Diameter 
										 Circle->SetCircleChoice(0)        ; // 0:From Begin, 1:From End, 2:Largest Amplitude 
										 Circle->SetCircleIndex (0)        ; // Circle EdgePoint Index 
										 Circle->SetCircleType(0)          ; // 0:Black to White, 1:White to Black 2: Both Black, White 
										 Circle->OnExecute()               ;

										 // Circle In Data 기준 새로운 Circle Center 좌표 받아옴 
										 RealC4CirCenter.x = Circle->FCP.x;
										 RealC4CirCenter.y = Circle->FCP.y;
										 CirDiameter4      = (Circle->Diameter)/2.0;

										 // Circle In Data취합 
										 OrgC4CirInEdgeCount = Circle->FCirclePointCount;
										 if(OrgC4CirInEdgeCount>0){
											 if(OrgC4CirInPoint!=NULL) delete[] OrgC4CirInPoint;
											 OrgC4CirInPoint = new TFPoint[OrgC4CirInEdgeCount];

											 for(int k=0; k<OrgC4CirInEdgeCount; k++){
												 if(k>MAX_CIRCLE_EDGEPOINT) break;
												 OrgC4CirInPoint[k].x = Circle->FCirclePoint[k].x;
												 OrgC4CirInPoint[k].y = Circle->FCirclePoint[k].y;
												 if(OrgC4CirInPoint[k].x==0.0f && OrgC4CirInPoint[k].y==0.0f)C4CirInEdgeCount++;
												 // BTM영역 Circle을 제외한 영역 Defect검사 목적에 좌표계산 
												 // 											 if(k==0) {BtmEdgePoint1.x = C1CirInPoint[k].x; BtmEdgePoint1.y = C1CirInPoint[k].y;}
											 }
										 }

										 // C4Circle Grind_Width, Grind_Measure 
										 // C4Circle 연마량 가공량 검사 시퀀스 시작(TrackMode VS MarkMode)
										 if(FInspectMode==Insp_Track){ // TrackMode 
											 if(OrgC4CirInEdgeCount==OrgC4CirOutEdgeCount){// 가공량 계산
												 double OutDis=0.0f, InDis=0.0f, TotalGrindWidth=0.0f, AvgGrindWidth=0.0f;C4GrindWidthCount=0;
												 for(int k=0; k<OrgC4CirInEdgeCount; k++){
													 if(OrgC4CirOutPoint[k].x==0.0f && OrgC4CirOutPoint[k].y==0.0f){
														 OutDis =0.0f;
													 }
													 else {
														 OutDis = Math.GetLengthFrPointToPoint(C4CirCenter,OrgC4CirOutPoint[k]);
													 }

													 if(OrgC4CirInPoint[k].x==0.0f && OrgC4CirInPoint[k].y==0.0f){
														 InDis =0.0f;
													 }
													 else {
														 InDis = Math.GetLengthFrPointToPoint(C4CirCenter,OrgC4CirInPoint[k]);
													 }

													 if(OutDis!=0.0f && InDis!=0.0f){
														 TotalGrindWidth+=(InDis - OutDis);
														 C4GrindWidthCount++;
													 }
												 }
												 if(C4GrindWidthCount!=0){
													 AvgGrindWidth = (TotalGrindWidth/C4GrindWidthCount);
													 C4CirGrindWd = AvgGrindWidth;
												 }
											 }
											 if(IsMarkBtm){ // LTPS일경만 가공량 계산 
												 if(CirGrindMeaThresHold!=0){
													 Circle->GImage = &RotateGrindBinaryImg; //Binary Image 넘겨줌 
													 Circle->SetTolerance(40.0f )          ; // Circle Tolerance 
													 Circle->SetDiameter (C4Diameter)      ; // Circle Diameter 
													 Circle->SetCircleType(1)              ; // 0:Black to White, 1:White to Black 2: Both Black, White 
													 Circle->OnExecute()                   ;

													 // Circle In Data 기준 새로운 Circle Center 좌표 받아옴 
													 RealC4CirCenter.x = Circle->FCP.x;
													 RealC4CirCenter.y = Circle->FCP.y;

													 OrgC4CirStandEdgeCount = Circle->FCirclePointCount;
													 if(OrgC4CirStandEdgeCount>0){
														 if(OrgC4CirStandPoint!=NULL) delete[] OrgC4CirStandPoint;
														 OrgC4CirStandPoint = new TFPoint[OrgC4CirStandEdgeCount];

														 PreC4CirStandPoint[0].x=0.0f;PreC4CirStandPoint[0].y=0.0f;
														 for(int k=0; k<OrgC4CirStandEdgeCount; k++){
															 if(k>MAX_CIRCLE_EDGEPOINT) break;
															 OrgC4CirStandPoint[k].x = Circle->FCirclePoint[k].x;
															 OrgC4CirStandPoint[k].y = Circle->FCirclePoint[k].y;
															 if(OrgC4CirStandPoint[k].x==0.0f && OrgC4CirStandPoint[k].y==0.0f) C4CirStandEdgeCount++;
															 // TrackLine 자재 상태에 따라서 잘못된 EdgePoint를 찾을경우 대비하여 이전데이터 기준 데이터 복원 
															 if(OrgC4CirStandPoint[k].x!=0.0f && OrgC4CirStandPoint[k].y!=0.0f){
																 // 첫번째는 무조건 데이터 넘겨줌 
																 if(PreC4CirStandPoint[0].x==0.0f && PreC4CirStandPoint[0].y==0.0f){
																	 PreC4CirStandPoint[0].x = OrgC4CirStandPoint[k].x; 
																	 PreC4CirStandPoint[0].y = OrgC4CirStandPoint[k].y; 
																 }
																 else {
																	 if(fabs (OrgC4CirStandPoint[k].x-PreC4CirStandPoint[0].x)>TrackLineMargin ||
																		 fabs(OrgC4CirStandPoint[k].y-PreC4CirStandPoint[0].y)>TrackLineMargin   ){
																			 OrgC4CirStandPoint[k].x = PreC4CirStandPoint[0].x+0.5;
																			 OrgC4CirStandPoint[k].y = PreC4CirStandPoint[0].y+0.5;

																			 PreC4CirStandPoint[0].x = OrgC4CirStandPoint[k].x; 
																			 PreC4CirStandPoint[0].y = OrgC4CirStandPoint[k].y; 
																	 }
																	 else {
																		 PreC4CirStandPoint[0].x = OrgC4CirStandPoint[k].x; 
																		 PreC4CirStandPoint[0].y = OrgC4CirStandPoint[k].y; 
																	 }
																 }
															 }
														 }
														 //C4Circle Grind_Measure Calculate 
														 if(OrgC4CirOutEdgeCount==OrgC4CirStandEdgeCount){
															 double GrindMeaDis=0.0f, TotalGrindMeasure=0.0f, AvgGrindMeasure=0.0f;C4GrindMeasureCount=0;
															 for(int k=0; k<OrgC4CirStandEdgeCount; k++){
																 if(OrgC4CirOutPoint[k].x==0.0f || OrgC4CirOutPoint[k].y==0.0f || OrgC4CirStandPoint[k].x==0.0f || OrgC4CirStandPoint[k].y==0.0f){
																	 GrindMeaDis =0.0f;
																 }
																 else {
																	 GrindMeaDis = Math.GetLengthFrPointToPoint(OrgC4CirStandPoint[k],OrgC4CirOutPoint[k]);
																 }

																 if(GrindMeaDis!=0.0f){
																	 TotalGrindMeasure+= GrindMeaDis;
																	 C4GrindMeasureCount++;
																 }
															 }
															 if(C4GrindMeasureCount!=0){
																 AvgGrindMeasure = (TotalGrindMeasure/C4GrindMeasureCount);
																 C4CirGrindMea= AvgGrindMeasure;
															 }
														 }
														 else if(OrgC4CirStandEdgeCount>OrgC4CirOutEdgeCount){ // 연마가 적게되어 실제 TrackLine보다 EdgePoint데이터가 적을경우 
															 double GrindMeaDis=0.0f, TotalGrindMeasure=0.0f, AvgGrindMeasure=0.0f;C4GrindMeasureCount=0;
															 for(int k=0; k<OrgC4CirOutEdgeCount; k++){
																 if(OrgC4CirOutPoint[k].x==0.0f || OrgC4CirOutPoint[k].y==0.0f || OrgC4CirStandPoint[k].x==0.0f || OrgC4CirStandPoint[k].y==0.0f ){
																	 GrindMeaDis =0.0f;
																 }
																 else {
																	 GrindMeaDis = Math.GetLengthFrPointToPoint(OrgC4CirStandPoint[k],OrgC4CirOutPoint[k]);
																 }

																 if(GrindMeaDis!=0.0f){
																	 TotalGrindMeasure+= GrindMeaDis;
																	 C4GrindMeasureCount++;
																 }
															 }
															 if(C4GrindMeasureCount!=0){
																 AvgGrindMeasure = (TotalGrindMeasure/C4GrindMeasureCount);
																 C4CirGrindMea= AvgGrindMeasure;
															 }
														 }
														 else if(OrgC4CirStandEdgeCount<OrgC4CirOutEdgeCount){
															 double GrindMeaDis=0.0f, TotalGrindMeasure=0.0f, AvgGrindMeasure=0.0f;C4GrindMeasureCount=0;
															 for(int k=0; k<OrgC4CirStandEdgeCount; k++){
																 if(OrgC4CirOutPoint[k].x==0.0f || OrgC4CirOutPoint[k].y==0.0f || OrgC4CirStandPoint[k].x==0.0f || OrgC4CirStandPoint[k].y==0.0f ){
																	 GrindMeaDis =0.0f;
																 }
																 else {
																	 GrindMeaDis = Math.GetLengthFrPointToPoint(OrgC4CirStandPoint[k],OrgC4CirOutPoint[k]);
																 }

																 if(GrindMeaDis!=0.0f){
																	 TotalGrindMeasure+= GrindMeaDis;
																	 C4GrindMeasureCount++;
																 }
															 }
															 if(C4GrindMeasureCount!=0){
																 AvgGrindMeasure = (TotalGrindMeasure/C4GrindMeasureCount);
																 C4CirGrindMea= AvgGrindMeasure;
															 }
														 }
													 }
												 }
											 }
										 }
										 else if(FInspectMode==Insp_Mark){ // MarkMode 
											 if(IsMarkBtm){ //LTPS 가공량 계산 ==> 연마량 계산 
												 if(OrgC4CirOutEdgeCount!=0 && OrgC4CirInEdgeCount!=0){// 연마량이 존재할경우 가공량 검사를 진행함 
													 GrindMeaDis =0.0f, MinDis =10000.0f;C4GrindMarkCount=0;
													 if(GrindMarkPoint[11].x!=0.0f && GrindMarkPoint[11].y!=0.0f){
														 for(int k=0; k<OrgC4CirOutEdgeCount; k++){
															 if(OrgC4CirOutPoint[k].x==0.0f || OrgC4CirOutPoint[k].y==0.0f) continue;
															 if(GrindMarkPoint[11].x  ==0.0f || GrindMarkPoint[11].y  ==0.0f) continue;

															 GrindMeaDis = Math.GetLength(GrindMarkPoint[11], OrgC4CirOutPoint[k]);
															 if(GrindMeaDis<MinDis){
																 MinDis = GrindMeaDis;
																 C4GrindMarkCount = k;
															 }
														 }
														 // GrindMark기준 수직 포인트 주변값 Avg산출한다 
														 if(C4GrindMarkCount!=0 && C4GrindMarkCount>5){
															 CircleCount=0,TotalCirDis=0.0f,GrindMeaDis=0.0f;
															 for(int k=C4GrindMarkCount-5; k<C4GrindMarkCount+5; k++){
																 if(OrgC4CirOutPoint[k].x==0.0f || OrgC4CirOutPoint[k].y==0.0f) continue;

																 GrindMeaDis = Math.GetLength(GrindMarkPoint[11], OrgC4CirOutPoint[k]);
																 TotalCirDis+= GrindMeaDis;
																 CircleCount++;
															 }
															 if(TotalCirDis!=0.0f && CircleCount!=0){
																 C4CirGrindMea = TotalCirDis/CircleCount;
															 }
														 }
														 // GrindMark기준 수직 평균값 연마량 측정 
														 if(C4GrindMarkCount!=0 && C4GrindMarkCount>5){
															 CircleCount=0,TotalCirDis=0.0f,GrindWidthDis=0.0f;
															 for(int k=C4GrindMarkCount-5; k<C4GrindMarkCount+5; k++){
																 if(OrgC4CirOutPoint[k].x==0.0f && OrgC4CirOutPoint[k].y==0.0f) continue;
																 if(OrgC4CirInPoint [k].x==0.0f && OrgC4CirInPoint [k].y==0.0f) continue;
																 GrindWidthDis = Math.GetLength(OrgC4CirInPoint[k], OrgC4CirOutPoint[k]);
																 TotalCirDis+=   GrindWidthDis;
																 CircleCount++;
															 }
															 if(TotalCirDis!=0.0f && CircleCount!=0){
																 C4CirGrindWd = TotalCirDis/CircleCount;
															 }
														 }
													 }
													 else { // Grind Mark 못 찾았을경우 (가공량 0, 연마량 계산함)
														 for(int k=0; k<OrgC4CirOutEdgeCount; k++){
															 if(OrgC4CirOutPoint[k].x==0.0f || OrgC4CirOutPoint[k].y==0.0f) continue;

															 GrindMarkRectCenter[11].x = GrindMarkRect[11].left + (GrindMarkRect[11].right  - GrindMarkRect[11].left)/2; 
															 GrindMarkRectCenter[11].y = GrindMarkRect[11].top  + (GrindMarkRect[11].bottom - GrindMarkRect[11].top )/2; 

															 GrindMeaDis = Math.GetLength(GrindMarkRectCenter[11], OrgC4CirOutPoint[k]);
															 if(GrindMeaDis<MinDis){
																 MinDis = GrindMeaDis;
																 C4GrindMarkCount = k;
															 }
														 }
														 // GrindMark기준 수직 평균값 연마량 측정 
														 if(C4GrindMarkCount!=0 && C4GrindMarkCount>5){
															 CircleCount=0,TotalCirDis=0.0f,GrindWidthDis=0.0f;
															 for(int k=C4GrindMarkCount-5; k<C4GrindMarkCount+5; k++){
																 if(OrgC4CirOutPoint[k].x==0.0f && OrgC4CirOutPoint[k].y==0.0f) continue;
																 if(OrgC4CirInPoint [k].x==0.0f && OrgC4CirInPoint [k].y==0.0f) continue;
																 GrindWidthDis = Math.GetLength(OrgC4CirInPoint[k], OrgC4CirOutPoint[k]);
																 TotalCirDis+=   GrindWidthDis;
																 CircleCount++;
															 }
															 if(TotalCirDis!=0.0f && CircleCount!=0){
																 C4CirGrindWd = TotalCirDis/CircleCount;
															 }
														 }
													 }
												 }
											 }
											 else         { //Encap 연마량 계산 
												 if(OrgC4CirInEdgeCount==OrgC4CirOutEdgeCount){
													 double OutDis=0.0f, InDis=0.0f, TotalGrindWidth=0.0f, AvgGrindWidth=0.0f;C4GrindWidthCount=0;
													 for(int k=0; k<OrgC4CirInEdgeCount; k++){
														 if(OrgC4CirOutPoint[k].x==0.0f && OrgC4CirOutPoint[k].y==0.0f){
															 OutDis =0.0f;
														 }
														 else {
															 OutDis = Math.GetLengthFrPointToPoint(C4CirCenter,OrgC4CirOutPoint[k]);
														 }

														 if(OrgC4CirInPoint[k].x==0.0f && OrgC4CirInPoint[k].y==0.0f){
															 InDis =0.0f;
														 }
														 else {
															 InDis = Math.GetLengthFrPointToPoint(C4CirCenter,OrgC4CirInPoint[k]);
														 }

														 if(OutDis!=0.0f && InDis!=0.0f){
															 TotalGrindWidth+=(InDis - OutDis);
															 C4GrindWidthCount++;
														 }
													 }
													 if(C4GrindWidthCount!=0){
														 AvgGrindWidth = (TotalGrindWidth/C4GrindWidthCount);
														 C4CirGrindWd = AvgGrindWidth;
													 }
												 }
											 }
										 }
										 // C4Circle 연마량 가공량 검사 시퀀스 종료(TrackMode VS MarkMode)
										 //////////////////////////////////////////////////////////////////////////////////////////////////////


										 // Org Circle데이터중 유호하지 않은 값을 제외한 실제 존재하는 데이터 기준으로 동적 메모리 생성함
										 // Circle Defect검사에 필요한 Edge데이터 값
										 int Count=0;
										 if(OrgC4CirInEdgeCount>0){
											 C4CirInEdgeCount = OrgC4CirInEdgeCount - C4CirInEdgeCount;
											 // 										 C4CirInEdgeCount = OrgC4CirInEdgeCount;
											 if(C4CirInEdgeCount>0){
												 if(C4CirInPoint!=NULL) delete[] C4CirInPoint;
												 C4CirInPoint = new TFPoint[C4CirInEdgeCount];

												 for(int k=0; k<OrgC4CirInEdgeCount; k++){
													 if(k>MAX_CIRCLE_EDGEPOINT) break;
													 if(OrgC4CirInPoint[k].x==0.0f && OrgC4CirInPoint[k].y==0.0f) continue;
													 C4CirInPoint[Count].x = OrgC4CirInPoint[k].x;
													 C4CirInPoint[Count].y = OrgC4CirInPoint[k].y;
													 Count++;
												 }
											 }
											 // Circle 원본 데이터 메모리 삭제
											 if(OrgC4CirInPoint!=NULL) delete[] OrgC4CirInPoint;
										 }
										 // Circle Fitting 결과물 
										 SampleSize = C4CirInEdgeCount*0.75; //0.5~0.8이하로 입력할것
										 DistDevRatio = 0.15; //0.1~0.25 이하로 입력할것
										 // 									Radius = 0;
										 CircleFit->OnRansac(C4CirInPoint,C4CirInEdgeCount,SampleSize,DistDevRatio,&CircleFit4Center,&CirFitDiameter4);

										 if(OrgC4CirOutEdgeCount>0){
											 C4CirOutEdgeCount = OrgC4CirOutEdgeCount - C4CirOutEdgeCount;
											 Count =0;
											 if(C4CirOutEdgeCount>0){
												 if(C4CirOutPoint!=NULL) delete[] C4CirOutPoint;
												 C4CirOutPoint = new TFPoint[C4CirOutEdgeCount];

												 for(int k=0; k<OrgC4CirOutEdgeCount; k++){
													 if(k>MAX_CIRCLE_EDGEPOINT) break;
													 if(OrgC4CirOutPoint[k].x==0.0f && OrgC4CirOutPoint[k].y==0.0f) continue;
													 C4CirOutPoint[Count].x = OrgC4CirOutPoint[k].x;
													 C4CirOutPoint[Count].y = OrgC4CirOutPoint[k].y;
													 Count++;
												 }
											 }
											 // Circle 원본 데이터 메모리 삭제
											 if(OrgC4CirOutPoint!=NULL) delete[] OrgC4CirOutPoint;
										 }
										 if(OrgC4CirStandEdgeCount>0){
											 C4CirStandEdgeCount = OrgC4CirStandEdgeCount - C4CirStandEdgeCount;
											 // 										 C4CirStandEdgeCount = OrgC4CirStandEdgeCount;
											 Count =0;
											 if(C4CirStandEdgeCount>0){
												 if(C4CirStandPoint!=NULL) delete[] C4CirStandPoint;
												 C4CirStandPoint = new TFPoint[C4CirStandEdgeCount];

												 for(int k=0; k<OrgC4CirStandEdgeCount; k++){
													 if(k>MAX_CIRCLE_EDGEPOINT) break;
													 if(OrgC4CirStandPoint[k].x==0.0f && OrgC4CirStandPoint[k].y==0.0f) continue;
													 C4CirStandPoint[Count].x = OrgC4CirStandPoint[k].x;
													 C4CirStandPoint[Count].y = OrgC4CirStandPoint[k].y;
													 Count++;
												 }
											 }
											 // Circle 원본 데이터 메모리 삭제
											 if(OrgC4CirStandPoint!=NULL) delete[] OrgC4CirStandPoint;
										 }
										 LogUnit.SetLog(L"Circle_4_Insp_End");
										 // Circle 영역 꽃박리, 원형박리 검출 목적 시퀀스(EnCap)
										 // 정식 명칭은 몰라서.....일단 Crack으로 정함 
										 if(!IsMarkBtm && BrokenThresHold!=0){
											 if(CirFitDiameter4!=0.0f && CircleFit4Center.x!=0.0f && CircleFit4Center.y!=0.0f){ // FAVION Circle Fitting 성공시 박리검사 진행 
												 Circle->GImage = &RotateBrokenImg;                                             //Binary Image 넘겨줌 

												 Circle->SetCenterXY(CircleFit4Center.x,CircleFit4Center.y)      ;
												 Circle->SetTolerance((dEdgeToTrapLineDis/2)-CirOffsetMargin)    ; // Circle Tolerance 
												 Circle->SetDiameter ((CirFitDiameter4+(dEdgeToTrapLineDis/2))*2); // Circle Diameter 
												 Circle->SetCircleChoice(0)                                      ; // 0:From Begin, 1:From End, 2:Largest Amplitude 
												 Circle->SetCircleType  (2)                                      ; // 0:Black to White, 1:White to Black 2: Both Black, White 
												 Circle->SetCircleIndex (0)                                      ; // Circle EdgePoint Index 
												 Circle->OnExecute(true)                                         ;
												 CrackCirDiameter4 = (CirFitDiameter4+(dEdgeToTrapLineDis/2))-((dEdgeToTrapLineDis/2)-CirOffsetMargin);

												 C4CirInCrackCount = Circle->FCirclePointCount;

												 if(C4CirInCrackCount>0){
													 if(C4CirInCrackPoint!=NULL) delete[] C4CirInCrackPoint;
													 C4CirInCrackPoint = new TFPoint[C4CirInCrackCount];

													 for(int k=0; k<C4CirInCrackCount; k++){
														 if(k>MAX_CIRCLE_EDGEPOINT) break;
														 C4CirInCrackPoint[k].x = Circle->FCirclePoint[k].x;
														 C4CirInCrackPoint[k].y = Circle->FCirclePoint[k].y;
													 }
												 }
											 }
										 }
									 }

									 // 다섯번째 Circle EdgePoint Data 추출 
									 if(C5CirCenter.x!=0 && C5CirCenter.y!=0){
										 LogUnit.SetLog(L"Circle_5_Insp_Start");

										 // 									 if(BtmEdgeThresHold==0) Circle->GImage = &RotateImg      ; //Org Image 넘겨줌 
										 // 									 else                    Circle->GImage = &RotateBinaryImg; //Binary Image 넘겨줌 

										 if(CirGrindInThresHold==0) Circle->GImage = &RotateImg             ; //Org Image 넘겨줌 
										 else                       Circle->GImage = &RotateGrindInBinaryImg; //Binary Image 넘겨줌 

										 if      (FInspectMode==Insp_Track) Circle->SetCenterXY(TrackC5CirCenter.x , TrackC5CirCenter.y); // TrackLine 교차점 기준 센터 
										 else if (FInspectMode==Insp_Mark ) Circle->SetCenterXY(C5CirCenter.x      , C5CirCenter.y     ); // 외곽라인 교차점 기준 센터 
										 // Diameter 계산함(OutCircle과 TrackCircle 중간값 기준)
										 C5Diameter = ((CenterCircleHeight*2)+((CenterCircleHeight-OutToTrackLineDis)*2))/2;
										 // 									 C5Diameter = (CenterCircleHeight*2);
										 if(IsMarkBtm) Circle->SetTolerance(60.0f);
										 else          Circle->SetTolerance(80.0f);
										 // 									 Circle->SetTolerance(40.0f )                      ; // Circle Tolerance 
										 Circle->SetDiameter (C5Diameter)                  ; // Circle Diameter 
										 // 									 Circle->SetCircleChoice(0)                        ; // 0:From Begin, 1:From End, 2:Largest Amplitude 
										 // 									 Circle->SetCircleIndex (0)                        ; // Circle EdgePoint Index 
										 Circle->SetCircleChoice(1)                        ; // 0:From Begin, 1:From End, 2:Largest Amplitude 
										 Circle->SetCircleType  (2)                        ; // 0:Black to White, 1:White to Black 2: Both Black, White 
										 Circle->SetCircleIndex (1)                        ; // Circle EdgePoint Index 

										 // W1 Cell
										 // 									 Circle->SetAngle(90)                              ; // Cirlce Angle 
										 // 									 Circle->SetAmplitude(46)                          ; // Circle Amplitude
										 // W4 Cell
										 // 									 Circle->SetAngle(90)                              ; // Cirlce Angle 
										 // 									 Circle->SetAmplitude(81)                          ; // Circle Amplitude
										 if(CenterCirDeg>=0){
											 CenterCirDeg = (CenterCirDeg==0)? 90:CenterCirDeg;
											 // 										 Circle->SetAngle(90+CirAngleMargin);               // Circle Fitting 시작점 각도
											 // 										 Circle->SetAmplitude(CenterCirDeg-2*CirAngleMargin);  // Circle Fitting 시작점 부터 검사 범위 
											 Circle->SetAngle    (90          );               // Circle Fitting 시작점 각도
											 Circle->SetAmplitude(CenterCirDeg);  // Circle Fitting 시작점 부터 검사 범위 

										 }
										 Circle->OnExecute()                               ;

										 // Circle In Data 기준 새로운 Circle Center 좌표 받아옴 
										 RealC5CirCenter.x = Circle->FCP.x;
										 RealC5CirCenter.y = Circle->FCP.y;
										 CirDiameter5      = (Circle->Diameter)/2.0;

										 // Circle In Data취합 
										 OrgC5CirInEdgeCount = Circle->FCirclePointCount;
										 if(OrgC5CirInEdgeCount>0){
											 if(OrgC5CirInPoint!=NULL) delete[] OrgC5CirInPoint;
											 OrgC5CirInPoint = new TFPoint[OrgC5CirInEdgeCount];

											 for(int k=0; k<OrgC5CirInEdgeCount; k++){
												 if(k>MAX_CIRCLE_EDGEPOINT) break;
												 OrgC5CirInPoint[k].x = Circle->FCirclePoint[k].x;
												 OrgC5CirInPoint[k].y = Circle->FCirclePoint[k].y;
												 if(OrgC5CirInPoint[k].x==0.0f && OrgC5CirInPoint[k].y==0.0f) C5CirInEdgeCount++;
												 // BTM영역 Circle을 제외한 영역 Defect검사 목적에 좌표계산 
												 // 											 if(k==0) {BtmEdgePoint1.x = C1CirInPoint[k].x; BtmEdgePoint1.y = C1CirInPoint[k].y;}
											 }
										 }

										 // C5Circle 연마량 가공량 검사 시퀀스 시작(TrackMode VS MarkMode)
										 if(BtmEdgeThresHold==0) Circle->GImage = &RotateImg      ; //Org Image 넘겨줌 
										 else                    Circle->GImage = &RotateBinaryImg; //Binary Image 넘겨줌 

										 if(IsMarkBtm) Circle->SetTolerance(60.0f);
										 else          Circle->SetTolerance(80.0f);
										 // 									 Circle->SetTolerance(40.0f )                      ; // Circle Tolerance 
										 Circle->SetDiameter (C5Diameter)                  ; // Circle Diameter 
										 // 									 Circle->SetCircleType(0)                          ; // 0:Black to White, 1:White to Black 2: Both Black, White 
										 Circle->SetCircleChoice(1)                        ; // 0:From Begin, 1:From End, 2:Largest Amplitude 
										 Circle->SetCircleType  (2)                        ; // 0:Black to White, 1:White to Black 2: Both Black, White 
										 Circle->SetCircleIndex (0)                        ; // Circle EdgePoint Index 
										 Circle->OnExecute()                               ;

										 // Circle Out Data취합 
										 OrgC5CirOutEdgeCount = Circle->FCirclePointCount;
										 if(OrgC5CirOutEdgeCount>0){
											 if(OrgC5CirOutPoint!=NULL) delete[] OrgC5CirOutPoint;
											 OrgC5CirOutPoint = new TFPoint[OrgC5CirOutEdgeCount];

											 for(int k=0; k<OrgC5CirOutEdgeCount; k++){
												 if(k>MAX_CIRCLE_EDGEPOINT) break;
												 OrgC5CirOutPoint[k].x = Circle->FCirclePoint[k].x;
												 OrgC5CirOutPoint[k].y = Circle->FCirclePoint[k].y;
												 // BTM영역 Circle을 제외한 영역 Defect검사 목적에 좌표계산 
												 if(k==0                                                                         ){BtmEdgePoint[8].x = OrgC5CirOutPoint[k].x; BtmEdgePoint[8].y = OrgC5CirOutPoint[k].y;}
												 if(k==(OrgC5CirOutEdgeCount-1) && (BtmEdgePoint[7].x==0 || BtmEdgePoint[7].y==0)){BtmEdgePoint[7].x = OrgC5CirOutPoint[k].x; BtmEdgePoint[7].y = OrgC5CirOutPoint[k].y;}
												 if(OrgC5CirOutPoint[k].x==0.0f && OrgC5CirOutPoint[k].y==0.0f) C5CirOutEdgeCount++;
											 }
										 }
										 // C5Circle Grind_Width, Grind_Measure 
										 // C5Circle 연마량 가공량 검사 시퀀스 시작(TrackMode VS MarkMode)
										 if(FInspectMode==Insp_Track){
											 if(OrgC5CirInEdgeCount==OrgC5CirOutEdgeCount){//연마량 계산 
												 double OutDis=0.0f, InDis=0.0f, TotalGrindWidth=0.0f, AvgGrindWidth=0.0f;C5GrindWidthCount=0;
												 for(int k=0; k<OrgC5CirInEdgeCount; k++){
													 if(OrgC5CirOutPoint[k].x==0.0f && OrgC5CirOutPoint[k].y==0.0f){
														 OutDis =0.0f;
													 }
													 else {
														 OutDis = Math.GetLengthFrPointToPoint(C5CirCenter,OrgC5CirOutPoint[k]);
													 }

													 if(OrgC5CirInPoint[k].x==0.0f && OrgC5CirInPoint[k].y==0.0f){
														 InDis =0.0f;
													 }
													 else {
														 InDis = Math.GetLengthFrPointToPoint(C5CirCenter,OrgC5CirInPoint[k]);
													 }

													 if(OutDis!=0.0f && InDis!=0.0f){
														 TotalGrindWidth+=(OutDis - InDis);
														 C5GrindWidthCount++;
													 }
												 }
												 if(C5GrindWidthCount!=0){
													 AvgGrindWidth = (TotalGrindWidth/C5GrindWidthCount);
													 C5CirGrindWd = AvgGrindWidth;
												 }
											 }
											 if(IsMarkBtm){ // LTPS 가공량 계산
												 if(CirGrindMeaThresHold!=0){
													 Circle->GImage = &RotateGrindBinaryImg; //Binary Image 넘겨줌 
													 Circle->SetCircleChoice(1)            ; // 0:From Begin, 1:From End, 2:Largest Amplitude 
													 Circle->SetCircleType(2)              ; // 0:Black to White, 1:White to Black 2: Both Black, White 
													 Circle->SetCircleIndex (1)            ; // Circle EdgePoint Index 
													 Circle->SetTolerance(40.0f )          ; // Circle Tolerance 
													 Circle->SetDiameter (C5Diameter)      ; // Circle Diameter 
													 // 										 Circle->SetCircleType(1)              ; // 0:Black to White, 1:White to Black 2: Both Black, White 
													 Circle->OnExecute()                   ;

													 // Circle In Data 기준 새로운 Circle Center 좌표 받아옴 
													 RealC5CirCenter.x = Circle->FCP.x;
													 RealC5CirCenter.y = Circle->FCP.y;

													 OrgC5CirStandEdgeCount = Circle->FCirclePointCount;
													 if(OrgC5CirStandEdgeCount>0){
														 if(OrgC5CirStandPoint!=NULL) delete[] OrgC5CirStandPoint;
														 OrgC5CirStandPoint = new TFPoint[OrgC5CirStandEdgeCount];

														 PreC5CirStandPoint[0].x=0.0f; PreC5CirStandPoint[0].y=0.0f;
														 for(int k=0; k<OrgC5CirStandEdgeCount; k++){
															 if(k>MAX_CIRCLE_EDGEPOINT) break;
															 OrgC5CirStandPoint[k].x = Circle->FCirclePoint[k].x;
															 OrgC5CirStandPoint[k].y = Circle->FCirclePoint[k].y;
															 if(OrgC5CirStandPoint[k].x==0.0f && OrgC5CirStandPoint[k].y==0.0f) C5CirStandEdgeCount++;
															 // TrackLine 자재 상태에 따라서 잘못된 EdgePoint를 찾을경우 대비하여 이전데이터 기준 데이터 복원 
															 if(OrgC5CirStandPoint[k].x!=0.0f && OrgC5CirStandPoint[k].y!=0.0f){
																 // 첫번째는 무조건 데이터 넘겨줌 
																 if(PreC5CirStandPoint[0].x==0.0f && PreC5CirStandPoint[0].y==0.0f){
																	 PreC5CirStandPoint[0].x = OrgC5CirStandPoint[k].x; 
																	 PreC5CirStandPoint[0].y = OrgC5CirStandPoint[k].y; 
																 }
																 else {
																	 if(fabs (OrgC5CirStandPoint[k].x-PreC5CirStandPoint[0].x)>TrackLineMargin ||
																		 fabs(OrgC5CirStandPoint[k].y-PreC5CirStandPoint[0].y)>TrackLineMargin   ){
																			 OrgC5CirStandPoint[k].x = PreC5CirStandPoint[0].x-0.5;
																			 OrgC5CirStandPoint[k].y = PreC5CirStandPoint[0].y-0.5;

																			 PreC5CirStandPoint[0].x = OrgC5CirStandPoint[k].x; 
																			 PreC5CirStandPoint[0].y = OrgC5CirStandPoint[k].y; 
																	 }
																	 else {
																		 PreC5CirStandPoint[0].x = OrgC5CirStandPoint[k].x; 
																		 PreC5CirStandPoint[0].y = OrgC5CirStandPoint[k].y; 
																	 }
																 }
															 }
														 }
														 //C5Circle Grind_Measure Calculate 
														 if(OrgC5CirOutEdgeCount==OrgC5CirStandEdgeCount){
															 double GrindMeaDis=0.0f, TotalGrindMeasure=0.0f, AvgGrindMeasure=0.0f; C5GrindMeasureCount=0;
															 for(int k=0; k<OrgC5CirInEdgeCount; k++){
																 if(OrgC5CirOutPoint[k].x==0.0f || OrgC5CirOutPoint[k].y==0.0f || OrgC5CirStandPoint[k].x==0.0f || OrgC5CirStandPoint[k].y==0.0f){
																	 GrindMeaDis =0.0f;
																 }
																 else {
																	 GrindMeaDis = Math.GetLengthFrPointToPoint(OrgC5CirStandPoint[k],OrgC5CirOutPoint[k]);
																 }

																 if(GrindMeaDis!=0.0f){
																	 TotalGrindMeasure+= GrindMeaDis;
																	 C5GrindMeasureCount++;
																 }
															 }
															 if(C5GrindMeasureCount!=0){
																 AvgGrindMeasure = (TotalGrindMeasure/C5GrindMeasureCount);
																 C5CirGrindMea= AvgGrindMeasure;
															 }
														 }
														 else if(OrgC5CirStandEdgeCount>OrgC5CirOutEdgeCount) { // 연마가 적게되어 실제 TrackLine보다 EdgePoint데이터가 적을경우 
															 double GrindMeaDis=0.0f, TotalGrindMeasure=0.0f, AvgGrindMeasure=0.0f;C5GrindMeasureCount=0;
															 for(int k=0; k<OrgC5CirOutEdgeCount; k++){
																 if(OrgC5CirOutPoint[k].x==0.0f || OrgC5CirOutPoint[k].y==0.0f || OrgC5CirStandPoint[k].x==0.0f || OrgC5CirStandPoint[k].y==0.0f ){
																	 GrindMeaDis =0.0f;
																 }
																 else {
																	 GrindMeaDis = Math.GetLengthFrPointToPoint(OrgC5CirStandPoint[k],OrgC5CirOutPoint[k]);
																 }

																 if(GrindMeaDis!=0.0f){
																	 TotalGrindMeasure+= GrindMeaDis;
																	 C5GrindMeasureCount++;
																 }
															 }
															 if(C5GrindMeasureCount!=0){
																 AvgGrindMeasure = (TotalGrindMeasure/C5GrindMeasureCount);
																 C5CirGrindMea= AvgGrindMeasure;
															 }
														 }
														 else if(OrgC5CirStandEdgeCount<OrgC5CirOutEdgeCount){
															 double GrindMeaDis=0.0f, TotalGrindMeasure=0.0f, AvgGrindMeasure=0.0f;C5GrindMeasureCount=0;
															 for(int k=0; k<OrgC5CirStandEdgeCount; k++){
																 if(OrgC5CirOutPoint[k].x==0.0f || OrgC5CirOutPoint[k].y==0.0f || OrgC5CirStandPoint[k].x==0.0f || OrgC5CirStandPoint[k].y==0.0f ){
																	 GrindMeaDis =0.0f;
																 }
																 else {
																	 GrindMeaDis = Math.GetLengthFrPointToPoint(OrgC5CirStandPoint[k],OrgC5CirOutPoint[k]);
																 }

																 if(GrindMeaDis!=0.0f){
																	 TotalGrindMeasure+= GrindMeaDis;
																	 C5GrindMeasureCount++;
																 }
															 }
															 if(C5GrindMeasureCount!=0){
																 AvgGrindMeasure = (TotalGrindMeasure/C5GrindMeasureCount);
																 C5CirGrindMea= AvgGrindMeasure;
															 }
														 }
													 }
												 }
											 }
										 }
										 else if(FInspectMode==Insp_Mark){ //MarkMode 
											 if(IsMarkBtm){ // LTPS 가공량 계산 ==> 연마량 계산 
												 if(OrgC5CirOutEdgeCount!=0 && OrgC5CirInEdgeCount!=0){ // 연마량이 존재할경우 가공량 검사를 진행함 
													 // 가공량,연마량 측정 전 데이터 존재시 가상GrindMark 생성한다 
													 if(GrindMarkPoint[13].x!=0.0f && GrindMarkPoint[13].y!=0.0f){
														 GrindMarkPoint[12].x     = GrindMarkPoint[13].x - GrindRectSpec[6].DvX;
														 GrindMarkPoint[12].y     = GrindMarkPoint[13].y - GrindRectSpec[6].DvY;
														 GrindMarkRect [12].left  = GrindMarkPoint[12].x    - GrindMarkRange   ;  
														 GrindMarkRect [12].top   = GrindMarkPoint[12].y    - GrindMarkRange   ;  
														 GrindMarkRect [12].right = GrindMarkRect [12].left + GrindMarkLength  ;  
														 GrindMarkRect [12].bottom= GrindMarkRect [12].top  + GrindMarkLength  ;  
													 }

													 // GrindMarkPoint12 Calc 진행함(연마량,가공량)
													 if(GrindMarkPoint[12].x!=0.0f && GrindMarkPoint[12].y!=0.0f){
														 GrindMeaDis =0.0f, MinDis =10000.0f; C5GrindMarkCount=0;
														 for(int k=0; k<OrgC5CirOutEdgeCount; k++){
															 if(OrgC5CirOutPoint[k].x==0.0f || OrgC5CirOutPoint[k].y==0.0f) continue;
															 if(GrindMarkPoint[12].x  ==0.0f || GrindMarkPoint[12].y  ==0.0f) continue;

															 GrindMeaDis = Math.GetLength(GrindMarkPoint[12], OrgC5CirOutPoint[k]);
															 if(GrindMeaDis<MinDis){
																 MinDis = GrindMeaDis;
																 C5GrindMarkCount = k;
															 }
														 }
														 // GrindMark기준 수직 포인트 주변값 Avg산출한다 
														 if(C5GrindMarkCount!=0 && C5GrindMarkCount>5 && (C5GrindMarkCount+5)<OrgC5CirOutEdgeCount){
															 CircleCount=0,TotalCirDis=0.0f,GrindMeaDis=0.0f;
															 for(int k=C5GrindMarkCount-5; k<C5GrindMarkCount+5; k++){
																 if(OrgC5CirOutPoint[k].x==0.0f || OrgC5CirOutPoint[k].y==0.0f) continue;

																 GrindMeaDis = Math.GetLength(GrindMarkPoint[12], OrgC5CirOutPoint[k]);
																 TotalCirDis+= GrindMeaDis;
																 CircleCount++;
															 }
															 if(TotalCirDis!=0.0f && CircleCount!=0){
																 TrenchRightGrindMea = TotalCirDis/CircleCount;
															 }
														 }
														 // GrindMark기준 수직 평균값 연마량 측정 
														 if(C5GrindMarkCount!=0 && C5GrindMarkCount>5 && (C5GrindMarkCount+5)<OrgC5CirOutEdgeCount){
															 CircleCount=0,TotalCirDis=0.0f,GrindWidthDis=0.0f;
															 for(int k=C5GrindMarkCount-5; k<C5GrindMarkCount+5; k++){
																 if(OrgC5CirOutPoint[k].x==0.0f && OrgC5CirOutPoint[k].y==0.0f) continue;
																 if(OrgC5CirInPoint [k].x==0.0f && OrgC5CirInPoint [k].y==0.0f) continue;
																 GrindWidthDis = Math.GetLength(OrgC5CirInPoint[k], OrgC5CirOutPoint[k]);
																 TotalCirDis+=   GrindWidthDis;
																 CircleCount++;
															 }
															 if(TotalCirDis!=0.0f && CircleCount!=0){
																 TrenchRightGrindWd = TotalCirDis/CircleCount;
															 }
														 }
													 }
													 else { // Grind Mark 못 찾았을경우 (가공량 0, 연마량 계산함)
														 GrindMeaDis =0.0f, MinDis =10000.0f; C5GrindMarkCount=0;
														 for(int k=0; k<OrgC5CirOutEdgeCount; k++){
															 if(OrgC5CirOutPoint[k].x==0.0f || OrgC5CirOutPoint[k].y==0.0f) continue;

															 if(k==0){
																 GrindMarkRectCenter[13].x = GrindMarkRect[13].left + (GrindMarkRect[13].right  - GrindMarkRect[13].left)/2; 
																 GrindMarkRectCenter[13].y = GrindMarkRect[13].top  + (GrindMarkRect[13].bottom - GrindMarkRect[13].top )/2; 

																 GrindMarkRectCenter[12].x = GrindMarkRectCenter[13].x - GrindRectSpec[6].DvX;
																 GrindMarkRectCenter[12].y = GrindMarkRectCenter[13].y - GrindRectSpec[6].DvY;

																 GrindMarkRect [12].left  =  GrindMarkRectCenter[12].x   - GrindMarkRange   ;  
																 GrindMarkRect [12].top   =  GrindMarkRectCenter[12].y   - GrindMarkRange   ;  
																 GrindMarkRect [12].right =  GrindMarkRect [12].left + GrindMarkLength  ;  
																 GrindMarkRect [12].bottom=  GrindMarkRect [12].top  + GrindMarkLength  ;  
															 }

															 // 														 GrindMarkRectPoint5.x = GrindMarkRect[12].left + (GrindMarkRect[12].right  - GrindMarkRect[12].left)/2; 
															 // 														 GrindMarkRectPoint5.y = GrindMarkRect[12].top  + (GrindMarkRect[12].bottom - GrindMarkRect[12].top )/2; 

															 GrindMeaDis = Math.GetLength( GrindMarkRectCenter[12], OrgC5CirOutPoint[k]);
															 if(GrindMeaDis<MinDis){
																 MinDis = GrindMeaDis;
																 C5GrindMarkCount = k;
															 }
														 }
														 // GrindMark기준 수직 평균값 연마량 측정 
														 if(C5GrindMarkCount!=0 && C5GrindMarkCount>5 && (C5GrindMarkCount+5)<OrgC5CirOutEdgeCount){
															 CircleCount=0,TotalCirDis=0.0f,GrindWidthDis=0.0f;
															 for(int k=C5GrindMarkCount-5; k<C5GrindMarkCount+5; k++){
																 if(OrgC5CirOutPoint[k].x==0.0f && OrgC5CirOutPoint[k].y==0.0f) continue;
																 if(OrgC5CirInPoint [k].x==0.0f && OrgC5CirInPoint [k].y==0.0f) continue;
																 GrindWidthDis = Math.GetLength(OrgC5CirInPoint[k], OrgC5CirOutPoint[k]);
																 TotalCirDis+=   GrindWidthDis;
																 CircleCount++;
															 }
															 if(TotalCirDis!=0.0f && CircleCount!=0){
																 TrenchRightGrindWd = TotalCirDis/CircleCount;
															 }
														 }
													 }


													 // GrindMarkPoint13 Calc 진행함(연마량,가공량)
													 if(GrindMarkPoint[13].x!=0.0f && GrindMarkPoint[13].y!=0.0f){
														 GrindMeaDis =0.0f, MinDis =10000.0f; C5GrindMarkCount=0;
														 for(int k=0; k<OrgC5CirOutEdgeCount; k++){
															 if(OrgC5CirOutPoint[k].x==0.0f || OrgC5CirOutPoint[k].y==0.0f) continue;
															 if(GrindMarkPoint[13].x  ==0.0f || GrindMarkPoint[13].y  ==0.0f) continue;

															 GrindMeaDis = Math.GetLength(GrindMarkPoint[13], OrgC5CirOutPoint[k]);
															 if(GrindMeaDis<MinDis){
																 MinDis = GrindMeaDis;
																 C5GrindMarkCount = k;
															 }
														 }
														 // GrindMark기준 수직 포인트 주변값 Avg산출한다 
														 if(C5GrindMarkCount!=0 && C5GrindMarkCount>5){
															 CircleCount=0,TotalCirDis=0.0f,GrindMeaDis=0.0f;
															 for(int k=C5GrindMarkCount-5; k<C5GrindMarkCount+5; k++){
																 if(OrgC5CirOutPoint[k].x==0.0f || OrgC5CirOutPoint[k].y==0.0f) continue;

																 GrindMeaDis = Math.GetLength(GrindMarkPoint[13], OrgC5CirOutPoint[k]);
																 TotalCirDis+= GrindMeaDis;
																 CircleCount++;
															 }
															 if(TotalCirDis!=0.0f && CircleCount!=0){
																 C5CirGrindMea = TotalCirDis/CircleCount;
															 }
														 }
														 // GrindMark기준 수직 평균값 연마량 측정 
														 if(C5GrindMarkCount!=0 && C5GrindMarkCount>5){
															 CircleCount=0,TotalCirDis=0.0f,GrindWidthDis=0.0f;
															 for(int k=C5GrindMarkCount-5; k<C5GrindMarkCount+5; k++){
																 if(OrgC5CirOutPoint[k].x==0.0f && OrgC5CirOutPoint[k].y==0.0f) continue;
																 if(OrgC5CirInPoint [k].x==0.0f && OrgC5CirInPoint [k].y==0.0f) continue;
																 GrindWidthDis = Math.GetLength(OrgC5CirInPoint[k], OrgC5CirOutPoint[k]);
																 TotalCirDis+=   GrindWidthDis;
																 CircleCount++;
															 }
															 if(TotalCirDis!=0.0f && CircleCount!=0){
																 C5CirGrindWd = TotalCirDis/CircleCount;
															 }
														 }
													 }
													 else { // Grind Mark 못 찾았을경우 (가공량 0, 연마량 계산함)
														 GrindMeaDis =0.0f, MinDis =10000.0f; C5GrindMarkCount=0;
														 for(int k=0; k<OrgC5CirOutEdgeCount; k++){
															 if(OrgC5CirOutPoint[k].x==0.0f || OrgC5CirOutPoint[k].y==0.0f) continue;

															 GrindMarkRectCenter[13].x = GrindMarkRect[13].left + (GrindMarkRect[13].right  - GrindMarkRect[13].left)/2; 
															 GrindMarkRectCenter[13].y = GrindMarkRect[13].top  + (GrindMarkRect[13].bottom - GrindMarkRect[13].top )/2; 

															 GrindMeaDis = Math.GetLength( GrindMarkRectCenter[13], OrgC5CirOutPoint[k]);
															 if(GrindMeaDis<MinDis){
																 MinDis = GrindMeaDis;
																 C5GrindMarkCount = k;
															 }
														 }
														 // GrindMark기준 수직 평균값 연마량 측정 
														 if(C5GrindMarkCount!=0 && C5GrindMarkCount>5){
															 CircleCount=0,TotalCirDis=0.0f,GrindWidthDis=0.0f;
															 for(int k=C5GrindMarkCount-5; k<C5GrindMarkCount+5; k++){
																 if(OrgC5CirOutPoint[k].x==0.0f && OrgC5CirOutPoint[k].y==0.0f) continue;
																 if(OrgC5CirInPoint [k].x==0.0f && OrgC5CirInPoint [k].y==0.0f) continue;
																 GrindWidthDis = Math.GetLength(OrgC5CirInPoint[k], OrgC5CirOutPoint[k]);
																 TotalCirDis+=   GrindWidthDis;
																 CircleCount++;
															 }
															 if(TotalCirDis!=0.0f && CircleCount!=0){
																 C5CirGrindWd = TotalCirDis/CircleCount;
															 }
														 }
													 }
												 }
											 }
											 else         {// EnCap 가공량 계산 
												 if(OrgC5CirInEdgeCount==OrgC5CirOutEdgeCount){
													 double OutDis=0.0f, InDis=0.0f, TotalGrindWidth=0.0f, AvgGrindWidth=0.0f;C5GrindWidthCount=0;
													 for(int k=0; k<OrgC5CirInEdgeCount; k++){
														 if(OrgC5CirOutPoint[k].x==0.0f && OrgC5CirOutPoint[k].y==0.0f){
															 OutDis =0.0f;
														 }
														 else {
															 OutDis = Math.GetLengthFrPointToPoint(C5CirCenter,OrgC5CirOutPoint[k]);
														 }

														 if(OrgC5CirInPoint[k].x==0.0f && OrgC5CirInPoint[k].y==0.0f){
															 InDis =0.0f;
														 }
														 else {
															 InDis = Math.GetLengthFrPointToPoint(C5CirCenter,OrgC5CirInPoint[k]);
														 }

														 if(OutDis!=0.0f && InDis!=0.0f){
															 TotalGrindWidth+=(OutDis - InDis);
															 C5GrindWidthCount++;
														 }
													 }
													 if(C5GrindWidthCount!=0){
														 AvgGrindWidth = (TotalGrindWidth/C5GrindWidthCount);
														 C5CirGrindWd = AvgGrindWidth;
													 }
												 }
											 }
										 }
										 // C5Circle 연마량 가공량 검사 시퀀스 종료(TrackMode VS MarkMode)
										 //////////////////////////////////////////////////////////////////////////////////////////////////////

										 // Org Circle데이터중 유호하지 않은 값을 제외한 실제 존재하는 데이터 기준으로 동적 메모리 생성함
										 // Circle Defect검사에 필요한 Edge데이터 값
										 int Count=0;
										 if(OrgC5CirInEdgeCount>0){
											 C5CirInEdgeCount = OrgC5CirInEdgeCount - C5CirInEdgeCount;
											 // 										 C5CirInEdgeCount = OrgC5CirInEdgeCount;
											 if(C5CirInEdgeCount>0){
												 if(C5CirInPoint!=NULL) delete[] C5CirInPoint;
												 C5CirInPoint = new TFPoint[C5CirInEdgeCount];

												 for(int k=0; k<OrgC5CirInEdgeCount; k++){
													 if(k>MAX_CIRCLE_EDGEPOINT) break;
													 if(OrgC5CirInPoint[k].x==0.0f && OrgC5CirInPoint[k].y==0.0f) continue;
													 C5CirInPoint[Count].x = OrgC5CirInPoint[k].x;
													 C5CirInPoint[Count].y = OrgC5CirInPoint[k].y;
													 Count++;
												 }
											 }
											 // Circle 원본 데이터 메모리 삭제
											 if(OrgC5CirInPoint!=NULL) delete[] OrgC5CirInPoint;
										 }
										 // Circle Fitting 결과물 
										 SampleSize = C5CirInEdgeCount*0.75; //0.5~0.8이하로 입력할것
										 DistDevRatio = 0.15; //0.1~0.25 이하로 입력할것
										 // 									Radius = 0;
										 CircleFit->OnRansac(C5CirInPoint,C5CirInEdgeCount,SampleSize,DistDevRatio,&CircleFit5Center,&CirFitDiameter5);

										 if(OrgC5CirOutEdgeCount>0){
											 C5CirOutEdgeCount = OrgC5CirOutEdgeCount - C5CirOutEdgeCount;
											 Count =0;
											 if(C5CirOutEdgeCount>0){
												 if(C5CirOutPoint!=NULL) delete[] C5CirOutPoint;
												 C5CirOutPoint = new TFPoint[C5CirOutEdgeCount];

												 for(int k=0; k<OrgC5CirOutEdgeCount; k++){
													 if(k>MAX_CIRCLE_EDGEPOINT) break;
													 if(OrgC5CirOutPoint[k].x==0.0f && OrgC5CirOutPoint[k].y==0.0f) continue;
													 C5CirOutPoint[Count].x = OrgC5CirOutPoint[k].x;
													 C5CirOutPoint[Count].y = OrgC5CirOutPoint[k].y;
													 Count++;
												 }
											 }
											 // Circle 원본 데이터 메모리 삭제
											 if(OrgC5CirOutPoint!=NULL) delete[] OrgC5CirOutPoint;
										 }
										 if(OrgC5CirStandEdgeCount>0){
											 C5CirStandEdgeCount = OrgC5CirStandEdgeCount - C5CirStandEdgeCount;
											 // 										 C5CirStandEdgeCount = OrgC5CirStandEdgeCount;
											 Count =0;
											 if(C5CirStandEdgeCount>0){
												 if(C5CirStandPoint!=NULL) delete[] C5CirStandPoint;
												 C5CirStandPoint = new TFPoint[C5CirStandEdgeCount];

												 for(int k=0; k<OrgC5CirStandEdgeCount; k++){
													 if(k>MAX_CIRCLE_EDGEPOINT) break;
													 if(OrgC5CirStandPoint[k].x==0.0f && OrgC5CirStandPoint[k].y==0.0f) continue;
													 C5CirStandPoint[Count].x = OrgC5CirStandPoint[k].x;
													 C5CirStandPoint[Count].y = OrgC5CirStandPoint[k].y;
													 Count++;
												 }
											 }
											 // Circle 원본 데이터 메모리 삭제
											 if(OrgC5CirStandPoint!=NULL) delete[] OrgC5CirStandPoint;
										 }
										 LogUnit.SetLog(L"Circle_5_Insp_End");
										 // Circle 영역 꽃박리, 원형박리 검출 목적 시퀀스(EnCap)
										 // 정식 명칭은 몰라서.....일단 Crack으로 정함 
										 if(!IsMarkBtm && BrokenThresHold!=0){
											 if(CirFitDiameter5!=0.0f && CircleFit5Center.x!=0.0f && CircleFit5Center.y!=0.0f){ // FAVION Circle Fitting 성공시 박리검사 진행 
												 Circle->GImage = &RotateBrokenImg;                                             //Binary Image 넘겨줌 

												 Circle->SetCenterXY(CircleFit5Center.x,CircleFit5Center.y)       ;
												 Circle->SetTolerance((dEdgeToTrapLineDis/2)-CirOffsetMargin)     ; // Circle Tolerance 
												 Circle->SetDiameter ((CirFitDiameter5-(dEdgeToTrapLineDis/2))*2); // Circle Diameter 
												 Circle->SetCircleChoice(0)                                       ; // 0:From Begin, 1:From End, 2:Largest Amplitude 
												 Circle->SetCircleType  (2)                                       ; // 0:Black to White, 1:White to Black 2: Both Black, White 
												 Circle->SetCircleIndex (0)                                       ; // Circle EdgePoint Index 
												 Circle->OnExecute(true)                                          ;
												 CrackCirDiameter5 = (CirFitDiameter5-(dEdgeToTrapLineDis/2))+((dEdgeToTrapLineDis/2)-CirOffsetMargin);

												 C5CirInCrackCount = Circle->FCirclePointCount;

												 if(C5CirInCrackCount>0){
													 if(C5CirInCrackPoint!=NULL) delete[] C5CirInCrackPoint;
													 C5CirInCrackPoint = new TFPoint[C5CirInCrackCount];

													 for(int k=0; k<C5CirInCrackCount; k++){
														 if(k>MAX_CIRCLE_EDGEPOINT) break;
														 C5CirInCrackPoint[k].x = Circle->FCirclePoint[k].x;
														 C5CirInCrackPoint[k].y = Circle->FCirclePoint[k].y;
													 }
												 }
											 }
										 }
									 }

									 // 여섯번째 Circle EdgePoint Data 추출 
									 if(C6CirCenter.x!=0 && C6CirCenter.y!=0){
										 LogUnit.SetLog(L"Circle_6_Insp_Start");

										 // 									 if(BtmEdgeThresHold==0) Circle->GImage = &RotateImg      ; //Org Image 넘겨줌 
										 // 									 else                    Circle->GImage = &RotateBinaryImg; //Binary Image 넘겨줌 

										 if(CirGrindInThresHold==0) Circle->GImage = &RotateImg             ; //Org Image 넘겨줌 
										 else                       Circle->GImage = &RotateGrindInBinaryImg; //Binary Image 넘겨줌 

										 if      (FInspectMode==Insp_Track) Circle->SetCenterXY(TrackC6CirCenter.x , TrackC6CirCenter.y); // TrackLine 교차점 기준 센터 
										 else if (FInspectMode==Insp_Mark ) Circle->SetCenterXY(C6CirCenter.x      , C6CirCenter.y     ); // 외곽라인 교차점 기준 센터 
										 // Diameter 계산함(OutCircle과 TrackCircle 중간값 기준)
										 // 									 C6Diameter = ((CSideCircleWidth*2)+(TrackCircleWidth*2))/2;
										 C6Diameter = (CSideCircleWidth*2);
										 // 									 C6Diameter = (CSideCircleWidth*2);
										 if(IsMarkBtm) Circle->SetTolerance(60.0f);
										 else          Circle->SetTolerance(80.0f);
										 // 									 Circle->SetTolerance(40.0f )         ; // Circle Tolerance 
										 Circle->SetDiameter (C6Diameter)     ; // Circle Diameter 
										 // 									 Circle->SetCircleChoice(0)           ; // 0:From Begin, 1:From End, 2:Largest Amplitude 
										 // 									 Circle->SetCircleIndex (0)           ; // Circle EdgePoint Index 
										 Circle->SetCircleChoice(1)           ; // 0:From Begin, 1:From End, 2:Largest Amplitude 
										 Circle->SetCircleType  (2)           ; // 0:Black to White, 1:White to Black 2: Both Black, White 
										 Circle->SetCircleIndex (1)           ; // Circle EdgePoint Index 

										 // 									 Circle->SetAngle(0)                  ; // Cirlce Angle 
										 // 									 Circle->SetAmplitude(90)             ; // Circle Amplitude
										 if(SideCirDeg>=0){
											 if(90-SideCirDeg>=0) Circle->SetAngle(90-SideCirDeg+CirAngleMargin   );  // Circle Fitting 시작점 각도
											 Circle->SetAmplitude(SideCirDeg-2*CirAngleMargin);  // Circle Fitting 시작점 부터 검사 범위 
										 }

										 // 									 Circle->SetCircleType(1)             ; // 0:Black to White, 1:White to Black 2: Both Black, White 
										 Circle->OnExecute()                  ;

										 // Circle In Data 기준 새로운 Circle Center 좌표 받아옴 
										 RealC6CirCenter.x = Circle->FCP.x;
										 RealC6CirCenter.y = Circle->FCP.y;
										 CirDiameter6      = (Circle->Diameter)/2.0;

										 // Circle In Data취합 
										 OrgC6CirInEdgeCount = Circle->FCirclePointCount;
										 if(OrgC6CirInEdgeCount>0){
											 if(OrgC6CirInPoint!=NULL) delete[] OrgC6CirInPoint;
											 OrgC6CirInPoint = new TFPoint[OrgC6CirInEdgeCount];

											 for(int k=0; k<OrgC6CirInEdgeCount; k++){
												 if(k>MAX_CIRCLE_EDGEPOINT) break;
												 OrgC6CirInPoint[k].x = Circle->FCirclePoint[k].x;
												 OrgC6CirInPoint[k].y = Circle->FCirclePoint[k].y;
												 if(OrgC6CirInPoint[k].x==0.0f && OrgC6CirInPoint[k].y==0.0f) C6CirInEdgeCount++;
												 // BTM영역 Circle을 제외한 영역 Defect검사 목적에 좌표계산 
												 // 											 if(k==0) {BtmEdgePoint1.x = C1CirInPoint[k].x; BtmEdgePoint1.y = C1CirInPoint[k].y;}
											 }
										 }

										 // Circle Out Data목적 다시 검사  
										 if(BtmEdgeThresHold==0) Circle->GImage = &RotateImg      ; //Org Image 넘겨줌 
										 else                    Circle->GImage = &RotateBinaryImg; //Binary Image 넘겨줌 

										 if(IsMarkBtm) Circle->SetTolerance(60.0f);
										 else          Circle->SetTolerance(80.0f);
										 // 									 Circle->SetTolerance(40.0f )                      ; // Circle Tolerance 
										 Circle->SetDiameter (C6Diameter)                  ; // Circle Diameter 
										 // 									 Circle->SetCircleType(0)                          ; // 0:Black to White, 1:White to Black 2: Both Black, White 
										 Circle->SetCircleChoice(1)                        ; // 0:From Begin, 1:From End, 2:Largest Amplitude 
										 Circle->SetCircleType  (2)                        ; // 0:Black to White, 1:White to Black 2: Both Black, White 
										 Circle->SetCircleIndex (0)                        ; // Circle EdgePoint Index 

										 Circle->OnExecute()                               ;

										 // Circle Out Data취합 
										 OrgC6CirOutEdgeCount = Circle->FCirclePointCount;
										 if(OrgC6CirOutEdgeCount>0){
											 if(OrgC6CirOutPoint!=NULL) delete[] OrgC6CirOutPoint;
											 OrgC6CirOutPoint = new TFPoint[OrgC6CirOutEdgeCount];

											 for(int k=0; k<OrgC6CirOutEdgeCount; k++){
												 if(k>MAX_CIRCLE_EDGEPOINT) break;
												 OrgC6CirOutPoint[k].x = Circle->FCirclePoint[k].x;
												 OrgC6CirOutPoint[k].y = Circle->FCirclePoint[k].y;
												 // BTM영역 Circle을 제외한 영역 Defect검사 목적에 좌표계산 
												 if(k==(OrgC6CirOutEdgeCount-1)) {BtmEdgePoint[9].x = OrgC6CirOutPoint[k].x; BtmEdgePoint[9].y = OrgC6CirOutPoint[k].y;}
												 if(OrgC6CirOutPoint[k].x==0.0f && OrgC6CirOutPoint[k].y==0.0f) C6CirOutEdgeCount++;
											 }
										 }
										 // C6Circle Grind_Width, Grind_Measure 
										 // C6Circle 연마량 가공량 검사 시퀀스 시작(TrackMode VS MarkMode)
										 if(FInspectMode==Insp_Track){
											 if(OrgC6CirInEdgeCount==OrgC6CirOutEdgeCount){//연마량 계산 
												 double OutDis=0.0f, InDis=0.0f, TotalGrindWidth=0.0f, AvgGrindWidth=0.0f; C6GrindWidthCount=0;
												 for(int k=0; k<OrgC6CirInEdgeCount; k++){
													 if(OrgC6CirOutPoint[k].x==0.0f && OrgC6CirOutPoint[k].y==0.0f){
														 OutDis =0.0f;
													 }
													 else {
														 OutDis = Math.GetLengthFrPointToPoint(C6CirCenter,OrgC6CirOutPoint[k]);
													 }

													 if(OrgC6CirInPoint[k].x==0.0f && OrgC6CirInPoint[k].y==0.0f){
														 InDis =0.0f;
													 }
													 else {
														 InDis = Math.GetLengthFrPointToPoint(C6CirCenter,OrgC6CirInPoint[k]);
													 }

													 if(OutDis!=0.0f && InDis!=0.0f){
														 TotalGrindWidth+=(OutDis - InDis);
														 C6GrindWidthCount++;
													 }
												 }
												 if(C6GrindWidthCount!=0){
													 AvgGrindWidth = (TotalGrindWidth/C6GrindWidthCount);
													 C6CirGrindWd = AvgGrindWidth;
												 }
											 }
											 if(IsMarkBtm){ // LTPS 가공량 계산 
												 if(CirGrindMeaThresHold!=0){
													 Circle->GImage = &RotateGrindBinaryImg  ; //Binary Image 넘겨줌 
													 Circle->SetCircleChoice(1)                ; // 0:From Begin, 1:From End, 2:Largest Amplitude 
													 Circle->SetCircleType(2)                  ; // 0:Black to White, 1:White to Black 2: Both Black, White 
													 Circle->SetCircleIndex (1)                ; // Circle EdgePoint Index 

													 Circle->SetTolerance(40.0f )            ; // Circle Tolerance 
													 Circle->SetDiameter (C6Diameter)        ; // Circle Diameter 
													 // 										 Circle->SetCircleType(1)                ; // 0:Black to White, 1:White to Black 2: Both Black, White 
													 Circle->OnExecute()                     ;

													 // Circle In Data 기준 새로운 Circle Center 좌표 받아옴 
													 RealC6CirCenter.x = Circle->FCP.x;
													 RealC6CirCenter.y = Circle->FCP.y;

													 OrgC6CirStandEdgeCount = Circle->FCirclePointCount;
													 if(OrgC6CirStandEdgeCount>0){
														 if(OrgC6CirStandPoint!=NULL) delete[] OrgC6CirStandPoint;
														 OrgC6CirStandPoint = new TFPoint[OrgC6CirStandEdgeCount];

														 PreC6CirStandPoint[0].x=0.0f; PreC6CirStandPoint[0].y=0.0f;
														 for(int k=0; k<OrgC6CirStandEdgeCount; k++){
															 if(k>MAX_CIRCLE_EDGEPOINT) break;
															 OrgC6CirStandPoint[k].x = Circle->FCirclePoint[k].x;
															 OrgC6CirStandPoint[k].y = Circle->FCirclePoint[k].y;
															 if(OrgC6CirStandPoint[k].x==0.0f && OrgC6CirStandPoint[k].y==0.0f) C6CirStandEdgeCount++;
															 // TrackLine 자재 상태에 따라서 잘못된 EdgePoint를 찾을경우 대비하여 이전데이터 기준 데이터 복원 
															 if(OrgC6CirStandPoint[k].x!=0.0f && OrgC6CirStandPoint[k].y!=0.0f){
																 // 첫번째는 무조건 데이터 넘겨줌 
																 if(PreC6CirStandPoint[0].x==0.0f && PreC6CirStandPoint[0].y==0.0f){
																	 PreC6CirStandPoint[0].x = OrgC6CirStandPoint[k].x; 
																	 PreC6CirStandPoint[0].y = OrgC6CirStandPoint[k].y; 
																 }
																 else {
																	 if(fabs (OrgC6CirStandPoint[k].x-PreC6CirStandPoint[0].x)>TrackLineMargin ||
																		 fabs(OrgC6CirStandPoint[k].y-PreC6CirStandPoint[0].y)>TrackLineMargin   ){
																			 OrgC6CirStandPoint[k].x = PreC6CirStandPoint[0].x-0.5;
																			 OrgC6CirStandPoint[k].y = PreC6CirStandPoint[0].y+0.5;

																			 PreC6CirStandPoint[0].x = OrgC6CirStandPoint[k].x; 
																			 PreC6CirStandPoint[0].y = OrgC6CirStandPoint[k].y; 
																	 }
																	 else {
																		 PreC6CirStandPoint[0].x = OrgC6CirStandPoint[k].x; 
																		 PreC6CirStandPoint[0].y = OrgC6CirStandPoint[k].y; 
																	 }
																 }
															 }
														 }
														 //C6Circle Grind_Measure Calculate 
														 if(OrgC6CirOutEdgeCount==OrgC6CirStandEdgeCount){
															 double GrindMeaDis=0.0f, TotalGrindMeasure=0.0f, AvgGrindMeasure=0.0f; C6GrindMeasureCount=0;
															 for(int k=0; k<OrgC6CirInEdgeCount; k++){
																 if(OrgC6CirOutPoint[k].x==0.0f || OrgC6CirOutPoint[k].y==0.0f || OrgC6CirStandPoint[k].x==0.0f || OrgC6CirStandPoint[k].y==0.0f){
																	 GrindMeaDis =0.0f;
																 }
																 else {
																	 GrindMeaDis = Math.GetLengthFrPointToPoint(OrgC6CirStandPoint[k],OrgC6CirOutPoint[k]);
																 }

																 if(GrindMeaDis!=0.0f){
																	 TotalGrindMeasure+= GrindMeaDis;
																	 C6GrindMeasureCount++;
																 }
															 }
															 if(C6GrindMeasureCount!=0){
																 AvgGrindMeasure = (TotalGrindMeasure/C6GrindMeasureCount);
																 C6CirGrindMea= AvgGrindMeasure;
															 }
														 }
														 else if(OrgC6CirStandEdgeCount>OrgC6CirOutEdgeCount){ // 연마가 적게되어 실제 TrackLine보다 EdgePoint데이터가 적을경우 
															 double GrindMeaDis=0.0f, TotalGrindMeasure=0.0f, AvgGrindMeasure=0.0f;
															 for(int k=0; k<OrgC6CirStandEdgeCount; k++){
																 if(OrgC6CirOutPoint[k].x==0.0f || OrgC6CirOutPoint[k].y==0.0f || OrgC6CirStandPoint[k].x==0.0f || OrgC6CirStandPoint[k].y==0.0f ){
																	 GrindMeaDis =0.0f;
																 }
																 else {
																	 GrindMeaDis = Math.GetLengthFrPointToPoint(OrgC6CirStandPoint[k],OrgC6CirOutPoint[k]);
																 }

																 if(GrindMeaDis!=0.0f){
																	 TotalGrindMeasure+= GrindMeaDis;
																	 C6GrindMeasureCount++;
																 }
															 }
															 if(C6GrindMeasureCount!=0){
																 AvgGrindMeasure = (TotalGrindMeasure/C6GrindMeasureCount);
																 C6CirGrindMea= AvgGrindMeasure;
															 }
														 }
														 else if(OrgC6CirStandEdgeCount<OrgC6CirOutEdgeCount){
															 double GrindMeaDis=0.0f, TotalGrindMeasure=0.0f, AvgGrindMeasure=0.0f;
															 for(int k=0; k<OrgC6CirStandEdgeCount; k++){
																 if(OrgC6CirOutPoint[k].x==0.0f || OrgC6CirOutPoint[k].y==0.0f || OrgC6CirStandPoint[k].x==0.0f || OrgC6CirStandPoint[k].y==0.0f ){
																	 GrindMeaDis =0.0f;
																 }
																 else {
																	 GrindMeaDis = Math.GetLengthFrPointToPoint(OrgC6CirStandPoint[k],OrgC6CirOutPoint[k]);
																 }

																 if(GrindMeaDis!=0.0f){
																	 TotalGrindMeasure+= GrindMeaDis;
																	 C6GrindMeasureCount++;
																 }
															 }
															 if(C6GrindMeasureCount!=0){
																 AvgGrindMeasure = (TotalGrindMeasure/C6GrindMeasureCount);
																 C6CirGrindMea= AvgGrindMeasure;
															 }
														 }
													 }
												 }
											 }
										 }
										 else if(FInspectMode==Insp_Mark){ // MarkMode 
											 if(IsMarkBtm){ // LTPS 가공량 계산 ==> 연마량 계산 
												 if(OrgC6CirOutEdgeCount!=0 && OrgC6CirInEdgeCount!=0){// 연마량이 존재할경우 가공량 검사를 진행함 
													 GrindMeaDis =0.0f, MinDis =10000.0f; C6GrindMarkCount=0;
													 if(GrindMarkPoint[17].x!=0.0f && GrindMarkPoint[17].y!=0.0f){
														 for(int k=0; k<OrgC6CirOutEdgeCount; k++){
															 if(OrgC6CirOutPoint[k].x==0.0f || OrgC6CirOutPoint[k].y==0.0f) continue;
															 if(GrindMarkPoint[17].x  ==0.0f || GrindMarkPoint[17].y  ==0.0f) continue;

															 GrindMeaDis = Math.GetLength(GrindMarkPoint[17], OrgC6CirOutPoint[k]);
															 if(GrindMeaDis<MinDis){
																 MinDis = GrindMeaDis;
																 C6GrindMarkCount = k;
															 }
														 }
														 // GrindMark기준 수직 포인트 주변값 Avg산출한다 
														 if(C6GrindMarkCount!=0 && C6GrindMarkCount>5){
															 CircleCount=0,TotalCirDis=0.0f,GrindMeaDis=0.0f;
															 for(int k=C6GrindMarkCount-5; k<C6GrindMarkCount+5; k++){
																 if(OrgC6CirOutPoint[k].x==0.0f || OrgC6CirOutPoint[k].y==0.0f) continue;

																 GrindMeaDis = Math.GetLength(GrindMarkPoint[17], OrgC6CirOutPoint[k]);
																 TotalCirDis+= GrindMeaDis;
																 CircleCount++;
															 }
															 if(TotalCirDis!=0.0f && CircleCount!=0){
																 C6CirGrindMea = TotalCirDis/CircleCount;
															 }
														 }
														 // GrindMark기준 수직 평균값 연마량 측정 
														 if(C6GrindMarkCount!=0 && C6GrindMarkCount>5){
															 CircleCount=0,TotalCirDis=0.0f,GrindWidthDis=0.0f;
															 for(int k=C6GrindMarkCount-5; k<C6GrindMarkCount+5; k++){
																 if(OrgC6CirOutPoint[k].x==0.0f && OrgC6CirOutPoint[k].y==0.0f) continue;
																 if(OrgC6CirInPoint [k].x==0.0f && OrgC6CirInPoint [k].y==0.0f) continue;
																 GrindWidthDis = Math.GetLength(OrgC6CirInPoint[k], OrgC6CirOutPoint[k]);
																 TotalCirDis+=   GrindWidthDis;
																 CircleCount++;
															 }
															 if(TotalCirDis!=0.0f && CircleCount!=0){
																 C6CirGrindWd = TotalCirDis/CircleCount;
															 }
														 }
													 }
													 else { // Grind Mark 못 찾았을경우 (가공량 0, 연마량 계산함)
														 for(int k=0; k<OrgC6CirOutEdgeCount; k++){
															 if(OrgC6CirOutPoint[k].x==0.0f || OrgC6CirOutPoint[k].y==0.0f) continue;

															 GrindMarkRectCenter[17].x = GrindMarkRect[17].left + (GrindMarkRect[17].right  - GrindMarkRect[17].left)/2; 
															 GrindMarkRectCenter[17].y = GrindMarkRect[17].top  + (GrindMarkRect[17].bottom - GrindMarkRect[17].top )/2; 

															 GrindMeaDis = Math.GetLength(GrindMarkRectCenter[17], OrgC6CirOutPoint[k]);
															 if(GrindMeaDis<MinDis){
																 MinDis = GrindMeaDis;
																 C6GrindMarkCount = k;
															 }
														 }
														 // GrindMark기준 수직 평균값 연마량 측정 
														 if(C6GrindMarkCount!=0 && C6GrindMarkCount>5){
															 CircleCount=0,TotalCirDis=0.0f,GrindWidthDis=0.0f;
															 for(int k=C6GrindMarkCount-5; k<C6GrindMarkCount+5; k++){
																 if(OrgC6CirOutPoint[k].x==0.0f && OrgC6CirOutPoint[k].y==0.0f) continue;
																 if(OrgC6CirInPoint [k].x==0.0f && OrgC6CirInPoint [k].y==0.0f) continue;
																 GrindWidthDis = Math.GetLength(OrgC6CirInPoint[k], OrgC6CirOutPoint[k]);
																 TotalCirDis+=   GrindWidthDis;
																 CircleCount++;
															 }
															 if(TotalCirDis!=0.0f && CircleCount!=0){
																 C6CirGrindWd = TotalCirDis/CircleCount;
															 }
														 }
														 // GrindMark기준 수직 평균값 연마량 측정 
														 if(C6GrindMarkCount!=0 && C6GrindMarkCount>5){
															 CircleCount=0,TotalCirDis=0.0f,GrindWidthDis=0.0f;
															 for(int k=C6GrindMarkCount-5; k<C6GrindMarkCount+5; k++){
																 if(OrgC6CirOutPoint[k].x==0.0f && OrgC6CirOutPoint[k].y==0.0f) continue;
																 if(OrgC6CirInPoint [k].x==0.0f && OrgC6CirInPoint [k].y==0.0f) continue;
																 GrindWidthDis = Math.GetLength(OrgC6CirInPoint[k], OrgC6CirOutPoint[k]);
																 TotalCirDis+=   GrindWidthDis;
																 CircleCount++;
															 }
															 if(TotalCirDis!=0.0f && CircleCount!=0){
																 C6CirGrindWd = TotalCirDis/CircleCount;
															 }
														 }
													 }
												 }
											 }
											 else          { // EnCap 연마량 계산 
												 if(OrgC6CirInEdgeCount==OrgC6CirOutEdgeCount){//연마량 계산 
													 double OutDis=0.0f, InDis=0.0f, TotalGrindWidth=0.0f, AvgGrindWidth=0.0f; C6GrindWidthCount=0;
													 for(int k=0; k<OrgC6CirInEdgeCount; k++){
														 if(OrgC6CirOutPoint[k].x==0.0f && OrgC6CirOutPoint[k].y==0.0f){
															 OutDis =0.0f;
														 }
														 else {
															 OutDis = Math.GetLengthFrPointToPoint(C6CirCenter,OrgC6CirOutPoint[k]);
														 }

														 if(OrgC6CirInPoint[k].x==0.0f && OrgC6CirInPoint[k].y==0.0f){
															 InDis =0.0f;
														 }
														 else {
															 InDis = Math.GetLengthFrPointToPoint(C6CirCenter,OrgC6CirInPoint[k]);
														 }

														 if(OutDis!=0.0f && InDis!=0.0f){
															 TotalGrindWidth+=(OutDis - InDis);
															 C6GrindWidthCount++;
														 }
													 }
													 if(C6GrindWidthCount!=0){
														 AvgGrindWidth = (TotalGrindWidth/C6GrindWidthCount);
														 C6CirGrindWd = AvgGrindWidth;
													 }
												 }
											 }
										 }
										 // C6Circle 연마량 가공량 검사 시퀀스 종료(TrackMode VS MarkMode)
										 //////////////////////////////////////////////////////////////////////////////////////////////////////

										 // Org Circle데이터중 유호하지 않은 값을 제외한 실제 존재하는 데이터 기준으로 동적 메모리 생성함
										 // Circle Defect검사에 필요한 Edge데이터 값
										 int Count=0;
										 if(OrgC6CirInEdgeCount>0){
											 C6CirInEdgeCount = OrgC6CirInEdgeCount - C6CirInEdgeCount;
											 // 										 C6CirInEdgeCount = OrgC6CirInEdgeCount;
											 if(C6CirInEdgeCount>0){
												 if(C6CirInPoint!=NULL) delete[] C6CirInPoint;
												 C6CirInPoint = new TFPoint[C6CirInEdgeCount];

												 for(int k=0; k<OrgC6CirInEdgeCount; k++){
													 if(k>MAX_CIRCLE_EDGEPOINT) break;
													 if(OrgC6CirInPoint[k].x==0.0f && OrgC6CirInPoint[k].y==0.0f) continue;
													 C6CirInPoint[Count].x = OrgC6CirInPoint[k].x;
													 C6CirInPoint[Count].y = OrgC6CirInPoint[k].y;
													 Count++;
												 }
											 }
											 // Circle 원본 데이터 메모리 삭제
											 if(OrgC6CirInPoint!=NULL) delete[] OrgC6CirInPoint;
										 }
										 // Circle Fitting 결과물 
										 SampleSize = C6CirInEdgeCount*0.75; //0.5~0.8이하로 입력할것
										 DistDevRatio = 0.15; //0.1~0.25 이하로 입력할것
										 // 									Radius = 0;
										 CircleFit->OnRansac(C6CirInPoint,C6CirInEdgeCount,SampleSize,DistDevRatio,&CircleFit6Center,&CirFitDiameter6);

										 if(OrgC6CirOutEdgeCount>0){
											 C6CirOutEdgeCount = OrgC6CirOutEdgeCount - C6CirOutEdgeCount;
											 Count =0;
											 if(C6CirOutEdgeCount>0){
												 if(C6CirOutPoint!=NULL) delete[] C6CirOutPoint;
												 C6CirOutPoint = new TFPoint[C6CirOutEdgeCount];

												 for(int k=0; k<OrgC6CirOutEdgeCount; k++){
													 if(k>MAX_CIRCLE_EDGEPOINT) break;
													 if(OrgC6CirOutPoint[k].x==0.0f && OrgC6CirOutPoint[k].y==0.0f) continue;
													 C6CirOutPoint[Count].x = OrgC6CirOutPoint[k].x;
													 C6CirOutPoint[Count].y = OrgC6CirOutPoint[k].y;
													 Count++;
												 }
											 }
											 // Circle 원본 데이터 메모리 삭제
											 if(OrgC6CirOutPoint!=NULL) delete[] OrgC6CirOutPoint;
										 }
										 if(OrgC6CirStandEdgeCount>0){
											 C6CirStandEdgeCount = OrgC6CirStandEdgeCount - C6CirStandEdgeCount;
											 // 										 C6CirStandEdgeCount = OrgC6CirStandEdgeCount;
											 Count =0;
											 if(C6CirStandEdgeCount>0){
												 if(C6CirStandPoint!=NULL) delete[] C6CirStandPoint;
												 C6CirStandPoint = new TFPoint[C6CirStandEdgeCount];

												 for(int k=0; k<OrgC6CirStandEdgeCount; k++){
													 if(k>MAX_CIRCLE_EDGEPOINT) break;
													 if(OrgC6CirStandPoint[k].x==0.0f && OrgC6CirStandPoint[k].y==0.0f) continue;
													 C6CirStandPoint[Count].x = OrgC6CirStandPoint[k].x;
													 C6CirStandPoint[Count].y = OrgC6CirStandPoint[k].y;
													 Count++;
												 }
											 }
											 // Circle 원본 데이터 메모리 삭제
											 if(OrgC6CirStandPoint!=NULL) delete[] OrgC6CirStandPoint;
										 }
										 LogUnit.SetLog(L"Circle_6_Insp_End");
										 // Circle 영역 꽃박리, 원형박리 검출 목적 시퀀스(EnCap)
										 // 정식 명칭은 몰라서.....일단 Crack으로 정함 
										 if(!IsMarkBtm && BrokenThresHold!=0){
											 if(CirFitDiameter6!=0.0f && CircleFit6Center.x!=0.0f && CircleFit6Center.y!=0.0f){ // FAVION Circle Fitting 성공시 박리검사 진행 
												 Circle->GImage = &RotateBrokenImg;                                             //Binary Image 넘겨줌 

												 Circle->SetCenterXY(CircleFit6Center.x,CircleFit6Center.y)      ;
												 Circle->SetTolerance((dEdgeToTrapLineDis/2) -CirOffsetMargin)   ; // Circle Tolerance 
												 Circle->SetDiameter ((CirFitDiameter6-(dEdgeToTrapLineDis/2))*2); // Circle Diameter 
												 Circle->SetCircleChoice(0)                                      ; // 0:From Begin, 1:From End, 2:Largest Amplitude 
												 Circle->SetCircleType  (2)                                      ; // 0:Black to White, 1:White to Black 2: Both Black, White 
												 Circle->SetCircleIndex (0)                                      ; // Circle EdgePoint Index 
												 Circle->OnExecute(true)                                         ;
												 CrackCirDiameter6 = (CirFitDiameter6-(dEdgeToTrapLineDis/2))+((dEdgeToTrapLineDis/2) -CirOffsetMargin);

												 C6CirInCrackCount = Circle->FCirclePointCount;

												 if(C6CirInCrackCount>0){
													 if(C6CirInCrackPoint!=NULL) delete[] C6CirInCrackPoint;
													 C6CirInCrackPoint = new TFPoint[C6CirInCrackCount];

													 for(int k=0; k<C6CirInCrackCount; k++){
														 if(k>MAX_CIRCLE_EDGEPOINT) break;
														 C6CirInCrackPoint[k].x = Circle->FCirclePoint[k].x;
														 C6CirInCrackPoint[k].y = Circle->FCirclePoint[k].y;
													 }
												 }
											 }
										 }
									 }


									 // 개별 Circle Data 교차점 기준 직선영역의 새로운 Btm영역 BtmOutLine, BtmInLine 찾는다 
									 // Circle1과 Circle2 사이의 직선영역 검사
									 const int BtmMargin =50; const int LeftMargin =30; const int RightMargin =30;
									 if(BtmEdgePoint[0].x!=0 && BtmEdgePoint[0].y!=0 && BtmEdgePoint[1].x!=0 && BtmEdgePoint[1].y!=0 ){ // BTM
										 LogUnit.SetLog(L"shRectC_Btm1_Insp_Start");

										 if(BtmEdgeThresHold==0)    {SingleLine->GImage = &RotateImg      ;  SingleLine->FThreshold =5 ;}
										 else                       {SingleLine->GImage = &RotateBinaryImg;  SingleLine->FThreshold =10;}

										 // BtmOutLine Search 
										 SingleLine->IRoi->SetOrgX  (BtmEdgePoint[0].x+50                       );
										 SingleLine->IRoi->SetOrgY  (BtmEdgePoint[0].y - BtmMargin              );
										 SingleLine->IRoi->SetWidth ((BtmEdgePoint[1].x - BtmEdgePoint[0].x)-100);
										 SingleLine->IRoi->SetHeight(100                                        );
										 if(BtmEdgePoint[0].x+100<=0 || (BtmEdgePoint[0].y-BtmMargin<=0) || ((BtmEdgePoint[1].x-BtmEdgePoint[0].x)-200)<=0 ) return false;

										 SingleLine->SetOrientation(orSouth);
										 // 									 SingleLine->FIncrement =1   ;
										 SingleLine->SetFindLineId(0);
										 SingleLine->FThreshold =5;

										 if(IsMarkBtm) {SingleLine->FIncrement =1 ; SingleLine->SetEdgeType(1);}  //White To Black 
										 else          {SingleLine->FIncrement =10; SingleLine->SetEdgeType(1);}  //White To Black 

										 SingleLine->OnExecute();
										 BtmOutLine[0].FP0 = SingleLine->GetResultP0();
										 BtmOutLine[0].FP1 = SingleLine->GetResultP1();

										 // BtmOutLine Real EdgePoint 추출함 
										 OrgBtm1OutEdgeCount = SingleLine->FEdgePointCount;
										 if(OrgBtm1OutEdgeCount>0){
											 if(OrgBtm1OutPoint!=NULL) delete[] OrgBtm1OutPoint;
											 OrgBtm1OutPoint = new TFPoint[OrgBtm1OutEdgeCount];

											 for(int k=0; k<OrgBtm1OutEdgeCount; k++){
												 if(k>MAX_CIRCLE_EDGEPOINT) break;
												 OrgBtm1OutPoint[k].x = SingleLine->FEdgePoint[k].x;
												 OrgBtm1OutPoint[k].y = SingleLine->FEdgePoint[k].y;
											 }
										 }

										 // BtmInLine Search 
										 if(CirGrindInThresHold==0) {Circle->GImage = &RotateImg             ; SingleLine->FThreshold =5 ;} //Org Image 넘겨줌 
										 else                       {Circle->GImage = &RotateGrindInBinaryImg; SingleLine->FThreshold =10;}//Binary Image 넘겨줌 

										 SingleLine->SetEdgeType(0);  //Black To White  
										 SingleLine->OnExecute();
										 BtmInLine[0].FP0 = SingleLine->GetResultP0();
										 BtmInLine[0].FP1 = SingleLine->GetResultP1();

										 // BtmInLine Real EdgePoint 추출함 
										 OrgBtm1InEdgeCount = SingleLine->FEdgePointCount;
										 if(OrgBtm1InEdgeCount>0){
											 if(OrgBtm1InPoint!=NULL) delete[] OrgBtm1InPoint;
											 OrgBtm1InPoint = new TFPoint[OrgBtm1InEdgeCount];

											 for(int k=0; k<OrgBtm1InEdgeCount; k++){
												 if(k>MAX_CIRCLE_EDGEPOINT) break;
												 OrgBtm1InPoint[k].x = SingleLine->FEdgePoint[k].x;
												 OrgBtm1InPoint[k].y = SingleLine->FEdgePoint[k].y;
											 }
										 }

										 // Grind Mark 기준 연마량 계산 
										 if(IsMarkBtm){ // LT검사시 가공량 측정함 
											 if(FInspectMode==Insp_Track){ // TrackMode TrackLine기준 가공량 측정 
												 if(CirGrindMeaThresHold!=0){
													 // 연마량 계산  
													 if((fabs(BtmOutLine[0].FP0.y - BtmOutLine[0].FP1.y))>1
														 ||(fabs(BtmInLine[0].FP0.y - BtmInLine[0].FP1.y))>1){
															 BtmGrindWidth1 = BtmOutLine[0].FP0.y - BtmInLine[0].FP0.y; 
													 }
													 else{
														 BtmGrindWidth1 = Math.GetLengthFrLineToPoint(BtmOutLine[0].FP0, BtmOutLine[0].FP1, BtmInLine[0].FP0);
													 }

													 SingleLine->GImage = &RotateGrindBinaryImg; //Binary Image 넘겨줌 
													 SingleLine->SetEdgeType(1);  //White To Black 
													 SingleLine->SetFindLineId(0);
													 SingleLine->OnExecute();

													 BtmStandLine[0].FP0 = SingleLine->GetResultP0();
													 BtmStandLine[0].FP1 = SingleLine->GetResultP1();
													 // 가공량 계산 
													 BtmGrindMeasure1 = Math.GetLengthFrLineToPoint(BtmOutLine[0].FP0, BtmOutLine[0].FP1, BtmStandLine[0].FP0);
												 }
											 }
											 else if(FInspectMode==Insp_Mark){
												 // GrindMark 상관없이 연마량 측정
												 if(OrgBtm1InEdgeCount>10 && OrgBtm1OutEdgeCount>10 && (OrgBtm1InEdgeCount==OrgBtm1OutEdgeCount)){
													 // 가공량,연마량 측정 전 데이터 존재시 가상GrindMark 생성한다 
													 if(GrindMarkPoint[2].x!=0.0f && GrindMarkPoint[2].y!=0.0f){
														 GrindMarkPoint[4].x     = OrgBtm1InPoint[OrgBtm1InEdgeCount-10].x ;
														 GrindMarkPoint[4].y     = GrindMarkPoint[2].y                     ;
														 GrindMarkRect [4].left  = GrindMarkPoint[4].x    - GrindMarkRange ;  
														 GrindMarkRect [4].top   = GrindMarkPoint[4].y    - GrindMarkRange ;  
														 GrindMarkRect [4].right = GrindMarkRect [4].left + GrindMarkLength;  
														 GrindMarkRect [4].bottom= GrindMarkRect [4].top  + GrindMarkLength;  
													 }

													 // GrindMark[2] 가공량,연마량 측정 
													 ////////////////////////////////////////////////////////////////////////////////////////////////////
													 if(GrindMarkPoint[2].x!=0.0f && GrindMarkPoint[2].y!=0.0f){ //GrindMark 찾았을경우 검사 시퀀스 가공량 측정 
														 GrindMeaDis =0.0f, MinDis =10000.0f;  Btm1GrindMarkCount=0;
														 for(int k=0; k<OrgBtm1OutEdgeCount; k++){
															 if(OrgBtm1OutPoint[k].x==0.0f || OrgBtm1OutPoint[k].y==0.0f) continue;
															 if(GrindMarkPoint[2].x ==0.0f || GrindMarkPoint[2].y ==0.0f) continue;

															 GrindMeaDis = Math.GetLength(GrindMarkPoint[2], OrgBtm1OutPoint[k]);
															 if(GrindMeaDis<MinDis){
																 MinDis = GrindMeaDis;
																 Btm1GrindMarkCount = k;
															 }
														 }
														 // GrindMark기준 수직 포인트 주변값 Avg산출한다 
														 if(Btm1GrindMarkCount!=0 && Btm1GrindMarkCount>5 && (Btm1GrindMarkCount+5)<OrgBtm1OutEdgeCount){
															 CircleCount=0,TotalCirDis=0.0f,GrindMeaDis=0.0f;
															 for(int k=Btm1GrindMarkCount-5; k<Btm1GrindMarkCount+5; k++){
																 if(OrgBtm1OutPoint[k].x==0.0f || OrgBtm1OutPoint[k].y==0.0f) continue;

																 GrindMeaDis = Math.GetLength(GrindMarkPoint[2], OrgBtm1OutPoint[k]);
																 TotalCirDis+= GrindMeaDis;
																 CircleCount++;
															 }
															 if(TotalCirDis!=0.0f && CircleCount!=0){
																 BtmGrindMeasure1 = TotalCirDis/CircleCount;
															 }
														 }
														 // GrindMark기준 수직 평균값 연마량 측정 
														 if(Btm1GrindMarkCount!=0 && Btm1GrindMarkCount>5 && (Btm1GrindMarkCount+5)<OrgBtm1OutEdgeCount){
															 CircleCount=0,TotalCirDis=0.0f,GrindWidthDis=0.0f;
															 for(int k=Btm1GrindMarkCount-5; k<Btm1GrindMarkCount+5; k++){
																 if(OrgBtm1OutPoint[k].x==0.0f && OrgBtm1OutPoint[k].y==0.0f) continue;
																 if(OrgBtm1InPoint [k].x==0.0f && OrgBtm1InPoint [k].y==0.0f) continue;
																 GrindWidthDis = Math.GetLength(OrgBtm1InPoint[k], OrgBtm1OutPoint[k]);
																 TotalCirDis+=   GrindWidthDis;
																 CircleCount++;
															 }
															 if(TotalCirDis!=0.0f && CircleCount!=0){
																 BtmGrindWidth1 = TotalCirDis/CircleCount;
															 }
														 }
													 }
													 else {  //GrindMark 못 찾았을경우 검사 시퀀스 (가공량: 0, 연마량 측정)
														 GrindMeaDis =0.0f, MinDis =10000.0f;  Btm1GrindMarkCount=0;
														 for(int k=0; k<OrgBtm1OutEdgeCount; k++){
															 if(OrgBtm1OutPoint[k].x==0.0f || OrgBtm1OutPoint[k].y==0.0f) continue;

															 GrindMarkRectCenter[2].x = GrindMarkRect[2].left + (GrindMarkRect[2].right  - GrindMarkRect[2].left)/2; 
															 GrindMarkRectCenter[2].y = GrindMarkRect[2].top  + (GrindMarkRect[2].bottom - GrindMarkRect[2].top )/2; 

															 GrindMeaDis = Math.GetLength(GrindMarkRectCenter[2], OrgBtm1OutPoint[k]);
															 if(GrindMeaDis<MinDis){
																 MinDis = GrindMeaDis;
																 Btm1GrindMarkCount = k;
															 }
														 }
														 // GrindMark기준 수직 평균값 연마량 측정 
														 if(Btm1GrindMarkCount!=0 && Btm1GrindMarkCount>5 &&(Btm1GrindMarkCount+5<OrgBtm1OutEdgeCount)){
															 CircleCount=0,TotalCirDis=0.0f,GrindWidthDis=0.0f;
															 for(int k=Btm1GrindMarkCount-5; k<Btm1GrindMarkCount+5; k++){
																 if(OrgBtm1OutPoint[k].x==0.0f && OrgBtm1OutPoint[k].y==0.0f) continue;
																 if(OrgBtm1InPoint [k].x==0.0f && OrgBtm1InPoint [k].y==0.0f) continue;
																 GrindWidthDis = Math.GetLength(OrgBtm1InPoint[k], OrgBtm1OutPoint[k]);
																 TotalCirDis+=   GrindWidthDis;
																 CircleCount++;
															 }
															 if(TotalCirDis!=0.0f && CircleCount!=0){
																 BtmGrindWidth1 = TotalCirDis/CircleCount;
															 }
														 }
													 }
													 ////////////////////////////////////////////////////////////////////////////////////////////////////

													 // GrindMark[4] 가공량,연마량 측정 
													 ////////////////////////////////////////////////////////////////////////////////////////////////////
													 if(GrindMarkPoint[4].x!=0.0f && GrindMarkPoint[4].y!=0.0f){ //GrindMark 찾았을경우 검사 시퀀스 가공량 측정 
														 GrindMeaDis =0.0f, MinDis =10000.0f;  Btm1GrindMarkCount=0;
														 for(int k=0; k<OrgBtm1OutEdgeCount; k++){
															 if(OrgBtm1OutPoint[k].x==0.0f || OrgBtm1OutPoint[k].y==0.0f) continue;
															 if(GrindMarkPoint[4].x ==0.0f || GrindMarkPoint[4].y ==0.0f) continue;

															 GrindMeaDis = Math.GetLength(GrindMarkPoint[4], OrgBtm1OutPoint[k]);
															 if(GrindMeaDis<MinDis){
																 MinDis = GrindMeaDis;
																 Btm1GrindMarkCount = k;
															 }
														 }
														 // GrindMark기준 수직 포인트 주변값 Avg산출한다 
														 if(Btm1GrindMarkCount!=0 && Btm1GrindMarkCount>5 && (Btm1GrindMarkCount+5)<OrgBtm1OutEdgeCount){
															 CircleCount=0,TotalCirDis=0.0f,GrindMeaDis=0.0f;
															 for(int k=Btm1GrindMarkCount-5; k<Btm1GrindMarkCount+5; k++){
																 if(OrgBtm1OutPoint[k].x==0.0f || OrgBtm1OutPoint[k].y==0.0f) continue;

																 GrindMeaDis = Math.GetLength(GrindMarkPoint[4], OrgBtm1OutPoint[k]);
																 TotalCirDis+= GrindMeaDis;
																 CircleCount++;
															 }
															 if(TotalCirDis!=0.0f && CircleCount!=0){
																 BtmGrindMeasure3 = TotalCirDis/CircleCount;
															 }
														 }
														 // GrindMark기준 수직 평균값 연마량 측정 
														 if(Btm1GrindMarkCount!=0 && Btm1GrindMarkCount>5 && (Btm1GrindMarkCount+5)<OrgBtm1OutEdgeCount){
															 CircleCount=0,TotalCirDis=0.0f,GrindWidthDis=0.0f;
															 for(int k=Btm1GrindMarkCount-5; k<Btm1GrindMarkCount+5; k++){
																 if(OrgBtm1OutPoint[k].x==0.0f && OrgBtm1OutPoint[k].y==0.0f) continue;
																 if(OrgBtm1InPoint [k].x==0.0f && OrgBtm1InPoint [k].y==0.0f) continue;
																 GrindWidthDis = Math.GetLength(OrgBtm1InPoint[k], OrgBtm1OutPoint[k]);
																 TotalCirDis+=   GrindWidthDis;
																 CircleCount++;
															 }
															 if(TotalCirDis!=0.0f && CircleCount!=0){
																 BtmGrindWidth3 = TotalCirDis/CircleCount;
															 }
														 }
													 }
													 else {  //GrindMark 못 찾았을경우 검사 시퀀스 (가공량: 0, 연마량 측정)
														 GrindMeaDis =0.0f, MinDis =10000.0f;  Btm1GrindMarkCount=0;
														 for(int k=0; k<OrgBtm1OutEdgeCount; k++){
															 if(OrgBtm1OutPoint[k].x==0.0f || OrgBtm1OutPoint[k].y==0.0f) continue;

															 if(k==0){ // GrindMark[2] 못찾을 경우 가상으로 데이터 생성해줌 
																 GrindMarkRectCenter[4].x     =  OrgBtm1InPoint[OrgBtm1InEdgeCount-10].x;
																 GrindMarkRectCenter[4].y     =  GrindMarkRectCenter[2].y               ;

																 GrindMarkRect [4].left  = GrindMarkRectCenter[4].x  - GrindMarkRange  ;  
																 GrindMarkRect [4].top   = GrindMarkRectCenter[4].y  - GrindMarkRange  ;  
																 GrindMarkRect [4].right = GrindMarkRect [4].left    + GrindMarkLength ;  
																 GrindMarkRect [4].bottom= GrindMarkRect [4].top     + GrindMarkLength ;  

															 }

															 GrindMeaDis = Math.GetLength(GrindMarkRectCenter[4], OrgBtm1OutPoint[k]);
															 if(GrindMeaDis<MinDis){
																 MinDis = GrindMeaDis;
																 Btm1GrindMarkCount = k;
															 }
														 }
														 // GrindMark기준 수직 평균값 연마량 측정 
														 if(Btm1GrindMarkCount!=0 && Btm1GrindMarkCount>5 &&(Btm1GrindMarkCount+5<OrgBtm1OutEdgeCount)){
															 CircleCount=0,TotalCirDis=0.0f,GrindWidthDis=0.0f;
															 for(int k=Btm1GrindMarkCount-5; k<Btm1GrindMarkCount+5; k++){
																 if(OrgBtm1OutPoint[k].x==0.0f && OrgBtm1OutPoint[k].y==0.0f) continue;
																 if(OrgBtm1InPoint [k].x==0.0f && OrgBtm1InPoint [k].y==0.0f) continue;
																 GrindWidthDis = Math.GetLength(OrgBtm1InPoint[k], OrgBtm1OutPoint[k]);
																 TotalCirDis+=   GrindWidthDis;
																 CircleCount++;
															 }
															 if(TotalCirDis!=0.0f && CircleCount!=0){
																 BtmGrindWidth3 = TotalCirDis/CircleCount;
															 }
														 }
													 }
													 ////////////////////////////////////////////////////////////////////////////////////////////////////
												 }

												 // 가공량 측정 
												 // 											 if(BtmGrindWidth1!=0 && GrindMarkPoint[2].x!=0.0f && GrindMarkPoint[2].y!=0.0f){ // MarkMode GrindMark중심 좌표 기준 가공량 측정 
												 // 												 if(fabs(BtmOutLine[0].FP0.y - BtmOutLine[0].FP1.y)>2){
												 // // 													 BtmGrindWidth1   = (BtmOutLine[0].FP0.y  - GrindMarkPoint[2].y) - (BtmInLine[0].FP0.y - GrindMarkPoint[2].y);
												 // 													 BtmGrindMeasure1 = BtmOutLine[0].FP0.y  - GrindMarkPoint[2].y; 
												 // 												 }
												 // 												 else {
												 // 													 BtmGrindMeasure1 = Math.GetLengthFrLineToPoint(BtmOutLine[0].FP0, BtmOutLine[0].FP1, GrindMarkPoint[2]);
												 // // 													 BtmGrindWidth1   = BtmGrindMeasure1 - Math.GetLengthFrLineToPoint(BtmInLine[0].FP0, BtmInLine[0].FP1, GrindMarkPoint[2]);
												 // 												 }
												 // 											 }
											 }
										 }
										 else { // ENCAP 연마량 데이터만 계측함
											 if(BtmOutLine[0].FP0.x!=0.0f && BtmOutLine[0].FP0.y!=0.0f && BtmOutLine[0].FP1.x!=0.0f && BtmOutLine[0].FP1.y!=0.0f &&
												 BtmInLine [0].FP0.x!=0.0f && BtmInLine [0].FP0.y!=0.0f && BtmInLine [0].FP1.x!=0.0f && BtmInLine [0].FP1.y!=0.0f ){
													 // 연마량 계산  
													 if((fabs(BtmOutLine[0].FP0.y - BtmOutLine[0].FP1.y))>1
														 ||(fabs(BtmInLine[0].FP0.y - BtmInLine[0].FP1.y))>1){
															 BtmGrindWidth1 = BtmOutLine[0].FP0.y - BtmInLine[0].FP0.y; 
													 }
													 else{
														 BtmGrindWidth1 = Math.GetLengthFrLineToPoint(BtmOutLine[0].FP0, BtmOutLine[0].FP1, BtmInLine[0].FP0);
													 }
											 }
										 }
										 // 동적 생성한 데이터를 지운다 
										 if(OrgBtm1InPoint !=NULL) delete[] OrgBtm1InPoint;
										 if(OrgBtm1OutPoint!=NULL) delete[] OrgBtm1OutPoint;
										 LogUnit.SetLog(L"shRectC_Btm1_Insp_End");
									 }

									 // Circle2과 Circle3 사이의 직선영역 검사 
									 if(BtmEdgePoint[2].x!=0 && BtmEdgePoint[2].y!=0 && BtmEdgePoint[3].x!=0 && BtmEdgePoint[3].y!=0 ){ //RIGHT
										 LogUnit.SetLog(L"shRectC_Btm2_Insp_Start");

										 if(BtmEdgeThresHold==0)   {SingleLine->GImage = &RotateImg      ;  SingleLine->FThreshold =5 ;}
										 else                      {SingleLine->GImage = &RotateBinaryImg;  SingleLine->FThreshold =10;}

										 SingleLine->IRoi->SetOrgX  (BtmEdgePoint[3].x-RightMargin        ); 
										 SingleLine->IRoi->SetOrgY  (BtmEdgePoint[3].y                    );
										 SingleLine->IRoi->SetWidth (100                                  );
										 SingleLine->IRoi->SetHeight(BtmEdgePoint[2].y - BtmEdgePoint[3].y);

										 SingleLine->SetOrientation(orEast);
										 SingleLine->FIncrement =10;
										 SingleLine->SetFindLineId(0);
										 SingleLine->FThreshold =5;

										 if(IsMarkBtm) SingleLine->SetEdgeType(1);  //White To Black 
										 else          SingleLine->SetEdgeType(1);  //White To Black 

										 SingleLine->OnExecute();

										 BtmOutLine[1].FP0 = SingleLine->GetResultP0();
										 BtmOutLine[1].FP1 = SingleLine->GetResultP1();

										 // BtmInLine Search 
										 SingleLine->SetEdgeType(0);  //Black To White  
										 SingleLine->OnExecute();
										 BtmInLine[1].FP0 = SingleLine->GetResultP0();
										 BtmInLine[1].FP1 = SingleLine->GetResultP1();

										 // 연마폭 계산  
										 BtmGrindWidth2 = Math.GetLengthFrLineToPoint(BtmOutLine[1].FP0, BtmOutLine[1].FP1, BtmInLine[1].FP0);

										 //연마량 계산 
										 if(IsMarkBtm){
											 if(CirGrindMeaThresHold!=0){
												 SingleLine->GImage = &RotateGrindBinaryImg; //Binary Image 넘겨줌 
												 SingleLine->SetEdgeType(1);  //White To Black 
												 SingleLine->SetFindLineId(0);
												 SingleLine->OnExecute();

												 BtmStandLine[1].FP0 = SingleLine->GetResultP0();
												 BtmStandLine[1].FP1 = SingleLine->GetResultP1();
												 //연마량 계산 
												 BtmGrindMeasure2 = Math.GetLengthFrLineToPoint(BtmOutLine[1].FP0, BtmOutLine[1].FP1, BtmStandLine[1].FP0);
											 }
										 }
										 LogUnit.SetLog(L"shRectC_Btm2_Insp_End");
									 }

									 // Circl31과 Circle4 사이의 직선영역 검사 
									 if(BtmEdgePoint[4].x!=0 && BtmEdgePoint[4].y!=0 && BtmEdgePoint[5].x!=0 && BtmEdgePoint[5].y!=0 ){ //BTM
										 LogUnit.SetLog(L"shRectC_Btm3_Insp_Start");

										 if(BtmEdgeThresHold==0)    {SingleLine->GImage = &RotateImg      ;  SingleLine->FThreshold =5 ;}
										 else                       {SingleLine->GImage = &RotateBinaryImg;  SingleLine->FThreshold =10;}

										 // Trench Width 길이가 클경우 EdgePoint 간격을 조밀하게 검사진행시 시간 Delay 가능성 발생함 
										 // 연마량 측정 목적이므로 검사 ROI영역을 줄여준다 
										 int TrenchWidth=0;
										 TrenchWidth = (BtmEdgePoint[5].x>BtmEdgePoint[4].x) ? (BtmEdgePoint[5].x - BtmEdgePoint[4].x):(BtmEdgePoint[4].x - BtmEdgePoint[5].x);

										 if(TrenchWidth>TrenchWidthMargin){ // Trench Width 클경우 
											 SingleLine->IRoi->SetOrgX  (BtmEdgePoint[4].x+200                       );
											 SingleLine->IRoi->SetOrgY  (BtmEdgePoint[4].y - BtmMargin               );
											 SingleLine->IRoi->SetWidth ((BtmEdgePoint[5].x - BtmEdgePoint[4].x)-400 );
											 SingleLine->IRoi->SetHeight(100                                         );
											 if(BtmEdgePoint[4].x+500<=0 || (BtmEdgePoint[4].y-BtmMargin<=0) || ((BtmEdgePoint[5].x-BtmEdgePoint[4].x)-1000)<=0 ) return false;
										 }
										 else {                             // Trench Width 작을 경우 
											 SingleLine->IRoi->SetOrgX  (BtmEdgePoint[4].x+100                      );
											 SingleLine->IRoi->SetOrgY  (BtmEdgePoint[4].y - BtmMargin              );
											 SingleLine->IRoi->SetWidth ((BtmEdgePoint[5].x - BtmEdgePoint[4].x)-200);
											 SingleLine->IRoi->SetHeight(100                                        );
											 if(BtmEdgePoint[4].x+100<=0 || (BtmEdgePoint[4].y-BtmMargin<=0) || ((BtmEdgePoint[5].x-BtmEdgePoint[4].x)-200)<=0 ) return false;
										 }

										 SingleLine->SetOrientation(orSouth);
										 SingleLine->SetFindLineId(0);
										 SingleLine->FThreshold =5;

										 if(IsMarkBtm) {
											 SingleLine->SetEdgeType(1);  //White To Black
											 SingleLine->FIncrement =1 ;
										 }
										 else          {
											 SingleLine->SetEdgeType(1);  //White To Black 
											 SingleLine->FIncrement =20;
										 }

										 SingleLine->OnExecute();
										 BtmOutLine[2].FP0 = SingleLine->GetResultP0();
										 BtmOutLine[2].FP1 = SingleLine->GetResultP1();

										 // BtmOutLine Real EdgePoint 추출함 
										 OrgBtm3OutEdgeCount = SingleLine->FEdgePointCount;
										 if(OrgBtm3OutEdgeCount>0){
											 if(OrgBtm3OutPoint!=NULL) delete[] OrgBtm3OutPoint;
											 OrgBtm3OutPoint = new TFPoint[OrgBtm3OutEdgeCount];

											 for(int k=0; k<OrgBtm3OutEdgeCount; k++){
												 if(k>MAX_CIRCLE_EDGEPOINT) break;
												 OrgBtm3OutPoint[k].x = SingleLine->FEdgePoint[k].x;
												 OrgBtm3OutPoint[k].y = SingleLine->FEdgePoint[k].y;
											 }
										 }

										 // BtmInLine Search 

										 if(CirGrindInThresHold==0) {Circle->GImage = &RotateImg             ; SingleLine->FThreshold =5 ;} //Org Image 넘겨줌 
										 else                       {Circle->GImage = &RotateGrindInBinaryImg; SingleLine->FThreshold =10;}//Binary Image 넘겨줌 

										 SingleLine->SetEdgeType(0);  //Black To White  
										 SingleLine->OnExecute();
										 BtmInLine[2].FP0 = SingleLine->GetResultP0();
										 BtmInLine[2].FP1 = SingleLine->GetResultP1();

										 // BtmInLine Real EdgePoint 추출함 
										 OrgBtm3InEdgeCount = SingleLine->FEdgePointCount;
										 if(OrgBtm3InEdgeCount>0){
											 if(OrgBtm3InPoint!=NULL)  delete[] OrgBtm3InPoint;
											 OrgBtm3InPoint = new TFPoint[OrgBtm3InEdgeCount];

											 for(int k=0; k<OrgBtm3InEdgeCount; k++){
												 if(k>MAX_CIRCLE_EDGEPOINT) break;
												 OrgBtm3InPoint[k].x = SingleLine->FEdgePoint[k].x;
												 OrgBtm3InPoint[k].y = SingleLine->FEdgePoint[k].y;
											 }
										 }

										 // Grind Mark 기준 연마량 계산 
										 if(IsMarkBtm){ // LT검사시 가공량 측정함 
											 if(FInspectMode==Insp_Track){ // TrackMode TrackLine기준 가공량 측정 
												 if(CirGrindMeaThresHold!=0){
													 // 연마폭 계산  
													 BtmGrindWidth3 = Math.GetLengthFrLineToPoint(BtmOutLine[2].FP0, BtmOutLine[2].FP1, BtmInLine[2].FP0);

													 SingleLine->GImage = &RotateGrindBinaryImg; //Binary Image 넘겨줌 
													 SingleLine->SetEdgeType(1);  //White To Black 
													 SingleLine->SetFindLineId(0);
													 SingleLine->OnExecute();

													 BtmStandLine[2].FP0 = SingleLine->GetResultP0();
													 BtmStandLine[2].FP1 = SingleLine->GetResultP1();
													 //연마량 계산 
													 BtmGrindMeasure3 = Math.GetLengthFrLineToPoint(BtmOutLine[2].FP0, BtmOutLine[2].FP1, BtmStandLine[2].FP0);
												 }
											 }
											 else if(FInspectMode==Insp_Mark){
												 // GrindMark 상관없이 연마량 측정
												 if(OrgBtm3OutEdgeCount!=0 && OrgBtm3InEdgeCount!=0 && (OrgBtm3OutEdgeCount==OrgBtm3InEdgeCount)){ // 연마량이 존재할경우 가공량 검사를 진행함 
													 // 가공량,연마량 측정 전 데이터 존재시 가상GrindMark 생성한다 
													 if(GrindMarkPoint[9].x!=0.0f && GrindMarkPoint[9].y!=0.0f){
														 // GrindMark 8
														 GrindMarkPoint[8].x     = OrgBtm3InPoint[7].x ;
														 GrindMarkPoint[8].y     = GrindMarkPoint[9].y                     ;
														 GrindMarkRect [8].left  = GrindMarkPoint[8].x    - GrindMarkRange ;  
														 GrindMarkRect [8].top   = GrindMarkPoint[8].y    - GrindMarkRange ;  
														 GrindMarkRect [8].right = GrindMarkRect [8].left + GrindMarkLength;  
														 GrindMarkRect [8].bottom= GrindMarkRect [8].top  + GrindMarkLength;  

														 // GrindMark 9
														 GrindMarkPoint[10].x     = OrgBtm3InPoint[OrgBtm3InEdgeCount-7].x   ;
														 GrindMarkPoint[10].y     = GrindMarkPoint[9 ].y                     ;
														 GrindMarkRect [10].left  = GrindMarkPoint[10].x    - GrindMarkRange ;  
														 GrindMarkRect [10].top   = GrindMarkPoint[10].y    - GrindMarkRange ;  
														 GrindMarkRect [10].right = GrindMarkRect [10].left + GrindMarkLength;  
														 GrindMarkRect [10].bottom= GrindMarkRect [10].top  + GrindMarkLength;  
													 }

													 // GrindMark[8] 가공량,연마량 측정 
													 ////////////////////////////////////////////////////////////////////////////////////////////////////
													 if(GrindMarkPoint[8].x!=0.0f && GrindMarkPoint[8].y!=0.0f){ //GrindMark 찾았을경우 검사 시퀀스 
														 GrindMeaDis =0.0f, MinDis =10000.0f;  Btm3GrindMarkCount=0;

														 for(int k=0; k<OrgBtm3OutEdgeCount; k++){
															 if(OrgBtm3OutPoint[k].x==0.0f || OrgBtm3OutPoint[k].y==0.0f) continue;
															 if(GrindMarkPoint[8].x ==0.0f || GrindMarkPoint[8].y ==0.0f) continue;

															 GrindMeaDis = Math.GetLength(GrindMarkPoint[8], OrgBtm3OutPoint[k]);
															 if(GrindMeaDis<MinDis){
																 MinDis = GrindMeaDis;
																 Btm3GrindMarkCount = k;
															 }
														 }
														 // GrindMark기준 수직 포인트 주변값 Avg산출한다 
														 if(Btm3GrindMarkCount!=0 && Btm3GrindMarkCount>5 && (Btm3GrindMarkCount+5)<OrgBtm3OutEdgeCount){
															 CircleCount=0,TotalCirDis=0.0f,GrindMeaDis=0.0f;
															 for(int k=Btm3GrindMarkCount-5; k<Btm3GrindMarkCount+5; k++){
																 if(OrgBtm3OutPoint[k].x==0.0f || OrgBtm3OutPoint[k].y==0.0f) continue;

																 GrindMeaDis = Math.GetLength(GrindMarkPoint[8], OrgBtm3OutPoint[k]);
																 TotalCirDis+= GrindMeaDis;
																 CircleCount++;
															 }
															 if(TotalCirDis!=0.0f && CircleCount!=0){
																 BtmGrindMeasure4 = TotalCirDis/CircleCount;
															 }
														 }
														 // GrindMark기준 수직 평균값 연마량 측정 
														 if(Btm3GrindMarkCount!=0 && Btm3GrindMarkCount>5 && (Btm3GrindMarkCount+5)<OrgBtm3OutEdgeCount){
															 CircleCount=0,TotalCirDis=0.0f,GrindWidthDis=0.0f;
															 for(int k=Btm3GrindMarkCount-5; k<Btm3GrindMarkCount+5; k++){
																 if(OrgBtm3OutPoint[k].x==0.0f && OrgBtm3OutPoint[k].y==0.0f) continue;
																 if(OrgBtm3InPoint [k].x==0.0f && OrgBtm3InPoint [k].y==0.0f) continue;
																 GrindWidthDis = Math.GetLength(OrgBtm3InPoint[k], OrgBtm3OutPoint[k]);
																 TotalCirDis+=   GrindWidthDis;
																 CircleCount++;
															 }
															 if(TotalCirDis!=0.0f && CircleCount!=0){
																 BtmGrindWidth4 = TotalCirDis/CircleCount;
															 }
														 }
													 }
													 else { //GrindMark 못 찾았을경우 검사 시퀀스 (가공량: 0, 연마량 측정)
														 GrindMeaDis =0.0f, MinDis =10000.0f;  Btm3GrindMarkCount=0;
														 for(int k=0; k<OrgBtm3OutEdgeCount; k++){
															 if(OrgBtm3OutPoint[k].x==0.0f || OrgBtm3OutPoint[k].y==0.0f) continue;

															 if(k==0){ // 순서상 9번이 없는경우 
																 GrindMarkRectCenter[9].x = GrindMarkRect[9].left + (GrindMarkRect[9].right  - GrindMarkRect[9].left)/2; 
																 GrindMarkRectCenter[9].y = GrindMarkRect[9].top  + (GrindMarkRect[9].bottom - GrindMarkRect[9].top )/2; 

																 GrindMarkRectCenter[8].x = OrgBtm3InPoint[7].x     ;
																 GrindMarkRectCenter[8].y = GrindMarkRectCenter[9].y; 

																 GrindMarkRect [8].left  = GrindMarkRectCenter[8].x    - GrindMarkRange ;  
																 GrindMarkRect [8].top   = GrindMarkRectCenter[8].y    - GrindMarkRange ;  
																 GrindMarkRect [8].right = GrindMarkRect [8].left      + GrindMarkLength;  
																 GrindMarkRect [8].bottom= GrindMarkRect [8].top       + GrindMarkLength;  
															 }

															 GrindMeaDis = Math.GetLength(GrindMarkRectCenter[8], OrgBtm3OutPoint[k]);
															 if(GrindMeaDis<MinDis){
																 MinDis = GrindMeaDis;
																 Btm3GrindMarkCount = k;
															 }
														 }
														 // GrindMark기준 수직 평균값 연마량 측정 
														 if(Btm3GrindMarkCount!=0 && Btm3GrindMarkCount>5 &&(Btm3GrindMarkCount+5<OrgBtm3OutEdgeCount)){
															 CircleCount=0,TotalCirDis=0.0f,GrindWidthDis=0.0f;
															 for(int k=Btm3GrindMarkCount-5; k<Btm3GrindMarkCount+5; k++){
																 if(OrgBtm3OutPoint[k].x==0.0f && OrgBtm3OutPoint[k].y==0.0f) continue;
																 if(OrgBtm3InPoint [k].x==0.0f && OrgBtm3InPoint [k].y==0.0f) continue;
																 GrindWidthDis = Math.GetLength(OrgBtm3InPoint[k], OrgBtm3OutPoint[k]);
																 TotalCirDis+=   GrindWidthDis;
																 CircleCount++;
															 }
															 if(TotalCirDis!=0.0f && CircleCount!=0){
																 BtmGrindWidth4 = TotalCirDis/CircleCount;
															 }
														 }
													 }
													 ////////////////////////////////////////////////////////////////////////////////////////////////////

													 // GrindMark[9] 가공량,연마량 측정 
													 ////////////////////////////////////////////////////////////////////////////////////////////////////
													 if(GrindMarkPoint[9].x!=0.0f && GrindMarkPoint[9].y!=0.0f){ //GrindMark 찾았을경우 검사 시퀀스 
														 GrindMeaDis =0.0f, MinDis =10000.0f;  Btm3GrindMarkCount=0;

														 for(int k=0; k<OrgBtm3OutEdgeCount; k++){
															 if(OrgBtm3OutPoint[k].x==0.0f || OrgBtm3OutPoint[k].y==0.0f) continue;
															 if(GrindMarkPoint[9].x  ==0.0f || GrindMarkPoint[9].y  ==0.0f) continue;

															 GrindMeaDis = Math.GetLength(GrindMarkPoint[9], OrgBtm3OutPoint[k]);
															 if(GrindMeaDis<MinDis){
																 MinDis = GrindMeaDis;
																 Btm3GrindMarkCount = k;
															 }
														 }
														 // GrindMark기준 수직 포인트 주변값 Avg산출한다 
														 if(Btm3GrindMarkCount!=0 && Btm3GrindMarkCount>5 && (Btm3GrindMarkCount+5)<OrgBtm3OutEdgeCount){
															 CircleCount=0,TotalCirDis=0.0f,GrindMeaDis=0.0f;
															 for(int k=Btm3GrindMarkCount-5; k<Btm3GrindMarkCount+5; k++){
																 if(OrgBtm3OutPoint[k].x==0.0f || OrgBtm3OutPoint[k].y==0.0f) continue;

																 GrindMeaDis = Math.GetLength(GrindMarkPoint[9], OrgBtm3OutPoint[k]);
																 TotalCirDis+= GrindMeaDis;
																 CircleCount++;
															 }
															 if(TotalCirDis!=0.0f && CircleCount!=0){
																 BtmGrindMeasure5 = TotalCirDis/CircleCount;
															 }
														 }
														 // GrindMark기준 수직 평균값 연마량 측정 
														 if(Btm3GrindMarkCount!=0 && Btm3GrindMarkCount>5 && (Btm3GrindMarkCount+5)<OrgBtm3OutEdgeCount){
															 CircleCount=0,TotalCirDis=0.0f,GrindWidthDis=0.0f;
															 for(int k=Btm3GrindMarkCount-5; k<Btm3GrindMarkCount+5; k++){
																 if(OrgBtm3OutPoint[k].x==0.0f && OrgBtm3OutPoint[k].y==0.0f) continue;
																 if(OrgBtm3InPoint [k].x==0.0f && OrgBtm3InPoint [k].y==0.0f) continue;
																 GrindWidthDis = Math.GetLength(OrgBtm3InPoint[k], OrgBtm3OutPoint[k]);
																 TotalCirDis+=   GrindWidthDis;
																 CircleCount++;
															 }
															 if(TotalCirDis!=0.0f && CircleCount!=0){
																 BtmGrindWidth5 = TotalCirDis/CircleCount;
															 }
														 }
													 }
													 else { //GrindMark 못 찾았을경우 검사 시퀀스 (가공량: 0, 연마량 측정)
														 GrindMeaDis =0.0f, MinDis =10000.0f;  Btm3GrindMarkCount=0;
														 for(int k=0; k<OrgBtm3OutEdgeCount; k++){
															 if(OrgBtm3OutPoint[k].x==0.0f || OrgBtm3OutPoint[k].y==0.0f) continue;

															 GrindMarkRectCenter[9].x = GrindMarkRect[9].left + (GrindMarkRect[9].right  - GrindMarkRect[9].left)/2; 
															 GrindMarkRectCenter[9].y = GrindMarkRect[9].top  + (GrindMarkRect[9].bottom - GrindMarkRect[9].top )/2; 

															 GrindMeaDis = Math.GetLength(GrindMarkRectCenter[9], OrgBtm3OutPoint[k]);
															 if(GrindMeaDis<MinDis){
																 MinDis = GrindMeaDis;
																 Btm3GrindMarkCount = k;
															 }
														 }
														 // GrindMark기준 수직 평균값 연마량 측정 
														 if(Btm3GrindMarkCount!=0 && Btm3GrindMarkCount>5 &&(Btm3GrindMarkCount+5<OrgBtm3OutEdgeCount)){
															 CircleCount=0,TotalCirDis=0.0f,GrindWidthDis=0.0f;
															 for(int k=Btm3GrindMarkCount-5; k<Btm3GrindMarkCount+5; k++){
																 if(OrgBtm3OutPoint[k].x==0.0f && OrgBtm3OutPoint[k].y==0.0f) continue;
																 if(OrgBtm3InPoint [k].x==0.0f && OrgBtm3InPoint [k].y==0.0f) continue;
																 GrindWidthDis = Math.GetLength(OrgBtm3InPoint[k], OrgBtm3OutPoint[k]);
																 TotalCirDis+=   GrindWidthDis;
																 CircleCount++;
															 }
															 if(TotalCirDis!=0.0f && CircleCount!=0){
																 BtmGrindWidth5 = TotalCirDis/CircleCount;
															 }
														 }
													 }
													 ////////////////////////////////////////////////////////////////////////////////////////////////////

													 // GrindMark[10] 가공량,연마량 측정 
													 ////////////////////////////////////////////////////////////////////////////////////////////////////
													 if(GrindMarkPoint[10].x!=0.0f && GrindMarkPoint[10].y!=0.0f){ //GrindMark 찾았을경우 검사 시퀀스 
														 GrindMeaDis =0.0f, MinDis =10000.0f;  Btm3GrindMarkCount=0;

														 for(int k=0; k<OrgBtm3OutEdgeCount; k++){
															 if(OrgBtm3OutPoint[k].x==0.0f || OrgBtm3OutPoint[k].y==0.0f) continue;
															 if(GrindMarkPoint[10].x  ==0.0f || GrindMarkPoint[10].y  ==0.0f) continue;

															 GrindMeaDis = Math.GetLength(GrindMarkPoint[10], OrgBtm3OutPoint[k]);
															 if(GrindMeaDis<MinDis){
																 MinDis = GrindMeaDis;
																 Btm3GrindMarkCount = k;
															 }
														 }
														 // GrindMark기준 수직 포인트 주변값 Avg산출한다 
														 if(Btm3GrindMarkCount!=0 && Btm3GrindMarkCount>5 && (Btm3GrindMarkCount+5)<OrgBtm3OutEdgeCount){
															 CircleCount=0,TotalCirDis=0.0f,GrindMeaDis=0.0f;
															 for(int k=Btm3GrindMarkCount-5; k<Btm3GrindMarkCount+5; k++){
																 if(OrgBtm3OutPoint[k].x==0.0f || OrgBtm3OutPoint[k].y==0.0f) continue;

																 GrindMeaDis = Math.GetLength(GrindMarkPoint[10], OrgBtm3OutPoint[k]);
																 TotalCirDis+= GrindMeaDis;
																 CircleCount++;
															 }
															 if(TotalCirDis!=0.0f && CircleCount!=0){
																 BtmGrindMeasure6 = TotalCirDis/CircleCount;
															 }
														 }
														 // GrindMark기준 수직 평균값 연마량 측정 
														 if(Btm3GrindMarkCount!=0 && Btm3GrindMarkCount>5 && (Btm3GrindMarkCount+5)<OrgBtm3OutEdgeCount){
															 CircleCount=0,TotalCirDis=0.0f,GrindWidthDis=0.0f;
															 for(int k=Btm3GrindMarkCount-5; k<Btm3GrindMarkCount+5; k++){
																 if(OrgBtm3OutPoint[k].x==0.0f && OrgBtm3OutPoint[k].y==0.0f) continue;
																 if(OrgBtm3InPoint [k].x==0.0f && OrgBtm3InPoint [k].y==0.0f) continue;
																 GrindWidthDis = Math.GetLength(OrgBtm3InPoint[k], OrgBtm3OutPoint[k]);
																 TotalCirDis+=   GrindWidthDis;
																 CircleCount++;
															 }
															 if(TotalCirDis!=0.0f && CircleCount!=0){
																 BtmGrindWidth6 = TotalCirDis/CircleCount;
															 }
														 }
													 }
													 else { //GrindMark 못 찾았을경우 검사 시퀀스 (가공량: 0, 연마량 측정)
														 GrindMeaDis =0.0f, MinDis =10000.0f;  Btm3GrindMarkCount=0;
														 for(int k=0; k<OrgBtm3OutEdgeCount; k++){
															 if(OrgBtm3OutPoint[k].x==0.0f || OrgBtm3OutPoint[k].y==0.0f) continue;
															 
															 if(k==0){
																 GrindMarkRectCenter[10].x = OrgBtm3InPoint[OrgBtm3InEdgeCount-7].x ;
																 GrindMarkRectCenter[10].y = GrindMarkRectCenter[9].y               ; 
															     
																 GrindMarkRect [10].left  = GrindMarkRectCenter[10].x - GrindMarkRange ;  
																 GrindMarkRect [10].top   = GrindMarkRectCenter[10].y - GrindMarkRange ;  
																 GrindMarkRect [10].right = GrindMarkRect [10].left   + GrindMarkLength;  
																 GrindMarkRect [10].bottom= GrindMarkRect [10].top    + GrindMarkLength;  
															 }

															 GrindMeaDis = Math.GetLength(GrindMarkRectCenter[10], OrgBtm3OutPoint[k]);
															 if(GrindMeaDis<MinDis){
																 MinDis = GrindMeaDis;
																 Btm3GrindMarkCount = k;
															 }
														 }
														 // GrindMark기준 수직 평균값 연마량 측정 
														 if(Btm3GrindMarkCount!=0 && Btm3GrindMarkCount>5 &&(Btm3GrindMarkCount+5<OrgBtm3OutEdgeCount)){
															 CircleCount=0,TotalCirDis=0.0f,GrindWidthDis=0.0f;
															 for(int k=Btm3GrindMarkCount-5; k<Btm3GrindMarkCount+5; k++){
																 if(OrgBtm3OutPoint[k].x==0.0f && OrgBtm3OutPoint[k].y==0.0f) continue;
																 if(OrgBtm3InPoint [k].x==0.0f && OrgBtm3InPoint [k].y==0.0f) continue;
																 GrindWidthDis = Math.GetLength(OrgBtm3InPoint[k], OrgBtm3OutPoint[k]);
																 TotalCirDis+=   GrindWidthDis;
																 CircleCount++;
															 }
															 if(TotalCirDis!=0.0f && CircleCount!=0){
																 BtmGrindWidth6 = TotalCirDis/CircleCount;
															 }
														 }
													 }
													 ////////////////////////////////////////////////////////////////////////////////////////////////////
												 }
											 }
										 }
										 else { // ENCAP 연마량 데이터만 계측함
											 if(BtmOutLine[2].FP0.x!=0.0f && BtmOutLine[2].FP0.y!=0.0f && BtmOutLine[2].FP1.x!=0.0f && BtmOutLine[2].FP1.y!=0.0f &&
												 BtmInLine [2].FP0.x!=0.0f && BtmInLine [2].FP0.y!=0.0f && BtmInLine [2].FP1.x!=0.0f && BtmInLine [2].FP1.y!=0.0f ) 
											 {
												 // 연마량 계산  
												 if((fabs(BtmOutLine[2].FP0.y - BtmOutLine[2].FP1.y))>1
													 ||(fabs(BtmInLine[2].FP0.y - BtmInLine[2].FP1.y))>1){
														 BtmGrindWidth5 = BtmOutLine[2].FP0.y - BtmInLine[2].FP0.y; 
												 }
												 else{
													 BtmGrindWidth5 = Math.GetLengthFrLineToPoint(BtmOutLine[2].FP0, BtmOutLine[2].FP1, BtmInLine[2].FP0);
												 }
											 }
										 }
										 // 동적 생성한 데이터를 지운다 
										 if(OrgBtm3InPoint !=NULL) delete[] OrgBtm3InPoint;
										 if(OrgBtm3OutPoint!=NULL) delete[] OrgBtm3OutPoint;
										 // 계측목적으로 영역을 줄였던것을  Defect검사 목적으로 다시 넓혀줌 
										 BtmInLine[2].FP0.x = BtmEdgePoint[4].x+100;
										 BtmInLine[2].FP1.x = BtmEdgePoint[5].x-100;
										 LogUnit.SetLog(L"shRectC_Btm3_Insp_End");
									 }

									 // Circle4과 Circle5 사이의 직선영역 검사 
									 if(BtmEdgePoint[6].x!=0 && BtmEdgePoint[6].y!=0 && BtmEdgePoint[7].x!=0 && BtmEdgePoint[7].y!=0 ){ //LEFT
										 LogUnit.SetLog(L"shRectC_Btm4_Insp_Start");

										 if(BtmEdgeThresHold==0)  {SingleLine->GImage = &RotateImg      ;  SingleLine->FThreshold =5 ;}
										 else                     {SingleLine->GImage = &RotateBinaryImg;  SingleLine->FThreshold =10;}

										 SingleLine->IRoi->SetOrgX  (BtmEdgePoint[6].x-LeftMargin         ); 
										 SingleLine->IRoi->SetOrgY  (BtmEdgePoint[6].y                    );
										 SingleLine->IRoi->SetWidth (100                                  );
										 SingleLine->IRoi->SetHeight(BtmEdgePoint[7].y - BtmEdgePoint[6].y);

										 SingleLine->SetOrientation(orWest);
										 SingleLine->FIncrement =10;
										 SingleLine->SetFindLineId(0);
										 SingleLine->FThreshold =5;

										 if(IsMarkBtm) SingleLine->SetEdgeType(1);  //White To Black 
										 else          SingleLine->SetEdgeType(1);  //White To Black 

										 SingleLine->OnExecute();

										 BtmOutLine[3].FP0 = SingleLine->GetResultP0();
										 BtmOutLine[3].FP1 = SingleLine->GetResultP1();

										 // BtmInLine Search 
										 SingleLine->SetEdgeType(0);  //Black To White  
										 SingleLine->OnExecute();
										 BtmInLine[3].FP0 = SingleLine->GetResultP0();
										 BtmInLine[3].FP1 = SingleLine->GetResultP1();

										 // 연마폭 계산  
										 BtmGrindWidth4 = Math.GetLengthFrLineToPoint(BtmOutLine[3].FP0, BtmOutLine[3].FP1, BtmInLine[3].FP0);

										 //연마량 계산 
										 if(IsMarkBtm){
											 if(CirGrindMeaThresHold!=0){
												 SingleLine->GImage = &RotateGrindBinaryImg; //Binary Image 넘겨줌 
												 SingleLine->SetEdgeType(1);  //White To Black 
												 SingleLine->SetFindLineId(0);
												 SingleLine->OnExecute();

												 BtmStandLine[3].FP0 = SingleLine->GetResultP0();
												 BtmStandLine[3].FP1 = SingleLine->GetResultP1();
												 //연마량 계산 
												 BtmGrindMeasure4 = Math.GetLengthFrLineToPoint(BtmOutLine[3].FP0, BtmOutLine[3].FP1, BtmStandLine[3].FP0);
											 }
										 }
										 LogUnit.SetLog(L"shRectC_Btm4_Insp_End");
									 }

									 // Circle5과 Circle6 사이의 직선영역 검사 
									 if(BtmEdgePoint[8].x!=0 && BtmEdgePoint[8].y!=0 && BtmEdgePoint[9].x!=0 && BtmEdgePoint[9].y!=0 ){ //BTM 
										 LogUnit.SetLog(L"shRectC_Btm5_Insp_Start");

										 if(BtmEdgeThresHold==0)    {SingleLine->GImage = &RotateImg      ;  SingleLine->FThreshold =5 ;}
										 else                       {SingleLine->GImage = &RotateBinaryImg;  SingleLine->FThreshold =10;}

										 SingleLine->IRoi->SetOrgX  (BtmEdgePoint[8].x+50                );
										 SingleLine->IRoi->SetOrgY  (BtmEdgePoint[8].y - BtmMargin        );
										 SingleLine->IRoi->SetWidth ((BtmEdgePoint[9].x - BtmEdgePoint[8].x)-100);
										 SingleLine->IRoi->SetHeight(100                                  );
										 if(BtmEdgePoint[8].x+100<=0 || (BtmEdgePoint[8].y-BtmMargin<=0) || ((BtmEdgePoint[9].x-BtmEdgePoint[8].x)-200)<=0 ) return false;

										 SingleLine->SetOrientation(orSouth);
										 // 									 SingleLine->FIncrement =1   ;
										 SingleLine->SetFindLineId(0);
										 SingleLine->FThreshold =5;

										 if(IsMarkBtm) {SingleLine->FIncrement =1 ; SingleLine->SetEdgeType(1);}  //White To Black 
										 else          {SingleLine->FIncrement =10; SingleLine->SetEdgeType(1);}  //White To Black 

										 SingleLine->OnExecute();
										 BtmOutLine[4].FP0 = SingleLine->GetResultP0();
										 BtmOutLine[4].FP1 = SingleLine->GetResultP1();

										 // BtmOutLine Real EdgePoint 추출함 
										 OrgBtm5OutEdgeCount = SingleLine->FEdgePointCount;
										 if(OrgBtm5OutEdgeCount>0){
											 if(OrgBtm5OutPoint!=NULL) delete[] OrgBtm5OutPoint;
											 OrgBtm5OutPoint = new TFPoint[OrgBtm5OutEdgeCount];

											 for(int k=0; k<OrgBtm5OutEdgeCount; k++){
												 if(k>MAX_CIRCLE_EDGEPOINT) break;
												 OrgBtm5OutPoint[k].x = SingleLine->FEdgePoint[k].x;
												 OrgBtm5OutPoint[k].y = SingleLine->FEdgePoint[k].y;
											 }
										 }


										 // BtmInLine Search 
										 if(CirGrindInThresHold==0) {Circle->GImage = &RotateImg             ; SingleLine->FThreshold =5 ;} //Org Image 넘겨줌 
										 else                       {Circle->GImage = &RotateGrindInBinaryImg; SingleLine->FThreshold =10;}//Binary Image 넘겨줌 

										 SingleLine->SetEdgeType(0);  //Black To White  
										 SingleLine->OnExecute();
										 BtmInLine[4].FP0 = SingleLine->GetResultP0();
										 BtmInLine[4].FP1 = SingleLine->GetResultP1();

										 // BtmInLine Real EdgePoint 추출함 
										 OrgBtm5InEdgeCount = SingleLine->FEdgePointCount;
										 if(OrgBtm5InEdgeCount>0){
											 if(OrgBtm5InPoint!=NULL) delete[] OrgBtm5InPoint;
											 OrgBtm5InPoint = new TFPoint[OrgBtm5InEdgeCount];

											 for(int k=0; k<OrgBtm5InEdgeCount; k++){
												 if(k>MAX_CIRCLE_EDGEPOINT) break;
												 OrgBtm5InPoint[k].x = SingleLine->FEdgePoint[k].x;
												 OrgBtm5InPoint[k].y = SingleLine->FEdgePoint[k].y;
											 }
										 }

										 // Grind Mark 기준 연마량 계산 
										 if(IsMarkBtm){ // LT검사시 가공량 측정함 
											 if(FInspectMode==Insp_Track){ // TrackMode TrackLine기준 가공량 측정 
												 if(CirGrindMeaThresHold!=0){
													 // 연마폭 계산  
													 if((fabs(BtmOutLine[4].FP0.y - BtmOutLine[4].FP1.y))>1
														 ||(fabs(BtmInLine[4].FP0.y - BtmInLine[4].FP1.y))>1){
															 BtmGrindWidth5 = BtmOutLine[4].FP1.y - BtmInLine[4].FP1.y; 
													 }
													 else{
														 BtmGrindWidth5 = Math.GetLengthFrLineToPoint(BtmOutLine[4].FP0, BtmOutLine[4].FP1, BtmInLine[4].FP0);
													 }

													 SingleLine->GImage = &RotateGrindBinaryImg; //Binary Image 넘겨줌 
													 SingleLine->SetEdgeType(1);  //White To Black 
													 SingleLine->SetFindLineId(0);
													 SingleLine->OnExecute();

													 BtmStandLine[4].FP0 = SingleLine->GetResultP0();
													 BtmStandLine[4].FP1 = SingleLine->GetResultP1();
													 //연마량 계산 
													 BtmGrindMeasure5 = Math.GetLengthFrLineToPoint(BtmOutLine[4].FP0, BtmOutLine[4].FP1, BtmStandLine[4].FP0);
												 }
											 }
											 else if(Insp_Mark){
												 // GrindMark 상관없이 연마량 측정
												 if(OrgBtm5InEdgeCount>10 && OrgBtm5OutEdgeCount>10 && (OrgBtm5InEdgeCount==OrgBtm5OutEdgeCount)){
													 // 가공량,연마량 측정 전 데이터 존재시 가상GrindMark 생성한다 
													 if(GrindMarkPoint[16].x!=0.0f && GrindMarkPoint[16].y!=0.0f){
														 GrindMarkPoint[14].x     = OrgBtm5InPoint[7 ].x                     ;
														 GrindMarkPoint[14].y     = GrindMarkPoint[16].y                     ;
														 GrindMarkRect [14].left  = GrindMarkPoint[14].x    - GrindMarkRange ;  
														 GrindMarkRect [14].top   = GrindMarkPoint[14].y    - GrindMarkRange ;  
														 GrindMarkRect [14].right = GrindMarkRect [14].left + GrindMarkLength;  
														 GrindMarkRect [14].bottom= GrindMarkRect [14].top  + GrindMarkLength;  
													 }

													 // GrindMark[14] 가공량,연마량 측정 
													 ////////////////////////////////////////////////////////////////////////////////////////////////////
													 if(GrindMarkPoint[14].x!=0.0f && GrindMarkPoint[14].y!=0.0f){ //GrindMark 찾았을경우 검사 시퀀스 가공량 측정 
														 GrindMeaDis =0.0f, MinDis =10000.0f;  Btm5GrindMarkCount=0;
														 for(int k=0; k<OrgBtm5OutEdgeCount; k++){
															 if(OrgBtm5OutPoint[k].x==0.0f || OrgBtm5OutPoint[k].y==0.0f) continue;
															 if(GrindMarkPoint[14].x ==0.0f || GrindMarkPoint[14].y ==0.0f) continue;

															 GrindMeaDis = Math.GetLength(GrindMarkPoint[14], OrgBtm5OutPoint[k]);
															 if(GrindMeaDis<MinDis){
																 MinDis = GrindMeaDis;
																 Btm5GrindMarkCount = k;
															 }
														 }
														 // GrindMark기준 수직 포인트 주변값 Avg산출한다 
														 if(Btm5GrindMarkCount!=0 && Btm5GrindMarkCount>5 && (Btm5GrindMarkCount+5)<OrgBtm5OutEdgeCount){
															 CircleCount=0,TotalCirDis=0.0f,GrindMeaDis=0.0f;
															 for(int k=Btm5GrindMarkCount-5; k<Btm5GrindMarkCount+5; k++){
																 if(OrgBtm5OutPoint[k].x==0.0f || OrgBtm5OutPoint[k].y==0.0f) continue;

																 GrindMeaDis = Math.GetLength(GrindMarkPoint[14], OrgBtm5OutPoint[k]);
																 TotalCirDis+= GrindMeaDis;
																 CircleCount++;
															 }
															 if(TotalCirDis!=0.0f && CircleCount!=0){
																 BtmGrindMeasure7 = TotalCirDis/CircleCount;
															 }
														 }
														 // GrindMark기준 수직 평균값 연마량 측정 
														 if(Btm5GrindMarkCount!=0 && Btm5GrindMarkCount>5 && (Btm5GrindMarkCount+5)<OrgBtm5OutEdgeCount){
															 CircleCount=0,TotalCirDis=0.0f,GrindWidthDis=0.0f;
															 for(int k=Btm5GrindMarkCount-5; k<Btm5GrindMarkCount+5; k++){
																 if(OrgBtm5OutPoint[k].x==0.0f && OrgBtm5OutPoint[k].y==0.0f) continue;
																 if(OrgBtm5InPoint [k].x==0.0f && OrgBtm5InPoint [k].y==0.0f) continue;
																 GrindWidthDis = Math.GetLength(OrgBtm5InPoint[k], OrgBtm5OutPoint[k]);
																 TotalCirDis+=   GrindWidthDis;
																 CircleCount++;
															 }
															 if(TotalCirDis!=0.0f && CircleCount!=0){
																 BtmGrindWidth7 = TotalCirDis/CircleCount;
															 }
														 }
													 }
													 else {  //GrindMark 못 찾았을경우 검사 시퀀스 (가공량: 0, 연마량 측정)
														 GrindMeaDis =0.0f, MinDis =10000.0f;  Btm5GrindMarkCount=0;
														 for(int k=0; k<OrgBtm5OutEdgeCount; k++){
															 if(OrgBtm5OutPoint[k].x==0.0f || OrgBtm5OutPoint[k].y==0.0f) continue;

															 if(k==0){
																 GrindMarkRectCenter[16].x = GrindMarkRect[16].left + (GrindMarkRect[16].right  - GrindMarkRect[16].left)/2; 
																 GrindMarkRectCenter[16].y = GrindMarkRect[16].top  + (GrindMarkRect[16].bottom - GrindMarkRect[16].top )/2; 

																 GrindMarkRectCenter[14].x     = OrgBtm5InPoint     [7 ].x                     ;
																 GrindMarkRectCenter[14].y     = GrindMarkRectCenter[16].y                     ;
																 GrindMarkRect      [14].left  = GrindMarkRectCenter[14].x    - GrindMarkRange ;  
																 GrindMarkRect      [14].top   = GrindMarkRectCenter[14].y    - GrindMarkRange ;  
																 GrindMarkRect      [14].right = GrindMarkRect      [14].left + GrindMarkLength;  
																 GrindMarkRect      [14].bottom= GrindMarkRect      [14].top  + GrindMarkLength;  
															 }

															 GrindMeaDis = Math.GetLength(GrindMarkRectCenter[14], OrgBtm5OutPoint[k]);
															 if(GrindMeaDis<MinDis){
																 MinDis = GrindMeaDis;
																 Btm5GrindMarkCount = k;
															 }
														 }
														 // GrindMark기준 수직 평균값 연마량 측정 
														 if(Btm5GrindMarkCount!=0 && Btm5GrindMarkCount>5 &&(Btm5GrindMarkCount+5<OrgBtm5OutEdgeCount)){
															 CircleCount=0,TotalCirDis=0.0f,GrindWidthDis=0.0f;
															 for(int k=Btm5GrindMarkCount-5; k<Btm5GrindMarkCount+5; k++){
																 if(OrgBtm5OutPoint[k].x==0.0f && OrgBtm5OutPoint[k].y==0.0f) continue;
																 if(OrgBtm5InPoint [k].x==0.0f && OrgBtm5InPoint [k].y==0.0f) continue;
																 GrindWidthDis = Math.GetLength(OrgBtm5InPoint[k], OrgBtm5OutPoint[k]);
																 TotalCirDis+=   GrindWidthDis;
																 CircleCount++;
															 }
															 if(TotalCirDis!=0.0f && CircleCount!=0){
																 BtmGrindWidth7 = TotalCirDis/CircleCount;
															 }
														 }
													 }
													 ////////////////////////////////////////////////////////////////////////////////////////////////////

													 // GrindMark[14] 가공량,연마량 측정 
													 ////////////////////////////////////////////////////////////////////////////////////////////////////
													 if(GrindMarkPoint[16].x!=0.0f && GrindMarkPoint[16].y!=0.0f){ //GrindMark 찾았을경우 검사 시퀀스 가공량 측정 
														 GrindMeaDis =0.0f, MinDis =10000.0f;  Btm5GrindMarkCount=0;
														 for(int k=0; k<OrgBtm5OutEdgeCount; k++){
															 if(OrgBtm5OutPoint[k].x==0.0f || OrgBtm5OutPoint[k ].y==0.0f) continue;
															 if(GrindMarkPoint[16].x==0.0f || GrindMarkPoint[16].y ==0.0f) continue;

															 GrindMeaDis = Math.GetLength(GrindMarkPoint[16], OrgBtm5OutPoint[k]);
															 if(GrindMeaDis<MinDis){
																 MinDis = GrindMeaDis;
																 Btm5GrindMarkCount = k;
															 }
														 }
														 // GrindMark기준 수직 포인트 주변값 Avg산출한다 
														 if(Btm5GrindMarkCount!=0 && Btm5GrindMarkCount>5 && (Btm5GrindMarkCount+5)<OrgBtm5OutEdgeCount){
															 CircleCount=0,TotalCirDis=0.0f,GrindMeaDis=0.0f;
															 for(int k=Btm5GrindMarkCount-5; k<Btm5GrindMarkCount+5; k++){
																 if(OrgBtm5OutPoint[k].x==0.0f || OrgBtm5OutPoint[k].y==0.0f) continue;

																 GrindMeaDis = Math.GetLength(GrindMarkPoint[16], OrgBtm5OutPoint[k]);
																 TotalCirDis+= GrindMeaDis;
																 CircleCount++;
															 }
															 if(TotalCirDis!=0.0f && CircleCount!=0){
																 BtmGrindMeasure9 = TotalCirDis/CircleCount;
															 }
														 }
														 // GrindMark기준 수직 평균값 연마량 측정 
														 if(Btm5GrindMarkCount!=0 && Btm5GrindMarkCount>5 && (Btm5GrindMarkCount+5)<OrgBtm5OutEdgeCount){
															 CircleCount=0,TotalCirDis=0.0f,GrindWidthDis=0.0f;
															 for(int k=Btm5GrindMarkCount-5; k<Btm5GrindMarkCount+5; k++){
																 if(OrgBtm5OutPoint[k].x==0.0f && OrgBtm5OutPoint[k].y==0.0f) continue;
																 if(OrgBtm5InPoint [k].x==0.0f && OrgBtm5InPoint [k].y==0.0f) continue;
																 GrindWidthDis = Math.GetLength(OrgBtm5InPoint[k], OrgBtm5OutPoint[k]);
																 TotalCirDis+=   GrindWidthDis;
																 CircleCount++;
															 }
															 if(TotalCirDis!=0.0f && CircleCount!=0){
																 BtmGrindWidth9 = TotalCirDis/CircleCount;
															 }
														 }
													 }
													 else {  //GrindMark 못 찾았을경우 검사 시퀀스 (가공량: 0, 연마량 측정)
														 GrindMeaDis =0.0f, MinDis =10000.0f;  Btm5GrindMarkCount=0;
														 for(int k=0; k<OrgBtm5OutEdgeCount; k++){
															 if(OrgBtm5OutPoint[k].x==0.0f || OrgBtm5OutPoint[k].y==0.0f) continue;

															 GrindMarkRectCenter[16].x = GrindMarkRect[16].left + (GrindMarkRect[16].right  - GrindMarkRect[16].left)/2; 
															 GrindMarkRectCenter[16].y = GrindMarkRect[16].top  + (GrindMarkRect[16].bottom - GrindMarkRect[16].top )/2; 

															 GrindMeaDis = Math.GetLength(GrindMarkRectCenter[16], OrgBtm5OutPoint[k]);
															 if(GrindMeaDis<MinDis){
																 MinDis = GrindMeaDis;
																 Btm5GrindMarkCount = k;
															 }
														 }
														 // GrindMark기준 수직 평균값 연마량 측정 
														 if(Btm5GrindMarkCount!=0 && Btm5GrindMarkCount>5 &&(Btm5GrindMarkCount+5<OrgBtm5OutEdgeCount)){
															 CircleCount=0,TotalCirDis=0.0f,GrindWidthDis=0.0f;
															 for(int k=Btm5GrindMarkCount-5; k<Btm5GrindMarkCount+5; k++){
																 if(OrgBtm5OutPoint[k].x==0.0f && OrgBtm5OutPoint[k].y==0.0f) continue;
																 if(OrgBtm5InPoint [k].x==0.0f && OrgBtm5InPoint [k].y==0.0f) continue;
																 GrindWidthDis = Math.GetLength(OrgBtm5InPoint[k], OrgBtm5OutPoint[k]);
																 TotalCirDis+=   GrindWidthDis;
																 CircleCount++;
															 }
															 if(TotalCirDis!=0.0f && CircleCount!=0){
																 BtmGrindWidth9 = TotalCirDis/CircleCount;
															 }
														 }
													 }
													 ///////////////////////////////////////////////////////////////////////////////////////////////////////
												 }

												 // 											 if(BtmGrindWidth5!=0.0f && GrindMarkPoint[16].x!=0.0f && GrindMarkPoint[16].y!=0.0f){ // MarkMode GrindMark중심 좌표 기준 가공량 측정 
												 // 												 if(fabs(BtmOutLine[4].FP0.y - BtmOutLine[4].FP1.y)>2){
												 // // 													 BtmGrindWidth5   = (BtmOutLine[4].FP1.y  - GrindMarkPoint[8].y) - (BtmInLine[4].FP1.y - GrindMarkPoint[8].y);
												 // 													 BtmGrindMeasure5 = BtmOutLine[4].FP1.y - GrindMarkPoint[16].y; 
												 // 												 }
												 // 												 else {
												 // 													 BtmGrindMeasure5 = Math.GetLengthFrLineToPoint(BtmOutLine[4].FP0, BtmOutLine[4].FP1, GrindMarkPoint[16]);
												 // // 													 BtmGrindWidth5   = BtmGrindMeasure5 - Math.GetLengthFrLineToPoint(BtmInLine[4].FP0, BtmInLine[4].FP1, GrindMarkPoint[8]);
												 // 												 }
												 // 											 }
											 }
										 }
										 else { // ENCAP 연마량 데이터만 계측함
											 if(BtmOutLine[4].FP0.x!=0.0f && BtmOutLine[4].FP0.y!=0.0f && BtmOutLine[4].FP1.x!=0.0f && BtmOutLine[4].FP1.y!=0.0f &&
												 BtmInLine [4].FP0.x!=0.0f && BtmInLine [4].FP0.y!=0.0f && BtmInLine [4].FP1.x!=0.0f && BtmInLine [4].FP1.y!=0.0f ) 
											 {
												 // 연마량 계산  
												 if((fabs(BtmOutLine[4].FP0.y - BtmOutLine[4].FP1.y))>1
													 ||(fabs(BtmInLine[4].FP0.y - BtmInLine[4].FP1.y))>1){
														 BtmGrindWidth9 = BtmOutLine[4].FP0.y - BtmInLine[4].FP0.y; 
												 }
												 else{
													 BtmGrindWidth9 = Math.GetLengthFrLineToPoint(BtmOutLine[4].FP0, BtmOutLine[4].FP1, BtmInLine[4].FP0);
												 }
											 }
										 }
										 // 동적 생성한 데이터를 지운다 
										 if(OrgBtm5InPoint !=NULL) delete[] OrgBtm5InPoint;
										 if(OrgBtm5OutPoint!=NULL) delete[] OrgBtm5OutPoint;
										 LogUnit.SetLog(L"shRectC_Btm5_Insp_End");
									 }

									 //RF_MODEL 정말 소스가 점점...더러워진다...ㅜ.ㅜ;;;
									 //Notch부 Side만 Arc가공이 존재할 경우 
									 if(C2CirCenter.x==0.0f && C2CirCenter.y==0.0f && C3CirCenter.x==0.0f && C3CirCenter.y==0.0f && 
										 C4CirCenter.x==0.0f && C4CirCenter.y==0.0f && C5CirCenter.x==0.0f && C5CirCenter.y==0.0f){
										 // 개별 Circle Data 교차점 기준 직선영역의 새로운 Btm영역 BtmOutLine, BtmInLine 찾는다 
										 // Circle1과 Circle6 사이의 직선영역 검사
										 const int BtmMargin =50; const int LeftMargin =30; const int RightMargin =30;
										 if(BtmEdgePoint[0].x!=0 && BtmEdgePoint[0].y!=0 && BtmEdgePoint[9].x!=0 && BtmEdgePoint[9].y!=0 ){ // BTM
											 LogUnit.SetLog(L"shRectC_Btm1_RF_Insp_Start");

											 if(BtmEdgeThresHold==0)    {SingleLine->GImage = &RotateImg      ;  SingleLine->FThreshold =5 ;}
											 else                       {SingleLine->GImage = &RotateBinaryImg;  SingleLine->FThreshold =10;}

											 // BtmOutLine Search 
											 SingleLine->IRoi->SetOrgX  (BtmEdgePoint[0].x+100                       );
											 SingleLine->IRoi->SetOrgY  (BtmEdgePoint[0].y - BtmMargin              );
											 SingleLine->IRoi->SetWidth ((BtmEdgePoint[9].x - BtmEdgePoint[0].x)-200);
											 SingleLine->IRoi->SetHeight(100                                        );
											 if(BtmEdgePoint[0].x+100<=0 || (BtmEdgePoint[0].y-BtmMargin<=0) || ((BtmEdgePoint[9].x-BtmEdgePoint[0].x)-200)<=0 ) return false;

											 SingleLine->SetOrientation(orSouth);
											 // 									 SingleLine->FIncrement =1   ;
											 SingleLine->SetFindLineId(0);
											 SingleLine->FThreshold =5;

											 if(IsMarkBtm) {SingleLine->FIncrement =20; SingleLine->SetEdgeType(1);}  //White To Black 
											 else          {SingleLine->FIncrement =20; SingleLine->SetEdgeType(1);}  //White To Black 

											 SingleLine->OnExecute();
											 BtmOutLine[0].FP0 = SingleLine->GetResultP0();
											 BtmOutLine[0].FP1 = SingleLine->GetResultP1();

											 // BtmInLine Search 
											 if(CirGrindInThresHold==0) {Circle->GImage = &RotateImg             ; SingleLine->FThreshold =5 ;} //Org Image 넘겨줌 
											 else                       {Circle->GImage = &RotateGrindInBinaryImg; SingleLine->FThreshold =10;}//Binary Image 넘겨줌 

											 SingleLine->SetEdgeType(0);  //Black To White  
											 SingleLine->OnExecute();
											 BtmInLine[0].FP0 = SingleLine->GetResultP0();
											 BtmInLine[0].FP1 = SingleLine->GetResultP1();

											 // Grind Mark 기준 연마량 계산 
											 if(IsMarkBtm){ // LT검사시 가공량 측정함 
												 if(FInspectMode==Insp_Track){ // TrackMode TrackLine기준 가공량 측정 
													 if(CirGrindMeaThresHold!=0){
														 // 연마량 계산  
														 if((fabs(BtmOutLine[0].FP0.y - BtmOutLine[0].FP1.y))>1
															 ||(fabs(BtmInLine[0].FP0.y - BtmInLine[0].FP1.y))>1){
																 BtmGrindWidth1 = BtmOutLine[0].FP0.y - BtmInLine[0].FP0.y; 
														 }
														 else{
															 BtmGrindWidth1 = Math.GetLengthFrLineToPoint(BtmOutLine[0].FP0, BtmOutLine[0].FP1, BtmInLine[0].FP0);
														 }

														 SingleLine->GImage = &RotateGrindBinaryImg; //Binary Image 넘겨줌 
														 SingleLine->SetEdgeType(1);  //White To Black 
														 SingleLine->SetFindLineId(0);
														 SingleLine->OnExecute();

														 BtmStandLine[0].FP0 = SingleLine->GetResultP0();
														 BtmStandLine[0].FP1 = SingleLine->GetResultP1();
														 // 가공량 계산 
														 BtmGrindMeasure1 = Math.GetLengthFrLineToPoint(BtmOutLine[0].FP0, BtmOutLine[0].FP1, BtmStandLine[0].FP0);
													 }
												 }
												 else if(FInspectMode==Insp_Mark){ // RF_MODEL GrindMark 기준 특정 Point 개별 EdgePoint 데이터를 산출하여 연마량,가공량 계산
													 // GrindMark[2] 시퀀스 시작 
													 if(GrindMarkRect[2].left!=0.0f && GrindMarkRect[2].top!=0.0f && GrindMarkRect[2].right!=0.0f && GrindMarkRect[2].bottom!=0.0f){ //GrindMark 찾았을경우 검사 시퀀스 가공량 측정 
														 if(BtmEdgeThresHold==0)    {SingleLine->GImage = &RotateImg      ;  SingleLine->FThreshold =5 ;}
														 else                       {SingleLine->GImage = &RotateBinaryImg;  SingleLine->FThreshold =10;}

														 // Btm1OutLine
														 SingleLine->IRoi->SetOrgX  (GrindMarkRect[2].left-50                            );
														 SingleLine->IRoi->SetOrgY  (BtmOutLine[0].FP0.y - BtmMargin                     );
														 SingleLine->IRoi->SetWidth ((GrindMarkRect[2].right - GrindMarkRect[2].left)+100);
														 SingleLine->IRoi->SetHeight(100                                                 );
														 if(GrindMarkRect[2].left-50 <=0 || (BtmOutLine[0].FP0.y - BtmMargin<=0) || ((GrindMarkRect[2].right - GrindMarkRect[2].left)+100)<=0 ) return false;

														 SingleLine->SetOrientation(orSouth);
														 SingleLine->SetFindLineId(0);
														 SingleLine->FThreshold =5;

														 if(IsMarkBtm) {SingleLine->FIncrement =1; SingleLine->SetEdgeType(1);}  //White To Black 
														 else          {SingleLine->FIncrement =1; SingleLine->SetEdgeType(1);}  //White To Black 

														 SingleLine->OnExecute();

														 // Btm1OutLine Real EdgePoint 추출함 
														 OrgBtm1OutEdgeCount = SingleLine->FEdgePointCount;
														 if(OrgBtm1OutEdgeCount>0){
															 if(OrgBtm1OutPoint!=NULL) delete[] OrgBtm1OutPoint;
															 OrgBtm1OutPoint = new TFPoint[OrgBtm1OutEdgeCount];

															 for(int k=0; k<OrgBtm1OutEdgeCount; k++){
																 if(k>MAX_CIRCLE_EDGEPOINT) break;
																 OrgBtm1OutPoint[k].x = SingleLine->FEdgePoint[k].x;
																 OrgBtm1OutPoint[k].y = SingleLine->FEdgePoint[k].y;
															 }
														 }

														 // GrindMarkPoint 검출 유무에 따라서 연마량,가공량 측정한다 
														 if(GrindMarkPoint[2].x!=0.0f && GrindMarkPoint[2].y!=0.0f){ //GrindMark 찾았을경우 검사 시퀀스 연마량,가공량 측정 
															 GrindMeaDis =0.0f, MinDis =10000.0f;  Btm1GrindMarkCount=0;
															 for(int k=0; k<OrgBtm1OutEdgeCount; k++){
																 if(OrgBtm1OutPoint[k].x==0.0f || OrgBtm1OutPoint[k].y==0.0f) continue;
																 if(GrindMarkPoint[2].x ==0.0f || GrindMarkPoint[2].y ==0.0f) continue;

																 GrindMeaDis = Math.GetLength(GrindMarkPoint[2], OrgBtm1OutPoint[k]);
																 if(GrindMeaDis<MinDis){
																	 MinDis = GrindMeaDis;
																	 Btm1GrindMarkCount = k;
																 }
															 }
															 // GrindMark기준 수직 포인트 주변값 Avg산출한다 
															 if(Btm1GrindMarkCount!=0 && Btm1GrindMarkCount>5 && (Btm1GrindMarkCount+5)<OrgBtm1OutEdgeCount){
																 CircleCount=0,TotalCirDis=0.0f,GrindMeaDis=0.0f;
																 for(int k=Btm1GrindMarkCount-5; k<Btm1GrindMarkCount+5; k++){
																	 if(OrgBtm1OutPoint[k].x==0.0f || OrgBtm1OutPoint[k].y==0.0f) continue;

																	 GrindMeaDis = Math.GetLength(GrindMarkPoint[2], OrgBtm1OutPoint[k]);
																	 TotalCirDis+= GrindMeaDis;
																	 CircleCount++;
																 }
																 if(TotalCirDis!=0.0f && CircleCount!=0){
																	 BtmGrindMeasure1 = TotalCirDis/CircleCount;
																 }
															 }
														 }
													 }

													 // GrindMark[9] 시퀀스 시작 
													 if(GrindMarkRect[9].left!=0.0f && GrindMarkRect[9].top!=0.0f && GrindMarkRect[9].right!=0.0f && GrindMarkRect[9].bottom!=0.0f){ //GrindMark 찾았을경우 검사 시퀀스 가공량 측정 
														 if(BtmEdgeThresHold==0)    {SingleLine->GImage = &RotateImg      ;  SingleLine->FThreshold =5 ;}
														 else                       {SingleLine->GImage = &RotateBinaryImg;  SingleLine->FThreshold =10;}

														 // Btm1OutLine
														 SingleLine->IRoi->SetOrgX  (GrindMarkRect[9].left-50                            );
														 SingleLine->IRoi->SetOrgY  (BtmOutLine[0].FP0.y - BtmMargin                     );
														 SingleLine->IRoi->SetWidth ((GrindMarkRect[9].right - GrindMarkRect[9].left)+100);
														 SingleLine->IRoi->SetHeight(100                                                 );
														 if(GrindMarkRect[9].left-50 <=0 || (BtmOutLine[0].FP0.y - BtmMargin<=0) || ((GrindMarkRect[9].right - GrindMarkRect[9].left)+100)<=0 ) return false;

														 SingleLine->SetOrientation(orSouth);
														 SingleLine->SetFindLineId(0);
														 SingleLine->FThreshold =5;

														 if(IsMarkBtm) {SingleLine->FIncrement =1; SingleLine->SetEdgeType(1);}  //White To Black 
														 else          {SingleLine->FIncrement =1; SingleLine->SetEdgeType(1);}  //White To Black 

														 SingleLine->OnExecute();

														 // Btm1OutLine Real EdgePoint 추출함 
														 OrgBtm3OutEdgeCount = SingleLine->FEdgePointCount;
														 if(OrgBtm3OutEdgeCount>0){
															 if(OrgBtm1OutPoint!=NULL) delete[] OrgBtm3OutPoint;
															 OrgBtm3OutPoint = new TFPoint[OrgBtm3OutEdgeCount];

															 for(int k=0; k<OrgBtm3OutEdgeCount; k++){
																 if(k>MAX_CIRCLE_EDGEPOINT) break;
																 OrgBtm3OutPoint[k].x = SingleLine->FEdgePoint[k].x;
																 OrgBtm3OutPoint[k].y = SingleLine->FEdgePoint[k].y;
															 }
														 }

														 // GrindMarkPoint 검출 유무에 따라서 연마량,가공량 측정한다 
														 if(GrindMarkPoint[9].x!=0.0f && GrindMarkPoint[9].y!=0.0f){ //GrindMark 찾았을경우 검사 시퀀스 연마량,가공량 측정 
															 GrindMeaDis =0.0f, MinDis =10000.0f;  Btm3GrindMarkCount=0;
															 for(int k=0; k<OrgBtm3OutEdgeCount; k++){
																 if(OrgBtm3OutPoint[k].x==0.0f || OrgBtm3OutPoint[k].y==0.0f) continue;
																 if(GrindMarkPoint[9].x ==0.0f || GrindMarkPoint[9].y ==0.0f) continue;

																 GrindMeaDis = Math.GetLength(GrindMarkPoint[9], OrgBtm3OutPoint[k]);
																 if(GrindMeaDis<MinDis){
																	 MinDis = GrindMeaDis;
																	 Btm3GrindMarkCount = k;
																 }
															 }
															 // GrindMark기준 수직 포인트 주변값 Avg산출한다 
															 if(Btm3GrindMarkCount!=0 && Btm3GrindMarkCount>5 && (Btm3GrindMarkCount+5)<OrgBtm3OutEdgeCount){
																 CircleCount=0,TotalCirDis=0.0f,GrindMeaDis=0.0f;
																 for(int k=Btm3GrindMarkCount-5; k<Btm3GrindMarkCount+5; k++){
																	 if(OrgBtm3OutPoint[k].x==0.0f || OrgBtm3OutPoint[k].y==0.0f) continue;

																	 GrindMeaDis = Math.GetLength(GrindMarkPoint[9], OrgBtm3OutPoint[k]);
																	 TotalCirDis+= GrindMeaDis;
																	 CircleCount++;
																 }
																 if(TotalCirDis!=0.0f && CircleCount!=0){
																	 BtmGrindMeasure5 = TotalCirDis/CircleCount;
																 }
															 }
														 }
													 }

													 // GrindMark[16] 시퀀스 시작 
													 if(GrindMarkRect[16].left!=0.0f && GrindMarkRect[16].top!=0.0f && GrindMarkRect[16].right!=0.0f && GrindMarkRect[16].bottom!=0.0f){ //GrindMark 찾았을경우 검사 시퀀스 가공량 측정 
														 if(BtmEdgeThresHold==0)    {SingleLine->GImage = &RotateImg      ;  SingleLine->FThreshold =5 ;}
														 else                       {SingleLine->GImage = &RotateBinaryImg;  SingleLine->FThreshold =10;}

														 // Btm1OutLine
														 SingleLine->IRoi->SetOrgX  (GrindMarkRect[16].left-50                           );
														 SingleLine->IRoi->SetOrgY  (BtmOutLine[0].FP1.y - BtmMargin                     );
														 SingleLine->IRoi->SetWidth ((GrindMarkRect[16].right - GrindMarkRect[16].left)+100);
														 SingleLine->IRoi->SetHeight(100                                                 );
														 if(GrindMarkRect[16].left-50 <=0 || (BtmOutLine[0].FP1.y - BtmMargin<=0) || ((GrindMarkRect[16].right - GrindMarkRect[16].left)+100)<=0 ) return false;

														 SingleLine->SetOrientation(orSouth);
														 SingleLine->SetFindLineId(0);
														 SingleLine->FThreshold =5;

														 if(IsMarkBtm) {SingleLine->FIncrement =1; SingleLine->SetEdgeType(1);}  //White To Black 
														 else          {SingleLine->FIncrement =1; SingleLine->SetEdgeType(1);}  //White To Black 

														 SingleLine->OnExecute();

														 // Btm1OutLine Real EdgePoint 추출함 
														 OrgBtm5OutEdgeCount = SingleLine->FEdgePointCount;
														 if(OrgBtm5OutEdgeCount>0){
															 if(OrgBtm5OutPoint!=NULL) delete[] OrgBtm5OutPoint;
															 OrgBtm5OutPoint = new TFPoint[OrgBtm5OutEdgeCount];

															 for(int k=0; k<OrgBtm5OutEdgeCount; k++){
																 if(k>MAX_CIRCLE_EDGEPOINT) break;
																 OrgBtm5OutPoint[k].x = SingleLine->FEdgePoint[k].x;
																 OrgBtm5OutPoint[k].y = SingleLine->FEdgePoint[k].y;
															 }
														 }

														 // GrindMarkPoint 검출 유무에 따라서 연마량,가공량 측정한다 
														 if(GrindMarkPoint[16].x!=0.0f && GrindMarkPoint[16].y!=0.0f){ //GrindMark 찾았을경우 검사 시퀀스 연마량,가공량 측정 
															 GrindMeaDis =0.0f, MinDis =10000.0f;  Btm5GrindMarkCount=0;
															 for(int k=0; k<OrgBtm5OutEdgeCount; k++){
																 if(OrgBtm5OutPoint[k].x==0.0f || OrgBtm5OutPoint[k].y==0.0f) continue;
																 if(GrindMarkPoint[16].x==0.0f || GrindMarkPoint[16].y==0.0f) continue;

																 GrindMeaDis = Math.GetLength(GrindMarkPoint[16], OrgBtm5OutPoint[k]);
																 if(GrindMeaDis<MinDis){
																	 MinDis = GrindMeaDis;
																	 Btm5GrindMarkCount = k;
																 }
															 }
															 // GrindMark기준 수직 포인트 주변값 Avg산출한다 
															 if(Btm5GrindMarkCount!=0 && Btm5GrindMarkCount>5 && (Btm5GrindMarkCount+5)<OrgBtm5OutEdgeCount){
																 CircleCount=0,TotalCirDis=0.0f,GrindMeaDis=0.0f;
																 for(int k=Btm5GrindMarkCount-5; k<Btm5GrindMarkCount+5; k++){
																	 if(OrgBtm5OutPoint[k].x==0.0f || OrgBtm5OutPoint[k].y==0.0f) continue;

																	 GrindMeaDis = Math.GetLength(GrindMarkPoint[16], OrgBtm5OutPoint[k]);
																	 TotalCirDis+= GrindMeaDis;
																	 CircleCount++;
																 }
																 if(TotalCirDis!=0.0f && CircleCount!=0){
																	 BtmGrindMeasure9 = TotalCirDis/CircleCount;
																 }
															 }
														 }
													 }
												 }
											 }
											 else { // ENCAP 연마량 데이터만 계측함
												 if(BtmOutLine[0].FP0.x!=0.0f && BtmOutLine[0].FP0.y!=0.0f && BtmOutLine[0].FP1.x!=0.0f && BtmOutLine[0].FP1.y!=0.0f &&
													 BtmInLine [0].FP0.x!=0.0f && BtmInLine [0].FP0.y!=0.0f && BtmInLine [0].FP1.x!=0.0f && BtmInLine [0].FP1.y!=0.0f ){
														 // 연마량 계산  
														 if((fabs(BtmOutLine[0].FP0.y - BtmOutLine[0].FP1.y))>1
															 ||(fabs(BtmInLine[0].FP0.y - BtmInLine[0].FP1.y))>1){
																 BtmGrindWidth1 = BtmOutLine[0].FP0.y - BtmInLine[0].FP0.y; 
																 BtmGrindWidth5 = BtmOutLine[0].FP0.y - BtmInLine[0].FP0.y; 
																 BtmGrindWidth9 = BtmOutLine[0].FP0.y - BtmInLine[0].FP0.y; 
														 }
														 else{
															 BtmGrindWidth1 = Math.GetLengthFrLineToPoint(BtmOutLine[0].FP0, BtmOutLine[0].FP1, BtmInLine[0].FP0);
															 BtmGrindWidth5 = Math.GetLengthFrLineToPoint(BtmOutLine[0].FP0, BtmOutLine[0].FP1, BtmInLine[0].FP0);
															 BtmGrindWidth9 = Math.GetLengthFrLineToPoint(BtmOutLine[0].FP0, BtmOutLine[0].FP1, BtmInLine[0].FP0);
														 }
												 }
											 }
											 // 동적 생성한 데이터를 지운다 
											 if(OrgBtm1OutPoint!=NULL) delete[] OrgBtm1OutPoint;
											 if(OrgBtm3OutPoint!=NULL) delete[] OrgBtm3OutPoint;
											 if(OrgBtm5OutPoint!=NULL) delete[] OrgBtm5OutPoint;
											 LogUnit.SetLog(L"shRectC_Btm1_RF_Insp_End");
										 }
									 }
								 }           
							 }       
						 }
					 }
					 else if(FCompanyMode==COM_BMDT){ // BMDT_shRectC Image Rotate Sequence
						 // Image Roate 전 원본이미지 기준 교차점 산출 
						 FLBPoint = Math.OnIntersect(Line[0].FP0 , Line[0].FP1 , Line[3].FP0, Line[3].FP1);
						 FRBPoint = Math.OnIntersect(Line[2].FP0 , Line[2].FP1 , Line[3].FP0, Line[3].FP1);

						 if(FLBPoint.x!=0 && FLBPoint.y!=0 && FRBPoint.x!=0 && FRBPoint.y!=0) ImgDegree = -(Math.GetDegree(FLBPoint.x , FLBPoint.y, FRBPoint.x, FRBPoint.y));

						 LogUnit.SetLog(L"shRectC_RotateImg_Start");
						 RotateImg.SetSize(GImage->GetWidth(), GImage->GetHeight());
						 EasyImage::Oper(EArithmeticLogicOperation_Copy,GImage,&RotateImg);

						 // 원본 복사하여 이미지 회전 
						 EasyImage::ScaleRotate(GImage, (float)ImgW/2, (float)ImgH/2, (float)ImgW/2, (float)ImgH/2, 1.0f, 1.0f, ImgDegree, &RotateImg, 4);
						 CenterPoint.x = ImgW/2;
						 CenterPoint.y = ImgH/2;
						 //EasyImage::ScaleRotate(GImage, (float)ImgW/2, (float)ImgH/2, (float)ImgW/2, (float)ImgH/2, 1.0f, 0.2f, ImgDegree, &RotateImg, 0);
						 //EasyImage::ScaleRotate(GImage, (float)ImgW/2, (float)ImgH/2, (float)ImgW/2, (float)ImgH/2, 1.0f, 1.0f, ImgDegree, &RotateImg, 0);
						 //GImage->Save   ("D:\\ROTATE_IMG\\GImage_CUP.bmp");
						 //RotateImg.Save("D:\\ROTATE_IMG\\RotateImg회전_CUP.bmp");

						 // Binary RotateImg Size 설정 및 복사 
						 RotateBinaryImg.SetSize(RotateImg.GetWidth(), RotateImg.GetHeight());
						 EasyImage::Oper(EArithmeticLogicOperation_Copy,&RotateImg,&RotateBinaryImg);

						 // Circle Grind In EdgePoint 검출목적 이미지 
						 RotateGrindInBinaryImg.SetSize(RotateImg.GetWidth(), RotateImg.GetHeight());
						 EasyImage::Oper(EArithmeticLogicOperation_Copy,&RotateImg,&RotateGrindInBinaryImg);

						 // Grind Measure Corner, Circle 검사 목적 
						 RotateGrindBinaryImg.SetSize(RotateImg.GetWidth(), RotateImg.GetHeight());
						 EasyImage::Oper(EArithmeticLogicOperation_Copy,&RotateImg,&RotateGrindBinaryImg);
// 						 RotateImg.Save("D:\\ROTATE_IMG\\RotateImg회전_CUP.bmp");
						 LogUnit.SetLog(L"shRectC_RotateImg_End");

						 if(FLeftWall){ // Image 회전 후 LeftLine Search 
							 EasyImage::Threshold(&RotateImg,&RotateBinaryImg, LeftEdgeThresHold);
							 if(LeftEdgeThresHold==0) {SingleLine->GImage = &RotateImg      ;  SingleLine->FThreshold =5 ;}
							 else                     {SingleLine->GImage = &RotateBinaryImg;  SingleLine->FThreshold =10;}

							 if(FInspectMode==Insp_Surface){ //표면검사 시퀀스//
								 SingleLine->IRoi->SetOrgX  (IRoi->GetOrgX()          );
								 SingleLine->IRoi->SetOrgY  (IRoi->GetOrgY()          );
								 SingleLine->IRoi->SetWidth (IRoi->GetWidth()         );
								 SingleLine->IRoi->SetHeight(FEndLine-CSideCircleHeight);
								 SingleLine->SetIncrement(5 );

								 SingleLine->SetOrientation(orWest);

								 SingleLine->SetFindLineId(0);

								 if(IsMarkBtm) SingleLine->SetEdgeType(1); // White To Black  
								 else          SingleLine->SetEdgeType(1); // White to Black  

								 SingleLine->OnExecute();
								 Line[0].FP0 = SingleLine->GetResultP0();
								 Line[0].FP1 = SingleLine->GetResultP1();

								 // Btm,Top 상관없이 첫번째
								 LeftOutLine[0].FP0.x = Line[0].FP0.x;
								 LeftOutLine[0].FP0.y = Line[0].FP0.y;
								 LeftOutLine[0].FP1.x = Line[0].FP1.x;
								 LeftOutLine[0].FP1.y = Line[0].FP1.y;

								 if(fabs(LeftOutLine[0].FP0.x - LeftOutLine[0].FP1.x)>=0.5){
									 LeftOutLine[0].FP0.x = (LeftOutLine[0].FP0.x+LeftOutLine[0].FP1.x)/2.0;
									 LeftOutLine[0].FP1.x = (LeftOutLine[0].FP0.x+LeftOutLine[0].FP1.x)/2.0;
								 }

								 // LeftOutLine....make OutLine Data 
								 // 현재의 데이터를 넘겨준다 
								 // 검사중 기준라인을 찾지 못할경우 이전데이터 넘겨줘서 기준라인 생성함 
								 if(LeftOutLine[0].FP0.x!=0.0f && LeftOutLine[0].FP0.y!=0.0f && LeftOutLine[0].FP1.x!=0.0f && LeftOutLine[0].FP1.y!=0.0f){
									 PreLeftOutLine[0].FP0.x = LeftOutLine[0].FP0.x;    PreLeftOutLine[0].FP1.x = LeftOutLine[0].FP1.x;       
									 PreLeftOutLine[0].FP0.y = LeftOutLine[0].FP0.y;    PreLeftOutLine[0].FP1.y = LeftOutLine[0].FP1.y;       
								 } // 셀의 상단 시작부터 Broken 발생으로 데이터가 없는경우 
								 else if(LeftOutLine[0].FP0.x==0.0f || LeftOutLine[0].FP0.y==0.0f || LeftOutLine[0].FP1.x==0.0f || LeftOutLine[0].FP1.y==0.0f){
									 if(PreLeftOutLine[0].FP0.x==0.0f && PreLeftOutLine[0].FP0.y==0.0f && PreLeftOutLine[0].FP1.x==0.0f && PreLeftOutLine[0].FP1.y==0.0f){// 시작부분 Broken발생으로 데이터가 없는경우 
										 // Mark좌표를 기준으로 라인좌표값을 다시 설정함 
										 ROI_H = IRoi->GetHeight();
										 LeftOutLine[0].FP0.x = Line[0].FP0.x;    LeftOutLine[0].FP0.y = 0.0f        ;
										 LeftOutLine[0].FP1.x = Line[0].FP1.x;    LeftOutLine[0].FP1.y = (float)ROI_H;

										 //Line 데이터를 PreLine에 넘겨준다 
										 PreLeftOutLine[0].FP0.x = LeftOutLine[0].FP0.x;    PreLeftOutLine[0].FP1.x = LeftOutLine[0].FP1.x;       
										 PreLeftOutLine[0].FP0.y = LeftOutLine[0].FP0.y;    PreLeftOutLine[0].FP1.y = LeftOutLine[0].FP1.y;       
									 }
									 else { // 중간부분 Broken발생으로 데이터가 없는경우 
										 // PreLine 데이터를 넘겨줌 
										 LeftOutLine[0].FP0.x = PreLeftOutLine[0].FP0.x;  LeftOutLine[0].FP1.x = PreLeftOutLine[0].FP1.x;  
										 LeftOutLine[0].FP0.y = PreLeftOutLine[0].FP0.y;  LeftOutLine[0].FP1.y = PreLeftOutLine[0].FP1.y;  
									 }
								 }
							 }
							 else             { //외관검사 시퀀스//
								 SingleLine->IRoi->SetOrgX  (IRoi->GetOrgX()          );
								 SingleLine->IRoi->SetOrgY  (IRoi->GetOrgY()          );
								 SingleLine->IRoi->SetWidth (IRoi->GetWidth()         );
								 SingleLine->IRoi->SetHeight(FEndLine-CSideCircleHeight);
								 SingleLine->SetIncrement(5 );

								 SingleLine->SetOrientation(orWest);

								 SingleLine->SetFindLineId(0);

								 if(IsMarkBtm) SingleLine->SetEdgeType(0); // Black to White 
								 else          SingleLine->SetEdgeType(0); // Black to White

								 SingleLine->OnExecute();
								 Line[0].FP0 = SingleLine->GetResultP0();
								 Line[0].FP1 = SingleLine->GetResultP1();

								 // Btm,Top 상관없이 첫번째
								 LeftOutLine[0].FP0.x = Line[0].FP0.x;
								 LeftOutLine[0].FP0.y = Line[0].FP0.y;
								 LeftOutLine[0].FP1.x = Line[0].FP1.x;
								 LeftOutLine[0].FP1.y = Line[0].FP1.y;

								 if(fabs(LeftOutLine[0].FP0.x - LeftOutLine[0].FP1.x)>=0.5){
									 LeftOutLine[0].FP0.x = (LeftOutLine[0].FP0.x+LeftOutLine[0].FP1.x)/2.0;
									 LeftOutLine[0].FP1.x = (LeftOutLine[0].FP0.x+LeftOutLine[0].FP1.x)/2.0;
								 }

								 // LeftOutLine....make OutLine Data 
								 // 현재의 데이터를 넘겨준다 
								 // 검사중 기준라인을 찾지 못할경우 이전데이터 넘겨줘서 기준라인 생성함 
								 if(LeftOutLine[0].FP0.x!=0.0f && LeftOutLine[0].FP0.y!=0.0f && LeftOutLine[0].FP1.x!=0.0f && LeftOutLine[0].FP1.y!=0.0f){
									 PreLeftOutLine[0].FP0.x = LeftOutLine[0].FP0.x;    PreLeftOutLine[0].FP1.x = LeftOutLine[0].FP1.x;       
									 PreLeftOutLine[0].FP0.y = LeftOutLine[0].FP0.y;    PreLeftOutLine[0].FP1.y = LeftOutLine[0].FP1.y;       
								 } // 셀의 상단 시작부터 Broken 발생으로 데이터가 없는경우 
								 else if(LeftOutLine[0].FP0.x==0.0f || LeftOutLine[0].FP0.y==0.0f || LeftOutLine[0].FP1.x==0.0f || LeftOutLine[0].FP1.y==0.0f){
									 if(PreLeftOutLine[0].FP0.x==0.0f && PreLeftOutLine[0].FP0.y==0.0f && PreLeftOutLine[0].FP1.x==0.0f && PreLeftOutLine[0].FP1.y==0.0f){// 시작부분 Broken발생으로 데이터가 없는경우 
										 // Mark좌표를 기준으로 라인좌표값을 다시 설정함 
										 ROI_H = IRoi->GetHeight();
										 LeftOutLine[0].FP0.x = Line[0].FP0.x;    LeftOutLine[0].FP0.y = 0.0f        ;
										 LeftOutLine[0].FP1.x = Line[0].FP1.x;    LeftOutLine[0].FP1.y = (float)ROI_H;

										 //Line 데이터를 PreLine에 넘겨준다 
										 PreLeftOutLine[0].FP0.x = LeftOutLine[0].FP0.x;    PreLeftOutLine[0].FP1.x = LeftOutLine[0].FP1.x;       
										 PreLeftOutLine[0].FP0.y = LeftOutLine[0].FP0.y;    PreLeftOutLine[0].FP1.y = LeftOutLine[0].FP1.y;       
									 }
									 else { // 중간부분 Broken발생으로 데이터가 없는경우 
										 // PreLine 데이터를 넘겨줌 
										 LeftOutLine[0].FP0.x = PreLeftOutLine[0].FP0.x;  LeftOutLine[0].FP1.x = PreLeftOutLine[0].FP1.x;  
										 LeftOutLine[0].FP0.y = PreLeftOutLine[0].FP0.y;  LeftOutLine[0].FP1.y = PreLeftOutLine[0].FP1.y;  
									 }
								 }

								 if(IsAllGrind){    // 현재 전체 연마Cell없음,추후에 출시 예정 
									 if(IsMarkBtm){ //LeftInLine, LeftTrackLine Search, Data생성 
										 // LeftInLine Search Start 
										 EasyImage::Threshold(&RotateImg,&RotateBinaryImg, LeftEdgeThresHold);
										 if(LeftEdgeThresHold==0) {SingleLine->GImage = &RotateImg      ;  SingleLine->FThreshold =5 ;}
										 else                     {SingleLine->GImage = &RotateBinaryImg;  SingleLine->FThreshold =10;}

										 // 영역설정 
										 if(fabs(LeftOutLine[0].FP0.x - LeftOutLine[0].FP1.x) > 3){
											 LSP.x = (LeftOutLine[0].FP0.x + LeftOutLine[0].FP1.x)/2;
											 LSP.y = 0.0f;
										 }
										 else {
											 LSP = Math.OnIntersect(LeftOutLine[0].FP0, LeftOutLine[0].FP1, LT, RT);
										 }

										 SingleLine->IRoi->SetOrgX  ((int)LSP.x+3 );
										 SingleLine->IRoi->SetOrgY  (0            );
										 SingleLine->IRoi->SetWidth (100          );
										 SingleLine->IRoi->SetHeight(ImgH         );
										 SingleLine->SetIncrement(5 );

										 if(((LSP.x+3)<=0) || ImgH<=0) return false;

										 // 									 if(IRoi->GetHeight()<300) SingleLine->SetIncrement(5 );
										 // 									 else                      SingleLine->SetIncrement(10);

										 // 연마량 측정 OutLine
										 SingleLine->SetFindLineId(0);
										 SingleLine->SetOrientation(orWest);
										 SingleLine->SetEdgeType(0); // Black to White 
										 SingleLine->OnExecute();
										 LeftInLine[0].FP0 = SingleLine->GetResultP0();
										 LeftInLine[0].FP1 = SingleLine->GetResultP1();

										 SingleLine->SetEdgeType(2); // Line Search Org 

										 // LeftInLine None....make InLine Data 
										 // 현재의 데이터를 넘겨준다 
										 if(LeftInLine[0].FP0.x!=0.0f && LeftInLine[0].FP0.y!=0.0f && LeftInLine[0].FP1.x!=0.0f && LeftInLine[0].FP1.y!=0.0f){
											 PreLeftInLine[0].FP0.x = LeftInLine[0].FP0.x;    PreLeftInLine[0].FP1.x = LeftInLine[0].FP1.x;       
											 PreLeftInLine[0].FP0.y = LeftInLine[0].FP0.y;    PreLeftInLine[0].FP1.y = LeftInLine[0].FP1.y;       
										 }
										 else if(LeftInLine[0].FP0.x==0.0f || LeftInLine[0].FP0.y==0.0f || LeftInLine[0].FP1.x==0.0f || LeftInLine[0].FP1.y==0.0f){
											 if(PreLeftInLine[0].FP0.x==0.0f && PreLeftInLine[0].FP0.y==0.0f && PreLeftInLine[0].FP1.x==0.0f && PreLeftInLine[0].FP1.y==0.0f){// 시작부분 Broken발생으로 데이터가 없는경우 
												 // Mark좌표를 기준으로 라인좌표값을 다시 설정함 
												 ROI_H = IRoi->GetHeight();
												 ROI_L = IRoi->GetOrgX()  ;
												 LeftInLine[0].FP0.x = ROI_L;   LeftInLine[0].FP0.y = 0.0f        ;
												 LeftInLine[0].FP1.x = ROI_L;   LeftInLine[0].FP1.y = (float)ROI_H;

												 //Line 데이터를 PreLine에 넘겨준다 
												 PreLeftInLine[0].FP0.x = LeftInLine[0].FP0.x;    PreLeftInLine[0].FP1.x = LeftInLine[0].FP1.x;       
												 PreLeftInLine[0].FP0.y = LeftInLine[0].FP0.y;    PreLeftInLine[0].FP1.y = LeftInLine[0].FP1.y;       
											 }
											 else {                                                                                                    // 중간부분 Broken발생으로 데이터가 없는경우 
												 // PreLine 데이터를 넘겨줌 
												 LeftInLine[0].FP0.x = PreLeftInLine[0].FP0.x;  LeftInLine[0].FP1.x = PreLeftInLine[0].FP1.x;  
												 LeftInLine[0].FP0.y = PreLeftInLine[0].FP0.y;  LeftInLine[0].FP1.y = PreLeftInLine[0].FP1.y;  
											 }
										 }
										 // NOTCH CELL Btm 검사에서만 연마폭 측정함 
										 Left_Grind_Width =(float)(Math.GetLengthFrLineToPoint (LeftOutLine[0].FP0,LeftOutLine[0].FP1, LeftInLine[0].FP0 ));
										 ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////


										 // LeftTrackLine Search Start 
										 EasyImage::Threshold(&RotateImg,&RotateBinaryImg, CirGrindMeaThresHold);

										 // LeftInLine기준 LeftTrackLine 검출  
										 if(CirGrindMeaThresHold==0) {SingleLine->GImage = &RotateImg      ;  SingleLine->FThreshold =5 ;}
										 else                        {SingleLine->GImage = &RotateBinaryImg;  SingleLine->FThreshold =10;}

										 // 영역설정 
										 if(fabs(LeftInLine[0].FP0.x - LeftInLine[0].FP1.x) > 3){
											 LSP.x = (LeftInLine[0].FP0.x + LeftInLine[0].FP1.x)/2;
											 LSP.y = 0.0f;
										 }
										 else {
											 LSP = Math.OnIntersect(LeftInLine[0].FP0, LeftInLine[0].FP1, LT, RT);
										 }

										 SingleLine->IRoi->SetOrgX  ((int)LSP.x+3 );
										 SingleLine->IRoi->SetOrgY  (0            );
										 SingleLine->IRoi->SetWidth (100          );
										 SingleLine->IRoi->SetHeight(ImgH         );
										 SingleLine->SetIncrement(5 );

										 if(((LSP.x+3)<=0) || ImgH<=0) return false;

										 // 									 if(IRoi->GetHeight()<300) SingleLine->SetIncrement(5 );
										 // 									 else                      SingleLine->SetIncrement(10);

										 // Left Track Line Search 
										 SingleLine->SetFindLineId(0);
										 SingleLine->SetOrientation(orWest);
										 SingleLine->SetEdgeType(1); // White To Black  
										 SingleLine->OnExecute();
										 LeftTrackLine[0].FP0 = SingleLine->GetResultP0();
										 LeftTrackLine[0].FP1 = SingleLine->GetResultP1();

										 SingleLine->SetEdgeType(2); // Line Search Type Normal 

										 // LeftTrackLine....make OutLine Data 
										 // 현재의 데이터를 넘겨준다 
										 // 검사중 기준라인을 찾지 못할경우 이전데이터 넘겨줘서 기준라인 생성함 
										 if(LeftTrackLine[0].FP0.x!=0.0f && LeftTrackLine[0].FP0.y!=0.0f && LeftTrackLine[0].FP1.x!=0.0f && LeftTrackLine[0].FP1.y!=0.0f){
											 PreLeftTrackLine[0].FP0.x = LeftTrackLine[0].FP0.x;    PreLeftTrackLine[0].FP1.x = LeftTrackLine[0].FP1.x;       
											 PreLeftTrackLine[0].FP0.y = LeftTrackLine[0].FP0.y;    PreLeftTrackLine[0].FP1.y = LeftTrackLine[0].FP1.y;       
										 } // 셀의 상단 시작부터 Broken 발생으로 데이터가 없는경우 
										 else if(LeftTrackLine[0].FP0.x==0.0f || LeftTrackLine[0].FP0.y==0.0f || LeftTrackLine[0].FP1.x==0.0f || LeftTrackLine[0].FP1.y==0.0f){
											 if(PreLeftTrackLine[0].FP0.x==0.0f && PreLeftTrackLine[0].FP0.y==0.0f && PreLeftTrackLine[0].FP1.x==0.0f && PreLeftTrackLine[0].FP1.y==0.0f){// 시작부분 Broken발생으로 데이터가 없는경우 
												 // Mark좌표를 기준으로 라인좌표값을 다시 설정함 
												 ROI_H = IRoi->GetHeight();
												 ROI_L = IRoi->GetOrgX()  ;
												 LeftTrackLine[0].FP0.x = ROI_L;    LeftTrackLine[0].FP0.y = 0.0f        ;
												 LeftTrackLine[0].FP1.x = ROI_L;    LeftTrackLine[0].FP1.y = (float)ROI_H;

												 //LeftTrackLine 데이터를 PreLeftTrackLine에 넘겨준다 
												 PreLeftTrackLine[0].FP0.x = LeftTrackLine[0].FP0.x;    PreLeftTrackLine[0].FP1.x = LeftTrackLine[0].FP1.x;       
												 PreLeftTrackLine[0].FP0.y = LeftTrackLine[0].FP0.y;    PreLeftTrackLine[0].FP1.y = LeftTrackLine[0].FP1.y;       
											 }
											 else { // 중간부분 Broken발생으로 데이터가 없는경우 
												 // PreLeftTrackLine 데이터를 넘겨줌 
												 LeftTrackLine[0].FP0.x = PreLeftTrackLine[0].FP0.x;  LeftTrackLine[0].FP1.x = PreLeftTrackLine[0].FP1.x;  
												 LeftTrackLine[0].FP0.y = PreLeftTrackLine[0].FP0.y;  LeftTrackLine[0].FP1.y = PreLeftTrackLine[0].FP1.y;  
											 }
										 }
										 // NOTCH CELL Btm 검사에서만 연마폭 측정함 
										 Left_Grind_Mea =(float)(Math.GetLengthFrLineToPoint (LeftOutLine[0].FP0,LeftOutLine[0].FP1, LeftTrackLine[0].FP0 ));

										 // 마크라인에서 부터 LeftTrackLine 까지 거리 산출 
										 // LeftTrackLine Data 존재할 경우 거리 측정함 
										 if(LeftTrackLine[0].FP0.x!=0.0f && LeftTrackLine[0].FP0.y!=0.0f && LeftTrackLine[0].FP1.x!=0.0f && LeftTrackLine[0].FP1.y!=0.0f){
											 // 											 LeftTrackLine[0].FP0.y = LeftTrackLine[0].FP0.y + ImageHeight; //전체 이미지 기준 y좌표
											 // 											 LeftTrackLine[0].FP1.y = LeftTrackLine[0].FP1.y + ImageHeight; //전체 이미지 기준 y좌표
											 // 
											 // 											 MarkToTrackLineDis1 = Math.GetLengthFrLineToPoint(LeftMarkSta, LeftMarkEnd, LeftTrackLine[0].FP0);//Mark라인에서 TrackLine거리 
											 // 											 MarkToTrackLineDis2 = Math.GetLengthFrLineToPoint(LeftMarkSta, LeftMarkEnd, LeftTrackLine[0].FP1);//Mark라인에서 TrackLine거리 
											 // 
											 // 											 TotalLeftTrackDis  +=  (int)((MarkToTrackLineDis1 + MarkToTrackLineDis2)/2.0); //Mark라인에서 TrackLine거리 누적                   
											 // 											 LeftTrackLineCount++; //누적 카운트 증가
											 // 
											 // 											 // Org Data 
											 // 											 LeftTrackLine[0].FP0.y = LeftTrackLine[0].FP0.y - ImageHeight; //Frame 이미지 기준 y좌표 원복
											 // 											 LeftTrackLine[0].FP1.y = LeftTrackLine[0].FP1.y - ImageHeight; //Frame 이미지 기준 y좌표 원복 
										 }
										 ///////////////////////////////////////////////////////////////////////////////////////////////////////
									 }
									 else { //LeftInLine Search, LeftTrackLine Data Overlap 
										 // LeftInLine Search Start 
										 EasyImage::Threshold(&RotateImg,&RotateBinaryImg, LeftEdgeThresHold);
										 if(LeftEdgeThresHold==0) {SingleLine->GImage = &RotateImg      ;  SingleLine->FThreshold =5 ;}
										 else                     {SingleLine->GImage = &RotateBinaryImg;  SingleLine->FThreshold =10;}

										 // 영역설정 
										 if(fabs(LeftOutLine[0].FP0.x - LeftOutLine[0].FP1.x) > 3){
											 LSP.x = (LeftOutLine[0].FP0.x + LeftOutLine[0].FP1.x)/2;
											 LSP.y = 0.0f;
										 }
										 else {
											 LSP = Math.OnIntersect(LeftOutLine[0].FP0, LeftOutLine[0].FP1, LT, RT);
										 }

										 SingleLine->IRoi->SetOrgX  ((int)LSP.x+3 );
										 SingleLine->IRoi->SetOrgY  (0            );
										 SingleLine->IRoi->SetWidth (100          );
										 SingleLine->IRoi->SetHeight(ImgH         );
										 SingleLine->SetIncrement(5 );

										 if(((LSP.x+3)<=0) || ImgH<=0) return false;

										 // 									 if(IRoi->GetHeight()<300) SingleLine->SetIncrement(5 );
										 // 									 else                      SingleLine->SetIncrement(10);

										 // 연마량 측정 OutLine
										 SingleLine->SetFindLineId(0);
										 SingleLine->SetOrientation(orWest);
										 SingleLine->SetEdgeType(0); // Black to White 
										 SingleLine->OnExecute();
										 LeftInLine[0].FP0 = SingleLine->GetResultP0();
										 LeftInLine[0].FP1 = SingleLine->GetResultP1();

										 SingleLine->SetEdgeType(2); // Line Search Org 

										 // LeftInLine None....make InLine Data 
										 // 현재의 데이터를 넘겨준다 
										 if(LeftInLine[0].FP0.x!=0.0f && LeftInLine[0].FP0.y!=0.0f && LeftInLine[0].FP1.x!=0.0f && LeftInLine[0].FP1.y!=0.0f){
											 PreLeftInLine[0].FP0.x = LeftInLine[0].FP0.x;    PreLeftInLine[0].FP1.x = LeftInLine[0].FP1.x;       
											 PreLeftInLine[0].FP0.y = LeftInLine[0].FP0.y;    PreLeftInLine[0].FP1.y = LeftInLine[0].FP1.y;       
										 }
										 else if(LeftInLine[0].FP0.x==0.0f || LeftInLine[0].FP0.y==0.0f || LeftInLine[0].FP1.x==0.0f || LeftInLine[0].FP1.y==0.0f){
											 if(PreLeftInLine[0].FP0.x==0.0f && PreLeftInLine[0].FP0.y==0.0f && PreLeftInLine[0].FP1.x==0.0f && PreLeftInLine[0].FP1.y==0.0f){// 시작부분 Broken발생으로 데이터가 없는경우 
												 // Mark좌표를 기준으로 라인좌표값을 다시 설정함 
												 ROI_H = IRoi->GetHeight();
												 ROI_L = IRoi->GetOrgX()  ;
												 LeftInLine[0].FP0.x = ROI_L;   LeftInLine[0].FP0.y = 0.0f        ;
												 LeftInLine[0].FP1.x = ROI_L;   LeftInLine[0].FP1.y = (float)ROI_H;

												 //Line 데이터를 PreLine에 넘겨준다 
												 PreLeftInLine[0].FP0.x = LeftInLine[0].FP0.x;    PreLeftInLine[0].FP1.x = LeftInLine[0].FP1.x;       
												 PreLeftInLine[0].FP0.y = LeftInLine[0].FP0.y;    PreLeftInLine[0].FP1.y = LeftInLine[0].FP1.y;       
											 }
											 else {                                                                                                    // 중간부분 Broken발생으로 데이터가 없는경우 
												 // PreLine 데이터를 넘겨줌 
												 LeftInLine[0].FP0.x = PreLeftInLine[0].FP0.x;  LeftInLine[0].FP1.x = PreLeftInLine[0].FP1.x;  
												 LeftInLine[0].FP0.y = PreLeftInLine[0].FP0.y;  LeftInLine[0].FP1.y = PreLeftInLine[0].FP1.y;  
											 }
										 }
										 // NOTCH CELL Btm 검사에서만 연마폭 측정함 
										 Left_Grind_Width =(float)(Math.GetLengthFrLineToPoint (LeftOutLine[0].FP0,LeftOutLine[0].FP1, LeftInLine[0].FP0 ));
										 ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////

										 // LeftTrackLine Data Overlap 
										 if(AvgLeftTrackLineDis!=0){
											 // 											 LeftOutLine[0].FP0.y = LeftOutLine[0].FP0.y + ImageHeight; //전체 이미지 기준 y좌표
											 // 											 LeftOutLine[0].FP1.y = LeftOutLine[0].FP1.y + ImageHeight; //전체 이미지 기준 y좌표
											 // 
											 // 											 MarkToTrackLineDis1 = Math.GetLengthFrLineToPoint(LeftMarkSta, LeftMarkEnd, LeftOutLine[0].FP0);//Mark라인에서 OutLine까지 거리 
											 // 											 MarkToTrackLineDis2 = Math.GetLengthFrLineToPoint(LeftMarkSta, LeftMarkEnd, LeftOutLine[0].FP1);//Mark라인에서 OutLine까지 거리 
											 // 
											 // 											 if(MarkToTrackLineDis1>AvgLeftTrackLineDis) LeftTrackLine[0].FP0.x = LeftOutLine[0].FP0.x+(MarkToTrackLineDis1 - AvgLeftTrackLineDis);
											 // 											 if(MarkToTrackLineDis2>AvgLeftTrackLineDis) LeftTrackLine[0].FP1.x = LeftOutLine[0].FP1.x+(MarkToTrackLineDis2 - AvgLeftTrackLineDis);
											 // 
											 // 											 // LeftOutLine Data 원본 
											 // 											 LeftOutLine[0].FP0.y = LeftOutLine[0].FP0.y - ImageHeight; 
											 // 											 LeftOutLine[0].FP1.y = LeftOutLine[0].FP1.y - ImageHeight; 
											 // 
											 // 											 LeftTrackLine[0].FP0.y = LeftOutLine[0].FP0.y;
											 // 											 LeftTrackLine[0].FP1.y = LeftOutLine[0].FP1.y;
										 }
									 }
								 }
								 else {
									 if(IsMarkBtm){ //LeftTrackLine Search,Data생성
										 if(FInspectMode==Insp_Track){
											 // LeftTrackLine Search Start 
											 EasyImage::Threshold(&RotateImg,&RotateBinaryImg, CirGrindMeaThresHold);
											 if(CirGrindMeaThresHold==0) {SingleLine->GImage = &RotateImg      ;  SingleLine->FThreshold =5 ;}
											 else                        {SingleLine->GImage = &RotateBinaryImg;  SingleLine->FThreshold =10;}

											 // 영역설정 
											 if(fabs(LeftOutLine[0].FP0.x - LeftOutLine[0].FP1.x) > 3){
												 LSP.x = (LeftOutLine[0].FP0.x + LeftOutLine[0].FP1.x)/2;
												 LSP.y = 0.0f;
											 }
											 else {
												 LSP = Math.OnIntersect(LeftOutLine[0].FP0, LeftOutLine[0].FP1, LT, RT);
											 }

											 SingleLine->IRoi->SetOrgX  ((int)LSP.x+3             );
											 SingleLine->IRoi->SetOrgY  (0                        );
											 SingleLine->IRoi->SetWidth (100                      );
											 SingleLine->IRoi->SetHeight(FEndLine-CSideCircleHeight);
											 SingleLine->SetIncrement( 1);

											 if(((LSP.x+3)<=0) || ImgH<=0) return false;

											 // 									 if(IRoi->GetHeight()<300) SingleLine->SetIncrement(5 );
											 // 									 else                      SingleLine->SetIncrement(10);

											 // Left Track Line Search 
											 SingleLine->SetFindLineId(0);
											 SingleLine->SetOrientation(orWest);
											 SingleLine->SetEdgeType(1); // White To Black  
											 SingleLine->OnExecute();
											 LeftTrackLine[0].FP0 = SingleLine->GetResultP0();
											 LeftTrackLine[0].FP1 = SingleLine->GetResultP1();

											 if(fabs(LeftTrackLine[0].FP0.x - LeftTrackLine[0].FP1.x)>=0.5){
												 LeftTrackLine[0].FP0.x = (LeftTrackLine[0].FP0.x+LeftTrackLine[0].FP1.x)/2.0;
												 LeftTrackLine[0].FP1.x = (LeftTrackLine[0].FP0.x+LeftTrackLine[0].FP1.x)/2.0;
											 }

											 SingleLine->SetEdgeType(2); // Line Search Type Normal 

											 // LeftTrackLine....Make OutLine Data 
											 // 현재의 데이터를 넘겨준다 
											 // 검사중 기준라인을 찾지 못할경우 이전데이터 넘겨줘서 기준라인 생성함 
											 if(LeftTrackLine[0].FP0.x!=0.0f && LeftTrackLine[0].FP0.y!=0.0f && LeftTrackLine[0].FP1.x!=0.0f && LeftTrackLine[0].FP1.y!=0.0f){
												 PreLeftTrackLine[0].FP0.x = LeftTrackLine[0].FP0.x;    PreLeftTrackLine[0].FP1.x = LeftTrackLine[0].FP1.x;       
												 PreLeftTrackLine[0].FP0.y = LeftTrackLine[0].FP0.y;    PreLeftTrackLine[0].FP1.y = LeftTrackLine[0].FP1.y;       
											 } // 셀의 상단 시작부터 Broken 발생으로 데이터가 없는경우 
											 else if(LeftTrackLine[0].FP0.x==0.0f || LeftTrackLine[0].FP0.y==0.0f || LeftTrackLine[0].FP1.x==0.0f || LeftTrackLine[0].FP1.y==0.0f){
												 if(PreLeftTrackLine[0].FP0.x==0.0f && PreLeftTrackLine[0].FP0.y==0.0f && PreLeftTrackLine[0].FP1.x==0.0f && PreLeftTrackLine[0].FP1.y==0.0f){// 시작부분 Broken발생으로 데이터가 없는경우 
													 // Mark좌표를 기준으로 라인좌표값을 다시 설정함 
													 ROI_H = IRoi->GetHeight();
													 ROI_L = IRoi->GetOrgX()  ;
													 LeftTrackLine[0].FP0.x = ROI_L;    LeftTrackLine[0].FP0.y = 0.0f        ;
													 LeftTrackLine[0].FP1.x = ROI_L;    LeftTrackLine[0].FP1.y = (float)ROI_H;

													 //LeftTrackLine 데이터를 PreLeftTrackLine에 넘겨준다 
													 PreLeftTrackLine[0].FP0.x = LeftTrackLine[0].FP0.x;    PreLeftTrackLine[0].FP1.x = LeftTrackLine[0].FP1.x;       
													 PreLeftTrackLine[0].FP0.y = LeftTrackLine[0].FP0.y;    PreLeftTrackLine[0].FP1.y = LeftTrackLine[0].FP1.y;       
												 }
												 else { // 중간부분 Broken발생으로 데이터가 없는경우 
													 // PreLeftTrackLine 데이터를 넘겨줌 
													 LeftTrackLine[0].FP0.x = PreLeftTrackLine[0].FP0.x;  LeftTrackLine[0].FP1.x = PreLeftTrackLine[0].FP1.x;  
													 LeftTrackLine[0].FP0.y = PreLeftTrackLine[0].FP0.y;  LeftTrackLine[0].FP1.y = PreLeftTrackLine[0].FP1.y;  
												 }
											 }

											 // 마크라인에서 부터 LeftTrackLine 까지 거리 산출 
											 // LeftTrackLine Data 존재할 경우 거리 측정함 
											 // Image Rotate 있음 
											 // 외곽라인 기준 EnCap에 필요한 데이터 생성 
											 if(LeftTrackLine[0].FP0.x!=0.0f && LeftTrackLine[0].FP0.y!=0.0f && LeftTrackLine[0].FP1.x!=0.0f && LeftTrackLine[0].FP1.y!=0.0f){
												 if(LeftOutLine[0].FP0.x!=0.0f && LeftOutLine[0].FP0.y!=0.0f && LeftOutLine[0].FP1.x!=0.0f && LeftOutLine[0].FP1.y!=0.0f){
													 LeftToTrackLineDis1 = Math.GetLengthFrLineToPoint(LeftOutLine[0].FP0, LeftOutLine[0].FP1, LeftTrackLine[0].FP0);//외곽라인에서 TrackLine거리 
													 LeftToTrackLineDis2 = Math.GetLengthFrLineToPoint(LeftOutLine[0].FP0, LeftOutLine[0].FP1, LeftTrackLine[0].FP1);//외곽라인에서 TrackLine거리 

													 TotalLeftTrackDis  +=  (int)((LeftToTrackLineDis1 + LeftToTrackLineDis2)/2.0); //Mark라인에서 TrackLine거리 누적                   
													 LeftTrackLineCount++; //누적 카운트 증가
												 }
											 }
										 }
									 }
									 else {  //LeftTrackLine Data Overlap
										 // LeftTrackLine Data Overlap 
										 if(AvgLeftTrackLineDis!=0){
											 if(FInspectMode==Insp_Track){ // Mark기준 
												 if(LeftOutLine[0].FP0.x!=0.0f && LeftOutLine[0].FP0.y!=0.0f && LeftOutLine[0].FP1.x!=0.0f && LeftOutLine[0].FP1.y!=0.0f){
													 // TOP영역 LeftTrackLine x좌표 
													 LeftTrackLine[0].FP0.x = LeftOutLine[0].FP0.x+AvgLeftTrackLineDis;
													 LeftTrackLine[0].FP1.x = LeftOutLine[0].FP1.x+AvgLeftTrackLineDis;

													 // TOP영역 LeftTrackLine y좌표 
													 LeftTrackLine[0].FP0.y = LeftOutLine[0].FP0.y;
													 LeftTrackLine[0].FP1.y = LeftOutLine[0].FP1.y;
												 }
											 }
										 }
									 }
								 }
							 }
						 }

						 if(FRightWall){ //BMDT RightLine Search 
							 EasyImage::Threshold(&RotateImg,&RotateBinaryImg, RightEdgeThresHold);
							 if(RightEdgeThresHold==0) {SingleLine->GImage = &RotateImg      ;  SingleLine->FThreshold =5 ;}
							 else                      {SingleLine->GImage = &RotateBinaryImg;  SingleLine->FThreshold =10;}

							 if(FInspectMode==Insp_Surface){ //표면검사 시퀀스//
								 SingleLine->IRoi->SetOrgX  (IRoi->GetOrgX()          );
								 SingleLine->IRoi->SetOrgY  (IRoi->GetOrgY()          );
								 SingleLine->IRoi->SetWidth (IRoi->GetWidth()         );
								 SingleLine->IRoi->SetHeight(FEndLine-CSideCircleHeight);
								 SingleLine->SetIncrement(5 );

								 SingleLine->SetOrientation(orEast);

								 SingleLine->SetFindLineId(0);
								 SingleLine->FThreshold =10;

								 if(IsMarkBtm) SingleLine->SetEdgeType(1); // White to Black  
								 else          SingleLine->SetEdgeType(1); // White to Black  

								 SingleLine->OnExecute();
								 Line[2].FP0 = SingleLine->GetResultP0();
								 Line[2].FP1 = SingleLine->GetResultP1();

								 // Btm,Top 상관없이 첫번째
								 RightOutLine[0].FP0.x = Line[2].FP0.x;
								 RightOutLine[0].FP0.y = Line[2].FP0.y;
								 RightOutLine[0].FP1.x = Line[2].FP1.x;
								 RightOutLine[0].FP1.y = Line[2].FP1.y;

								 if(fabs(RightOutLine[0].FP0.x - RightOutLine[0].FP1.x)>=0.5){
									 RightOutLine[0].FP0.x = (RightOutLine[0].FP0.x+RightOutLine[0].FP1.x)/2.0;
									 RightOutLine[0].FP1.x = (RightOutLine[0].FP0.x+RightOutLine[0].FP1.x)/2.0;
								 }

								 // LeftOutLine....make OutLine Data 
								 // 현재의 데이터를 넘겨준다 
								 // 검사중 기준라인을 찾지 못할경우 이전데이터 넘겨줘서 기준라인 생성함 
								 if(RightOutLine[0].FP0.x!=0.0f && RightOutLine[0].FP0.y!=0.0f && RightOutLine[0].FP1.x!=0.0f && RightOutLine[0].FP1.y!=0.0f){
									 PreRightOutLine[0].FP0.x = RightOutLine[0].FP0.x;    PreRightOutLine[0].FP1.x = RightOutLine[0].FP1.x;       
									 PreRightOutLine[0].FP0.y = RightOutLine[0].FP0.y;    PreRightOutLine[0].FP1.y = RightOutLine[0].FP1.y;       
								 } // 셀의 상단 시작부터 Broken 발생으로 데이터가 없는경우 
								 else if(RightOutLine[0].FP0.x==0.0f || RightOutLine[0].FP0.y==0.0f || RightOutLine[0].FP1.x==0.0f || RightOutLine[0].FP1.y==0.0f){
									 if(PreRightOutLine[0].FP0.x==0.0f && PreRightOutLine[0].FP0.y==0.0f && PreRightOutLine[0].FP1.x==0.0f && PreRightOutLine[0].FP1.y==0.0f){// 시작부분 Broken발생으로 데이터가 없는경우 
										 // Mark좌표를 기준으로 라인좌표값을 다시 설정함 
										 ROI_H = IRoi->GetHeight();
										 RightOutLine[0].FP0.x = Line[2].FP0.x;    RightOutLine[0].FP0.y = 0.0f        ;
										 RightOutLine[0].FP1.x = Line[2].FP1.x;    RightOutLine[0].FP1.y = (float)ROI_H;

										 //Line 데이터를 PreLine에 넘겨준다 
										 PreRightOutLine[0].FP0.x = RightOutLine[0].FP0.x;    PreRightOutLine[0].FP1.x = RightOutLine[0].FP1.x;       
										 PreRightOutLine[0].FP0.y = RightOutLine[0].FP0.y;    PreRightOutLine[0].FP1.y = RightOutLine[0].FP1.y;       
									 }
									 else { // 중간부분 Broken발생으로 데이터가 없는경우 
										 // PreLine 데이터를 넘겨줌 
										 RightOutLine[0].FP0.x = PreRightOutLine[0].FP0.x;  RightOutLine[0].FP1.x = PreRightOutLine[0].FP1.x;  
										 RightOutLine[0].FP0.y = PreRightOutLine[0].FP0.y;  RightOutLine[0].FP1.y = PreRightOutLine[0].FP1.y;  
									 }
								 }
							 }
							 else             { //외관검사 시퀀스//
								 SingleLine->IRoi->SetOrgX  (IRoi->GetOrgX()          );
								 SingleLine->IRoi->SetOrgY  (IRoi->GetOrgY()          );
								 SingleLine->IRoi->SetWidth (IRoi->GetWidth()         );
								 SingleLine->IRoi->SetHeight(FEndLine-CSideCircleHeight);
								 SingleLine->SetIncrement(5 );

								 SingleLine->SetOrientation(orEast);
								 // 								 if(IRoi->GetHeight()<350) SingleLine->SetIncrement(5 );
								 // 								 else                      SingleLine->SetIncrement(10);

								 SingleLine->SetFindLineId(0);
								 SingleLine->FThreshold =10;
								 // 								 SingleLine->SetEdgeType(0);  //Black To White  

								 // TEST 
								 if(IsMarkBtm) SingleLine->SetEdgeType(0); // Black to White 
								 else          SingleLine->SetEdgeType(0); // Black to White  

								 SingleLine->OnExecute();
								 Line[2].FP0 = SingleLine->GetResultP0();
								 Line[2].FP1 = SingleLine->GetResultP1();

								 // Btm,Top 상관없이 첫번째
								 RightOutLine[0].FP0.x = Line[2].FP0.x;
								 RightOutLine[0].FP0.y = Line[2].FP0.y;
								 RightOutLine[0].FP1.x = Line[2].FP1.x;
								 RightOutLine[0].FP1.y = Line[2].FP1.y;

								 if(fabs(RightOutLine[0].FP0.x - RightOutLine[0].FP1.x)>=0.5){
									 RightOutLine[0].FP0.x = (RightOutLine[0].FP0.x+RightOutLine[0].FP1.x)/2.0;
									 RightOutLine[0].FP1.x = (RightOutLine[0].FP0.x+RightOutLine[0].FP1.x)/2.0;
								 }

								 // LeftOutLine....make OutLine Data 
								 // 현재의 데이터를 넘겨준다 
								 // 검사중 기준라인을 찾지 못할경우 이전데이터 넘겨줘서 기준라인 생성함 
								 if(RightOutLine[0].FP0.x!=0.0f && RightOutLine[0].FP0.y!=0.0f && RightOutLine[0].FP1.x!=0.0f && RightOutLine[0].FP1.y!=0.0f){
									 PreRightOutLine[0].FP0.x = RightOutLine[0].FP0.x;    PreRightOutLine[0].FP1.x = RightOutLine[0].FP1.x;       
									 PreRightOutLine[0].FP0.y = RightOutLine[0].FP0.y;    PreRightOutLine[0].FP1.y = RightOutLine[0].FP1.y;       
								 } // 셀의 상단 시작부터 Broken 발생으로 데이터가 없는경우 
								 else if(RightOutLine[0].FP0.x==0.0f || RightOutLine[0].FP0.y==0.0f || RightOutLine[0].FP1.x==0.0f || RightOutLine[0].FP1.y==0.0f){
									 if(PreRightOutLine[0].FP0.x==0.0f && PreRightOutLine[0].FP0.y==0.0f && PreRightOutLine[0].FP1.x==0.0f && PreRightOutLine[0].FP1.y==0.0f){// 시작부분 Broken발생으로 데이터가 없는경우 
										 // Mark좌표를 기준으로 라인좌표값을 다시 설정함 
										 ROI_H = IRoi->GetHeight();
										 RightOutLine[0].FP0.x = Line[2].FP0.x;    RightOutLine[0].FP0.y = 0.0f        ;
										 RightOutLine[0].FP1.x = Line[2].FP1.x;    RightOutLine[0].FP1.y = (float)ROI_H;

										 //Line 데이터를 PreLine에 넘겨준다 
										 PreRightOutLine[0].FP0.x = RightOutLine[0].FP0.x;    PreRightOutLine[0].FP1.x = RightOutLine[0].FP1.x;       
										 PreRightOutLine[0].FP0.y = RightOutLine[0].FP0.y;    PreRightOutLine[0].FP1.y = RightOutLine[0].FP1.y;       
									 }
									 else { // 중간부분 Broken발생으로 데이터가 없는경우 
										 // PreLine 데이터를 넘겨줌 
										 RightOutLine[0].FP0.x = PreRightOutLine[0].FP0.x;  RightOutLine[0].FP1.x = PreRightOutLine[0].FP1.x;  
										 RightOutLine[0].FP0.y = PreRightOutLine[0].FP0.y;  RightOutLine[0].FP1.y = PreRightOutLine[0].FP1.y;  
									 }
								 }

								 if(IsAllGrind){ 
									 if(IsMarkBtm){ //RightInLine, RightTrackLine Search, Data생성 
										 // RightInLine Search Start 
										 EasyImage::Threshold(&RotateImg,&RotateBinaryImg, RightEdgeThresHold);
										 //RightOutLine기준 RightInLine 검출
										 if(RightEdgeThresHold==0) {SingleLine->GImage = &RotateImg      ;  SingleLine->FThreshold =5 ;}
										 else                      {SingleLine->GImage = &RotateBinaryImg;  SingleLine->FThreshold =10;}

										 // 영역설정 
										 if(fabs(RightOutLine[0].FP0.x - RightOutLine[0].FP1.x) > 3){
											 LSP.x = (RightOutLine[0].FP0.x + RightOutLine[0].FP1.x)/2;
											 LSP.y = 0.0f;
										 }
										 else {
											 LSP = Math.OnIntersect(RightOutLine[0].FP0, RightOutLine[0].FP1, LT, RT);
										 }

										 SingleLine->IRoi->SetOrgX  ((int)LSP.x-100);
										 SingleLine->IRoi->SetOrgY  (0             );
										 SingleLine->IRoi->SetWidth (97            );
										 SingleLine->IRoi->SetHeight(ImgH          );
										 SingleLine->SetIncrement(5 );

										 if(((LSP.x+3)<=0) || ImgH<=0) return false;

										 // 										 if(IRoi->GetHeight()<300) SingleLine->SetIncrement(5 );
										 // 										 else                      SingleLine->SetIncrement(10);

										 // 연마량 측정 OutLine
										 SingleLine->SetFindLineId(0);
										 SingleLine->SetOrientation(orEast);
										 SingleLine->SetEdgeType(0); // Black to White 
										 SingleLine->OnExecute();
										 RightInLine[0].FP0 = SingleLine->GetResultP0();
										 RightInLine[0].FP1 = SingleLine->GetResultP1();

										 SingleLine->SetEdgeType(2); // Line Search Org 

										 // RightInLine None....make InLine Data 
										 // 현재의 데이터를 넘겨준다 
										 if(RightInLine[0].FP0.x!=0.0f && RightInLine[0].FP0.y!=0.0f && RightInLine[0].FP1.x!=0.0f && RightInLine[0].FP1.y!=0.0f){
											 PreRightInLine[0].FP0.x = RightInLine[0].FP0.x;    PreRightInLine[0].FP1.x = RightInLine[0].FP1.x;       
											 PreRightInLine[0].FP0.y = RightInLine[0].FP0.y;    PreRightInLine[0].FP1.y = RightInLine[0].FP1.y;       
										 }
										 else if(RightInLine[0].FP0.x==0.0f || RightInLine[0].FP0.y==0.0f || RightInLine[0].FP1.x==0.0f || RightInLine[0].FP1.y==0.0f){
											 if(PreRightInLine[0].FP0.x==0.0f && PreRightInLine[0].FP0.y==0.0f && PreRightInLine[0].FP1.x==0.0f && PreRightInLine[0].FP1.y==0.0f){// 시작부분 Broken발생으로 데이터가 없는경우 
												 // Mark좌표를 기준으로 라인좌표값을 다시 설정함 
												 ROI_H = IRoi->GetHeight();
												 ROI_L = IRoi->GetOrgX()  ;
												 RightInLine[0].FP0.x = ROI_L;   RightInLine[0].FP0.y = 0.0f        ;
												 RightInLine[0].FP1.x = ROI_L;   RightInLine[0].FP1.y = (float)ROI_H;

												 //Line 데이터를 PreLine에 넘겨준다 
												 PreRightInLine[0].FP0.x = RightInLine[0].FP0.x;    PreRightInLine[0].FP1.x = RightInLine[0].FP1.x;       
												 PreRightInLine[0].FP0.y = RightInLine[0].FP0.y;    PreRightInLine[0].FP1.y = RightInLine[0].FP1.y;       
											 }
											 else {                                                                                                    // 중간부분 Broken발생으로 데이터가 없는경우 
												 // PreLine 데이터를 넘겨줌 
												 RightInLine[0].FP0.x = PreRightInLine[0].FP0.x;  RightInLine[0].FP1.x = PreRightInLine[0].FP1.x;  
												 RightInLine[0].FP0.y = PreRightInLine[0].FP0.y;  RightInLine[0].FP1.y = PreRightInLine[0].FP1.y;  
											 }
										 }
										 // NOTCH CELL Btm 검사에서만 연마폭 측정함 
										 Right_Grind_Width =(float)(Math.GetLengthFrLineToPoint (RightOutLine[0].FP0,RightOutLine[0].FP1, RightInLine[0].FP0 ));
										 /////////////////////////////////////////////////////////////////////////////////////////////


										 // Right TrackLine Search 
										 /////////////////////////////////////////////////////////////////////////////////////////////
										 // 									 BinaryImg.SetSize(GImage->GetWidth(), GImage->GetHeight());
										 // 									 EasyImage::Oper(EArithmeticLogicOperation_Copy,GImage,&BinaryImg);
										 EasyImage::Threshold(&RotateImg,&RotateBinaryImg, CirGrindMeaThresHold);
										 //RightInLine기준 RightTrackLine 검출
										 if(CirGrindMeaThresHold==0) {SingleLine->GImage = &RotateImg      ;  SingleLine->FThreshold =5 ;}
										 else                        {SingleLine->GImage = &RotateBinaryImg;  SingleLine->FThreshold =10;}


										 // 영역설정 
										 if(fabs(RightInLine[0].FP0.x - RightInLine[0].FP1.x) > 3){
											 LSP.x = (RightInLine[0].FP0.x + RightInLine[0].FP1.x)/2;
											 LSP.y = 0.0f;
										 }
										 else {
											 LSP = Math.OnIntersect(RightInLine[0].FP0, RightInLine[0].FP1, LT, RT);
										 }

										 SingleLine->IRoi->SetOrgX  ((int)LSP.x-100);
										 SingleLine->IRoi->SetOrgY  (0             );
										 SingleLine->IRoi->SetWidth (97            );
										 SingleLine->IRoi->SetHeight(ImgH          );
										 SingleLine->SetIncrement(5 );

										 if(((LSP.x+3)<=0) || ImgH<=0) return false;

										 // 										 if(IRoi->GetHeight()<300) SingleLine->SetIncrement(5 );
										 // 										 else                      SingleLine->SetIncrement(10);

										 // 연마량 측정 OutLine
										 SingleLine->SetFindLineId(0);
										 SingleLine->SetOrientation(orEast);
										 SingleLine->SetEdgeType(1); // White To Black  
										 SingleLine->OnExecute();
										 RightTrackLine[0].FP0 = SingleLine->GetResultP0();
										 RightTrackLine[0].FP1 = SingleLine->GetResultP1();

										 SingleLine->SetEdgeType(2); // Line Search Org 

										 // RightTrackLine....make OutLine Data 
										 // 현재의 데이터를 넘겨준다 
										 // 검사중 기준라인을 찾지 못할경우 이전데이터 넘겨줘서 기준라인 생성함 
										 if(RightTrackLine[0].FP0.x!=0.0f && RightTrackLine[0].FP0.y!=0.0f && RightTrackLine[0].FP1.x!=0.0f && RightTrackLine[0].FP1.y!=0.0f){
											 PreRightTrackLine[0].FP0.x = RightTrackLine[0].FP0.x;    PreRightTrackLine[0].FP1.x = RightTrackLine[0].FP1.x;       
											 PreRightTrackLine[0].FP0.y = RightTrackLine[0].FP0.y;    PreRightTrackLine[0].FP1.y = RightTrackLine[0].FP1.y;       
										 } // 셀의 상단 시작부터 Broken 발생으로 데이터가 없는경우 
										 else if(RightTrackLine[0].FP0.x==0.0f || RightTrackLine[0].FP0.y==0.0f || RightTrackLine[0].FP1.x==0.0f || RightTrackLine[0].FP1.y==0.0f){
											 if(PreRightTrackLine[0].FP0.x==0.0f && PreRightTrackLine[0].FP0.y==0.0f && PreRightTrackLine[0].FP1.x==0.0f && PreRightTrackLine[0].FP1.y==0.0f){// 시작부분 Broken발생으로 데이터가 없는경우 
												 // Mark좌표를 기준으로 라인좌표값을 다시 설정함 
												 ROI_H = IRoi->GetHeight();
												 ROI_L = IRoi->GetOrgX()  ;
												 RightTrackLine[0].FP0.x = ROI_L;    RightTrackLine[0].FP0.y = 0.0f        ;
												 RightTrackLine[0].FP1.x = ROI_L;    RightTrackLine[0].FP1.y = (float)ROI_H;

												 //RightTrackLine 데이터를 PreRightTrackLine에 넘겨준다 
												 PreRightTrackLine[0].FP0.x = RightTrackLine[0].FP0.x;    PreRightTrackLine[0].FP1.x = RightTrackLine[0].FP1.x;       
												 PreRightTrackLine[0].FP0.y = RightTrackLine[0].FP0.y;    PreRightTrackLine[0].FP1.y = RightTrackLine[0].FP1.y;       
											 }
											 else { // 중간부분 Broken발생으로 데이터가 없는경우 
												 // PreRightTrackLine 데이터를 넘겨줌 
												 RightTrackLine[0].FP0.x = PreRightTrackLine[0].FP0.x;  RightTrackLine[0].FP1.x = PreRightTrackLine[0].FP1.x;  
												 RightTrackLine[0].FP0.y = PreRightTrackLine[0].FP0.y;  RightTrackLine[0].FP1.y = PreRightTrackLine[0].FP1.y;  
											 }
										 }
										 // NOTCH CELL Btm 검사에서만 연마폭 측정함 
										 Right_Grind_Mea =(float)(Math.GetLengthFrLineToPoint (RightOutLine[0].FP0,RightOutLine[0].FP1,RightTrackLine[0].FP0));

										 // 마크라인에서 부터 RightTrackLine 까지 거리 산출 
										 // RightTrackLine Data 존재할 경우 거리 측정함 
										 if(RightTrackLine[0].FP0.x!=0.0f && RightTrackLine[0].FP0.y!=0.0f && RightTrackLine[0].FP1.x!=0.0f && RightTrackLine[0].FP1.y!=0.0f){
											 // 											 RightTrackLine[0].FP0.y = RightTrackLine[0].FP0.y + ImageHeight; //전체 이미지 기준 y좌표
											 // 											 RightTrackLine[0].FP1.y = RightTrackLine[0].FP1.y + ImageHeight; //전체 이미지 기준 y좌표
											 // 
											 // 											 MarkToTrackLineDis1 = Math.GetLengthFrLineToPoint(RightMarkSta, RightMarkEnd, RightTrackLine[0].FP0);//Mark라인에서 TrackLine거리 
											 // 											 MarkToTrackLineDis2 = Math.GetLengthFrLineToPoint(RightMarkSta, RightMarkEnd, RightTrackLine[0].FP1);//Mark라인에서 TrackLine거리 
											 // 
											 // 											 TotalRightTrackDis  +=  (int)((MarkToTrackLineDis1 + MarkToTrackLineDis2)/2.0); //Mark라인에서 TrackLine거리 누적                   
											 // 											 RightTrackLineCount++; //누적 카운트 증가
											 // 
											 // 											 // Org Data 
											 // 											 RightTrackLine[0].FP0.y = RightTrackLine[0].FP0.y - ImageHeight; //Frame 이미지 기준 y좌표 원복
											 // 											 RightTrackLine[0].FP1.y = RightTrackLine[0].FP1.y - ImageHeight; //Frame 이미지 기준 y좌표 원복 
										 }
									 }
									 else { //RightInLine Search, RightTrackLine Data Overlap 
										 // RightInLine Search Start 
										 EasyImage::Threshold(&RotateImg,&RotateBinaryImg, RightEdgeThresHold);
										 //RightOutLine기준 RightInLine 검출
										 if(RightEdgeThresHold==0) {SingleLine->GImage = &RotateImg      ;  SingleLine->FThreshold =5 ;}
										 else                      {SingleLine->GImage = &RotateBinaryImg;  SingleLine->FThreshold =10;}

										 // 영역설정 
										 if(fabs(RightOutLine[0].FP0.x - RightOutLine[0].FP1.x) > 3){
											 LSP.x = (RightOutLine[0].FP0.x + RightOutLine[0].FP1.x)/2;
											 LSP.y = 0.0f;
										 }
										 else {
											 LSP = Math.OnIntersect(RightOutLine[0].FP0, RightOutLine[0].FP1, LT, RT);
										 }

										 SingleLine->IRoi->SetOrgX  ((int)LSP.x-100);
										 SingleLine->IRoi->SetOrgY  (0             );
										 SingleLine->IRoi->SetWidth (97            );
										 SingleLine->IRoi->SetHeight(ImgH          );
										 SingleLine->SetIncrement(5 );

										 if(((LSP.x+3)<=0) || ImgH<=0) return false;

										 // 										 if(IRoi->GetHeight()<300) SingleLine->SetIncrement(5 );
										 // 										 else                      SingleLine->SetIncrement(10);

										 // 연마량 측정 OutLine
										 SingleLine->SetFindLineId(0);
										 SingleLine->SetOrientation(orEast);
										 SingleLine->SetEdgeType(0); // Black to White 
										 SingleLine->OnExecute();
										 RightInLine[0].FP0 = SingleLine->GetResultP0();
										 RightInLine[0].FP1 = SingleLine->GetResultP1();

										 SingleLine->SetEdgeType(2); // Line Search Org 

										 // RightInLine None....make InLine Data 
										 // 현재의 데이터를 넘겨준다 
										 if(RightInLine[0].FP0.x!=0.0f && RightInLine[0].FP0.y!=0.0f && RightInLine[0].FP1.x!=0.0f && RightInLine[0].FP1.y!=0.0f){
											 PreRightInLine[0].FP0.x = RightInLine[0].FP0.x;    PreRightInLine[0].FP1.x = RightInLine[0].FP1.x;       
											 PreRightInLine[0].FP0.y = RightInLine[0].FP0.y;    PreRightInLine[0].FP1.y = RightInLine[0].FP1.y;       
										 }
										 else if(RightInLine[0].FP0.x==0.0f || RightInLine[0].FP0.y==0.0f || RightInLine[0].FP1.x==0.0f || RightInLine[0].FP1.y==0.0f){
											 if(PreRightInLine[0].FP0.x==0.0f && PreRightInLine[0].FP0.y==0.0f && PreRightInLine[0].FP1.x==0.0f && PreRightInLine[0].FP1.y==0.0f){// 시작부분 Broken발생으로 데이터가 없는경우 
												 // Mark좌표를 기준으로 라인좌표값을 다시 설정함 
												 ROI_H = IRoi->GetHeight();
												 ROI_L = IRoi->GetOrgX()  ;
												 RightInLine[0].FP0.x = ROI_L;   RightInLine[0].FP0.y = 0.0f        ;
												 RightInLine[0].FP1.x = ROI_L;   RightInLine[0].FP1.y = (float)ROI_H;

												 //Line 데이터를 PreLine에 넘겨준다 
												 PreRightInLine[0].FP0.x = RightInLine[0].FP0.x;    PreRightInLine[0].FP1.x = RightInLine[0].FP1.x;       
												 PreRightInLine[0].FP0.y = RightInLine[0].FP0.y;    PreRightInLine[0].FP1.y = RightInLine[0].FP1.y;       
											 }
											 else {                                                                                                    // 중간부분 Broken발생으로 데이터가 없는경우 
												 // PreLine 데이터를 넘겨줌 
												 RightInLine[0].FP0.x = PreRightInLine[0].FP0.x;  RightInLine[0].FP1.x = PreRightInLine[0].FP1.x;  
												 RightInLine[0].FP0.y = PreRightInLine[0].FP0.y;  RightInLine[0].FP1.y = PreRightInLine[0].FP1.y;  
											 }
										 }
										 // NOTCH CELL Btm 검사에서만 연마폭 측정함 
										 Right_Grind_Width =(float)(Math.GetLengthFrLineToPoint (RightOutLine[0].FP0,RightOutLine[0].FP1, RightInLine[0].FP0 ));
										 /////////////////////////////////////////////////////////////////////////////////////////////

										 // RightTrackLine Data Overlap
										 if(AvgRightTrackLineDis!=0){
											 // 											 RightOutLine[0].FP0.y = RightOutLine[0].FP0.y + ImageHeight; //전체 이미지 기준 y좌표
											 // 											 RightOutLine[0].FP1.y = RightOutLine[0].FP1.y + ImageHeight; //전체 이미지 기준 y좌표
											 // 
											 // 											 MarkToTrackLineDis1 = Math.GetLengthFrLineToPoint(RightMarkSta, RightMarkEnd, RightOutLine[0].FP0);//Mark라인에서 OutLine까지 거리 
											 // 											 MarkToTrackLineDis2 = Math.GetLengthFrLineToPoint(RightMarkSta, RightMarkEnd, RightOutLine[0].FP1);//Mark라인에서 OutLine까지 거리 
											 // 
											 // 											 if(MarkToTrackLineDis1>AvgRightTrackLineDis) RightTrackLine[0].FP0.x = RightOutLine[0].FP0.x-(MarkToTrackLineDis1 - AvgRightTrackLineDis);
											 // 											 if(MarkToTrackLineDis2>AvgRightTrackLineDis) RightTrackLine[0].FP1.x = RightOutLine[0].FP1.x-(MarkToTrackLineDis2 - AvgRightTrackLineDis);
											 // 
											 // 											 // RightOutLine Data 원본 
											 // 											 RightOutLine[0].FP0.y = RightOutLine[0].FP0.y - ImageHeight; 
											 // 											 RightOutLine[0].FP1.y = RightOutLine[0].FP1.y - ImageHeight; 
											 // 
											 // 											 RightTrackLine[0].FP0.y = RightOutLine[0].FP0.y;
											 // 											 RightTrackLine[0].FP1.y = RightOutLine[0].FP1.y;
										 }
									 }
								 }
								 else {
									 if(IsMarkBtm){ //RightTrackLine Search,Data생성 
										 if(FInspectMode==Insp_Track){
											 // Right TrackLine Search 
											 /////////////////////////////////////////////////////////////////////////////////////////////
											 // 									 BinaryImg.SetSize(GImage->GetWidth(), GImage->GetHeight());
											 // 									 EasyImage::Oper(EArithmeticLogicOperation_Copy,GImage,&BinaryImg);
											 EasyImage::Threshold(&RotateImg,&RotateBinaryImg, CirGrindMeaThresHold);
											 //RightInLine기준 RightTrackLine 검출
											 if(CirGrindMeaThresHold==0) {SingleLine->GImage = &RotateImg      ;  SingleLine->FThreshold =5 ;}
											 else                        {SingleLine->GImage = &RotateBinaryImg;  SingleLine->FThreshold =10;}

											 // 영역설정 
											 if(fabs(RightOutLine[0].FP0.x - RightOutLine[0].FP1.x) > 3){
												 LSP.x = (RightOutLine[0].FP0.x + RightOutLine[0].FP1.x)/2;
												 LSP.y = 0.0f;
											 }
											 else {
												 LSP = Math.OnIntersect(RightOutLine[0].FP0, RightOutLine[0].FP1, LT, RT);
											 }

											 SingleLine->IRoi->SetOrgX  ((int)LSP.x-50            );
											 SingleLine->IRoi->SetOrgY  (0                        );
											 SingleLine->IRoi->SetWidth (47                       );
											 SingleLine->IRoi->SetHeight(FEndLine-CSideCircleHeight);
											 SingleLine->SetIncrement(1 );

											 if(((LSP.x+3)<=0) || ImgH<=0) return false;

											 // 										 if(IRoi->GetHeight()<300) SingleLine->SetIncrement(5 );
											 // 										 else                      SingleLine->SetIncrement(10);

											 // 연마량 측정 OutLine
											 SingleLine->SetFindLineId(0);
											 SingleLine->SetOrientation(orEast);
											 SingleLine->SetEdgeType(1); // White To Black  
											 SingleLine->OnExecute();
											 RightTrackLine[0].FP0 = SingleLine->GetResultP0();
											 RightTrackLine[0].FP1 = SingleLine->GetResultP1();

											 if(fabs(RightTrackLine[0].FP0.x - RightTrackLine[0].FP1.x)>=0.5){
												 RightTrackLine[0].FP0.x = (RightTrackLine[0].FP0.x+RightTrackLine[0].FP1.x)/2.0;
												 RightTrackLine[0].FP1.x = (RightTrackLine[0].FP0.x+RightTrackLine[0].FP1.x)/2.0;
											 }


											 SingleLine->SetEdgeType(2); // Line Search Org 

											 // RightTrackLine....make OutLine Data 
											 // 현재의 데이터를 넘겨준다 
											 // 검사중 기준라인을 찾지 못할경우 이전데이터 넘겨줘서 기준라인 생성함 
											 if(RightTrackLine[0].FP0.x!=0.0f && RightTrackLine[0].FP0.y!=0.0f && RightTrackLine[0].FP1.x!=0.0f && RightTrackLine[0].FP1.y!=0.0f){
												 PreRightTrackLine[0].FP0.x = RightTrackLine[0].FP0.x;    PreRightTrackLine[0].FP1.x = RightTrackLine[0].FP1.x;       
												 PreRightTrackLine[0].FP0.y = RightTrackLine[0].FP0.y;    PreRightTrackLine[0].FP1.y = RightTrackLine[0].FP1.y;       
											 } // 셀의 상단 시작부터 Broken 발생으로 데이터가 없는경우 
											 else if(RightTrackLine[0].FP0.x==0.0f || RightTrackLine[0].FP0.y==0.0f || RightTrackLine[0].FP1.x==0.0f || RightTrackLine[0].FP1.y==0.0f){
												 if(PreRightTrackLine[0].FP0.x==0.0f && PreRightTrackLine[0].FP0.y==0.0f && PreRightTrackLine[0].FP1.x==0.0f && PreRightTrackLine[0].FP1.y==0.0f){// 시작부분 Broken발생으로 데이터가 없는경우 
													 // Mark좌표를 기준으로 라인좌표값을 다시 설정함 
													 ROI_H = IRoi->GetHeight();
													 ROI_L = IRoi->GetOrgX()  ;
													 RightTrackLine[0].FP0.x = ROI_L;    RightTrackLine[0].FP0.y = 0.0f        ;
													 RightTrackLine[0].FP1.x = ROI_L;    RightTrackLine[0].FP1.y = (float)ROI_H;

													 //RightTrackLine 데이터를 PreRightTrackLine에 넘겨준다 
													 PreRightTrackLine[0].FP0.x = RightTrackLine[0].FP0.x;    PreRightTrackLine[0].FP1.x = RightTrackLine[0].FP1.x;       
													 PreRightTrackLine[0].FP0.y = RightTrackLine[0].FP0.y;    PreRightTrackLine[0].FP1.y = RightTrackLine[0].FP1.y;       
												 }
												 else { // 중간부분 Broken발생으로 데이터가 없는경우 
													 // PreRightTrackLine 데이터를 넘겨줌 
													 RightTrackLine[0].FP0.x = PreRightTrackLine[0].FP0.x;  RightTrackLine[0].FP1.x = PreRightTrackLine[0].FP1.x;  
													 RightTrackLine[0].FP0.y = PreRightTrackLine[0].FP0.y;  RightTrackLine[0].FP1.y = PreRightTrackLine[0].FP1.y;  
												 }
											 }

											 // 마크라인에서 부터 RightTrackLine 까지 거리 산출 
											 // RightTrackLine Data 존재할 경우 거리 측정함 
											 // Image Rotate 있음 
											 if(RightTrackLine[0].FP0.x!=0.0f && RightTrackLine[0].FP0.y!=0.0f && RightTrackLine[0].FP1.x!=0.0f && RightTrackLine[0].FP1.y!=0.0f){ // Mark기준 
												 if(RightOutLine[0].FP0.x!=0.0f && RightOutLine[0].FP0.y!=0.0f && RightOutLine[0].FP1.x!=0.0f && RightOutLine[0].FP1.y!=0.0f){
													 RightToTrackLineDis1 = Math.GetLengthFrLineToPoint(RightOutLine[0].FP0, RightOutLine[0].FP1, RightTrackLine[0].FP0);//외곽라인에서 TrackLine거리 
													 RightToTrackLineDis2 = Math.GetLengthFrLineToPoint(RightOutLine[0].FP0, RightOutLine[0].FP1, RightTrackLine[0].FP1);//외곽라인에서 TrackLine거리 

													 TotalRightTrackDis  +=  (int)((RightToTrackLineDis1 + RightToTrackLineDis2)/2.0); //Mark라인에서 TrackLine거리 누적                   
													 RightTrackLineCount++; //누적 카운트 증가
												 }
											 }
										 }
									 }
									 else { //RightTrackLine Data Overlap
										 if(AvgRightTrackLineDis!=0){
											 if(FInspectMode==Insp_Track){ //Mark기준 
												 if(RightOutLine[0].FP0.x!=0.0f && RightOutLine[0].FP0.y!=0.0f && RightOutLine[0].FP1.x!=0.0f && RightOutLine[0].FP1.y!=0.0f){
													 // TOP영역 LeftTrackLine x좌표 
													 RightTrackLine[0].FP0.x = RightOutLine[0].FP0.x - AvgRightTrackLineDis;
													 RightTrackLine[0].FP1.x = RightOutLine[0].FP1.x - AvgRightTrackLineDis;

													 // TOP영역 LeftTrackLine y좌표 
													 RightTrackLine[0].FP0.y = RightOutLine[0].FP0.y;
													 RightTrackLine[0].FP1.y = RightOutLine[0].FP1.y;
												 }
											 }
										 }
									 }
								 }
							 }
						 } 

						 if(FBottomWall){ // BMDT BottomLine Search 시퀀스 
							 EasyImage::Threshold(&RotateImg,&RotateBinaryImg, BtmEdgeThresHold);
							 if(BtmEdgeThresHold==0)    {SingleLine->GImage = &RotateImg      ;  SingleLine->FThreshold =5 ;}
							 else                       {SingleLine->GImage = &RotateBinaryImg;  SingleLine->FThreshold =10;}

							 if(FInspectMode==Insp_Surface){ //표면검사 시퀀스//
								 SingleLine->IRoi->SetOrgX  (IRoi->GetOrgX());
								 SingleLine->IRoi->SetOrgY  (FEndLine-100   );
								 SingleLine->IRoi->SetWidth (IRoi->GetWidth());
								 SingleLine->IRoi->SetHeight(200             );

								 SingleLine->SetOrientation(orSouth);
								 SingleLine->FIncrement =20;
								 SingleLine->SetFindLineId(0);
								 SingleLine->FThreshold =5;

								 if(IsMarkBtm) SingleLine->SetEdgeType(1);  //White To Black
								 else          SingleLine->SetEdgeType(1);  //White To Black

								 SingleLine->OnExecute();
								 Line[3].FP0 = SingleLine->GetResultP0();
								 Line[3].FP1 = SingleLine->GetResultP1();

								 // Image Roate 후 기준 데이터 다시 산출 
								 FLBPoint = Math.OnIntersect(LeftOutLine [0].FP0 , LeftOutLine [0].FP1 , Line[3].FP0, Line[3].FP1);
								 FRBPoint = Math.OnIntersect(RightOutLine[0].FP0 , RightOutLine[0].FP1 , Line[3].FP0, Line[3].FP1);
							 }
							 else             { //외관검사 시퀀스//
								 SingleLine->IRoi->SetOrgX  (IRoi->GetOrgX());
								 SingleLine->IRoi->SetOrgY  (FEndLine-100   );
								 SingleLine->IRoi->SetWidth (IRoi->GetWidth());
								 SingleLine->IRoi->SetHeight(200             );

								 SingleLine->SetOrientation(orSouth);
								 SingleLine->FIncrement =20;
								 SingleLine->SetFindLineId(0);
								 SingleLine->FThreshold =5;

								 if(IsMarkBtm) SingleLine->SetEdgeType(1);  //White To Black
								 else          SingleLine->SetEdgeType(1);  //White To Black

								 SingleLine->OnExecute();
								 // 								 Line[waBottomWall].FP0 = SingleLine->GetResultP0();
								 // 								 Line[waBottomWall].FP1 = SingleLine->GetResultP1();
								 Line[3].FP0 = SingleLine->GetResultP0();
								 Line[3].FP1 = SingleLine->GetResultP1();

								 // Image Roate 후 기준 데이터 다시 산출 
								 FLBPoint = Math.OnIntersect(LeftOutLine [0].FP0 , LeftOutLine [0].FP1 , Line[3].FP0, Line[3].FP1);
								 FRBPoint = Math.OnIntersect(RightOutLine[0].FP0 , RightOutLine[0].FP1 , Line[3].FP0, Line[3].FP1);


								 // Btm TrackLine Search Only LTCell ==> Btm 검사시 
								 if(IsMarkBtm && IsCircleBtm && FInspectMode==Insp_Track){

									 EasyImage::Threshold(&RotateImg,&RotateBinaryImg, CirGrindMeaThresHold);
									 if(CirGrindMeaThresHold==0) {SingleLine->GImage = &RotateImg      ;  SingleLine->FThreshold =5 ;}
									 else                        {SingleLine->GImage = &RotateBinaryImg;  SingleLine->FThreshold =10;}

									 SingleLine->IRoi->SetOrgX  (IRoi->GetOrgX());
									 SingleLine->IRoi->SetOrgY  (FEndLine-100   );
									 SingleLine->IRoi->SetWidth (IRoi->GetWidth());
									 SingleLine->IRoi->SetHeight(200             );

									 // 									 SingleLine->IRoi->SetOrgX  (FLBPoint.x+CSideCircleWidth                               );
									 // 									 SingleLine->IRoi->SetOrgY  (FEndLine-100                                             );
									 // 									 SingleLine->IRoi->SetWidth ((FRBPoint.x-CSideCircleWidth)-(FLBPoint.x+CSideCircleWidth));
									 // 									 SingleLine->IRoi->SetHeight(200                                                      );

									 if((FEndLine-100<=0)|| (FEndLine-100>=ImgW)) return false;

									 SingleLine->SetOrientation(orSouth);
									 SingleLine->FIncrement =50;
									 SingleLine->SetFindLineId(0);
									 SingleLine->FThreshold =5;

									 SingleLine->SetEdgeType(1);  //White To Black 

									 SingleLine->OnExecute();
									 BtmTrackLine[0].FP0 = SingleLine->GetResultP0();
									 BtmTrackLine[0].FP1 = SingleLine->GetResultP1();

									 if(fabs(BtmTrackLine[0].FP0.y - BtmTrackLine[0].FP1.y)>=1){
										 BtmTrackLine[0].FP0.y = (BtmTrackLine[0].FP0.y+BtmTrackLine[0].FP1.y)/2.0;
										 BtmTrackLine[0].FP1.y = (BtmTrackLine[0].FP0.y+BtmTrackLine[0].FP1.y)/2.0;
									 }

									 // TrackLine CrossPoint Calculate (Org Data)
									 FTRLBPoint = Math.OnIntersect(LeftTrackLine [0].FP0, LeftTrackLine [0].FP1, BtmTrackLine[0].FP0 , BtmTrackLine[0].FP1);
									 FTRRBPoint = Math.OnIntersect(RightTrackLine[0].FP0, RightTrackLine[0].FP1, BtmTrackLine[0].FP0 , BtmTrackLine[0].FP1);

									 if(TotalLeftTrackDis!=0  && LeftTrackLineCount!=0){ //LeftTrackLine 거리편차 평균값 
										 AvgLeftTrackLineDis  = (int)(TotalLeftTrackDis/LeftTrackLineCount);
									 }
									 if(TotalRightTrackDis!=0 && RightTrackLineCount!=0){//RightTrackLine 거리편차 평균값 
										 AvgRightTrackLineDis = (int)(TotalRightTrackDis/RightTrackLineCount);
									 }

									 // LeftBtmTrackLine, RightBtmTrackLine Dis Calculate 
									 // TrackLine에서 Mark까지 거리를 개별 계산함 
									 // Image Rotate 있음 
									 if(FInspectMode==Insp_Track){ // 외곽라인 기준 
										 if(BtmTrackLine[0].FP0.x!=0 && BtmTrackLine[0].FP0.y!=0 && BtmTrackLine[0].FP1.x!=0 && BtmTrackLine[0].FP1.y!=0){
											 // 상단에 마크기준으로 거리값을 계산시 이미지 회전으로 인해서 정확성 떨어짐....
											 if(Line[3].FP0.x!=0 && Line[3].FP0.y!=0 && Line[3].FP1.x!=0 && Line[3].FP1.y!=0){
												 AvgLeftBtmTrackLineDis = Math.GetLengthFrLineToPoint(Line[3].FP0, Line[3].FP1, BtmTrackLine[0].FP0);//외곽라인에서 TrackLine거리 
												 AvgRightBtmTrackLineDis= Math.GetLengthFrLineToPoint(Line[3].FP0, Line[3].FP1, BtmTrackLine[0].FP1);//외곽라인에서 TrackLine거리 
											 }
										 }
									 }
								 }
								 else if(!IsMarkBtm && IsCircleBtm && FInspectMode==Insp_Track){ // EnCap Cell 검사시 TrackLine 데이터 만들어 준다 
									 if(AvgLeftBtmTrackLineDis!=0 && AvgRightBtmTrackLineDis!=0){
									     BtmTrackLine[0].FP0.y = Line[3].FP0.y - AvgLeftBtmTrackLineDis ;
										 BtmTrackLine[0].FP1.y = Line[3].FP1.y - AvgRightBtmTrackLineDis;

										 BtmTrackLine[0].FP0.x = Line[3].FP0.x;
										 BtmTrackLine[0].FP1.x = Line[3].FP1.x;
									 }
									 // EnCap영역에 TrackLine 교차점을 LT영역 데이터를 이용하여 가상으로 생성해준다 
									 // Image Rotate 있음 
									 if(LeftTrackLine[0].FP0.x!=0.0f && LeftTrackLine[0].FP0.y!=0.0f && RightTrackLine[0].FP0.x!=0.0f && RightTrackLine[0].FP0.y!=0.0f&&
										 LeftTrackLine[0].FP1.x!=0.0f && LeftTrackLine[0].FP1.y!=0.0f && RightTrackLine[0].FP1.x!=0.0f && RightTrackLine[0].FP1.y!=0.0f){
											 if(BtmTrackLine[0].FP0.x!=0.0f && BtmTrackLine[0].FP0.y!=0.0f && BtmTrackLine[0].FP1.x!=0.0f && BtmTrackLine[0].FP1.y!=0.0f){
												 FTRLBPoint = Math.OnIntersect(LeftTrackLine [0].FP0, LeftTrackLine [0].FP1, BtmTrackLine[0].FP0 , BtmTrackLine[0].FP1);
												 FTRRBPoint = Math.OnIntersect(RightTrackLine[0].FP0, RightTrackLine[0].FP1, BtmTrackLine[0].FP0 , BtmTrackLine[0].FP1);
											 }
									 }
								 }
								 else if(IsCornerBtm){ // Btm영역이 Corner일경우 
									 EasyImage::Threshold(&RotateImg,&RotateBinaryImg, ECThresHold); // Corner ThresHold 
									 if(BtmEdgeThresHold==0)    {SingleLine->GImage = &RotateImg      ;  SingleLine->FThreshold =5 ;}
									 else                       {SingleLine->GImage = &RotateBinaryImg;  SingleLine->FThreshold =10;}

									 // LeftBottom Start 
									 ///////////////////////////////////////////////////////////////////////////////////////////////////
									 SingleLine->IRoi->SetOrgX  ((int)FLBPoint.x-10            );
									 SingleLine->IRoi->SetOrgY  ((int)FLBPoint.y-LBCornerHeight);
									 SingleLine->IRoi->SetWidth ((int)LBCornerWidth+20         );
									 SingleLine->IRoi->SetHeight((int)LBCornerHeight           );

									 SingleLine->SetOrientation(orWest);
									 SingleLine->FIncrement =1;
									 SingleLine->FThreshold =15;
									 SingleLine->SetFindLineId(0);
									 SingleLine->SetEdgeType(1);  //White To Black 
									 SingleLine->OnExecute();

									 Line[7].FP0 = SingleLine->GetResultP0();
									 Line[7].FP1 = SingleLine->GetResultP1();

									 // ORG 
									 FLBLPoint = Math.OnIntersect(SingleLine->GetResultP0(), SingleLine->GetResultP1(), Line[waLeftWall].FP0   , Line[waLeftWall].FP1);
									 FLBBPoint = Math.OnIntersect(SingleLine->GetResultP0(), SingleLine->GetResultP1(), Line[waBottomWall ].FP0, Line[waBottomWall ].FP1);

									 if((FLBLPoint.x==0 || FLBLPoint.y==0 || FLBBPoint.x==0 || FLBBPoint.y==0) || (SingleLine->FEdgePointCount <30)){
										 LBDx = 0.0f;
										 LBDy = 0.0f;
										 //화면에 디스플레이 위해서 
										 FLBLPoint.x = FLBPoint.x;
										 FLBLPoint.y = FLBPoint.y;
										 FLBBPoint.x = FLBPoint.x;
										 FLBBPoint.y = FLBPoint.y;
									 }
									 else { 
										 LBDx = Math.GetLengthFrPointToPoint(FLBPoint, FLBBPoint);
										 LBDy = Math.GetLengthFrPointToPoint(FLBPoint, FLBLPoint);

										 // OutLine C3Corner Data 
										 if((SingleLine->FEdgePointCount) - (CornerMargin*2)>0){
											 if(C3Point!=NULL) delete[] C3Point;
											 C3Point  = new TFPoint [(SingleLine->FEdgePointCount) - (CornerMargin*2)];
											 C3EdgeCount = (SingleLine->FEdgePointCount) -(CornerMargin*2);

											 CornerCount =0;  
											 for(int k=CornerMargin; k<((SingleLine->FEdgePointCount)-CornerMargin); k++){
												 if(CornerCount>=MAX_CORNER_POINT) break;
												 C3Point[CornerCount].x = SingleLine->FEdgePoint[k].x;
												 C3Point[CornerCount].y = SingleLine->FEdgePoint[k].y;
												 CornerCount++;
											 }
										 }

										 // Corner 기울기 완만하여 Edge찾을 경우 Defect 오버킬 발생함 
										 // 방향을 Top방향에서 다시 엣지를 찾음 (Corner Defect OverKill 감소 목적)
										 if(LBCornerWidth >(LBCornerHeight*3)){
											 SingleLine->IRoi->SetOrgX  ((int)FLBPoint.x );
											 SingleLine->IRoi->SetOrgY  ((int)FLBPoint.y - LBCornerHeight    );
											 SingleLine->IRoi->SetWidth ((int)((FLBBPoint.x - FLBPoint.x)+20));
											 SingleLine->IRoi->SetHeight((int)((FLBPoint.y  - FLBLPoint.y)  ));

											 if(FLBPoint.x<=0    || FLBPoint.y - LBCornerHeight<=0    || (FLBBPoint.x - FLBPoint.x )<=0    || ((FLBPoint.y  - FLBLPoint.y)+20)<=0   ) return false;
											 if(FLBPoint.x>=ImgW || FLBPoint.y - LBCornerHeight>=ImgH || (FLBBPoint.x - FLBPoint.x )>=ImgW || ((FLBPoint.y  - FLBLPoint.y)+20)>=ImgH) return false;

											 SingleLine->SetOrientation(orSouth);
											 SingleLine->FIncrement =1;
											 SingleLine->SetFindLineId(0);
											 SingleLine->SetEdgeType(0);  //Black To White 
											 SingleLine->OnExecute();

											 // InLine C3Corner Data 
											 if((SingleLine->FEdgePointCount) - (CornerMargin*2)>0){
												 if(C3InPoint!=NULL) delete[] C3InPoint;
												 C3InPoint  = new TFPoint [(SingleLine->FEdgePointCount) - (CornerMargin*2)];
												 C3EdgeCount = (SingleLine->FEdgePointCount) -(CornerMargin*2);

												 CornerCount =0;  
												 for(int k=CornerMargin; k<((SingleLine->FEdgePointCount)-CornerMargin); k++){
													 if(CornerCount>=MAX_CORNER_POINT) break;
													 C3InPoint[CornerCount].x = SingleLine->FEdgePoint[k].x;
													 C3InPoint[CornerCount].y = SingleLine->FEdgePoint[k].y;
													 CornerCount++;
												 }
											 }
										 }
										 else {
											 // Corner 연마 안쪽라인 찾는다 
											 SingleLine->SetOrientation(orWest);
											 SingleLine->SetFindLineId(0);
											 SingleLine->SetEdgeType(0);  //Black To White 
											 SingleLine->OnExecute();

											 // InLine C1Corner Data 
											 if((SingleLine->FEdgePointCount) - (CornerMargin*2)>0){
												 if(C3InPoint!=NULL) delete[] C3InPoint;
												 C3InPoint  = new TFPoint [(SingleLine->FEdgePointCount) - (CornerMargin*2)];
												 C3EdgeCount = (SingleLine->FEdgePointCount) -(CornerMargin*2);

												 CornerCount =0;  
												 for(int k=CornerMargin; k<((SingleLine->FEdgePointCount)-CornerMargin); k++){
													 if(CornerCount>=MAX_CORNER_POINT) break;
													 C3InPoint[CornerCount].x = SingleLine->FEdgePoint[k].x;
													 C3InPoint[CornerCount].y = SingleLine->FEdgePoint[k].y;
													 CornerCount++;
												 }
											 }
										 }

										 //코너 연마안쪽라인 기준 새로운 교차점 생성 
										 FLBLInPoint = Math.OnIntersect(SingleLine->GetResultP0(), SingleLine->GetResultP1(), Line[waLeftWall].FP0   , Line[waLeftWall].FP1);
										 FLBBInPoint = Math.OnIntersect(SingleLine->GetResultP0(), SingleLine->GetResultP1(), Line[waBottomWall ].FP0, Line[waBottomWall ].FP1);

										 //코너 연마폭 
										 double Dis =0.0f, AvgGrindWidth=0.0f, AvgGrindMea=0.0f, TotalGrindWidth=0.0f, TotalGrindMeasure=0.0f;
										 for(int k=0; k<C3EdgeCount; k++){
											 Dis = Math.GetLengthFrLineToPoint(FLBLPoint, FLBBPoint, C3InPoint[k]);
											 TotalGrindWidth+=Dis;
										 }
										 if(C3EdgeCount!=0){
											 AvgGrindWidth = (TotalGrindWidth/C3EdgeCount);
											 C3CorGrindWd  = AvgGrindWidth;
										 }

										 // 코너 연마량 기준 라인을 찾는다 
										 // ROI 영역 설정(3개의 흰색 점선 기준 라인을 찾는다)
										 if(CorGrindMeaThresHold==0){SingleLine->GImage = &RotateImg           ;  SingleLine->FThreshold =5 ;}
										 else                       {SingleLine->GImage = &RotateGrindBinaryImg;  SingleLine->FThreshold =10;}

										 SingleLine->IRoi->SetOrgX  ((int)FLBPoint.x                   );
										 SingleLine->IRoi->SetOrgY  ((int)FLBPoint.y-LBCornerHeight +20);
										 SingleLine->IRoi->SetWidth ((int)LBCornerWidth +50            );
										 SingleLine->IRoi->SetHeight((int)LBCornerHeight               );

										 SingleLine->SetOrientation(orWest);
										 SingleLine->SetFindLineId(0);
										 SingleLine->SetEdgeType(0);  //Black To White 
										 SingleLine->OnExecute();

										 P1 = SingleLine->GetResultP0();
										 P2 = SingleLine->GetResultP1();

										 //코너 연마량 기준 라인과 새로운 교차점 생성 
										 FLBLMeaPoint = Math.OnIntersect(SingleLine->GetResultP0(), SingleLine->GetResultP1(), Line[waLeftWall].FP0   , Line[waLeftWall].FP1);
										 FLBBMeaPoint = Math.OnIntersect(SingleLine->GetResultP0(), SingleLine->GetResultP1(), Line[waBottomWall ].FP0, Line[waBottomWall ].FP1);

										 // C3Corner Grind Measure Stand Data 
										 if((SingleLine->FEdgePointCount)>0){
											 if(C3MeaPoint!=NULL) delete[] C3MeaPoint;
											 C3MeaPoint     = new TFPoint [(SingleLine->FEdgePointCount)];
											 C3MeaEdgeCount = (SingleLine->FEdgePointCount);

											 CornerCount =0;  
											 for(int k=0; k<(SingleLine->FEdgePointCount); k++){
												 if(CornerCount>=MAX_CORNER_POINT) break;
												 C3MeaPoint[CornerCount].x = SingleLine->FEdgePoint[k].x;
												 C3MeaPoint[CornerCount].y = SingleLine->FEdgePoint[k].y;
												 CornerCount++;
											 }
										 }
										 //코너 연마량 계산  
										 Dis =0.0f, AvgGrindMea=0.0f, TotalGrindMeasure=0.0f;
										 for(int k=0; k<C3MeaEdgeCount; k++){
											 Dis = Math.GetLengthFrLineToPoint(FLBLPoint, FLBBPoint, C3MeaPoint[k]);
											 TotalGrindMeasure+=Dis;
										 }
										 if(C3MeaEdgeCount!=0){
											 AvgGrindMea    = (TotalGrindMeasure/C3MeaEdgeCount);
											 C3CorGrindMea  = AvgGrindMea;
										 }
									 }	
									 // LeftBottom End 
									 ///////////////////////////////////////////////////////////////////////////////////////////////////


									 // RightBottom Start 
									 ///////////////////////////////////////////////////////////////////////////////////////////////////
									 SingleLine->IRoi->SetOrgX  ((int)FRBPoint.x-RBCornerWidth );
									 SingleLine->IRoi->SetOrgY  ((int)FRBPoint.y-RBCornerHeight);
									 SingleLine->IRoi->SetWidth ((int)RBCornerWidth+10         );
									 SingleLine->IRoi->SetHeight((int)RBCornerHeight           );

									 SingleLine->SetOrientation(orEast);
									 SingleLine->FIncrement =1;
									 SingleLine->FThreshold =15;
									 SingleLine->SetFindLineId(0);
									 SingleLine->SetEdgeType(1);  //White To Black 
									 SingleLine->OnExecute();

									 Line[6].FP0 = SingleLine->GetResultP0();
									 Line[6].FP1 = SingleLine->GetResultP1();

									 // ORG 
									 FRBRPoint = Math.OnIntersect(SingleLine->GetResultP0(), SingleLine->GetResultP1(), Line[waRightWall ].FP0, Line[waRightWall] .FP1);
									 FRBBPoint = Math.OnIntersect(SingleLine->GetResultP0(), SingleLine->GetResultP1(), Line[waBottomWall].FP0, Line[waBottomWall].FP1);

									 if((FRBRPoint.x==0 || FRBRPoint.y==0 || FRBBPoint.x==0 || FRBBPoint.y==0) || (SingleLine->FEdgePointCount <30)){
										 RBDx = 0.0f;
										 RBDy = 0.0f;
										 //화면에 디스플레이 위해서 
										 FRBRPoint.x = FRBPoint.x;
										 FRBRPoint.y = FRBPoint.y;
										 FRBBPoint.x = FRBPoint.x;
										 FRBBPoint.y = FRBPoint.y;
									 }
									 else { 
										 RBDx = Math.GetLengthFrPointToPoint(FRBPoint, FRBBPoint);
										 RBDy = Math.GetLengthFrPointToPoint(FRBPoint, FRBRPoint);

										 // OutLine C4Corner Data 
										 if((SingleLine->FEdgePointCount) - (CornerMargin*2)>0){
											 if(C4Point!=NULL) delete[] C4Point;
											 C4Point  = new TFPoint [(SingleLine->FEdgePointCount) - (CornerMargin*2)];
											 C4EdgeCount = (SingleLine->FEdgePointCount) -(CornerMargin*2);

											 CornerCount =0;  
											 for(int k=CornerMargin; k<((SingleLine->FEdgePointCount)-CornerMargin); k++){
												 if(CornerCount>=MAX_CORNER_POINT) break;
												 C4Point[CornerCount].x = SingleLine->FEdgePoint[k].x;
												 C4Point[CornerCount].y = SingleLine->FEdgePoint[k].y;
												 CornerCount++;
											 }
										 }

										 // Corner 기울기 완만하여 Edge찾을 경우 Defect 오버킬 발생함 
										 // 방향을 Top방향에서 다시 엣지를 찾음 (Corner Defect OverKill 감소 목적)
										 if(RBCornerWidth >(RBCornerHeight*3)){
											 SingleLine->IRoi->SetOrgX  ((int)FRBBPoint.x                 ) ;
											 SingleLine->IRoi->SetOrgY  ((int)FRBBPoint.y - RBCornerHeight) ;
											 SingleLine->IRoi->SetWidth ((int)(RBCornerWidth+10           ));
											 SingleLine->IRoi->SetHeight((int)(RBCornerHeight             ));

											 if(FRBBPoint.x<=0    || FRBBPoint.y - RBCornerHeight<=0    || RBCornerWidth+10<=0    || RBCornerHeight+10 <=0    ) return false;
											 if(FRBBPoint.x>=ImgW || FRBBPoint.y - RBCornerHeight>=ImgH || RBCornerWidth+10>=ImgW || RBCornerHeight+10 >=ImgH ) return false;

											 SingleLine->SetOrientation(orSouth);
											 SingleLine->FIncrement =1;
											 SingleLine->SetFindLineId(0);
											 SingleLine->SetEdgeType(0);  //Black To White 
											 SingleLine->OnExecute();

											 // InLine C4Corner Data 
											 if((SingleLine->FEdgePointCount) - (CornerMargin*2)>0){
												 if(C4InPoint!=NULL) delete[] C4InPoint;
												 C4InPoint  = new TFPoint [(SingleLine->FEdgePointCount) - (CornerMargin*2)];
												 C4EdgeCount = (SingleLine->FEdgePointCount) -(CornerMargin*2);

												 CornerCount =0;  
												 for(int k=CornerMargin; k<((SingleLine->FEdgePointCount)-CornerMargin); k++){
													 if(CornerCount>=MAX_CORNER_POINT) break;
													 C4InPoint[CornerCount].x = SingleLine->FEdgePoint[k].x;
													 C4InPoint[CornerCount].y = SingleLine->FEdgePoint[k].y;
													 CornerCount++;
												 }
											 }
										 }
										 else {
											 // Corner 연마 안쪽라인 찾는다 
											 SingleLine->SetOrientation(orEast);
											 SingleLine->SetFindLineId(0);
											 SingleLine->SetEdgeType(0);  //Black To White 
											 SingleLine->OnExecute();

											 // InLine C4Corner Data 
											 if((SingleLine->FEdgePointCount) - (CornerMargin*2)>0){
												 if(C4InPoint!=NULL) delete[] C4InPoint;
												 C4InPoint  = new TFPoint [(SingleLine->FEdgePointCount) - (CornerMargin*2)];
												 C4EdgeCount = (SingleLine->FEdgePointCount) -(CornerMargin*2);

												 CornerCount =0;  
												 for(int k=CornerMargin; k<((SingleLine->FEdgePointCount)-CornerMargin); k++){
													 if(CornerCount>=MAX_CORNER_POINT) break;
													 C4InPoint[CornerCount].x = SingleLine->FEdgePoint[k].x;
													 C4InPoint[CornerCount].y = SingleLine->FEdgePoint[k].y;
													 CornerCount++;
												 }
											 }
										 }

										 //코너 연마안쪽라인 기준 새로운 교차점 생성 
										 FRBRInPoint = Math.OnIntersect(SingleLine->GetResultP0(), SingleLine->GetResultP1(), Line[waRightWall ].FP0, Line[waRightWall ].FP1);
										 FRBBInPoint = Math.OnIntersect(SingleLine->GetResultP0(), SingleLine->GetResultP1(), Line[waBottomWall].FP0, Line[waBottomWall].FP1);

										 //코너 연마폭 
										 double Dis =0.0f, AvgGrindWidth=0.0f, AvgGrindMea=0.0f, TotalGrindWidth=0.0f, TotalGrindMeasure=0.0f;
										 for(int k=0; k<C4EdgeCount; k++){
											 Dis = Math.GetLengthFrLineToPoint(FLBLPoint, FLBBPoint, C4InPoint[k]);
											 TotalGrindWidth+=Dis;
										 }
										 if(C4EdgeCount!=0){
											 AvgGrindWidth = (TotalGrindWidth/C4EdgeCount);
											 C4CorGrindWd  = AvgGrindWidth;
										 }

										 // 코너 연마량 기준 라인을 찾는다 
										 // ROI 영역 설정(3개의 흰색 점선 기준 라인을 찾는다)
										 if(CorGrindMeaThresHold==0){SingleLine->GImage = &RotateImg           ;  SingleLine->FThreshold =5 ;}
										 else                       {SingleLine->GImage = &RotateGrindBinaryImg;  SingleLine->FThreshold =10;}

										 SingleLine->IRoi->SetOrgX  ((int)FRBPoint.x -RBCornerWidth -20 );
										 SingleLine->IRoi->SetOrgY  ((int)FRBPoint.y -RBCornerHeight +20);
										 SingleLine->IRoi->SetWidth ((int)RBCornerWidth                 );
										 SingleLine->IRoi->SetHeight((int)RBCornerHeight                );

										 SingleLine->SetOrientation(orEast);
										 SingleLine->SetFindLineId(0);
										 SingleLine->SetEdgeType(0);  //Black To White 
										 SingleLine->OnExecute();

										 P1 = SingleLine->GetResultP0();
										 P2 = SingleLine->GetResultP1();

										 //코너 연마량 기준 라인과 새로운 교차점 생성 
										 FRBRMeaPoint = Math.OnIntersect(SingleLine->GetResultP0(), SingleLine->GetResultP1(), Line[waRightWall ].FP0, Line[waRightWall ].FP1);
										 FRBBMeaPoint = Math.OnIntersect(SingleLine->GetResultP0(), SingleLine->GetResultP1(), Line[waBottomWall].FP0, Line[waBottomWall].FP1);

										 // C4Corner Grind Measure Stand Data 
										 if((SingleLine->FEdgePointCount)>0){
											 if(C4MeaPoint!=NULL) delete[] C4MeaPoint;
											 C4MeaPoint     = new TFPoint [(SingleLine->FEdgePointCount)];
											 C4MeaEdgeCount = (SingleLine->FEdgePointCount);

											 CornerCount =0;  
											 for(int k=0; k<(SingleLine->FEdgePointCount); k++){
												 if(CornerCount>=MAX_CORNER_POINT) break;
												 C4MeaPoint[CornerCount].x = SingleLine->FEdgePoint[k].x;
												 C4MeaPoint[CornerCount].y = SingleLine->FEdgePoint[k].y;
												 CornerCount++;
											 }
										 }
										 //코너 연마량 계산  
										 Dis =0.0f, AvgGrindMea=0.0f, TotalGrindMeasure=0.0f;
										 for(int k=0; k<C4MeaEdgeCount; k++){
											 Dis = Math.GetLengthFrLineToPoint(FRBRPoint, FRBBPoint, C4MeaPoint[k]);
											 TotalGrindMeasure+=Dis;
										 }
										 if(C4MeaEdgeCount!=0){
											 AvgGrindMea    = (TotalGrindMeasure/C4MeaEdgeCount);
											 C4CorGrindMea  = AvgGrindMea;
										 }
									 }	
									 // RightBottom End 
									 ///////////////////////////////////////////////////////////////////////////////////////////////////
								 }
								 else if(IsRectBtm){ // Btm영역이 Rect일경우 
									 LBDx = 0.0f;
									 LBDy = 0.0f;
									 RBDx = 0.0f;
									 RBDy = 0.0f;

									 //화면에 디스플레이 위해서 
									 FLBLPoint.x = FLBPoint.x;
									 FLBLPoint.y = FLBPoint.y;
									 FLBBPoint.x = FLBPoint.x;
									 FLBBPoint.y = FLBPoint.y;

									 FRBRPoint.x = FRBPoint.x;
									 FRBRPoint.y = FRBPoint.y;
									 FRBBPoint.x = FRBPoint.x;
									 FRBBPoint.y = FRBPoint.y;
								 }
							 }

							 // Btm EdgeLine Search(Cicle 영역 검사조건에서 MarkMode VS TrackMode 구별하여 시퀀스 진행함)
							 if(FLBPoint.x!=0 && FLBPoint.y!=0 && FRBPoint.x!=0 && FRBPoint.y!=0 && IsCircleBtm && FInspectMode!=Insp_Surface){
								 //자재의 외곽라인 교차점 기준 CirCenter 설정함 
								 if(CSideCircleWidth!=0.0f && CSideCircleHeight!=0.0f){
									 C1CirCenter.x = FLBPoint.x + CSideCircleWidth + dCirOffsetX;  C1CirCenter.y = FLBPoint.y -  CSideCircleHeight - dCirOffsetY;  
									 C6CirCenter.x = FRBPoint.x - CSideCircleWidth - dCirOffsetX;  C6CirCenter.y = FRBPoint.y -  CSideCircleHeight              ;  
								 }

								 if(CenterCircleWidth!=0.0f && CenterCircleHeight!=0.0f){
									 C2CirCenter.x = FLBPoint.x + CELL_E - CELL_F               ;  C2CirCenter.y = FLBPoint.y -  CenterCircleHeight             ;  
									 C3CirCenter.x = FLBPoint.x + CELL_E                        ;  C3CirCenter.y = FLBPoint.y -  CELL_D+(CenterCircleHeight)    ;  
									 C4CirCenter.x = FRBPoint.x - CELL_E                        ;  C4CirCenter.y = FRBPoint.y -  CELL_D+(CenterCircleHeight)    ;  
									 C5CirCenter.x = FRBPoint.x - CELL_E + CELL_F               ;  C5CirCenter.y = FRBPoint.y -  CenterCircleHeight             ;  
								 }

								 if(FInspectMode==Insp_Track){ //TrackMode TrackLine교자점 기준으로 Circle 센터 좌표 계산함 
									 TrackC1CirCenter.x = FTRLBPoint.x + TrackCircleWidth + dCirOffsetX     ;  TrackC1CirCenter.y = FTRLBPoint.y - TrackCircleHeight - dCirOffsetY                ;  
									 TrackC2CirCenter.x = FTRLBPoint.x + CELL_E - CELL_F - OutToTrackLineDis;  TrackC2CirCenter.y = FTRLBPoint.y - CenterCircleHeight+OutToTrackLineDis           ;  
									 TrackC3CirCenter.x = FTRLBPoint.x + CELL_E - OutToTrackLineDis         ;  TrackC3CirCenter.y = FTRLBPoint.y - CELL_D + (CenterCircleHeight)+OutToTrackLineDis;  
									 TrackC4CirCenter.x = FTRRBPoint.x - CELL_E + OutToTrackLineDis         ;  TrackC4CirCenter.y = FTRRBPoint.y - CELL_D + (CenterCircleHeight)+OutToTrackLineDis;  
									 TrackC5CirCenter.x = FTRRBPoint.x - CELL_E + CELL_F + OutToTrackLineDis;  TrackC5CirCenter.y = FTRRBPoint.y - CenterCircleHeight+OutToTrackLineDis           ;  
									 TrackC6CirCenter.x = FTRRBPoint.x - TrackCircleWidth - dCirOffsetX     ;  TrackC6CirCenter.y = FTRRBPoint.y - TrackCircleHeight - dCirOffsetY                ;
								 }
								 // 자재의 외곽라인 교차점 기준 GrindMark Match 영역 설정 및 Match 검사 시퀀스 
								 if(IsMarkBtm && FInspectMode!=Insp_Track){
									 // Match 알고리즘 적용한 검사 시퀀스 
									 double OrgDis=0.0f, MatchDis=0.0f, DvDis=0.0f, AvgDvDis=0.0f, MinDvDis=100000.0f; 
									 // Find 알고리즘 적용한 검사 시퀀스 
									 // GrindMarkRect영역 설정 (Find)
									 // 화면에 설정값을 최소화 목적으로 영역설정값을 다시 계산함
									 for(int k=0; k<19; k++){
										 // 특정 포인트는 현재 GrindMark없음...
										 // 									 if(k==0 || k==3 || k==4|| k==6 || k==8 || k==10|| k==12 ||k==14|| k==15 || k==18) continue;
										 if(k<9)    {
											 if(GrindRectSpec[k].DvX==0.0f || GrindRectSpec[k].DvY==0.0f)  continue;
										 }
										 else if(k>9){
											 if(GrindRectSpec[18 -k].DvX==0.0f || GrindRectSpec[18 -k].DvY==0.0f)  continue;
										 }


										 if(k<9){ // Left 영역 
											 GrindMarkRect[k].left = (FLBPoint.x + GrindRectSpec[k].DvX) -GrindMarkRange;
											 GrindMarkRect[k].top  = (FLBPoint.y - GrindRectSpec[k].DvY) -GrindMarkRange;
										 }
										 else if(k==9 && CenterCircleHeight!=0.0f && CenterCircleWidth!=0.0f){																	      
											 GrindMarkRect[k].left   = (FLBPoint.x + ((FRBPoint.x -FLBPoint.x)/2) -GrindMarkRange);
											 GrindMarkRect[k].top    = (FLBPoint.y - CELL_D - OutToGrindMarkDis1  -GrindMarkRange);
										 }																				      
										 else if(k>9){ //Right 영역 
											 GrindMarkRect[k].left = (FRBPoint.x - GrindRectSpec[18 -k].DvX) -GrindMarkRange;
											 GrindMarkRect[k].top  = (FRBPoint.y - GrindRectSpec[18 -k].DvY) -GrindMarkRange;
										 }
										 // GrindMarkRect Right/Bottom 영역 좌표 계산 
										 GrindMarkRect[k].right  = GrindMarkRect[k].left+GrindMarkLength;
										 GrindMarkRect[k].bottom = GrindMarkRect[k].top +GrindMarkLength;
									 }

									 // Match 검사시 기본 설정 
									 // 								 if(IsMarkBtm) Find->OnLoad(true,FindDir  );
									 // 								 else          Find->OnLoad(true,FindDir,1);
									 LogUnit.SetLog(L"GindMark_Find_Circle_Start"   );
									 Find->OnLoad(true,FindDir  )                   ;
									 Find->GImage = &RotateImg                      ;
									 // 								 Find->SetContrastMode(EFindContrastMode_Any)   ;
									 Find->SetContrastMode(EFindContrastMode_Normal);
									 // 								 Find->SetMinScore(0.8f)                        ;
									 Find->SetMinScore (GrindMarkMinScore)          ; // PatternrFind 검사 최소 Score
									 Find->SetZeroScore(GrindMarkMinScore)          ; // 검사 후 최소 Score 
									 Find->SetMaxInstances(1)                       ;
									 Find->SetAngleTolerance(20.0f)                 ;
									 Find->SetScaleBias(1.00f)                      ;
									 Find->SetScaleTolerance(0.0f)                  ;
									 Find->Property.Ox = (float)ImgW/2              ;
									 Find->Property.Oy = (float)ImgH/2              ;

									 // 								 int GrindRectWidth=0, GrindRectHeight=0;
									 GrindRectWidth=0, GrindRectHeight=0;
									 // Math 검사 진행 및 ㅏ Mark 중심좌표 산출 
									 // 								 for(int k=0; k<MAX_FIND_MARK_COUNT; k++){
									 for(int k=0; k<19; k++){ 
										 // 특정 포인트는 현재 GrindMark없음...
										 if(k==0 || k==3 || k==4|| k==6 || k==8 || k==10|| k==12 ||k==14|| k==15 || k==18) continue;

										 GrindRectWidth  = (GrindMarkRect[k].right  - GrindMarkRect[k].left);
										 GrindRectHeight = (GrindMarkRect[k].bottom - GrindMarkRect[k].top );
										 Find->IRoi->SetPlacement(GrindMarkRect[k].left,GrindMarkRect[k].top,GrindRectWidth,GrindRectHeight);
										 if(GrindMarkRect[k].left<=0    || GrindMarkRect[k].top<=0    || GrindRectWidth<=0    || GrindRectHeight<=0   ) continue;
										 if(GrindMarkRect[k].left>=ImgW || GrindMarkRect[k].top>=ImgH || GrindRectWidth>=ImgW || GrindRectHeight>=ImgH) continue;

										 if     (k==1 ) Find->SetAngleBias(45.0f );
										 else if(k==2 ) Find->SetAngleBias(0.0f  );
										 else if(k==5 ) Find->SetAngleBias(315.0f);
										 else if(k==7 ) Find->SetAngleBias(315.0f);
										 else if(k==9 ) Find->SetAngleBias(0.0f  );
										 else if(k==11) Find->SetAngleBias(45.0f );
										 else if(k==13) Find->SetAngleBias(45.0f );
										 else if(k==16) Find->SetAngleBias(0.0f  );
										 else if(k==17) Find->SetAngleBias(315.0f);
										 // 검사 및 Match Pos 좌표 받어온다 
										 // Find 검사 성공시 데이터 받아옴 
										 if(Find->OnExecute()){
											 GrindMarkPoint[k].x = Find->Result[0].Px;
											 GrindMarkPoint[k].y = Find->Result[0].Py;
											 GrindMarkScore[k]   = Find->Result[0].Score;// 실제 Pattern Finder Score Value
										 }
										 // Contrast Gradient Pixel Value
// 										 GrindMarkGradient[k] = EasyImage::Focusing(Find->IRoi);
									 }
									 LogUnit.SetLog(L"GindMark_Find_Circle_End");
								 }

								 // 각각의 CirCenter_Point 기준 Circle_Fitting 및 검사진행 
								 if(FBottomWall){
									 EasyImage::Threshold(&RotateImg,&RotateBinaryImg       , BtmEdgeThresHold    ); // Circle Grind Edge
									 EasyImage::Threshold(&RotateImg,&RotateGrindBinaryImg  , CirGrindMeaThresHold); // Circle Grind Measure 측정 기준 패턴Edge(Circle Track Line)
									 EasyImage::Threshold(&RotateImg,&RotateGrindInBinaryImg, CirGrindInThresHold ); // Circle Grind In_EdgePoint 측정 목적

									 // 									 RotateBinaryImg.Save       ("D:\\ROTATE_IMG\\RotateBinaryImg회전_CUP.bmp");
// 									 RotateGrindBinaryImg.Save  ("D:\\ROTATE_IMG\\RotateGrindBinaryImg_TrackLine회전_CUP.bmp");
// 									 RotateGrindInBinaryImg.Save("D:\\ROTATE_IMG\\RotateGrindInBinaryImg.bmp");

									 // Circle Fitting 진행시 공통으로 사용하는 설정값
									 Circle->SetSamplingStep(1)                            ; // Circle Edge 간격 

									 // 첫번째 Circle EdgePoint Data 추출 
									 if(C1CirCenter.x!=0 && C1CirCenter.y!=0){
										 LogUnit.SetLog(L"Circle_1_Insp_Start");

										 // 									 if(BtmEdgeThresHold==0) Circle->GImage = &RotateImg      ; //Org Image 넘겨줌 
										 // 									 else                    Circle->GImage = &RotateBinaryImg; //Binary Image 넘겨줌 

										 if(CirGrindInThresHold==0) Circle->GImage = &RotateImg             ; //Org Image 넘겨줌 
										 else                       Circle->GImage = &RotateGrindInBinaryImg; //Binary Image 넘겨줌 

										 if      (FInspectMode==Insp_Track) Circle->SetCenterXY(TrackC1CirCenter.x , TrackC1CirCenter.y); // TrackLine 교차점 기준 센터 
										 else if (FInspectMode==Insp_Mark ) Circle->SetCenterXY(C1CirCenter.x      , C1CirCenter.y     ); // 외곽라인 교차점 기준 센터 

										 // Diameter 계산함(OutCircle과 TrackCircle 중간값 기준)
										 // 									 C1Diameter = ((CSideCircleWidth*2)+(TrackCircleWidth*2))/2;
										 C1Diameter = (CSideCircleWidth*2);
										 // 									 C1Diameter = (CSideCircleWidth*2);
										 // 검사 영역으로 인해서 불량 미검출 발생할수 있음....LTPS와 EnCap분류함
										 if(IsMarkBtm) Circle->SetTolerance(60.0f);
										 else          Circle->SetTolerance(80.0f);
										 // 									 Circle->SetTolerance(40.0f )                              ; // Circle Tolerance 
										 Circle->SetDiameter (C1Diameter)                          ; // Circle Diameter 
										 // 									 Circle->SetCircleChoice(0)                                ; // 0:From Begin, 1:From End, 2:Largest Amplitude 
										 // 									 Circle->SetCircleIndex (0)                                ; // Circle EdgePoint Index 
										 Circle->SetCircleChoice(1)                                ; // 0:From Begin, 1:From End, 2:Largest Amplitude 
										 Circle->SetCircleType  (2)                                ; // 0:Black to White, 1:White to Black 2: Both Black, White 
										 Circle->SetCircleIndex (1)                                ; // Circle EdgePoint Index 

										 // Angle 및 Amplitude 설정 
										 if(SideCirDeg>=0){
											 Circle->SetAngle    (90+CirAngleMargin          );  // Circle Fitting 시작점 각도
											 Circle->SetAmplitude(SideCirDeg-2*CirAngleMargin);  // Circle Fitting 시작점 부터 검사 범위 
										 }

										 // Circle1 InData EdgePoint 
										 //////////////////////////////////////////////////////////////////////////////////////////////////////
										 Circle->OnExecute()                               ;

										 // Circle In Data 기준 새로운 Circle Center 좌표 받아옴 
										 RealC1CirCenter.x = Circle->FCP.x;
										 RealC1CirCenter.y = Circle->FCP.y;
										 CirDiameter1      = (Circle->Diameter)/2.0;

										 // Circle In Data취합 
										 OrgC1CirInEdgeCount = Circle->FCirclePointCount;
										 if(OrgC1CirInEdgeCount>0){
											 if(OrgC1CirInPoint!=NULL) delete[] OrgC1CirInPoint;
											 OrgC1CirInPoint = new TFPoint[OrgC1CirInEdgeCount];

											 for(int k=0; k<OrgC1CirInEdgeCount; k++){
												 if(k>MAX_CIRCLE_EDGEPOINT) break;
												 OrgC1CirInPoint[k].x = Circle->FCirclePoint[k].x;
												 OrgC1CirInPoint[k].y = Circle->FCirclePoint[k].y;
												 if(OrgC1CirInPoint[k].x==0.0f && OrgC1CirInPoint[k].y==0.0f) C1CirInEdgeCount++;
												 // BTM영역 Circle을 제외한 영역 Defect검사 목적에 좌표계산 
												 // 											 if(k==0) {BtmEdgePoint1.x = C1CirInPoint[k].x; BtmEdgePoint1.y = C1CirInPoint[k].y;}
											 }
										 }
										 //////////////////////////////////////////////////////////////////////////////////////////////////////

										 // Circle Out Data 다시 검사  
										 //////////////////////////////////////////////////////////////////////////////////////////////////////
										 if(BtmEdgeThresHold==0) Circle->GImage = &RotateImg      ; //Org Image 넘겨줌 
										 else                    Circle->GImage = &RotateBinaryImg; //Binary Image 넘겨줌 

										 // 검사 영역으로 인해서 불량 미검출 발생할수 있음....LTPS와 EnCap분류함
										 if(IsMarkBtm) Circle->SetTolerance(60.0f);
										 else          Circle->SetTolerance(80.0f);
										 // 									Circle->SetTolerance(40.0f )      ; // Circle Tolerance 
										 Circle->SetDiameter (C1Diameter)  ; // Circle Diameter 
										 Circle->SetCircleChoice(1)        ; // 0:From Begin, 1:From End, 2:Largest Amplitude 
										 Circle->SetCircleType(2)          ; // 0:Black to White, 1:White to Black 2: Both Black, White 
										 Circle->SetCircleIndex (0)        ; // Circle EdgePoint Index 
										 // Circle1 OutData EdgePoint 
										 /////////////////////////////////////////////////////////////////////////////////////////////////////////
										 Circle->OnExecute()               ;

										 // Circle Out Data취합 
										 OrgC1CirOutEdgeCount = Circle->FCirclePointCount;
										 if(OrgC1CirOutEdgeCount>0){
											 if(OrgC1CirOutPoint!=NULL) delete[] OrgC1CirOutPoint;
											 OrgC1CirOutPoint = new TFPoint[OrgC1CirOutEdgeCount];

											 for(int k=0; k<OrgC1CirOutEdgeCount; k++){
												 if(k>MAX_CIRCLE_EDGEPOINT) break;
												 OrgC1CirOutPoint[k].x = Circle->FCirclePoint[k].x;
												 OrgC1CirOutPoint[k].y = Circle->FCirclePoint[k].y;
												 // BTM영역 Circle을 제외한 영역 Defect검사 목적에 좌표계산 
												 if(k==0) {BtmEdgePoint[0].x = OrgC1CirOutPoint[k].x; BtmEdgePoint[0].y = OrgC1CirOutPoint[k].y;}
												 if(OrgC1CirOutPoint[k].x==0.0f && OrgC1CirOutPoint[k].y==0.0f) C1CirOutEdgeCount++;
											 }
										 }
										 // C1Circle Grind_Width Calculate 
										 // TrackMode CirInEdgePoint 기준과 CirOutEdgePoint 수직거리 산출
										 if(FInspectMode==Insp_Track){
											 // 연마량 계산 
											 if(OrgC1CirInEdgeCount==OrgC1CirOutEdgeCount){
												 double OutDis=0.0f, InDis=0.0f, TotalGrindWidth=0.0f, AvgGrindWidth=0.0f;C1GrindWidthCount=0;
												 for(int k=0; k<OrgC1CirInEdgeCount; k++){
													 if(OrgC1CirOutPoint[k].x==0.0f && OrgC1CirOutPoint[k].y==0.0f){
														 OutDis =0.0f;
													 }
													 else {
														 OutDis = Math.GetLengthFrPointToPoint(C1CirCenter,OrgC1CirOutPoint[k]);
													 }

													 if(OrgC1CirInPoint[k].x==0.0f && OrgC1CirInPoint[k].y==0.0f){
														 InDis =0.0f;
													 }
													 else {
														 InDis = Math.GetLengthFrPointToPoint(C1CirCenter,OrgC1CirInPoint[k]);
													 }

													 // CircleFitting 진행시 실제 EdgePoint 데이터가 존재 할 경우만 포함하여 계산한다
													 if(OutDis!=0.0f && InDis!=0.0f){
														 TotalGrindWidth+=(OutDis - InDis);
														 C1GrindWidthCount++;
													 }
												 }
												 if(C1GrindWidthCount!=0){
													 AvgGrindWidth = (TotalGrindWidth/C1GrindWidthCount);
													 C1CirGrindWd = AvgGrindWidth;
												 }
											 }
											 if(IsMarkBtm){ // 가공량 계산(TrackMode)==>LTPS
												 if(CirGrindMeaThresHold!=0){
													 Circle->GImage = &RotateGrindBinaryImg    ; //Binary Image 넘겨줌 
													 Circle->SetCircleChoice(1)                ; // 0:From Begin, 1:From End, 2:Largest Amplitude 
													 Circle->SetCircleType(2)                  ; // 0:Black to White, 1:White to Black 2: Both Black, White 
													 Circle->SetCircleIndex (1)                ; // Circle EdgePoint Index 
													 Circle->SetTolerance(80.0f )              ; // Circle Tolerance 
													 Circle->SetDiameter (C1Diameter)          ; // Circle Diameter 
													 Circle->OnExecute()                       ;

													 // Circle TrackLine Data 기준 새로운 Circle Center 좌표 받아옴 
													 // Circle Defect검사시 필요한 기준데이터 좌표 
													 RealC1CirCenter.x = Circle->FCP.x;
													 RealC1CirCenter.y = Circle->FCP.y;

													 OrgC1CirStandEdgeCount = Circle->FCirclePointCount;
													 if(OrgC1CirStandEdgeCount>0){
														 if(OrgC1CirStandPoint!=NULL) delete[] OrgC1CirStandPoint;
														 OrgC1CirStandPoint = new TFPoint[OrgC1CirStandEdgeCount];

														 PreC1CirStandPoint[0].x=0.0f; PreC1CirStandPoint[0].y=0.0f; 
														 for(int k=0; k<OrgC1CirStandEdgeCount; k++){
															 if(k>MAX_CIRCLE_EDGEPOINT) break;
															 OrgC1CirStandPoint[k].x = Circle->FCirclePoint[k].x;
															 OrgC1CirStandPoint[k].y = Circle->FCirclePoint[k].y;
															 if(OrgC1CirStandPoint[k].x==0.0f && OrgC1CirStandPoint[k].y==0.0f) C1CirStandEdgeCount++;
															 // TrackLine 자재 상태에 따라서 잘못된 EdgePoint를 찾을경우 대비하여 이전데이터 기준 데이터 복원 
															 if(OrgC1CirStandPoint[k].x!=0.0f && OrgC1CirStandPoint[k].y!=0.0f){
																 // 첫번째는 무조건 데이터 넘겨줌 
																 if(PreC1CirStandPoint[0].x==0.0f && PreC1CirStandPoint[0].y==0.0f){
																	 PreC1CirStandPoint[0].x = OrgC1CirStandPoint[k].x; 
																	 PreC1CirStandPoint[0].y = OrgC1CirStandPoint[k].y; 
																 }
																 // 																 else {
																 // 																	 if(fabs(OrgC1CirStandPoint[k].x-PreC1CirStandPoint[0].x)>TrackLineMargin ||
																 // 																		 fabs(OrgC1CirStandPoint[k].y-PreC1CirStandPoint[0].y)>TrackLineMargin   ){
																 // 																			 OrgC1CirStandPoint[k].x = PreC1CirStandPoint[0].x-0.5;
																 // 																			 OrgC1CirStandPoint[k].y = PreC1CirStandPoint[0].y-0.5;
																 // 
																 // 																			 PreC1CirStandPoint[0].x = OrgC1CirStandPoint[k].x; 
																 // 																			 PreC1CirStandPoint[0].y = OrgC1CirStandPoint[k].y; 
																 // 																	 }
																 // 																	 else {
																 // 																		 PreC1CirStandPoint[0].x = OrgC1CirStandPoint[k].x; 
																 // 																		 PreC1CirStandPoint[0].y = OrgC1CirStandPoint[k].y; 
																 // 																	 }
																 // 																 }
															 }
														 }
														 //C1Circle Grind_Measure Calculate 
														 if(OrgC1CirOutEdgeCount==OrgC1CirStandEdgeCount){
															 double GrindMeaDis=0.0f, TotalGrindMeasure=0.0f, AvgGrindMeasure=0.0f;C1GrindMeasureCount=0;
															 double Degree =0.0f;
															 for(int k=0; k<OrgC1CirStandEdgeCount; k++){
																 if(OrgC1CirOutPoint[k].x==0.0f || OrgC1CirOutPoint[k].y==0.0f || OrgC1CirStandPoint[k].x==0.0f || OrgC1CirStandPoint[k].y==0.0f){
																	 GrindMeaDis =0.0f;
																 }
																 else {
																	 Degree = Math.GetDegree(OrgC1CirStandPoint[k],OrgC1CirOutPoint[k]);
																	 GrindMeaDis = Math.GetLengthFrPointToPoint(OrgC1CirStandPoint[k],OrgC1CirOutPoint[k]);
																 }

																 if(GrindMeaDis!=0.0f){
																	 TotalGrindMeasure+= GrindMeaDis;
																	 C1GrindMeasureCount++;
																 }
															 }
															 if(C1GrindMeasureCount!=0){
																 AvgGrindMeasure = (TotalGrindMeasure/C1GrindMeasureCount);
																 C1CirGrindMea= AvgGrindMeasure;
															 }
														 }
														 else if(OrgC1CirStandEdgeCount>OrgC1CirOutEdgeCount) { // 연마가 적게되어 실제 TrackLine보다 EdgePoint데이터가 적을경우 
															 double GrindMeaDis=0.0f, TotalGrindMeasure=0.0f, AvgGrindMeasure=0.0f;C1GrindMeasureCount=0;
															 for(int k=0; k<OrgC1CirOutEdgeCount; k++){
																 if(OrgC1CirOutPoint[k].x==0.0f || OrgC1CirOutPoint[k].y==0.0f || OrgC1CirStandPoint[k].x==0.0f || OrgC1CirStandPoint[k].y==0.0f ){
																	 GrindMeaDis =0.0f;
																 }
																 else {
																	 GrindMeaDis = Math.GetLengthFrPointToPoint(OrgC1CirStandPoint[k],OrgC1CirOutPoint[k]);
																 }

																 if(GrindMeaDis!=0.0f){
																	 TotalGrindMeasure+= GrindMeaDis;
																	 C1GrindMeasureCount++;
																 }
															 }
															 if(C1GrindMeasureCount!=0){
																 AvgGrindMeasure = (TotalGrindMeasure/C1GrindMeasureCount);
																 C1CirGrindMea= AvgGrindMeasure;
															 }
														 }
														 else if(OrgC1CirStandEdgeCount<OrgC1CirOutEdgeCount){
															 double GrindMeaDis=0.0f, TotalGrindMeasure=0.0f, AvgGrindMeasure=0.0f;C1GrindMeasureCount=0;
															 // test 
															 double OutDegree=0.0f, TrackDegree=0.0f;
															 for(int k=0; k<OrgC1CirStandEdgeCount; k++){
																 if(OrgC1CirOutPoint[k].x==0.0f || OrgC1CirOutPoint[k].y==0.0f || OrgC1CirStandPoint[k].x==0.0f || OrgC1CirStandPoint[k].y==0.0f ){
																	 GrindMeaDis =0.0f;
																 }
																 else {
																	 OutDegree   = Math.GetDegree(TrackC1CirCenter, OrgC1CirOutPoint[k]  );
																	 TrackDegree = Math.GetDegree(TrackC1CirCenter, OrgC1CirStandPoint[k]); 
																	 GrindMeaDis = Math.GetLengthFrPointToPoint(OrgC1CirStandPoint[k],OrgC1CirOutPoint[k]);
																 }

																 if(GrindMeaDis!=0.0f){
																	 TotalGrindMeasure+= GrindMeaDis;
																	 C1GrindMeasureCount++;
																 }
															 }
															 if(C1GrindMeasureCount!=0){
																 AvgGrindMeasure = (TotalGrindMeasure/C1GrindMeasureCount);
																 C1CirGrindMea= AvgGrindMeasure;
															 }
														 }
													 }
												 }
											 }
										 }
										 else if(FInspectMode==Insp_Mark){ // MarkMode 
											 if(IsMarkBtm){ // LTPS경우 가공량 계산 ==> 연마량 계산 
												 if(OrgC1CirOutEdgeCount!=0 && OrgC1CirInEdgeCount!=0) { // MarkMode경우 가공량 검사를 먼저 진행 후 연마량 산출  
													 GrindMeaDis =0.0f, MinDis =10000.0f;C1GrindMarkCount=0;
													 if(GrindMarkPoint[1].x!=0.0f && GrindMarkPoint[1].y!=0.0f){ // Grind Mark 찾았을경우 
														 for(int k=0; k<OrgC1CirOutEdgeCount; k++){
															 if(OrgC1CirOutPoint[k].x==0.0f || OrgC1CirOutPoint[k].y==0.0f) continue;
															 if(GrindMarkPoint[1].x  ==0.0f || GrindMarkPoint[1].y  ==0.0f) continue;

															 GrindMeaDis = Math.GetLength(GrindMarkPoint[1], OrgC1CirOutPoint[k]);
															 if(GrindMeaDis<MinDis){
																 MinDis = GrindMeaDis;
																 C1GrindMarkCount = k;
															 }
														 }
														 // GrindMark기준 수직 포인트 주변값 Avg산출한다 ==>가공량 측정 
														 if(C1GrindMarkCount!=0 && C1GrindMarkCount>5){
															 CircleCount=0,TotalCirDis=0.0f,GrindMeaDis=0.0f;
															 for(int k=C1GrindMarkCount-5; k<C1GrindMarkCount+5; k++){
																 if(OrgC1CirOutPoint[k].x==0.0f || OrgC1CirOutPoint[k].y==0.0f) continue;
																 GrindMeaDis = Math.GetLength(GrindMarkPoint[1], OrgC1CirOutPoint[k]);
																 TotalCirDis+= GrindMeaDis;
																 CircleCount++;
															 }
															 if(TotalCirDis!=0.0f && CircleCount!=0){
																 C1CirGrindMea = TotalCirDis/CircleCount;
															 }
														 }

														 // GrindMark기준 수직 평균값 연마량 측정 
														 if(C1GrindMarkCount!=0 && C1GrindMarkCount>5){
															 CircleCount=0,TotalCirDis=0.0f,GrindWidthDis=0.0f;
															 for(int k=C1GrindMarkCount-5; k<C1GrindMarkCount+5; k++){
																 if(OrgC1CirOutPoint[k].x==0.0f && OrgC1CirOutPoint[k].y==0.0f) continue;
																 if(OrgC1CirInPoint [k].x==0.0f && OrgC1CirInPoint [k].y==0.0f) continue;
																 GrindWidthDis = Math.GetLength(OrgC1CirInPoint[k], OrgC1CirOutPoint[k]);
																 TotalCirDis+=   GrindWidthDis;
																 CircleCount++;
															 }
															 if(TotalCirDis!=0.0f && CircleCount!=0){
																 C1CirGrindWd = TotalCirDis/CircleCount;
															 }
														 }
													 }
													 else { // Grind Mark 못 찾았을경우 (가공량 0, 연마량 계산함)
														 for(int k=0; k<OrgC1CirOutEdgeCount; k++){
															 if(OrgC1CirOutPoint[k].x==0.0f || OrgC1CirOutPoint[k].y==0.0f) continue;

															 GrindMarkRectCenter[1].x = GrindMarkRect[1].left + (GrindMarkRect[1].right  - GrindMarkRect[1].left)/2; 
															 GrindMarkRectCenter[1].y = GrindMarkRect[1].top  + (GrindMarkRect[1].bottom - GrindMarkRect[1].top )/2; 

															 GrindMeaDis = Math.GetLength(GrindMarkRectCenter[1], OrgC1CirOutPoint[k]);
															 if(GrindMeaDis<MinDis){
																 MinDis = GrindMeaDis;
																 C1GrindMarkCount = k;
															 }
														 }
														 // GrindMark기준 수직 평균값 연마량 측정 
														 if(C1GrindMarkCount!=0 && C1GrindMarkCount>5){
															 CircleCount=0,TotalCirDis=0.0f,GrindWidthDis=0.0f;
															 for(int k=C1GrindMarkCount-5; k<C1GrindMarkCount+5; k++){
																 if(OrgC1CirOutPoint[k].x==0.0f && OrgC1CirOutPoint[k].y==0.0f) continue;
																 if(OrgC1CirInPoint [k].x==0.0f && OrgC1CirInPoint [k].y==0.0f) continue;
																 GrindWidthDis = Math.GetLength(OrgC1CirInPoint[k], OrgC1CirOutPoint[k]);
																 TotalCirDis+=   GrindWidthDis;
																 CircleCount++;
															 }
															 if(TotalCirDis!=0.0f && CircleCount!=0){
																 C1CirGrindWd = TotalCirDis/CircleCount;
															 }
														 }
													 }
												 }
											 }
											 else     { // MarkMode ==> EnCap경우 연마량만 계산한다 
												 if(OrgC1CirInEdgeCount==OrgC1CirOutEdgeCount){
													 double OutDis=0.0f, InDis=0.0f, TotalGrindWidth=0.0f, AvgGrindWidth=0.0f;C1GrindWidthCount=0;
													 for(int k=0; k<OrgC1CirInEdgeCount; k++){
														 if(OrgC1CirOutPoint[k].x==0.0f && OrgC1CirOutPoint[k].y==0.0f){
															 OutDis =0.0f;
														 }
														 else {
															 OutDis = Math.GetLengthFrPointToPoint(C1CirCenter,OrgC1CirOutPoint[k]);
														 }

														 if(OrgC1CirInPoint[k].x==0.0f && OrgC1CirInPoint[k].y==0.0f){
															 InDis =0.0f;
														 }
														 else {
															 InDis = Math.GetLengthFrPointToPoint(C1CirCenter,OrgC1CirInPoint[k]);
														 }

														 // CircleFitting 진행시 실제 EdgePoint 데이터가 존재 할 경우만 포함하여 계산한다
														 if(OutDis!=0.0f && InDis!=0.0f){
															 TotalGrindWidth+=(OutDis - InDis);
															 C1GrindWidthCount++;
														 }
													 }
													 if(C1GrindWidthCount!=0){
														 AvgGrindWidth = (TotalGrindWidth/C1GrindWidthCount);
														 C1CirGrindWd = AvgGrindWidth;
													 }
												 }
											 }
										 }
										 // C1 Grind Mark 기준 가공량 측정 시퀀스 종료  
										 //////////////////////////////////////////////////////////////////////////////////////////////////////

										 // Org Circle데이터중 유호하지 않은 값을 제외한 실제 존재하는 데이터 기준으로 동적 메모리 생성함
										 // Circle Defect검사에 필요한 Edge데이터 값
										 int Count=0;
										 if(OrgC1CirInEdgeCount>0){
											 C1CirInEdgeCount = OrgC1CirInEdgeCount - C1CirInEdgeCount;
											 // 										 C1CirInEdgeCount = OrgC1CirInEdgeCount;
											 if(C1CirInEdgeCount>0){
												 if(C1CirInPoint!=NULL) delete[] C1CirInPoint;
												 C1CirInPoint = new TFPoint[C1CirInEdgeCount];

												 for(int k=0; k<OrgC1CirInEdgeCount; k++){
													 if(k>MAX_CIRCLE_EDGEPOINT) break;
													 if(OrgC1CirInPoint[k].x==0.0f && OrgC1CirInPoint[k].y==0.0f) continue;
													 C1CirInPoint[Count].x = OrgC1CirInPoint[k].x;
													 C1CirInPoint[Count].y = OrgC1CirInPoint[k].y;
													 Count++;
												 }
											 }
											 // Circle 원본 데이터 메모리 삭제
											 if(OrgC1CirInPoint!=NULL) delete[] OrgC1CirInPoint;
										 }
										 // FAVION Circle Fitting 결과물 
										 SampleSize = C1CirInEdgeCount*0.75; //0.5~0.8이하로 입력할것
										 DistDevRatio = 0.15;                //0.1~0.25 이하로 입력할것
										 CircleFit->OnRansac(C1CirInPoint,C1CirInEdgeCount,SampleSize,DistDevRatio,&CircleFit1Center,&CirFitDiameter1);

										 if(OrgC1CirOutEdgeCount>0){
											 C1CirOutEdgeCount = OrgC1CirOutEdgeCount - C1CirOutEdgeCount;
											 C1CirOutEdgeCount = OrgC1CirOutEdgeCount;
											 Count =0;
											 if(C1CirOutEdgeCount>0){
												 if(C1CirOutPoint!=NULL) delete[] C1CirOutPoint;
												 C1CirOutPoint = new TFPoint[C1CirOutEdgeCount];

												 for(int k=0; k<OrgC1CirOutEdgeCount; k++){
													 if(k>MAX_CIRCLE_EDGEPOINT) break;
													 if(OrgC1CirOutPoint[k].x==0.0f && OrgC1CirOutPoint[k].y==0.0f) continue;
													 C1CirOutPoint[Count].x = OrgC1CirOutPoint[k].x;
													 C1CirOutPoint[Count].y = OrgC1CirOutPoint[k].y;
													 Count++;
												 }
											 }
											 // Circle 원본 데이터 메모리 삭제
											 if(OrgC1CirOutPoint!=NULL) delete[] OrgC1CirOutPoint;
										 }
										 if(OrgC1CirStandEdgeCount>0){
											 C1CirStandEdgeCount = OrgC1CirStandEdgeCount - C1CirStandEdgeCount;
											 // 										 C1CirStandEdgeCount = OrgC1CirStandEdgeCount;
											 Count =0;
											 if(C1CirStandEdgeCount>0){
												 if(C1CirStandPoint!=NULL) delete[] C1CirStandPoint;
												 C1CirStandPoint = new TFPoint[C1CirStandEdgeCount];

												 for(int k=0; k<OrgC1CirStandEdgeCount; k++){
													 if(k>MAX_CIRCLE_EDGEPOINT) break;
													 if(OrgC1CirStandPoint[k].x==0.0f && OrgC1CirStandPoint[k].y==0.0f) continue;
													 C1CirStandPoint[Count].x = OrgC1CirStandPoint[k].x;
													 C1CirStandPoint[Count].y = OrgC1CirStandPoint[k].y;
													 Count++;
												 }
											 }
											 // Circle 원본 데이터 메모리 삭제
											 if(OrgC1CirStandPoint!=NULL) delete[] OrgC1CirStandPoint;
										 }
										 LogUnit.SetLog(L"Circle_1_Insp_End");

										 // Circle 영역 꽃박리, 원형박리 검출 목적 시퀀스(EnCap)
										 // 정식 명칭은 몰라서.....일단 Crack으로 정함 
										 if(!IsMarkBtm && BrokenThresHold!=0){
											 RotateBrokenImg.SetSize(RotateImg.GetWidth(), RotateImg.GetHeight());
											 EasyImage::Oper(EArithmeticLogicOperation_Copy,&RotateImg,&RotateBrokenImg);

											 EasyImage::Threshold(&RotateImg,&RotateBrokenImg,BrokenThresHold);                 //박리 검사 목적 이미지 변환
											 //										 RotateBrokenImg.Save("D:\\ROTATE_IMG\\RotateBrokenImg_CUP.bmp");

											 if(CirFitDiameter1!=0.0f && CircleFit1Center.x!=0.0f && CircleFit1Center.y!=0.0f){ // FAVION Circle Fitting 성공시 박리검사 진행 
												 Circle->GImage = &RotateBrokenImg;                                             //Binary Image 넘겨줌 

												 Circle->SetCenterXY(CircleFit1Center.x,CircleFit1Center.y)      ;
												 Circle->SetTolerance((dEdgeToTrapLineDis/2)-CirOffsetMargin)    ; // Circle Tolerance 
												 Circle->SetDiameter ((CirFitDiameter1-(dEdgeToTrapLineDis/2))*2); // Circle Diameter 
												 Circle->SetCircleChoice(0)                                      ; // 0:From Begin, 1:From End, 2:Largest Amplitude 
												 Circle->SetCircleType  (2)                                      ; // 0:Black to White, 1:White to Black 2: Both Black, White 
												 Circle->SetCircleIndex (0)                                      ; // Circle EdgePoint Index 
												 Circle->OnExecute(true)                                         ;
												 CrackCirDiameter1 = (CirFitDiameter1-(dEdgeToTrapLineDis/2))+((dEdgeToTrapLineDis/2)-CirOffsetMargin);

												 C1CirInCrackCount = Circle->FCirclePointCount;

												 if(C1CirInCrackCount>0){
													 if(C1CirInCrackPoint!=NULL) delete[] C1CirInCrackPoint;
													 C1CirInCrackPoint = new TFPoint[C1CirInCrackCount];

													 for(int k=0; k<C1CirInCrackCount; k++){
														 if(k>MAX_CIRCLE_EDGEPOINT) break;
														 C1CirInCrackPoint[k].x = Circle->FCirclePoint[k].x;
														 C1CirInCrackPoint[k].y = Circle->FCirclePoint[k].y;
													 }
												 }
											 }
										 }
									 }

									 // 두번째 Circle EdgePoint Data 추출 
									 if(C2CirCenter.x!=0 && C2CirCenter.y!=0){
										 LogUnit.SetLog(L"Circle_2_Insp_Start");

										 // 									 if(BtmEdgeThresHold==0) Circle->GImage = &RotateImg      ; //Org Image 넘겨줌 
										 // 									 else                    Circle->GImage = &RotateBinaryImg; //Binary Image 넘겨줌 
										 if(CirGrindInThresHold==0) Circle->GImage = &RotateImg             ; //Org Image 넘겨줌 
										 else                       Circle->GImage = &RotateGrindInBinaryImg; //Binary Image 넘겨줌 

										 if      (FInspectMode==Insp_Track) Circle->SetCenterXY(TrackC2CirCenter.x , TrackC2CirCenter.y); // TrackLine 교차점 기준 센터 
										 else if (FInspectMode==Insp_Mark ) Circle->SetCenterXY(C2CirCenter.x      , C2CirCenter.y     ); // 외곽라인 교차점 기준 센터 

										 // Diameter 계산함(OutCircle과 TrackCircle 중간값 기준)
										 // 									 C2Diameter = (CenterCircleHeight*2);
										 C2Diameter = ((CenterCircleHeight*2)+((CenterCircleHeight-OutToTrackLineDis)*2))/2;
										 // 검사 영역으로 인해서 불량 미검출 발생할수 있음....LTPS와 EnCap분류함
										 if(IsMarkBtm) Circle->SetTolerance(60.0f);
										 else          Circle->SetTolerance(80.0f);
										 // 									 Circle->SetTolerance(40.0f )                      ; // Circle Tolerance 
										 Circle->SetDiameter (C2Diameter)                  ; // Circle Diameter 
										 Circle->SetCircleChoice(1)                        ; // 0:From Begin, 1:From End, 2:Largest Amplitude 
										 Circle->SetCircleType  (2)                        ; // 0:Black to White, 1:White to Black 2: Both Black, White 
										 Circle->SetCircleIndex (1)                        ; // Circle EdgePoint Index 

										 if(CenterCirDeg>=0){
											 CenterCirDeg = (CenterCirDeg==0)? 90:CenterCirDeg;
											 // 										 if(90-CenterCirDeg>=0) Circle->SetAngle    (90-CenterCirDeg+CirAngleMargin);   // Circle Fitting 시작점 각도
											 // 										                        Circle->SetAmplitude(CenterCirDeg-2*CirAngleMargin );  // Circle Fitting 시작점 부터 검사 범위 
											 if(90-CenterCirDeg>=0) Circle->SetAngle    (90-CenterCirDeg);   // Circle Fitting 시작점 각도
											 Circle->SetAmplitude(CenterCirDeg   );  // Circle Fitting 시작점 부터 검사 범위 

										 }
										 // 									 Circle->SetCircleType(1)                          ; // 0:Black to White, 1:White to Black 2: Both Black, White 
										 Circle->OnExecute()                               ;

										 // Circle In Data 기준 새로운 Circle Center 좌표 받아옴 
										 RealC2CirCenter.x = Circle->FCP.x   ;
										 RealC2CirCenter.y = Circle->FCP.y   ;
										 CirDiameter2      = (Circle->Diameter)/2.0;

										 // Circle In Data취합 
										 OrgC2CirInEdgeCount = Circle->FCirclePointCount;
										 if(OrgC2CirInEdgeCount>0){
											 if(OrgC2CirInPoint!=NULL) delete[] OrgC2CirInPoint;
											 OrgC2CirInPoint = new TFPoint[OrgC2CirInEdgeCount];

											 for(int k=0; k<OrgC2CirInEdgeCount; k++){
												 if(k>MAX_CIRCLE_EDGEPOINT) break;
												 OrgC2CirInPoint[k].x = Circle->FCirclePoint[k].x;
												 OrgC2CirInPoint[k].y = Circle->FCirclePoint[k].y;
												 if(OrgC2CirInPoint[k].x==0.0f && OrgC2CirInPoint[k].y==0.0f) C2CirInEdgeCount++;
												 // BTM영역 Circle을 제외한 영역 Defect검사 목적에 좌표계산 
												 // 											 if(k==0) {BtmEdgePoint1.x = C1CirInPoint[k].x; BtmEdgePoint1.y = C1CirInPoint[k].y;}
											 }
										 }

										 // Circle Out Data목적 다시 검사  
										 if(BtmEdgeThresHold==0) Circle->GImage = &RotateImg      ; //Org Image 넘겨줌 
										 else                    Circle->GImage = &RotateBinaryImg; //Binary Image 넘겨줌 

										 // 검사 영역으로 인해서 불량 미검출 발생할수 있음....LTPS와 EnCap분류함
										 if(IsMarkBtm) Circle->SetTolerance(60.0f);
										 else          Circle->SetTolerance(80.0f);
										 // 									Circle->SetTolerance(40.0f )                      ; // Circle Tolerance 
										 Circle->SetDiameter (C2Diameter)                  ; // Circle Diameter 
										 Circle->SetCircleChoice(1)                        ; // 0:From Begin, 1:From End, 2:Largest Amplitude 
										 Circle->SetCircleType  (2)                        ; // 0:Black to White, 1:White to Black 2: Both Black, White 
										 Circle->SetCircleIndex (0)                        ; // Circle EdgePoint Index 
										 Circle->OnExecute()                               ;

										 // Circle Out Data취합 
										 OrgC2CirOutEdgeCount = Circle->FCirclePointCount;
										 if(OrgC2CirOutEdgeCount>0){
											 if(OrgC2CirOutPoint!=NULL) delete[] OrgC2CirOutPoint;
											 OrgC2CirOutPoint = new TFPoint[OrgC2CirOutEdgeCount];

											 for(int k=0; k<OrgC2CirOutEdgeCount; k++){
												 if(k>MAX_CIRCLE_EDGEPOINT) break;
												 OrgC2CirOutPoint[k].x = Circle->FCirclePoint[k].x;
												 OrgC2CirOutPoint[k].y = Circle->FCirclePoint[k].y;
												 // BTM영역 Circle을 제외한 영역 Defect검사 목적에 좌표계산 
												 if(k==(OrgC2CirOutEdgeCount-1)) {BtmEdgePoint[1].x = OrgC2CirOutPoint[k].x; BtmEdgePoint[1].y = OrgC2CirOutPoint[k].y;}
												 if(k==0                       ) {BtmEdgePoint[2].x = OrgC2CirOutPoint[k].x; BtmEdgePoint[2].y = OrgC2CirOutPoint[k].y;}
												 if(OrgC2CirOutPoint[k].x==0.0f && OrgC2CirOutPoint[k].y==0.0f) C2CirOutEdgeCount++;
											 }
										 }
										 // C2Circle Grind_Width, Grind_Measure 
										 // C2Circle 연마량 가공량 검사 시퀀스(TrackMode VS MarkMode)
										 if(FInspectMode==Insp_Track){
											 if(OrgC2CirInEdgeCount==OrgC2CirOutEdgeCount){// 연마량 계산(LTPS, EnCap)
												 double OutDis=0.0f, InDis=0.0f, TotalGrindWidth=0.0f, AvgGrindWidth=0.0f;C2GrindWidthCount=0;
												 for(int k=0; k<OrgC2CirInEdgeCount; k++){
													 if(OrgC2CirOutPoint[k].x==0.0f && OrgC2CirOutPoint[k].y==0.0f){
														 OutDis =0.0f;
													 }
													 else {
														 OutDis = Math.GetLengthFrPointToPoint(C2CirCenter,OrgC2CirOutPoint[k]);
													 }

													 if(OrgC2CirInPoint[k].x==0.0f && OrgC2CirInPoint[k].y==0.0f){
														 InDis =0.0f;
													 }
													 else {
														 InDis = Math.GetLengthFrPointToPoint(C2CirCenter,OrgC2CirInPoint[k]);
													 }

													 if(OutDis!=0.0f && InDis!=0.0f){
														 TotalGrindWidth+=(OutDis - InDis);
														 C2GrindWidthCount++;
													 }
												 }
												 if(C2GrindWidthCount!=0){
													 AvgGrindWidth = (TotalGrindWidth/C2GrindWidthCount);
													 C2CirGrindWd = AvgGrindWidth;
												 }
											 }
											 if(IsMarkBtm){ // LTPS일경우만 가공량 계산 
												 if(CirGrindMeaThresHold!=0){
													 Circle->GImage = &RotateGrindBinaryImg; //Binary Image 넘겨줌 
													 Circle->SetCircleChoice(1)                ; // 0:From Begin, 1:From End, 2:Largest Amplitude 
													 Circle->SetCircleType(2)                  ; // 0:Black to White, 1:White to Black 2: Both Black, White 
													 Circle->SetCircleIndex (1)                ; // Circle EdgePoint Index 
													 Circle->SetTolerance(80.0f )              ; // Circle Tolerance 
													 Circle->SetDiameter (C2Diameter)          ; // Circle Diameter 
													 Circle->OnExecute()                       ;

													 // Circle In Data 기준 새로운 Circle Center 좌표 받아옴 
													 RealC2CirCenter.x = Circle->FCP.x;
													 RealC2CirCenter.y = Circle->FCP.y;

													 OrgC2CirStandEdgeCount = Circle->FCirclePointCount;
													 if(OrgC2CirStandEdgeCount>0){
														 if(OrgC2CirStandPoint!=NULL) delete[] OrgC2CirStandPoint;
														 OrgC2CirStandPoint = new TFPoint[OrgC2CirStandEdgeCount];

														 PreC2CirStandPoint[0].x=0.0f; PreC2CirStandPoint[0].y=0.0f;
														 for(int k=0; k<OrgC2CirStandEdgeCount; k++){
															 if(k>MAX_CIRCLE_EDGEPOINT) break;
															 OrgC2CirStandPoint[k].x = Circle->FCirclePoint[k].x;
															 OrgC2CirStandPoint[k].y = Circle->FCirclePoint[k].y;
															 if(OrgC2CirStandPoint[k].x==0.0f && OrgC2CirStandPoint[k].y==0.0f)C2CirStandEdgeCount++;
															 // TrackLine 자재 상태에 따라서 잘못된 EdgePoint를 찾을경우 대비하여 이전데이터 기준 데이터 복원 
															 if(OrgC2CirStandPoint[k].x!=0.0f && OrgC2CirStandPoint[k].y!=0.0f){
																 // 첫번째는 무조건 데이터 넘겨줌 
																 if(PreC2CirStandPoint[0].x==0.0f && PreC2CirStandPoint[0].y==0.0f){
																	 PreC2CirStandPoint[0].x = OrgC2CirStandPoint[k].x; 
																	 PreC2CirStandPoint[0].y = OrgC2CirStandPoint[k].y; 
																 }
																 // 																 else {
																 // 																	 if(fabs (OrgC2CirStandPoint[k].x-PreC2CirStandPoint[0].x)>TrackLineMargin ||
																 // 																		 fabs(OrgC2CirStandPoint[k].y-PreC2CirStandPoint[0].y)>TrackLineMargin   ){
																 // 																			 OrgC2CirStandPoint[k].x = PreC2CirStandPoint[0].x-0.5;
																 // 																			 OrgC2CirStandPoint[k].y = PreC2CirStandPoint[0].y+0.5;
																 // 
																 // 																			 PreC2CirStandPoint[0].x = OrgC2CirStandPoint[k].x; 
																 // 																			 PreC2CirStandPoint[0].y = OrgC2CirStandPoint[k].y; 
																 // 																	 }
																 // 																	 else {
																 // 																		 PreC2CirStandPoint[0].x = OrgC2CirStandPoint[k].x; 
																 // 																		 PreC2CirStandPoint[0].y = OrgC2CirStandPoint[k].y; 
																 // 																	 }
																 // 																 }
															 }
														 }
														 //C1Circle Grind_Measure Calculate 
														 if(OrgC2CirOutEdgeCount==OrgC2CirStandEdgeCount){
															 double GrindMeaDis=0.0f, TotalGrindMeasure=0.0f, AvgGrindMeasure=0.0f;C2GrindMeasureCount=0;
															 for(int k=0; k<OrgC2CirStandEdgeCount; k++){
																 if(OrgC2CirOutPoint[k].x==0.0f || OrgC2CirOutPoint[k].y==0.0f || OrgC2CirStandPoint[k].x==0.0f || OrgC2CirStandPoint[k].y==0.0f){
																	 GrindMeaDis =0.0f;
																 }
																 else {
																	 GrindMeaDis = Math.GetLengthFrPointToPoint(OrgC2CirStandPoint[k],OrgC2CirOutPoint[k]);
																 }

																 if(GrindMeaDis!=0.0f){
																	 TotalGrindMeasure+= GrindMeaDis;
																	 C2GrindMeasureCount++;
																 }
															 }
															 if(C2GrindMeasureCount!=0){
																 AvgGrindMeasure = (TotalGrindMeasure/C2GrindMeasureCount);
																 C2CirGrindMea= AvgGrindMeasure;
															 }
														 }
														 else if(OrgC2CirStandEdgeCount>OrgC2CirOutEdgeCount) { // 연마가 적게되어 실제 TrackLine보다 EdgePoint데이터가 적을경우 
															 double GrindMeaDis=0.0f, TotalGrindMeasure=0.0f, AvgGrindMeasure=0.0f;C2GrindMeasureCount=0;
															 for(int k=0; k<OrgC2CirOutEdgeCount; k++){
																 if(OrgC2CirOutPoint[k].x==0.0f || OrgC2CirOutPoint[k].y==0.0f || OrgC2CirStandPoint[k].x==0.0f || OrgC2CirStandPoint[k].y==0.0f ){
																	 GrindMeaDis =0.0f;
																 }
																 else {
																	 GrindMeaDis = Math.GetLengthFrPointToPoint(OrgC2CirStandPoint[k],OrgC2CirOutPoint[k]);
																 }

																 if(GrindMeaDis!=0.0f){
																	 TotalGrindMeasure+= GrindMeaDis;
																	 C2GrindMeasureCount++;
																 }
															 }
															 if(C2GrindMeasureCount!=0){
																 AvgGrindMeasure = (TotalGrindMeasure/C2GrindMeasureCount);
																 C2CirGrindMea= AvgGrindMeasure;
															 }
														 }
														 else if(OrgC2CirStandEdgeCount<OrgC2CirOutEdgeCount){
															 double GrindMeaDis=0.0f, TotalGrindMeasure=0.0f, AvgGrindMeasure=0.0f;C2GrindMeasureCount=0;
															 for(int k=0; k<OrgC2CirStandEdgeCount; k++){
																 if(OrgC2CirOutPoint[k].x==0.0f || OrgC2CirOutPoint[k].y==0.0f || OrgC2CirStandPoint[k].x==0.0f || OrgC2CirStandPoint[k].y==0.0f ){
																	 GrindMeaDis =0.0f;
																 }
																 else {
																	 GrindMeaDis = Math.GetLengthFrPointToPoint(OrgC2CirStandPoint[k],OrgC2CirOutPoint[k]);
																 }

																 if(GrindMeaDis!=0.0f){
																	 TotalGrindMeasure+= GrindMeaDis;
																	 C2GrindMeasureCount++;
																 }
															 }
															 if(C2GrindMeasureCount!=0){
																 AvgGrindMeasure = (TotalGrindMeasure/C2GrindMeasureCount);
																 C2CirGrindMea= AvgGrindMeasure;
															 }
														 }
													 }
												 }
											 }
										 }
										 else if(FInspectMode==Insp_Mark){ // MarkMode 
											 if(IsMarkBtm){ // LTPS 가공량 계산 ==> 연마량 계산 
												 if(OrgC2CirOutEdgeCount!=0 && OrgC2CirInEdgeCount!=0){ // 연마량이 존재할경우 가공량 검사를 진행함 
													 // 가공량,연마량 측정 전 데이터 존재시 가상GrindMark 생성한다 
													 if(GrindMarkPoint[5].x!=0.0f && GrindMarkPoint[5].y!=0.0f){
														 GrindMarkPoint[6].x     = GrindMarkPoint[5].x + GrindRectSpec[6].DvX;
														 GrindMarkPoint[6].y     = GrindMarkPoint[5].y - GrindRectSpec[6].DvY;
														 GrindMarkRect [6].left  = GrindMarkPoint[6].x    - GrindMarkRange  ;  
														 GrindMarkRect [6].top   = GrindMarkPoint[6].y    - GrindMarkRange  ;  
														 GrindMarkRect [6].right = GrindMarkRect [6].left + GrindMarkLength ;  
														 GrindMarkRect [6].bottom= GrindMarkRect [6].top  + GrindMarkLength ;  
													 }

													 // GrindMarkPoint5 Calc 진행함(연마량,가공량)
													 if(GrindMarkPoint[5].x!=0.0f && GrindMarkPoint[5].y!=0.0f){
														 GrindMeaDis =0.0f, MinDis =10000.0f;C2GrindMarkCount=0;
														 for(int k=0; k<OrgC2CirOutEdgeCount; k++){
															 if(OrgC2CirOutPoint[k].x==0.0f || OrgC2CirOutPoint[k].y==0.0f) continue;
															 if(GrindMarkPoint[5].x  ==0.0f || GrindMarkPoint[5].y  ==0.0f) continue;

															 GrindMeaDis = Math.GetLength(GrindMarkPoint[5], OrgC2CirOutPoint[k]);
															 if(GrindMeaDis<MinDis){
																 MinDis = GrindMeaDis;
																 C2GrindMarkCount = k;
															 }
														 }
														 // GrindMark기준 수직 포인트 주변값 Avg산출한다 
														 if(C2GrindMarkCount!=0 && C2GrindMarkCount>5){
															 CircleCount=0,TotalCirDis=0.0f,GrindMeaDis=0.0f;
															 for(int k=C2GrindMarkCount-5; k<C2GrindMarkCount+5; k++){
																 if(OrgC2CirOutPoint[k].x==0.0f || OrgC2CirOutPoint[k].y==0.0f) continue;

																 GrindMeaDis = Math.GetLength(GrindMarkPoint[5], OrgC2CirOutPoint[k]);
																 TotalCirDis+= GrindMeaDis;
																 CircleCount++;
															 }
															 if(TotalCirDis!=0.0f && CircleCount!=0){
																 C2CirGrindMea = TotalCirDis/CircleCount;
															 }
														 }
														 // GrindMark기준 수직 평균값 연마량 측정 
														 if(C2GrindMarkCount!=0 && C2GrindMarkCount>5){
															 CircleCount=0,TotalCirDis=0.0f,GrindWidthDis=0.0f;
															 for(int k=C2GrindMarkCount-5; k<C2GrindMarkCount+5; k++){
																 if(OrgC2CirOutPoint[k].x==0.0f && OrgC2CirOutPoint[k].y==0.0f) continue;
																 if(OrgC2CirInPoint [k].x==0.0f && OrgC2CirInPoint [k].y==0.0f) continue;
																 GrindWidthDis = Math.GetLength(OrgC2CirInPoint[k], OrgC2CirOutPoint[k]);
																 TotalCirDis+=   GrindWidthDis;
																 CircleCount++;
															 }
															 if(TotalCirDis!=0.0f && CircleCount!=0){
																 C2CirGrindWd = TotalCirDis/CircleCount;
															 }
														 }
													 }
													 else { // Grind Mark 못 찾았을경우 (가공량 0, 연마량 계산함)
														 GrindMeaDis =0.0f, MinDis =10000.0f;C2GrindMarkCount=0;
														 for(int k=0; k<OrgC2CirOutEdgeCount; k++){
															 if(OrgC2CirOutPoint[k].x==0.0f || OrgC2CirOutPoint[k].y==0.0f) continue;

															 GrindMarkRectCenter[5].x = GrindMarkRect[5].left + (GrindMarkRect[5].right  - GrindMarkRect[5].left)/2; 
															 GrindMarkRectCenter[5].y = GrindMarkRect[5].top  + (GrindMarkRect[5].bottom - GrindMarkRect[5].top )/2; 

															 GrindMeaDis = Math.GetLength(GrindMarkRectCenter[5], OrgC2CirOutPoint[k]);
															 if(GrindMeaDis<MinDis){
																 MinDis = GrindMeaDis;
																 C2GrindMarkCount = k;
															 }
														 }
														 // GrindMark기준 수직 평균값 연마량 측정 
														 if(C2GrindMarkCount!=0 && C2GrindMarkCount>5){
															 CircleCount=0,TotalCirDis=0.0f,GrindWidthDis=0.0f;
															 for(int k=C2GrindMarkCount-5; k<C2GrindMarkCount+5; k++){
																 if(OrgC2CirOutPoint[k].x==0.0f && OrgC2CirOutPoint[k].y==0.0f) continue;
																 if(OrgC2CirInPoint [k].x==0.0f && OrgC2CirInPoint [k].y==0.0f) continue;
																 GrindWidthDis = Math.GetLength(OrgC2CirInPoint[k], OrgC2CirOutPoint[k]);
																 TotalCirDis+=   GrindWidthDis;
																 CircleCount++;
															 }
															 if(TotalCirDis!=0.0f && CircleCount!=0){
																 C2CirGrindWd = TotalCirDis/CircleCount;
															 }
														 }
													 }

													 // GrindMarkPoint6 Calc 진행함(연마량,가공량)
													 if(GrindMarkPoint[6].x!=0.0f && GrindMarkPoint[6].y!=0.0f){
														 GrindMeaDis =0.0f, MinDis =10000.0f;C2GrindMarkCount=0;
														 for(int k=0; k<OrgC2CirOutEdgeCount; k++){
															 if(OrgC2CirOutPoint[k].x==0.0f || OrgC2CirOutPoint[k].y==0.0f) continue;
															 if(GrindMarkPoint[6].x  ==0.0f || GrindMarkPoint[6].y  ==0.0f) continue;

															 GrindMeaDis = Math.GetLength(GrindMarkPoint[6], OrgC2CirOutPoint[k]);
															 if(GrindMeaDis<MinDis){
																 MinDis = GrindMeaDis;
																 C2GrindMarkCount = k;
															 }
														 }
														 // GrindMark기준 수직 포인트 주변값 Avg산출한다 
														 if(C2GrindMarkCount!=0 && C2GrindMarkCount>5 && (C2GrindMarkCount+5)<OrgC2CirOutEdgeCount){
															 CircleCount=0,TotalCirDis=0.0f,GrindMeaDis=0.0f;
															 for(int k=C2GrindMarkCount-5; k<C2GrindMarkCount+5; k++){
																 if(OrgC2CirOutPoint[k].x==0.0f || OrgC2CirOutPoint[k].y==0.0f) continue;

																 GrindMeaDis = Math.GetLength(GrindMarkPoint[6], OrgC2CirOutPoint[k]);
																 TotalCirDis+= GrindMeaDis;
																 CircleCount++;
															 }
															 if(TotalCirDis!=0.0f && CircleCount!=0){
																 TrenchLeftGrindMea = TotalCirDis/CircleCount;
															 }
														 }
														 // GrindMark기준 수직 평균값 연마량 측정 
														 if(C2GrindMarkCount!=0 && C2GrindMarkCount>5 && (C2GrindMarkCount+5)<OrgC2CirOutEdgeCount){
															 CircleCount=0,TotalCirDis=0.0f,GrindWidthDis=0.0f;
															 for(int k=C2GrindMarkCount-5; k<C2GrindMarkCount+5; k++){
																 if(OrgC2CirOutPoint[k].x==0.0f && OrgC2CirOutPoint[k].y==0.0f) continue;
																 if(OrgC2CirInPoint [k].x==0.0f && OrgC2CirInPoint [k].y==0.0f) continue;
																 GrindWidthDis = Math.GetLength(OrgC2CirInPoint[k], OrgC2CirOutPoint[k]);
																 TotalCirDis+=   GrindWidthDis;
																 CircleCount++;
															 }
															 if(TotalCirDis!=0.0f && CircleCount!=0){
																 TrenchLeftGrindWd = TotalCirDis/CircleCount;
															 }
														 }
													 }
													 else { // Grind Mark 못 찾았을경우 (가공량 0, 연마량 계산함)
														 GrindMeaDis =0.0f, MinDis =10000.0f;C2GrindMarkCount=0;
														 for(int k=0; k<OrgC2CirOutEdgeCount; k++){
															 if(OrgC2CirOutPoint[k].x==0.0f || OrgC2CirOutPoint[k].y==0.0f) continue;

															 if(k==0){
																 GrindMarkRectCenter[6].x     =  GrindMarkRectCenter[5].x + GrindRectSpec[6].DvX;
																 GrindMarkRectCenter[6].y     =  GrindMarkRectCenter[5].y - GrindRectSpec[6].DvY;

																 GrindMarkRect [6].left  = GrindMarkRectCenter[6].x  - GrindMarkRange  ;  
																 GrindMarkRect [6].top   = GrindMarkRectCenter[6].y  - GrindMarkRange  ;  
																 GrindMarkRect [6].right = GrindMarkRect [6].left + GrindMarkLength ;  
																 GrindMarkRect [6].bottom= GrindMarkRect [6].top  + GrindMarkLength ;  
															 }

															 // 														GrindMarkRectPoint2.x = GrindMarkRect[6].left + (GrindMarkRect[6].right  - GrindMarkRect[6].left)/2; 
															 // 														GrindMarkRectPoint2.y = GrindMarkRect[6].top  + (GrindMarkRect[6].bottom - GrindMarkRect[6].top )/2; 

															 GrindMeaDis = Math.GetLength(GrindMarkRectCenter[6], OrgC2CirOutPoint[k]);
															 if(GrindMeaDis<MinDis){
																 MinDis = GrindMeaDis;
																 C2GrindMarkCount = k;
															 }
														 }
														 // GrindMark기준 수직 평균값 연마량 측정 
														 if(C2GrindMarkCount!=0 && C2GrindMarkCount>5 && (C2GrindMarkCount+5)<OrgC2CirOutEdgeCount){
															 CircleCount=0,TotalCirDis=0.0f,GrindWidthDis=0.0f;
															 for(int k=C2GrindMarkCount-5; k<C2GrindMarkCount+5; k++){
																 if(OrgC2CirOutPoint[k].x==0.0f && OrgC2CirOutPoint[k].y==0.0f) continue;
																 if(OrgC2CirInPoint [k].x==0.0f && OrgC2CirInPoint [k].y==0.0f) continue;
																 GrindWidthDis = Math.GetLength(OrgC2CirInPoint[k], OrgC2CirOutPoint[k]);
																 TotalCirDis+=   GrindWidthDis;
																 CircleCount++;
															 }
															 if(TotalCirDis!=0.0f && CircleCount!=0){
																 TrenchLeftGrindWd = TotalCirDis/CircleCount;
															 }
														 }
													 }
												 }
											 }
											 else         { // EnCap 연마량만 계산 
												 if(OrgC2CirInEdgeCount==OrgC2CirOutEdgeCount){
													 double OutDis=0.0f, InDis=0.0f, TotalGrindWidth=0.0f, AvgGrindWidth=0.0f;C2GrindWidthCount=0;
													 for(int k=0; k<OrgC2CirInEdgeCount; k++){
														 if(OrgC2CirOutPoint[k].x==0.0f && OrgC2CirOutPoint[k].y==0.0f){
															 OutDis =0.0f;
														 }
														 else {
															 OutDis = Math.GetLengthFrPointToPoint(C2CirCenter,OrgC2CirOutPoint[k]);
														 }

														 if(OrgC2CirInPoint[k].x==0.0f && OrgC2CirInPoint[k].y==0.0f){
															 InDis =0.0f;
														 }
														 else {
															 InDis = Math.GetLengthFrPointToPoint(C2CirCenter,OrgC2CirInPoint[k]);
														 }

														 if(OutDis!=0.0f && InDis!=0.0f){
															 TotalGrindWidth+=(OutDis - InDis);
															 C2GrindWidthCount++;
														 }
													 }
													 if(C2GrindWidthCount!=0){
														 AvgGrindWidth = (TotalGrindWidth/C2GrindWidthCount);
														 C2CirGrindWd = AvgGrindWidth;
													 }
												 }
											 }
										 }

										 // Org Circle데이터중 유호하지 않은 값을 제외한 실제 존재하는 데이터 기준으로 동적 메모리 생성함
										 // Circle Defect검사에 필요한 Edge데이터 값
										 int Count=0;
										 if(OrgC2CirInEdgeCount>0){
											 C2CirInEdgeCount = OrgC2CirInEdgeCount - C2CirInEdgeCount;
											 // 										C2CirInEdgeCount = OrgC2CirInEdgeCount;
											 if(C2CirInEdgeCount>0){
												 if(C2CirInPoint!=NULL) delete[] C2CirInPoint;
												 C2CirInPoint = new TFPoint[C2CirInEdgeCount];

												 for(int k=0; k<OrgC2CirInEdgeCount; k++){
													 if(k>MAX_CIRCLE_EDGEPOINT) break;
													 if(OrgC2CirInPoint[k].x==0.0f && OrgC2CirInPoint[k].y==0.0f) continue;
													 C2CirInPoint[Count].x = OrgC2CirInPoint[k].x;
													 C2CirInPoint[Count].y = OrgC2CirInPoint[k].y;
													 Count++;
												 }
											 }
											 // Circle 원본 데이터 메모리 삭제
											 if(OrgC2CirInPoint!=NULL) delete[] OrgC2CirInPoint;
										 }
										 // Circle Fitting 결과물 
										 SampleSize = C2CirInEdgeCount*0.75; //0.5~0.8이하로 입력할것
										 DistDevRatio = 0.15; //0.1~0.25 이하로 입력할것
										 // 									Radius = 0;
										 CircleFit->OnRansac(C2CirInPoint,C2CirInEdgeCount,SampleSize,DistDevRatio,&CircleFit2Center,&CirFitDiameter2);

										 if(OrgC2CirOutEdgeCount>0){
											 C2CirOutEdgeCount = OrgC2CirOutEdgeCount - C2CirOutEdgeCount;
											 Count =0;
											 if(C2CirOutEdgeCount>0){
												 if(C2CirOutPoint!=NULL) delete[] C2CirOutPoint;
												 C2CirOutPoint = new TFPoint[C2CirOutEdgeCount];

												 for(int k=0; k<OrgC2CirOutEdgeCount; k++){
													 if(k>MAX_CIRCLE_EDGEPOINT) break;
													 if(OrgC2CirOutPoint[k].x==0.0f && OrgC2CirOutPoint[k].y==0.0f) continue;
													 C2CirOutPoint[Count].x = OrgC2CirOutPoint[k].x;
													 C2CirOutPoint[Count].y = OrgC2CirOutPoint[k].y;
													 Count++;
												 }
											 }
											 // Circle 원본 데이터 메모리 삭제
											 if(OrgC2CirOutPoint!=NULL) delete[] OrgC2CirOutPoint;
										 }
										 if(OrgC2CirStandEdgeCount>0){
											 C2CirStandEdgeCount = OrgC2CirStandEdgeCount - C2CirStandEdgeCount;
											 // 										C2CirStandEdgeCount = OrgC2CirStandEdgeCount;
											 Count =0;
											 if(C2CirStandEdgeCount>0){
												 if(C2CirStandPoint!=NULL) delete[] C2CirStandPoint;
												 C2CirStandPoint = new TFPoint[C2CirStandEdgeCount];

												 for(int k=0; k<OrgC2CirStandEdgeCount; k++){
													 if(k>MAX_CIRCLE_EDGEPOINT) break;
													 if(OrgC2CirStandPoint[k].x==0.0f && OrgC2CirStandPoint[k].y==0.0f) continue;
													 C2CirStandPoint[Count].x = OrgC2CirStandPoint[k].x;
													 C2CirStandPoint[Count].y = OrgC2CirStandPoint[k].y;
													 Count++;
												 }
											 }
											 // Circle 원본 데이터 메모리 삭제
											 if(OrgC2CirStandPoint!=NULL) delete[] OrgC2CirStandPoint;
										 }
										 LogUnit.SetLog(L"Circle_2_Insp_End");

										 // Circle 영역 꽃박리, 원형박리 검출 목적 시퀀스(EnCap)
										 // 정식 명칭은 몰라서.....일단 Crack으로 정함 
										 if(!IsMarkBtm && BrokenThresHold!=0){
											 if(CirFitDiameter2!=0.0f && CircleFit2Center.x!=0.0f && CircleFit2Center.y!=0.0f){ // FAVION Circle Fitting 성공시 박리검사 진행 
												 Circle->GImage = &RotateBrokenImg;                                             //Binary Image 넘겨줌 

												 Circle->SetCenterXY(CircleFit2Center.x,CircleFit2Center.y);
												 Circle->SetTolerance((dEdgeToTrapLineDis/2)-CirOffsetMargin)    ; // Circle Tolerance 
												 Circle->SetDiameter ((CirFitDiameter2-(dEdgeToTrapLineDis/2))*2); // Circle Diameter 
												 Circle->SetCircleChoice(0)                                      ; // 0:From Begin, 1:From End, 2:Largest Amplitude 
												 Circle->SetCircleType  (2)                                      ; // 0:Black to White, 1:White to Black 2: Both Black, White 
												 Circle->SetCircleIndex (0)                                      ; // Circle EdgePoint Index 
												 Circle->OnExecute(true)                                         ;
												 CrackCirDiameter2 = (CirFitDiameter2-(dEdgeToTrapLineDis/2))+((dEdgeToTrapLineDis/2)-CirOffsetMargin);

												 C2CirInCrackCount = Circle->FCirclePointCount;

												 if(C2CirInCrackCount>0){
													 if(C2CirInCrackPoint!=NULL) delete[] C2CirInCrackPoint;
													 C2CirInCrackPoint = new TFPoint[C2CirInCrackCount];

													 for(int k=0; k<C2CirInCrackCount; k++){
														 if(k>MAX_CIRCLE_EDGEPOINT) break;
														 C2CirInCrackPoint[k].x = Circle->FCirclePoint[k].x;
														 C2CirInCrackPoint[k].y = Circle->FCirclePoint[k].y;
													 }
												 }
											 }
										 }
									 }

									 // 세번째 Circle EdgePoint Data 추출 
									 if(C3CirCenter.x!=0 && C3CirCenter.y!=0){
										 LogUnit.SetLog(L"Circle_3_Insp_Start");

										 if(BtmEdgeThresHold==0) Circle->GImage = &RotateImg      ; //Org Image 넘겨줌 
										 else                    Circle->GImage = &RotateBinaryImg; //Binary Image 넘겨줌 

										 if      (FInspectMode==Insp_Track) Circle->SetCenterXY(TrackC3CirCenter.x , TrackC3CirCenter.y); // TrackLine 교차점 기준 센터 
										 else if (FInspectMode==Insp_Mark ) Circle->SetCenterXY(C3CirCenter.x      , C3CirCenter.y     ); // 외곽라인 교차점 기준 센터 
										 // Diameter 계산함(OutCircle과 TrackCircle 중간값 기준)
										 C3Diameter = ((CenterCircleHeight*2)+((CenterCircleHeight+OutToTrackLineDis)*2))/2;
										 // 									 C3Diameter = (CenterCircleHeight*2);
										 if(IsMarkBtm) Circle->SetTolerance(60.0f);
										 else          Circle->SetTolerance(80.0f);
										 // 									 Circle->SetTolerance(60.0f )              ; // Circle Tolerance 
										 Circle->SetDiameter (C3Diameter)          ; // Circle Diameter 
										 Circle->SetCircleChoice(0)                ; // 0:From Begin, 1:From End, 2:Largest Amplitude 
										 Circle->SetCircleIndex (0)                ; // Circle EdgePoint Index 
										 if(CenterCirDeg>=0){
											 CenterCirDeg = (CenterCirDeg==0)? 90:CenterCirDeg;
											 // 										 if(270-CenterCirDeg>=0) Circle->SetAngle(270-CenterCirDeg+CirAngleMargin);   // Circle Fitting 시작점 각도
											 // 										                         Circle->SetAmplitude(CenterCirDeg-2*CirAngleMargin);  // Circle Fitting 시작점 부터 검사 범위 
											 if(270-CenterCirDeg>=0) Circle->SetAngle(270-CenterCirDeg);   // Circle Fitting 시작점 각도
											 Circle->SetAmplitude(CenterCirDeg);  // Circle Fitting 시작점 부터 검사 범위 
										 }
										 Circle->SetCircleType(1)                          ; // 0:Black to White, 1:White to Black 2: Both Black, White 
										 Circle->OnExecute()                               ;

										 // Circle Out Data취합 
										 OrgC3CirOutEdgeCount = Circle->FCirclePointCount;
										 if(OrgC3CirOutEdgeCount>0){
											 if(OrgC3CirOutPoint!=NULL) delete[] OrgC3CirOutPoint;
											 OrgC3CirOutPoint = new TFPoint[OrgC3CirOutEdgeCount];

											 for(int k=0; k<OrgC3CirOutEdgeCount; k++){
												 if(k>MAX_CIRCLE_EDGEPOINT) break;
												 OrgC3CirOutPoint[k].x = Circle->FCirclePoint[k].x;
												 OrgC3CirOutPoint[k].y = Circle->FCirclePoint[k].y;

												 // BTM영역 Circle을 제외한 영역 Defect검사 목적에 좌표계산
												 // Circle2에서 TrenchWidth 가로길이 기준점을 찾지 못할경우 Circle3에서 새로운 좌표를 넘겨준다 
												 if(k==0 && (BtmEdgePoint[2].x==0 || BtmEdgePoint[2].y==0)){BtmEdgePoint[2].x = OrgC3CirOutPoint[k].x; BtmEdgePoint[2].y = OrgC3CirOutPoint[k].y;}
												 if(k==(OrgC3CirOutEdgeCount-1))                           {BtmEdgePoint[4].x = OrgC3CirOutPoint[k].x; BtmEdgePoint[4].y = OrgC3CirOutPoint[k].y;}
												 if(OrgC3CirOutPoint[k].x==0.0f && OrgC3CirOutPoint[k].y==0.0f) C3CirOutEdgeCount++;
											 }
										 }

										 // Circle In Data목적 다시 검사  
										 // Cell외곽에서 안쪽으로 들어가면서 Circle 찾을경우 오버킬 발생빈도 높음
										 if(CirGrindInThresHold==0) Circle->GImage = &RotateImg             ; //Org Image 넘겨줌 
										 else                       Circle->GImage = &RotateGrindInBinaryImg; //Binary Image 넘겨줌 
										 // 									if(BtmEdgeThresHold==0) Circle->GImage = &RotateImg      ; //Org Image 넘겨줌 
										 // 									else                    Circle->GImage = &RotateBinaryImg; //Binary Image 넘겨줌 

										 if(IsMarkBtm) Circle->SetTolerance(60.0f);
										 else          Circle->SetTolerance(80.0f);
										 // 									Circle->SetTolerance(60.0f )      ; // Circle Tolerance 
										 Circle->SetDiameter (C3Diameter)  ; // Circle Diameter 
										 Circle->SetCircleChoice(0)        ; // 0:From Begin, 1:From End, 2:Largest Amplitude 
										 Circle->SetCircleIndex (0)        ; // Circle EdgePoint Index 
										 Circle->SetCircleType(0)          ; // 0:Black to White, 1:White to Black 2: Both Black, White 
										 Circle->OnExecute()               ;

										 // Circle In Data 기준 새로운 Circle Center 좌표 받아옴 
										 RealC3CirCenter.x = Circle->FCP.x;
										 RealC3CirCenter.y = Circle->FCP.y;
										 CirDiameter3      = (Circle->Diameter)/2.0;

										 // Circle In Data취합 
										 OrgC3CirInEdgeCount = Circle->FCirclePointCount;
										 if(OrgC3CirInEdgeCount>0){
											 if(OrgC3CirInPoint!=NULL) delete[] OrgC3CirInPoint;
											 OrgC3CirInPoint = new TFPoint[OrgC3CirInEdgeCount];

											 for(int k=0; k<OrgC3CirInEdgeCount; k++){
												 if(k>MAX_CIRCLE_EDGEPOINT) break;
												 OrgC3CirInPoint[k].x = Circle->FCirclePoint[k].x;
												 OrgC3CirInPoint[k].y = Circle->FCirclePoint[k].y;
												 if(OrgC3CirInPoint[k].x==0.0f && OrgC3CirInPoint[k].y==0.0f) C3CirInEdgeCount++;
											 }
										 }

										 // C3Circle Grind_Width, Grind_Measure 
										 // C3Circle 연마량 가공량 검사 시퀀스 시작(TrackMode VS MarkMode)
										 if(FInspectMode==Insp_Track){
											 if(OrgC3CirInEdgeCount==OrgC3CirOutEdgeCount){// 연마량 계산
												 double OutDis=0.0f, InDis=0.0f, TotalGrindWidth=0.0f, AvgGrindWidth=0.0f;C3GrindWidthCount=0;
												 for(int k=0; k<OrgC3CirInEdgeCount; k++){
													 if(OrgC3CirOutPoint[k].x==0.0f && OrgC3CirOutPoint[k].y==0.0f){
														 OutDis =0.0f;
													 }
													 else {
														 OutDis = Math.GetLengthFrPointToPoint(C3CirCenter,OrgC3CirOutPoint[k]);
													 }

													 if(OrgC3CirInPoint[k].x==0.0f && OrgC3CirInPoint[k].y==0.0f){
														 InDis =0.0f;
													 }
													 else {
														 InDis = Math.GetLengthFrPointToPoint(C3CirCenter,OrgC3CirInPoint[k]);
													 }

													 if(OutDis!=0.0f && InDis!=0.0f){
														 TotalGrindWidth+=(InDis - OutDis);
														 C3GrindWidthCount++;
													 }
												 }
												 if(C3GrindWidthCount!=0){
													 AvgGrindWidth = (TotalGrindWidth/C3GrindWidthCount);
													 C3CirGrindWd = AvgGrindWidth;
												 }
											 }
											 if(IsMarkBtm){ // LTPS일경우만 가공량 계산 
												 if(CirGrindMeaThresHold!=0){
													 Circle->GImage = &RotateGrindBinaryImg; //Binary Image 넘겨줌 
													 Circle->SetTolerance(80.0f )          ; // Circle Tolerance 
													 Circle->SetDiameter (C3Diameter)      ; // Circle Diameter 
													 Circle->SetCircleType(1)              ; // 0:Black to White, 1:White to Black 2: Both Black, White 
													 Circle->OnExecute()                   ;

													 // Circle In Data 기준 새로운 Circle Center 좌표 받아옴 
													 RealC3CirCenter.x = Circle->FCP.x;
													 RealC3CirCenter.y = Circle->FCP.y;

													 OrgC3CirStandEdgeCount = Circle->FCirclePointCount;
													 if(OrgC3CirStandEdgeCount>0){
														 if(OrgC3CirStandPoint!=NULL) delete[] OrgC3CirStandPoint;
														 OrgC3CirStandPoint = new TFPoint[OrgC3CirStandEdgeCount];

														 PreC3CirStandPoint[0].x=0.0f; PreC3CirStandPoint[0].y=0.0f;
														 for(int k=0; k<OrgC3CirStandEdgeCount; k++){
															 if(k>MAX_CIRCLE_EDGEPOINT) break;
															 OrgC3CirStandPoint[k].x = Circle->FCirclePoint[k].x;
															 OrgC3CirStandPoint[k].y = Circle->FCirclePoint[k].y;
															 if(OrgC3CirStandPoint[k].x==0.0f && OrgC3CirStandPoint[k].y==0.0f)C3CirStandEdgeCount++;
															 // TrackLine 자재 상태에 따라서 잘못된 EdgePoint를 찾을경우 대비하여 이전데이터 기준 데이터 복원 
															 if(OrgC3CirStandPoint[k].x!=0.0f && OrgC3CirStandPoint[k].y!=0.0f){
																 // 첫번째는 무조건 데이터 넘겨줌 
																 if(PreC3CirStandPoint[0].x==0.0f && PreC3CirStandPoint[0].y==0.0f){
																	 PreC3CirStandPoint[0].x = OrgC3CirStandPoint[k].x; 
																	 PreC3CirStandPoint[0].y = OrgC3CirStandPoint[k].y; 
																 }
																 // 																 else {
																 // 																	 if(fabs (OrgC3CirStandPoint[k].x-PreC3CirStandPoint[0].x)>TrackLineMargin ||
																 // 																		 fabs(OrgC3CirStandPoint[k].y-PreC3CirStandPoint[0].y)>TrackLineMargin   ){
																 // 																			 OrgC3CirStandPoint[k].x = PreC3CirStandPoint[0].x+0.5;
																 // 																			 OrgC3CirStandPoint[k].y = PreC3CirStandPoint[0].y-0.5;
																 // 
																 // 																			 PreC3CirStandPoint[0].x = OrgC3CirStandPoint[k].x; 
																 // 																			 PreC3CirStandPoint[0].y = OrgC3CirStandPoint[k].y; 
																 // 																	 }
																 // 																	 else {
																 // 																		 PreC3CirStandPoint[0].x = OrgC3CirStandPoint[k].x; 
																 // 																		 PreC3CirStandPoint[0].y = OrgC3CirStandPoint[k].y; 
																 // 																	 }
																 // 																 }
															 }
														 }
														 //C1Circle Grind_Measure Calculate 
														 if(OrgC3CirOutEdgeCount==OrgC3CirStandEdgeCount){
															 double GrindMeaDis=0.0f, TotalGrindMeasure=0.0f, AvgGrindMeasure=0.0f; C3GrindMeasureCount=0;
															 for(int k=0; k<OrgC3CirInEdgeCount; k++){
																 if(OrgC3CirOutPoint[k].x==0.0f || OrgC3CirOutPoint[k].y==0.0f || OrgC3CirStandPoint[k].x==0.0f || OrgC3CirStandPoint[k].y==0.0f){
																	 GrindMeaDis =0.0f;
																 }
																 else {
																	 GrindMeaDis = Math.GetLengthFrPointToPoint(OrgC3CirStandPoint[k],OrgC3CirOutPoint[k]);
																 }

																 if(GrindMeaDis!=0.0f){
																	 TotalGrindMeasure+= GrindMeaDis;
																	 C3GrindMeasureCount++;
																 }
															 }
															 if(C3GrindMeasureCount!=0){
																 AvgGrindMeasure = (TotalGrindMeasure/C3GrindMeasureCount);
																 C3CirGrindMea= AvgGrindMeasure;
															 }
														 }
														 else if(OrgC3CirStandEdgeCount>OrgC3CirOutEdgeCount) { // 연마가 적게되어 실제 TrackLine보다 EdgePoint데이터가 적을경우 
															 double GrindMeaDis=0.0f, TotalGrindMeasure=0.0f, AvgGrindMeasure=0.0f;C3GrindMeasureCount=0;
															 for(int k=0; k<OrgC3CirOutEdgeCount; k++){
																 if(OrgC3CirOutPoint[k].x==0.0f || OrgC3CirOutPoint[k].y==0.0f || OrgC3CirStandPoint[k].x==0.0f || OrgC3CirStandPoint[k].y==0.0f ){
																	 GrindMeaDis =0.0f;
																 }
																 else {
																	 GrindMeaDis = Math.GetLengthFrPointToPoint(OrgC3CirStandPoint[k],OrgC3CirOutPoint[k]);
																 }

																 if(GrindMeaDis!=0.0f){
																	 TotalGrindMeasure+= GrindMeaDis;
																	 C3GrindMeasureCount++;
																 }
															 }
															 if(C3GrindMeasureCount!=0){
																 AvgGrindMeasure = (TotalGrindMeasure/C3GrindMeasureCount);
																 C3CirGrindMea= AvgGrindMeasure;
															 }
														 }
														 else if(OrgC3CirStandEdgeCount<OrgC3CirOutEdgeCount){
															 double GrindMeaDis=0.0f, TotalGrindMeasure=0.0f, AvgGrindMeasure=0.0f;C3GrindMeasureCount=0;
															 for(int k=0; k<OrgC3CirStandEdgeCount; k++){
																 if(OrgC3CirOutPoint[k].x==0.0f || OrgC3CirOutPoint[k].y==0.0f || OrgC3CirStandPoint[k].x==0.0f || OrgC3CirStandPoint[k].y==0.0f ){
																	 GrindMeaDis =0.0f;
																 }
																 else {
																	 GrindMeaDis = Math.GetLengthFrPointToPoint(OrgC3CirStandPoint[k],OrgC3CirOutPoint[k]);
																 }

																 if(GrindMeaDis!=0.0f){
																	 TotalGrindMeasure+= GrindMeaDis;
																	 C3GrindMeasureCount++;
																 }
															 }
															 if(C3GrindMeasureCount!=0){
																 AvgGrindMeasure = (TotalGrindMeasure/C3GrindMeasureCount);
																 C3CirGrindMea= AvgGrindMeasure;
															 }
														 }
													 }
												 }
											 }
										 }
										 else if(FInspectMode==Insp_Mark){ // MarkMode 시퀀스 
											 if(IsMarkBtm){ // LTPS 가공량계산 ==> 연마량 계산 
												 if(OrgC3CirOutEdgeCount!=0 && OrgC3CirInEdgeCount!=0){ // 연마량이 존재할경우 가공량 검사를 진행함 
													 GrindMeaDis =0.0f, MinDis =10000.0f; C3GrindMarkCount=0;
													 if(GrindMarkPoint[7].x!=0.0f && GrindMarkPoint[7].y!=0.0f){
														 for(int k=0; k<OrgC3CirOutEdgeCount; k++){
															 if(OrgC3CirOutPoint[k].x==0.0f || OrgC3CirOutPoint[k].y==0.0f) continue;
															 if(GrindMarkPoint[7].x  ==0.0f || GrindMarkPoint[7].y  ==0.0f) continue;

															 GrindMeaDis = Math.GetLength(GrindMarkPoint[7], OrgC3CirOutPoint[k]);
															 if(GrindMeaDis<MinDis){
																 MinDis = GrindMeaDis;
																 C3GrindMarkCount = k;
															 }
														 }
														 // GrindMark기준 수직 포인트 주변값 Avg산출한다 
														 if(C3GrindMarkCount!=0 && C3GrindMarkCount>5){
															 CircleCount=0,TotalCirDis=0.0f,GrindMeaDis=0.0f;
															 for(int k=C3GrindMarkCount-5; k<C3GrindMarkCount+5; k++){
																 if(OrgC3CirOutPoint[k].x==0.0f || OrgC3CirOutPoint[k].y==0.0f) continue;

																 GrindMeaDis = Math.GetLength(GrindMarkPoint[7], OrgC3CirOutPoint[k]);
																 TotalCirDis+= GrindMeaDis;
																 CircleCount++;
															 }
															 if(TotalCirDis!=0.0f && CircleCount!=0){
																 C3CirGrindMea = TotalCirDis/CircleCount;
															 }
														 }
														 // GrindMark기준 수직 평균값 연마량 측정 
														 if(C3GrindMarkCount!=0 && C3GrindMarkCount>5){
															 CircleCount=0,TotalCirDis=0.0f,GrindWidthDis=0.0f;
															 for(int k=C3GrindMarkCount-5; k<C3GrindMarkCount+5; k++){
																 if(OrgC3CirInPoint [k].x==0.0f && OrgC3CirInPoint [k].y==0.0f) continue;
																 GrindWidthDis = Math.GetLength(OrgC3CirInPoint[k], OrgC3CirOutPoint[k]);
																 TotalCirDis+=   GrindWidthDis;
																 CircleCount++;
															 }
															 if(TotalCirDis!=0.0f && CircleCount!=0){
																 C3CirGrindWd = TotalCirDis/CircleCount;
															 }
														 }
													 }
													 else { // Grind Mark 못 찾았을경우 (가공량 0, 연마량 계산함)
														 for(int k=0; k<OrgC3CirOutEdgeCount; k++){
															 if(OrgC3CirOutPoint[k].x==0.0f || OrgC3CirOutPoint[k].y==0.0f) continue;

															 GrindMarkRectCenter[7].x = GrindMarkRect[7].left + (GrindMarkRect[7].right  - GrindMarkRect[7].left)/2; 
															 GrindMarkRectCenter[7].y = GrindMarkRect[7].top  + (GrindMarkRect[7].bottom - GrindMarkRect[7].top )/2; 

															 GrindMeaDis = Math.GetLength(GrindMarkRectCenter[7], OrgC3CirOutPoint[k]);
															 if(GrindMeaDis<MinDis){
																 MinDis = GrindMeaDis;
																 C3GrindMarkCount = k;
															 }
														 }
														 // GrindMark기준 수직 평균값 연마량 측정 
														 if(C3GrindMarkCount!=0 && C3GrindMarkCount>5){
															 CircleCount=0,TotalCirDis=0.0f,GrindWidthDis=0.0f;
															 for(int k=C3GrindMarkCount-5; k<C3GrindMarkCount+5; k++){
																 if(OrgC3CirOutPoint[k].x==0.0f && OrgC3CirOutPoint[k].y==0.0f) continue;
																 if(OrgC3CirInPoint [k].x==0.0f && OrgC3CirInPoint [k].y==0.0f) continue;
																 GrindWidthDis = Math.GetLength(OrgC3CirInPoint[k], OrgC3CirOutPoint[k]);
																 TotalCirDis+=   GrindWidthDis;
																 CircleCount++;
															 }
															 if(TotalCirDis!=0.0f && CircleCount!=0){
																 C3CirGrindWd = TotalCirDis/CircleCount;
															 }
														 }
													 }
												 }
											 }
											 else         { // EnCAP 연마량만 계산 
												 if(OrgC3CirInEdgeCount==OrgC3CirOutEdgeCount){
													 double OutDis=0.0f, InDis=0.0f, TotalGrindWidth=0.0f, AvgGrindWidth=0.0f;C3GrindWidthCount=0;
													 for(int k=0; k<OrgC3CirInEdgeCount; k++){
														 if(OrgC3CirOutPoint[k].x==0.0f && OrgC3CirOutPoint[k].y==0.0f){
															 OutDis =0.0f;
														 }
														 else {
															 OutDis = Math.GetLengthFrPointToPoint(C3CirCenter,OrgC3CirOutPoint[k]);
														 }

														 if(OrgC3CirInPoint[k].x==0.0f && OrgC3CirInPoint[k].y==0.0f){
															 InDis =0.0f;
														 }
														 else {
															 InDis = Math.GetLengthFrPointToPoint(C3CirCenter,OrgC3CirInPoint[k]);
														 }

														 if(OutDis!=0.0f && InDis!=0.0f){
															 TotalGrindWidth+=(InDis - OutDis);
															 C3GrindWidthCount++;
														 }
													 }
													 if(C3GrindWidthCount!=0){
														 AvgGrindWidth = (TotalGrindWidth/C3GrindWidthCount);
														 C3CirGrindWd = AvgGrindWidth;
													 }
												 }
											 }
										 }
										 // C3Circle 연마량 가공량 검사 시퀀스 종료(TrackMode VS MarkMode)
										 //////////////////////////////////////////////////////////////////////////////////////////////////////


										 // Org Circle데이터중 유호하지 않은 값을 제외한 실제 존재하는 데이터 기준으로 동적 메모리 생성함
										 // Circle Defect검사에 필요한 Edge데이터 값
										 int Count=0;
										 if(OrgC3CirInEdgeCount>0){
											 C3CirInEdgeCount = OrgC3CirInEdgeCount - C3CirInEdgeCount;
											 // 										C3CirInEdgeCount = OrgC3CirInEdgeCount;
											 if(C3CirInEdgeCount>0){
												 if(C3CirInPoint!=NULL) delete[] C3CirInPoint;
												 C3CirInPoint = new TFPoint[C3CirInEdgeCount];

												 for(int k=0; k<OrgC3CirInEdgeCount; k++){
													 if(k>MAX_CIRCLE_EDGEPOINT) break;
													 if(OrgC3CirInPoint[k].x==0.0f && OrgC3CirInPoint[k].y==0.0f) continue;
													 C3CirInPoint[Count].x = OrgC3CirInPoint[k].x;
													 C3CirInPoint[Count].y = OrgC3CirInPoint[k].y;
													 Count++;
												 }
											 }
											 // Circle 원본 데이터 메모리 삭제
											 if(OrgC3CirInPoint!=NULL) delete[] OrgC3CirInPoint;
										 }
										 // Circle Fitting 결과물 
										 SampleSize = C3CirInEdgeCount*0.75; //0.5~0.8이하로 입력할것
										 DistDevRatio = 0.15; //0.1~0.25 이하로 입력할것
										 // 									Radius = 0;
										 CircleFit->OnRansac(C3CirInPoint,C3CirInEdgeCount,SampleSize,DistDevRatio,&CircleFit3Center,&CirFitDiameter3);

										 if(OrgC3CirOutEdgeCount>0){
											 C3CirOutEdgeCount = OrgC3CirOutEdgeCount - C3CirOutEdgeCount;
											 Count =0;
											 if(C3CirOutEdgeCount>0){
												 if(C3CirOutPoint!=NULL) delete[] C3CirOutPoint;
												 C3CirOutPoint = new TFPoint[C3CirOutEdgeCount];

												 for(int k=0; k<OrgC3CirOutEdgeCount; k++){
													 if(k>MAX_CIRCLE_EDGEPOINT) break;
													 if(OrgC3CirOutPoint[k].x==0.0f && OrgC3CirOutPoint[k].y==0.0f) continue;
													 C3CirOutPoint[Count].x = OrgC3CirOutPoint[k].x;
													 C3CirOutPoint[Count].y = OrgC3CirOutPoint[k].y;
													 Count++;
												 }
											 }
											 // Circle 원본 데이터 메모리 삭제
											 if(OrgC3CirOutPoint!=NULL) delete[] OrgC3CirOutPoint;
										 }
										 if(OrgC3CirStandEdgeCount>0){
											 C3CirStandEdgeCount = OrgC3CirStandEdgeCount - C3CirStandEdgeCount;
											 // 										C3CirStandEdgeCount = OrgC3CirStandEdgeCount;
											 Count =0;
											 if(C3CirStandEdgeCount>0){
												 if(C3CirStandPoint!=NULL) delete[] C3CirStandPoint;
												 C3CirStandPoint = new TFPoint[C3CirStandEdgeCount];

												 for(int k=0; k<OrgC3CirStandEdgeCount; k++){
													 if(k>MAX_CIRCLE_EDGEPOINT) break;
													 if(OrgC3CirStandPoint[k].x==0.0f && OrgC3CirStandPoint[k].y==0.0f) continue;
													 C3CirStandPoint[Count].x = OrgC3CirStandPoint[k].x;
													 C3CirStandPoint[Count].y = OrgC3CirStandPoint[k].y;
													 Count++;
												 }
											 }
											 // Circle 원본 데이터 메모리 삭제
											 if(OrgC3CirStandPoint!=NULL) delete[] OrgC3CirStandPoint;
										 }
										 LogUnit.SetLog(L"Circle_3_Insp_End");
										 // Circle 영역 꽃박리, 원형박리 검출 목적 시퀀스(EnCap)
										 // 정식 명칭은 몰라서.....일단 Crack으로 정함 
										 if(!IsMarkBtm && BrokenThresHold!=0){
											 if(CirFitDiameter3!=0.0f && CircleFit3Center.x!=0.0f && CircleFit3Center.y!=0.0f){ // FAVION Circle Fitting 성공시 박리검사 진행 
												 Circle->GImage = &RotateBrokenImg;                                             //Binary Image 넘겨줌 

												 Circle->SetCenterXY(CircleFit3Center.x,CircleFit3Center.y)      ;
												 Circle->SetTolerance((dEdgeToTrapLineDis/2)-CirOffsetMargin)    ; // Circle Tolerance 
												 Circle->SetDiameter ((CirFitDiameter3+(dEdgeToTrapLineDis/2))*2); // Circle Diameter 
												 Circle->SetCircleChoice(0)                                      ; // 0:From Begin, 1:From End, 2:Largest Amplitude 
												 Circle->SetCircleType  (2)                                      ; // 0:Black to White, 1:White to Black 2: Both Black, White 
												 Circle->SetCircleIndex (0)                                      ; // Circle EdgePoint Index 
												 Circle->OnExecute(true)							                ;
												 CrackCirDiameter3 = (CirFitDiameter3+(dEdgeToTrapLineDis/2)) - (dEdgeToTrapLineDis/2)-CirOffsetMargin;

												 C3CirInCrackCount = Circle->FCirclePointCount;

												 if(C3CirInCrackCount>0){
													 if(C3CirInCrackPoint!=NULL) delete[] C3CirInCrackPoint;
													 C3CirInCrackPoint = new TFPoint[C3CirInCrackCount];

													 for(int k=0; k<C3CirInCrackCount; k++){
														 if(k>MAX_CIRCLE_EDGEPOINT) break;
														 C3CirInCrackPoint[k].x = Circle->FCirclePoint[k].x;
														 C3CirInCrackPoint[k].y = Circle->FCirclePoint[k].y;
													 }
												 }
											 }
										 }
									 }

									 // 네번째 Circle EdgePoint Data 추출 
									 if(C4CirCenter.x!=0 && C4CirCenter.y!=0){
										 LogUnit.SetLog(L"Circle_4_Insp_Start");

										 if(BtmEdgeThresHold==0) Circle->GImage = &RotateImg      ; //Org Image 넘겨줌 
										 else                    Circle->GImage = &RotateBinaryImg; //Binary Image 넘겨줌 

										 if      (FInspectMode==Insp_Track) Circle->SetCenterXY(TrackC4CirCenter.x , TrackC4CirCenter.y); // TrackLine 교차점 기준 센터 
										 else if (FInspectMode==Insp_Mark ) Circle->SetCenterXY(C4CirCenter.x      , C4CirCenter.y     ); // 외곽라인 교차점 기준 센터 
										 // Diameter 계산함(OutCircle과 TrackCircle 중간값 기준)
										 C4Diameter = ((CenterCircleHeight*2)+((CenterCircleHeight+OutToTrackLineDis)*2))/2;
										 // 									 C4Diameter = (CenterCircleHeight*2);
										 if(IsMarkBtm) Circle->SetTolerance(60.0f);
										 else          Circle->SetTolerance(80.0f);
										 // 									 Circle->SetTolerance(60.0f )              ; // Circle Tolerance 
										 Circle->SetDiameter (C4Diameter)          ; // Circle Diameter 
										 Circle->SetCircleChoice(0)                ; // 0:From Begin, 1:From End, 2:Largest Amplitude 
										 Circle->SetCircleIndex (0)                ; // Circle EdgePoint Index 
										 if(CenterCirDeg>=0){
											 CenterCirDeg = (CenterCirDeg==0)? 90:CenterCirDeg;
											 // 										 Circle->SetAngle(270+CirAngleMargin               );               // Circle Fitting 시작점 각도
											 // 										 Circle->SetAmplitude(CenterCirDeg-2*CirAngleMargin);  // Circle Fitting 시작점 부터 검사 범위 
											 Circle->SetAngle(270             );               // Circle Fitting 시작점 각도
											 Circle->SetAmplitude(CenterCirDeg);  // Circle Fitting 시작점 부터 검사 범위 
										 }

										 Circle->SetCircleType(1)                          ; // 0:Black to White, 1:White to Black 2: Both Black, White 
										 Circle->OnExecute()                               ;

										 // Circle Out Data취합 
										 OrgC4CirOutEdgeCount = Circle->FCirclePointCount;
										 if(OrgC4CirOutEdgeCount>0){
											 if(OrgC4CirOutPoint!=NULL) delete[] OrgC4CirOutPoint;
											 OrgC4CirOutPoint = new TFPoint[OrgC4CirOutEdgeCount];

											 for(int k=0; k<OrgC4CirOutEdgeCount; k++){
												 if(k>MAX_CIRCLE_EDGEPOINT) break;
												 OrgC4CirOutPoint[k].x = Circle->FCirclePoint[k].x;
												 OrgC4CirOutPoint[k].y = Circle->FCirclePoint[k].y;
												 // BTM영역 Circle을 제외한 영역 Defect검사 목적에 좌표계산 
												 if(k==0)                        {BtmEdgePoint[5].x = OrgC4CirOutPoint[k].x; BtmEdgePoint[5].y = OrgC4CirOutPoint[k].y;}
												 if(k==(OrgC4CirOutEdgeCount-1)) {BtmEdgePoint[7].x = OrgC4CirOutPoint[k].x; BtmEdgePoint[7].y = OrgC4CirOutPoint[k].y;}

												 if(OrgC4CirOutPoint[k].x==0.0f && OrgC4CirOutPoint[k].y==0.0f) C4CirOutEdgeCount++;
											 }
										 }

										 // Circle Out Data목적 다시 검사  
										 if(CirGrindInThresHold==0) Circle->GImage = &RotateImg             ; //Org Image 넘겨줌 
										 else                       Circle->GImage = &RotateGrindInBinaryImg; //Binary Image 넘겨줌 
										 // 									 if(BtmEdgeThresHold==0) Circle->GImage = &RotateImg      ; //Org Image 넘겨줌 
										 // 									 else                    Circle->GImage = &RotateBinaryImg; //Binary Image 넘겨줌 

										 if(IsMarkBtm) Circle->SetTolerance(60.0f);
										 else          Circle->SetTolerance(80.0f);
										 // 									 Circle->SetTolerance(60.0f )      ; // Circle Tolerance 
										 Circle->SetDiameter (C4Diameter)  ; // Circle Diameter 
										 Circle->SetCircleChoice(0)        ; // 0:From Begin, 1:From End, 2:Largest Amplitude 
										 Circle->SetCircleIndex (0)        ; // Circle EdgePoint Index 
										 Circle->SetCircleType(0)          ; // 0:Black to White, 1:White to Black 2: Both Black, White 
										 Circle->OnExecute()               ;

										 // Circle In Data 기준 새로운 Circle Center 좌표 받아옴 
										 RealC4CirCenter.x = Circle->FCP.x;
										 RealC4CirCenter.y = Circle->FCP.y;
										 CirDiameter4      = (Circle->Diameter)/2.0;

										 // Circle In Data취합 
										 OrgC4CirInEdgeCount = Circle->FCirclePointCount;
										 if(OrgC4CirInEdgeCount>0){
											 if(OrgC4CirInPoint!=NULL) delete[] OrgC4CirInPoint;
											 OrgC4CirInPoint = new TFPoint[OrgC4CirInEdgeCount];

											 for(int k=0; k<OrgC4CirInEdgeCount; k++){
												 if(k>MAX_CIRCLE_EDGEPOINT) break;
												 OrgC4CirInPoint[k].x = Circle->FCirclePoint[k].x;
												 OrgC4CirInPoint[k].y = Circle->FCirclePoint[k].y;
												 if(OrgC4CirInPoint[k].x==0.0f && OrgC4CirInPoint[k].y==0.0f)C4CirInEdgeCount++;
												 // BTM영역 Circle을 제외한 영역 Defect검사 목적에 좌표계산 
												 // 											 if(k==0) {BtmEdgePoint1.x = C1CirInPoint[k].x; BtmEdgePoint1.y = C1CirInPoint[k].y;}
											 }
										 }

										 // C4Circle Grind_Width, Grind_Measure 
										 // C4Circle 연마량 가공량 검사 시퀀스 시작(TrackMode VS MarkMode)
										 if(FInspectMode==Insp_Track){ // TrackMode 
											 if(OrgC4CirInEdgeCount==OrgC4CirOutEdgeCount){// 가공량 계산
												 double OutDis=0.0f, InDis=0.0f, TotalGrindWidth=0.0f, AvgGrindWidth=0.0f;C4GrindWidthCount=0;
												 for(int k=0; k<OrgC4CirInEdgeCount; k++){
													 if(OrgC4CirOutPoint[k].x==0.0f && OrgC4CirOutPoint[k].y==0.0f){
														 OutDis =0.0f;
													 }
													 else {
														 OutDis = Math.GetLengthFrPointToPoint(C4CirCenter,OrgC4CirOutPoint[k]);
													 }

													 if(OrgC4CirInPoint[k].x==0.0f && OrgC4CirInPoint[k].y==0.0f){
														 InDis =0.0f;
													 }
													 else {
														 InDis = Math.GetLengthFrPointToPoint(C4CirCenter,OrgC4CirInPoint[k]);
													 }

													 if(OutDis!=0.0f && InDis!=0.0f){
														 TotalGrindWidth+=(InDis - OutDis);
														 C4GrindWidthCount++;
													 }
												 }
												 if(C4GrindWidthCount!=0){
													 AvgGrindWidth = (TotalGrindWidth/C4GrindWidthCount);
													 C4CirGrindWd = AvgGrindWidth;
												 }
											 }
											 if(IsMarkBtm){ // LTPS일경만 가공량 계산 
												 if(CirGrindMeaThresHold!=0){
													 Circle->GImage = &RotateGrindBinaryImg; //Binary Image 넘겨줌 
													 Circle->SetTolerance(80.0f )          ; // Circle Tolerance 
													 Circle->SetDiameter (C4Diameter)      ; // Circle Diameter 
													 Circle->SetCircleType(1)              ; // 0:Black to White, 1:White to Black 2: Both Black, White 
													 Circle->OnExecute()                   ;

													 // Circle In Data 기준 새로운 Circle Center 좌표 받아옴 
													 RealC4CirCenter.x = Circle->FCP.x;
													 RealC4CirCenter.y = Circle->FCP.y;

													 OrgC4CirStandEdgeCount = Circle->FCirclePointCount;
													 if(OrgC4CirStandEdgeCount>0){
														 if(OrgC4CirStandPoint!=NULL) delete[] OrgC4CirStandPoint;
														 OrgC4CirStandPoint = new TFPoint[OrgC4CirStandEdgeCount];

														 PreC4CirStandPoint[0].x=0.0f;PreC4CirStandPoint[0].y=0.0f;
														 for(int k=0; k<OrgC4CirStandEdgeCount; k++){
															 if(k>MAX_CIRCLE_EDGEPOINT) break;
															 OrgC4CirStandPoint[k].x = Circle->FCirclePoint[k].x;
															 OrgC4CirStandPoint[k].y = Circle->FCirclePoint[k].y;
															 if(OrgC4CirStandPoint[k].x==0.0f && OrgC4CirStandPoint[k].y==0.0f) C4CirStandEdgeCount++;
															 // TrackLine 자재 상태에 따라서 잘못된 EdgePoint를 찾을경우 대비하여 이전데이터 기준 데이터 복원 
															 if(OrgC4CirStandPoint[k].x!=0.0f && OrgC4CirStandPoint[k].y!=0.0f){
																 // 첫번째는 무조건 데이터 넘겨줌 
																 if(PreC4CirStandPoint[0].x==0.0f && PreC4CirStandPoint[0].y==0.0f){
																	 PreC4CirStandPoint[0].x = OrgC4CirStandPoint[k].x; 
																	 PreC4CirStandPoint[0].y = OrgC4CirStandPoint[k].y; 
																 }
																 // 																 else {
																 // 																	 if(fabs (OrgC4CirStandPoint[k].x-PreC4CirStandPoint[0].x)>TrackLineMargin ||
																 // 																		 fabs(OrgC4CirStandPoint[k].y-PreC4CirStandPoint[0].y)>TrackLineMargin   ){
																 // 																			 OrgC4CirStandPoint[k].x = PreC4CirStandPoint[0].x+0.5;
																 // 																			 OrgC4CirStandPoint[k].y = PreC4CirStandPoint[0].y+0.5;
																 // 
																 // 																			 PreC4CirStandPoint[0].x = OrgC4CirStandPoint[k].x; 
																 // 																			 PreC4CirStandPoint[0].y = OrgC4CirStandPoint[k].y; 
																 // 																	 }
																 // 																	 else {
																 // 																		 PreC4CirStandPoint[0].x = OrgC4CirStandPoint[k].x; 
																 // 																		 PreC4CirStandPoint[0].y = OrgC4CirStandPoint[k].y; 
																 // 																	 }
																 // 																 }
															 }
														 }
														 //C4Circle Grind_Measure Calculate 
														 if(OrgC4CirOutEdgeCount==OrgC4CirStandEdgeCount){
															 double GrindMeaDis=0.0f, TotalGrindMeasure=0.0f, AvgGrindMeasure=0.0f;C4GrindMeasureCount=0;
															 for(int k=0; k<OrgC4CirStandEdgeCount; k++){
																 if(OrgC4CirOutPoint[k].x==0.0f || OrgC4CirOutPoint[k].y==0.0f || OrgC4CirStandPoint[k].x==0.0f || OrgC4CirStandPoint[k].y==0.0f){
																	 GrindMeaDis =0.0f;
																 }
																 else {
																	 GrindMeaDis = Math.GetLengthFrPointToPoint(OrgC4CirStandPoint[k],OrgC4CirOutPoint[k]);
																 }

																 if(GrindMeaDis!=0.0f){
																	 TotalGrindMeasure+= GrindMeaDis;
																	 C4GrindMeasureCount++;
																 }
															 }
															 if(C4GrindMeasureCount!=0){
																 AvgGrindMeasure = (TotalGrindMeasure/C4GrindMeasureCount);
																 C4CirGrindMea= AvgGrindMeasure;
															 }
														 }
														 else if(OrgC4CirStandEdgeCount>OrgC4CirOutEdgeCount){ // 연마가 적게되어 실제 TrackLine보다 EdgePoint데이터가 적을경우 
															 double GrindMeaDis=0.0f, TotalGrindMeasure=0.0f, AvgGrindMeasure=0.0f;C4GrindMeasureCount=0;
															 for(int k=0; k<OrgC4CirOutEdgeCount; k++){
																 if(OrgC4CirOutPoint[k].x==0.0f || OrgC4CirOutPoint[k].y==0.0f || OrgC4CirStandPoint[k].x==0.0f || OrgC4CirStandPoint[k].y==0.0f ){
																	 GrindMeaDis =0.0f;
																 }
																 else {
																	 GrindMeaDis = Math.GetLengthFrPointToPoint(OrgC4CirStandPoint[k],OrgC4CirOutPoint[k]);
																 }

																 if(GrindMeaDis!=0.0f){
																	 TotalGrindMeasure+= GrindMeaDis;
																	 C4GrindMeasureCount++;
																 }
															 }
															 if(C4GrindMeasureCount!=0){
																 AvgGrindMeasure = (TotalGrindMeasure/C4GrindMeasureCount);
																 C4CirGrindMea= AvgGrindMeasure;
															 }
														 }
														 else if(OrgC4CirStandEdgeCount<OrgC4CirOutEdgeCount){
															 double GrindMeaDis=0.0f, TotalGrindMeasure=0.0f, AvgGrindMeasure=0.0f;C4GrindMeasureCount=0;
															 for(int k=0; k<OrgC4CirStandEdgeCount; k++){
																 if(OrgC4CirOutPoint[k].x==0.0f || OrgC4CirOutPoint[k].y==0.0f || OrgC4CirStandPoint[k].x==0.0f || OrgC4CirStandPoint[k].y==0.0f ){
																	 GrindMeaDis =0.0f;
																 }
																 else {
																	 GrindMeaDis = Math.GetLengthFrPointToPoint(OrgC4CirStandPoint[k],OrgC4CirOutPoint[k]);
																 }

																 if(GrindMeaDis!=0.0f){
																	 TotalGrindMeasure+= GrindMeaDis;
																	 C4GrindMeasureCount++;
																 }
															 }
															 if(C4GrindMeasureCount!=0){
																 AvgGrindMeasure = (TotalGrindMeasure/C4GrindMeasureCount);
																 C4CirGrindMea= AvgGrindMeasure;
															 }
														 }
													 }
												 }
											 }
										 }
										 else if(FInspectMode==Insp_Mark){ // MarkMode 
											 if(IsMarkBtm){ //LTPS 가공량 계산 ==> 연마량 계산 
												 if(OrgC4CirOutEdgeCount!=0 && OrgC4CirInEdgeCount!=0){// 연마량이 존재할경우 가공량 검사를 진행함 
													 GrindMeaDis =0.0f, MinDis =10000.0f;C4GrindMarkCount=0;
													 if(GrindMarkPoint[11].x!=0.0f && GrindMarkPoint[11].y!=0.0f){
														 for(int k=0; k<OrgC4CirOutEdgeCount; k++){
															 if(OrgC4CirOutPoint[k].x==0.0f || OrgC4CirOutPoint[k].y==0.0f) continue;
															 if(GrindMarkPoint[11].x  ==0.0f || GrindMarkPoint[11].y  ==0.0f) continue;

															 GrindMeaDis = Math.GetLength(GrindMarkPoint[11], OrgC4CirOutPoint[k]);
															 if(GrindMeaDis<MinDis){
																 MinDis = GrindMeaDis;
																 C4GrindMarkCount = k;
															 }
														 }
														 // GrindMark기준 수직 포인트 주변값 Avg산출한다 
														 if(C4GrindMarkCount!=0 && C4GrindMarkCount>5){
															 CircleCount=0,TotalCirDis=0.0f,GrindMeaDis=0.0f;
															 for(int k=C4GrindMarkCount-5; k<C4GrindMarkCount+5; k++){
																 if(OrgC4CirOutPoint[k].x==0.0f || OrgC4CirOutPoint[k].y==0.0f) continue;

																 GrindMeaDis = Math.GetLength(GrindMarkPoint[11], OrgC4CirOutPoint[k]);
																 TotalCirDis+= GrindMeaDis;
																 CircleCount++;
															 }
															 if(TotalCirDis!=0.0f && CircleCount!=0){
																 C4CirGrindMea = TotalCirDis/CircleCount;
															 }
														 }
														 // GrindMark기준 수직 평균값 연마량 측정 
														 if(C4GrindMarkCount!=0 && C4GrindMarkCount>5){
															 CircleCount=0,TotalCirDis=0.0f,GrindWidthDis=0.0f;
															 for(int k=C4GrindMarkCount-5; k<C4GrindMarkCount+5; k++){
																 if(OrgC4CirOutPoint[k].x==0.0f && OrgC4CirOutPoint[k].y==0.0f) continue;
																 if(OrgC4CirInPoint [k].x==0.0f && OrgC4CirInPoint [k].y==0.0f) continue;
																 GrindWidthDis = Math.GetLength(OrgC4CirInPoint[k], OrgC4CirOutPoint[k]);
																 TotalCirDis+=   GrindWidthDis;
																 CircleCount++;
															 }
															 if(TotalCirDis!=0.0f && CircleCount!=0){
																 C4CirGrindWd = TotalCirDis/CircleCount;
															 }
														 }
													 }
													 else { // Grind Mark 못 찾았을경우 (가공량 0, 연마량 계산함)
														 for(int k=0; k<OrgC4CirOutEdgeCount; k++){
															 if(OrgC4CirOutPoint[k].x==0.0f || OrgC4CirOutPoint[k].y==0.0f) continue;

															 GrindMarkRectCenter[11].x = GrindMarkRect[11].left + (GrindMarkRect[11].right  - GrindMarkRect[11].left)/2; 
															 GrindMarkRectCenter[11].y = GrindMarkRect[11].top  + (GrindMarkRect[11].bottom - GrindMarkRect[11].top )/2; 

															 GrindMeaDis = Math.GetLength(GrindMarkRectCenter[11], OrgC4CirOutPoint[k]);
															 if(GrindMeaDis<MinDis){
																 MinDis = GrindMeaDis;
																 C4GrindMarkCount = k;
															 }
														 }
														 // GrindMark기준 수직 평균값 연마량 측정 
														 if(C4GrindMarkCount!=0 && C4GrindMarkCount>5){
															 CircleCount=0,TotalCirDis=0.0f,GrindWidthDis=0.0f;
															 for(int k=C4GrindMarkCount-5; k<C4GrindMarkCount+5; k++){
																 if(OrgC4CirOutPoint[k].x==0.0f && OrgC4CirOutPoint[k].y==0.0f) continue;
																 if(OrgC4CirInPoint [k].x==0.0f && OrgC4CirInPoint [k].y==0.0f) continue;
																 GrindWidthDis = Math.GetLength(OrgC4CirInPoint[k], OrgC4CirOutPoint[k]);
																 TotalCirDis+=   GrindWidthDis;
																 CircleCount++;
															 }
															 if(TotalCirDis!=0.0f && CircleCount!=0){
																 C4CirGrindWd = TotalCirDis/CircleCount;
															 }
														 }
													 }
												 }
											 }
											 else         { //Encap 연마량 계산 
												 if(OrgC4CirInEdgeCount==OrgC4CirOutEdgeCount){
													 double OutDis=0.0f, InDis=0.0f, TotalGrindWidth=0.0f, AvgGrindWidth=0.0f;C4GrindWidthCount=0;
													 for(int k=0; k<OrgC4CirInEdgeCount; k++){
														 if(OrgC4CirOutPoint[k].x==0.0f && OrgC4CirOutPoint[k].y==0.0f){
															 OutDis =0.0f;
														 }
														 else {
															 OutDis = Math.GetLengthFrPointToPoint(C4CirCenter,OrgC4CirOutPoint[k]);
														 }

														 if(OrgC4CirInPoint[k].x==0.0f && OrgC4CirInPoint[k].y==0.0f){
															 InDis =0.0f;
														 }
														 else {
															 InDis = Math.GetLengthFrPointToPoint(C4CirCenter,OrgC4CirInPoint[k]);
														 }

														 if(OutDis!=0.0f && InDis!=0.0f){
															 TotalGrindWidth+=(InDis - OutDis);
															 C4GrindWidthCount++;
														 }
													 }
													 if(C4GrindWidthCount!=0){
														 AvgGrindWidth = (TotalGrindWidth/C4GrindWidthCount);
														 C4CirGrindWd = AvgGrindWidth;
													 }
												 }
											 }
										 }
										 // C4Circle 연마량 가공량 검사 시퀀스 종료(TrackMode VS MarkMode)
										 //////////////////////////////////////////////////////////////////////////////////////////////////////


										 // Org Circle데이터중 유호하지 않은 값을 제외한 실제 존재하는 데이터 기준으로 동적 메모리 생성함
										 // Circle Defect검사에 필요한 Edge데이터 값
										 int Count=0;
										 if(OrgC4CirInEdgeCount>0){
											 C4CirInEdgeCount = OrgC4CirInEdgeCount - C4CirInEdgeCount;
											 // 										 C4CirInEdgeCount = OrgC4CirInEdgeCount;
											 if(C4CirInEdgeCount>0){
												 if(C4CirInPoint!=NULL) delete[] C4CirInPoint;
												 C4CirInPoint = new TFPoint[C4CirInEdgeCount];

												 for(int k=0; k<OrgC4CirInEdgeCount; k++){
													 if(k>MAX_CIRCLE_EDGEPOINT) break;
													 if(OrgC4CirInPoint[k].x==0.0f && OrgC4CirInPoint[k].y==0.0f) continue;
													 C4CirInPoint[Count].x = OrgC4CirInPoint[k].x;
													 C4CirInPoint[Count].y = OrgC4CirInPoint[k].y;
													 Count++;
												 }
											 }
											 // Circle 원본 데이터 메모리 삭제
											 if(OrgC4CirInPoint!=NULL) delete[] OrgC4CirInPoint;
										 }
										 // Circle Fitting 결과물 
										 SampleSize = C4CirInEdgeCount*0.75; //0.5~0.8이하로 입력할것
										 DistDevRatio = 0.15; //0.1~0.25 이하로 입력할것
										 // 									Radius = 0;
										 CircleFit->OnRansac(C4CirInPoint,C4CirInEdgeCount,SampleSize,DistDevRatio,&CircleFit4Center,&CirFitDiameter4);

										 if(OrgC4CirOutEdgeCount>0){
											 C4CirOutEdgeCount = OrgC4CirOutEdgeCount - C4CirOutEdgeCount;
											 Count =0;
											 if(C4CirOutEdgeCount>0){
												 if(C4CirOutPoint!=NULL) delete[] C4CirOutPoint;
												 C4CirOutPoint = new TFPoint[C4CirOutEdgeCount];

												 for(int k=0; k<OrgC4CirOutEdgeCount; k++){
													 if(k>MAX_CIRCLE_EDGEPOINT) break;
													 if(OrgC4CirOutPoint[k].x==0.0f && OrgC4CirOutPoint[k].y==0.0f) continue;
													 C4CirOutPoint[Count].x = OrgC4CirOutPoint[k].x;
													 C4CirOutPoint[Count].y = OrgC4CirOutPoint[k].y;
													 Count++;
												 }
											 }
											 // Circle 원본 데이터 메모리 삭제
											 if(OrgC4CirOutPoint!=NULL) delete[] OrgC4CirOutPoint;
										 }
										 if(OrgC4CirStandEdgeCount>0){
											 C4CirStandEdgeCount = OrgC4CirStandEdgeCount - C4CirStandEdgeCount;
											 // 										 C4CirStandEdgeCount = OrgC4CirStandEdgeCount;
											 Count =0;
											 if(C4CirStandEdgeCount>0){
												 if(C4CirStandPoint!=NULL) delete[] C4CirStandPoint;
												 C4CirStandPoint = new TFPoint[C4CirStandEdgeCount];

												 for(int k=0; k<OrgC4CirStandEdgeCount; k++){
													 if(k>MAX_CIRCLE_EDGEPOINT) break;
													 if(OrgC4CirStandPoint[k].x==0.0f && OrgC4CirStandPoint[k].y==0.0f) continue;
													 C4CirStandPoint[Count].x = OrgC4CirStandPoint[k].x;
													 C4CirStandPoint[Count].y = OrgC4CirStandPoint[k].y;
													 Count++;
												 }
											 }
											 // Circle 원본 데이터 메모리 삭제
											 if(OrgC4CirStandPoint!=NULL) delete[] OrgC4CirStandPoint;
										 }
										 LogUnit.SetLog(L"Circle_4_Insp_End");
										 // Circle 영역 꽃박리, 원형박리 검출 목적 시퀀스(EnCap)
										 // 정식 명칭은 몰라서.....일단 Crack으로 정함 
										 if(!IsMarkBtm && BrokenThresHold!=0){
											 if(CirFitDiameter4!=0.0f && CircleFit4Center.x!=0.0f && CircleFit4Center.y!=0.0f){ // FAVION Circle Fitting 성공시 박리검사 진행 
												 Circle->GImage = &RotateBrokenImg;                                             //Binary Image 넘겨줌 

												 Circle->SetCenterXY(CircleFit4Center.x,CircleFit4Center.y)      ;
												 Circle->SetTolerance((dEdgeToTrapLineDis/2)-CirOffsetMargin)    ; // Circle Tolerance 
												 Circle->SetDiameter ((CirFitDiameter4+(dEdgeToTrapLineDis/2))*2); // Circle Diameter 
												 Circle->SetCircleChoice(0)                                      ; // 0:From Begin, 1:From End, 2:Largest Amplitude 
												 Circle->SetCircleType  (2)                                      ; // 0:Black to White, 1:White to Black 2: Both Black, White 
												 Circle->SetCircleIndex (0)                                      ; // Circle EdgePoint Index 
												 Circle->OnExecute(true)                                         ;
												 CrackCirDiameter4 = (CirFitDiameter4+(dEdgeToTrapLineDis/2))-((dEdgeToTrapLineDis/2)-CirOffsetMargin);

												 C4CirInCrackCount = Circle->FCirclePointCount;

												 if(C4CirInCrackCount>0){
													 if(C4CirInCrackPoint!=NULL) delete[] C4CirInCrackPoint;
													 C4CirInCrackPoint = new TFPoint[C4CirInCrackCount];

													 for(int k=0; k<C4CirInCrackCount; k++){
														 if(k>MAX_CIRCLE_EDGEPOINT) break;
														 C4CirInCrackPoint[k].x = Circle->FCirclePoint[k].x;
														 C4CirInCrackPoint[k].y = Circle->FCirclePoint[k].y;
													 }
												 }
											 }
										 }
									 }

									 // 다섯번째 Circle EdgePoint Data 추출 
									 if(C5CirCenter.x!=0 && C5CirCenter.y!=0){
										 LogUnit.SetLog(L"Circle_5_Insp_Start");

										 // 									 if(BtmEdgeThresHold==0) Circle->GImage = &RotateImg      ; //Org Image 넘겨줌 
										 // 									 else                    Circle->GImage = &RotateBinaryImg; //Binary Image 넘겨줌 

										 if(CirGrindInThresHold==0) Circle->GImage = &RotateImg             ; //Org Image 넘겨줌 
										 else                       Circle->GImage = &RotateGrindInBinaryImg; //Binary Image 넘겨줌 

										 if      (FInspectMode==Insp_Track) Circle->SetCenterXY(TrackC5CirCenter.x , TrackC5CirCenter.y); // TrackLine 교차점 기준 센터 
										 else if (FInspectMode==Insp_Mark ) Circle->SetCenterXY(C5CirCenter.x      , C5CirCenter.y     ); // 외곽라인 교차점 기준 센터 
										 // Diameter 계산함(OutCircle과 TrackCircle 중간값 기준)
										 C5Diameter = ((CenterCircleHeight*2)+((CenterCircleHeight-OutToTrackLineDis)*2))/2;
										 // 									 C5Diameter = (CenterCircleHeight*2);
										 if(IsMarkBtm) Circle->SetTolerance(60.0f);
										 else          Circle->SetTolerance(80.0f);
										 // 									 Circle->SetTolerance(40.0f )                      ; // Circle Tolerance 
										 Circle->SetDiameter (C5Diameter)                  ; // Circle Diameter 
										 // 									 Circle->SetCircleChoice(0)                        ; // 0:From Begin, 1:From End, 2:Largest Amplitude 
										 // 									 Circle->SetCircleIndex (0)                        ; // Circle EdgePoint Index 
										 Circle->SetCircleChoice(1)                        ; // 0:From Begin, 1:From End, 2:Largest Amplitude 
										 Circle->SetCircleType  (2)                        ; // 0:Black to White, 1:White to Black 2: Both Black, White 
										 Circle->SetCircleIndex (1)                        ; // Circle EdgePoint Index 

										 // W1 Cell
										 // 									 Circle->SetAngle(90)                              ; // Cirlce Angle 
										 // 									 Circle->SetAmplitude(46)                          ; // Circle Amplitude
										 // W4 Cell
										 // 									 Circle->SetAngle(90)                              ; // Cirlce Angle 
										 // 									 Circle->SetAmplitude(81)                          ; // Circle Amplitude
										 if(CenterCirDeg>=0){
											 CenterCirDeg = (CenterCirDeg==0)? 90:CenterCirDeg;
											 // 										 Circle->SetAngle(90+CirAngleMargin);               // Circle Fitting 시작점 각도
											 // 										 Circle->SetAmplitude(CenterCirDeg-2*CirAngleMargin);  // Circle Fitting 시작점 부터 검사 범위 
											 Circle->SetAngle    (90          );               // Circle Fitting 시작점 각도
											 Circle->SetAmplitude(CenterCirDeg);  // Circle Fitting 시작점 부터 검사 범위 

										 }
										 Circle->OnExecute()                               ;

										 // Circle In Data 기준 새로운 Circle Center 좌표 받아옴 
										 RealC5CirCenter.x = Circle->FCP.x;
										 RealC5CirCenter.y = Circle->FCP.y;
										 CirDiameter5      = (Circle->Diameter)/2.0;

										 // Circle In Data취합 
										 OrgC5CirInEdgeCount = Circle->FCirclePointCount;
										 if(OrgC5CirInEdgeCount>0){
											 if(OrgC5CirInPoint!=NULL) delete[] OrgC5CirInPoint;
											 OrgC5CirInPoint = new TFPoint[OrgC5CirInEdgeCount];

											 for(int k=0; k<OrgC5CirInEdgeCount; k++){
												 if(k>MAX_CIRCLE_EDGEPOINT) break;
												 OrgC5CirInPoint[k].x = Circle->FCirclePoint[k].x;
												 OrgC5CirInPoint[k].y = Circle->FCirclePoint[k].y;
												 if(OrgC5CirInPoint[k].x==0.0f && OrgC5CirInPoint[k].y==0.0f) C5CirInEdgeCount++;
												 // BTM영역 Circle을 제외한 영역 Defect검사 목적에 좌표계산 
												 // 											 if(k==0) {BtmEdgePoint1.x = C1CirInPoint[k].x; BtmEdgePoint1.y = C1CirInPoint[k].y;}
											 }
										 }

										 // C5Circle 연마량 가공량 검사 시퀀스 시작(TrackMode VS MarkMode)
										 if(BtmEdgeThresHold==0) Circle->GImage = &RotateImg      ; //Org Image 넘겨줌 
										 else                    Circle->GImage = &RotateBinaryImg; //Binary Image 넘겨줌 

										 if(IsMarkBtm) Circle->SetTolerance(60.0f);
										 else          Circle->SetTolerance(80.0f);
										 // 									 Circle->SetTolerance(40.0f )                      ; // Circle Tolerance 
										 Circle->SetDiameter (C5Diameter)                  ; // Circle Diameter 
										 // 									 Circle->SetCircleType(0)                          ; // 0:Black to White, 1:White to Black 2: Both Black, White 
										 Circle->SetCircleChoice(1)                        ; // 0:From Begin, 1:From End, 2:Largest Amplitude 
										 Circle->SetCircleType  (2)                        ; // 0:Black to White, 1:White to Black 2: Both Black, White 
										 Circle->SetCircleIndex (0)                        ; // Circle EdgePoint Index 
										 Circle->OnExecute()                               ;

										 // Circle Out Data취합 
										 OrgC5CirOutEdgeCount = Circle->FCirclePointCount;
										 if(OrgC5CirOutEdgeCount>0){
											 if(OrgC5CirOutPoint!=NULL) delete[] OrgC5CirOutPoint;
											 OrgC5CirOutPoint = new TFPoint[OrgC5CirOutEdgeCount];

											 for(int k=0; k<OrgC5CirOutEdgeCount; k++){
												 if(k>MAX_CIRCLE_EDGEPOINT) break;
												 OrgC5CirOutPoint[k].x = Circle->FCirclePoint[k].x;
												 OrgC5CirOutPoint[k].y = Circle->FCirclePoint[k].y;
												 // BTM영역 Circle을 제외한 영역 Defect검사 목적에 좌표계산 
												 if(k==0                                                                         ){BtmEdgePoint[8].x = OrgC5CirOutPoint[k].x; BtmEdgePoint[8].y = OrgC5CirOutPoint[k].y;}
												 if(k==(OrgC5CirOutEdgeCount-1) && (BtmEdgePoint[7].x==0 || BtmEdgePoint[7].y==0)){BtmEdgePoint[7].x = OrgC5CirOutPoint[k].x; BtmEdgePoint[7].y = OrgC5CirOutPoint[k].y;}
												 if(OrgC5CirOutPoint[k].x==0.0f && OrgC5CirOutPoint[k].y==0.0f) C5CirOutEdgeCount++;
											 }
										 }
										 // C5Circle Grind_Width, Grind_Measure 
										 // C5Circle 연마량 가공량 검사 시퀀스 시작(TrackMode VS MarkMode)
										 if(FInspectMode==Insp_Track){
											 if(OrgC5CirInEdgeCount==OrgC5CirOutEdgeCount){//연마량 계산 
												 double OutDis=0.0f, InDis=0.0f, TotalGrindWidth=0.0f, AvgGrindWidth=0.0f;C5GrindWidthCount=0;
												 for(int k=0; k<OrgC5CirInEdgeCount; k++){
													 if(OrgC5CirOutPoint[k].x==0.0f && OrgC5CirOutPoint[k].y==0.0f){
														 OutDis =0.0f;
													 }
													 else {
														 OutDis = Math.GetLengthFrPointToPoint(C5CirCenter,OrgC5CirOutPoint[k]);
													 }

													 if(OrgC5CirInPoint[k].x==0.0f && OrgC5CirInPoint[k].y==0.0f){
														 InDis =0.0f;
													 }
													 else {
														 InDis = Math.GetLengthFrPointToPoint(C5CirCenter,OrgC5CirInPoint[k]);
													 }

													 if(OutDis!=0.0f && InDis!=0.0f){
														 TotalGrindWidth+=(OutDis - InDis);
														 C5GrindWidthCount++;
													 }
												 }
												 if(C5GrindWidthCount!=0){
													 AvgGrindWidth = (TotalGrindWidth/C5GrindWidthCount);
													 C5CirGrindWd = AvgGrindWidth;
												 }
											 }
											 if(IsMarkBtm){ // LTPS 가공량 계산
												 if(CirGrindMeaThresHold!=0){
													 Circle->GImage = &RotateGrindBinaryImg; //Binary Image 넘겨줌 
													 Circle->SetCircleChoice(1)            ; // 0:From Begin, 1:From End, 2:Largest Amplitude 
													 Circle->SetCircleType(2)              ; // 0:Black to White, 1:White to Black 2: Both Black, White 
													 Circle->SetCircleIndex (1)            ; // Circle EdgePoint Index 
													 Circle->SetTolerance(80.0f )          ; // Circle Tolerance 
													 Circle->SetDiameter (C5Diameter)      ; // Circle Diameter 
													 // 										 Circle->SetCircleType(1)              ; // 0:Black to White, 1:White to Black 2: Both Black, White 
													 Circle->OnExecute()                   ;

													 // Circle In Data 기준 새로운 Circle Center 좌표 받아옴 
													 RealC5CirCenter.x = Circle->FCP.x;
													 RealC5CirCenter.y = Circle->FCP.y;

													 OrgC5CirStandEdgeCount = Circle->FCirclePointCount;
													 if(OrgC5CirStandEdgeCount>0){
														 if(OrgC5CirStandPoint!=NULL) delete[] OrgC5CirStandPoint;
														 OrgC5CirStandPoint = new TFPoint[OrgC5CirStandEdgeCount];

														 PreC5CirStandPoint[0].x=0.0f; PreC5CirStandPoint[0].y=0.0f;
														 for(int k=0; k<OrgC5CirStandEdgeCount; k++){
															 if(k>MAX_CIRCLE_EDGEPOINT) break;
															 OrgC5CirStandPoint[k].x = Circle->FCirclePoint[k].x;
															 OrgC5CirStandPoint[k].y = Circle->FCirclePoint[k].y;
															 if(OrgC5CirStandPoint[k].x==0.0f && OrgC5CirStandPoint[k].y==0.0f) C5CirStandEdgeCount++;
															 // TrackLine 자재 상태에 따라서 잘못된 EdgePoint를 찾을경우 대비하여 이전데이터 기준 데이터 복원 
															 if(OrgC5CirStandPoint[k].x!=0.0f && OrgC5CirStandPoint[k].y!=0.0f){
																 // 첫번째는 무조건 데이터 넘겨줌 
																 if(PreC5CirStandPoint[0].x==0.0f && PreC5CirStandPoint[0].y==0.0f){
																	 PreC5CirStandPoint[0].x = OrgC5CirStandPoint[k].x; 
																	 PreC5CirStandPoint[0].y = OrgC5CirStandPoint[k].y; 
																 }
																 // 																 else {
																 // 																	 if(fabs (OrgC5CirStandPoint[k].x-PreC5CirStandPoint[0].x)>TrackLineMargin ||
																 // 																		 fabs(OrgC5CirStandPoint[k].y-PreC5CirStandPoint[0].y)>TrackLineMargin   ){
																 // 																			 OrgC5CirStandPoint[k].x = PreC5CirStandPoint[0].x-0.5;
																 // 																			 OrgC5CirStandPoint[k].y = PreC5CirStandPoint[0].y-0.5;
																 // 
																 // 																			 PreC5CirStandPoint[0].x = OrgC5CirStandPoint[k].x; 
																 // 																			 PreC5CirStandPoint[0].y = OrgC5CirStandPoint[k].y; 
																 // 																	 }
																 // 																	 else {
																 // 																		 PreC5CirStandPoint[0].x = OrgC5CirStandPoint[k].x; 
																 // 																		 PreC5CirStandPoint[0].y = OrgC5CirStandPoint[k].y; 
																 // 																	 }
																 // 																 }
															 }
														 }
														 //C5Circle Grind_Measure Calculate 
														 if(OrgC5CirOutEdgeCount==OrgC5CirStandEdgeCount){
															 double GrindMeaDis=0.0f, TotalGrindMeasure=0.0f, AvgGrindMeasure=0.0f; C5GrindMeasureCount=0;
															 for(int k=0; k<OrgC5CirInEdgeCount; k++){
																 if(OrgC5CirOutPoint[k].x==0.0f || OrgC5CirOutPoint[k].y==0.0f || OrgC5CirStandPoint[k].x==0.0f || OrgC5CirStandPoint[k].y==0.0f){
																	 GrindMeaDis =0.0f;
																 }
																 else {
																	 GrindMeaDis = Math.GetLengthFrPointToPoint(OrgC5CirStandPoint[k],OrgC5CirOutPoint[k]);
																 }

																 if(GrindMeaDis!=0.0f){
																	 TotalGrindMeasure+= GrindMeaDis;
																	 C5GrindMeasureCount++;
																 }
															 }
															 if(C5GrindMeasureCount!=0){
																 AvgGrindMeasure = (TotalGrindMeasure/C5GrindMeasureCount);
																 C5CirGrindMea= AvgGrindMeasure;
															 }
														 }
														 else if(OrgC5CirStandEdgeCount>OrgC5CirOutEdgeCount) { // 연마가 적게되어 실제 TrackLine보다 EdgePoint데이터가 적을경우 
															 double GrindMeaDis=0.0f, TotalGrindMeasure=0.0f, AvgGrindMeasure=0.0f;C5GrindMeasureCount=0;
															 for(int k=0; k<OrgC5CirOutEdgeCount; k++){
																 if(OrgC5CirOutPoint[k].x==0.0f || OrgC5CirOutPoint[k].y==0.0f || OrgC5CirStandPoint[k].x==0.0f || OrgC5CirStandPoint[k].y==0.0f ){
																	 GrindMeaDis =0.0f;
																 }
																 else {
																	 GrindMeaDis = Math.GetLengthFrPointToPoint(OrgC5CirStandPoint[k],OrgC5CirOutPoint[k]);
																 }

																 if(GrindMeaDis!=0.0f){
																	 TotalGrindMeasure+= GrindMeaDis;
																	 C5GrindMeasureCount++;
																 }
															 }
															 if(C5GrindMeasureCount!=0){
																 AvgGrindMeasure = (TotalGrindMeasure/C5GrindMeasureCount);
																 C5CirGrindMea= AvgGrindMeasure;
															 }
														 }
														 else if(OrgC5CirStandEdgeCount<OrgC5CirOutEdgeCount){
															 double GrindMeaDis=0.0f, TotalGrindMeasure=0.0f, AvgGrindMeasure=0.0f;C5GrindMeasureCount=0;
															 for(int k=0; k<OrgC5CirStandEdgeCount; k++){
																 if(OrgC5CirOutPoint[k].x==0.0f || OrgC5CirOutPoint[k].y==0.0f || OrgC5CirStandPoint[k].x==0.0f || OrgC5CirStandPoint[k].y==0.0f ){
																	 GrindMeaDis =0.0f;
																 }
																 else {
																	 GrindMeaDis = Math.GetLengthFrPointToPoint(OrgC5CirStandPoint[k],OrgC5CirOutPoint[k]);
																 }

																 if(GrindMeaDis!=0.0f){
																	 TotalGrindMeasure+= GrindMeaDis;
																	 C5GrindMeasureCount++;
																 }
															 }
															 if(C5GrindMeasureCount!=0){
																 AvgGrindMeasure = (TotalGrindMeasure/C5GrindMeasureCount);
																 C5CirGrindMea= AvgGrindMeasure;
															 }
														 }
													 }
												 }
											 }
										 }
										 else if(FInspectMode==Insp_Mark){ //MarkMode 
											 if(IsMarkBtm){ // LTPS 가공량 계산 ==> 연마량 계산 
												 if(OrgC5CirOutEdgeCount!=0 && OrgC5CirInEdgeCount!=0){ // 연마량이 존재할경우 가공량 검사를 진행함 
													 // 가공량,연마량 측정 전 데이터 존재시 가상GrindMark 생성한다 
													 if(GrindMarkPoint[13].x!=0.0f && GrindMarkPoint[13].y!=0.0f){
														 GrindMarkPoint[12].x     = GrindMarkPoint[13].x - GrindRectSpec[6].DvX;
														 GrindMarkPoint[12].y     = GrindMarkPoint[13].y - GrindRectSpec[6].DvY;
														 GrindMarkRect [12].left  = GrindMarkPoint[12].x    - GrindMarkRange   ;  
														 GrindMarkRect [12].top   = GrindMarkPoint[12].y    - GrindMarkRange   ;  
														 GrindMarkRect [12].right = GrindMarkRect [12].left + GrindMarkLength  ;  
														 GrindMarkRect [12].bottom= GrindMarkRect [12].top  + GrindMarkLength  ;  
													 }

													 // GrindMarkPoint12 Calc 진행함(연마량,가공량)
													 if(GrindMarkPoint[12].x!=0.0f && GrindMarkPoint[12].y!=0.0f){
														 GrindMeaDis =0.0f, MinDis =10000.0f; C5GrindMarkCount=0;
														 for(int k=0; k<OrgC5CirOutEdgeCount; k++){
															 if(OrgC5CirOutPoint[k].x==0.0f || OrgC5CirOutPoint[k].y==0.0f) continue;
															 if(GrindMarkPoint[12].x  ==0.0f || GrindMarkPoint[12].y  ==0.0f) continue;

															 GrindMeaDis = Math.GetLength(GrindMarkPoint[12], OrgC5CirOutPoint[k]);
															 if(GrindMeaDis<MinDis){
																 MinDis = GrindMeaDis;
																 C5GrindMarkCount = k;
															 }
														 }
														 // GrindMark기준 수직 포인트 주변값 Avg산출한다 
														 if(C5GrindMarkCount!=0 && C5GrindMarkCount>5 && (C5GrindMarkCount+5)<OrgC5CirOutEdgeCount){
															 CircleCount=0,TotalCirDis=0.0f,GrindMeaDis=0.0f;
															 for(int k=C5GrindMarkCount-5; k<C5GrindMarkCount+5; k++){
																 if(OrgC5CirOutPoint[k].x==0.0f || OrgC5CirOutPoint[k].y==0.0f) continue;

																 GrindMeaDis = Math.GetLength(GrindMarkPoint[12], OrgC5CirOutPoint[k]);
																 TotalCirDis+= GrindMeaDis;
																 CircleCount++;
															 }
															 if(TotalCirDis!=0.0f && CircleCount!=0){
																 TrenchRightGrindMea = TotalCirDis/CircleCount;
															 }
														 }
														 // GrindMark기준 수직 평균값 연마량 측정 
														 if(C5GrindMarkCount!=0 && C5GrindMarkCount>5 && (C5GrindMarkCount+5)<OrgC5CirOutEdgeCount){
															 CircleCount=0,TotalCirDis=0.0f,GrindWidthDis=0.0f;
															 for(int k=C5GrindMarkCount-5; k<C5GrindMarkCount+5; k++){
																 if(OrgC5CirOutPoint[k].x==0.0f && OrgC5CirOutPoint[k].y==0.0f) continue;
																 if(OrgC5CirInPoint [k].x==0.0f && OrgC5CirInPoint [k].y==0.0f) continue;
																 GrindWidthDis = Math.GetLength(OrgC5CirInPoint[k], OrgC5CirOutPoint[k]);
																 TotalCirDis+=   GrindWidthDis;
																 CircleCount++;
															 }
															 if(TotalCirDis!=0.0f && CircleCount!=0){
																 TrenchRightGrindWd = TotalCirDis/CircleCount;
															 }
														 }
													 }
													 else { // Grind Mark 못 찾았을경우 (가공량 0, 연마량 계산함)
														 GrindMeaDis =0.0f, MinDis =10000.0f; C5GrindMarkCount=0;
														 for(int k=0; k<OrgC5CirOutEdgeCount; k++){
															 if(OrgC5CirOutPoint[k].x==0.0f || OrgC5CirOutPoint[k].y==0.0f) continue;

															 if(k==0){
																 GrindMarkRectCenter[13].x = GrindMarkRect[13].left + (GrindMarkRect[13].right  - GrindMarkRect[13].left)/2; 
																 GrindMarkRectCenter[13].y = GrindMarkRect[13].top  + (GrindMarkRect[13].bottom - GrindMarkRect[13].top )/2; 

																 GrindMarkRectCenter[12].x = GrindMarkRectCenter[13].x - GrindRectSpec[6].DvX;
																 GrindMarkRectCenter[12].y = GrindMarkRectCenter[13].y - GrindRectSpec[6].DvY;

																 GrindMarkRect [12].left  =  GrindMarkRectCenter[12].x   - GrindMarkRange   ;  
																 GrindMarkRect [12].top   =  GrindMarkRectCenter[12].y   - GrindMarkRange   ;  
																 GrindMarkRect [12].right =  GrindMarkRect [12].left + GrindMarkLength  ;  
																 GrindMarkRect [12].bottom=  GrindMarkRect [12].top  + GrindMarkLength  ;  
															 }
															 // 														 GrindMarkRectPoint5.x = GrindMarkRect[12].left + (GrindMarkRect[12].right  - GrindMarkRect[12].left)/2; 
															 // 														 GrindMarkRectPoint5.y = GrindMarkRect[12].top  + (GrindMarkRect[12].bottom - GrindMarkRect[12].top )/2; 

															 GrindMeaDis = Math.GetLength(GrindMarkRectCenter[13], OrgC5CirOutPoint[k]);
															 if(GrindMeaDis<MinDis){
																 MinDis = GrindMeaDis;
																 C5GrindMarkCount = k;
															 }
														 }
														 // GrindMark기준 수직 평균값 연마량 측정 
														 if(C5GrindMarkCount!=0 && C5GrindMarkCount>5 && (C5GrindMarkCount+5)<OrgC5CirOutEdgeCount){
															 CircleCount=0,TotalCirDis=0.0f,GrindWidthDis=0.0f;
															 for(int k=C5GrindMarkCount-5; k<C5GrindMarkCount+5; k++){
																 if(OrgC5CirOutPoint[k].x==0.0f && OrgC5CirOutPoint[k].y==0.0f) continue;
																 if(OrgC5CirInPoint [k].x==0.0f && OrgC5CirInPoint [k].y==0.0f) continue;
																 GrindWidthDis = Math.GetLength(OrgC5CirInPoint[k], OrgC5CirOutPoint[k]);
																 TotalCirDis+=   GrindWidthDis;
																 CircleCount++;
															 }
															 if(TotalCirDis!=0.0f && CircleCount!=0){
																 TrenchRightGrindWd = TotalCirDis/CircleCount;
															 }
														 }
													 }


													 // GrindMarkPoint13 Calc 진행함(연마량,가공량)
													 if(GrindMarkPoint[13].x!=0.0f && GrindMarkPoint[13].y!=0.0f){
														 GrindMeaDis =0.0f, MinDis =10000.0f; C5GrindMarkCount=0;
														 for(int k=0; k<OrgC5CirOutEdgeCount; k++){
															 if(OrgC5CirOutPoint[k].x==0.0f || OrgC5CirOutPoint[k].y==0.0f) continue;
															 if(GrindMarkPoint[13].x  ==0.0f || GrindMarkPoint[13].y  ==0.0f) continue;

															 GrindMeaDis = Math.GetLength(GrindMarkPoint[13], OrgC5CirOutPoint[k]);
															 if(GrindMeaDis<MinDis){
																 MinDis = GrindMeaDis;
																 C5GrindMarkCount = k;
															 }
														 }
														 // GrindMark기준 수직 포인트 주변값 Avg산출한다 
														 if(C5GrindMarkCount!=0 && C5GrindMarkCount>5){
															 CircleCount=0,TotalCirDis=0.0f,GrindMeaDis=0.0f;
															 for(int k=C5GrindMarkCount-5; k<C5GrindMarkCount+5; k++){
																 if(OrgC5CirOutPoint[k].x==0.0f || OrgC5CirOutPoint[k].y==0.0f) continue;

																 GrindMeaDis = Math.GetLength(GrindMarkPoint[13], OrgC5CirOutPoint[k]);
																 TotalCirDis+= GrindMeaDis;
																 CircleCount++;
															 }
															 if(TotalCirDis!=0.0f && CircleCount!=0){
																 C5CirGrindMea = TotalCirDis/CircleCount;
															 }
														 }
														 // GrindMark기준 수직 평균값 연마량 측정 
														 if(C5GrindMarkCount!=0 && C5GrindMarkCount>5){
															 CircleCount=0,TotalCirDis=0.0f,GrindWidthDis=0.0f;
															 for(int k=C5GrindMarkCount-5; k<C5GrindMarkCount+5; k++){
																 if(OrgC5CirOutPoint[k].x==0.0f && OrgC5CirOutPoint[k].y==0.0f) continue;
																 if(OrgC5CirInPoint [k].x==0.0f && OrgC5CirInPoint [k].y==0.0f) continue;
																 GrindWidthDis = Math.GetLength(OrgC5CirInPoint[k], OrgC5CirOutPoint[k]);
																 TotalCirDis+=   GrindWidthDis;
																 CircleCount++;
															 }
															 if(TotalCirDis!=0.0f && CircleCount!=0){
																 C5CirGrindWd = TotalCirDis/CircleCount;
															 }
														 }
													 }
													 else { // Grind Mark 못 찾았을경우 (가공량 0, 연마량 계산함)
														 GrindMeaDis =0.0f, MinDis =10000.0f; C5GrindMarkCount=0;
														 for(int k=0; k<OrgC5CirOutEdgeCount; k++){
															 if(OrgC5CirOutPoint[k].x==0.0f || OrgC5CirOutPoint[k].y==0.0f) continue;

															 GrindMarkRectCenter[13].x = GrindMarkRect[13].left + (GrindMarkRect[13].right  - GrindMarkRect[13].left)/2; 
															 GrindMarkRectCenter[13].y = GrindMarkRect[13].top  + (GrindMarkRect[13].bottom - GrindMarkRect[13].top )/2; 

															 GrindMeaDis = Math.GetLength(GrindMarkRectCenter[13], OrgC5CirOutPoint[k]);
															 if(GrindMeaDis<MinDis){
																 MinDis = GrindMeaDis;
																 C5GrindMarkCount = k;
															 }
														 }
														 // GrindMark기준 수직 평균값 연마량 측정 
														 if(C5GrindMarkCount!=0 && C5GrindMarkCount>5){
															 CircleCount=0,TotalCirDis=0.0f,GrindWidthDis=0.0f;
															 for(int k=C5GrindMarkCount-5; k<C5GrindMarkCount+5; k++){
																 if(OrgC5CirOutPoint[k].x==0.0f && OrgC5CirOutPoint[k].y==0.0f) continue;
																 if(OrgC5CirInPoint [k].x==0.0f && OrgC5CirInPoint [k].y==0.0f) continue;
																 GrindWidthDis = Math.GetLength(OrgC5CirInPoint[k], OrgC5CirOutPoint[k]);
																 TotalCirDis+=   GrindWidthDis;
																 CircleCount++;
															 }
															 if(TotalCirDis!=0.0f && CircleCount!=0){
																 C5CirGrindWd = TotalCirDis/CircleCount;
															 }
														 }
													 }
												 }
											 }
											 else         {// EnCap 가공량 계산 
												 if(OrgC5CirInEdgeCount==OrgC5CirOutEdgeCount){
													 double OutDis=0.0f, InDis=0.0f, TotalGrindWidth=0.0f, AvgGrindWidth=0.0f;C5GrindWidthCount=0;
													 for(int k=0; k<OrgC5CirInEdgeCount; k++){
														 if(OrgC5CirOutPoint[k].x==0.0f && OrgC5CirOutPoint[k].y==0.0f){
															 OutDis =0.0f;
														 }
														 else {
															 OutDis = Math.GetLengthFrPointToPoint(C5CirCenter,OrgC5CirOutPoint[k]);
														 }

														 if(OrgC5CirInPoint[k].x==0.0f && OrgC5CirInPoint[k].y==0.0f){
															 InDis =0.0f;
														 }
														 else {
															 InDis = Math.GetLengthFrPointToPoint(C5CirCenter,OrgC5CirInPoint[k]);
														 }

														 if(OutDis!=0.0f && InDis!=0.0f){
															 TotalGrindWidth+=(OutDis - InDis);
															 C5GrindWidthCount++;
														 }
													 }
													 if(C5GrindWidthCount!=0){
														 AvgGrindWidth = (TotalGrindWidth/C5GrindWidthCount);
														 C5CirGrindWd = AvgGrindWidth;
													 }
												 }
											 }
										 }
										 // C5Circle 연마량 가공량 검사 시퀀스 종료(TrackMode VS MarkMode)
										 //////////////////////////////////////////////////////////////////////////////////////////////////////

										 // Org Circle데이터중 유호하지 않은 값을 제외한 실제 존재하는 데이터 기준으로 동적 메모리 생성함
										 // Circle Defect검사에 필요한 Edge데이터 값
										 int Count=0;
										 if(OrgC5CirInEdgeCount>0){
											 C5CirInEdgeCount = OrgC5CirInEdgeCount - C5CirInEdgeCount;
											 // 										 C5CirInEdgeCount = OrgC5CirInEdgeCount;
											 if(C5CirInEdgeCount>0){
												 if(C5CirInPoint!=NULL) delete[] C5CirInPoint;
												 C5CirInPoint = new TFPoint[C5CirInEdgeCount];

												 for(int k=0; k<OrgC5CirInEdgeCount; k++){
													 if(k>MAX_CIRCLE_EDGEPOINT) break;
													 if(OrgC5CirInPoint[k].x==0.0f && OrgC5CirInPoint[k].y==0.0f) continue;
													 C5CirInPoint[Count].x = OrgC5CirInPoint[k].x;
													 C5CirInPoint[Count].y = OrgC5CirInPoint[k].y;
													 Count++;
												 }
											 }
											 // Circle 원본 데이터 메모리 삭제
											 if(OrgC5CirInPoint!=NULL) delete[] OrgC5CirInPoint;
										 }
										 // Circle Fitting 결과물 
										 SampleSize = C5CirInEdgeCount*0.75; //0.5~0.8이하로 입력할것
										 DistDevRatio = 0.15; //0.1~0.25 이하로 입력할것
										 // 									Radius = 0;
										 CircleFit->OnRansac(C5CirInPoint,C5CirInEdgeCount,SampleSize,DistDevRatio,&CircleFit5Center,&CirFitDiameter5);

										 if(OrgC5CirOutEdgeCount>0){
											 C5CirOutEdgeCount = OrgC5CirOutEdgeCount - C5CirOutEdgeCount;
											 Count =0;
											 if(C5CirOutEdgeCount>0){
												 if(C5CirOutPoint!=NULL) delete[] C5CirOutPoint;
												 C5CirOutPoint = new TFPoint[C5CirOutEdgeCount];

												 for(int k=0; k<OrgC5CirOutEdgeCount; k++){
													 if(k>MAX_CIRCLE_EDGEPOINT) break;
													 if(OrgC5CirOutPoint[k].x==0.0f && OrgC5CirOutPoint[k].y==0.0f) continue;
													 C5CirOutPoint[Count].x = OrgC5CirOutPoint[k].x;
													 C5CirOutPoint[Count].y = OrgC5CirOutPoint[k].y;
													 Count++;
												 }
											 }
											 // Circle 원본 데이터 메모리 삭제
											 if(OrgC5CirOutPoint!=NULL) delete[] OrgC5CirOutPoint;
										 }
										 if(OrgC5CirStandEdgeCount>0){
											 C5CirStandEdgeCount = OrgC5CirStandEdgeCount - C5CirStandEdgeCount;
											 // 										 C5CirStandEdgeCount = OrgC5CirStandEdgeCount;
											 Count =0;
											 if(C5CirStandEdgeCount>0){
												 if(C5CirStandPoint!=NULL) delete[] C5CirStandPoint;
												 C5CirStandPoint = new TFPoint[C5CirStandEdgeCount];

												 for(int k=0; k<OrgC5CirStandEdgeCount; k++){
													 if(k>MAX_CIRCLE_EDGEPOINT) break;
													 if(OrgC5CirStandPoint[k].x==0.0f && OrgC5CirStandPoint[k].y==0.0f) continue;
													 C5CirStandPoint[Count].x = OrgC5CirStandPoint[k].x;
													 C5CirStandPoint[Count].y = OrgC5CirStandPoint[k].y;
													 Count++;
												 }
											 }
											 // Circle 원본 데이터 메모리 삭제
											 if(OrgC5CirStandPoint!=NULL) delete[] OrgC5CirStandPoint;
										 }
										 LogUnit.SetLog(L"Circle_5_Insp_End");
										 // Circle 영역 꽃박리, 원형박리 검출 목적 시퀀스(EnCap)
										 // 정식 명칭은 몰라서.....일단 Crack으로 정함 
										 if(!IsMarkBtm && BrokenThresHold!=0){
											 if(CirFitDiameter5!=0.0f && CircleFit5Center.x!=0.0f && CircleFit5Center.y!=0.0f){ // FAVION Circle Fitting 성공시 박리검사 진행 
												 Circle->GImage = &RotateBrokenImg;                                             //Binary Image 넘겨줌 

												 Circle->SetCenterXY(CircleFit5Center.x,CircleFit5Center.y)       ;
												 Circle->SetTolerance((dEdgeToTrapLineDis/2)-CirOffsetMargin)     ; // Circle Tolerance 
												 Circle->SetDiameter ((CirFitDiameter5-(dEdgeToTrapLineDis/2))*2); // Circle Diameter 
												 Circle->SetCircleChoice(0)                                       ; // 0:From Begin, 1:From End, 2:Largest Amplitude 
												 Circle->SetCircleType  (2)                                       ; // 0:Black to White, 1:White to Black 2: Both Black, White 
												 Circle->SetCircleIndex (0)                                       ; // Circle EdgePoint Index 
												 Circle->OnExecute(true)                                          ;
												 CrackCirDiameter5 = (CirFitDiameter5-(dEdgeToTrapLineDis/2))+((dEdgeToTrapLineDis/2)-CirOffsetMargin);

												 C5CirInCrackCount = Circle->FCirclePointCount;

												 if(C5CirInCrackCount>0){
													 if(C5CirInCrackPoint!=NULL) delete[] C5CirInCrackPoint;
													 C5CirInCrackPoint = new TFPoint[C5CirInCrackCount];

													 for(int k=0; k<C5CirInCrackCount; k++){
														 if(k>MAX_CIRCLE_EDGEPOINT) break;
														 C5CirInCrackPoint[k].x = Circle->FCirclePoint[k].x;
														 C5CirInCrackPoint[k].y = Circle->FCirclePoint[k].y;
													 }
												 }
											 }
										 }
									 }

									 // 여섯번째 Circle EdgePoint Data 추출 
									 if(C6CirCenter.x!=0 && C6CirCenter.y!=0){
										 LogUnit.SetLog(L"Circle_6_Insp_Start");

										 // 									 if(BtmEdgeThresHold==0) Circle->GImage = &RotateImg      ; //Org Image 넘겨줌 
										 // 									 else                    Circle->GImage = &RotateBinaryImg; //Binary Image 넘겨줌 

										 if(CirGrindInThresHold==0) Circle->GImage = &RotateImg             ; //Org Image 넘겨줌 
										 else                       Circle->GImage = &RotateGrindInBinaryImg; //Binary Image 넘겨줌 

										 if      (FInspectMode==Insp_Track) Circle->SetCenterXY(TrackC6CirCenter.x , TrackC6CirCenter.y); // TrackLine 교차점 기준 센터 
										 else if (FInspectMode==Insp_Mark ) Circle->SetCenterXY(C6CirCenter.x      , C6CirCenter.y     ); // 외곽라인 교차점 기준 센터 
										 // Diameter 계산함(OutCircle과 TrackCircle 중간값 기준)
										 // 									 C6Diameter = ((CSideCircleWidth*2)+(TrackCircleWidth*2))/2;
										 C6Diameter = (CSideCircleWidth*2);
										 // 									 C6Diameter = (CSideCircleWidth*2);
										 if(IsMarkBtm) Circle->SetTolerance(60.0f);
										 else          Circle->SetTolerance(80.0f);
										 // 									 Circle->SetTolerance(40.0f )         ; // Circle Tolerance 
										 Circle->SetDiameter (C6Diameter)     ; // Circle Diameter 
										 // 									 Circle->SetCircleChoice(0)           ; // 0:From Begin, 1:From End, 2:Largest Amplitude 
										 // 									 Circle->SetCircleIndex (0)           ; // Circle EdgePoint Index 
										 Circle->SetCircleChoice(1)           ; // 0:From Begin, 1:From End, 2:Largest Amplitude 
										 Circle->SetCircleType  (2)           ; // 0:Black to White, 1:White to Black 2: Both Black, White 
										 Circle->SetCircleIndex (1)           ; // Circle EdgePoint Index 

										 // 									 Circle->SetAngle(0)                  ; // Cirlce Angle 
										 // 									 Circle->SetAmplitude(90)             ; // Circle Amplitude
										 if(SideCirDeg>=0){
											 if(90-SideCirDeg>=0) Circle->SetAngle(90-SideCirDeg+CirAngleMargin   );  // Circle Fitting 시작점 각도
											 Circle->SetAmplitude(SideCirDeg-2*CirAngleMargin);  // Circle Fitting 시작점 부터 검사 범위 
										 }

										 // 									 Circle->SetCircleType(1)             ; // 0:Black to White, 1:White to Black 2: Both Black, White 
										 Circle->OnExecute()                  ;

										 // Circle In Data 기준 새로운 Circle Center 좌표 받아옴 
										 RealC6CirCenter.x = Circle->FCP.x;
										 RealC6CirCenter.y = Circle->FCP.y;
										 CirDiameter6      = (Circle->Diameter)/2.0;

										 // Circle In Data취합 
										 OrgC6CirInEdgeCount = Circle->FCirclePointCount;
										 if(OrgC6CirInEdgeCount>0){
											 if(OrgC6CirInPoint!=NULL) delete[] OrgC6CirInPoint;
											 OrgC6CirInPoint = new TFPoint[OrgC6CirInEdgeCount];

											 for(int k=0; k<OrgC6CirInEdgeCount; k++){
												 if(k>MAX_CIRCLE_EDGEPOINT) break;
												 OrgC6CirInPoint[k].x = Circle->FCirclePoint[k].x;
												 OrgC6CirInPoint[k].y = Circle->FCirclePoint[k].y;
												 if(OrgC6CirInPoint[k].x==0.0f && OrgC6CirInPoint[k].y==0.0f) C6CirInEdgeCount++;
												 // BTM영역 Circle을 제외한 영역 Defect검사 목적에 좌표계산 
												 // 											 if(k==0) {BtmEdgePoint1.x = C1CirInPoint[k].x; BtmEdgePoint1.y = C1CirInPoint[k].y;}
											 }
										 }

										 // Circle Out Data목적 다시 검사  
										 if(BtmEdgeThresHold==0) Circle->GImage = &RotateImg      ; //Org Image 넘겨줌 
										 else                    Circle->GImage = &RotateBinaryImg; //Binary Image 넘겨줌 

										 if(IsMarkBtm) Circle->SetTolerance(60.0f);
										 else          Circle->SetTolerance(80.0f);
										 // 									 Circle->SetTolerance(40.0f )                      ; // Circle Tolerance 
										 Circle->SetDiameter (C6Diameter)                  ; // Circle Diameter 
										 // 									 Circle->SetCircleType(0)                          ; // 0:Black to White, 1:White to Black 2: Both Black, White 
										 Circle->SetCircleChoice(1)                        ; // 0:From Begin, 1:From End, 2:Largest Amplitude 
										 Circle->SetCircleType  (2)                        ; // 0:Black to White, 1:White to Black 2: Both Black, White 
										 Circle->SetCircleIndex (0)                        ; // Circle EdgePoint Index 

										 Circle->OnExecute()                               ;

										 // Circle Out Data취합 
										 OrgC6CirOutEdgeCount = Circle->FCirclePointCount;
										 if(OrgC6CirOutEdgeCount>0){
											 if(OrgC6CirOutPoint!=NULL) delete[] OrgC6CirOutPoint;
											 OrgC6CirOutPoint = new TFPoint[OrgC6CirOutEdgeCount];

											 for(int k=0; k<OrgC6CirOutEdgeCount; k++){
												 if(k>MAX_CIRCLE_EDGEPOINT) break;
												 OrgC6CirOutPoint[k].x = Circle->FCirclePoint[k].x;
												 OrgC6CirOutPoint[k].y = Circle->FCirclePoint[k].y;
												 // BTM영역 Circle을 제외한 영역 Defect검사 목적에 좌표계산 
												 if(k==(OrgC6CirOutEdgeCount-1)) {BtmEdgePoint[9].x = OrgC6CirOutPoint[k].x; BtmEdgePoint[9].y = OrgC6CirOutPoint[k].y;}
												 if(OrgC6CirOutPoint[k].x==0.0f && OrgC6CirOutPoint[k].y==0.0f) C6CirOutEdgeCount++;
											 }
										 }
										 // C6Circle Grind_Width, Grind_Measure 
										 // C6Circle 연마량 가공량 검사 시퀀스 시작(TrackMode VS MarkMode)
										 if(FInspectMode==Insp_Track){
											 if(OrgC6CirInEdgeCount==OrgC6CirOutEdgeCount){//연마량 계산 
												 double OutDis=0.0f, InDis=0.0f, TotalGrindWidth=0.0f, AvgGrindWidth=0.0f; C6GrindWidthCount=0;
												 for(int k=0; k<OrgC6CirInEdgeCount; k++){
													 if(OrgC6CirOutPoint[k].x==0.0f && OrgC6CirOutPoint[k].y==0.0f){
														 OutDis =0.0f;
													 }
													 else {
														 OutDis = Math.GetLengthFrPointToPoint(C6CirCenter,OrgC6CirOutPoint[k]);
													 }

													 if(OrgC6CirInPoint[k].x==0.0f && OrgC6CirInPoint[k].y==0.0f){
														 InDis =0.0f;
													 }
													 else {
														 InDis = Math.GetLengthFrPointToPoint(C6CirCenter,OrgC6CirInPoint[k]);
													 }

													 if(OutDis!=0.0f && InDis!=0.0f){
														 TotalGrindWidth+=(OutDis - InDis);
														 C6GrindWidthCount++;
													 }
												 }
												 if(C6GrindWidthCount!=0){
													 AvgGrindWidth = (TotalGrindWidth/C6GrindWidthCount);
													 C6CirGrindWd = AvgGrindWidth;
												 }
											 }
											 if(IsMarkBtm){ // LTPS 가공량 계산 
												 if(CirGrindMeaThresHold!=0){
													 Circle->GImage = &RotateGrindBinaryImg  ; //Binary Image 넘겨줌 
													 Circle->SetCircleChoice(1)                ; // 0:From Begin, 1:From End, 2:Largest Amplitude 
													 Circle->SetCircleType(2)                  ; // 0:Black to White, 1:White to Black 2: Both Black, White 
													 Circle->SetCircleIndex (1)                ; // Circle EdgePoint Index 

													 Circle->SetTolerance(80.0f )            ; // Circle Tolerance 
													 Circle->SetDiameter (C6Diameter)        ; // Circle Diameter 
													 // 										 Circle->SetCircleType(1)                ; // 0:Black to White, 1:White to Black 2: Both Black, White 
													 Circle->OnExecute()                     ;

													 // Circle In Data 기준 새로운 Circle Center 좌표 받아옴 
													 RealC6CirCenter.x = Circle->FCP.x;
													 RealC6CirCenter.y = Circle->FCP.y;

													 OrgC6CirStandEdgeCount = Circle->FCirclePointCount;
													 if(OrgC6CirStandEdgeCount>0){
														 if(OrgC6CirStandPoint!=NULL) delete[] OrgC6CirStandPoint;
														 OrgC6CirStandPoint = new TFPoint[OrgC6CirStandEdgeCount];

														 PreC6CirStandPoint[0].x=0.0f; PreC6CirStandPoint[0].y=0.0f;
														 for(int k=0; k<OrgC6CirStandEdgeCount; k++){
															 if(k>MAX_CIRCLE_EDGEPOINT) break;
															 OrgC6CirStandPoint[k].x = Circle->FCirclePoint[k].x;
															 OrgC6CirStandPoint[k].y = Circle->FCirclePoint[k].y;
															 if(OrgC6CirStandPoint[k].x==0.0f && OrgC6CirStandPoint[k].y==0.0f) C6CirStandEdgeCount++;
															 // TrackLine 자재 상태에 따라서 잘못된 EdgePoint를 찾을경우 대비하여 이전데이터 기준 데이터 복원 
															 if(OrgC6CirStandPoint[k].x!=0.0f && OrgC6CirStandPoint[k].y!=0.0f){
																 // 첫번째는 무조건 데이터 넘겨줌 
																 if(PreC6CirStandPoint[0].x==0.0f && PreC6CirStandPoint[0].y==0.0f){
																	 PreC6CirStandPoint[0].x = OrgC6CirStandPoint[k].x; 
																	 PreC6CirStandPoint[0].y = OrgC6CirStandPoint[k].y; 
																 }
																 // 																 else {
																 // 																	 if(fabs (OrgC6CirStandPoint[k].x-PreC6CirStandPoint[0].x)>TrackLineMargin ||
																 // 																		 fabs(OrgC6CirStandPoint[k].y-PreC6CirStandPoint[0].y)>TrackLineMargin   ){
																 // 																			 OrgC6CirStandPoint[k].x = PreC6CirStandPoint[0].x-0.5;
																 // 																			 OrgC6CirStandPoint[k].y = PreC6CirStandPoint[0].y+0.5;
																 // 
																 // 																			 PreC6CirStandPoint[0].x = OrgC6CirStandPoint[k].x; 
																 // 																			 PreC6CirStandPoint[0].y = OrgC6CirStandPoint[k].y; 
																 // 																	 }
																 // 																	 else {
																 // 																		 PreC6CirStandPoint[0].x = OrgC6CirStandPoint[k].x; 
																 // 																		 PreC6CirStandPoint[0].y = OrgC6CirStandPoint[k].y; 
																 // 																	 }
																 // 																 }
															 }
														 }
														 //C6Circle Grind_Measure Calculate 
														 if(OrgC6CirOutEdgeCount==OrgC6CirStandEdgeCount){
															 double GrindMeaDis=0.0f, TotalGrindMeasure=0.0f, AvgGrindMeasure=0.0f; C6GrindMeasureCount=0;
															 for(int k=0; k<OrgC6CirInEdgeCount; k++){
																 if(OrgC6CirOutPoint[k].x==0.0f || OrgC6CirOutPoint[k].y==0.0f || OrgC6CirStandPoint[k].x==0.0f || OrgC6CirStandPoint[k].y==0.0f){
																	 GrindMeaDis =0.0f;
																 }
																 else {
																	 GrindMeaDis = Math.GetLengthFrPointToPoint(OrgC6CirStandPoint[k],OrgC6CirOutPoint[k]);
																 }

																 if(GrindMeaDis!=0.0f){
																	 TotalGrindMeasure+= GrindMeaDis;
																	 C6GrindMeasureCount++;
																 }
															 }
															 if(C6GrindMeasureCount!=0){
																 AvgGrindMeasure = (TotalGrindMeasure/C6GrindMeasureCount);
																 C6CirGrindMea= AvgGrindMeasure;
															 }
														 }
														 else if(OrgC6CirStandEdgeCount>OrgC6CirOutEdgeCount){ // 연마가 적게되어 실제 TrackLine보다 EdgePoint데이터가 적을경우 
															 double GrindMeaDis=0.0f, TotalGrindMeasure=0.0f, AvgGrindMeasure=0.0f;
															 for(int k=0; k<OrgC6CirStandEdgeCount; k++){
																 if(OrgC6CirOutPoint[k].x==0.0f || OrgC6CirOutPoint[k].y==0.0f || OrgC6CirStandPoint[k].x==0.0f || OrgC6CirStandPoint[k].y==0.0f ){
																	 GrindMeaDis =0.0f;
																 }
																 else {
																	 GrindMeaDis = Math.GetLengthFrPointToPoint(OrgC6CirStandPoint[k],OrgC6CirOutPoint[k]);
																 }

																 if(GrindMeaDis!=0.0f){
																	 TotalGrindMeasure+= GrindMeaDis;
																	 C6GrindMeasureCount++;
																 }
															 }
															 if(C6GrindMeasureCount!=0){
																 AvgGrindMeasure = (TotalGrindMeasure/C6GrindMeasureCount);
																 C6CirGrindMea= AvgGrindMeasure;
															 }
														 }
														 else if(OrgC6CirStandEdgeCount<OrgC6CirOutEdgeCount){
															 double GrindMeaDis=0.0f, TotalGrindMeasure=0.0f, AvgGrindMeasure=0.0f;
															 for(int k=0; k<OrgC6CirStandEdgeCount; k++){
																 if(OrgC6CirOutPoint[k].x==0.0f || OrgC6CirOutPoint[k].y==0.0f || OrgC6CirStandPoint[k].x==0.0f || OrgC6CirStandPoint[k].y==0.0f ){
																	 GrindMeaDis =0.0f;
																 }
																 else {
																	 GrindMeaDis = Math.GetLengthFrPointToPoint(OrgC6CirStandPoint[k],OrgC6CirOutPoint[k]);
																 }

																 if(GrindMeaDis!=0.0f){
																	 TotalGrindMeasure+= GrindMeaDis;
																	 C6GrindMeasureCount++;
																 }
															 }
															 if(C6GrindMeasureCount!=0){
																 AvgGrindMeasure = (TotalGrindMeasure/C6GrindMeasureCount);
																 C6CirGrindMea= AvgGrindMeasure;
															 }
														 }
													 }
												 }
											 }
										 }
										 else if(FInspectMode==Insp_Mark){ // MarkMode 
											 if(IsMarkBtm){ // LTPS 가공량 계산 ==> 연마량 계산 
												 if(OrgC6CirOutEdgeCount!=0 && OrgC6CirInEdgeCount!=0){// 연마량이 존재할경우 가공량 검사를 진행함 
													 GrindMeaDis =0.0f, MinDis =10000.0f; C6GrindMarkCount=0;
													 if(GrindMarkPoint[17].x!=0.0f && GrindMarkPoint[17].y!=0.0f){
														 for(int k=0; k<OrgC6CirOutEdgeCount; k++){
															 if(OrgC6CirOutPoint[k].x==0.0f || OrgC6CirOutPoint[k].y==0.0f) continue;
															 if(GrindMarkPoint[17].x  ==0.0f || GrindMarkPoint[17].y  ==0.0f) continue;

															 GrindMeaDis = Math.GetLength(GrindMarkPoint[17], OrgC6CirOutPoint[k]);
															 if(GrindMeaDis<MinDis){
																 MinDis = GrindMeaDis;
																 C6GrindMarkCount = k;
															 }
														 }
														 // GrindMark기준 수직 포인트 주변값 Avg산출한다 
														 if(C6GrindMarkCount!=0 && C6GrindMarkCount>5){
															 CircleCount=0,TotalCirDis=0.0f,GrindMeaDis=0.0f;
															 for(int k=C6GrindMarkCount-5; k<C6GrindMarkCount+5; k++){
																 if(OrgC6CirOutPoint[k].x==0.0f || OrgC6CirOutPoint[k].y==0.0f) continue;

																 GrindMeaDis = Math.GetLength(GrindMarkPoint[17], OrgC6CirOutPoint[k]);
																 TotalCirDis+= GrindMeaDis;
																 CircleCount++;
															 }
															 if(TotalCirDis!=0.0f && CircleCount!=0){
																 C6CirGrindMea = TotalCirDis/CircleCount;
															 }
														 }
														 // GrindMark기준 수직 평균값 연마량 측정 
														 if(C6GrindMarkCount!=0 && C6GrindMarkCount>5){
															 CircleCount=0,TotalCirDis=0.0f,GrindWidthDis=0.0f;
															 for(int k=C6GrindMarkCount-5; k<C6GrindMarkCount+5; k++){
																 if(OrgC6CirOutPoint[k].x==0.0f && OrgC6CirOutPoint[k].y==0.0f) continue;
																 if(OrgC6CirInPoint [k].x==0.0f && OrgC6CirInPoint [k].y==0.0f) continue;
																 GrindWidthDis = Math.GetLength(OrgC6CirInPoint[k], OrgC6CirOutPoint[k]);
																 TotalCirDis+=   GrindWidthDis;
																 CircleCount++;
															 }
															 if(TotalCirDis!=0.0f && CircleCount!=0){
																 C6CirGrindWd = TotalCirDis/CircleCount;
															 }
														 }
													 }
													 else { // Grind Mark 못 찾았을경우 (가공량 0, 연마량 계산함)
														 for(int k=0; k<OrgC6CirOutEdgeCount; k++){
															 if(OrgC6CirOutPoint[k].x==0.0f || OrgC6CirOutPoint[k].y==0.0f) continue;

															 GrindMarkRectCenter[17].x = GrindMarkRect[17].left + (GrindMarkRect[17].right  - GrindMarkRect[17].left)/2; 
															 GrindMarkRectCenter[17].y = GrindMarkRect[17].top  + (GrindMarkRect[17].bottom - GrindMarkRect[17].top )/2; 

															 GrindMeaDis = Math.GetLength(GrindMarkRectCenter[17], OrgC6CirOutPoint[k]);
															 if(GrindMeaDis<MinDis){
																 MinDis = GrindMeaDis;
																 C6GrindMarkCount = k;
															 }
														 }
														 // GrindMark기준 수직 평균값 연마량 측정 
														 if(C6GrindMarkCount!=0 && C6GrindMarkCount>5){
															 CircleCount=0,TotalCirDis=0.0f,GrindWidthDis=0.0f;
															 for(int k=C6GrindMarkCount-5; k<C6GrindMarkCount+5; k++){
																 if(OrgC6CirOutPoint[k].x==0.0f && OrgC6CirOutPoint[k].y==0.0f) continue;
																 if(OrgC6CirInPoint [k].x==0.0f && OrgC6CirInPoint [k].y==0.0f) continue;
																 GrindWidthDis = Math.GetLength(OrgC6CirInPoint[k], OrgC6CirOutPoint[k]);
																 TotalCirDis+=   GrindWidthDis;
																 CircleCount++;
															 }
															 if(TotalCirDis!=0.0f && CircleCount!=0){
																 C6CirGrindWd = TotalCirDis/CircleCount;
															 }
														 }
														 // GrindMark기준 수직 평균값 연마량 측정 
														 if(C6GrindMarkCount!=0 && C6GrindMarkCount>5){
															 CircleCount=0,TotalCirDis=0.0f,GrindWidthDis=0.0f;
															 for(int k=C6GrindMarkCount-5; k<C6GrindMarkCount+5; k++){
																 if(OrgC6CirOutPoint[k].x==0.0f && OrgC6CirOutPoint[k].y==0.0f) continue;
																 if(OrgC6CirInPoint [k].x==0.0f && OrgC6CirInPoint [k].y==0.0f) continue;
																 GrindWidthDis = Math.GetLength(OrgC6CirInPoint[k], OrgC6CirOutPoint[k]);
																 TotalCirDis+=   GrindWidthDis;
																 CircleCount++;
															 }
															 if(TotalCirDis!=0.0f && CircleCount!=0){
																 C6CirGrindWd = TotalCirDis/CircleCount;
															 }
														 }
													 }
												 }
											 }
											 else          { // EnCap 연마량 계산 
												 if(OrgC6CirInEdgeCount==OrgC6CirOutEdgeCount){//연마량 계산 
													 double OutDis=0.0f, InDis=0.0f, TotalGrindWidth=0.0f, AvgGrindWidth=0.0f; C6GrindWidthCount=0;
													 for(int k=0; k<OrgC6CirInEdgeCount; k++){
														 if(OrgC6CirOutPoint[k].x==0.0f && OrgC6CirOutPoint[k].y==0.0f){
															 OutDis =0.0f;
														 }
														 else {
															 OutDis = Math.GetLengthFrPointToPoint(C6CirCenter,OrgC6CirOutPoint[k]);
														 }

														 if(OrgC6CirInPoint[k].x==0.0f && OrgC6CirInPoint[k].y==0.0f){
															 InDis =0.0f;
														 }
														 else {
															 InDis = Math.GetLengthFrPointToPoint(C6CirCenter,OrgC6CirInPoint[k]);
														 }

														 if(OutDis!=0.0f && InDis!=0.0f){
															 TotalGrindWidth+=(OutDis - InDis);
															 C6GrindWidthCount++;
														 }
													 }
													 if(C6GrindWidthCount!=0){
														 AvgGrindWidth = (TotalGrindWidth/C6GrindWidthCount);
														 C6CirGrindWd = AvgGrindWidth;
													 }
												 }
											 }
										 }
										 // C6Circle 연마량 가공량 검사 시퀀스 종료(TrackMode VS MarkMode)
										 //////////////////////////////////////////////////////////////////////////////////////////////////////

										 // Org Circle데이터중 유호하지 않은 값을 제외한 실제 존재하는 데이터 기준으로 동적 메모리 생성함
										 // Circle Defect검사에 필요한 Edge데이터 값
										 int Count=0;
										 if(OrgC6CirInEdgeCount>0){
											 C6CirInEdgeCount = OrgC6CirInEdgeCount - C6CirInEdgeCount;
											 // 										 C6CirInEdgeCount = OrgC6CirInEdgeCount;
											 if(C6CirInEdgeCount>0){
												 if(C6CirInPoint!=NULL) delete[] C6CirInPoint;
												 C6CirInPoint = new TFPoint[C6CirInEdgeCount];

												 for(int k=0; k<OrgC6CirInEdgeCount; k++){
													 if(k>MAX_CIRCLE_EDGEPOINT) break;
													 if(OrgC6CirInPoint[k].x==0.0f && OrgC6CirInPoint[k].y==0.0f) continue;
													 C6CirInPoint[Count].x = OrgC6CirInPoint[k].x;
													 C6CirInPoint[Count].y = OrgC6CirInPoint[k].y;
													 Count++;
												 }
											 }
											 // Circle 원본 데이터 메모리 삭제
											 if(OrgC6CirInPoint!=NULL) delete[] OrgC6CirInPoint;
										 }
										 // Circle Fitting 결과물 
										 SampleSize = C6CirInEdgeCount*0.75; //0.5~0.8이하로 입력할것
										 DistDevRatio = 0.15; //0.1~0.25 이하로 입력할것
										 // 									Radius = 0;
										 CircleFit->OnRansac(C6CirInPoint,C6CirInEdgeCount,SampleSize,DistDevRatio,&CircleFit6Center,&CirFitDiameter6);

										 if(OrgC6CirOutEdgeCount>0){
											 C6CirOutEdgeCount = OrgC6CirOutEdgeCount - C6CirOutEdgeCount;
											 Count =0;
											 if(C6CirOutEdgeCount>0){
												 if(C6CirOutPoint!=NULL) delete[] C6CirOutPoint;
												 C6CirOutPoint = new TFPoint[C6CirOutEdgeCount];

												 for(int k=0; k<OrgC6CirOutEdgeCount; k++){
													 if(k>MAX_CIRCLE_EDGEPOINT) break;
													 if(OrgC6CirOutPoint[k].x==0.0f && OrgC6CirOutPoint[k].y==0.0f) continue;
													 C6CirOutPoint[Count].x = OrgC6CirOutPoint[k].x;
													 C6CirOutPoint[Count].y = OrgC6CirOutPoint[k].y;
													 Count++;
												 }
											 }
											 // Circle 원본 데이터 메모리 삭제
											 if(OrgC6CirOutPoint!=NULL) delete[] OrgC6CirOutPoint;
										 }
										 if(OrgC6CirStandEdgeCount>0){
											 C6CirStandEdgeCount = OrgC6CirStandEdgeCount - C6CirStandEdgeCount;
											 // 										 C6CirStandEdgeCount = OrgC6CirStandEdgeCount;
											 Count =0;
											 if(C6CirStandEdgeCount>0){
												 if(C6CirStandPoint!=NULL) delete[] C6CirStandPoint;
												 C6CirStandPoint = new TFPoint[C6CirStandEdgeCount];

												 for(int k=0; k<OrgC6CirStandEdgeCount; k++){
													 if(k>MAX_CIRCLE_EDGEPOINT) break;
													 if(OrgC6CirStandPoint[k].x==0.0f && OrgC6CirStandPoint[k].y==0.0f) continue;
													 C6CirStandPoint[Count].x = OrgC6CirStandPoint[k].x;
													 C6CirStandPoint[Count].y = OrgC6CirStandPoint[k].y;
													 Count++;
												 }
											 }
											 // Circle 원본 데이터 메모리 삭제
											 if(OrgC6CirStandPoint!=NULL) delete[] OrgC6CirStandPoint;
										 }
										 LogUnit.SetLog(L"Circle_6_Insp_End");
										 // Circle 영역 꽃박리, 원형박리 검출 목적 시퀀스(EnCap)
										 // 정식 명칭은 몰라서.....일단 Crack으로 정함 
										 if(!IsMarkBtm && BrokenThresHold!=0){
											 if(CirFitDiameter6!=0.0f && CircleFit6Center.x!=0.0f && CircleFit6Center.y!=0.0f){ // FAVION Circle Fitting 성공시 박리검사 진행 
												 Circle->GImage = &RotateBrokenImg;                                             //Binary Image 넘겨줌 

												 Circle->SetCenterXY(CircleFit6Center.x,CircleFit6Center.y)      ;
												 Circle->SetTolerance((dEdgeToTrapLineDis/2) -CirOffsetMargin)   ; // Circle Tolerance 
												 Circle->SetDiameter ((CirFitDiameter6-(dEdgeToTrapLineDis/2))*2); // Circle Diameter 
												 Circle->SetCircleChoice(0)                                      ; // 0:From Begin, 1:From End, 2:Largest Amplitude 
												 Circle->SetCircleType  (2)                                      ; // 0:Black to White, 1:White to Black 2: Both Black, White 
												 Circle->SetCircleIndex (0)                                      ; // Circle EdgePoint Index 
												 Circle->OnExecute(true)                                         ;
												 CrackCirDiameter6 = (CirFitDiameter6-(dEdgeToTrapLineDis/2))+((dEdgeToTrapLineDis/2) -CirOffsetMargin);

												 C6CirInCrackCount = Circle->FCirclePointCount;

												 if(C6CirInCrackCount>0){
													 if(C6CirInCrackPoint!=NULL) delete[] C6CirInCrackPoint;
													 C6CirInCrackPoint = new TFPoint[C6CirInCrackCount];

													 for(int k=0; k<C6CirInCrackCount; k++){
														 if(k>MAX_CIRCLE_EDGEPOINT) break;
														 C6CirInCrackPoint[k].x = Circle->FCirclePoint[k].x;
														 C6CirInCrackPoint[k].y = Circle->FCirclePoint[k].y;
													 }
												 }
											 }
										 }
									 }

									 // 개별 Circle Data 교차점 기준 직선영역의 새로운 Btm영역 BtmOutLine, BtmInLine 찾는다 
									 // Circle1과 Circle2 사이의 직선영역 검사
									 // BMDT Cell은 특정 영역 직선구간 연마를 가공하지 않음 
									 const int BtmMargin =50; const int LeftMargin =30; const int RightMargin =30;
									 if(BtmEdgePoint[0].x!=0 && BtmEdgePoint[0].y!=0 && BtmEdgePoint[1].x!=0 && BtmEdgePoint[1].y!=0 &&FInspectMode==Insp_Surface){ // BTM
										 LogUnit.SetLog(L"shRectC_Btm1_Insp_Start");

										 if(BtmEdgeThresHold==0)    {SingleLine->GImage = &RotateImg      ;  SingleLine->FThreshold =5 ;}
										 else                       {SingleLine->GImage = &RotateBinaryImg;  SingleLine->FThreshold =10;}

										 // BtmOutLine Search 
										 SingleLine->IRoi->SetOrgX  (BtmEdgePoint[0].x+50                       );
										 SingleLine->IRoi->SetOrgY  (BtmEdgePoint[0].y - BtmMargin              );
										 SingleLine->IRoi->SetWidth ((BtmEdgePoint[1].x - BtmEdgePoint[0].x)-100);
										 SingleLine->IRoi->SetHeight(100                                        );
										 if(BtmEdgePoint[0].x+100<=0 || (BtmEdgePoint[0].y-BtmMargin<=0) || ((BtmEdgePoint[1].x-BtmEdgePoint[0].x)-200)<=0 ) return false;

										 SingleLine->SetOrientation(orSouth);
										 // 									 SingleLine->FIncrement =1   ;
										 SingleLine->SetFindLineId(0);
										 SingleLine->FThreshold =5;

										 if(IsMarkBtm) {SingleLine->FIncrement =1 ; SingleLine->SetEdgeType(1);}  //White To Black 
										 else          {SingleLine->FIncrement =10; SingleLine->SetEdgeType(1);}  //White To Black 

										 SingleLine->OnExecute();
										 BtmOutLine[0].FP0 = SingleLine->GetResultP0();
										 BtmOutLine[0].FP1 = SingleLine->GetResultP1();

										 // BtmOutLine Real EdgePoint 추출함 
										 OrgBtm1OutEdgeCount = SingleLine->FEdgePointCount;
										 if(OrgBtm1OutEdgeCount>0){
											 if(OrgBtm1OutPoint!=NULL) delete[] OrgBtm1OutPoint;
											 OrgBtm1OutPoint = new TFPoint[OrgBtm1OutEdgeCount];

											 for(int k=0; k<OrgBtm1OutEdgeCount; k++){
												 if(k>MAX_CIRCLE_EDGEPOINT) break;
												 OrgBtm1OutPoint[k].x = SingleLine->FEdgePoint[k].x;
												 OrgBtm1OutPoint[k].y = SingleLine->FEdgePoint[k].y;
											 }
										 }

										 // BtmInLine Search 
										 if(CirGrindInThresHold==0) {Circle->GImage = &RotateImg             ; SingleLine->FThreshold =5 ;} //Org Image 넘겨줌 
										 else                       {Circle->GImage = &RotateGrindInBinaryImg; SingleLine->FThreshold =10;}//Binary Image 넘겨줌 

										 SingleLine->SetEdgeType(0);  //Black To White  
										 SingleLine->OnExecute();
										 BtmInLine[0].FP0 = SingleLine->GetResultP0();
										 BtmInLine[0].FP1 = SingleLine->GetResultP1();

										 // BtmInLine Real EdgePoint 추출함 
										 OrgBtm1InEdgeCount = SingleLine->FEdgePointCount;
										 if(OrgBtm1InEdgeCount>0){
											 if(OrgBtm1InPoint!=NULL) delete[] OrgBtm1InPoint;
											 OrgBtm1InPoint = new TFPoint[OrgBtm1InEdgeCount];

											 for(int k=0; k<OrgBtm1InEdgeCount; k++){
												 if(k>MAX_CIRCLE_EDGEPOINT) break;
												 OrgBtm1InPoint[k].x = SingleLine->FEdgePoint[k].x;
												 OrgBtm1InPoint[k].y = SingleLine->FEdgePoint[k].y;
											 }
										 }

										 // Grind Mark 기준 연마량 계산 
										 if(IsMarkBtm){ // LT검사시 가공량 측정함 
											 if(FInspectMode==Insp_Track){ // TrackMode TrackLine기준 가공량 측정 
												 if(CirGrindMeaThresHold!=0){
													 // 연마량 계산  
													 if((fabs(BtmOutLine[0].FP0.y - BtmOutLine[0].FP1.y))>1
														 ||(fabs(BtmInLine[0].FP0.y - BtmInLine[0].FP1.y))>1){
															 BtmGrindWidth1 = BtmOutLine[0].FP0.y - BtmInLine[0].FP0.y; 
													 }
													 else{
														 BtmGrindWidth1 = Math.GetLengthFrLineToPoint(BtmOutLine[0].FP0, BtmOutLine[0].FP1, BtmInLine[0].FP0);
													 }

													 SingleLine->GImage = &RotateGrindBinaryImg; //Binary Image 넘겨줌 
													 SingleLine->SetEdgeType(1);  //White To Black 
													 SingleLine->SetFindLineId(0);
													 SingleLine->OnExecute();

													 BtmStandLine[0].FP0 = SingleLine->GetResultP0();
													 BtmStandLine[0].FP1 = SingleLine->GetResultP1();
													 // 가공량 계산 
													 BtmGrindMeasure1 = Math.GetLengthFrLineToPoint(BtmOutLine[0].FP0, BtmOutLine[0].FP1, BtmStandLine[0].FP0);
												 }
											 }
											 else if(FInspectMode==Insp_Mark){
												 // GrindMark 상관없이 연마량 측정
												 if(OrgBtm1InEdgeCount>10 && OrgBtm1OutEdgeCount>10 && (OrgBtm1InEdgeCount==OrgBtm1OutEdgeCount)){
													 // 가공량,연마량 측정 전 데이터 존재시 가상GrindMark 생성한다 
													 if(GrindMarkPoint[2].x!=0.0f && GrindMarkPoint[2].y!=0.0f){
														 GrindMarkPoint[4].x     = OrgBtm1InPoint[OrgBtm1InEdgeCount-10].x ;
														 GrindMarkPoint[4].y     = GrindMarkPoint[2].y                     ;
														 GrindMarkRect [4].left  = GrindMarkPoint[4].x    - GrindMarkRange ;  
														 GrindMarkRect [4].top   = GrindMarkPoint[4].y    - GrindMarkRange ;  
														 GrindMarkRect [4].right = GrindMarkRect [4].left + GrindMarkLength;  
														 GrindMarkRect [4].bottom= GrindMarkRect [4].top  + GrindMarkLength;  
													 }

													 // GrindMark[2] 가공량,연마량 측정 
													 ////////////////////////////////////////////////////////////////////////////////////////////////////
													 if(GrindMarkPoint[2].x!=0.0f && GrindMarkPoint[2].y!=0.0f){ //GrindMark 찾았을경우 검사 시퀀스 가공량 측정 
														 GrindMeaDis =0.0f, MinDis =10000.0f;  Btm1GrindMarkCount=0;
														 for(int k=0; k<OrgBtm1OutEdgeCount; k++){
															 if(OrgBtm1OutPoint[k].x==0.0f || OrgBtm1OutPoint[k].y==0.0f) continue;
															 if(GrindMarkPoint[2].x ==0.0f || GrindMarkPoint[2].y ==0.0f) continue;

															 GrindMeaDis = Math.GetLength(GrindMarkPoint[2], OrgBtm1OutPoint[k]);
															 if(GrindMeaDis<MinDis){
																 MinDis = GrindMeaDis;
																 Btm1GrindMarkCount = k;
															 }
														 }
														 // GrindMark기준 수직 포인트 주변값 Avg산출한다 
														 if(Btm1GrindMarkCount!=0 && Btm1GrindMarkCount>5 && (Btm1GrindMarkCount+5)<OrgBtm1OutEdgeCount){
															 CircleCount=0,TotalCirDis=0.0f,GrindMeaDis=0.0f;
															 for(int k=Btm1GrindMarkCount-5; k<Btm1GrindMarkCount+5; k++){
																 if(OrgBtm1OutPoint[k].x==0.0f || OrgBtm1OutPoint[k].y==0.0f) continue;

																 GrindMeaDis = Math.GetLength(GrindMarkPoint[2], OrgBtm1OutPoint[k]);
																 TotalCirDis+= GrindMeaDis;
																 CircleCount++;
															 }
															 if(TotalCirDis!=0.0f && CircleCount!=0){
																 BtmGrindMeasure1 = TotalCirDis/CircleCount;
															 }
														 }
														 // GrindMark기준 수직 평균값 연마량 측정 
														 if(Btm1GrindMarkCount!=0 && Btm1GrindMarkCount>5 && (Btm1GrindMarkCount+5)<OrgBtm1OutEdgeCount){
															 CircleCount=0,TotalCirDis=0.0f,GrindWidthDis=0.0f;
															 for(int k=Btm1GrindMarkCount-5; k<Btm1GrindMarkCount+5; k++){
																 if(OrgBtm1OutPoint[k].x==0.0f && OrgBtm1OutPoint[k].y==0.0f) continue;
																 if(OrgBtm1InPoint [k].x==0.0f && OrgBtm1InPoint [k].y==0.0f) continue;
																 GrindWidthDis = Math.GetLength(OrgBtm1InPoint[k], OrgBtm1OutPoint[k]);
																 TotalCirDis+=   GrindWidthDis;
																 CircleCount++;
															 }
															 if(TotalCirDis!=0.0f && CircleCount!=0){
																 BtmGrindWidth1 = TotalCirDis/CircleCount;
															 }
														 }
													 }
													 else {  //GrindMark 못 찾았을경우 검사 시퀀스 (가공량: 0, 연마량 측정)
														 GrindMeaDis =0.0f, MinDis =10000.0f;  Btm1GrindMarkCount=0;
														 for(int k=0; k<OrgBtm1OutEdgeCount; k++){
															 if(OrgBtm1OutPoint[k].x==0.0f || OrgBtm1OutPoint[k].y==0.0f) continue;

															 GrindMarkRectCenter[2].x = GrindMarkRect[2].left + (GrindMarkRect[2].right  - GrindMarkRect[2].left)/2; 
															 GrindMarkRectCenter[2].y = GrindMarkRect[2].top  + (GrindMarkRect[2].bottom - GrindMarkRect[2].top )/2; 

															 GrindMeaDis = Math.GetLength(GrindMarkRectCenter[2], OrgBtm1OutPoint[k]);
															 if(GrindMeaDis<MinDis){
																 MinDis = GrindMeaDis;
																 Btm1GrindMarkCount = k;
															 }
														 }
														 // GrindMark기준 수직 평균값 연마량 측정 
														 if(Btm1GrindMarkCount!=0 && Btm1GrindMarkCount>5 &&(Btm1GrindMarkCount+5<OrgBtm1OutEdgeCount)){
															 CircleCount=0,TotalCirDis=0.0f,GrindWidthDis=0.0f;
															 for(int k=Btm1GrindMarkCount-5; k<Btm1GrindMarkCount+5; k++){
																 if(OrgBtm1OutPoint[k].x==0.0f && OrgBtm1OutPoint[k].y==0.0f) continue;
																 if(OrgBtm1InPoint [k].x==0.0f && OrgBtm1InPoint [k].y==0.0f) continue;
																 GrindWidthDis = Math.GetLength(OrgBtm1InPoint[k], OrgBtm1OutPoint[k]);
																 TotalCirDis+=   GrindWidthDis;
																 CircleCount++;
															 }
															 if(TotalCirDis!=0.0f && CircleCount!=0){
																 BtmGrindWidth1 = TotalCirDis/CircleCount;
															 }
														 }
													 }
													 ////////////////////////////////////////////////////////////////////////////////////////////////////

													 // GrindMark[4] 가공량,연마량 측정 
													 ////////////////////////////////////////////////////////////////////////////////////////////////////
													 if(GrindMarkPoint[4].x!=0.0f && GrindMarkPoint[4].y!=0.0f){ //GrindMark 찾았을경우 검사 시퀀스 가공량 측정 
														 GrindMeaDis =0.0f, MinDis =10000.0f;  Btm1GrindMarkCount=0;
														 for(int k=0; k<OrgBtm1OutEdgeCount; k++){
															 if(OrgBtm1OutPoint[k].x==0.0f || OrgBtm1OutPoint[k].y==0.0f) continue;
															 if(GrindMarkPoint[4].x ==0.0f || GrindMarkPoint[4].y ==0.0f) continue;

															 GrindMeaDis = Math.GetLength(GrindMarkPoint[4], OrgBtm1OutPoint[k]);
															 if(GrindMeaDis<MinDis){
																 MinDis = GrindMeaDis;
																 Btm1GrindMarkCount = k;
															 }
														 }
														 // GrindMark기준 수직 포인트 주변값 Avg산출한다 
														 if(Btm1GrindMarkCount!=0 && Btm1GrindMarkCount>5 && (Btm1GrindMarkCount+5)<OrgBtm1OutEdgeCount){
															 CircleCount=0,TotalCirDis=0.0f,GrindMeaDis=0.0f;
															 for(int k=Btm1GrindMarkCount-5; k<Btm1GrindMarkCount+5; k++){
																 if(OrgBtm1OutPoint[k].x==0.0f || OrgBtm1OutPoint[k].y==0.0f) continue;

																 GrindMeaDis = Math.GetLength(GrindMarkPoint[4], OrgBtm1OutPoint[k]);
																 TotalCirDis+= GrindMeaDis;
																 CircleCount++;
															 }
															 if(TotalCirDis!=0.0f && CircleCount!=0){
																 BtmGrindMeasure3 = TotalCirDis/CircleCount;
															 }
														 }
														 // GrindMark기준 수직 평균값 연마량 측정 
														 if(Btm1GrindMarkCount!=0 && Btm1GrindMarkCount>5 && (Btm1GrindMarkCount+5)<OrgBtm1OutEdgeCount){
															 CircleCount=0,TotalCirDis=0.0f,GrindWidthDis=0.0f;
															 for(int k=Btm1GrindMarkCount-5; k<Btm1GrindMarkCount+5; k++){
																 if(OrgBtm1OutPoint[k].x==0.0f && OrgBtm1OutPoint[k].y==0.0f) continue;
																 if(OrgBtm1InPoint [k].x==0.0f && OrgBtm1InPoint [k].y==0.0f) continue;
																 GrindWidthDis = Math.GetLength(OrgBtm1InPoint[k], OrgBtm1OutPoint[k]);
																 TotalCirDis+=   GrindWidthDis;
																 CircleCount++;
															 }
															 if(TotalCirDis!=0.0f && CircleCount!=0){
																 BtmGrindWidth3 = TotalCirDis/CircleCount;
															 }
														 }
													 }
													 else {  //GrindMark 못 찾았을경우 검사 시퀀스 (가공량: 0, 연마량 측정)
														 GrindMeaDis =0.0f, MinDis =10000.0f;  Btm1GrindMarkCount=0;
														 for(int k=0; k<OrgBtm1OutEdgeCount; k++){
															 if(OrgBtm1OutPoint[k].x==0.0f || OrgBtm1OutPoint[k].y==0.0f) continue;

															 GrindMarkRectCenter[4].x = GrindMarkRect[4].left + (GrindMarkRect[4].right  - GrindMarkRect[4].left)/2; 
															 GrindMarkRectCenter[4].y = GrindMarkRect[4].top  + (GrindMarkRect[4].bottom - GrindMarkRect[4].top )/2; 

															 GrindMeaDis = Math.GetLength(GrindMarkRectCenter[4], OrgBtm1OutPoint[k]);
															 if(GrindMeaDis<MinDis){
																 MinDis = GrindMeaDis;
																 Btm1GrindMarkCount = k;
															 }
														 }
														 // GrindMark기준 수직 평균값 연마량 측정 
														 if(Btm1GrindMarkCount!=0 && Btm1GrindMarkCount>5 &&(Btm1GrindMarkCount+5<OrgBtm1OutEdgeCount)){
															 CircleCount=0,TotalCirDis=0.0f,GrindWidthDis=0.0f;
															 for(int k=Btm1GrindMarkCount-5; k<Btm1GrindMarkCount+5; k++){
																 if(OrgBtm1OutPoint[k].x==0.0f && OrgBtm1OutPoint[k].y==0.0f) continue;
																 if(OrgBtm1InPoint [k].x==0.0f && OrgBtm1InPoint [k].y==0.0f) continue;
																 GrindWidthDis = Math.GetLength(OrgBtm1InPoint[k], OrgBtm1OutPoint[k]);
																 TotalCirDis+=   GrindWidthDis;
																 CircleCount++;
															 }
															 if(TotalCirDis!=0.0f && CircleCount!=0){
																 BtmGrindWidth3 = TotalCirDis/CircleCount;
															 }
														 }
													 }
													 ////////////////////////////////////////////////////////////////////////////////////////////////////
												 }

												 // 가공량 측정 
												 // 											 if(BtmGrindWidth1!=0 && GrindMarkPoint[2].x!=0.0f && GrindMarkPoint[2].y!=0.0f){ // MarkMode GrindMark중심 좌표 기준 가공량 측정 
												 // 												 if(fabs(BtmOutLine[0].FP0.y - BtmOutLine[0].FP1.y)>2){
												 // // 													 BtmGrindWidth1   = (BtmOutLine[0].FP0.y  - GrindMarkPoint[2].y) - (BtmInLine[0].FP0.y - GrindMarkPoint[2].y);
												 // 													 BtmGrindMeasure1 = BtmOutLine[0].FP0.y  - GrindMarkPoint[2].y; 
												 // 												 }
												 // 												 else {
												 // 													 BtmGrindMeasure1 = Math.GetLengthFrLineToPoint(BtmOutLine[0].FP0, BtmOutLine[0].FP1, GrindMarkPoint[2]);
												 // // 													 BtmGrindWidth1   = BtmGrindMeasure1 - Math.GetLengthFrLineToPoint(BtmInLine[0].FP0, BtmInLine[0].FP1, GrindMarkPoint[2]);
												 // 												 }
												 // 											 }
											 }
										 }
										 else { // ENCAP 연마량 데이터만 계측함
											 if(BtmOutLine[0].FP0.x!=0.0f && BtmOutLine[0].FP0.y!=0.0f && BtmOutLine[0].FP1.x!=0.0f && BtmOutLine[0].FP1.y!=0.0f &&
												 BtmInLine [0].FP0.x!=0.0f && BtmInLine [0].FP0.y!=0.0f && BtmInLine [0].FP1.x!=0.0f && BtmInLine [0].FP1.y!=0.0f ){
													 // 연마량 계산  
													 if((fabs(BtmOutLine[0].FP0.y - BtmOutLine[0].FP1.y))>1
														 ||(fabs(BtmInLine[0].FP0.y - BtmInLine[0].FP1.y))>1){
															 BtmGrindWidth1 = BtmOutLine[0].FP0.y - BtmInLine[0].FP0.y; 
													 }
													 else{
														 BtmGrindWidth1 = Math.GetLengthFrLineToPoint(BtmOutLine[0].FP0, BtmOutLine[0].FP1, BtmInLine[0].FP0);
													 }
											 }
										 }
										 // 동적 생성한 데이터를 지운다 
										 if(OrgBtm1InPoint !=NULL) delete[] OrgBtm1InPoint;
										 if(OrgBtm1OutPoint!=NULL) delete[] OrgBtm1OutPoint;
										 LogUnit.SetLog(L"shRectC_Btm1_Insp_End");
									 }
									 // Circle2과 Circle3 사이의 직선영역 검사 
									 if(BtmEdgePoint[2].x!=0 && BtmEdgePoint[2].y!=0 && BtmEdgePoint[3].x!=0 && BtmEdgePoint[3].y!=0 ){ //RIGHT
										 LogUnit.SetLog(L"shRectC_Btm2_Insp_Start");

										 if(BtmEdgeThresHold==0)   {SingleLine->GImage = &RotateImg      ;  SingleLine->FThreshold =5 ;}
										 else                      {SingleLine->GImage = &RotateBinaryImg;  SingleLine->FThreshold =10;}

										 SingleLine->IRoi->SetOrgX  (BtmEdgePoint[3].x-RightMargin        ); 
										 SingleLine->IRoi->SetOrgY  (BtmEdgePoint[3].y                    );
										 SingleLine->IRoi->SetWidth (100                                  );
										 SingleLine->IRoi->SetHeight(BtmEdgePoint[2].y - BtmEdgePoint[3].y);

										 SingleLine->SetOrientation(orEast);
										 SingleLine->FIncrement =10;
										 SingleLine->SetFindLineId(0);
										 SingleLine->FThreshold =5;

										 if(IsMarkBtm) SingleLine->SetEdgeType(1);  //White To Black 
										 else          SingleLine->SetEdgeType(1);  //White To Black 

										 SingleLine->OnExecute();

										 BtmOutLine[1].FP0 = SingleLine->GetResultP0();
										 BtmOutLine[1].FP1 = SingleLine->GetResultP1();

										 // BtmInLine Search 
										 SingleLine->SetEdgeType(0);  //Black To White  
										 SingleLine->OnExecute();
										 BtmInLine[1].FP0 = SingleLine->GetResultP0();
										 BtmInLine[1].FP1 = SingleLine->GetResultP1();

										 // 연마폭 계산  
										 BtmGrindWidth2 = Math.GetLengthFrLineToPoint(BtmOutLine[1].FP0, BtmOutLine[1].FP1, BtmInLine[1].FP0);

										 //연마량 계산 
										 if(IsMarkBtm){
											 if(CirGrindMeaThresHold!=0){
												 SingleLine->GImage = &RotateGrindBinaryImg; //Binary Image 넘겨줌 
												 SingleLine->SetEdgeType(1);  //White To Black 
												 SingleLine->SetFindLineId(0);
												 SingleLine->OnExecute();

												 BtmStandLine[1].FP0 = SingleLine->GetResultP0();
												 BtmStandLine[1].FP1 = SingleLine->GetResultP1();
												 //연마량 계산 
												 BtmGrindMeasure2 = Math.GetLengthFrLineToPoint(BtmOutLine[1].FP0, BtmOutLine[1].FP1, BtmStandLine[1].FP0);
											 }
										 }
										 LogUnit.SetLog(L"shRectC_Btm2_Insp_End");
									 }
									 // Circl31과 Circle4 사이의 직선영역 검사 
									 if(BtmEdgePoint[4].x!=0 && BtmEdgePoint[4].y!=0 && BtmEdgePoint[5].x!=0 && BtmEdgePoint[5].y!=0 ){ //BTM
										 LogUnit.SetLog(L"shRectC_Btm3_Insp_Start");

										 if(BtmEdgeThresHold==0)    {SingleLine->GImage = &RotateImg      ;  SingleLine->FThreshold =5 ;}
										 else                       {SingleLine->GImage = &RotateBinaryImg;  SingleLine->FThreshold =10;}

										 // Trench Width 길이가 클경우 EdgePoint 간격을 조밀하게 검사진행시 시간 Delay 가능성 발생함 
										 // 연마량 측정 목적이므로 검사 ROI영역을 줄여준다 
										 int TrenchWidth=0;
										 TrenchWidth = (BtmEdgePoint[5].x>BtmEdgePoint[4].x) ? (BtmEdgePoint[5].x - BtmEdgePoint[4].x):(BtmEdgePoint[4].x - BtmEdgePoint[5].x);

										 if(TrenchWidth>TrenchWidthMargin){ // Trench Width 클경우 
											 SingleLine->IRoi->SetOrgX  (BtmEdgePoint[4].x+200                       );
											 SingleLine->IRoi->SetOrgY  (BtmEdgePoint[4].y - BtmMargin               );
											 SingleLine->IRoi->SetWidth ((BtmEdgePoint[5].x - BtmEdgePoint[4].x)-400 );
											 SingleLine->IRoi->SetHeight(100                                         );
											 if(BtmEdgePoint[4].x+500<=0 || (BtmEdgePoint[4].y-BtmMargin<=0) || ((BtmEdgePoint[5].x-BtmEdgePoint[4].x)-1000)<=0 ) return false;
										 }
										 else {                             // Trench Width 작을 경우 
											 SingleLine->IRoi->SetOrgX  (BtmEdgePoint[4].x+100                      );
											 SingleLine->IRoi->SetOrgY  (BtmEdgePoint[4].y - BtmMargin              );
											 SingleLine->IRoi->SetWidth ((BtmEdgePoint[5].x - BtmEdgePoint[4].x)-200);
											 SingleLine->IRoi->SetHeight(100                                        );
											 if(BtmEdgePoint[4].x+100<=0 || (BtmEdgePoint[4].y-BtmMargin<=0) || ((BtmEdgePoint[5].x-BtmEdgePoint[4].x)-200)<=0 ) return false;
										 }

										 SingleLine->SetOrientation(orSouth);
										 SingleLine->SetFindLineId(0);
										 SingleLine->FThreshold =5;

										 if(IsMarkBtm) {
											 SingleLine->SetEdgeType(1);  //White To Black 
											 SingleLine->FIncrement =1 ;
										 }
										 else          {
											 SingleLine->SetEdgeType(1);  //White To Black 
											 SingleLine->FIncrement =20;
										 }

										 SingleLine->OnExecute();
										 BtmOutLine[2].FP0 = SingleLine->GetResultP0();
										 BtmOutLine[2].FP1 = SingleLine->GetResultP1();

										 // BtmOutLine Real EdgePoint 추출함 
										 OrgBtm3OutEdgeCount = SingleLine->FEdgePointCount;
										 if(OrgBtm3OutEdgeCount>0){
											 if(OrgBtm3OutPoint!=NULL) delete[] OrgBtm3OutPoint;
											 OrgBtm3OutPoint = new TFPoint[OrgBtm3OutEdgeCount];

											 for(int k=0; k<OrgBtm3OutEdgeCount; k++){
												 if(k>MAX_CIRCLE_EDGEPOINT) break;
												 OrgBtm3OutPoint[k].x = SingleLine->FEdgePoint[k].x;
												 OrgBtm3OutPoint[k].y = SingleLine->FEdgePoint[k].y;
											 }
										 }

										 // BtmInLine Search 

										 if(CirGrindInThresHold==0) {Circle->GImage = &RotateImg             ; SingleLine->FThreshold =5 ;} //Org Image 넘겨줌 
										 else                       {Circle->GImage = &RotateGrindInBinaryImg; SingleLine->FThreshold =10;}//Binary Image 넘겨줌 

										 SingleLine->SetEdgeType(0);  //Black To White  
										 SingleLine->OnExecute();
										 BtmInLine[2].FP0 = SingleLine->GetResultP0();
										 BtmInLine[2].FP1 = SingleLine->GetResultP1();

										 // BtmInLine Real EdgePoint 추출함 
										 OrgBtm3InEdgeCount = SingleLine->FEdgePointCount;
										 if(OrgBtm3InEdgeCount>0){
											 if(OrgBtm3InPoint!=NULL)  delete[] OrgBtm3InPoint;
											 OrgBtm3InPoint = new TFPoint[OrgBtm3InEdgeCount];

											 for(int k=0; k<OrgBtm3InEdgeCount; k++){
												 if(k>MAX_CIRCLE_EDGEPOINT) break;
												 OrgBtm3InPoint[k].x = SingleLine->FEdgePoint[k].x;
												 OrgBtm3InPoint[k].y = SingleLine->FEdgePoint[k].y;
											 }
										 }

										 // Grind Mark 기준 연마량 계산 
										 if(IsMarkBtm){ // LT검사시 가공량 측정함 
											 if(FInspectMode==Insp_Track){ // TrackMode TrackLine기준 가공량 측정 
												 if(CirGrindMeaThresHold!=0){
													 // 연마폭 계산  
													 BtmGrindWidth5 = Math.GetLengthFrLineToPoint(BtmOutLine[2].FP0, BtmOutLine[2].FP1, BtmInLine[2].FP0);

													 SingleLine->GImage = &RotateGrindBinaryImg; //Binary Image 넘겨줌 
													 SingleLine->SetEdgeType(1);  //White To Black 
													 SingleLine->SetFindLineId(0);
													 SingleLine->OnExecute();

													 BtmStandLine[2].FP0 = SingleLine->GetResultP0();
													 BtmStandLine[2].FP1 = SingleLine->GetResultP1();
													 //연마량 계산 
													 BtmGrindMeasure5 = Math.GetLengthFrLineToPoint(BtmOutLine[2].FP0, BtmOutLine[2].FP1, BtmStandLine[2].FP0);
												 }
											 }
											 else if(FInspectMode==Insp_Mark){
												 // GrindMark 상관없이 연마량 측정
												 if(OrgBtm3OutEdgeCount!=0 && OrgBtm3InEdgeCount!=0 && (OrgBtm3OutEdgeCount==OrgBtm3InEdgeCount)){ // 연마량이 존재할경우 가공량 검사를 진행함 
													 // 가공량,연마량 측정 전 데이터 존재시 가상GrindMark 생성한다 
													 if(GrindMarkPoint[9].x!=0.0f && GrindMarkPoint[9].y!=0.0f){
														 // GrindMark 8
														 GrindMarkPoint[8].x     = OrgBtm3InPoint[7].x ;
														 GrindMarkPoint[8].y     = GrindMarkPoint[9].y                     ;
														 GrindMarkRect [8].left  = GrindMarkPoint[8].x    - GrindMarkRange ;  
														 GrindMarkRect [8].top   = GrindMarkPoint[8].y    - GrindMarkRange ;  
														 GrindMarkRect [8].right = GrindMarkRect [8].left + GrindMarkLength;  
														 GrindMarkRect [8].bottom= GrindMarkRect [8].top  + GrindMarkLength;  

														 // GrindMark 9
														 GrindMarkPoint[10].x     = OrgBtm3InPoint[OrgBtm3InEdgeCount-7].x   ;
														 GrindMarkPoint[10].y     = GrindMarkPoint[9 ].y                     ;
														 GrindMarkRect [10].left  = GrindMarkPoint[10].x    - GrindMarkRange ;  
														 GrindMarkRect [10].top   = GrindMarkPoint[10].y    - GrindMarkRange ;  
														 GrindMarkRect [10].right = GrindMarkRect [10].left + GrindMarkLength;  
														 GrindMarkRect [10].bottom= GrindMarkRect [10].top  + GrindMarkLength;  
													 }

													 // GrindMark[8] 가공량,연마량 측정 
													 ////////////////////////////////////////////////////////////////////////////////////////////////////
													 if(GrindMarkPoint[8].x!=0.0f && GrindMarkPoint[8].y!=0.0f){ //GrindMark 찾았을경우 검사 시퀀스 
														 GrindMeaDis =0.0f, MinDis =10000.0f;  Btm3GrindMarkCount=0;

														 for(int k=0; k<OrgBtm3OutEdgeCount; k++){
															 if(OrgBtm3OutPoint[k].x==0.0f || OrgBtm3OutPoint[k].y==0.0f) continue;
															 if(GrindMarkPoint[8].x ==0.0f || GrindMarkPoint[8].y ==0.0f) continue;

															 GrindMeaDis = Math.GetLength(GrindMarkPoint[8], OrgBtm3OutPoint[k]);
															 if(GrindMeaDis<MinDis){
																 MinDis = GrindMeaDis;
																 Btm3GrindMarkCount = k;
															 }
														 }
														 // GrindMark기준 수직 포인트 주변값 Avg산출한다 
														 if(Btm3GrindMarkCount!=0 && Btm3GrindMarkCount>5 && (Btm3GrindMarkCount+5)<OrgBtm3OutEdgeCount){
															 CircleCount=0,TotalCirDis=0.0f,GrindMeaDis=0.0f;
															 for(int k=Btm3GrindMarkCount-5; k<Btm3GrindMarkCount+5; k++){
																 if(OrgBtm3OutPoint[k].x==0.0f || OrgBtm3OutPoint[k].y==0.0f) continue;

																 GrindMeaDis = Math.GetLength(GrindMarkPoint[8], OrgBtm3OutPoint[k]);
																 TotalCirDis+= GrindMeaDis;
																 CircleCount++;
															 }
															 if(TotalCirDis!=0.0f && CircleCount!=0){
																 BtmGrindMeasure4 = TotalCirDis/CircleCount;
															 }
														 }
														 // GrindMark기준 수직 평균값 연마량 측정 
														 if(Btm3GrindMarkCount!=0 && Btm3GrindMarkCount>5 && (Btm3GrindMarkCount+5)<OrgBtm3OutEdgeCount){
															 CircleCount=0,TotalCirDis=0.0f,GrindWidthDis=0.0f;
															 for(int k=Btm3GrindMarkCount-5; k<Btm3GrindMarkCount+5; k++){
																 if(OrgBtm3OutPoint[k].x==0.0f && OrgBtm3OutPoint[k].y==0.0f) continue;
																 if(OrgBtm3InPoint [k].x==0.0f && OrgBtm3InPoint [k].y==0.0f) continue;
																 GrindWidthDis = Math.GetLength(OrgBtm3InPoint[k], OrgBtm3OutPoint[k]);
																 TotalCirDis+=   GrindWidthDis;
																 CircleCount++;
															 }
															 if(TotalCirDis!=0.0f && CircleCount!=0){
																 BtmGrindWidth4 = TotalCirDis/CircleCount;
															 }
														 }
													 }
													 else { //GrindMark 못 찾았을경우 검사 시퀀스 (가공량: 0, 연마량 측정)
														 GrindMeaDis =0.0f, MinDis =10000.0f;  Btm3GrindMarkCount=0;
														 for(int k=0; k<OrgBtm3OutEdgeCount; k++){
															 if(OrgBtm3OutPoint[k].x==0.0f || OrgBtm3OutPoint[k].y==0.0f) continue;

															 GrindMarkRectCenter[8].x = GrindMarkRect[8].left + (GrindMarkRect[8].right  - GrindMarkRect[8].left)/2; 
															 GrindMarkRectCenter[8].y = GrindMarkRect[8].top  + (GrindMarkRect[8].bottom - GrindMarkRect[8].top )/2; 

															 GrindMeaDis = Math.GetLength(GrindMarkRectCenter[8], OrgBtm3OutPoint[k]);
															 if(GrindMeaDis<MinDis){
																 MinDis = GrindMeaDis;
																 Btm3GrindMarkCount = k;
															 }
														 }
														 // GrindMark기준 수직 평균값 연마량 측정 
														 if(Btm3GrindMarkCount!=0 && Btm3GrindMarkCount>5 &&(Btm3GrindMarkCount+5<OrgBtm3OutEdgeCount)){
															 CircleCount=0,TotalCirDis=0.0f,GrindWidthDis=0.0f;
															 for(int k=Btm3GrindMarkCount-5; k<Btm3GrindMarkCount+5; k++){
																 if(OrgBtm3OutPoint[k].x==0.0f && OrgBtm3OutPoint[k].y==0.0f) continue;
																 if(OrgBtm3InPoint [k].x==0.0f && OrgBtm3InPoint [k].y==0.0f) continue;
																 GrindWidthDis = Math.GetLength(OrgBtm3InPoint[k], OrgBtm3OutPoint[k]);
																 TotalCirDis+=   GrindWidthDis;
																 CircleCount++;
															 }
															 if(TotalCirDis!=0.0f && CircleCount!=0){
																 BtmGrindWidth4 = TotalCirDis/CircleCount;
															 }
														 }
													 }
													 ////////////////////////////////////////////////////////////////////////////////////////////////////

													 // GrindMark[9] 가공량,연마량 측정 
													 ////////////////////////////////////////////////////////////////////////////////////////////////////
													 if(GrindMarkPoint[9].x!=0.0f && GrindMarkPoint[9].y!=0.0f){ //GrindMark 찾았을경우 검사 시퀀스 
														 GrindMeaDis =0.0f, MinDis =10000.0f;  Btm3GrindMarkCount=0;

														 for(int k=0; k<OrgBtm3OutEdgeCount; k++){
															 if(OrgBtm3OutPoint[k].x==0.0f || OrgBtm3OutPoint[k].y==0.0f) continue;
															 if(GrindMarkPoint[9].x  ==0.0f || GrindMarkPoint[9].y  ==0.0f) continue;

															 GrindMeaDis = Math.GetLength(GrindMarkPoint[9], OrgBtm3OutPoint[k]);
															 if(GrindMeaDis<MinDis){
																 MinDis = GrindMeaDis;
																 Btm3GrindMarkCount = k;
															 }
														 }
														 // GrindMark기준 수직 포인트 주변값 Avg산출한다 
														 if(Btm3GrindMarkCount!=0 && Btm3GrindMarkCount>5 && (Btm3GrindMarkCount+5)<OrgBtm3OutEdgeCount){
															 CircleCount=0,TotalCirDis=0.0f,GrindMeaDis=0.0f;
															 for(int k=Btm3GrindMarkCount-5; k<Btm3GrindMarkCount+5; k++){
																 if(OrgBtm3OutPoint[k].x==0.0f || OrgBtm3OutPoint[k].y==0.0f) continue;

																 GrindMeaDis = Math.GetLength(GrindMarkPoint[9], OrgBtm3OutPoint[k]);
																 TotalCirDis+= GrindMeaDis;
																 CircleCount++;
															 }
															 if(TotalCirDis!=0.0f && CircleCount!=0){
																 BtmGrindMeasure5 = TotalCirDis/CircleCount;
															 }
														 }
														 // GrindMark기준 수직 평균값 연마량 측정 
														 if(Btm3GrindMarkCount!=0 && Btm3GrindMarkCount>5 && (Btm3GrindMarkCount+5)<OrgBtm3OutEdgeCount){
															 CircleCount=0,TotalCirDis=0.0f,GrindWidthDis=0.0f;
															 for(int k=Btm3GrindMarkCount-5; k<Btm3GrindMarkCount+5; k++){
																 if(OrgBtm3OutPoint[k].x==0.0f && OrgBtm3OutPoint[k].y==0.0f) continue;
																 if(OrgBtm3InPoint [k].x==0.0f && OrgBtm3InPoint [k].y==0.0f) continue;
																 GrindWidthDis = Math.GetLength(OrgBtm3InPoint[k], OrgBtm3OutPoint[k]);
																 TotalCirDis+=   GrindWidthDis;
																 CircleCount++;
															 }
															 if(TotalCirDis!=0.0f && CircleCount!=0){
																 BtmGrindWidth5 = TotalCirDis/CircleCount;
															 }
														 }
													 }
													 else { //GrindMark 못 찾았을경우 검사 시퀀스 (가공량: 0, 연마량 측정)
														 GrindMeaDis =0.0f, MinDis =10000.0f;  Btm3GrindMarkCount=0;
														 for(int k=0; k<OrgBtm3OutEdgeCount; k++){
															 if(OrgBtm3OutPoint[k].x==0.0f || OrgBtm3OutPoint[k].y==0.0f) continue;

															 GrindMarkRectCenter[9].x = GrindMarkRect[9].left + (GrindMarkRect[9].right  - GrindMarkRect[9].left)/2; 
															 GrindMarkRectCenter[9].y = GrindMarkRect[9].top  + (GrindMarkRect[9].bottom - GrindMarkRect[9].top )/2; 

															 GrindMeaDis = Math.GetLength(GrindMarkRectCenter[9], OrgBtm3OutPoint[k]);
															 if(GrindMeaDis<MinDis){
																 MinDis = GrindMeaDis;
																 Btm3GrindMarkCount = k;
															 }
														 }
														 // GrindMark기준 수직 평균값 연마량 측정 
														 if(Btm3GrindMarkCount!=0 && Btm3GrindMarkCount>5 &&(Btm3GrindMarkCount+5<OrgBtm3OutEdgeCount)){
															 CircleCount=0,TotalCirDis=0.0f,GrindWidthDis=0.0f;
															 for(int k=Btm3GrindMarkCount-5; k<Btm3GrindMarkCount+5; k++){
																 if(OrgBtm3OutPoint[k].x==0.0f && OrgBtm3OutPoint[k].y==0.0f) continue;
																 if(OrgBtm3InPoint [k].x==0.0f && OrgBtm3InPoint [k].y==0.0f) continue;
																 GrindWidthDis = Math.GetLength(OrgBtm3InPoint[k], OrgBtm3OutPoint[k]);
																 TotalCirDis+=   GrindWidthDis;
																 CircleCount++;
															 }
															 if(TotalCirDis!=0.0f && CircleCount!=0){
																 BtmGrindWidth5 = TotalCirDis/CircleCount;
															 }
														 }
													 }
													 ////////////////////////////////////////////////////////////////////////////////////////////////////

													 // GrindMark[10] 가공량,연마량 측정 
													 ////////////////////////////////////////////////////////////////////////////////////////////////////
													 if(GrindMarkPoint[10].x!=0.0f && GrindMarkPoint[10].y!=0.0f){ //GrindMark 찾았을경우 검사 시퀀스 
														 GrindMeaDis =0.0f, MinDis =10000.0f;  Btm3GrindMarkCount=0;

														 for(int k=0; k<OrgBtm3OutEdgeCount; k++){
															 if(OrgBtm3OutPoint[k].x==0.0f || OrgBtm3OutPoint[k].y==0.0f) continue;
															 if(GrindMarkPoint[10].x  ==0.0f || GrindMarkPoint[10].y  ==0.0f) continue;

															 GrindMeaDis = Math.GetLength(GrindMarkPoint[10], OrgBtm3OutPoint[k]);
															 if(GrindMeaDis<MinDis){
																 MinDis = GrindMeaDis;
																 Btm3GrindMarkCount = k;
															 }
														 }
														 // GrindMark기준 수직 포인트 주변값 Avg산출한다 
														 if(Btm3GrindMarkCount!=0 && Btm3GrindMarkCount>5 && (Btm3GrindMarkCount+5)<OrgBtm3OutEdgeCount){
															 CircleCount=0,TotalCirDis=0.0f,GrindMeaDis=0.0f;
															 for(int k=Btm3GrindMarkCount-5; k<Btm3GrindMarkCount+5; k++){
																 if(OrgBtm3OutPoint[k].x==0.0f || OrgBtm3OutPoint[k].y==0.0f) continue;

																 GrindMeaDis = Math.GetLength(GrindMarkPoint[10], OrgBtm3OutPoint[k]);
																 TotalCirDis+= GrindMeaDis;
																 CircleCount++;
															 }
															 if(TotalCirDis!=0.0f && CircleCount!=0){
																 BtmGrindMeasure6 = TotalCirDis/CircleCount;
															 }
														 }
														 // GrindMark기준 수직 평균값 연마량 측정 
														 if(Btm3GrindMarkCount!=0 && Btm3GrindMarkCount>5 && (Btm3GrindMarkCount+5)<OrgBtm3OutEdgeCount){
															 CircleCount=0,TotalCirDis=0.0f,GrindWidthDis=0.0f;
															 for(int k=Btm3GrindMarkCount-5; k<Btm3GrindMarkCount+5; k++){
																 if(OrgBtm3OutPoint[k].x==0.0f && OrgBtm3OutPoint[k].y==0.0f) continue;
																 if(OrgBtm3InPoint [k].x==0.0f && OrgBtm3InPoint [k].y==0.0f) continue;
																 GrindWidthDis = Math.GetLength(OrgBtm3InPoint[k], OrgBtm3OutPoint[k]);
																 TotalCirDis+=   GrindWidthDis;
																 CircleCount++;
															 }
															 if(TotalCirDis!=0.0f && CircleCount!=0){
																 BtmGrindWidth6 = TotalCirDis/CircleCount;
															 }
														 }
													 }
													 else { //GrindMark 못 찾았을경우 검사 시퀀스 (가공량: 0, 연마량 측정)
														 GrindMeaDis =0.0f, MinDis =10000.0f;  Btm3GrindMarkCount=0;
														 for(int k=0; k<OrgBtm3OutEdgeCount; k++){
															 if(OrgBtm3OutPoint[k].x==0.0f || OrgBtm3OutPoint[k].y==0.0f) continue;

															 GrindMarkRectCenter[10].x = GrindMarkRect[10].left + (GrindMarkRect[10].right  - GrindMarkRect[10].left)/2; 
															 GrindMarkRectCenter[10].y = GrindMarkRect[10].top  + (GrindMarkRect[10].bottom - GrindMarkRect[10].top )/2; 

															 GrindMeaDis = Math.GetLength(GrindMarkRectCenter[10], OrgBtm3OutPoint[k]);
															 if(GrindMeaDis<MinDis){
																 MinDis = GrindMeaDis;
																 Btm3GrindMarkCount = k;
															 }
														 }
														 // GrindMark기준 수직 평균값 연마량 측정 
														 if(Btm3GrindMarkCount!=0 && Btm3GrindMarkCount>5 &&(Btm3GrindMarkCount+5<OrgBtm3OutEdgeCount)){
															 CircleCount=0,TotalCirDis=0.0f,GrindWidthDis=0.0f;
															 for(int k=Btm3GrindMarkCount-5; k<Btm3GrindMarkCount+5; k++){
																 if(OrgBtm3OutPoint[k].x==0.0f && OrgBtm3OutPoint[k].y==0.0f) continue;
																 if(OrgBtm3InPoint [k].x==0.0f && OrgBtm3InPoint [k].y==0.0f) continue;
																 GrindWidthDis = Math.GetLength(OrgBtm3InPoint[k], OrgBtm3OutPoint[k]);
																 TotalCirDis+=   GrindWidthDis;
																 CircleCount++;
															 }
															 if(TotalCirDis!=0.0f && CircleCount!=0){
																 BtmGrindWidth6 = TotalCirDis/CircleCount;
															 }
														 }
													 }
													 ////////////////////////////////////////////////////////////////////////////////////////////////////
												 }
											 }
										 }
										 else { // ENCAP 연마량 데이터만 계측함
											 if(BtmOutLine[2].FP0.x!=0.0f && BtmOutLine[2].FP0.y!=0.0f && BtmOutLine[2].FP1.x!=0.0f && BtmOutLine[2].FP1.y!=0.0f &&
												 BtmInLine [2].FP0.x!=0.0f && BtmInLine [2].FP0.y!=0.0f && BtmInLine [2].FP1.x!=0.0f && BtmInLine [2].FP1.y!=0.0f ) 
											 {
												 // 연마량 계산  
												 if((fabs(BtmOutLine[2].FP0.y - BtmOutLine[2].FP1.y))>1
													 ||(fabs(BtmInLine[2].FP0.y - BtmInLine[2].FP1.y))>1){
														 BtmGrindWidth5 = BtmOutLine[2].FP0.y - BtmInLine[2].FP0.y; 
												 }
												 else{
													 BtmGrindWidth5 = Math.GetLengthFrLineToPoint(BtmOutLine[2].FP0, BtmOutLine[2].FP1, BtmInLine[2].FP0);
												 }
											 }
										 }
										 // 동적 생성한 데이터를 지운다 
										 if(OrgBtm3InPoint !=NULL) delete[] OrgBtm3InPoint;
										 if(OrgBtm3OutPoint!=NULL) delete[] OrgBtm3OutPoint;
										 // 계측목적으로 영역을 줄였던것을  Defect검사 목적으로 다시 넓혀줌 
										 BtmInLine[2].FP0.x = BtmEdgePoint[4].x+100;
										 BtmInLine[2].FP1.x = BtmEdgePoint[5].x-100;
										 LogUnit.SetLog(L"shRectC_Btm3_Insp_End");
									 }
									 // Circle4과 Circle5 사이의 직선영역 검사 
									 if(BtmEdgePoint[6].x!=0 && BtmEdgePoint[6].y!=0 && BtmEdgePoint[7].x!=0 && BtmEdgePoint[7].y!=0 ){ //LEFT
										 LogUnit.SetLog(L"shRectC_Btm4_Insp_Start");

										 if(BtmEdgeThresHold==0)  {SingleLine->GImage = &RotateImg      ;  SingleLine->FThreshold =5 ;}
										 else                     {SingleLine->GImage = &RotateBinaryImg;  SingleLine->FThreshold =10;}

										 SingleLine->IRoi->SetOrgX  (BtmEdgePoint[6].x-LeftMargin         ); 
										 SingleLine->IRoi->SetOrgY  (BtmEdgePoint[6].y                    );
										 SingleLine->IRoi->SetWidth (100                                  );
										 SingleLine->IRoi->SetHeight(BtmEdgePoint[7].y - BtmEdgePoint[6].y);

										 SingleLine->SetOrientation(orWest);
										 SingleLine->FIncrement =10;
										 SingleLine->SetFindLineId(0);
										 SingleLine->FThreshold =5;

										 if(IsMarkBtm) SingleLine->SetEdgeType(1);  //White To Black 
										 else          SingleLine->SetEdgeType(1);  //White To Black 

										 SingleLine->OnExecute();

										 BtmOutLine[3].FP0 = SingleLine->GetResultP0();
										 BtmOutLine[3].FP1 = SingleLine->GetResultP1();

										 // BtmInLine Search 
										 SingleLine->SetEdgeType(0);  //Black To White  
										 SingleLine->OnExecute();
										 BtmInLine[3].FP0 = SingleLine->GetResultP0();
										 BtmInLine[3].FP1 = SingleLine->GetResultP1();

										 // 연마폭 계산  
										 BtmGrindWidth4 = Math.GetLengthFrLineToPoint(BtmOutLine[3].FP0, BtmOutLine[3].FP1, BtmInLine[3].FP0);

										 //연마량 계산 
										 if(IsMarkBtm){
											 if(CirGrindMeaThresHold!=0){
												 SingleLine->GImage = &RotateGrindBinaryImg; //Binary Image 넘겨줌 
												 SingleLine->SetEdgeType(1);  //White To Black 
												 SingleLine->SetFindLineId(0);
												 SingleLine->OnExecute();

												 BtmStandLine[3].FP0 = SingleLine->GetResultP0();
												 BtmStandLine[3].FP1 = SingleLine->GetResultP1();
												 //연마량 계산 
												 BtmGrindMeasure4 = Math.GetLengthFrLineToPoint(BtmOutLine[3].FP0, BtmOutLine[3].FP1, BtmStandLine[3].FP0);
											 }
										 }
										 LogUnit.SetLog(L"shRectC_Btm4_Insp_End");
									 }
									 // Circle5과 Circle6 사이의 직선영역 검사 
									 if(BtmEdgePoint[8].x!=0 && BtmEdgePoint[8].y!=0 && BtmEdgePoint[9].x!=0 && BtmEdgePoint[9].y!=0 && FInspectMode==Insp_Surface){ //BTM 
										 LogUnit.SetLog(L"shRectC_Btm5_Insp_Start");

										 if(BtmEdgeThresHold==0)    {SingleLine->GImage = &RotateImg      ;  SingleLine->FThreshold =5 ;}
										 else                       {SingleLine->GImage = &RotateBinaryImg;  SingleLine->FThreshold =10;}

										 SingleLine->IRoi->SetOrgX  (BtmEdgePoint[8].x+50                 );
										 SingleLine->IRoi->SetOrgY  (BtmEdgePoint[8].y - BtmMargin        );
										 SingleLine->IRoi->SetWidth ((BtmEdgePoint[9].x - BtmEdgePoint[8].x)-100);
										 SingleLine->IRoi->SetHeight(100                                  );
										 if(BtmEdgePoint[8].x+100<=0 || (BtmEdgePoint[8].y-BtmMargin<=0) || ((BtmEdgePoint[9].x-BtmEdgePoint[8].x)-200)<=0 ) return false;

										 SingleLine->SetOrientation(orSouth);
										 // 									 SingleLine->FIncrement =1   ;
										 SingleLine->SetFindLineId(0);
										 SingleLine->FThreshold =5;

										 if(IsMarkBtm) {SingleLine->FIncrement =1 ; SingleLine->SetEdgeType(1);}  //White To Black 
										 else          {SingleLine->FIncrement =10; SingleLine->SetEdgeType(1);}  //White To Black 

										 SingleLine->OnExecute();
										 BtmOutLine[4].FP0 = SingleLine->GetResultP0();
										 BtmOutLine[4].FP1 = SingleLine->GetResultP1();

										 // BtmOutLine Real EdgePoint 추출함 
										 OrgBtm5OutEdgeCount = SingleLine->FEdgePointCount;
										 if(OrgBtm5OutEdgeCount>0){
											 if(OrgBtm5OutPoint!=NULL) delete[] OrgBtm5OutPoint;
											 OrgBtm5OutPoint = new TFPoint[OrgBtm5OutEdgeCount];

											 for(int k=0; k<OrgBtm5OutEdgeCount; k++){
												 if(k>MAX_CIRCLE_EDGEPOINT) break;
												 OrgBtm5OutPoint[k].x = SingleLine->FEdgePoint[k].x;
												 OrgBtm5OutPoint[k].y = SingleLine->FEdgePoint[k].y;
											 }
										 }


										 // BtmInLine Search 
										 if(CirGrindInThresHold==0) {Circle->GImage = &RotateImg             ; SingleLine->FThreshold =5 ;} //Org Image 넘겨줌 
										 else                       {Circle->GImage = &RotateGrindInBinaryImg; SingleLine->FThreshold =10;}//Binary Image 넘겨줌 

										 SingleLine->SetEdgeType(0);  //Black To White  
										 SingleLine->OnExecute();
										 BtmInLine[4].FP0 = SingleLine->GetResultP0();
										 BtmInLine[4].FP1 = SingleLine->GetResultP1();

										 // BtmInLine Real EdgePoint 추출함 
										 OrgBtm5InEdgeCount = SingleLine->FEdgePointCount;
										 if(OrgBtm5InEdgeCount>0){
											 if(OrgBtm5InPoint!=NULL) delete[] OrgBtm5InPoint;
											 OrgBtm5InPoint = new TFPoint[OrgBtm5InEdgeCount];

											 for(int k=0; k<OrgBtm5InEdgeCount; k++){
												 if(k>MAX_CIRCLE_EDGEPOINT) break;
												 OrgBtm5InPoint[k].x = SingleLine->FEdgePoint[k].x;
												 OrgBtm5InPoint[k].y = SingleLine->FEdgePoint[k].y;
											 }
										 }

										 // Grind Mark 기준 연마량 계산 
										 if(IsMarkBtm){ // LT검사시 가공량 측정함 
											 if(FInspectMode==Insp_Track){ // TrackMode TrackLine기준 가공량 측정 
												 if(CirGrindMeaThresHold!=0){
													 // 연마폭 계산  
													 if((fabs(BtmOutLine[4].FP0.y - BtmOutLine[4].FP1.y))>1
														 ||(fabs(BtmInLine[4].FP0.y - BtmInLine[4].FP1.y))>1){
															 BtmGrindWidth5 = BtmOutLine[4].FP1.y - BtmInLine[4].FP1.y; 
													 }
													 else{
														 BtmGrindWidth5 = Math.GetLengthFrLineToPoint(BtmOutLine[4].FP0, BtmOutLine[4].FP1, BtmInLine[4].FP0);
													 }

													 SingleLine->GImage = &RotateGrindBinaryImg; //Binary Image 넘겨줌 
													 SingleLine->SetEdgeType(1);  //White To Black 
													 SingleLine->SetFindLineId(0);
													 SingleLine->OnExecute();

													 BtmStandLine[4].FP0 = SingleLine->GetResultP0();
													 BtmStandLine[4].FP1 = SingleLine->GetResultP1();
													 //연마량 계산 
													 BtmGrindMeasure5 = Math.GetLengthFrLineToPoint(BtmOutLine[4].FP0, BtmOutLine[4].FP1, BtmStandLine[4].FP0);
												 }
											 }
											 else if(FInspectMode==Insp_Mark){
												 // GrindMark 상관없이 연마량 측정
												 if(OrgBtm5InEdgeCount>10 && OrgBtm5OutEdgeCount>10 && (OrgBtm5InEdgeCount==OrgBtm5OutEdgeCount)){
													 // 가공량,연마량 측정 전 데이터 존재시 가상GrindMark 생성한다 
													 if(GrindMarkPoint[16].x!=0.0f && GrindMarkPoint[16].y!=0.0f){
														 GrindMarkPoint[14].x     = OrgBtm5InPoint[7 ].x                     ;
														 GrindMarkPoint[14].y     = GrindMarkPoint[16].y                     ;
														 GrindMarkRect [14].left  = GrindMarkPoint[14].x    - GrindMarkRange ;  
														 GrindMarkRect [14].top   = GrindMarkPoint[14].y    - GrindMarkRange ;  
														 GrindMarkRect [14].right = GrindMarkRect [14].left + GrindMarkLength;  
														 GrindMarkRect [14].bottom= GrindMarkRect [14].top  + GrindMarkLength;  
													 }

													 // GrindMark[14] 가공량,연마량 측정 
													 ////////////////////////////////////////////////////////////////////////////////////////////////////
													 if(GrindMarkPoint[14].x!=0.0f && GrindMarkPoint[14].y!=0.0f){ //GrindMark 찾았을경우 검사 시퀀스 가공량 측정 
														 GrindMeaDis =0.0f, MinDis =10000.0f;  Btm5GrindMarkCount=0;
														 for(int k=0; k<OrgBtm5OutEdgeCount; k++){
															 if(OrgBtm5OutPoint[k].x==0.0f || OrgBtm5OutPoint[k].y==0.0f) continue;
															 if(GrindMarkPoint[14].x ==0.0f || GrindMarkPoint[14].y ==0.0f) continue;

															 GrindMeaDis = Math.GetLength(GrindMarkPoint[14], OrgBtm5OutPoint[k]);
															 if(GrindMeaDis<MinDis){
																 MinDis = GrindMeaDis;
																 Btm5GrindMarkCount = k;
															 }
														 }
														 // GrindMark기준 수직 포인트 주변값 Avg산출한다 
														 if(Btm5GrindMarkCount!=0 && Btm5GrindMarkCount>5 && (Btm5GrindMarkCount+5)<OrgBtm5OutEdgeCount){
															 CircleCount=0,TotalCirDis=0.0f,GrindMeaDis=0.0f;
															 for(int k=Btm5GrindMarkCount-5; k<Btm5GrindMarkCount+5; k++){
																 if(OrgBtm5OutPoint[k].x==0.0f || OrgBtm5OutPoint[k].y==0.0f) continue;

																 GrindMeaDis = Math.GetLength(GrindMarkPoint[14], OrgBtm5OutPoint[k]);
																 TotalCirDis+= GrindMeaDis;
																 CircleCount++;
															 }
															 if(TotalCirDis!=0.0f && CircleCount!=0){
																 BtmGrindMeasure7 = TotalCirDis/CircleCount;
															 }
														 }
														 // GrindMark기준 수직 평균값 연마량 측정 
														 if(Btm5GrindMarkCount!=0 && Btm5GrindMarkCount>5 && (Btm5GrindMarkCount+5)<OrgBtm5OutEdgeCount){
															 CircleCount=0,TotalCirDis=0.0f,GrindWidthDis=0.0f;
															 for(int k=Btm5GrindMarkCount-5; k<Btm5GrindMarkCount+5; k++){
																 if(OrgBtm5OutPoint[k].x==0.0f && OrgBtm5OutPoint[k].y==0.0f) continue;
																 if(OrgBtm5InPoint [k].x==0.0f && OrgBtm5InPoint [k].y==0.0f) continue;
																 GrindWidthDis = Math.GetLength(OrgBtm5InPoint[k], OrgBtm5OutPoint[k]);
																 TotalCirDis+=   GrindWidthDis;
																 CircleCount++;
															 }
															 if(TotalCirDis!=0.0f && CircleCount!=0){
																 BtmGrindWidth7 = TotalCirDis/CircleCount;
															 }
														 }
													 }
													 else {  //GrindMark 못 찾았을경우 검사 시퀀스 (가공량: 0, 연마량 측정)
														 GrindMeaDis =0.0f, MinDis =10000.0f;  Btm5GrindMarkCount=0;
														 for(int k=0; k<OrgBtm5OutEdgeCount; k++){
															 if(OrgBtm5OutPoint[k].x==0.0f || OrgBtm5OutPoint[k].y==0.0f) continue;

															 GrindMarkRectCenter[14].x = GrindMarkRect[14].left + (GrindMarkRect[14].right  - GrindMarkRect[14].left)/2; 
															 GrindMarkRectCenter[14].y = GrindMarkRect[14].top  + (GrindMarkRect[14].bottom - GrindMarkRect[14].top )/2; 

															 GrindMeaDis = Math.GetLength(GrindMarkRectCenter[14], OrgBtm5OutPoint[k]);
															 if(GrindMeaDis<MinDis){
																 MinDis = GrindMeaDis;
																 Btm5GrindMarkCount = k;
															 }
														 }
														 // GrindMark기준 수직 평균값 연마량 측정 
														 if(Btm5GrindMarkCount!=0 && Btm5GrindMarkCount>5 &&(Btm5GrindMarkCount+5<OrgBtm5OutEdgeCount)){
															 CircleCount=0,TotalCirDis=0.0f,GrindWidthDis=0.0f;
															 for(int k=Btm5GrindMarkCount-5; k<Btm5GrindMarkCount+5; k++){
																 if(OrgBtm5OutPoint[k].x==0.0f && OrgBtm5OutPoint[k].y==0.0f) continue;
																 if(OrgBtm5InPoint [k].x==0.0f && OrgBtm5InPoint [k].y==0.0f) continue;
																 GrindWidthDis = Math.GetLength(OrgBtm5InPoint[k], OrgBtm5OutPoint[k]);
																 TotalCirDis+=   GrindWidthDis;
																 CircleCount++;
															 }
															 if(TotalCirDis!=0.0f && CircleCount!=0){
																 BtmGrindWidth7 = TotalCirDis/CircleCount;
															 }
														 }
													 }
													 ////////////////////////////////////////////////////////////////////////////////////////////////////

													 // GrindMark[14] 가공량,연마량 측정 
													 ////////////////////////////////////////////////////////////////////////////////////////////////////
													 if(GrindMarkPoint[16].x!=0.0f && GrindMarkPoint[16].y!=0.0f){ //GrindMark 찾았을경우 검사 시퀀스 가공량 측정 
														 GrindMeaDis =0.0f, MinDis =10000.0f;  Btm5GrindMarkCount=0;
														 for(int k=0; k<OrgBtm5OutEdgeCount; k++){
															 if(OrgBtm5OutPoint[k].x==0.0f || OrgBtm5OutPoint[k ].y==0.0f) continue;
															 if(GrindMarkPoint[16].x==0.0f || GrindMarkPoint[16].y ==0.0f) continue;

															 GrindMeaDis = Math.GetLength(GrindMarkPoint[16], OrgBtm5OutPoint[k]);
															 if(GrindMeaDis<MinDis){
																 MinDis = GrindMeaDis;
																 Btm5GrindMarkCount = k;
															 }
														 }
														 // GrindMark기준 수직 포인트 주변값 Avg산출한다 
														 if(Btm5GrindMarkCount!=0 && Btm5GrindMarkCount>5 && (Btm5GrindMarkCount+5)<OrgBtm5OutEdgeCount){
															 CircleCount=0,TotalCirDis=0.0f,GrindMeaDis=0.0f;
															 for(int k=Btm5GrindMarkCount-5; k<Btm5GrindMarkCount+5; k++){
																 if(OrgBtm5OutPoint[k].x==0.0f || OrgBtm5OutPoint[k].y==0.0f) continue;

																 GrindMeaDis = Math.GetLength(GrindMarkPoint[16], OrgBtm5OutPoint[k]);
																 TotalCirDis+= GrindMeaDis;
																 CircleCount++;
															 }
															 if(TotalCirDis!=0.0f && CircleCount!=0){
																 BtmGrindMeasure9 = TotalCirDis/CircleCount;
															 }
														 }
														 // GrindMark기준 수직 평균값 연마량 측정 
														 if(Btm5GrindMarkCount!=0 && Btm5GrindMarkCount>5 && (Btm5GrindMarkCount+5)<OrgBtm5OutEdgeCount){
															 CircleCount=0,TotalCirDis=0.0f,GrindWidthDis=0.0f;
															 for(int k=Btm5GrindMarkCount-5; k<Btm5GrindMarkCount+5; k++){
																 if(OrgBtm5OutPoint[k].x==0.0f && OrgBtm5OutPoint[k].y==0.0f) continue;
																 if(OrgBtm5InPoint [k].x==0.0f && OrgBtm5InPoint [k].y==0.0f) continue;
																 GrindWidthDis = Math.GetLength(OrgBtm5InPoint[k], OrgBtm5OutPoint[k]);
																 TotalCirDis+=   GrindWidthDis;
																 CircleCount++;
															 }
															 if(TotalCirDis!=0.0f && CircleCount!=0){
																 BtmGrindWidth9 = TotalCirDis/CircleCount;
															 }
														 }
													 }
													 else {  //GrindMark 못 찾았을경우 검사 시퀀스 (가공량: 0, 연마량 측정)
														 GrindMeaDis =0.0f, MinDis =10000.0f;  Btm5GrindMarkCount=0;
														 for(int k=0; k<OrgBtm5OutEdgeCount; k++){
															 if(OrgBtm5OutPoint[k].x==0.0f || OrgBtm5OutPoint[k].y==0.0f) continue;

															 GrindMarkRectCenter[16].x = GrindMarkRect[16].left + (GrindMarkRect[16].right  - GrindMarkRect[16].left)/2; 
															 GrindMarkRectCenter[16].y = GrindMarkRect[16].top  + (GrindMarkRect[16].bottom - GrindMarkRect[16].top )/2; 

															 GrindMeaDis = Math.GetLength(GrindMarkRectCenter[16], OrgBtm5OutPoint[k]);
															 if(GrindMeaDis<MinDis){
																 MinDis = GrindMeaDis;
																 Btm5GrindMarkCount = k;
															 }
														 }
														 // GrindMark기준 수직 평균값 연마량 측정 
														 if(Btm5GrindMarkCount!=0 && Btm5GrindMarkCount>5 &&(Btm5GrindMarkCount+5<OrgBtm5OutEdgeCount)){
															 CircleCount=0,TotalCirDis=0.0f,GrindWidthDis=0.0f;
															 for(int k=Btm5GrindMarkCount-5; k<Btm5GrindMarkCount+5; k++){
																 if(OrgBtm5OutPoint[k].x==0.0f && OrgBtm5OutPoint[k].y==0.0f) continue;
																 if(OrgBtm5InPoint [k].x==0.0f && OrgBtm5InPoint [k].y==0.0f) continue;
																 GrindWidthDis = Math.GetLength(OrgBtm5InPoint[k], OrgBtm5OutPoint[k]);
																 TotalCirDis+=   GrindWidthDis;
																 CircleCount++;
															 }
															 if(TotalCirDis!=0.0f && CircleCount!=0){
																 BtmGrindWidth9 = TotalCirDis/CircleCount;
															 }
														 }
													 }
													 ///////////////////////////////////////////////////////////////////////////////////////////////////////
												 }

												 // 											 if(BtmGrindWidth5!=0.0f && GrindMarkPoint[16].x!=0.0f && GrindMarkPoint[16].y!=0.0f){ // MarkMode GrindMark중심 좌표 기준 가공량 측정 
												 // 												 if(fabs(BtmOutLine[4].FP0.y - BtmOutLine[4].FP1.y)>2){
												 // // 													 BtmGrindWidth5   = (BtmOutLine[4].FP1.y  - GrindMarkPoint[8].y) - (BtmInLine[4].FP1.y - GrindMarkPoint[8].y);
												 // 													 BtmGrindMeasure5 = BtmOutLine[4].FP1.y - GrindMarkPoint[16].y; 
												 // 												 }
												 // 												 else {
												 // 													 BtmGrindMeasure5 = Math.GetLengthFrLineToPoint(BtmOutLine[4].FP0, BtmOutLine[4].FP1, GrindMarkPoint[16]);
												 // // 													 BtmGrindWidth5   = BtmGrindMeasure5 - Math.GetLengthFrLineToPoint(BtmInLine[4].FP0, BtmInLine[4].FP1, GrindMarkPoint[8]);
												 // 												 }
												 // 											 }
											 }
										 }
										 else { // ENCAP 연마량 데이터만 계측함
											 if(BtmOutLine[4].FP0.x!=0.0f && BtmOutLine[4].FP0.y!=0.0f && BtmOutLine[4].FP1.x!=0.0f && BtmOutLine[4].FP1.y!=0.0f &&
												 BtmInLine [4].FP0.x!=0.0f && BtmInLine [4].FP0.y!=0.0f && BtmInLine [4].FP1.x!=0.0f && BtmInLine [4].FP1.y!=0.0f ) 
											 {
												 // 연마량 계산  
												 if((fabs(BtmOutLine[4].FP0.y - BtmOutLine[4].FP1.y))>1
													 ||(fabs(BtmInLine[4].FP0.y - BtmInLine[4].FP1.y))>1){
														 BtmGrindWidth9 = BtmOutLine[4].FP0.y - BtmInLine[4].FP0.y; 
												 }
												 else{
													 BtmGrindWidth9 = Math.GetLengthFrLineToPoint(BtmOutLine[4].FP0, BtmOutLine[4].FP1, BtmInLine[4].FP0);
												 }
											 }
										 }
										 // 동적 생성한 데이터를 지운다 
										 if(OrgBtm5InPoint !=NULL) delete[] OrgBtm5InPoint;
										 if(OrgBtm5OutPoint!=NULL) delete[] OrgBtm5OutPoint;
										 LogUnit.SetLog(L"shRectC_Btm5_Insp_End");
									 }


									 //RF_MODEL 정말 소스가 점점...더러워진다...ㅜ.ㅜ;;;
									 //Notch부 Side만 Arc가공이 존재할 경우 
									 if(C2CirCenter.x==0.0f && C2CirCenter.y==0.0f && C3CirCenter.x==0.0f && C3CirCenter.y==0.0f && 
										 C4CirCenter.x==0.0f && C4CirCenter.y==0.0f && C5CirCenter.x==0.0f && C5CirCenter.y==0.0f){
											 // 개별 Circle Data 교차점 기준 직선영역의 새로운 Btm영역 BtmOutLine, BtmInLine 찾는다 
											 // Circle1과 Circle6 사이의 직선영역 검사
											 const int BtmMargin =50; const int LeftMargin =30; const int RightMargin =30;
											 if(BtmEdgePoint[0].x!=0 && BtmEdgePoint[0].y!=0 && BtmEdgePoint[9].x!=0 && BtmEdgePoint[9].y!=0 ){ // BTM
												 LogUnit.SetLog(L"shRectC_Btm1_RF_Insp_Start");

												 if(BtmEdgeThresHold==0)    {SingleLine->GImage = &RotateImg      ;  SingleLine->FThreshold =5 ;}
												 else                       {SingleLine->GImage = &RotateBinaryImg;  SingleLine->FThreshold =10;}

												 // BtmOutLine Search 
												 SingleLine->IRoi->SetOrgX  (BtmEdgePoint[0].x+100                      );
												 SingleLine->IRoi->SetOrgY  (BtmEdgePoint[0].y - BtmMargin              );
												 SingleLine->IRoi->SetWidth ((BtmEdgePoint[9].x - BtmEdgePoint[0].x)-200);
												 SingleLine->IRoi->SetHeight(100                                        );
												 if(BtmEdgePoint[0].x+100<=0 || (BtmEdgePoint[0].y-BtmMargin<=0) || ((BtmEdgePoint[9].x-BtmEdgePoint[0].x)-200)<=0 ) return false;

												 SingleLine->SetOrientation(orSouth);
												 // 									 SingleLine->FIncrement =1   ;
												 SingleLine->SetFindLineId(0);
												 SingleLine->FThreshold =5;

												 if(IsMarkBtm) {SingleLine->FIncrement =20; SingleLine->SetEdgeType(1);}  //White To Black 
												 else          {SingleLine->FIncrement =20; SingleLine->SetEdgeType(1);}  //White To Black 

												 SingleLine->OnExecute();
												 BtmOutLine[0].FP0 = SingleLine->GetResultP0();
												 BtmOutLine[0].FP1 = SingleLine->GetResultP1();

												 // BtmInLine Search 
												 if(CirGrindInThresHold==0) {Circle->GImage = &RotateImg             ; SingleLine->FThreshold =5 ;} //Org Image 넘겨줌 
												 else                       {Circle->GImage = &RotateGrindInBinaryImg; SingleLine->FThreshold =10;}//Binary Image 넘겨줌 

												 SingleLine->SetEdgeType(0);  //Black To White  
												 SingleLine->OnExecute();
												 BtmInLine[0].FP0 = SingleLine->GetResultP0();
												 BtmInLine[0].FP1 = SingleLine->GetResultP1();

												 // Grind Mark 기준 연마량 계산 
												 if(IsMarkBtm){ // LT검사시 가공량 측정함 
													 if(FInspectMode==Insp_Track){ // TrackMode TrackLine기준 가공량 측정 
														 if(CirGrindMeaThresHold!=0){
															 // 연마량 계산  
															 if((fabs(BtmOutLine[0].FP0.y - BtmOutLine[0].FP1.y))>1
																 ||(fabs(BtmInLine[0].FP0.y - BtmInLine[0].FP1.y))>1){
																	 BtmGrindWidth1 = BtmOutLine[0].FP0.y - BtmInLine[0].FP0.y; 
															 }
															 else{
																 BtmGrindWidth1 = Math.GetLengthFrLineToPoint(BtmOutLine[0].FP0, BtmOutLine[0].FP1, BtmInLine[0].FP0);
															 }

															 SingleLine->GImage = &RotateGrindBinaryImg; //Binary Image 넘겨줌 
															 SingleLine->SetEdgeType(1);  //White To Black 
															 SingleLine->SetFindLineId(0);
															 SingleLine->OnExecute();

															 BtmStandLine[0].FP0 = SingleLine->GetResultP0();
															 BtmStandLine[0].FP1 = SingleLine->GetResultP1();
															 // 가공량 계산 
															 BtmGrindMeasure1 = Math.GetLengthFrLineToPoint(BtmOutLine[0].FP0, BtmOutLine[0].FP1, BtmStandLine[0].FP0);
														 }
													 }
													 else if(FInspectMode==Insp_Mark){ // RF_MODEL GrindMark 기준 특정 Point 개별 EdgePoint 데이터를 산출하여 연마량,가공량 계산
														 // GrindMark[2] 시퀀스 시작 
														 if(GrindMarkRect[2].left!=0.0f && GrindMarkRect[2].top!=0.0f && GrindMarkRect[2].right!=0.0f && GrindMarkRect[2].bottom!=0.0f){ //GrindMark 찾았을경우 검사 시퀀스 가공량 측정 
															 if(BtmEdgeThresHold==0)    {SingleLine->GImage = &RotateImg      ;  SingleLine->FThreshold =5 ;}
															 else                       {SingleLine->GImage = &RotateBinaryImg;  SingleLine->FThreshold =10;}

															 // Btm1OutLine
															 SingleLine->IRoi->SetOrgX  (GrindMarkRect[2].left-50                            );
															 SingleLine->IRoi->SetOrgY  (BtmOutLine[0].FP0.y - BtmMargin                     );
															 SingleLine->IRoi->SetWidth ((GrindMarkRect[2].right - GrindMarkRect[2].left)+100);
															 SingleLine->IRoi->SetHeight(100                                                 );
															 if(GrindMarkRect[2].left-50 <=0 || (BtmOutLine[0].FP0.y - BtmMargin<=0) || ((GrindMarkRect[2].right - GrindMarkRect[2].left)+100)<=0 ) return false;

															 SingleLine->SetOrientation(orSouth);
															 SingleLine->SetFindLineId(0);
															 SingleLine->FThreshold =5;

															 if(IsMarkBtm) {SingleLine->FIncrement =1; SingleLine->SetEdgeType(1);}  //White To Black 
															 else          {SingleLine->FIncrement =1; SingleLine->SetEdgeType(1);}  //White To Black 

															 SingleLine->OnExecute();

															 // Btm1OutLine Real EdgePoint 추출함 
															 OrgBtm1OutEdgeCount = SingleLine->FEdgePointCount;
															 if(OrgBtm1OutEdgeCount>0){
																 if(OrgBtm1OutPoint!=NULL) delete[] OrgBtm1OutPoint;
																 OrgBtm1OutPoint = new TFPoint[OrgBtm1OutEdgeCount];

																 for(int k=0; k<OrgBtm1OutEdgeCount; k++){
																	 if(k>MAX_CIRCLE_EDGEPOINT) break;
																	 OrgBtm1OutPoint[k].x = SingleLine->FEdgePoint[k].x;
																	 OrgBtm1OutPoint[k].y = SingleLine->FEdgePoint[k].y;
																 }
															 }

															 //Btm1InLine Real EdgePoint 추출함 
															 if(CirGrindInThresHold==0) {Circle->GImage = &RotateImg             ; SingleLine->FThreshold =5 ;} //Org Image 넘겨줌 
															 else                       {Circle->GImage = &RotateGrindInBinaryImg; SingleLine->FThreshold =10;}//Binary Image 넘겨줌 

															 SingleLine->SetEdgeType(0);  //Black To White  
															 SingleLine->OnExecute();

															 OrgBtm1InEdgeCount = SingleLine->FEdgePointCount;
															 if(OrgBtm1InEdgeCount>0){
																 if(OrgBtm1InPoint!=NULL) delete[] OrgBtm1InPoint;
																 OrgBtm1InPoint = new TFPoint[OrgBtm1InEdgeCount];

																 for(int k=0; k<OrgBtm1InEdgeCount; k++){
																	 if(k>MAX_CIRCLE_EDGEPOINT) break;
																	 OrgBtm1InPoint[k].x = SingleLine->FEdgePoint[k].x;
																	 OrgBtm1InPoint[k].y = SingleLine->FEdgePoint[k].y;
																 }
															 }

															 // GrindMarkPoint 검출 유무에 따라서 연마량,가공량 측정한다 
															 if(GrindMarkPoint[2].x!=0.0f && GrindMarkPoint[2].y!=0.0f){ //GrindMark 찾았을경우 검사 시퀀스 연마량,가공량 측정 
																 GrindMeaDis =0.0f, MinDis =10000.0f;  Btm1GrindMarkCount=0;
																 for(int k=0; k<OrgBtm1OutEdgeCount; k++){
																	 if(OrgBtm1OutPoint[k].x==0.0f || OrgBtm1OutPoint[k].y==0.0f) continue;
																	 if(GrindMarkPoint[2].x ==0.0f || GrindMarkPoint[2].y ==0.0f) continue;

																	 GrindMeaDis = Math.GetLength(GrindMarkPoint[2], OrgBtm1OutPoint[k]);
																	 if(GrindMeaDis<MinDis){
																		 MinDis = GrindMeaDis;
																		 Btm1GrindMarkCount = k;
																	 }
																 }
																 // GrindMark기준 수직 포인트 주변값 Avg산출한다 
																 if(Btm1GrindMarkCount!=0 && Btm1GrindMarkCount>5 && (Btm1GrindMarkCount+5)<OrgBtm1OutEdgeCount){
																	 CircleCount=0,TotalCirDis=0.0f,GrindMeaDis=0.0f;
																	 for(int k=Btm1GrindMarkCount-5; k<Btm1GrindMarkCount+5; k++){
																		 if(OrgBtm1OutPoint[k].x==0.0f || OrgBtm1OutPoint[k].y==0.0f) continue;

																		 GrindMeaDis = Math.GetLength(GrindMarkPoint[2], OrgBtm1OutPoint[k]);
																		 TotalCirDis+= GrindMeaDis;
																		 CircleCount++;
																	 }
																	 if(TotalCirDis!=0.0f && CircleCount!=0){
																		 BtmGrindMeasure1 = TotalCirDis/CircleCount;
																	 }
																 }
																 // GrindMark기준 수직 평균값 연마량 측정 
																 if(Btm1GrindMarkCount!=0 && Btm1GrindMarkCount>5 && (Btm1GrindMarkCount+5)<OrgBtm1OutEdgeCount){
																	 CircleCount=0,TotalCirDis=0.0f,GrindWidthDis=0.0f;
																	 for(int k=Btm1GrindMarkCount-5; k<Btm1GrindMarkCount+5; k++){
																		 if(OrgBtm1OutPoint[k].x==0.0f && OrgBtm1OutPoint[k].y==0.0f) continue;
																		 if(OrgBtm1InPoint [k].x==0.0f && OrgBtm1InPoint [k].y==0.0f) continue;
																		 GrindWidthDis = Math.GetLength(OrgBtm1InPoint[k], OrgBtm1OutPoint[k]);
																		 TotalCirDis+=   GrindWidthDis;
																		 CircleCount++;
																	 }
																	 if(TotalCirDis!=0.0f && CircleCount!=0){
																		 BtmGrindWidth1 = TotalCirDis/CircleCount;
																	 }
																 }
															 }
															 else                                                      { //GrindMark 못 찾았을경우 검사 시퀀스 (가공량: 0, 연마량 측정)
																 GrindMeaDis =0.0f, MinDis =10000.0f;  Btm1GrindMarkCount=0;
																 for(int k=0; k<OrgBtm1OutEdgeCount; k++){
																	 if(OrgBtm1OutPoint[k].x==0.0f || OrgBtm1OutPoint[k].y==0.0f) continue;

																	 GrindMarkRectCenter[2].x = GrindMarkRect[2].left + (GrindMarkRect[2].right  - GrindMarkRect[2].left)/2; 
																	 GrindMarkRectCenter[2].y = GrindMarkRect[2].top  + (GrindMarkRect[2].bottom - GrindMarkRect[2].top )/2; 

																	 GrindMeaDis = Math.GetLength(GrindMarkRectCenter[2], OrgBtm1OutPoint[k]);
																	 if(GrindMeaDis<MinDis){
																		 MinDis = GrindMeaDis;
																		 Btm1GrindMarkCount = k;
																	 }
																 }
																 // GrindMark기준 수직 평균값 연마량 측정 
																 if(Btm1GrindMarkCount!=0 && Btm1GrindMarkCount>5 &&(Btm1GrindMarkCount+5<OrgBtm1OutEdgeCount)){
																	 CircleCount=0,TotalCirDis=0.0f,GrindWidthDis=0.0f;
																	 for(int k=Btm1GrindMarkCount-5; k<Btm1GrindMarkCount+5; k++){
																		 if(OrgBtm1OutPoint[k].x==0.0f && OrgBtm1OutPoint[k].y==0.0f) continue;
																		 if(OrgBtm1InPoint [k].x==0.0f && OrgBtm1InPoint [k].y==0.0f) continue;
																		 GrindWidthDis = Math.GetLength(OrgBtm1InPoint[k], OrgBtm1OutPoint[k]);
																		 TotalCirDis+=   GrindWidthDis;
																		 CircleCount++;
																	 }
																	 if(TotalCirDis!=0.0f && CircleCount!=0){
																		 BtmGrindWidth1 = TotalCirDis/CircleCount;
																	 }
																 }
															 }
														 }

														 // GrindMark[9] 시퀀스 시작 
														 if(GrindMarkRect[9].left!=0.0f && GrindMarkRect[9].top!=0.0f && GrindMarkRect[9].right!=0.0f && GrindMarkRect[9].bottom!=0.0f){ //GrindMark 찾았을경우 검사 시퀀스 가공량 측정 
															 if(BtmEdgeThresHold==0)    {SingleLine->GImage = &RotateImg      ;  SingleLine->FThreshold =5 ;}
															 else                       {SingleLine->GImage = &RotateBinaryImg;  SingleLine->FThreshold =10;}

															 // Btm1OutLine
															 SingleLine->IRoi->SetOrgX  (GrindMarkRect[9].left-50                            );
															 SingleLine->IRoi->SetOrgY  (BtmOutLine[0].FP0.y - BtmMargin                     );
															 SingleLine->IRoi->SetWidth ((GrindMarkRect[9].right - GrindMarkRect[9].left)+100);
															 SingleLine->IRoi->SetHeight(100                                                 );
															 if(GrindMarkRect[9].left-50 <=0 || (BtmOutLine[0].FP0.y - BtmMargin<=0) || ((GrindMarkRect[9].right - GrindMarkRect[9].left)+100)<=0 ) return false;

															 SingleLine->SetOrientation(orSouth);
															 SingleLine->SetFindLineId(0);
															 SingleLine->FThreshold =5;

															 if(IsMarkBtm) {SingleLine->FIncrement =1; SingleLine->SetEdgeType(1);}  //White To Black 
															 else          {SingleLine->FIncrement =1; SingleLine->SetEdgeType(1);}  //White To Black 

															 SingleLine->OnExecute();

															 // Btm1OutLine Real EdgePoint 추출함 
															 OrgBtm3OutEdgeCount = SingleLine->FEdgePointCount;
															 if(OrgBtm3OutEdgeCount>0){
																 if(OrgBtm1OutPoint!=NULL) delete[] OrgBtm3OutPoint;
																 OrgBtm3OutPoint = new TFPoint[OrgBtm3OutEdgeCount];

																 for(int k=0; k<OrgBtm3OutEdgeCount; k++){
																	 if(k>MAX_CIRCLE_EDGEPOINT) break;
																	 OrgBtm3OutPoint[k].x = SingleLine->FEdgePoint[k].x;
																	 OrgBtm3OutPoint[k].y = SingleLine->FEdgePoint[k].y;
																 }
															 }

															 //Btm1InLine Real EdgePoint 추출함 
															 if(CirGrindInThresHold==0) {Circle->GImage = &RotateImg             ; SingleLine->FThreshold =5 ;} //Org Image 넘겨줌 
															 else                       {Circle->GImage = &RotateGrindInBinaryImg; SingleLine->FThreshold =10;}//Binary Image 넘겨줌 

															 SingleLine->SetEdgeType(0);  //Black To White  
															 SingleLine->OnExecute();

															 OrgBtm3InEdgeCount = SingleLine->FEdgePointCount;
															 if(OrgBtm3InEdgeCount>0){
																 if(OrgBtm3InPoint!=NULL) delete[] OrgBtm3InPoint;
																 OrgBtm3InPoint = new TFPoint[OrgBtm3InEdgeCount];

																 for(int k=0; k<OrgBtm3InEdgeCount; k++){
																	 if(k>MAX_CIRCLE_EDGEPOINT) break;
																	 OrgBtm3InPoint[k].x = SingleLine->FEdgePoint[k].x;
																	 OrgBtm3InPoint[k].y = SingleLine->FEdgePoint[k].y;
																 }
															 }

															 // GrindMarkPoint 검출 유무에 따라서 연마량,가공량 측정한다 
															 if(GrindMarkPoint[9].x!=0.0f && GrindMarkPoint[9].y!=0.0f){ //GrindMark 찾았을경우 검사 시퀀스 연마량,가공량 측정 
																 GrindMeaDis =0.0f, MinDis =10000.0f;  Btm3GrindMarkCount=0;
																 for(int k=0; k<OrgBtm3OutEdgeCount; k++){
																	 if(OrgBtm3OutPoint[k].x==0.0f || OrgBtm3OutPoint[k].y==0.0f) continue;
																	 if(GrindMarkPoint[9].x ==0.0f || GrindMarkPoint[9].y ==0.0f) continue;

																	 GrindMeaDis = Math.GetLength(GrindMarkPoint[9], OrgBtm3OutPoint[k]);
																	 if(GrindMeaDis<MinDis){
																		 MinDis = GrindMeaDis;
																		 Btm3GrindMarkCount = k;
																	 }
																 }
																 // GrindMark기준 수직 포인트 주변값 Avg산출한다 
																 if(Btm3GrindMarkCount!=0 && Btm3GrindMarkCount>5 && (Btm3GrindMarkCount+5)<OrgBtm3OutEdgeCount){
																	 CircleCount=0,TotalCirDis=0.0f,GrindMeaDis=0.0f;
																	 for(int k=Btm3GrindMarkCount-5; k<Btm3GrindMarkCount+5; k++){
																		 if(OrgBtm3OutPoint[k].x==0.0f || OrgBtm3OutPoint[k].y==0.0f) continue;

																		 GrindMeaDis = Math.GetLength(GrindMarkPoint[9], OrgBtm3OutPoint[k]);
																		 TotalCirDis+= GrindMeaDis;
																		 CircleCount++;
																	 }
																	 if(TotalCirDis!=0.0f && CircleCount!=0){
																		 BtmGrindMeasure5 = TotalCirDis/CircleCount;
																	 }
																 }
																 // GrindMark기준 수직 평균값 연마량 측정 
																 if(Btm3GrindMarkCount!=0 && Btm3GrindMarkCount>5 && (Btm3GrindMarkCount+5)<OrgBtm3OutEdgeCount){
																	 CircleCount=0,TotalCirDis=0.0f,GrindWidthDis=0.0f;
																	 for(int k=Btm3GrindMarkCount-5; k<Btm3GrindMarkCount+5; k++){
																		 if(OrgBtm3OutPoint[k].x==0.0f && OrgBtm3OutPoint[k].y==0.0f) continue;
																		 if(OrgBtm3InPoint [k].x==0.0f && OrgBtm3InPoint [k].y==0.0f) continue;
																		 GrindWidthDis = Math.GetLength(OrgBtm3InPoint[k], OrgBtm3OutPoint[k]);
																		 TotalCirDis+=   GrindWidthDis;
																		 CircleCount++;
																	 }
																	 if(TotalCirDis!=0.0f && CircleCount!=0){
																		 BtmGrindWidth5 = TotalCirDis/CircleCount;
																	 }
																 }
															 }
															 else                                                      { //GrindMark 못 찾았을경우 검사 시퀀스 (가공량: 0, 연마량 측정)
																 GrindMeaDis =0.0f, MinDis =10000.0f;  Btm3GrindMarkCount=0;
																 for(int k=0; k<OrgBtm3OutEdgeCount; k++){
																	 if(OrgBtm3OutPoint[k].x==0.0f || OrgBtm3OutPoint[k].y==0.0f) continue;

																	 GrindMarkRectCenter[9].x = GrindMarkRect[9].left + (GrindMarkRect[9].right  - GrindMarkRect[9].left)/2; 
																	 GrindMarkRectCenter[9].y = GrindMarkRect[9].top  + (GrindMarkRect[9].bottom - GrindMarkRect[9].top )/2; 

																	 GrindMeaDis = Math.GetLength(GrindMarkRectCenter[9], OrgBtm3OutPoint[k]);
																	 if(GrindMeaDis<MinDis){
																		 MinDis = GrindMeaDis;
																		 Btm3GrindMarkCount = k;
																	 }
																 }
																 // GrindMark기준 수직 평균값 연마량 측정 
																 if(Btm3GrindMarkCount!=0 && Btm3GrindMarkCount>5 &&(Btm3GrindMarkCount+5<OrgBtm3OutEdgeCount)){
																	 CircleCount=0,TotalCirDis=0.0f,GrindWidthDis=0.0f;
																	 for(int k=Btm3GrindMarkCount-5; k<Btm3GrindMarkCount+5; k++){
																		 if(OrgBtm3OutPoint[k].x==0.0f && OrgBtm3OutPoint[k].y==0.0f) continue;
																		 if(OrgBtm3InPoint [k].x==0.0f && OrgBtm3InPoint [k].y==0.0f) continue;
																		 GrindWidthDis = Math.GetLength(OrgBtm3InPoint[k], OrgBtm3OutPoint[k]);
																		 TotalCirDis+=   GrindWidthDis;
																		 CircleCount++;
																	 }
																	 if(TotalCirDis!=0.0f && CircleCount!=0){
																		 BtmGrindWidth5 = TotalCirDis/CircleCount;
																	 }
																 }
															 }
														 }

														 // GrindMark[16] 시퀀스 시작 
														 if(GrindMarkRect[16].left!=0.0f && GrindMarkRect[16].top!=0.0f && GrindMarkRect[16].right!=0.0f && GrindMarkRect[16].bottom!=0.0f){ //GrindMark 찾았을경우 검사 시퀀스 가공량 측정 
															 if(BtmEdgeThresHold==0)    {SingleLine->GImage = &RotateImg      ;  SingleLine->FThreshold =5 ;}
															 else                       {SingleLine->GImage = &RotateBinaryImg;  SingleLine->FThreshold =10;}

															 // Btm1OutLine
															 SingleLine->IRoi->SetOrgX  (GrindMarkRect[16].left-50                            );
															 SingleLine->IRoi->SetOrgY  (BtmOutLine[0].FP1.y - BtmMargin                     );
															 SingleLine->IRoi->SetWidth ((GrindMarkRect[16].right - GrindMarkRect[16].left)+100);
															 SingleLine->IRoi->SetHeight(100                                                 );
															 if(GrindMarkRect[16].left-50 <=0 || (BtmOutLine[0].FP1.y - BtmMargin<=0) || ((GrindMarkRect[16].right - GrindMarkRect[16].left)+100)<=0 ) return false;

															 SingleLine->SetOrientation(orSouth);
															 SingleLine->SetFindLineId(0);
															 SingleLine->FThreshold =5;

															 if(IsMarkBtm) {SingleLine->FIncrement =1; SingleLine->SetEdgeType(1);}  //White To Black 
															 else          {SingleLine->FIncrement =1; SingleLine->SetEdgeType(1);}  //White To Black 

															 SingleLine->OnExecute();

															 // Btm1OutLine Real EdgePoint 추출함 
															 OrgBtm5OutEdgeCount = SingleLine->FEdgePointCount;
															 if(OrgBtm5OutEdgeCount>0){
																 if(OrgBtm5OutPoint!=NULL) delete[] OrgBtm5OutPoint;
																 OrgBtm5OutPoint = new TFPoint[OrgBtm5OutEdgeCount];

																 for(int k=0; k<OrgBtm5OutEdgeCount; k++){
																	 if(k>MAX_CIRCLE_EDGEPOINT) break;
																	 OrgBtm5OutPoint[k].x = SingleLine->FEdgePoint[k].x;
																	 OrgBtm5OutPoint[k].y = SingleLine->FEdgePoint[k].y;
																 }
															 }

															 //Btm1InLine Real EdgePoint 추출함 
															 if(CirGrindInThresHold==0) {Circle->GImage = &RotateImg             ; SingleLine->FThreshold =5 ;} //Org Image 넘겨줌 
															 else                       {Circle->GImage = &RotateGrindInBinaryImg; SingleLine->FThreshold =10;}//Binary Image 넘겨줌 

															 SingleLine->SetEdgeType(0);  //Black To White  
															 SingleLine->OnExecute();

															 OrgBtm5InEdgeCount = SingleLine->FEdgePointCount;
															 if(OrgBtm5InEdgeCount>0){
																 if(OrgBtm5InPoint!=NULL) delete[] OrgBtm5InPoint;
																 OrgBtm5InPoint = new TFPoint[OrgBtm5InEdgeCount];

																 for(int k=0; k<OrgBtm5InEdgeCount; k++){
																	 if(k>MAX_CIRCLE_EDGEPOINT) break;
																	 OrgBtm5InPoint[k].x = SingleLine->FEdgePoint[k].x;
																	 OrgBtm5InPoint[k].y = SingleLine->FEdgePoint[k].y;
																 }
															 }

															 // GrindMarkPoint 검출 유무에 따라서 연마량,가공량 측정한다 
															 if(GrindMarkPoint[16].x!=0.0f && GrindMarkPoint[16].y!=0.0f){ //GrindMark 찾았을경우 검사 시퀀스 연마량,가공량 측정 
																 GrindMeaDis =0.0f, MinDis =10000.0f;  Btm5GrindMarkCount=0;
																 for(int k=0; k<OrgBtm5OutEdgeCount; k++){
																	 if(OrgBtm5OutPoint[k].x==0.0f || OrgBtm5OutPoint[k].y==0.0f) continue;
																	 if(GrindMarkPoint[16].x==0.0f || GrindMarkPoint[16].y==0.0f) continue;

																	 GrindMeaDis = Math.GetLength(GrindMarkPoint[16], OrgBtm5OutPoint[k]);
																	 if(GrindMeaDis<MinDis){
																		 MinDis = GrindMeaDis;
																		 Btm5GrindMarkCount = k;
																	 }
																 }
																 // GrindMark기준 수직 포인트 주변값 Avg산출한다 
																 if(Btm5GrindMarkCount!=0 && Btm5GrindMarkCount>5 && (Btm5GrindMarkCount+5)<OrgBtm5OutEdgeCount){
																	 CircleCount=0,TotalCirDis=0.0f,GrindMeaDis=0.0f;
																	 for(int k=Btm5GrindMarkCount-5; k<Btm5GrindMarkCount+5; k++){
																		 if(OrgBtm5OutPoint[k].x==0.0f || OrgBtm5OutPoint[k].y==0.0f) continue;

																		 GrindMeaDis = Math.GetLength(GrindMarkPoint[16], OrgBtm5OutPoint[k]);
																		 TotalCirDis+= GrindMeaDis;
																		 CircleCount++;
																	 }
																	 if(TotalCirDis!=0.0f && CircleCount!=0){
																		 BtmGrindMeasure9 = TotalCirDis/CircleCount;
																	 }
																 }
																 // GrindMark기준 수직 평균값 연마량 측정 
																 if(Btm5GrindMarkCount!=0 && Btm5GrindMarkCount>5 && (Btm5GrindMarkCount+5)<OrgBtm5OutEdgeCount){
																	 CircleCount=0,TotalCirDis=0.0f,GrindWidthDis=0.0f;
																	 for(int k=Btm5GrindMarkCount-5; k<Btm5GrindMarkCount+5; k++){
																		 if(OrgBtm5OutPoint[k].x==0.0f && OrgBtm5OutPoint[k].y==0.0f) continue;
																		 if(OrgBtm5InPoint [k].x==0.0f && OrgBtm5InPoint [k].y==0.0f) continue;
																		 GrindWidthDis = Math.GetLength(OrgBtm5InPoint[k], OrgBtm5OutPoint[k]);
																		 TotalCirDis+=   GrindWidthDis;
																		 CircleCount++;
																	 }
																	 if(TotalCirDis!=0.0f && CircleCount!=0){
																		 BtmGrindWidth9 = TotalCirDis/CircleCount;
																	 }
																 }
															 }
															 else                                                      { //GrindMark 못 찾았을경우 검사 시퀀스 (가공량: 0, 연마량 측정)
																 GrindMeaDis =0.0f, MinDis =10000.0f;  Btm5GrindMarkCount=0;
																 for(int k=0; k<OrgBtm5OutEdgeCount; k++){
																	 if(OrgBtm5OutPoint[k].x==0.0f || OrgBtm5OutPoint[k].y==0.0f) continue;

																	 GrindMarkRectCenter[16].x = GrindMarkRect[16].left + (GrindMarkRect[16].right  - GrindMarkRect[16].left)/2; 
																	 GrindMarkRectCenter[16].y = GrindMarkRect[16].top  + (GrindMarkRect[16].bottom - GrindMarkRect[16].top )/2; 

																	 GrindMeaDis = Math.GetLength(GrindMarkRectCenter[16], OrgBtm5OutPoint[k]);
																	 if(GrindMeaDis<MinDis){
																		 MinDis = GrindMeaDis;
																		 Btm5GrindMarkCount = k;
																	 }
																 }
																 // GrindMark기준 수직 평균값 연마량 측정 
																 if(Btm5GrindMarkCount!=0 && Btm5GrindMarkCount>5 &&(Btm5GrindMarkCount+5<OrgBtm5OutEdgeCount)){
																	 CircleCount=0,TotalCirDis=0.0f,GrindWidthDis=0.0f;
																	 for(int k=Btm5GrindMarkCount-5; k<Btm5GrindMarkCount+5; k++){
																		 if(OrgBtm5OutPoint[k].x==0.0f && OrgBtm5OutPoint[k].y==0.0f) continue;
																		 if(OrgBtm5InPoint [k].x==0.0f && OrgBtm5InPoint [k].y==0.0f) continue;
																		 GrindWidthDis = Math.GetLength(OrgBtm5InPoint[k], OrgBtm5OutPoint[k]);
																		 TotalCirDis+=   GrindWidthDis;
																		 CircleCount++;
																	 }
																	 if(TotalCirDis!=0.0f && CircleCount!=0){
																		 BtmGrindWidth9 = TotalCirDis/CircleCount;
																	 }
																 }
															 }
														 }
													 }
												 }
												 else { // ENCAP 연마량 데이터만 계측함
													 if(BtmOutLine[0].FP0.x!=0.0f && BtmOutLine[0].FP0.y!=0.0f && BtmOutLine[0].FP1.x!=0.0f && BtmOutLine[0].FP1.y!=0.0f &&
														 BtmInLine [0].FP0.x!=0.0f && BtmInLine [0].FP0.y!=0.0f && BtmInLine [0].FP1.x!=0.0f && BtmInLine [0].FP1.y!=0.0f ){
															 // 연마량 계산  
															 if((fabs(BtmOutLine[0].FP0.y - BtmOutLine[0].FP1.y))>1
																 ||(fabs(BtmInLine[0].FP0.y - BtmInLine[0].FP1.y))>1){
																	 BtmGrindWidth1 = BtmOutLine[0].FP0.y - BtmInLine[0].FP0.y; 
																	 BtmGrindWidth5 = BtmOutLine[0].FP0.y - BtmInLine[0].FP0.y; 
																	 BtmGrindWidth9 = BtmOutLine[0].FP0.y - BtmInLine[0].FP0.y; 
															 }
															 else{
																 BtmGrindWidth1 = Math.GetLengthFrLineToPoint(BtmOutLine[0].FP0, BtmOutLine[0].FP1, BtmInLine[0].FP0);
																 BtmGrindWidth5 = Math.GetLengthFrLineToPoint(BtmOutLine[0].FP0, BtmOutLine[0].FP1, BtmInLine[0].FP0);
																 BtmGrindWidth9 = Math.GetLengthFrLineToPoint(BtmOutLine[0].FP0, BtmOutLine[0].FP1, BtmInLine[0].FP0);
															 }
													 }
												 }

												 // 동적 생성한 데이터를 지운다 
												 if(OrgBtm1InPoint !=NULL) delete[] OrgBtm1InPoint;
												 if(OrgBtm1OutPoint!=NULL) delete[] OrgBtm1OutPoint;
												 if(OrgBtm3InPoint !=NULL) delete[] OrgBtm3InPoint;
												 if(OrgBtm3OutPoint!=NULL) delete[] OrgBtm3OutPoint;
												 if(OrgBtm5InPoint !=NULL) delete[] OrgBtm5InPoint;
												 if(OrgBtm5OutPoint!=NULL) delete[] OrgBtm5OutPoint;
												 LogUnit.SetLog(L"shRectC_Btm1_RF_Insp_End");
									     }
									 }
								 }
							 }
						 }
					 } // BMDT END 
				 }

				 // 중국 EdgeInspection 검사시 외곽라인 찾은 이후 Cell_Size, Grind_Size 계산하는 시퀀스 
				 // 중국 BOE 검사 시퀀스 
				 if(FShape==shRectHL){
					 if(FCompanyMode==COM_TIANMA){
						 OrgPoint = Math.OnIntersect(Line[waLeftWall].FP0, Line[waLeftWall].FP1, Line[waTopWall].FP0, Line[waTopWall].FP1);
						 FLTPoint = OrgPoint;

						 BinaryImg.SetSize(GImage->GetWidth(), GImage->GetHeight());
						 EasyImage::Oper(EArithmeticLogicOperation_Copy,GImage,&BinaryImg);
						 EasyImage::Threshold(GImage,&BinaryImg, GrindThresHold);

						 if(IsShortCell){
							 if(IsMarkLine){
								 nCell_Count =0;
								 MarkStrPos.x = MarkPos.x;
								 MarkStrPos.y = MarkPos.y;
								 if(GrindCheck){
									 if(IsMarkBtm){  // 단축 Cam0
										 SingleLine->GImage = &BinaryImg;

										 LSP = FLTPoint;
										 LEP = Math.OnIntersect(Line[0].FP0, Line[0].FP1, LB, RB);
										 FLeftWidth = 100;

										 SingleLine->IRoi->SetOrgX  ((int)(LSP.x-20)     );
										 SingleLine->IRoi->SetOrgY  ((int)LSP.y          );
										 SingleLine->IRoi->SetWidth (FLeftWidth          );
										 SingleLine->IRoi->SetHeight((int)(LEP.y - LSP.y));
										 if(LSP.x-20<=0 || LSP.y <0 || (LEP.y - LSP.y)<=0 || FLeftWidth<=0) return false;

										 // 연마량 측정 OutLine
										 SingleLine->SetFindLineId(0);
										 SingleLine->SetOrientation(orWest);
										 SingleLine->OnExecute();
										 OutLine[0].FP0 = SingleLine->GetResultP0();
										 OutLine[0].FP1 = SingleLine->GetResultP1();

										 // 연마량 측정 InLine
										 SingleLine->SetFindLineId(1);
										 SingleLine->SetOrientation(orWest);
										 SingleLine->OnExecute();
										 InLine[0].FP0 = SingleLine->GetResultP0();
										 InLine[0].FP1 = SingleLine->GetResultP1();

										 SingleLine->SetFindLineId(0);

										 // Cell_Size 측정
										 //Cell_Size = Math.GetLengthFrLineToPoint(Line[0].FP0, Line[0].FP1,MarkPos);
										 FCellPoint[nCell_Count].x = (OutLine[0].FP0.x > OutLine[0].FP1.x) ? (OutLine[0].FP1.x+((OutLine[0].FP0.x - OutLine[0].FP1.x)/2)) :(OutLine[0].FP0.x+((OutLine[0].FP1.x - OutLine[0].FP0.x)/2)); 
										 FCellPoint[nCell_Count].y = (OutLine[0].FP0.y +OutLine[0].FP1.y )/2+ ImageHeight;
										 nCell_Count++;
										 GrindSize = Math.GetLengthFrLineToPoint(OutLine[0].FP0,OutLine[0].FP1, InLine[0].FP0 );

									 }
									 else { // 단축 Cam1
										 SingleLine->GImage = &BinaryImg;
										 LSP = FLTPoint;
										 LEP = Math.OnIntersect(Line[0].FP0, Line[0].FP1, LB, RB);

										 SingleLine->IRoi->SetOrgX  ((int)LSP.x+GROffset           );
										 SingleLine->IRoi->SetOrgY  ((int)LSP.y                    );
										 SingleLine->IRoi->SetWidth ((int)(ImgW - (LSP.x+GROffset)));
										 SingleLine->IRoi->SetHeight((int)(LEP.y - LSP.y)          );
										 if((LSP.x+GROffset)<=0 || LSP.y <0 || (LEP.y - LSP.y)<=0 || (ImgW - (LSP.x+GROffset))<=0 ) return false;

										 // 연마량 측정 OutLine
										 SingleLine->SetFindLineId(0);
										 SingleLine->SetOrientation(orWest);
										 SingleLine->OnExecute();
										 OutLine[0].FP0 = SingleLine->GetResultP0();
										 OutLine[0].FP1 = SingleLine->GetResultP1();

										 // 연마량 측정 InLine
										 SingleLine->SetFindLineId(1);
										 SingleLine->SetOrientation(orWest);
										 SingleLine->OnExecute();
										 InLine[0].FP0 = SingleLine->GetResultP0();
										 InLine[0].FP1 = SingleLine->GetResultP1();

										 SingleLine->SetFindLineId(0);

										 // Cell_Size 측정
										 //Cell_Size = Math.GetLengthFrLineToPoint(Line[0].FP0, Line[0].FP1,MarkPos);
										 FCellPoint[nCell_Count].x = (Line[0].FP0.x > Line[0].FP1.x) ? (Line[0].FP1.x+((Line[0].FP0.x - Line[0].FP1.x)/2)) :(Line[0].FP0.x+((Line[0].FP1.x - Line[0].FP0.x)/2)); 
										 FCellPoint[nCell_Count].y = (Line[0].FP0.y +Line[0].FP1.y)/2+ ImageHeight;
										 nCell_Count++;

										 GrindSize = Math.GetLengthFrLineToPoint(OutLine[0].FP0,OutLine[0].FP1, InLine[0].FP0 );
									 }
								 }
								 else {
									 //Cell_Size = Math.GetLengthFrLineToPoint(Line[0].FP0, Line[0].FP1,MarkPos);
									 FCellPoint[nCell_Count].x = (Line[0].FP0.x > Line[0].FP1.x) ? (Line[0].FP1.x+((Line[0].FP0.x - Line[0].FP1.x)/2)) :(Line[0].FP0.x+((Line[0].FP1.x - Line[0].FP0.x)/2)); 
									 FCellPoint[nCell_Count].y = (Line[0].FP0.y + Line[0].FP1.y)/2+ ImageHeight;
									 nCell_Count++;

									 GrindSize = 0.0f;
								 }
							 }
							 else { // 단축 Cam2, Cam3 Line Inspection(Out -> In)
								 if(GrindOutIn){
									 // GrindLine Start  
									 BinaryImg.SetSize(GImage->GetWidth(), GImage->GetHeight());
									 EasyImage::Oper(EArithmeticLogicOperation_Copy,GImage,&BinaryImg);
									 EasyImage::Threshold(GImage,&BinaryImg, GrindThresHold);

									 // BMLine 기준 연마량 첫번째 Line 검출 
									 SingleLine->GImage = &BinaryImg;

									 LSP = FLTPoint;
									 LEP = Math.OnIntersect(Line[0].FP0, Line[0].FP1, LB, RB);

									 SingleLine->IRoi->SetOrgX  ((int)LSP.x-20       );
									 SingleLine->IRoi->SetOrgY  ((int)LSP.y          );
									 SingleLine->IRoi->SetWidth (100                 );
									 SingleLine->IRoi->SetHeight((int)(LEP.y - LSP.y));

									 if((LSP.x-20)<=0 || (LSP.y<0) || ((LEP.y - LSP.y)<=0)) return false;

									 // 연마량 측정 OutLine
									 SingleLine->SetFindLineId(0);
									 SingleLine->SetOrientation(orWest);
									 SingleLine->OnExecute();
									 OutLine[0].FP0 = SingleLine->GetResultP0();
									 OutLine[0].FP1 = SingleLine->GetResultP1();

									 // OutLine None....make OutLine Data 
									 // 현재의 데이터를 넘겨준다 
									 if(OutLine[0].FP0.x!=0.0f && OutLine[0].FP0.y!=0.0f && OutLine[0].FP1.x!=0.0f && OutLine[0].FP1.y!=0.0f){
										 PreOutLine[0].FP0.x = OutLine[0].FP0.x;    PreOutLine[0].FP1.x = OutLine[0].FP1.x;       
										 PreOutLine[0].FP0.y = OutLine[0].FP0.y;    PreOutLine[0].FP1.y = OutLine[0].FP1.y;       
									 }

									 //Laege Broken 발생으로 Line을 찾지 못할경우 
									 if(OutLine[0].FP0.x==0.0f || OutLine[0].FP0.y==0.0f || OutLine[0].FP1.x==0.0f || OutLine[0].FP1.y==0.0f){
										 if(PreOutLine[0].FP0.x==0.0f && PreOutLine[0].FP0.y==0.0f && PreOutLine[0].FP1.x==0.0f && PreOutLine[0].FP1.y==0.0f){// 시작부분 Broken발생으로 데이터가 없는경우 
											 // Mark좌표를 기준으로 라인좌표값을 다시 설정함 
											 ROI_H = IRoi->GetHeight();
											 OutLine[0].FP0.x = Line[0].FP0.x;    OutLine[0].FP0.y = 0.0f        ;
											 OutLine[0].FP1.x = Line[0].FP1.x;    OutLine[0].FP1.y = (float)ROI_H;

											 //Line 데이터를 PreLine에 넘겨준다 
											 PreOutLine[0].FP0.x = OutLine[0].FP0.x;    PreOutLine[0].FP1.x = OutLine[0].FP1.x;       
											 PreOutLine[0].FP0.y = OutLine[0].FP0.y;    PreOutLine[0].FP1.y = OutLine[0].FP1.y;       
										 }
										 else {                                                                                                    // 중간부분 Broken발생으로 데이터가 없는경우 
											 // PreLine 데이터를 넘겨줌 
											 OutLine[0].FP0.x = PreOutLine[0].FP0.x;  OutLine[0].FP1.x = PreOutLine[0].FP1.x;  
											 OutLine[0].FP0.y = PreOutLine[0].FP0.y;  OutLine[0].FP1.y = PreOutLine[0].FP1.y;  
										 }
									 }

									 // 연마량 측정 InLine
									 SingleLine->SetFindLineId(1);
									 SingleLine->SetOrientation(orWest);
									 SingleLine->OnExecute();
									 InLine[0].FP0 = SingleLine->GetResultP0();
									 InLine[0].FP1 = SingleLine->GetResultP1();

									 // InLine None....make InLine Data 
									 // 현재의 데이터를 넘겨준다 
									 if(InLine[0].FP0.x!=0.0f && InLine[0].FP0.y!=0.0f && InLine[0].FP1.x!=0.0f && InLine[0].FP1.y!=0.0f){
										 PreInLine[0].FP0.x = InLine[0].FP0.x;    PreInLine[0].FP1.x = InLine[0].FP1.x;       
										 PreInLine[0].FP0.y = InLine[0].FP0.y;    PreInLine[0].FP1.y = InLine[0].FP1.y;       
									 }

									 //Laege Broken 발생으로 Line을 찾지 못할경우 
									 if(InLine[0].FP0.x==0.0f || InLine[0].FP0.y==0.0f || InLine[0].FP1.x==0.0f || InLine[0].FP1.y==0.0f){
										 if(PreInLine[0].FP0.x==0.0f && PreInLine[0].FP0.y==0.0f && PreInLine[0].FP1.x==0.0f && PreInLine[0].FP1.y==0.0f){// 시작부분 Broken발생으로 데이터가 없는경우 
											 // Mark좌표를 기준으로 라인좌표값을 다시 설정함 
											 ROI_H = IRoi->GetHeight();
											 InLine[0].FP0.x = Line[0].FP0.x+Grind_Spec;   InLine[0].FP0.y = 0.0f        ;
											 InLine[0].FP1.x = Line[0].FP1.x+Grind_Spec;   InLine[0].FP1.y = (float)ROI_H;

											 //Line 데이터를 PreLine에 넘겨준다 
											 PreInLine[0].FP0.x = InLine[0].FP0.x;    PreInLine[0].FP1.x = InLine[0].FP1.x;       
											 PreInLine[0].FP0.y = InLine[0].FP0.y;    PreInLine[0].FP1.y = InLine[0].FP1.y;       
										 }
										 else {                                                                                                    // 중간부분 Broken발생으로 데이터가 없는경우 
											 // PreLine 데이터를 넘겨줌 
											 InLine[0].FP0.x = PreInLine[0].FP0.x;  InLine[0].FP1.x = PreInLine[0].FP1.x;  
											 InLine[0].FP0.y = PreInLine[0].FP0.y;  InLine[0].FP1.y = PreInLine[0].FP1.y;  
										 }
									 }
									 // GrindLine End  
								 }
								 else { // 단축 Cam2, Cam3 Line Inspection(In -> Out)
									 // BMLine Start 
									 //---------------------------------------------------------------
									 BMLineImg.SetSize(GImage->GetWidth(), GImage->GetHeight());
									 EasyImage::Oper(EArithmeticLogicOperation_Copy,GImage,&BMLineImg);
									 EasyImage::Threshold(GImage,&BMLineImg, EBMLinThresHold);

									 SingleLine->GImage = &BMLineImg;

									 LSP = FLTPoint;
									 LEP = Math.OnIntersect(Line[0].FP0, Line[0].FP1, LB, RB);
									 FLeftWidth = 100;

									 SingleLine->IRoi->SetOrgX  ((int)LSP.x          );
									 SingleLine->IRoi->SetOrgY  ((int)LSP.y          );
									 SingleLine->IRoi->SetWidth (BMWidth             );
									 SingleLine->IRoi->SetHeight((int)(LEP.y - LSP.y));
									 if(LSP.x<=0 || LSP.y <0 || BMWidth<=0 || (LEP.y - LSP.y)<=0 ) return false;

									 SingleLine->SetOrientation(orWest);
									 SingleLine->FIncrement =10;
									 SingleLine->SetFindLineId(0);
									 SingleLine->OnExecute();
									 BMLine[0].FP0 = SingleLine->GetResultP0();
									 BMLine[0].FP1 = SingleLine->GetResultP1();

									 // BMLine None....make BMLine Data 
									 // 현재의 데이터를 넘겨준다 
									 if(BMLine[0].FP0.x!=0.0f && BMLine[0].FP0.y!=0.0f && BMLine[0].FP1.x!=0.0f && BMLine[0].FP1.y!=0.0f){
										 PreBMLine[0].FP0.x = BMLine[0].FP0.x;    PreBMLine[0].FP1.x = BMLine[0].FP1.x;       
										 PreBMLine[0].FP0.y = BMLine[0].FP0.y;    PreBMLine[0].FP1.y = BMLine[0].FP1.y;       
									 }

									 //Laege Broken 발생으로 Line을 찾지 못할경우 
									 if(BMLine[0].FP0.x==0.0f || BMLine[0].FP0.y==0.0f || BMLine[0].FP1.x==0.0f || BMLine[0].FP1.y==0.0f){
										 if(PreBMLine[0].FP0.x==0.0f && PreBMLine[0].FP0.y==0.0f && PreBMLine[0].FP1.x==0.0f && PreBMLine[0].FP1.y==0.0f){// 시작부분 Broken발생으로 데이터가 없는경우 
											 // Mark좌표를 기준으로 라인좌표값을 다시 설정함 
											 ROI_H = IRoi->GetHeight();
											 BMLine[0].FP0.x = (float)(Line[0].FP0.x+BMLineDistance);   BMLine[0].FP0.y = 0.0f        ;
											 BMLine[0].FP1.x = (float)(Line[0].FP1.x+BMLineDistance);   BMLine[0].FP1.y = (float)ROI_H;

											 //Line 데이터를 PreLine에 넘겨준다 
											 PreBMLine[0].FP0.x = BMLine[0].FP0.x;    PreBMLine[0].FP1.x = BMLine[0].FP1.x;       
											 PreBMLine[0].FP0.y = BMLine[0].FP0.y;    PreBMLine[0].FP1.y = BMLine[0].FP1.y;       
										 }
										 else {                                                                                                    // 중간부분 Broken발생으로 데이터가 없는경우 
											 // PreLine 데이터를 넘겨줌 
											 BMLine[0].FP0.x = PreBMLine[0].FP0.x;  BMLine[0].FP1.x = PreBMLine[0].FP1.x;  
											 BMLine[0].FP0.y = PreBMLine[0].FP0.y;  BMLine[0].FP1.y = PreBMLine[0].FP1.y;  
										 }
									 }


									 // 모자 BMLine Data Overlap 단축 Cam2 경우에만 데이터 넘겨줌 
									 // 20160419
									 if(IsBMLineData){
										 if(BMLine[0].FP0.x!=0) BMLineData[InspectCount].Dis1  = (int)(BMLine[0].FP0.x);
										 if(BMLine[0].FP0.x!=0) BMLineData[InspectCount].Dis2  = (int)(BMLine[0].FP1.x);
										 if(BMLine[0].FP0.x!=0) BMLineData[InspectCount].yPos1 = (int)(BMLine[0].FP0.y);
										 if(BMLine[0].FP0.x!=0) BMLineData[InspectCount].yPos2 = (int)(BMLine[0].FP1.y);
									 }
									 else {
										 BMLine[0].FP0.x  = (float)(BMLineData[InspectCount].Dis1+BMLineMargin);
										 BMLine[0].FP0.y  = (float)(BMLineData[InspectCount].yPos1            ); 
										 BMLine[0].FP1.x  = (float)(BMLineData[InspectCount].Dis2+BMLineMargin);
										 BMLine[0].FP1.y  = (float)(BMLineData[InspectCount].yPos2            ); 
									 }
									 // BMLine End 
									 //-----------------------------------------------------------------------------------------

									 // InLine Start 
									 //------------------------------------------------------------------------------------------
									 BinaryImg.SetSize(GImage->GetWidth(), GImage->GetHeight());
									 EasyImage::Oper(EArithmeticLogicOperation_Copy,GImage,&BinaryImg);
									 EasyImage::Threshold(GImage,&BinaryImg, GrindThresHold);

									 // BMLine 기준 연마량 첫번째 Line 검출 
									 SingleLine->GImage = &BinaryImg;

									 SingleLine->IRoi->SetOrgX  ( (int)(LSP.x-20)                                 );
									 SingleLine->IRoi->SetOrgY  ( (int) LSP.y                                     );
									 SingleLine->IRoi->SetWidth (((int)((BMLine[0].FP0.x-BmToMarkDis) - (LSP.x-20))));
									 SingleLine->IRoi->SetHeight( (int)(LEP.y - LSP.y)                            );

									 if((LSP.x-20)<=0 || (LSP.y<0) ||(((BMLine[0].FP0.x-BmToMarkDis) - LSP.x)<=0) || ((LEP.y - LSP.y)<=0)) return false;

									 // 연마량 측정 InLine
									 SingleLine->SetFindLineId(0);
									 SingleLine->SetOrientation(orEast);
									 SingleLine->OnExecute();
									 InLine[0].FP0 = SingleLine->GetResultP0();
									 InLine[0].FP1 = SingleLine->GetResultP1();

									 // InLine None....make InLine Data 
									 // 현재의 데이터를 넘겨준다 
									 if(InLine[0].FP0.x!=0.0f && InLine[0].FP0.y!=0.0f && InLine[0].FP1.x!=0.0f && InLine[0].FP1.y!=0.0f){
										 PreInLine[0].FP0.x = InLine[0].FP0.x;    PreInLine[0].FP1.x = InLine[0].FP1.x;       
										 PreInLine[0].FP0.y = InLine[0].FP0.y;    PreInLine[0].FP1.y = InLine[0].FP1.y;       
									 }

									 //Laege Broken 발생으로 Line을 찾지 못할경우 
									 if(InLine[0].FP0.x==0.0f || InLine[0].FP0.y==0.0f || InLine[0].FP1.x==0.0f || InLine[0].FP1.y==0.0f){
										 if(PreInLine[0].FP0.x==0.0f && PreInLine[0].FP0.y==0.0f && PreInLine[0].FP1.x==0.0f && PreInLine[0].FP1.y==0.0f){// 시작부분 Broken발생으로 데이터가 없는경우 
											 // Mark좌표를 기준으로 라인좌표값을 다시 설정함 
											 ROI_H = IRoi->GetHeight();
											 InLine[0].FP0.x = Line[0].FP0.x+Grind_Spec;   InLine[0].FP0.y = 0.0f        ;
											 InLine[0].FP1.x = Line[0].FP1.x+Grind_Spec;   InLine[0].FP1.y = (float)ROI_H;

											 //Line 데이터를 PreLine에 넘겨준다 
											 PreInLine[0].FP0.x = InLine[0].FP0.x;    PreInLine[0].FP1.x = InLine[0].FP1.x;       
											 PreInLine[0].FP0.y = InLine[0].FP0.y;    PreInLine[0].FP1.y = InLine[0].FP1.y;       
										 }
										 else {                                                                                                    // 중간부분 Broken발생으로 데이터가 없는경우 
											 // PreLine 데이터를 넘겨줌 
											 InLine[0].FP0.x = PreInLine[0].FP0.x;  InLine[0].FP1.x = PreInLine[0].FP1.x;  
											 InLine[0].FP0.y = PreInLine[0].FP0.y;  InLine[0].FP1.y = PreInLine[0].FP1.y;  
										 }
									 }
									 // InLine End 
									 //------------------------------------------------------------------------------------------


									 // OutLine & 연마량 측정 Start 
									 //------------------------------------------------------------------------------------------
									 SingleLine->SetFindLineId(1);
									 SingleLine->SetOrientation(orEast);
									 SingleLine->OnExecute();
									 OutLine[0].FP0 = SingleLine->GetResultP0();
									 OutLine[0].FP1 = SingleLine->GetResultP1();

									 // OutLine None....make OutLine Data 
									 // 현재의 데이터를 넘겨준다 
									 if(OutLine[0].FP0.x!=0.0f && OutLine[0].FP0.y!=0.0f && OutLine[0].FP1.x!=0.0f && OutLine[0].FP1.y!=0.0f){
										 PreOutLine[0].FP0.x = OutLine[0].FP0.x;    PreOutLine[0].FP1.x = OutLine[0].FP1.x;       
										 PreOutLine[0].FP0.y = OutLine[0].FP0.y;    PreOutLine[0].FP1.y = OutLine[0].FP1.y;       
									 }

									 //Laege Broken 발생으로 Line을 찾지 못할경우 
									 if(OutLine[0].FP0.x==0.0f || OutLine[0].FP0.y==0.0f || OutLine[0].FP1.x==0.0f || OutLine[0].FP1.y==0.0f){
										 if(PreOutLine[0].FP0.x==0.0f && PreOutLine[0].FP0.y==0.0f && PreOutLine[0].FP1.x==0.0f && PreOutLine[0].FP1.y==0.0f){// 시작부분 Broken발생으로 데이터가 없는경우 
											 // Mark좌표를 기준으로 라인좌표값을 다시 설정함 
											 ROI_H = IRoi->GetHeight();
											 OutLine[0].FP0.x = Line[0].FP0.x;    OutLine[0].FP0.y = 0.0f        ;
											 OutLine[0].FP1.x = Line[0].FP1.x;    OutLine[0].FP1.y = (float)ROI_H;

											 //Line 데이터를 PreLine에 넘겨준다 
											 PreOutLine[0].FP0.x = OutLine[0].FP0.x;    PreOutLine[0].FP1.x = OutLine[0].FP1.x;       
											 PreOutLine[0].FP0.y = OutLine[0].FP0.y;    PreOutLine[0].FP1.y = OutLine[0].FP1.y;       
										 }
										 else {                                                                                                    // 중간부분 Broken발생으로 데이터가 없는경우 
											 // PreLine 데이터를 넘겨줌 
											 OutLine[0].FP0.x = PreOutLine[0].FP0.x;  OutLine[0].FP1.x = PreOutLine[0].FP1.x;  
											 OutLine[0].FP0.y = PreOutLine[0].FP0.y;  OutLine[0].FP1.y = PreOutLine[0].FP1.y;  
										 }
									 }

									 // Cell_Size 
									 Cell_Size = Math.GetLengthFrLineToPoint(OutLine[0].FP0,OutLine[0].FP1, BMLine[0].FP0 );
								 }

								 SingleLine->SetFindLineId(0);

								 // Cell_Size 측정
								 //Cell_Size = Math.GetLengthFrLineToPoint(OutLine[0].FP0,OutLine[0].FP1, BMLine[0].FP0 );
								 GrindSize = Math.GetLengthFrLineToPoint(OutLine[0].FP0,OutLine[0].FP1, InLine[0].FP0 );
							 }
						 }
						 else { // 장축 Cam0, Cam1, Cam2, Cam3
							 if(IsLongTop){
								 GrindSize = 0.0f;
								 if(!GrindOutIn){
									 MarkPos.y = (Line[0].FP0.y + Line[0].FP1.y)/2;
									 if(BmToMarkDis!=0) Cell_Size = (float)(Math.GetLengthFrLineToPoint(Line[0].FP0, Line[0].FP1, MarkPos) - BmToMarkDis);
									 //Only Display 
									 BMLine[0].FP0.x = Line[0].FP0.x+Cell_Size;
									 BMLine[0].FP0.y = FLTPoint.y             ;
									 BMLine[0].FP1.x = Line[0].FP1.x+Cell_Size; 
									 BMLine[0].FP1.y = Line[0].FP1.y          ;
								 }
							 }
							 else {
								 // BMLine 기준 연마량 첫번째 Line 검출 
								 SingleLine->GImage = &BinaryImg;

								 LSP = FLTPoint;
								 LEP = Math.OnIntersect(Line[0].FP0, Line[0].FP1, LB, RB);
								 FLeftWidth = 100;

								 SingleLine->IRoi->SetOrgX  ((int)(LSP.x-20)     );
								 SingleLine->IRoi->SetOrgY  ((int)LSP.y          );
								 SingleLine->IRoi->SetWidth (FLeftWidth          );
								 SingleLine->IRoi->SetHeight((int)(LEP.y - LSP.y));
								 if(LSP.x-20<=0 || LSP.y <0 || FLeftWidth<=0 || (LEP.y - LSP.y)<=0 ) return false;

								 // 연마량 측정 OutLine
								 SingleLine->SetFindLineId(0);
								 SingleLine->SetOrientation(orWest);
								 SingleLine->OnExecute();
								 OutLine[0].FP0 = SingleLine->GetResultP0();
								 OutLine[0].FP1 = SingleLine->GetResultP1();

								 // 연마량 측정 InLine
								 SingleLine->SetFindLineId(1);
								 SingleLine->SetOrientation(orWest);
								 SingleLine->OnExecute();
								 InLine[0].FP0 = SingleLine->GetResultP0();
								 InLine[0].FP1 = SingleLine->GetResultP1();

								 SingleLine->SetFindLineId(0);
								 GrindSize =(float)(Math.GetLengthFrLineToPoint (OutLine[0].FP0,OutLine[0].FP1, InLine[0].FP0 ));

								 if(!GrindOutIn){
									 // Cell_Size 측정
									 //Cell_Size = Math.GetLengthFrLineToPoint(OutLine[0].FP0,OutLine[0].FP1, BMLine[0].FP0 );
									 MarkPos.y = (OutLine[0].FP0.y + OutLine[0].FP1.y)/2;
									 if(BmToMarkDis!=0) Cell_Size =(float)((Math.GetLengthFrLineToPoint(OutLine[0].FP0,OutLine[0].FP1, MarkPos) - BmToMarkDis));

									 //Only Display 
									 BMLine[0].FP0.x = OutLine[0].FP0.x+Cell_Size;
									 BMLine[0].FP0.y = FLTPoint.y                ;
									 BMLine[0].FP1.x = OutLine[0].FP1.x+Cell_Size; 
									 BMLine[0].FP1.y = OutLine[0].FP1.y;
								 }
							 }
						 }
					 }
					 else if(FCompanyMode==COM_BOE){  // RectHL OutLine, InLine Search
// 						 BinaryImg.SetSize(GImage->GetWidth(), GImage->GetHeight());
// 						 EasyImage::Oper(EArithmeticLogicOperation_Copy,GImage,&BinaryImg);
// 						 EasyImage::Threshold(GImage,&BinaryImg, GrindThresHold);

						 BinaryImg.SetSize(GImage->GetWidth(), GImage->GetHeight());
						 EasyImage::Oper(EArithmeticLogicOperation_Copy,GImage,&BinaryImg);
						 EasyImage::Threshold(GImage,&BinaryImg,EThresHold);

						 // BMLine 기준 연마량 첫번째 Line 검출 
						 SingleLine->GImage = &BinaryImg;

// 						 LSP = FLTPoint;
						 LSP = FLTLPoint;
						 LEP = Math.OnIntersect(Line[0].FP0, Line[0].FP1, LB, RB);

						 SingleLine->IRoi->SetOrgX  ((int)LSP.x-20       );
						 SingleLine->IRoi->SetOrgY  ((int)LSP.y          );
						 SingleLine->IRoi->SetWidth (100                 );
						 SingleLine->IRoi->SetHeight((int)(LEP.y - LSP.y));

						 if((LSP.x-20)<=0 || (LSP.y<0) || ((LEP.y - LSP.y)<=0)) return false;

						 // 연마량 측정 OutLine
						 SingleLine->SetFindLineId(0);
						 SingleLine->SetOrientation(orWest);

						 if(IRoi->GetHeight()<300) SingleLine->SetIncrement(5 );
						 else                      SingleLine->SetIncrement(100);

						 SingleLine->OnExecute();
						 OutLine[0].FP0 = SingleLine->GetResultP0();
						 OutLine[0].FP1 = SingleLine->GetResultP1();

						 // OutLine None....make OutLine Data 
						 // 현재의 데이터를 넘겨준다 
						 if(OutLine[0].FP0.x!=0.0f && OutLine[0].FP0.y!=0.0f && OutLine[0].FP1.x!=0.0f && OutLine[0].FP1.y!=0.0f){
							 PreOutLine[0].FP0.x = OutLine[0].FP0.x;    PreOutLine[0].FP1.x = OutLine[0].FP1.x;       
							 PreOutLine[0].FP0.y = OutLine[0].FP0.y;    PreOutLine[0].FP1.y = OutLine[0].FP1.y;       
						 }

						 //Laege Broken 발생으로 Line을 찾지 못할경우 
						 if(OutLine[0].FP0.x==0.0f || OutLine[0].FP0.y==0.0f || OutLine[0].FP1.x==0.0f || OutLine[0].FP1.y==0.0f){
							 if(PreOutLine[0].FP0.x==0.0f && PreOutLine[0].FP0.y==0.0f && PreOutLine[0].FP1.x==0.0f && PreOutLine[0].FP1.y==0.0f){// 시작부분 Broken발생으로 데이터가 없는경우 
								 // Mark좌표를 기준으로 라인좌표값을 다시 설정함 
								 ROI_H = IRoi->GetHeight();
								 OutLine[0].FP0.x = Line[0].FP0.x;    OutLine[0].FP0.y = 0.0f        ;
								 OutLine[0].FP1.x = Line[0].FP1.x;    OutLine[0].FP1.y = (float)ROI_H;

								 //Line 데이터를 PreLine에 넘겨준다 
								 PreOutLine[0].FP0.x = OutLine[0].FP0.x;    PreOutLine[0].FP1.x = OutLine[0].FP1.x;       
								 PreOutLine[0].FP0.y = OutLine[0].FP0.y;    PreOutLine[0].FP1.y = OutLine[0].FP1.y;       
							 }
							 else {                                                                                                    // 중간부분 Broken발생으로 데이터가 없는경우 
								 // PreLine 데이터를 넘겨줌 
								 OutLine[0].FP0.x = PreOutLine[0].FP0.x;  OutLine[0].FP1.x = PreOutLine[0].FP1.x;  
								 OutLine[0].FP0.y = PreOutLine[0].FP0.y;  OutLine[0].FP1.y = PreOutLine[0].FP1.y;  
							 }
						 }
						 // 연마량 측정 InLine
						 // ORG 
// 						 SingleLine->SetFindLineId(1);
// 						 SingleLine->SetOrientation(orWest);
// 						 SingleLine->OnExecute();
// 						 InLine[0].FP0 = SingleLine->GetResultP0();
// 						 InLine[0].FP1 = SingleLine->GetResultP1();

						 BinaryImg.SetSize(GImage->GetWidth(), GImage->GetHeight());
						 EasyImage::Oper(EArithmeticLogicOperation_Copy,GImage,&BinaryImg);
						 EasyImage::Threshold(GImage,&BinaryImg,GrindThresHold);

						 // BMLine 기준 연마량 첫번째 Line 검출 
						 SingleLine->GImage = &BinaryImg;

						 // 						 LSP = FLTPoint;
						 LSP = FLTLPoint;
						 LEP = Math.OnIntersect(OutLine[0].FP0, OutLine[0].FP1, LB, RB);

						 SingleLine->IRoi->SetOrgX  ((int)LSP.x+2        );
						 SingleLine->IRoi->SetOrgY  ((int)LSP.y          );
						 SingleLine->IRoi->SetWidth (100                 );
						 SingleLine->IRoi->SetHeight((int)(LEP.y - LSP.y));

						 if((LSP.x+10)<=0 || (LSP.y<0) || ((LEP.y - LSP.y)<=0)) return false;

						 // 연마량 측정 OutLine
						 SingleLine->SetFindLineId(0);
						 SingleLine->SetOrientation(orWest);

						 if(IRoi->GetHeight()<300) SingleLine->SetIncrement(5 );
						 else                      SingleLine->SetIncrement(100);

						 SingleLine->SetEdgeType(0);  // Black -> White

						 SingleLine->OnExecute();
						 InLine[0].FP0 = SingleLine->GetResultP0();
						 InLine[0].FP1 = SingleLine->GetResultP1();

						 SingleLine->SetEdgeType(2); // O

						 // InLine None....make InLine Data 
						 // 현재의 데이터를 넘겨준다 
						 if(InLine[0].FP0.x!=0.0f && InLine[0].FP0.y!=0.0f && InLine[0].FP1.x!=0.0f && InLine[0].FP1.y!=0.0f){
							 PreInLine[0].FP0.x = InLine[0].FP0.x;    PreInLine[0].FP1.x = InLine[0].FP1.x;       
							 PreInLine[0].FP0.y = InLine[0].FP0.y;    PreInLine[0].FP1.y = InLine[0].FP1.y;       
						 }

						 //Laege Broken 발생으로 Line을 찾지 못할경우 
						 if(InLine[0].FP0.x==0.0f || InLine[0].FP0.y==0.0f || InLine[0].FP1.x==0.0f || InLine[0].FP1.y==0.0f){
							 if(PreInLine[0].FP0.x==0.0f && PreInLine[0].FP0.y==0.0f && PreInLine[0].FP1.x==0.0f && PreInLine[0].FP1.y==0.0f){// 시작부분 Broken발생으로 데이터가 없는경우 
								 // Mark좌표를 기준으로 라인좌표값을 다시 설정함 
								 ROI_H = IRoi->GetHeight();
								 InLine[0].FP0.x = Line[0].FP0.x+Grind_Spec;   InLine[0].FP0.y = 0.0f        ;
								 InLine[0].FP1.x = Line[0].FP1.x+Grind_Spec;   InLine[0].FP1.y = (float)ROI_H;

								 //Line 데이터를 PreLine에 넘겨준다 
								 PreInLine[0].FP0.x = InLine[0].FP0.x;    PreInLine[0].FP1.x = InLine[0].FP1.x;       
								 PreInLine[0].FP0.y = InLine[0].FP0.y;    PreInLine[0].FP1.y = InLine[0].FP1.y;       
							 }
							 else {                                                                                                    // 중간부분 Broken발생으로 데이터가 없는경우 
								 // PreLine 데이터를 넘겨줌 
								 InLine[0].FP0.x = PreInLine[0].FP0.x;  InLine[0].FP1.x = PreInLine[0].FP1.x;  
								 InLine[0].FP0.y = PreInLine[0].FP0.y;  InLine[0].FP1.y = PreInLine[0].FP1.y;  
							 }
						 }
						 // GrindSize 측정 
						 // 사용자가 지정한 간격만큼 GrindSize 측정은 어떻게??..........
						 GrindSize =(float)(Math.GetLengthFrLineToPoint (OutLine[0].FP0,OutLine[0].FP1, InLine[0].FP0 ));
					 }
				 }
                 if (FShape==shRectSL){ // 젓가락 
					 if(FCompanyMode==COM_TIANMA){
						 if(IsShortCell){
							 if(IsMarkLine){
								 MarkStrPos.x = MarkPos.x;
								 MarkStrPos.y = MarkPos.y;
								 if(GrindCheck){
									 if(IsMarkBtm){
										 MarkStrPos = MarkPos;

										 BinaryImg.SetSize(GImage->GetWidth(), GImage->GetHeight());
										 EasyImage::Oper(EArithmeticLogicOperation_Copy,GImage,&BinaryImg);
										 EasyImage::Threshold(GImage,&BinaryImg, GrindThresHold);

										 SingleLine->GImage = &BinaryImg;
										 if(fabs(Line[0].FP0.x - Line[0].FP1.x) > 3){
											 LSP.x = (Line[0].FP0.x + Line[0].FP1.x)/2;
											 LSP.y = 0.0f;
										 }
										 else {
											 LSP = Math.OnIntersect(Line[0].FP0, Line[0].FP1, LT, RT);
										 }
										 FLeftWidth = 100;

										 SingleLine->IRoi->SetOrgX  ((int)(LSP.x-20)     );
										 SingleLine->IRoi->SetOrgY  ( 0                  );
										 SingleLine->IRoi->SetWidth (FLeftWidth          );
										 SingleLine->IRoi->SetHeight(ImgH                );
										 if(LSP.x-20<=0 || FLeftWidth<=0 || ImgH <=0  ) return false;

										 // 연마량 측정 OutLine
										 SingleLine->SetFindLineId(0);
										 SingleLine->SetOrientation(orWest);
										 SingleLine->OnExecute();
										 OutLine[0].FP0 = SingleLine->GetResultP0();
										 OutLine[0].FP1 = SingleLine->GetResultP1();

										 // 연마량 측정 InLine
										 SingleLine->SetFindLineId(1);
										 SingleLine->SetOrientation(orWest);
										 SingleLine->OnExecute();
										 InLine[0].FP0 = SingleLine->GetResultP0();
										 InLine[0].FP1 = SingleLine->GetResultP1();

										 SingleLine->SetFindLineId(0);

										 // Cell_Size 측정
										 //Cell_Size = Math.GetLengthFrLineToPoint(Line[0].FP0, Line[0].FP1,MarkPos);
										 FCellPoint[nCell_Count].x = (OutLine[0].FP0.x > OutLine[0].FP1.x) ? (OutLine[0].FP1.x+((OutLine[0].FP0.x - OutLine[0].FP1.x)/2)) :(OutLine[0].FP0.x+((OutLine[0].FP1.x - OutLine[0].FP0.x)/2)); 
										 FCellPoint[nCell_Count].y = (OutLine[0].FP0.y +OutLine[0].FP1.y)/2+ ImageHeight;
										 nCell_Count++;

										 GrindSize = Math.GetLengthFrLineToPoint(OutLine[0].FP0,OutLine[0].FP1, InLine[0].FP0 );
									 }
									 else {
										 BinaryImg.SetSize(GImage->GetWidth(), GImage->GetHeight());
										 EasyImage::Oper(EArithmeticLogicOperation_Copy,GImage,&BinaryImg);
										 EasyImage::Threshold(GImage,&BinaryImg, GrindThresHold);

										 SingleLine->GImage = &BinaryImg;
										 if(fabs(Line[0].FP0.x - Line[0].FP1.x) > 3){
											 LSP.x = (Line[0].FP0.x + Line[0].FP1.x)/2;
											 LSP.y = 0.0f;
										 }
										 else {
											 LSP = Math.OnIntersect(Line[0].FP0, Line[0].FP1, LT, RT);
										 }

										 SingleLine->IRoi->SetOrgX  ((int)LSP.x+GROffset           );
										 SingleLine->IRoi->SetOrgY  (0                             );
										 SingleLine->IRoi->SetWidth ((int)(ImgW - (LSP.x+GROffset)));
										 SingleLine->IRoi->SetHeight(ImgH                          );
										 if(((LSP.x+GROffset)<=0) || ((ImgW - (LSP.x+GROffset))<=0) || ImgH<=0 ) return false;

										 // 연마량 측정 OutLine
										 SingleLine->SetFindLineId(0);
										 SingleLine->SetOrientation(orWest);
										 SingleLine->OnExecute();
										 OutLine[0].FP0 = SingleLine->GetResultP0();
										 OutLine[0].FP1 = SingleLine->GetResultP1();

										 // 연마량 측정 InLine
										 SingleLine->SetFindLineId(1);
										 SingleLine->SetOrientation(orWest);
										 SingleLine->OnExecute();
										 InLine[0].FP0 = SingleLine->GetResultP0();
										 InLine[0].FP1 = SingleLine->GetResultP1();

										 SingleLine->SetFindLineId(0);

										 // Cell_Size 측정
										 //Cell_Size = Math.GetLengthFrLineToPoint(Line[0].FP0, Line[0].FP1,MarkPos);
										 FCellPoint[nCell_Count].x = (Line[0].FP0.x > Line[0].FP1.x) ? (Line[0].FP1.x+((Line[0].FP0.x - Line[0].FP1.x)/2)) :(Line[0].FP0.x+((Line[0].FP1.x - Line[0].FP0.x)/2)); 
										 FCellPoint[nCell_Count].y = (Line[0].FP0.y + Line[0].FP1.y)/2+ ImageHeight;
										 nCell_Count++;

										 GrindSize = Math.GetLengthFrLineToPoint(OutLine[0].FP0,OutLine[0].FP1, InLine[0].FP0 );
									 }
								 }
								 else {
									 //Cell_Size = Math.GetLengthFrLineToPoint(Line[0].FP0, Line[0].FP1,MarkPos);
									 FCellPoint[nCell_Count].x = (Line[0].FP0.x > Line[0].FP1.x) ? (Line[0].FP1.x+((Line[0].FP0.x - Line[0].FP1.x)/2)) :(Line[0].FP0.x+((Line[0].FP1.x - Line[0].FP0.x)/2)); 
									 FCellPoint[nCell_Count].y = (Line[0].FP0.y + Line[0].FP1.y)/2+ ImageHeight;
									 nCell_Count++;

									 GrindSize = 0.0f;
								 }
							 }
							 else {
								 if(GrindOutIn){ //단축 Cam2, Cam3 Line Inspection(Out -> In)
									 BinaryImg.SetSize(GImage->GetWidth(), GImage->GetHeight());
									 EasyImage::Oper(EArithmeticLogicOperation_Copy,GImage,&BinaryImg);
									 EasyImage::Threshold(GImage,&BinaryImg, GrindThresHold);

									 // BMLine 기준 연마량 첫번째 Line 검출 
									 SingleLine->GImage = &BinaryImg;

									 if(fabs(Line[0].FP0.x - Line[0].FP1.x) > 3){
										 LSP.x = (Line[0].FP0.x + Line[0].FP1.x)/2;
										 LSP.y = 0.0f;
									 }
									 else {
										 LSP = Math.OnIntersect(Line[0].FP0, Line[0].FP1, LT, RT);
									 }

									 SingleLine->IRoi->SetOrgX  ((int)LSP.x-20);
									 SingleLine->IRoi->SetOrgY  (0            );
									 SingleLine->IRoi->SetWidth (100          );
									 SingleLine->IRoi->SetHeight(ImgH         );

									 if(((LSP.x-20)<=0) || (ImgH<=0)) return false;

									 // 연마량 측정 OutLine
									 SingleLine->SetFindLineId(0);
									 SingleLine->SetOrientation(orWest);
									 SingleLine->OnExecute();
									 OutLine[0].FP0 = SingleLine->GetResultP0();
									 OutLine[0].FP1 = SingleLine->GetResultP1();

									 // OutLine None....make OutLine Data 
									 // 현재의 데이터를 넘겨준다 
									 if(OutLine[0].FP0.x!=0.0f && OutLine[0].FP0.y!=0.0f && OutLine[0].FP1.x!=0.0f && OutLine[0].FP1.y!=0.0f){
										 PreOutLine[0].FP0.x = OutLine[0].FP0.x;    PreOutLine[0].FP1.x = OutLine[0].FP1.x;       
										 PreOutLine[0].FP0.y = OutLine[0].FP0.y;    PreOutLine[0].FP1.y = OutLine[0].FP1.y;       
									 }

									 //Laege Broken 발생으로 Line을 찾지 못할경우 
									 if(OutLine[0].FP0.x==0.0f || OutLine[0].FP0.y==0.0f || OutLine[0].FP1.x==0.0f || OutLine[0].FP1.y==0.0f){
										 if(PreOutLine[0].FP0.x==0.0f && PreOutLine[0].FP0.y==0.0f && PreOutLine[0].FP1.x==0.0f && PreOutLine[0].FP1.y==0.0f){// 시작부분 Broken발생으로 데이터가 없는경우 
											 // Mark좌표를 기준으로 라인좌표값을 다시 설정함 
											 ROI_H = IRoi->GetHeight();
											 OutLine[0].FP0.x = Line[0].FP0.x;    OutLine[0].FP0.y = 0.0f        ;
											 OutLine[0].FP1.x = Line[0].FP1.x;    OutLine[0].FP1.y = (float)ROI_H;

											 //Line 데이터를 PreLine에 넘겨준다 
											 PreOutLine[0].FP0.x = OutLine[0].FP0.x;    PreOutLine[0].FP1.x = OutLine[0].FP1.x;       
											 PreOutLine[0].FP0.y = OutLine[0].FP0.y;    PreOutLine[0].FP1.y = OutLine[0].FP1.y;       
										 }
										 else {                                                                                                    // 중간부분 Broken발생으로 데이터가 없는경우 
											 // PreLine 데이터를 넘겨줌 
											 OutLine[0].FP0.x = PreOutLine[0].FP0.x;  OutLine[0].FP1.x = PreOutLine[0].FP1.x;  
											 OutLine[0].FP0.y = PreOutLine[0].FP0.y;  OutLine[0].FP1.y = PreOutLine[0].FP1.y;  
										 }
									 }

									 // 연마량 측정 InLine
									 SingleLine->SetFindLineId(1);
									 SingleLine->SetOrientation(orWest);
									 SingleLine->OnExecute();
									 InLine[0].FP0 = SingleLine->GetResultP0();
									 InLine[0].FP1 = SingleLine->GetResultP1();

									 // InLine None....make InLine Data 
									 // 현재의 데이터를 넘겨준다 
									 if(InLine[0].FP0.x!=0.0f && InLine[0].FP0.y!=0.0f && InLine[0].FP1.x!=0.0f && InLine[0].FP1.y!=0.0f){
										 PreInLine[0].FP0.x = InLine[0].FP0.x;    PreInLine[0].FP1.x = InLine[0].FP1.x;       
										 PreInLine[0].FP0.y = InLine[0].FP0.y;    PreInLine[0].FP1.y = InLine[0].FP1.y;       
									 }

									 //Laege Broken 발생으로 Line을 찾지 못할경우 
									 if(InLine[0].FP0.x==0.0f || InLine[0].FP0.y==0.0f || InLine[0].FP1.x==0.0f || InLine[0].FP1.y==0.0f){
										 if(PreInLine[0].FP0.x==0.0f && PreInLine[0].FP0.y==0.0f && PreInLine[0].FP1.x==0.0f && PreInLine[0].FP1.y==0.0f){// 시작부분 Broken발생으로 데이터가 없는경우 
											 // Mark좌표를 기준으로 라인좌표값을 다시 설정함 
											 ROI_H = IRoi->GetHeight();
											 InLine[0].FP0.x = Line[0].FP0.x+Grind_Spec;   InLine[0].FP0.y = 0.0f        ;
											 InLine[0].FP1.x = Line[0].FP1.x+Grind_Spec;   InLine[0].FP1.y = (float)ROI_H;

											 //Line 데이터를 PreLine에 넘겨준다 
											 PreInLine[0].FP0.x = InLine[0].FP0.x;    PreInLine[0].FP1.x = InLine[0].FP1.x;       
											 PreInLine[0].FP0.y = InLine[0].FP0.y;    PreInLine[0].FP1.y = InLine[0].FP1.y;       
										 }
										 else {                                                                                                    // 중간부분 Broken발생으로 데이터가 없는경우 
											 // PreLine 데이터를 넘겨줌 
											 InLine[0].FP0.x = PreInLine[0].FP0.x;  InLine[0].FP1.x = PreInLine[0].FP1.x;  
											 InLine[0].FP0.y = PreInLine[0].FP0.y;  InLine[0].FP1.y = PreInLine[0].FP1.y;  
										 }
									 }
								 }
								 else { //단축 Cam2, Cam3 Line Inspection(In -> Out)
									 // BMLine Start 
									 //-------------------------------------------------------------------------
									 BMLineImg.SetSize(GImage->GetWidth(), GImage->GetHeight());
									 EasyImage::Oper(EArithmeticLogicOperation_Copy,GImage,&BMLineImg);
									 EasyImage::Threshold(GImage,&BMLineImg, EBMLinThresHold);

									 SingleLine->GImage = &BMLineImg;


									 // 영역설정 
									 if(fabs(Line[0].FP0.x - Line[0].FP1.x) > 3){
										 LSP.x = (Line[0].FP0.x + Line[0].FP1.x)/2;
										 LSP.y = 0.0f;
									 }
									 else {
										 LSP = Math.OnIntersect(Line[0].FP0, Line[0].FP1, LT, RT);
									 }

									 // BMLine 찾기 
									 SingleLine->IRoi->SetOrgX  ((int)LSP.x );
									 SingleLine->IRoi->SetOrgY  (0          );
									 SingleLine->IRoi->SetWidth (BMWidth    );
									 SingleLine->IRoi->SetHeight(ImgH       );

									 if(LSP.x<=0 || BMWidth<=0 || ImgH<=0) return false;

									 SingleLine->SetOrientation(orWest);
									 SingleLine->FIncrement =10;
									 SingleLine->SetFindLineId(0);
									 SingleLine->OnExecute();
									 BMLine[0].FP0 = SingleLine->GetResultP0();
									 BMLine[0].FP1 = SingleLine->GetResultP1();

									 // BMLine None....make BMLine Data 
									 // 현재의 데이터를 넘겨준다 
									 if(BMLine[0].FP0.x!=0.0f && BMLine[0].FP0.y!=0.0f && BMLine[0].FP1.x!=0.0f && BMLine[0].FP1.y!=0.0f){
										 PreBMLine[0].FP0.x = BMLine[0].FP0.x;    PreBMLine[0].FP1.x = BMLine[0].FP1.x;       
										 PreBMLine[0].FP0.y = BMLine[0].FP0.y;    PreBMLine[0].FP1.y = BMLine[0].FP1.y;       
									 }

									 //Laege Broken 발생으로 Line을 찾지 못할경우 
									 if(BMLine[0].FP0.x==0.0f || BMLine[0].FP0.y==0.0f || BMLine[0].FP1.x==0.0f || BMLine[0].FP1.y==0.0f){
										 if(PreBMLine[0].FP0.x==0.0f && PreBMLine[0].FP0.y==0.0f && PreBMLine[0].FP1.x==0.0f && PreBMLine[0].FP1.y==0.0f){// 시작부분 Broken발생으로 데이터가 없는경우 
											 // Mark좌표를 기준으로 라인좌표값을 다시 설정함 
											 ROI_H = IRoi->GetHeight();
											 BMLine[0].FP0.x = (float)(Line[0].FP0.x+BMLineDistance);   BMLine[0].FP0.y = 0.0f        ;
											 BMLine[0].FP1.x = (float)(Line[0].FP1.x+BMLineDistance);   BMLine[0].FP1.y = (float)ROI_H;

											 //Line 데이터를 PreLine에 넘겨준다 
											 PreBMLine[0].FP0.x = BMLine[0].FP0.x;    PreBMLine[0].FP1.x = BMLine[0].FP1.x;       
											 PreBMLine[0].FP0.y = BMLine[0].FP0.y;    PreBMLine[0].FP1.y = BMLine[0].FP1.y;       
										 }
										 else {                                                                                                    // 중간부분 Broken발생으로 데이터가 없는경우 
											 // PreLine 데이터를 넘겨줌 
											 BMLine[0].FP0.x = PreBMLine[0].FP0.x;  BMLine[0].FP1.x = PreBMLine[0].FP1.x;  
											 BMLine[0].FP0.y = PreBMLine[0].FP0.y;  BMLine[0].FP1.y = PreBMLine[0].FP1.y;  
										 }
									 }

									 // 젓가락  BMLine Data Overlap 단축 Cam2 경우에만 데이터 넘겨줌 
									 // 20160419
									 if(IsBMLineData){
										 if(BMLine[0].FP0.x!=0) BMLineData[InspectCount].Dis1  = (int)(BMLine[0].FP0.x);
										 if(BMLine[0].FP0.x!=0) BMLineData[InspectCount].Dis2  = (int)(BMLine[0].FP1.x);
										 if(BMLine[0].FP0.x!=0) BMLineData[InspectCount].yPos1 = (int)(BMLine[0].FP0.y);
										 if(BMLine[0].FP0.x!=0) BMLineData[InspectCount].yPos2 = (int)(BMLine[0].FP1.y);
									 }
									 else {
										 BMLine[0].FP0.x  = (float)(BMLineData[InspectCount].Dis1+BMLineMargin);
										 BMLine[0].FP0.y  = (float)(BMLineData[InspectCount].yPos1            ); 
										 BMLine[0].FP1.x  = (float)(BMLineData[InspectCount].Dis2+BMLineMargin);
										 BMLine[0].FP1.y  = (float)(BMLineData[InspectCount].yPos2            ); 
									 }
									 // BMLine End  
									 //-------------------------------------------------------------------------


									 // InLine Start 
									 //-------------------------------------------------------------------------
									 BinaryImg.SetSize(GImage->GetWidth(), GImage->GetHeight());
									 EasyImage::Oper(EArithmeticLogicOperation_Copy,GImage,&BinaryImg);
									 EasyImage::Threshold(GImage,&BinaryImg, GrindThresHold);

									 // BMLine 기준 연마량 첫번째 Line 검출 
									 SingleLine->GImage = &BinaryImg;

									 SingleLine->IRoi->SetOrgX  ( (int)(LSP.x-20)                            );
									 SingleLine->IRoi->SetOrgY  ( 0                                          );
									 SingleLine->IRoi->SetWidth (((int)((BMLine[0].FP0.x-BmToMarkDis) - (LSP.x-20))));
									 SingleLine->IRoi->SetHeight( ImgH                                       );

									 if((LSP.x-20)<=0 || ((BMLine[0].FP0.x-BmToMarkDis) - (LSP.x-20))<=0 ||(ImgH<=0)) return false;


									 // 연마량 측정 InLine
									 SingleLine->SetFindLineId(0);
									 SingleLine->SetOrientation(orEast);
									 SingleLine->OnExecute();
									 InLine[0].FP0 = SingleLine->GetResultP0();
									 InLine[0].FP1 = SingleLine->GetResultP1();

									 // InLine None....make InLine Data 
									 // 현재의 데이터를 넘겨준다 
									 if(InLine[0].FP0.x!=0.0f && InLine[0].FP0.y!=0.0f && InLine[0].FP1.x!=0.0f && InLine[0].FP1.y!=0.0f){
										 PreInLine[0].FP0.x = InLine[0].FP0.x;    PreInLine[0].FP1.x = InLine[0].FP1.x;       
										 PreInLine[0].FP0.y = InLine[0].FP0.y;    PreInLine[0].FP1.y = InLine[0].FP1.y;       
									 }

									 //Laege Broken 발생으로 Line을 찾지 못할경우 
									 if(InLine[0].FP0.x==0.0f || InLine[0].FP0.y==0.0f || InLine[0].FP1.x==0.0f || InLine[0].FP1.y==0.0f){
										 if(PreInLine[0].FP0.x==0.0f && PreInLine[0].FP0.y==0.0f && PreInLine[0].FP1.x==0.0f && PreInLine[0].FP1.y==0.0f){// 시작부분 Broken발생으로 데이터가 없는경우 
											 // Mark좌표를 기준으로 라인좌표값을 다시 설정함 
											 ROI_H = IRoi->GetHeight();
											 InLine[0].FP0.x = Line[0].FP0.x+Grind_Spec;   InLine[0].FP0.y = 0.0f        ;
											 InLine[0].FP1.x = Line[0].FP1.x+Grind_Spec;   InLine[0].FP1.y = (float)ROI_H;

											 //Line 데이터를 PreLine에 넘겨준다 
											 PreInLine[0].FP0.x = InLine[0].FP0.x;    PreInLine[0].FP1.x = InLine[0].FP1.x;       
											 PreInLine[0].FP0.y = InLine[0].FP0.y;    PreInLine[0].FP1.y = InLine[0].FP1.y;       
										 }
										 else {                                                                                                    // 중간부분 Broken발생으로 데이터가 없는경우 
											 // PreLine 데이터를 넘겨줌 
											 InLine[0].FP0.x = PreInLine[0].FP0.x;  InLine[0].FP1.x = PreInLine[0].FP1.x;  
											 InLine[0].FP0.y = PreInLine[0].FP0.y;  InLine[0].FP1.y = PreInLine[0].FP1.y;  
										 }
									 }
									 // InLine End 
									 //-------------------------------------------------------------------------


									 // OutLine & 연마량 측정 Start 
									 //-------------------------------------------------------------------------
									 SingleLine->SetFindLineId(1);
									 SingleLine->SetOrientation(orEast);
									 SingleLine->OnExecute();
									 OutLine[0].FP0 = SingleLine->GetResultP0();
									 OutLine[0].FP1 = SingleLine->GetResultP1();

									 // OutLine None....make OutLine Data 
									 // 현재의 데이터를 넘겨준다 
									 if(OutLine[0].FP0.x!=0.0f && OutLine[0].FP0.y!=0.0f && OutLine[0].FP1.x!=0.0f && OutLine[0].FP1.y!=0.0f){
										 PreOutLine[0].FP0.x = OutLine[0].FP0.x;    PreOutLine[0].FP1.x = OutLine[0].FP1.x;       
										 PreOutLine[0].FP0.y = OutLine[0].FP0.y;    PreOutLine[0].FP1.y = OutLine[0].FP1.y;       
									 }

									 //Laege Broken 발생으로 Line을 찾지 못할경우 
									 if(OutLine[0].FP0.x==0.0f || OutLine[0].FP0.y==0.0f || OutLine[0].FP1.x==0.0f || OutLine[0].FP1.y==0.0f){
										 if(PreOutLine[0].FP0.x==0.0f && PreOutLine[0].FP0.y==0.0f && PreOutLine[0].FP1.x==0.0f && PreOutLine[0].FP1.y==0.0f){// 시작부분 Broken발생으로 데이터가 없는경우 
											 // Mark좌표를 기준으로 라인좌표값을 다시 설정함 
											 ROI_H = IRoi->GetHeight();
											 OutLine[0].FP0.x = Line[0].FP0.x;    OutLine[0].FP0.y = 0.0f        ;
											 OutLine[0].FP1.x = Line[0].FP1.x;    OutLine[0].FP1.y = (float)ROI_H;

											 //Line 데이터를 PreLine에 넘겨준다 
											 PreOutLine[0].FP0.x = OutLine[0].FP0.x;    PreOutLine[0].FP1.x = OutLine[0].FP1.x;       
											 PreOutLine[0].FP0.y = OutLine[0].FP0.y;    PreOutLine[0].FP1.y = OutLine[0].FP1.y;       
										 }
										 else {                                                                                                    // 중간부분 Broken발생으로 데이터가 없는경우 
											 // PreLine 데이터를 넘겨줌 
											 OutLine[0].FP0.x = PreOutLine[0].FP0.x;  OutLine[0].FP1.x = PreOutLine[0].FP1.x;  
											 OutLine[0].FP0.y = PreOutLine[0].FP0.y;  OutLine[0].FP1.y = PreOutLine[0].FP1.y;  
										 }
									 }
									 Cell_Size = Math.GetLengthFrLineToPoint(OutLine[0].FP0,OutLine[0].FP1, BMLine[0].FP0 );
								 }
								 // OutLine & 연마량 측정 End 
								 //-------------------------------------------------------------------------

								 SingleLine->SetFindLineId(0);

								 // Cell_Size 측정
								 GrindSize = Math.GetLengthFrLineToPoint(OutLine[0].FP0,OutLine[0].FP1, InLine[0].FP0 );
							 }
						 }
						 else{
							 if(IsBmLine){
								 if(GrindOutIn){ // 장축 Cam0, Cam1, Cam2, Cam3 (Out -> In)
									 // GrindLine 찾기 
									 BinaryImg.SetSize(GImage->GetWidth(), GImage->GetHeight());
									 EasyImage::Oper(EArithmeticLogicOperation_Copy,GImage,&BinaryImg);
									 EasyImage::Threshold(GImage,&BinaryImg, GrindThresHold);

									 // BMLine 기준 연마량 첫번째 Line 검출 
									 SingleLine->GImage = &BinaryImg;

									 // 영역설정 
									 if(fabs(Line[0].FP0.x - Line[0].FP1.x) > 3){
										 LSP.x = (Line[0].FP0.x + Line[0].FP1.x)/2;
										 LSP.y = 0.0f;
									 }
									 else {
										 LSP = Math.OnIntersect(Line[0].FP0, Line[0].FP1, LT, RT);
									 }

									 SingleLine->IRoi->SetOrgX  ((int)LSP.x-20);
									 SingleLine->IRoi->SetOrgY  (0            );
									 SingleLine->IRoi->SetWidth (100          );
									 SingleLine->IRoi->SetHeight(ImgH         );

									 if(((LSP.x-20)<=0) || ImgH<=0) return false;

									 // 연마량 측정 OutLine
									 SingleLine->SetFindLineId(0);
									 SingleLine->SetOrientation(orWest);
									 SingleLine->OnExecute();
									 OutLine[0].FP0 = SingleLine->GetResultP0();
									 OutLine[0].FP1 = SingleLine->GetResultP1();

									 // OutLine None....make OutLine Data 
									 // 현재의 데이터를 넘겨준다 
									 if(OutLine[0].FP0.x!=0.0f && OutLine[0].FP0.y!=0.0f && OutLine[0].FP1.x!=0.0f && OutLine[0].FP1.y!=0.0f){
										 PreOutLine[0].FP0.x = OutLine[0].FP0.x;    PreOutLine[0].FP1.x = OutLine[0].FP1.x;       
										 PreOutLine[0].FP0.y = OutLine[0].FP0.y;    PreOutLine[0].FP1.y = OutLine[0].FP1.y;       
									 }

									 //Laege Broken 발생으로 Line을 찾지 못할경우 
									 if(OutLine[0].FP0.x==0.0f || OutLine[0].FP0.y==0.0f || OutLine[0].FP1.x==0.0f || OutLine[0].FP1.y==0.0f){
										 if(PreOutLine[0].FP0.x==0.0f && PreOutLine[0].FP0.y==0.0f && PreOutLine[0].FP1.x==0.0f && PreOutLine[0].FP1.y==0.0f){// 시작부분 Broken발생으로 데이터가 없는경우 
											 // Mark좌표를 기준으로 라인좌표값을 다시 설정함 
											 ROI_H = IRoi->GetHeight();
											 OutLine[0].FP0.x = Line[0].FP0.x;    OutLine[0].FP0.y = 0.0f        ;
											 OutLine[0].FP1.x = Line[0].FP1.x;    OutLine[0].FP1.y = (float)ROI_H;

											 //Line 데이터를 PreLine에 넘겨준다 
											 PreOutLine[0].FP0.x = OutLine[0].FP0.x;    PreOutLine[0].FP1.x = OutLine[0].FP1.x;       
											 PreOutLine[0].FP0.y = OutLine[0].FP0.y;    PreOutLine[0].FP1.y = OutLine[0].FP1.y;       
										 }
										 else {                                                                                                    // 중간부분 Broken발생으로 데이터가 없는경우 
											 // PreLine 데이터를 넘겨줌 
											 OutLine[0].FP0.x = PreOutLine[0].FP0.x;  OutLine[0].FP1.x = PreOutLine[0].FP1.x;  
											 OutLine[0].FP0.y = PreOutLine[0].FP0.y;  OutLine[0].FP1.y = PreOutLine[0].FP1.y;  
										 }
									 }

									 // 연마량 측정 InLine
									 SingleLine->SetFindLineId(1);
									 SingleLine->SetOrientation(orWest);
									 SingleLine->OnExecute();
									 InLine[0].FP0 = SingleLine->GetResultP0();
									 InLine[0].FP1 = SingleLine->GetResultP1();

									 // InLine None....make InLine Data 
									 // 현재의 데이터를 넘겨준다 
									 if(InLine[0].FP0.x!=0.0f && InLine[0].FP0.y!=0.0f && InLine[0].FP1.x!=0.0f && InLine[0].FP1.y!=0.0f){
										 PreInLine[0].FP0.x = InLine[0].FP0.x;    PreInLine[0].FP1.x = InLine[0].FP1.x;       
										 PreInLine[0].FP0.y = InLine[0].FP0.y;    PreInLine[0].FP1.y = InLine[0].FP1.y;       
									 }

									 //Laege Broken 발생으로 Line을 찾지 못할경우 
									 if(InLine[0].FP0.x==0.0f || InLine[0].FP0.y==0.0f || InLine[0].FP1.x==0.0f || InLine[0].FP1.y==0.0f){
										 if(PreInLine[0].FP0.x==0.0f && PreInLine[0].FP0.y==0.0f && PreInLine[0].FP1.x==0.0f && PreInLine[0].FP1.y==0.0f){// 시작부분 Broken발생으로 데이터가 없는경우 
											 // Mark좌표를 기준으로 라인좌표값을 다시 설정함 
											 ROI_H = IRoi->GetHeight();
											 InLine[0].FP0.x = Line[0].FP0.x+Grind_Spec;   InLine[0].FP0.y = 0.0f        ;
											 InLine[0].FP1.x = Line[0].FP1.x+Grind_Spec;   InLine[0].FP1.y = (float)ROI_H;

											 //Line 데이터를 PreLine에 넘겨준다 
											 PreInLine[0].FP0.x = InLine[0].FP0.x;    PreInLine[0].FP1.x = InLine[0].FP1.x;       
											 PreInLine[0].FP0.y = InLine[0].FP0.y;    PreInLine[0].FP1.y = InLine[0].FP1.y;       
										 }
										 else {                                                                                                    // 중간부분 Broken발생으로 데이터가 없는경우 
											 // PreLine 데이터를 넘겨줌 
											 InLine[0].FP0.x = PreInLine[0].FP0.x;  InLine[0].FP1.x = PreInLine[0].FP1.x;  
											 InLine[0].FP0.y = PreInLine[0].FP0.y;  InLine[0].FP1.y = PreInLine[0].FP1.y;  
										 }
									 }
								 }
								 else { // 장축 Cam0, Cam1, Cam2, Cam3 (In -> Out)
									 // BMLine Start
									 //------------------------------------------------------------------
									 BMLineImg.SetSize(GImage->GetWidth(), GImage->GetHeight());
									 EasyImage::Oper(EArithmeticLogicOperation_Copy,GImage,&BMLineImg);
									 EasyImage::Threshold(GImage,&BMLineImg, EBMLinThresHold);

									 SingleLine->GImage = &BMLineImg;

									 // 영역설정 
									 if(fabs(Line[0].FP0.x - Line[0].FP1.x) > 3){
										 LSP.x = (Line[0].FP0.x + Line[0].FP1.x)/2;
										 LSP.y = 0.0f;
									 }
									 else {
										 LSP = Math.OnIntersect(Line[0].FP0, Line[0].FP1, LT, RT);
									 }

									 // BMLine 찾기 
									 SingleLine->IRoi->SetOrgX  ((int)LSP.x );
									 SingleLine->IRoi->SetOrgY  (0          );
									 SingleLine->IRoi->SetWidth (BMWidth    );
									 SingleLine->IRoi->SetHeight(ImgH       );

									 if((LSP.x<=0) || BMWidth<=0 || (ImgH<=0) ){
										 // 									 AfxMessageBox("Mid BMLine Inspection ROI Error");
										 return false;
									 }

									 SingleLine->SetOrientation(orWest);
									 SingleLine->FIncrement =10;
									 SingleLine->SetFindLineId(0);
									 SingleLine->OnExecute();
									 BMLine[0].FP0 = SingleLine->GetResultP0();
									 BMLine[0].FP1 = SingleLine->GetResultP1();

									 // BMLine None....make BMLine Data 
									 // 현재의 데이터를 넘겨준다 
									 if(BMLine[0].FP0.x!=0.0f && BMLine[0].FP0.y!=0.0f && BMLine[0].FP1.x!=0.0f && BMLine[0].FP1.y!=0.0f){
										 PreBMLine[0].FP0.x = BMLine[0].FP0.x;    PreBMLine[0].FP1.x = BMLine[0].FP1.x;       
										 PreBMLine[0].FP0.y = BMLine[0].FP0.y;    PreBMLine[0].FP1.y = BMLine[0].FP1.y;       
									 }

									 //Laege Broken 발생으로 Line을 찾지 못할경우 
									 if(BMLine[0].FP0.x==0.0f || BMLine[0].FP0.y==0.0f || BMLine[0].FP1.x==0.0f || BMLine[0].FP1.y==0.0f){
										 if(PreBMLine[0].FP0.x==0.0f && PreBMLine[0].FP0.y==0.0f && PreBMLine[0].FP1.x==0.0f && PreBMLine[0].FP1.y==0.0f){// 시작부분 Broken발생으로 데이터가 없는경우 
											 // Mark좌표를 기준으로 라인좌표값을 다시 설정함 
											 ROI_H = IRoi->GetHeight();
											 BMLine[0].FP0.x = (float)(Line[0].FP0.x+BMLineDistance);   BMLine[0].FP0.y = 0.0f        ;
											 BMLine[0].FP1.x = (float)(Line[0].FP1.x+BMLineDistance);   BMLine[0].FP1.y = (float)ROI_H;

											 //Line 데이터를 PreLine에 넘겨준다 
											 PreBMLine[0].FP0.x = BMLine[0].FP0.x;    PreBMLine[0].FP1.x = BMLine[0].FP1.x;       
											 PreBMLine[0].FP0.y = BMLine[0].FP0.y;    PreBMLine[0].FP1.y = BMLine[0].FP1.y;       
										 }
										 else {                                                                                                            // 중간부분 Broken발생으로 데이터가 없는경우 
											 // PreLine 데이터를 넘겨줌 
											 BMLine[0].FP0.x = PreBMLine[0].FP0.x;  BMLine[0].FP1.x = PreBMLine[0].FP1.x;  
											 BMLine[0].FP0.y = PreBMLine[0].FP0.y;  BMLine[0].FP1.y = PreBMLine[0].FP1.y;  
										 }
									 }

									 // BMLine Data Overlap 장축 Cam0, Cam2 경우에만 데이터 넘겨줌 
									 // 20160318
									 if(IsBMLineData){
										 BMLineData[InspectCount].Dis1  = (int)(fabs(MarkPos.x - BMLine[0].FP0.x));
										 BMLineData[InspectCount].Dis2  = (int)(fabs(MarkPos.x - BMLine[0].FP1.x));
										 BMLineData[InspectCount].yPos1 = (int)(BMLine[0].FP0.y);
										 BMLineData[InspectCount].yPos2 = (int)(BMLine[0].FP1.y);

										 // 									 LogUnit.SetLog("CamId: %d, InspCount: %d, Dis1: %d, Dis2: %d, Mark: %f, BM_X1: %d, BM_X2: %d"
										 // 										 ,0,InspectCount,BMLineData[InspectCount].Dis1,BMLineData[InspectCount].Dis2, MarkPos.x, x1, x2);

									 }
									 else {
										 BMLine[0].FP0.x  =        (BMLineData[InspectCount].Dis1>MarkPos.x) ? 0 :(MarkPos.x - BMLineData[InspectCount].Dis1);
										 BMLine[0].FP0.y  = (float)(BMLineData[InspectCount].yPos1)                                                          ; 
										 BMLine[0].FP1.x  =        (BMLineData[InspectCount].Dis2>MarkPos.x) ? 0 :(MarkPos.x - BMLineData[InspectCount].Dis2);
										 BMLine[0].FP1.y  = (float)(BMLineData[InspectCount].yPos2)                                                          ;

										 // 									 LogUnit.SetLog("CamId: %d, InspCount: %d, Dis1: %d, Dis2: %d, Mark: %f, BM_X1: %d, BM_X2: %d"
										 // 										 ,1,InspectCount,BMLineData[InspectCount].Dis1,BMLineData[InspectCount].Dis2, MarkPos.x, x1, x2);
									 }
									 // BMLine End 
									 //------------------------------------------------------------------

									 // InLine Start
									 //------------------------------------------------------------------
									 BinaryImg.SetSize(GImage->GetWidth(), GImage->GetHeight());
									 EasyImage::Oper(EArithmeticLogicOperation_Copy,GImage,&BinaryImg);
									 EasyImage::Threshold(GImage,&BinaryImg, GrindThresHold);

									 // BMLine 기준 연마량 첫번째 Line 검출 
									 SingleLine->GImage = &BinaryImg;

									 SingleLine->IRoi->SetOrgX  ( (int)(LSP.x-30)                            );
									 SingleLine->IRoi->SetOrgY  ( 0                                          );
									 SingleLine->IRoi->SetWidth (((int)((BMLine[0].FP0.x-BmToMarkDis) - (LSP.x-30))));
									 SingleLine->IRoi->SetHeight( ImgH                                       );

									 if((LSP.x-30)<=0 || ((BMLine[0].FP0.x-BmToMarkDis) - (LSP.x-30))<=0 || ImgH<=0){
										 // 									 AfxMessageBox("Mid InLine Inspection ROI Error");
										 // 									 LogUnit.SetLog("ETC_BMLIINE_CELLID:%s , CellId: %d, CamId: %d, ImageHeight: %d",CellName, CellId,CamId,ImageHeight);     
										 return false;
									 }

									 // 연마량 측정 InLine
									 SingleLine->SetFindLineId(0);								 
									 SingleLine->SetOrientation(orEast);
									 SingleLine->OnExecute();
									 InLine[0].FP0 = SingleLine->GetResultP0();
									 InLine[0].FP1 = SingleLine->GetResultP1();

									 // InLine None....make InLine Data 
									 // 현재의 데이터를 넘겨준다 
									 if(InLine[0].FP0.x!=0.0f && InLine[0].FP0.y!=0.0f && InLine[0].FP1.x!=0.0f && InLine[0].FP1.y!=0.0f){
										 PreInLine[0].FP0.x = InLine[0].FP0.x;    PreInLine[0].FP1.x = InLine[0].FP1.x;       
										 PreInLine[0].FP0.y = InLine[0].FP0.y;    PreInLine[0].FP1.y = InLine[0].FP1.y;       
									 }

									 //Laege Broken 발생으로 Line을 찾지 못할경우 
									 if(InLine[0].FP0.x==0.0f || InLine[0].FP0.y==0.0f || InLine[0].FP1.x==0.0f || InLine[0].FP1.y==0.0f){
										 if(PreInLine[0].FP0.x==0.0f && PreInLine[0].FP0.y==0.0f && PreInLine[0].FP1.x==0.0f && PreInLine[0].FP1.y==0.0f){// 시작부분 Broken발생으로 데이터가 없는경우 
											 // Mark좌표를 기준으로 라인좌표값을 다시 설정함 
											 ROI_H = IRoi->GetHeight();
											 InLine[0].FP0.x = Line[0].FP0.x+Grind_Spec;   InLine[0].FP0.y = 0.0f        ;
											 InLine[0].FP1.x = Line[0].FP1.x+Grind_Spec;   InLine[0].FP1.y = (float)ROI_H;

											 //Line 데이터를 PreLine에 넘겨준다 
											 PreInLine[0].FP0.x = InLine[0].FP0.x;    PreInLine[0].FP1.x = InLine[0].FP1.x;       
											 PreInLine[0].FP0.y = InLine[0].FP0.y;    PreInLine[0].FP1.y = InLine[0].FP1.y;       
										 }
										 else {                                                                                                    // 중간부분 Broken발생으로 데이터가 없는경우 
											 // PreLine 데이터를 넘겨줌 
											 InLine[0].FP0.x = PreInLine[0].FP0.x;  InLine[0].FP1.x = PreInLine[0].FP1.x;  
											 InLine[0].FP0.y = PreInLine[0].FP0.y;  InLine[0].FP1.y = PreInLine[0].FP1.y;  
										 }
									 }
									 // InLine End 
									 //------------------------------------------------------------------


									 // OutLine & 연마량 측정 Start 
									 //------------------------------------------------------------------
									 SingleLine->SetFindLineId(1);
									 SingleLine->SetOrientation(orEast);
									 SingleLine->OnExecute();
									 OutLine[0].FP0 = SingleLine->GetResultP0();
									 OutLine[0].FP1 = SingleLine->GetResultP1();

									 // OutLine None....make OutLine Data 
									 // 현재의 데이터를 넘겨준다 
									 if(OutLine[0].FP0.x!=0.0f && OutLine[0].FP0.y!=0.0f && OutLine[0].FP1.x!=0.0f && OutLine[0].FP1.y!=0.0f){
										 PreOutLine[0].FP0.x = OutLine[0].FP0.x;    PreOutLine[0].FP1.x = OutLine[0].FP1.x;       
										 PreOutLine[0].FP0.y = OutLine[0].FP0.y;    PreOutLine[0].FP1.y = OutLine[0].FP1.y;       
									 }

									 //Laege Broken 발생으로 Line을 찾지 못할경우 
									 if(OutLine[0].FP0.x==0.0f || OutLine[0].FP0.y==0.0f || OutLine[0].FP1.x==0.0f || OutLine[0].FP1.y==0.0f){
										 if(PreOutLine[0].FP0.x==0.0f && PreOutLine[0].FP0.y==0.0f && PreOutLine[0].FP1.x==0.0f && PreOutLine[0].FP1.y==0.0f){// 시작부분 Broken발생으로 데이터가 없는경우 
											 // Mark좌표를 기준으로 라인좌표값을 다시 설정함 
											 ROI_H = IRoi->GetHeight();
											 OutLine[0].FP0.x = Line[0].FP0.x;    OutLine[0].FP0.y = 0.0f        ;
											 OutLine[0].FP1.x = Line[0].FP1.x;    OutLine[0].FP1.y = (float)ROI_H;

											 //Line 데이터를 PreLine에 넘겨준다 
											 PreOutLine[0].FP0.x = OutLine[0].FP0.x;    PreOutLine[0].FP1.x = OutLine[0].FP1.x;       
											 PreOutLine[0].FP0.y = OutLine[0].FP0.y;    PreOutLine[0].FP1.y = OutLine[0].FP1.y;       
										 }
										 else {                                                                                                    // 중간부분 Broken발생으로 데이터가 없는경우 
											 // PreLine 데이터를 넘겨줌 
											 OutLine[0].FP0.x = PreOutLine[0].FP0.x;  OutLine[0].FP1.x = PreOutLine[0].FP1.x;  
											 OutLine[0].FP0.y = PreOutLine[0].FP0.y;  OutLine[0].FP1.y = PreOutLine[0].FP1.y;  
										 }
									 }
									 Cell_Size = Math.GetLengthFrLineToPoint(OutLine[0].FP0,OutLine[0].FP1, BMLine[0].FP0 );
								 }
								 // OutLine & 연마량 측정 End 
								 //------------------------------------------------------------------

								 SingleLine->SetFindLineId(0);
								 // Cell_Size 측정
								 //Cell_Size = Math.GetLengthFrLineToPoint(OutLine[0].FP0,OutLine[0].FP1, BMLine[0].FP0 );
								 GrindSize = Math.GetLengthFrLineToPoint(OutLine[0].FP0,OutLine[0].FP1, InLine[0].FP0 );
							 }
							 else {  // BMLine None
								 if(IsLongTop){
									 GrindSize = 0.0f;
									 if(!GrindOutIn){
										 MarkPos.y = (Line[0].FP0.y + Line[0].FP1.y)/2;
										 if(BmToMarkDis!=0) Cell_Size = (float)((Math.GetLengthFrLineToPoint(Line[0].FP0, Line[0].FP1, MarkPos) - BmToMarkDis));

										 //Only Display 
										 BMLine[0].FP0.x = Line[0].FP0.x+Cell_Size;
										 BMLine[0].FP0.y = Line[0].FP0.y          ;
										 BMLine[0].FP1.x = Line[0].FP1.x+Cell_Size; 
										 BMLine[0].FP1.y = Line[0].FP1.y          ;
									 }
								 }
								 else {
									 BinaryImg.SetSize(GImage->GetWidth(), GImage->GetHeight());
									 EasyImage::Oper(EArithmeticLogicOperation_Copy,GImage,&BinaryImg);
									 EasyImage::Threshold(GImage,&BinaryImg, GrindThresHold);

									 // BMLine 없기 때무에 외곽라인 기준으로 연마량 첫번째 Line 검출 
									 SingleLine->GImage = &BinaryImg;

									 // 영역설정 
									 if(fabs(Line[0].FP0.x - Line[0].FP1.x) > 3){
										 LSP.x = (Line[0].FP0.x + Line[0].FP1.x)/2;
										 LSP.y = 0.0f;
									 }
									 else {
										 LSP = Math.OnIntersect(Line[0].FP0, Line[0].FP1, LT, RT);
									 }

									 SingleLine->IRoi->SetOrgX  ((int)LSP.x-20);
									 SingleLine->IRoi->SetOrgY  (0            );
									 SingleLine->IRoi->SetWidth (100          );
									 SingleLine->IRoi->SetHeight(ImgH         );

									 if(((LSP.x-20)<=0) || ImgH<=0) return false;

									 // 연마량 측정 OutLine
									 SingleLine->SetFindLineId(0);
									 SingleLine->SetOrientation(orWest);
									 SingleLine->OnExecute();
									 OutLine[0].FP0 = SingleLine->GetResultP0();
									 OutLine[0].FP1 = SingleLine->GetResultP1();

									 // 연마량 측정 InLine
									 SingleLine->SetFindLineId(1);
									 SingleLine->SetOrientation(orWest);
									 SingleLine->OnExecute();
									 InLine[0].FP0 = SingleLine->GetResultP0();
									 InLine[0].FP1 = SingleLine->GetResultP1();

									 SingleLine->SetFindLineId(0);
									 GrindSize = (float)(Math.GetLengthFrLineToPoint(OutLine[0].FP0,OutLine[0].FP1, InLine[0].FP0 ));

									 if(!GrindOutIn){
										 // Cell_Size 측정
										 //Cell_Size = Math.GetLengthFrLineToPoint(OutLine[0].FP0,OutLine[0].FP1, BMLine[0].FP0 );
										 MarkPos.y = (OutLine[0].FP0.y + OutLine[0].FP1.y)/2;
										 if(BmToMarkDis!=0) Cell_Size = (float)((Math.GetLengthFrLineToPoint(OutLine[0].FP0,OutLine[0].FP1, MarkPos) - BmToMarkDis));

										 //Only Display 
										 BMLine[0].FP0.x = OutLine[0].FP0.x+Cell_Size;
										 BMLine[0].FP0.y = OutLine[0].FP0.y          ;
										 BMLine[0].FP1.x = OutLine[0].FP1.x+Cell_Size; 
										 BMLine[0].FP1.y = OutLine[0].FP1.y          ;
									 }
								 }
							 }
						 }
					 }
					 else if(FCompanyMode==COM_BOE){ // RectSL OutLine, InLine Search
						 BinaryImg.SetSize(GImage->GetWidth(), GImage->GetHeight());
						 EasyImage::Oper(EArithmeticLogicOperation_Copy,GImage,&BinaryImg);
						 EasyImage::Threshold(GImage,&BinaryImg, EThresHold);

						 // BMLine 기준 연마량 첫번째 Line 검출 
						 SingleLine->GImage = &BinaryImg;

						 // 영역설정 
						 if(fabs(Line[0].FP0.x - Line[0].FP1.x) > 3){
							 LSP.x = (Line[0].FP0.x + Line[0].FP1.x)/2;
							 LSP.y = 0.0f;
						 }
						 else {
							 LSP = Math.OnIntersect(Line[0].FP0, Line[0].FP1, LT, RT);
						 }

						 SingleLine->IRoi->SetOrgX  ((int)LSP.x-20);
						 SingleLine->IRoi->SetOrgY  (0            );
						 SingleLine->IRoi->SetWidth (100          );
						 SingleLine->IRoi->SetHeight(ImgH         );

						 if(((LSP.x-20)<=0) || ImgH<=0) return false;

						 if(IRoi->GetHeight()<300) SingleLine->SetIncrement(5 );
						 else                      SingleLine->SetIncrement(100);

						 // 연마량 측정 OutLine
						 SingleLine->SetFindLineId(0);
						 SingleLine->SetOrientation(orWest);
						 SingleLine->OnExecute();
						 OutLine[0].FP0 = SingleLine->GetResultP0();
						 OutLine[0].FP1 = SingleLine->GetResultP1();

						 // OutLine None....make OutLine Data 
						 // 현재의 데이터를 넘겨준다 
						 if(OutLine[0].FP0.x!=0.0f && OutLine[0].FP0.y!=0.0f && OutLine[0].FP1.x!=0.0f && OutLine[0].FP1.y!=0.0f){
							 PreOutLine[0].FP0.x = OutLine[0].FP0.x;    PreOutLine[0].FP1.x = OutLine[0].FP1.x;       
							 PreOutLine[0].FP0.y = OutLine[0].FP0.y;    PreOutLine[0].FP1.y = OutLine[0].FP1.y;       
						 }

						 //Laege Broken 발생으로 Line을 찾지 못할경우 
						 if(OutLine[0].FP0.x==0.0f || OutLine[0].FP0.y==0.0f || OutLine[0].FP1.x==0.0f || OutLine[0].FP1.y==0.0f){
							 if(PreOutLine[0].FP0.x==0.0f && PreOutLine[0].FP0.y==0.0f && PreOutLine[0].FP1.x==0.0f && PreOutLine[0].FP1.y==0.0f){// 시작부분 Broken발생으로 데이터가 없는경우 
								 // Mark좌표를 기준으로 라인좌표값을 다시 설정함 
								 ROI_H = IRoi->GetHeight();
								 OutLine[0].FP0.x = Line[0].FP0.x;    OutLine[0].FP0.y = 0.0f        ;
								 OutLine[0].FP1.x = Line[0].FP1.x;    OutLine[0].FP1.y = (float)ROI_H;

								 //Line 데이터를 PreLine에 넘겨준다 
								 PreOutLine[0].FP0.x = OutLine[0].FP0.x;    PreOutLine[0].FP1.x = OutLine[0].FP1.x;       
								 PreOutLine[0].FP0.y = OutLine[0].FP0.y;    PreOutLine[0].FP1.y = OutLine[0].FP1.y;       
							 }
							 else {                                                                                                    // 중간부분 Broken발생으로 데이터가 없는경우 
								 // PreLine 데이터를 넘겨줌 
								 OutLine[0].FP0.x = PreOutLine[0].FP0.x;  OutLine[0].FP1.x = PreOutLine[0].FP1.x;  
								 OutLine[0].FP0.y = PreOutLine[0].FP0.y;  OutLine[0].FP1.y = PreOutLine[0].FP1.y;  
							 }
						 }

						 // 연마량 측정 InLine
// 						 SingleLine->SetFindLineId(1);
// 						 SingleLine->SetOrientation(orWest);
// 						 SingleLine->OnExecute();
// 						 InLine[0].FP0 = SingleLine->GetResultP0();
// 						 InLine[0].FP1 = SingleLine->GetResultP1();

						 BinaryImg.SetSize(GImage->GetWidth(), GImage->GetHeight());
						 EasyImage::Oper(EArithmeticLogicOperation_Copy,GImage,&BinaryImg);
						 EasyImage::Threshold(GImage,&BinaryImg, GrindThresHold);

						 // BMLine 기준 연마량 첫번째 Line 검출 
						 SingleLine->GImage = &BinaryImg;

						 // 영역설정 
						 if(fabs(Line[0].FP0.x - Line[0].FP1.x) > 3){
							 LSP.x = (Line[0].FP0.x + Line[0].FP1.x)/2;
							 LSP.y = 0.0f;
						 }
						 else {
							 LSP = Math.OnIntersect(Line[0].FP0, Line[0].FP1, LT, RT);
						 }

						 SingleLine->IRoi->SetOrgX  ((int)LSP.x+2 );
						 SingleLine->IRoi->SetOrgY  (0            );
						 SingleLine->IRoi->SetWidth (100          );
						 SingleLine->IRoi->SetHeight(ImgH         );

						 if(((LSP.x+10)<=0) || ImgH<=0) return false;

						 if(IRoi->GetHeight()<300) SingleLine->SetIncrement(5 );
						 else                      SingleLine->SetIncrement(100);

						 // 연마량 측정 OutLine
						 SingleLine->SetFindLineId(0);
						 SingleLine->SetOrientation(orWest);
						 SingleLine->SetEdgeType(0); // Black to White 
						 SingleLine->OnExecute();
						 InLine[0].FP0 = SingleLine->GetResultP0();
						 InLine[0].FP1 = SingleLine->GetResultP1();

						 SingleLine->SetEdgeType(2); // Org 

						 // InLine None....make InLine Data 
						 // 현재의 데이터를 넘겨준다 
						 if(InLine[0].FP0.x!=0.0f && InLine[0].FP0.y!=0.0f && InLine[0].FP1.x!=0.0f && InLine[0].FP1.y!=0.0f){
							 PreInLine[0].FP0.x = InLine[0].FP0.x;    PreInLine[0].FP1.x = InLine[0].FP1.x;       
							 PreInLine[0].FP0.y = InLine[0].FP0.y;    PreInLine[0].FP1.y = InLine[0].FP1.y;       
						 }

						 //Laege Broken 발생으로 Line을 찾지 못할경우 
						 if(InLine[0].FP0.x==0.0f || InLine[0].FP0.y==0.0f || InLine[0].FP1.x==0.0f || InLine[0].FP1.y==0.0f){
							 if(PreInLine[0].FP0.x==0.0f && PreInLine[0].FP0.y==0.0f && PreInLine[0].FP1.x==0.0f && PreInLine[0].FP1.y==0.0f){// 시작부분 Broken발생으로 데이터가 없는경우 
								 // Mark좌표를 기준으로 라인좌표값을 다시 설정함 
								 ROI_H = IRoi->GetHeight();
								 InLine[0].FP0.x = Line[0].FP0.x+Grind_Spec;   InLine[0].FP0.y = 0.0f        ;
								 InLine[0].FP1.x = Line[0].FP1.x+Grind_Spec;   InLine[0].FP1.y = (float)ROI_H;

								 //Line 데이터를 PreLine에 넘겨준다 
								 PreInLine[0].FP0.x = InLine[0].FP0.x;    PreInLine[0].FP1.x = InLine[0].FP1.x;       
								 PreInLine[0].FP0.y = InLine[0].FP0.y;    PreInLine[0].FP1.y = InLine[0].FP1.y;       
							 }
							 else {                                                                                                    // 중간부분 Broken발생으로 데이터가 없는경우 
								 // PreLine 데이터를 넘겨줌 
								 InLine[0].FP0.x = PreInLine[0].FP0.x;  InLine[0].FP1.x = PreInLine[0].FP1.x;  
								 InLine[0].FP0.y = PreInLine[0].FP0.y;  InLine[0].FP1.y = PreInLine[0].FP1.y;  
							 }
						 }
						 // GrindSize 측정 
						 // 사용자가 지정한 간격만큼 GrindSize 측정은 어떻게??..........
						 GrindSize =(float)(Math.GetLengthFrLineToPoint (OutLine[0].FP0,OutLine[0].FP1, InLine[0].FP0 ));
					 }
				 }
				 if(FShape==shRectCL){ // 왼쪽 컵 
					 if(FCompanyMode==COM_TIANMA){
						 OrgPoint = Math.OnIntersect(Line[waLeftWall].FP0, Line[waLeftWall].FP1, Line[waBottomWall].FP0, Line[waBottomWall].FP1);
						 FLBPoint = OrgPoint;

						 if(IsMarkLine){ // 단축 Cam0, Cam1 
							 if(GrindCheck){
								 if(IsMarkBtm){
									 BinaryImg.SetSize(GImage->GetWidth(), GImage->GetHeight());
									 EasyImage::Oper(EArithmeticLogicOperation_Copy,GImage,&BinaryImg);
									 EasyImage::Threshold(GImage,&BinaryImg, GrindThresHold);

									 SingleLine->GImage = &BinaryImg;

									 LSP = Math.OnIntersect(Line[waLeftWall].FP0, Line[waLeftWall].FP1, LT, RT);
									 LEP = FLBPoint;
									 FLeftWidth = 100;

									 SingleLine->IRoi->SetOrgX  ((int)(LSP.x-20)     );
									 SingleLine->IRoi->SetOrgY  ((int)LSP.y          );
									 SingleLine->IRoi->SetWidth (FLeftWidth          );
									 SingleLine->IRoi->SetHeight((int)(LEP.y - LSP.y));
									 if(LSP.x-20<=0 || LSP.y <0 || FLeftWidth<=0 || (LEP.y - LSP.y)<=0 ) return false;

									 // 연마량 측정 OutLine
									 SingleLine->SetFindLineId(0);
									 SingleLine->SetOrientation(orWest);
									 SingleLine->OnExecute();
									 OutLine[0].FP0 = SingleLine->GetResultP0();
									 OutLine[0].FP1 = SingleLine->GetResultP1();

									 // 연마량 측정 InLine
									 SingleLine->SetFindLineId(1);
									 SingleLine->SetOrientation(orWest);
									 SingleLine->OnExecute();
									 InLine[0].FP0 = SingleLine->GetResultP0();
									 InLine[0].FP1 = SingleLine->GetResultP1();

									 SingleLine->SetFindLineId(0);

									 // Cell_Size 측정
									 //Cell_Size = Math.GetLengthFrLineToPoint(Line[0].FP0, Line[0].FP1,MarkPos);
									 FCellPoint[nCell_Count].x = (OutLine[0].FP0.x > OutLine[0].FP1.x) ? (OutLine[0].FP1.x+((OutLine[0].FP0.x - OutLine[0].FP1.x)/2)):(OutLine[0].FP0.x+((OutLine[0].FP1.x - OutLine[0].FP0.x)/2)); 
									 FCellPoint[nCell_Count].y = (OutLine[0].FP0.y +OutLine[0].FP1.y )/2+ ImageHeight;
									 nCell_Count++;

									 GrindSize = Math.GetLengthFrLineToPoint(OutLine[0].FP0,OutLine[0].FP1, InLine[0].FP0 );

								 }
								 else {
									 BinaryImg.SetSize(GImage->GetWidth(), GImage->GetHeight());
									 EasyImage::Oper(EArithmeticLogicOperation_Copy,GImage,&BinaryImg);
									 EasyImage::Threshold(GImage,&BinaryImg, GrindThresHold);

									 SingleLine->GImage = &BinaryImg;
									 // 영역설정 
									 LSP = Math.OnIntersect(Line[waLeftWall].FP0, Line[waLeftWall].FP1, LT, RT);
									 LEP = FLBPoint;

									 SingleLine->IRoi->SetOrgX  ((int)LSP.x+GROffset           );
									 SingleLine->IRoi->SetOrgY  ((int)LSP.y                    );
									 SingleLine->IRoi->SetWidth ((int)(ImgW - (LSP.x+GROffset)));
									 SingleLine->IRoi->SetHeight((int)(LEP.y - LSP.y)          );
									 if((LSP.x+GROffset)<=0 || LSP.y <0 || ((ImgW - (LSP.x+GROffset))<=0) || ((LEP.y - LSP.y)<=0) ) return false;

									 // 연마량 측정 OutLine
									 SingleLine->SetFindLineId(0);
									 SingleLine->SetOrientation(orWest);
									 SingleLine->OnExecute();
									 OutLine[0].FP0 = SingleLine->GetResultP0();
									 OutLine[0].FP1 = SingleLine->GetResultP1();

									 // 연마량 측정 InLine
									 SingleLine->SetFindLineId(1);
									 SingleLine->SetOrientation(orWest);
									 SingleLine->OnExecute();
									 InLine[0].FP0 = SingleLine->GetResultP0();
									 InLine[0].FP1 = SingleLine->GetResultP1();

									 SingleLine->SetFindLineId(0);

									 // Cell_Size 측정
									 //Cell_Size = Math.GetLengthFrLineToPoint(Line[0].FP0, Line[0].FP1,MarkPos);
									 FCellPoint[nCell_Count].x = (Line[0].FP0.x > Line[0].FP1.x) ? (Line[0].FP1.x+((Line[0].FP0.x - Line[0].FP1.x)/2)):(Line[0].FP0.x+((Line[0].FP1.x - Line[0].FP0.x)/2)); 
									 FCellPoint[nCell_Count].y = (Line[0].FP0.y + Line[0].FP1.y)/2+ ImageHeight;
									 nCell_Count++;

									 GrindSize = Math.GetLengthFrLineToPoint(OutLine[0].FP0,OutLine[0].FP1, InLine[0].FP0 );
								 }
							 }
							 else {
								 //Cell_Size = Math.GetLengthFrLineToPoint(Line[waLeftWall].FP0, Line[waLeftWall].FP1, MarkPos);
								 FCellPoint[nCell_Count].x = (Line[0].FP0.x > Line[0].FP1.x) ? (Line[0].FP1.x+((Line[0].FP0.x - Line[0].FP1.x)/2)) :(Line[0].FP0.x+((Line[0].FP1.x - Line[0].FP0.x)/2)); 
								 FCellPoint[nCell_Count].y = (Line[0].FP0.y + Line[0].FP1.y)/2+ ImageHeight;
								 nCell_Count++;

								 GrindSize = 0.0f;
							 }
						 }
						 else { // 단축 Cam2, Cam3 
							 if(GrindOutIn){
								 // GrindLine 찾기 
								 BinaryImg.SetSize(GImage->GetWidth(), GImage->GetHeight());
								 EasyImage::Oper(EArithmeticLogicOperation_Copy,GImage,&BinaryImg);
								 EasyImage::Threshold(GImage,&BinaryImg, GrindThresHold);

								 // BMLine 기준 연마량 첫번째 Line 검출 
								 SingleLine->GImage = &BinaryImg;

								 // 영역설정 
								 LSP = Math.OnIntersect(Line[waLeftWall].FP0, Line[waLeftWall].FP1, LT, RT);
								 LEP = FLBPoint;

								 SingleLine->IRoi->SetOrgX  ((int)LSP.x-20       );
								 SingleLine->IRoi->SetOrgY  ((int)LSP.y          );
								 SingleLine->IRoi->SetWidth (100                 );
								 SingleLine->IRoi->SetHeight((int)(LEP.y - LSP.y));

								 if((LSP.x-20)<=0 || LSP.y<0 || ((LEP.y - LSP.y)<=0) ) return false;

								 // 연마량 측정 OutLine
								 SingleLine->SetFindLineId(0);
								 SingleLine->SetOrientation(orWest);
								 SingleLine->OnExecute();
								 OutLine[0].FP0 = SingleLine->GetResultP0();
								 OutLine[0].FP1 = SingleLine->GetResultP1();

								 // OutLine None....make OutLine Data 
								 // 현재의 데이터를 넘겨준다 
								 if(OutLine[0].FP0.x!=0.0f && OutLine[0].FP0.y!=0.0f && OutLine[0].FP1.x!=0.0f && OutLine[0].FP1.y!=0.0f){
									 PreOutLine[0].FP0.x = OutLine[0].FP0.x;    PreOutLine[0].FP1.x = OutLine[0].FP1.x;       
									 PreOutLine[0].FP0.y = OutLine[0].FP0.y;    PreOutLine[0].FP1.y = OutLine[0].FP1.y;       
								 }

								 //Laege Broken 발생으로 Line을 찾지 못할경우 
								 if(OutLine[0].FP0.x==0.0f || OutLine[0].FP0.y==0.0f || OutLine[0].FP1.x==0.0f || OutLine[0].FP1.y==0.0f){
									 if(PreOutLine[0].FP0.x==0.0f && PreOutLine[0].FP0.y==0.0f && PreOutLine[0].FP1.x==0.0f && PreOutLine[0].FP1.y==0.0f){// 시작부분 Broken발생으로 데이터가 없는경우 
										 // Mark좌표를 기준으로 라인좌표값을 다시 설정함 
										 ROI_H = IRoi->GetHeight();
										 OutLine[0].FP0.x = Line[0].FP0.x;    OutLine[0].FP0.y = 0.0f        ;
										 OutLine[0].FP1.x = Line[0].FP1.x;    OutLine[0].FP1.y = (float)ROI_H;

										 //Line 데이터를 PreLine에 넘겨준다 
										 PreOutLine[0].FP0.x = OutLine[0].FP0.x;    PreOutLine[0].FP1.x = OutLine[0].FP1.x;       
										 PreOutLine[0].FP0.y = OutLine[0].FP0.y;    PreOutLine[0].FP1.y = OutLine[0].FP1.y;       
									 }
									 else {                                                                                                    // 중간부분 Broken발생으로 데이터가 없는경우 
										 // PreLine 데이터를 넘겨줌 
										 OutLine[0].FP0.x = PreOutLine[0].FP0.x;  OutLine[0].FP1.x = PreOutLine[0].FP1.x;  
										 OutLine[0].FP0.y = PreOutLine[0].FP0.y;  OutLine[0].FP1.y = PreOutLine[0].FP1.y;  
									 }
								 }

								 // 연마량 측정 InLine
								 SingleLine->SetFindLineId(1);
								 SingleLine->SetOrientation(orWest);
								 SingleLine->OnExecute();
								 InLine[0].FP0 = SingleLine->GetResultP0();
								 InLine[0].FP1 = SingleLine->GetResultP1();

								 // InLine None....make InLine Data 
								 // 현재의 데이터를 넘겨준다 
								 if(InLine[0].FP0.x!=0.0f && InLine[0].FP0.y!=0.0f && InLine[0].FP1.x!=0.0f && InLine[0].FP1.y!=0.0f){
									 PreInLine[0].FP0.x = InLine[0].FP0.x;    PreInLine[0].FP1.x = InLine[0].FP1.x;       
									 PreInLine[0].FP0.y = InLine[0].FP0.y;    PreInLine[0].FP1.y = InLine[0].FP1.y;       
								 }

								 //Laege Broken 발생으로 Line을 찾지 못할경우 
								 if(InLine[0].FP0.x==0.0f || InLine[0].FP0.y==0.0f || InLine[0].FP1.x==0.0f || InLine[0].FP1.y==0.0f){
									 if(PreInLine[0].FP0.x==0.0f && PreInLine[0].FP0.y==0.0f && PreInLine[0].FP1.x==0.0f && PreInLine[0].FP1.y==0.0f){// 시작부분 Broken발생으로 데이터가 없는경우 
										 // Mark좌표를 기준으로 라인좌표값을 다시 설정함 
										 ROI_H = IRoi->GetHeight();
										 InLine[0].FP0.x = Line[0].FP0.x+Grind_Spec;   InLine[0].FP0.y = 0.0f        ;
										 InLine[0].FP1.x = Line[0].FP1.x+Grind_Spec;   InLine[0].FP1.y = (float)ROI_H;

										 //Line 데이터를 PreLine에 넘겨준다 
										 PreInLine[0].FP0.x = InLine[0].FP0.x;    PreInLine[0].FP1.x = InLine[0].FP1.x;       
										 PreInLine[0].FP0.y = InLine[0].FP0.y;    PreInLine[0].FP1.y = InLine[0].FP1.y;       
									 }
									 else {                                                                                                    // 중간부분 Broken발생으로 데이터가 없는경우 
										 // PreLine 데이터를 넘겨줌 
										 InLine[0].FP0.x = PreInLine[0].FP0.x;  InLine[0].FP1.x = PreInLine[0].FP1.x;  
										 InLine[0].FP0.y = PreInLine[0].FP0.y;  InLine[0].FP1.y = PreInLine[0].FP1.y;  
									 }
								 }
							 }
							 else {// BMLine Start Short Cell=> Cam2, Cam3  Long Cell=>Cam0, Cam1, Cam2, Cam3
								 //-----------------------------------------------------------------------------------------
								 BMLineImg.SetSize(GImage->GetWidth(), GImage->GetHeight());
								 EasyImage::Oper(EArithmeticLogicOperation_Copy,GImage,&BMLineImg);
								 EasyImage::Threshold(GImage,&BMLineImg, EBMLinThresHold);

								 SingleLine->GImage = &BMLineImg;

								 // 영역설정 
								 LSP = Math.OnIntersect(Line[waLeftWall].FP0, Line[waLeftWall].FP1, LT, RT);
								 LEP = FLBPoint;

								 // BMLine 찾기 
								 SingleLine->IRoi->SetOrgX  ((int)LSP.x          );
								 SingleLine->IRoi->SetOrgY  ((int)LSP.y          );
								 SingleLine->IRoi->SetWidth (BMWidth             );
								 SingleLine->IRoi->SetHeight((int)(LEP.y - LSP.y));
								 if(LSP.x<=0 || LSP.y <0 || (BMWidth<=0) ||((LEP.y - LSP.y)<=0)){ 
									 // 								 AfxMessageBox("Btm BMLine Inspection ROI Error");
									 return false;
								 }

								 SingleLine->SetOrientation(orWest);
								 SingleLine->FIncrement =10;
								 SingleLine->SetFindLineId(0);
								 SingleLine->OnExecute();
								 BMLine[0].FP0 = SingleLine->GetResultP0();
								 BMLine[0].FP1 = SingleLine->GetResultP1();

								 // BMLine None....make BMLine Data 
								 // 현재의 데이터를 넘겨준다 
								 if(BMLine[0].FP0.x!=0.0f && BMLine[0].FP0.y!=0.0f && BMLine[0].FP1.x!=0.0f && BMLine[0].FP1.y!=0.0f){
									 PreBMLine[0].FP0.x = BMLine[0].FP0.x;    PreBMLine[0].FP1.x = BMLine[0].FP1.x;       
									 PreBMLine[0].FP0.y = BMLine[0].FP0.y;    PreBMLine[0].FP1.y = BMLine[0].FP1.y;       
								 }

								 //Laege Broken 발생으로 Line을 찾지 못할경우 
								 if(BMLine[0].FP0.x==0.0f || BMLine[0].FP0.y==0.0f || BMLine[0].FP1.x==0.0f || BMLine[0].FP1.y==0.0f){
									 if(PreBMLine[0].FP0.x==0.0f && PreBMLine[0].FP0.y==0.0f && PreBMLine[0].FP1.x==0.0f && PreBMLine[0].FP1.y==0.0f){// 시작부분 Broken발생으로 데이터가 없는경우 
										 // Mark좌표를 기준으로 라인좌표값을 다시 설정함 
										 ROI_H = IRoi->GetHeight();
										 BMLine[0].FP0.x =(float)(Line[0].FP0.x+BMLineDistance);   BMLine[0].FP0.y = 0.0f        ;
										 BMLine[0].FP1.x =(float)(Line[0].FP1.x+BMLineDistance);   BMLine[0].FP1.y = (float)ROI_H;

										 //Line 데이터를 PreLine에 넘겨준다 
										 PreBMLine[0].FP0.x = BMLine[0].FP0.x;    PreBMLine[0].FP1.x = BMLine[0].FP1.x;       
										 PreBMLine[0].FP0.y = BMLine[0].FP0.y;    PreBMLine[0].FP1.y = BMLine[0].FP1.y;       
									 }
									 else {                                                                                                    // 중간부분 Broken발생으로 데이터가 없는경우 
										 // PreLine 데이터를 넘겨줌 
										 BMLine[0].FP0.x = PreBMLine[0].FP0.x;  BMLine[0].FP1.x = PreBMLine[0].FP1.x;  
										 BMLine[0].FP0.y = PreBMLine[0].FP0.y;  BMLine[0].FP1.y = PreBMLine[0].FP1.y;  
									 }
								 }
								 // BMLine End 
								 //-----------------------------------------------------------------------------------------
								 // BMLine Data Overlap 장축 Cam0, Cam1 경우에만 데이터 넘겨줌 
								 // 20160318
								 // 							 if(!IsShortCell){
								 // 								 if(IsBMLineData){
								 // 									 //BMLineData[InspectCount].Dis1  = (int)(Math.GetLength(BMLine[0].FP0, MarkPos));
								 // 									 //BMLineData[InspectCount].Dis2  = (int)(Math.GetLength(BMLine[0].FP1, MarkPos));
								 // 									 BMLineData[InspectCount].Dis1  = (int)(fabs(MarkPos.x - BMLine[0].FP0.x));
								 // 									 BMLineData[InspectCount].Dis2  = (int)(fabs(MarkPos.x - BMLine[0].FP1.x));
								 // 									 BMLineData[InspectCount].yPos1 = (int)(BMLine[0].FP0.y);
								 // 									 BMLineData[InspectCount].yPos2 = (int)(BMLine[0].FP1.y);
								 // 								 }
								 // 								 else {
								 // 									 BMLine[0].FP0.x  =        (BMLineData[InspectCount].Dis1>MarkPos.x) ? 0 :(MarkPos.x - BMLineData[InspectCount].Dis1);
								 // 									 BMLine[0].FP0.y  = (float)(BMLineData[InspectCount].yPos1)                                                          ; 
								 // 									 BMLine[0].FP1.x  =        (BMLineData[InspectCount].Dis2>MarkPos.x) ? 0 :(MarkPos.x - BMLineData[InspectCount].Dis2);
								 // 									 BMLine[0].FP1.y  = (float)(BMLineData[InspectCount].yPos2)                                                          ; 
								 // 								 }
								 // 							 }
								 if(IsBMLineData){
									 if(IsShortCell){
										 if(BMLine[0].FP0.x!=0) BMLineData[InspectCount].Dis1  = (int)(BMLine[0].FP0.x);
										 if(BMLine[0].FP0.x!=0) BMLineData[InspectCount].Dis2  = (int)(BMLine[0].FP1.x);
										 if(BMLine[0].FP0.x!=0) BMLineData[InspectCount].yPos1 = (int)(BMLine[0].FP0.y);
										 if(BMLine[0].FP0.x!=0) BMLineData[InspectCount].yPos2 = (int)(BMLine[0].FP1.y);
									 }
									 else {
										 BMLineData[InspectCount].Dis1  = (int)(fabs(MarkPos.x - BMLine[0].FP0.x));
										 BMLineData[InspectCount].Dis2  = (int)(fabs(MarkPos.x - BMLine[0].FP1.x));
										 BMLineData[InspectCount].yPos1 = (int)(BMLine[0].FP0.y);
										 BMLineData[InspectCount].yPos2 = (int)(BMLine[0].FP1.y);

									 }
								 }
								 else {
									 if(IsShortCell){
										 BMLine[0].FP0.x  =(float)(BMLineData[InspectCount].Dis1+BMLineMargin);
										 BMLine[0].FP0.y  =(float)(BMLineData[InspectCount].yPos1            ); 
										 BMLine[0].FP1.x  =(float)(BMLineData[InspectCount].Dis2+BMLineMargin);
										 BMLine[0].FP1.y  =(float)(BMLineData[InspectCount].yPos2            ); 
									 }
									 else {
										 BMLine[0].FP0.x  = (float)(BMLineData[InspectCount].Dis1>MarkPos.x) ? 0 :(MarkPos.x - BMLineData[InspectCount].Dis1);
										 BMLine[0].FP0.y  = (float)(BMLineData[InspectCount].yPos1)                                                          ; 
										 BMLine[0].FP1.x  = (float)(BMLineData[InspectCount].Dis2>MarkPos.x) ? 0 :(MarkPos.x - BMLineData[InspectCount].Dis2);
										 BMLine[0].FP1.y  = (float)(BMLineData[InspectCount].yPos2)                                                          ; 
									 }
								 }


								 // InLine Start
								 //-----------------------------------------------------------------------------------------
								 BinaryImg.SetSize(GImage->GetWidth(), GImage->GetHeight());
								 EasyImage::Oper(EArithmeticLogicOperation_Copy,GImage,&BinaryImg);
								 EasyImage::Threshold(GImage,&BinaryImg, GrindThresHold);

								 // BMLine 기준 연마량 첫번째 Line 검출 
								 SingleLine->GImage = &BinaryImg;

								 SingleLine->IRoi->SetOrgX  ( (int)(LSP.x-20)                            );
								 SingleLine->IRoi->SetOrgY  ( (int) LSP.y                                );
								 SingleLine->IRoi->SetWidth (((int)((BMLine[0].FP0.x-BmToMarkDis) - (LSP.x-20))));
								 SingleLine->IRoi->SetHeight( (int)(LEP.y - LSP.y)                       );

								 if((LSP.x-20)<=0 || (LSP.y <0) || ((BMLine[0].FP0.x-BmToMarkDis) - (LSP.x-20))<=0 || ((LEP.y - LSP.y) <=0)){
									 // 								 AfxMessageBox("Btm InLine Inspection ROI Error");
									 return false;
								 }

								 // 연마량 측정 InLine
								 SingleLine->SetFindLineId(0);
								 SingleLine->SetOrientation(orEast);
								 SingleLine->OnExecute();
								 InLine[0].FP0 = SingleLine->GetResultP0();
								 InLine[0].FP1 = SingleLine->GetResultP1();


								 // InLine None....make InLine Data 
								 // 현재의 데이터를 넘겨준다 
								 if(InLine[0].FP0.x!=0.0f && InLine[0].FP0.y!=0.0f && InLine[0].FP1.x!=0.0f && InLine[0].FP1.y!=0.0f){
									 PreInLine[0].FP0.x = InLine[0].FP0.x;    PreInLine[0].FP1.x = InLine[0].FP1.x;       
									 PreInLine[0].FP0.y = InLine[0].FP0.y;    PreInLine[0].FP1.y = InLine[0].FP1.y;       
								 }

								 //Laege Broken 발생으로 Line을 찾지 못할경우 
								 if(InLine[0].FP0.x==0.0f || InLine[0].FP0.y==0.0f || InLine[0].FP1.x==0.0f || InLine[0].FP1.y==0.0f){
									 if(PreInLine[0].FP0.x==0.0f && PreInLine[0].FP0.y==0.0f && PreInLine[0].FP1.x==0.0f && PreInLine[0].FP1.y==0.0f){// 시작부분 Broken발생으로 데이터가 없는경우 
										 // Mark좌표를 기준으로 라인좌표값을 다시 설정함 
										 ROI_H = IRoi->GetHeight();
										 InLine[0].FP0.x = Line[0].FP0.x+Grind_Spec;   InLine[0].FP0.y = 0.0f        ;
										 InLine[0].FP1.x = Line[0].FP1.x+Grind_Spec;   InLine[0].FP1.y = (float)ROI_H;

										 //Line 데이터를 PreLine에 넘겨준다 
										 PreInLine[0].FP0.x = InLine[0].FP0.x;    PreInLine[0].FP1.x = InLine[0].FP1.x;       
										 PreInLine[0].FP0.y = InLine[0].FP0.y;    PreInLine[0].FP1.y = InLine[0].FP1.y;       
									 }
									 else {                                                                                                    // 중간부분 Broken발생으로 데이터가 없는경우 
										 // PreLine 데이터를 넘겨줌 
										 InLine[0].FP0.x = PreInLine[0].FP0.x;  InLine[0].FP1.x = PreInLine[0].FP1.x;  
										 InLine[0].FP0.y = PreInLine[0].FP0.y;  InLine[0].FP1.y = PreInLine[0].FP1.y;  
									 }
								 }
								 // InLine Start
								 //-----------------------------------------------------------------------------------------


								 // OutLine & 연마량 측정  Start
								 //-----------------------------------------------------------------------------------------
								 SingleLine->SetFindLineId(1);
								 SingleLine->SetOrientation(orEast);
								 SingleLine->OnExecute();
								 OutLine[0].FP0 = SingleLine->GetResultP0();
								 OutLine[0].FP1 = SingleLine->GetResultP1();

								 // OutLine None....make OutLine Data 
								 // 현재의 데이터를 넘겨준다 
								 if(OutLine[0].FP0.x!=0.0f && OutLine[0].FP0.y!=0.0f && OutLine[0].FP1.x!=0.0f && OutLine[0].FP1.y!=0.0f){
									 PreOutLine[0].FP0.x = OutLine[0].FP0.x;    PreOutLine[0].FP1.x = OutLine[0].FP1.x;       
									 PreOutLine[0].FP0.y = OutLine[0].FP0.y;    PreOutLine[0].FP1.y = OutLine[0].FP1.y;       
								 }

								 //Laege Broken 발생으로 Line을 찾지 못할경우 
								 if(OutLine[0].FP0.x==0.0f || OutLine[0].FP0.y==0.0f || OutLine[0].FP1.x==0.0f || OutLine[0].FP1.y==0.0f){
									 if(PreOutLine[0].FP0.x==0.0f && PreOutLine[0].FP0.y==0.0f && PreOutLine[0].FP1.x==0.0f && PreOutLine[0].FP1.y==0.0f){// 시작부분 Broken발생으로 데이터가 없는경우 
										 // Mark좌표를 기준으로 라인좌표값을 다시 설정함 
										 ROI_H = IRoi->GetHeight();
										 OutLine[0].FP0.x = Line[0].FP0.x;    OutLine[0].FP0.y = 0.0f        ;
										 OutLine[0].FP1.x = Line[0].FP1.x;    OutLine[0].FP1.y = (float)ROI_H;

										 //Line 데이터를 PreLine에 넘겨준다 
										 PreOutLine[0].FP0.x = OutLine[0].FP0.x;    PreOutLine[0].FP1.x = OutLine[0].FP1.x;       
										 PreOutLine[0].FP0.y = OutLine[0].FP0.y;    PreOutLine[0].FP1.y = OutLine[0].FP1.y;       
									 }
									 else {                                                                                                    // 중간부분 Broken발생으로 데이터가 없는경우 
										 // PreLine 데이터를 넘겨줌 
										 OutLine[0].FP0.x = PreOutLine[0].FP0.x;  OutLine[0].FP1.x = PreOutLine[0].FP1.x;  
										 OutLine[0].FP0.y = PreOutLine[0].FP0.y;  OutLine[0].FP1.y = PreOutLine[0].FP1.y;  
									 }
								 }
								 Cell_Size = Math.GetLengthFrLineToPoint(OutLine[0].FP0,OutLine[0].FP1, BMLine[0].FP0 );
								 // OutLine & 연마량 측정  End 
								 //-----------------------------------------------------------------------------------------
							 }
							 SingleLine->SetFindLineId(0);

							 // Cell_Size 측정
							 GrindSize = Math.GetLengthFrLineToPoint(OutLine[0].FP0,OutLine[0].FP1, InLine[0].FP0 );
						 }
					 }
					 else if(FCompanyMode==COM_BOE){ // RectCL OutLine, InLine Search
						 // GrindLine 찾기
						 // org
// 						 BinaryImg.SetSize(GImage->GetWidth(), GImage->GetHeight());
// 						 EasyImage::Oper(EArithmeticLogicOperation_Copy,GImage,&BinaryImg);
// 						 EasyImage::Threshold(GImage,&BinaryImg, GrindThresHold);

						 BinaryImg.SetSize(GImage->GetWidth(), GImage->GetHeight());
						 EasyImage::Oper(EArithmeticLogicOperation_Copy,GImage,&BinaryImg);
						 EasyImage::Threshold(GImage,&BinaryImg, EThresHold);

						 // BMLine 기준 연마량 첫번째 Line 검출 
						 SingleLine->GImage = &BinaryImg;

						 // 영역설정 
						 LSP = Math.OnIntersect(Line[waLeftWall].FP0, Line[waLeftWall].FP1, LT, RT);
						 LEP = FLBLPoint;
// 						 LEP = FLBPoint;

						 SingleLine->IRoi->SetOrgX  ((int)LSP.x-20       );
						 SingleLine->IRoi->SetOrgY  ((int)LSP.y          );
						 SingleLine->IRoi->SetWidth (100                 );
						 SingleLine->IRoi->SetHeight((int)(LEP.y - LSP.y));

						 if((LSP.x-20)<=0 || LSP.y<0 || ((LEP.y - LSP.y)<=0) ) return false;

						 if(IRoi->GetHeight()<300) SingleLine->SetIncrement(5 );
						 else                      SingleLine->SetIncrement(100);

						 // 연마량 측정 OutLine
						 SingleLine->SetFindLineId(0);
						 SingleLine->SetOrientation(orWest);
						 SingleLine->OnExecute();
						 OutLine[0].FP0 = SingleLine->GetResultP0();
						 OutLine[0].FP1 = SingleLine->GetResultP1();

						 // OutLine None....make OutLine Data 
						 // 현재의 데이터를 넘겨준다 
						 if(OutLine[0].FP0.x!=0.0f && OutLine[0].FP0.y!=0.0f && OutLine[0].FP1.x!=0.0f && OutLine[0].FP1.y!=0.0f){
							 PreOutLine[0].FP0.x = OutLine[0].FP0.x;    PreOutLine[0].FP1.x = OutLine[0].FP1.x;       
							 PreOutLine[0].FP0.y = OutLine[0].FP0.y;    PreOutLine[0].FP1.y = OutLine[0].FP1.y;       
						 }

						 //Laege Broken 발생으로 Line을 찾지 못할경우 
						 if(OutLine[0].FP0.x==0.0f || OutLine[0].FP0.y==0.0f || OutLine[0].FP1.x==0.0f || OutLine[0].FP1.y==0.0f){
							 if(PreOutLine[0].FP0.x==0.0f && PreOutLine[0].FP0.y==0.0f && PreOutLine[0].FP1.x==0.0f && PreOutLine[0].FP1.y==0.0f){// 시작부분 Broken발생으로 데이터가 없는경우 
								 // Mark좌표를 기준으로 라인좌표값을 다시 설정함 
								 ROI_H = IRoi->GetHeight();
								 OutLine[0].FP0.x = Line[0].FP0.x;    OutLine[0].FP0.y = 0.0f        ;
								 OutLine[0].FP1.x = Line[0].FP1.x;    OutLine[0].FP1.y = (float)ROI_H;

								 //Line 데이터를 PreLine에 넘겨준다 
								 PreOutLine[0].FP0.x = OutLine[0].FP0.x;    PreOutLine[0].FP1.x = OutLine[0].FP1.x;       
								 PreOutLine[0].FP0.y = OutLine[0].FP0.y;    PreOutLine[0].FP1.y = OutLine[0].FP1.y;       
							 }
							 else {                                                                                                    // 중간부분 Broken발생으로 데이터가 없는경우 
								 // PreLine 데이터를 넘겨줌 
								 OutLine[0].FP0.x = PreOutLine[0].FP0.x;  OutLine[0].FP1.x = PreOutLine[0].FP1.x;  
								 OutLine[0].FP0.y = PreOutLine[0].FP0.y;  OutLine[0].FP1.y = PreOutLine[0].FP1.y;  
							 }
						 }

						 // 연마량 측정 InLine
						 // ORG
// 						 SingleLine->SetFindLineId(1);
// 						 SingleLine->SetOrientation(orWest);
// 						 SingleLine->OnExecute();
// 						 InLine[0].FP0 = SingleLine->GetResultP0();
// 						 InLine[0].FP1 = SingleLine->GetResultP1();

						 BinaryImg.SetSize(GImage->GetWidth(), GImage->GetHeight());
						 EasyImage::Oper(EArithmeticLogicOperation_Copy,GImage,&BinaryImg);
						 EasyImage::Threshold(GImage,&BinaryImg, GrindThresHold);

						 // BMLine 기준 연마량 첫번째 Line 검출 
						 SingleLine->GImage = &BinaryImg;

						 // 영역설정 
						 LSP = Math.OnIntersect(Line[waLeftWall].FP0, Line[waLeftWall].FP1, LT, RT);
						 LEP = FLBLPoint;
						 // 						 LEP = FLBPoint;

						 SingleLine->IRoi->SetOrgX  ((int)LSP.x+2        );
						 SingleLine->IRoi->SetOrgY  ((int)LSP.y          );
						 SingleLine->IRoi->SetWidth (100                 );
						 SingleLine->IRoi->SetHeight((int)(LEP.y - LSP.y));

						 if((LSP.x+10)<=0 || LSP.y<0 || ((LEP.y - LSP.y)<=0) ) return false;

						 if(IRoi->GetHeight()<300) SingleLine->SetIncrement(5 );
						 else                      SingleLine->SetIncrement(100);

						 // 연마량 측정 OutLine
						 SingleLine->SetFindLineId(0);
						 SingleLine->SetOrientation(orWest);
						 SingleLine->SetEdgeType(0); // Black to White 
						 SingleLine->OnExecute();
						 InLine[0].FP0 = SingleLine->GetResultP0();
						 InLine[0].FP1 = SingleLine->GetResultP1();

						 SingleLine->SetEdgeType(2); // Black to White 

						 // InLine None....make InLine Data 
						 // 현재의 데이터를 넘겨준다 
						 if(InLine[0].FP0.x!=0.0f && InLine[0].FP0.y!=0.0f && InLine[0].FP1.x!=0.0f && InLine[0].FP1.y!=0.0f){
							 PreInLine[0].FP0.x = InLine[0].FP0.x;    PreInLine[0].FP1.x = InLine[0].FP1.x;       
							 PreInLine[0].FP0.y = InLine[0].FP0.y;    PreInLine[0].FP1.y = InLine[0].FP1.y;       
						 }

						 //Laege Broken 발생으로 Line을 찾지 못할경우 
						 if(InLine[0].FP0.x==0.0f || InLine[0].FP0.y==0.0f || InLine[0].FP1.x==0.0f || InLine[0].FP1.y==0.0f){
							 if(PreInLine[0].FP0.x==0.0f && PreInLine[0].FP0.y==0.0f && PreInLine[0].FP1.x==0.0f && PreInLine[0].FP1.y==0.0f){// 시작부분 Broken발생으로 데이터가 없는경우 
								 // Mark좌표를 기준으로 라인좌표값을 다시 설정함 
								 ROI_H = IRoi->GetHeight();
								 InLine[0].FP0.x = Line[0].FP0.x+Grind_Spec;   InLine[0].FP0.y = 0.0f        ;
								 InLine[0].FP1.x = Line[0].FP1.x+Grind_Spec;   InLine[0].FP1.y = (float)ROI_H;

								 //Line 데이터를 PreLine에 넘겨준다 
								 PreInLine[0].FP0.x = InLine[0].FP0.x;    PreInLine[0].FP1.x = InLine[0].FP1.x;       
								 PreInLine[0].FP0.y = InLine[0].FP0.y;    PreInLine[0].FP1.y = InLine[0].FP1.y;       
							 }
							 else {                                                                                                    // 중간부분 Broken발생으로 데이터가 없는경우 
								 // PreLine 데이터를 넘겨줌 
								 InLine[0].FP0.x = PreInLine[0].FP0.x;  InLine[0].FP1.x = PreInLine[0].FP1.x;  
								 InLine[0].FP0.y = PreInLine[0].FP0.y;  InLine[0].FP1.y = PreInLine[0].FP1.y;  
							 }
						 }
						 // GrindSize 측정 
						 // 사용자가 지정한 간격만큼 GrindSize 측정은 어떻게??..........
						 GrindSize =(float)(Math.GetLengthFrLineToPoint (OutLine[0].FP0,OutLine[0].FP1, InLine[0].FP0 ));
					 }
 				 }
                 Index++;


        // Find Edge Point - Bevel In Side Only
        //----------------------------------------------------------------------
        case 11 :
			     DefectImg.SetSize(GImage->GetWidth(), GImage->GetHeight());
			     EasyImage::Oper(EArithmeticLogicOperation_Copy,GImage,&DefectImg);
         		 //EasyImage::Threshold(GImage,&DefectImg, DThresHold);

                 if (FProcessMode==pmAutoBevelIn) {
					 //BinaryImg.SetSize(GImage->GetWidth(), GImage->GetHeight());
					 //EasyImage::Oper(EArithmeticLogicOperation_Copy,GImage,&BinaryImg);
					 //EasyImage::Threshold(GImage,&BinaryImg, ThredHold);
					 Edge->GImage = &DefectImg;
                     //Edge->GImage = GImage;
  
                     if(!OnAutoBevelIn()) return false;
                     Index=0;
                     return true;
                 }
                 else if (FProcessMode==pmManualBevelIn) {
					 //BinaryImg.SetSize(GImage->GetWidth(), GImage->GetHeight());
					 //EasyImage::Oper(EArithmeticLogicOperation_Copy,GImage,&BinaryImg);
					 //EasyImage::Threshold(GImage,&BinaryImg, ThredHold);
					 Edge->GImage = &DefectImg;

                     //Edge->GImage = GImage;
                     OnManualBevelIn();
                     Index=0;
                     return true;
                 }
                 Index++;


        // Find Edge Point
        //----------------------------------------------------------------------
        case 12 :
                 RectEdge->GImage = GImage;

                 RectEdge->IRoi->SetOrgX  (IRoi->GetOrgX());
                 RectEdge->IRoi->SetOrgY  (IRoi->GetOrgY());
                 RectEdge->IRoi->SetWidth (IRoi->GetWidth());
                 RectEdge->IRoi->SetHeight(IRoi->GetHeight());

                 RectEdge->OnExecute(l, t, r, b);
                 Index++;

        // Find Defect Edge Point
        //----------------------------------------------------------------------
        case 13 :
                 DefectPointCount = 0;
                 for (int i=0; i<RectEdge->GetResultEdgePointCount(); i++) {
                      bool IsNormal = false;
                      float dt = 0;
                      if (FLeftWall   ) { dt = GetLengthFrLineToPoint(Line[waLeftWall   ].FP0, Line[waLeftWall   ].FP1, RectEdge->GetResultEdgePoint(i)); if (dt<=FEscapeDeviation) IsNormal = true; }
                      if (FTopWall    ) { dt = GetLengthFrLineToPoint(Line[waTopWall    ].FP0, Line[waTopWall    ].FP1, RectEdge->GetResultEdgePoint(i)); if (dt<=FEscapeDeviation) IsNormal = true; }
                      if (FRightWall  ) { dt = GetLengthFrLineToPoint(Line[waRightWall  ].FP0, Line[waRightWall  ].FP1, RectEdge->GetResultEdgePoint(i)); if (dt<=FEscapeDeviation) IsNormal = true; }
                      if (FBottomWall ) { dt = GetLengthFrLineToPoint(Line[waBottomWall ].FP0, Line[waBottomWall ].FP1, RectEdge->GetResultEdgePoint(i)); if (dt<=FEscapeDeviation) IsNormal = true; }
                      if (FLeftTop    ) { dt = GetLengthFrLineToPoint(Line[waLeftTop    ].FP0, Line[waLeftTop    ].FP1, RectEdge->GetResultEdgePoint(i)); if (dt<=FEscapeDeviation) IsNormal = true; }
                      if (FRightTop   ) { dt = GetLengthFrLineToPoint(Line[waRightTop   ].FP0, Line[waRightTop   ].FP1, RectEdge->GetResultEdgePoint(i)); if (dt<=FEscapeDeviation) IsNormal = true; }
                      if (FRightBottom) { dt = GetLengthFrLineToPoint(Line[waRightBottom].FP0, Line[waRightBottom].FP1, RectEdge->GetResultEdgePoint(i)); if (dt<=FEscapeDeviation) IsNormal = true; }
                      if (FLeftBottom ) { dt = GetLengthFrLineToPoint(Line[waLeftBottom ].FP0, Line[waLeftBottom ].FP1, RectEdge->GetResultEdgePoint(i)); if (dt<=FEscapeDeviation) IsNormal = true; }

					  // GOO 
					  
                      //if (!IsNormal) {
                      //    FDefectPoint[DefectPointCount] = RectEdge->GetResultEdgePoint(i);
                      //    DefectPointCount++;
                      // }
				 }
				 Index++;

        case 14 :
			Index=0;
			break;



    }
    return true;
}
void CMultiLineDefect::OnLoad(bool IsLoad, CString Folder)
{
    CIFile Ini;

    if (Folder=="") return;
    CString Path = Folder + "\\PLine.ini";
    if (Path=="") return;

    //Ini.Load(IsLoad, Path, "Parameter", "FMaxLines"  , &FMaxLines);
}

void CMultiLineDefect::OnPaint(TDrawTool Tool)
{
	if (FDrawOutLine ) OnPaintOutLine (Tool);
	if (FDrawBevelIn ) OnPaintBevelIn (Tool);
	if (FDrawRectEdge) OnPaintRectEdge(Tool);
	if (FDrawDefect  ) OnPaintDefect  (Tool);
}

//------------------------------------------------------------------------------

void CMultiLineDefect::OnPaintOutLine(TDrawTool Tool)
{
    if (Tool.Handle==NULL) return;

    HGdi *Gdi = new HGdi(Tool.Handle);

	Gdi->FVx = Tool.FVx;
	Gdi->FVy = Tool.FVy;
	Gdi->FHs = Tool.FHs;
	Gdi->FVs = Tool.FVs;
	Gdi->CPen.Color = Tool.Color;

    Gdi->CText.Color  = YELLOW_COLOR;
    Gdi->CFont.Height = 12;
    Gdi->CPen.Color   = Tool.Color;
    Gdi->CPen.Width   = 2;

    int ImgW = GImage->GetWidth();
    int ImgH = GImage->GetHeight();

    TFPoint LT(0          ,           0);
    TFPoint RT((float)ImgW,           0);
    TFPoint RB((float)ImgW, (float)ImgH);
    TFPoint LB(0          , (float)ImgH);
    TFPoint SP, EP;

    bool Rect8 = FLeftWall && FTopWall && FRightWall && FBottomWall && FLeftTop && FRightTop && FRightBottom && FLeftBottom;
    bool Rect4 = FLeftWall && FTopWall && FRightWall && FBottomWall && !FLeftTop && !FRightTop && !FRightBottom && !FLeftBottom;
    bool RectH = FLeftWall && FTopWall && FRightWall && !FBottomWall && FLeftTop && FRightTop && !FRightBottom && !FLeftBottom;
    bool RectC = FLeftWall && !FTopWall && FRightWall && FBottomWall && !FLeftTop && !FRightTop && FRightBottom && FLeftBottom;
    bool RectS = FLeftWall && !FTopWall && FRightWall && !FBottomWall && !FLeftTop && !FRightTop && !FRightBottom && !FLeftBottom;

    int Index = 10;
    if (Rect4) Index = 10;
    if (Rect8) Index = 11;
    if (RectH) Index = 12;
    if (RectC) Index = 13;
    if (RectS) Index = 14;

    int dx=FEscapeDeviation, dy=FEscapeDeviation;

    TFPoint FPLW0 = Line[waLeftWall ].FP0;
    TFPoint FPLW1 = Line[waLeftWall ].FP1;
    TFPoint FPRW0 = Line[waRightWall].FP0;
    TFPoint FPRW1 = Line[waRightWall].FP1;

    switch (Index) {

        // Rect4
        //----------------------------------------------------------------------
        case 10 :
                 Gdi->OnMove(FLTPoint.x, FLTPoint.y);
                 Gdi->OnLine(FRTPoint.x, FRTPoint.y);
                 Gdi->OnLine(FRBPoint.x, FRBPoint.y);
                 Gdi->OnLine(FLBPoint.x, FLBPoint.y);
                 Gdi->OnLine(FLTPoint.x, FLTPoint.y);
                 break;

        // Rect8
        //----------------------------------------------------------------------
        case 11 :
                 Gdi->OnMove(FLTPoint.x, FLTPoint.y);
                 Gdi->OnLine(FRTPoint.x, FRTPoint.y);
                 Gdi->OnLine(FRBPoint.x, FRBPoint.y);
                 Gdi->OnLine(FLBPoint.x, FLBPoint.y);
                 Gdi->OnLine(FLTPoint.x, FLTPoint.y);

                 Gdi->OnMove(FLTLPoint.x, FLTLPoint.y);
                 Gdi->OnLine(FLTTPoint.x, FLTTPoint.y);
                 Gdi->OnLine(FRTTPoint.x, FRTTPoint.y);
                 Gdi->OnLine(FRTRPoint.x, FRTRPoint.y);
                 Gdi->OnLine(FRBRPoint.x, FRBRPoint.y);
                 Gdi->OnLine(FRBBPoint.x, FRBBPoint.y);
                 Gdi->OnLine(FLBBPoint.x, FLBBPoint.y);
                 Gdi->OnLine(FLBLPoint.x, FLBLPoint.y);
                 Gdi->OnLine(FLBLPoint.x, FLTLPoint.y);

                 break;

        // RectH
        //----------------------------------------------------------------------
        case 12 :
                 SP = Math.OnIntersect(FPLW0, FPLW1, LB, RB);
                 EP = Math.OnIntersect(FPRW0, FPRW1, LB, RB);

                 Gdi->OnMove(SP.x, SP.y);
                 Gdi->OnLine(FLTPoint.x, FLTPoint.y);
                 Gdi->OnLine(FRTPoint.x, FRTPoint.y);
                 Gdi->OnLine(EP.x, EP.y);
                 break;

        // RectC
        //----------------------------------------------------------------------
        case 13 :
                 SP = Math.OnIntersect(FPLW0, FPLW1, LT, RT);
                 EP = Math.OnIntersect(FPRW0, FPRW1, LT, RT);

                 Gdi->OnMove(SP.x, SP.y);
                 Gdi->OnLine(FLBPoint.x, FLBPoint.y);
                 Gdi->OnLine(FRBPoint.x, FRBPoint.y);
                 Gdi->OnLine(EP.x, EP.y);
                 break;

        // RectS
        //----------------------------------------------------------------------
        case 14 :
                 SP = Math.OnIntersect(FPLW0, FPLW1, LT, RT);
                 EP = Math.OnIntersect(FPLW0, FPLW1, LB, RB);

                 Gdi->OnMove(SP.x, SP.y);
                 Gdi->OnLine(EP.x, EP.y);

                 SP = Math.OnIntersect(FPRW0, FPRW1, LT, RT);
                 EP = Math.OnIntersect(FPRW0, FPRW1, LB, RB);

                 Gdi->OnMove(SP.x, SP.y);
                 Gdi->OnLine(EP.x, EP.y);
                 break;


    }

    // Draw Corner Lines
    // -------------------------------------------------------------------------
    if (FLeftTop    ) { Gdi->OnMove(FLTLPoint.x, FLTLPoint.y); Gdi->OnLine(FLTTPoint.x, FLTTPoint.y); }
    if (FRightTop   ) { Gdi->OnMove(FRTRPoint.x, FRTRPoint.y); Gdi->OnLine(FRTTPoint.x, FRTTPoint.y); }
    if (FRightBottom) { Gdi->OnMove(FRBRPoint.x, FRBRPoint.y); Gdi->OnLine(FRBBPoint.x, FRBBPoint.y); }
    if (FLeftBottom ) { Gdi->OnMove(FLBLPoint.x, FLBLPoint.y); Gdi->OnLine(FLBBPoint.x, FLBBPoint.y); }

    delete Gdi;
}

// -------------------------------------------------------------------------

void CMultiLineDefect::OnPaintBevelIn(TDrawTool Tool)
{
    if (Tool.Handle==NULL) return;

    HGdi *Gdi = new HGdi(Tool.Handle);

	Gdi->FVx = Tool.FVx;
	Gdi->FVy = Tool.FVy;
	Gdi->FHs = Tool.FHs;
	Gdi->FVs = Tool.FVs;
	Gdi->CPen.Color = Tool.Color;

    Gdi->CText.Color  = YELLOW_COLOR;
    Gdi->CFont.Height = 12;
    Gdi->CPen.Color = Tool.Color;
    Gdi->CPen.Width = 2;

    int ImgW = GImage->GetWidth();
    int ImgH = GImage->GetHeight();

    TFPoint LT(0          ,           0);
    TFPoint RT((float)ImgW,           0);
    TFPoint RB((float)ImgW, (float)ImgH);
    TFPoint LB(0          , (float)ImgH);
    TFPoint SP, EP;

    bool Rect8 = FLeftWall && FTopWall && FRightWall && FBottomWall && FLeftTop && FRightTop && FRightBottom && FLeftBottom;
    bool Rect4 = FLeftWall && FTopWall && FRightWall && FBottomWall && !FLeftTop && !FRightTop && !FRightBottom && !FLeftBottom;
    bool RectH = FLeftWall && FTopWall && FRightWall && !FBottomWall && FLeftTop && FRightTop && !FRightBottom && !FLeftBottom;
    bool RectC = FLeftWall && !FTopWall && FRightWall && FBottomWall && !FLeftTop && !FRightTop && FRightBottom && FLeftBottom;
    bool RectS = FLeftWall && !FTopWall && FRightWall && !FBottomWall && !FLeftTop && !FRightTop && !FRightBottom && !FLeftBottom;

    int Index = 10;
    if (Rect4) Index = 10;
    if (Rect8) Index = 11;
    if (RectH) Index = 12;
    if (RectC) Index = 13;
    if (RectS) Index = 14;

    int dx=FEscapeDeviation, dy=FEscapeDeviation;

    /*
    TFPoint FPLW0(Line[waLeftWall   ].FP0.x+dx, Line[waLeftWall   ].FP0.y   );
    TFPoint FPLW1(Line[waLeftWall   ].FP1.x+dx, Line[waLeftWall   ].FP1.y   );
    TFPoint FPTW0(Line[waTopWall    ].FP0.x   , Line[waTopWall    ].FP0.y+dy);
    TFPoint FPTW1(Line[waTopWall    ].FP1.x   , Line[waTopWall    ].FP1.y+dy);
    TFPoint FPRW0(Line[waRightWall  ].FP0.x-dx, Line[waRightWall  ].FP0.y   );
    TFPoint FPRW1(Line[waRightWall  ].FP1.x-dx, Line[waRightWall  ].FP1.y   );
    TFPoint FPBW0(Line[waBottomWall ].FP0.x+dx, Line[waBottomWall ].FP0.y-dy);
    TFPoint FPBW1(Line[waBottomWall ].FP1.x+dx, Line[waBottomWall ].FP1.y-dy);

    TFPoint InLTPoint(FLTPoint.x+dx, FLTPoint.y+dy);
    TFPoint InRTPoint(FRTPoint.x-dx, FRTPoint.y+dy);
    TFPoint InRBPoint(FRBPoint.x-dx, FRBPoint.y-dy);
    TFPoint InLBPoint(FLBPoint.x+dx, FLBPoint.y-dy);

    TFPoint InLTLPoint = Math.OnIntersect(FPLW0, FPLW1, FLTLPoint, Math.OnRotate(FLTLPoint, FLTTPoint, 90));
    TFPoint InLTTPoint = Math.OnIntersect(FPTW0, FPTW1, FLTTPoint, Math.OnRotate(FLTTPoint, FLTLPoint, 90));
    TFPoint InRTRPoint = Math.OnIntersect(FPRW0, FPRW1, FRTRPoint, Math.OnRotate(FRTRPoint, FRTTPoint, 90));
    TFPoint InRTTPoint = Math.OnIntersect(FPTW0, FPTW1, FRTTPoint, Math.OnRotate(FRTTPoint, FRTRPoint, 90));
    TFPoint InRBRPoint = Math.OnIntersect(FPRW0, FPRW1, FRBRPoint, Math.OnRotate(FRBRPoint, FRBBPoint, 90));
    TFPoint InRBBPoint = Math.OnIntersect(FPBW0, FPBW1, FRBBPoint, Math.OnRotate(FRBBPoint, FRBRPoint, 90));
    TFPoint InLBLPoint = Math.OnIntersect(FPLW0, FPLW1, FLBLPoint, Math.OnRotate(FLBLPoint, FLBBPoint, 90));
    TFPoint InLBBPoint = Math.OnIntersect(FPBW0, FPBW1, FLBBPoint, Math.OnRotate(FLBBPoint, FLBLPoint, 90));
    */
    
    switch (Index) {                                    
                                                        
        // Rect4
        //----------------------------------------------------------------------
        case 10 :
                 Gdi->OnMove(InLTPoint.x, InLTPoint.y);
                 Gdi->OnLine(InRTPoint.x, InRTPoint.y);
                 Gdi->OnLine(InRBPoint.x, InRBPoint.y);
                 Gdi->OnLine(InLBPoint.x, InLBPoint.y);
                 Gdi->OnLine(InLTPoint.x, InLTPoint.y);
                 break;

        // Rect8
        //----------------------------------------------------------------------
        case 11 :
                 Gdi->OnMove(InLTPoint.x, InLTPoint.y);
                 Gdi->OnLine(InRTPoint.x, InRTPoint.y);
                 Gdi->OnLine(InRBPoint.x, InRBPoint.y);
                 Gdi->OnLine(InLBPoint.x, InLBPoint.y);
                 Gdi->OnLine(InLTPoint.x, InLTPoint.y);

                 Gdi->OnMove(InLTLPoint.x, InLTLPoint.y);
                 Gdi->OnLine(InLTTPoint.x, InLTTPoint.y);
                 Gdi->OnLine(InRTTPoint.x, InRTTPoint.y);
                 Gdi->OnLine(InRTRPoint.x, InRTRPoint.y);
                 Gdi->OnLine(InRBRPoint.x, InRBRPoint.y);
                 Gdi->OnLine(InRBBPoint.x, InRBBPoint.y);
                 Gdi->OnLine(InLBBPoint.x, InLBBPoint.y);
                 Gdi->OnLine(InLBLPoint.x, InLBLPoint.y);
                 Gdi->OnLine(InLBLPoint.x, InLTLPoint.y);

                 break;

        // RectH
        //----------------------------------------------------------------------
        case 12 :
                 SP = Math.OnIntersect(PLW0, PLW1, LB, RB);
                 EP = Math.OnIntersect(PRW0, PRW1, LB, RB);

                 Gdi->OnMove(SP.x, SP.y);
                 Gdi->OnLine(InLTLPoint.x, InLTLPoint.y);
                 Gdi->OnLine(InLTTPoint.x, InLTTPoint.y);
                 Gdi->OnLine(InRTTPoint.x, InRTTPoint.y);
                 Gdi->OnLine(InRTRPoint.x, InRTRPoint.y);
                 Gdi->OnLine(EP.x, EP.y);
                 break;

        // RectC
        //----------------------------------------------------------------------
        case 13 :
                 SP = Math.OnIntersect(PLW0, PLW1, LT, RT);
                 EP = Math.OnIntersect(PRW0, PRW1, LT, RT);

                 Gdi->OnMove(SP.x, SP.y);
                 Gdi->OnLine(InLBLPoint.x, InLBLPoint.y);
                 Gdi->OnLine(InLBBPoint.x, InLBBPoint.y);
                 Gdi->OnLine(InRBBPoint.x, InRBBPoint.y);
                 Gdi->OnLine(InRBRPoint.x, InRBRPoint.y);
                 Gdi->OnLine(EP.x, EP.y);
                 break;

        // RectS
        //----------------------------------------------------------------------
        case 14 :
                 SP = Math.OnIntersect(PLW0, PLW1, LT, RT);
                 EP = Math.OnIntersect(PLW0, PLW1, LB, RB);

                 Gdi->OnMove(SP.x, SP.y);
                 Gdi->OnLine(EP.x, EP.y);

                 SP = Math.OnIntersect(PRW0, PRW1, LT, RT);
                 EP = Math.OnIntersect(PRW0, PRW1, LB, RB);

                 Gdi->OnMove(SP.x, SP.y);
                 Gdi->OnLine(EP.x, EP.y);
                 break;


    }

    // Draw Corner Lines
    // -------------------------------------------------------------------------
    if (FLeftTop    ) { Gdi->OnMove(InLTLPoint.x, InLTLPoint.y); Gdi->OnLine(InLTTPoint.x, InLTTPoint.y); }
    if (FRightTop   ) { Gdi->OnMove(InRTRPoint.x, InRTRPoint.y); Gdi->OnLine(InRTTPoint.x, InRTTPoint.y); }
    if (FRightBottom) { Gdi->OnMove(InRBRPoint.x, InRBRPoint.y); Gdi->OnLine(InRBBPoint.x, InRBBPoint.y); }
    if (FLeftBottom ) { Gdi->OnMove(InLBLPoint.x, InLBLPoint.y); Gdi->OnLine(InLBBPoint.x, InLBBPoint.y); }

    delete Gdi;
}


void CMultiLineDefect::OnPaintDefect(TDrawTool Tool)
{
    if (Tool.Handle==NULL) return;

    HGdi *Gdi = new HGdi(Tool.Handle);

    Gdi->FVx = Tool.FVx;
    Gdi->FVy = Tool.FVy;
    Gdi->FHs = Tool.FHs;
    Gdi->FVs = Tool.FVs;
    Gdi->CPen.Color = Tool.Color;

    Gdi->CText.Color  = YELLOW_COLOR;
    Gdi->CFont.Height = 12;
	Gdi->CPen.Color   = Tool.Color;
    Gdi->CPen.Width   = 2;

	// GOO 
	/*
    for (int k=0; k<ACount; k++) {
        Gdi->OnCircle(false, ADefectPoint[k].x, ADefectPoint[k].y, 5, 5);
        Gdi->OnLinePlus(ADefectPoint[k].x, ADefectPoint[k].y, 5);
    }

    for (int k=0; k<BCount; k++) {
        Gdi->OnCircle(false, BDefectPoint[k].x, BDefectPoint[k].y, 5, 5);
        Gdi->OnLinePlus(BDefectPoint[k].x, BDefectPoint[k].y, 5);
    }

    for (int k=0; k<CCount; k++) {
        Gdi->OnCircle(false, CDefectPoint[k].x, CDefectPoint[k].y, 5, 5);
        Gdi->OnLinePlus(CDefectPoint[k].x, CDefectPoint[k].y, 5);
    }

    for (int k=0; k<DCount; k++) {
        Gdi->OnCircle(false, DDefectPoint[k].x, DDefectPoint[k].y, 5, 5);
        Gdi->OnLinePlus(DDefectPoint[k].x, DDefectPoint[k].y, 5);
    }

    for (int k=0; k<C1Count; k++) {
        Gdi->OnCircle(false, C1DefectPoint[k].x, C1DefectPoint[k].y, 5, 5);
        Gdi->OnLinePlus(C1DefectPoint[k].x, C1DefectPoint[k].y, 5);
    }

    for (int k=0; k<C2Count; k++) {
        Gdi->OnCircle(false, C2DefectPoint[k].x, C2DefectPoint[k].y, 5, 5);
        Gdi->OnLinePlus(C2DefectPoint[k].x, C2DefectPoint[k].y, 5);
    }

    for (int k=0; k<C3Count; k++) {
        Gdi->OnCircle(false, C3DefectPoint[k].x, C3DefectPoint[k].y, 5, 5);
        Gdi->OnLinePlus(C3DefectPoint[k].x, C3DefectPoint[k].y, 5);
    }

    for (int k=0; k<C4Count; k++) {
        Gdi->OnCircle(false, C4DefectPoint[k].x, C4DefectPoint[k].y, 5, 5);
        Gdi->OnLinePlus(C4DefectPoint[k].x, C4DefectPoint[k].y, 5);
    }
	*/

    delete Gdi;
}
//-----------------------------------------------------------------------------------
void CMultiLineDefect::OnPaintRectEdge(TDrawTool Tool)
{
	RectEdge->OnPaint(Tool);
}
//------------------------------------------------------------------------------------
bool CMultiLineDefect::OnInspection()
{
	
    if     (GrabCount==0         ) {PreGrabCount=  0; NexGrabCount=0; return false;}
    else if(GrabCount==1         ) {LineIndex   = 10;                              }
    else if(GrabCount==TotalCount) {
		if(GrabCount>NexGrabCount) GrabCount = NexGrabCount;
		LineIndex   = 12;
    }
    else                                {
        if(GrabCount>NexGrabCount) GrabCount = NexGrabCount;
        LineIndex   = 11;
    }
	
	
    switch (LineIndex) 
	{
	default : LineIndex = 0; break;
		
	case 10 :
		if(GrabCount==1 && GrabCount!=PreGrabCount){
			// GImage 실제 이미지 넘겨줘야함
			SetShape(shRectH);
			OnExecute();
			PreGrabCount = GrabCount;
			NexGrabCount = GrabCount+1;
			return true;
		}
		break;
		
	case 11 :
		if(GrabCount!=PreGrabCount){
			// GImage 실제 이미지 넘겨줘야함
			// Grabber 빠를경우   GrabCount에 해당하는 이미지를 가져온다
			SetShape(shRectS);
			OnExecute();
			PreGrabCount = GrabCount;
			NexGrabCount = GrabCount+1;
			return true;
		}
		break;
		
	case 12 :
		if(GrabCount!=PreGrabCount){
			// GImage 실제 이미지 넘겨줘야함
			SetShape(shRectC);

			OnExecute();
			PreGrabCount = GrabCount;
			NexGrabCount = GrabCount+1;
			return true;
		}
		break;
    }
	return false;
}
//------------------------------------------------------------------------------------------
// 사용자 Set함수 
//------------------------------------------------------------------------------------------
void CMultiLineDefect::SetProcessMode(TProcessMode ProcessMode)
{
	FProcessMode  = ProcessMode;
}
//------------------------------------------------------------------------------------------
void CMultiLineDefect::SetInspectMode(TInspectMode InspectMode)
{
	FInspectMode  = InspectMode;
}
//------------------------------------------------------------------------------------------
void CMultiLineDefect::SetCutMode(TCutMode CutMode)
{
	FCutMode  = CutMode;
}
//-------------------------------------------------------------------------------------------
void CMultiLineDefect::SetCompanyMode(TCompany Company)
{
	FCompanyMode  = Company;
}
//-------------------------------------------------------------------------------------------
void CMultiLineDefect::SetShape(TShape Shape)
{
	FShape = Shape;
}
//-------------------------------------------------------------------------------------------
void CMultiLineDefect::SetEscapeDeviation(int EscapeDeviation)
{
	FEscapeDeviation = EscapeDeviation;
}
//-------------------------------------------------------------------------------------------
void CMultiLineDefect::SetLeftDistance(int Dv)
{
	LeftDistance     = Dv;
}
//-------------------------------------------------------------------------------------------
void CMultiLineDefect::SetTopDistance(int Dv)
{
	TopDistance      = Dv;
}
//-------------------------------------------------------------------------------------------
void CMultiLineDefect::SetRightDistance(int Dv)
{
	RightDistance    = Dv;
}
//------------------------------------------------------------------------------------------
void CMultiLineDefect::SetEdgeThresHold(int ThHold)
{
	EThresHold    = ThHold;
}
//------------------------------------------------------------------------------------------
void CMultiLineDefect::SetCornerThresHold(int ThHold)
{
	ECThresHold    = ThHold;
}
//------------------------------------------------------------------------------------------
void CMultiLineDefect::SetLtpsThHold(int ThHold)
{
	LtpsThresHold = ThHold;
}
//------------------------------------------------------------------------------------------
void CMultiLineDefect::SetEnCapTopThHold(int ThHold)
{
	EnCapTopThresHold  = ThHold;
}
//------------------------------------------------------------------------------------------
void CMultiLineDefect::SetEnCapMidThHold(int ThHold)
{
	EnCapMidThresHold  = ThHold;
}
//------------------------------------------------------------------------------------------
void CMultiLineDefect::SetEnCapBtmThHold(int ThHold)
{
	EnCapBtmThresHold  = ThHold;
}
//------------------------------------------------------------------------------------------
void CMultiLineDefect::SetStartLine(int StartLine)
{
	FStartLine    = StartLine;
}
//------------------------------------------------------------------------------------------
void CMultiLineDefect::SetEndLine(int EndLine)
{
	FEndLine    = EndLine;
}
//------------------------------------------------------------------------------------------
void CMultiLineDefect::SetLTCornerWidth(int Width)
{
	LTCornerWidth    = Width;
}
//------------------------------------------------------------------------------------------
void CMultiLineDefect::SetLTCornerHeight(int Height)
{
	LTCornerHeight   = Height;
}
//------------------------------------------------------------------------------------------
void CMultiLineDefect::SetRTCornerWidth(int Width)
{
	RTCornerWidth    = Width;
}
//------------------------------------------------------------------------------------------
void CMultiLineDefect::SetRTCornerHeight(int Height)
{
	RTCornerHeight   = Height;
}
//------------------------------------------------------------------------------------------
void CMultiLineDefect::SetLBCornerWidth(int Width)
{
	LBCornerWidth    = Width;
}
//------------------------------------------------------------------------------------------
void CMultiLineDefect::SetLBCornerHeight(int Height)
{
	LBCornerHeight   = Height;
}
//------------------------------------------------------------------------------------------
void CMultiLineDefect::SetRBCornerWidth(int Width)
{
	RBCornerWidth    = Width;
}
//------------------------------------------------------------------------------------------
void CMultiLineDefect::SetRBCornerHeight(int Height)
{
	RBCornerHeight   = Height;
}
//------------------------------------------------------------------------------------------
void CMultiLineDefect::SetCornerWidth(int Width)
{
	CornerWidth    = Width;
}
//------------------------------------------------------------------------------------------
void CMultiLineDefect::SetCornerHeight(int Height)
{
	CornerHeight   = Height;
}
//------------------------------------------------------------------------------------------
void CMultiLineDefect::SetCrossLeftPoint(int x, int y)
{
    FP0.x = (float)x;
	FP0.y = (float)y;
	AlignMark1.x = FP0.x;
	AlignMark1.y = FP0.y;
}
//------------------------------------------------------------------------------------------
void CMultiLineDefect::SetCrossRightPoint(int x, int y)
{
    FP1.x =(float)x;
	FP1.y =(float)y;
	AlignMark2.x = FP1.x;
	AlignMark2.y = FP1.y;
}
//------------------------------------------------------------------------------------------
void CMultiLineDefect::SetSpecWidth(float MinWidth , float MaxWidth)
{
	FMinWidth = MinWidth;
	FMaxWidth = MaxWidth;
}
//------------------------------------------------------------------------------------------
void CMultiLineDefect::SetSpecHeight(float MinHeight, float MaxHeight)
{
	FMinHeight = MinHeight;
	FMaxHeight = MaxHeight;
}
//------------------------------------------------------------------------------------------
void CMultiLineDefect::SetCornerTop(bool IsEnable)
{
	IsCornerTop  = IsEnable;
}
//------------------------------------------------------------------------------------------
void CMultiLineDefect::SetCornerBtm(bool IsEnable)
{
	IsCornerBtm  = IsEnable;
}
//------------------------------------------------------------------------------------------
void CMultiLineDefect::SetRectTop(bool IsEnable)
{
	IsRectTop  = IsEnable;
}
//------------------------------------------------------------------------------------------
void CMultiLineDefect::SetRectBtm(bool IsEnable)
{
	IsRectBtm  = IsEnable;
}
//------------------------------------------------------------------------------------------
void CMultiLineDefect::SetCircleTop(bool IsEnable)
{
	IsCircleTop  = IsEnable;
}
//------------------------------------------------------------------------------------------
void CMultiLineDefect::SetCircleBtm(bool IsEnable)
{
	IsCircleBtm  = IsEnable;
}
//------------------------------------------------------------------------------------------
void CMultiLineDefect::SetNarrowTrench(bool IsEnable)
{
	IsNarrowTrench  = IsEnable;
}
//------------------------------------------------------------------------------------------
void CMultiLineDefect::SetBMLineThresHold(int ThHold)
{
	EBMLinThresHold    = ThHold;
}
//------------------------------------------------------------------------------------------
void CMultiLineDefect::SetBurrThresHold(int ThHold)
{
	BurrThresHold   = ThHold;
}
//------------------------------------------------------------------------------------------
void CMultiLineDefect::SetBrokenThresHold(int ThHold)
{
	BrokenThresHold    = ThHold;
}
//------------------------------------------------------------------------------------------
void CMultiLineDefect::SetCrackThresHold(int ThHold)
{
	CrackThresHold   = ThHold;
}
//------------------------------------------------------------------------------------------
void CMultiLineDefect::SetGrindThresHold(int ThHold)
{
	GrindThresHold   = ThHold;
}
//------------------------------------------------------------------------------------------
void CMultiLineDefect::SetBurrOffset(int Offset)
{
	BurrOffset    = Offset;
}
//------------------------------------------------------------------------------------------
void CMultiLineDefect::SetBmToMarkDistance(double Distance)
{
    BmToMarkDis = Distance;
}
//------------------------------------------------------------------------------------------
void CMultiLineDefect::SetMinBrokenWidth(float MinWidth)
{
    FBrokenMinWidth = MinWidth;
}
//------------------------------------------------------------------------------------------
void CMultiLineDefect::SetMinBrokenHeight(float MinHeight)
{
    FBrokenMinHeight = MinHeight;
}
//------------------------------------------------------------------------------------------
void CMultiLineDefect::SetMinBurrWidth(float MinWidth)
{
    FBurrMinWidth = MinWidth;
}
//------------------------------------------------------------------------------------------
void CMultiLineDefect::SetMinBurrHeight(float MinHeight)
{
    FBurrMinHeight = MinHeight;
}
//------------------------------------------------------------------------------------------
void CMultiLineDefect::SetMinChippingWidth(float MinWidth)
{
    FChippingMinWidth = MinWidth;
}
//------------------------------------------------------------------------------------------
void CMultiLineDefect::SetMinChippingHeight(float MinHeight)
{
    FChippingMinHeight = MinHeight;
}
//------------------------------------------------------------------------------------------
void CMultiLineDefect::SetIgnoreOffset(int Offset)
{
	IgnoreOffset  = Offset;
}
//------------------------------------------------------------------------------------------
void CMultiLineDefect::SetGrindDirection(int Dir)
{
	GrindOutIn  = Dir;
}
//------------------------------------------------------------------------------------------
void CMultiLineDefect::SetGrindInspection(int GrindInsp)
{
	GrindCheck = GrindInsp;
}
void CMultiLineDefect::SetInspRoiOffset(int Offset)
{
	InspOffset = Offset;
}
//------------------------------------------------------------------------------------------


//------------------------------------------------------------------------------------------
// 사용자 Get함수 
//------------------------------------------------------------------------------------------
int CMultiLineDefect::GetProcessMode()
{
	return FProcessMode;
}
//------------------------------------------------------------------------------------------
int CMultiLineDefect::GetShape()
{
	return FShape;
}
//------------------------------------------------------------------------------------------
TFPoint CMultiLineDefect::GetOrgP0()
{
	return FP0;
}
//------------------------------------------------------------------------------------------
TFPoint CMultiLineDefect::GetOrgP1()
{
	return FP1;
}
//------------------------------------------------------------------------------------------
CFind* CMultiLineDefect::GetFindPointer(int n)
{
	if     (n==0) return Find1;
	else if(n==1) return Find2;
	return NULL;
}
// JTrace* CMultiLineDefect::GetTracePointer()
// {
//     return Trace;
// }
//------------------------------------------------------------------------------------------
CEdge* CMultiLineDefect::GetEdgePointer()
{
    return Edge;
}
//------------------------------------------------------------------------------------------
int CMultiLineDefect::GetEscapeDeviation()
{
	return FEscapeDeviation;
}
//------------------------------------------------------------------------------------------
// 사용자 Result함수 
//------------------------------------------------------------------------------------------
int CMultiLineDefect::GetResultDefectPointCount()
{
	return DefectPointCount;
}
int CMultiLineDefect::GetResultACountPointCount()
{
	return ACount;
}
int CMultiLineDefect::GetResultBCountPointCount()
{
	return BCount;
}
int CMultiLineDefect::GetResultCCountPointCount()
{
	return CCount;
}
int CMultiLineDefect::GetResultDCountPointCount()
{
	return DCount;
}
int CMultiLineDefect::GetResultC1CountPointCount()
{
	return C1Count;
}
int CMultiLineDefect::GetResultC2CountPointCount()
{
	return C2Count;
}
int CMultiLineDefect::GetResultC3CountPointCount()
{
	return C3Count;
}
int CMultiLineDefect::GetResultC4CountPointCount()
{
	return C4Count;
}
int CMultiLineDefect::GetResultABurrPointCount()
{
	return ABurrCount;
}
int CMultiLineDefect::GetResultBBurrPointCount()
{
	return BBurrCount;
}
int CMultiLineDefect::GetResultCBurrPointCount()
{
	return CBurrCount;
}
int CMultiLineDefect::GetResultDBurrPointCount()
{
	return DBurrCount;
}
int CMultiLineDefect::GetResultCrackPointCount()
{
    return CrackCount;
}
int CMultiLineDefect::GetResultBrokenPointCount()
{
    return BrokenCount;
}
int CMultiLineDefect::GetResultBurrPointCount()
{
    return BurrCount;
}
int CMultiLineDefect::GetResultA1CirPointCount()
{
	return A1CirDeftectCnt;
}
int CMultiLineDefect::GetResultA2CirPointCount()
{
	return A2CirDeftectCnt;
}
int CMultiLineDefect::GetResultC1CirPointCount()
{
	return C1CirDeftectCnt;
}
int CMultiLineDefect::GetResultC2CirPointCount()
{
	return C2CirDeftectCnt;
}
int CMultiLineDefect::GetResultC3CirPointCount()
{
	return C3CirDeftectCnt;
}
int CMultiLineDefect::GetResultC4CirPointCount()
{
	return C4CirDeftectCnt;
}
int CMultiLineDefect::GetResultC5CirPointCount()
{
	return C5CirDeftectCnt;
}
int CMultiLineDefect::GetResultC6CirPointCount()
{
	return C6CirDeftectCnt;
}
int CMultiLineDefect::GetResultBtm3CirPointCount()
{
	return Btm3CirDefectCnt;
}


// Bright Defect 
int CMultiLineDefect::GetResultACrackPointCount()
{
	return ACrackCount;
}
int CMultiLineDefect::GetResultBCrackPointCount()
{
	return BCrackCount;
}
int CMultiLineDefect::GetResultCCrackPointCount()
{
	return CCrackCount;
}
int CMultiLineDefect::GetResultDCrackPointCount()
{
	return DCrackCount;
}
int CMultiLineDefect::GetResultA1CirCrackPointCount()
{
	return A1CirCrackCnt;
}
int CMultiLineDefect::GetResultA2CirCrackPointCount()
{
	return A2CirCrackCnt;
}
int CMultiLineDefect::GetResultC1CirCrackPointCount()
{
	return C1CirCrackCnt;
}
int CMultiLineDefect::GetResultC2CirCrackPointCount()
{
	return C2CirCrackCnt;
}
int CMultiLineDefect::GetResultC3CirCrackPointCount()
{
	return C3CirCrackCnt;
}
int CMultiLineDefect::GetResultC4CirCrackPointCount()
{
	return C4CirCrackCnt;
}
int CMultiLineDefect::GetResultC5CirCrackPointCount()
{
	return C5CirCrackCnt;
}
int CMultiLineDefect::GetResultC6CirCrackPointCount()
{
	return C6CirCrackCnt;
}
int CMultiLineDefect::GetResultBtm3CirCrackPointCount()
{
	return Btm3CirCrackCnt;
}

//------------------------------------------------------------------------------------------
// GOO 
TFPoint CMultiLineDefect::GetResultDefectPoint(int n)
{
	return FDefectPoint[n];
}
//------------------------------------------------------------------------------------------
TFPoint CMultiLineDefect::GetResultLTPoint()
{
	return FLTPoint ;
}
//------------------------------------------------------------------------------------------
TFPoint CMultiLineDefect::GetResultRTPoint()
{
	return FRTPoint ;
}
//------------------------------------------------------------------------------------------
TFPoint CMultiLineDefect::GetResultRBPoint()
{
	return FRBPoint ;
}
//------------------------------------------------------------------------------------------
TFPoint CMultiLineDefect::GetResultLBPoint()
{
	return FLBPoint ;
}
//------------------------------------------------------------------------------------------  
TFPoint CMultiLineDefect::GetResultLTLPoint()
{
	return FLTLPoint ;
}
//------------------------------------------------------------------------------------------
TFPoint CMultiLineDefect::GetResultLTTPoint()
{
	return FLTTPoint ;
}
//------------------------------------------------------------------------------------------
TFPoint CMultiLineDefect::GetResultRTRPoint()
{
	return FRTRPoint ;
}
//------------------------------------------------------------------------------------------
TFPoint CMultiLineDefect::GetResultRTTPoint()
{
	return FRTTPoint ;
}
//------------------------------------------------------------------------------------------
TFPoint CMultiLineDefect::GetResultRBRPoint()
{
	return FRBRPoint ;
}
//------------------------------------------------------------------------------------------
TFPoint CMultiLineDefect::GetResultRBBPoint()
{
	return FRBBPoint ;
}
//------------------------------------------------------------------------------------------
TFPoint CMultiLineDefect::GetResultLBLPoint()
{
	return FLBLPoint ;
}
//------------------------------------------------------------------------------------------
TFPoint CMultiLineDefect::GetResultLBBPoint()
{
	return FLBBPoint ;
}
//------------------------------------------------------------------------------------------
float CMultiLineDefect::GetResultDistanceFromLTLToLTT()
{
	return Math.GetLength(FLTLPoint, FLTTPoint);
}
//------------------------------------------------------------------------------------------
float CMultiLineDefect::GetResultDistanceFromRTRToRTT()
{
	return Math.GetLength(FRTRPoint, FRTTPoint);
}
//------------------------------------------------------------------------------------------
float CMultiLineDefect::GetResultDistanceFromRBRToRBB()
{
	return Math.GetLength(FRBRPoint, FRBBPoint);
}
//------------------------------------------------------------------------------------------
float CMultiLineDefect::GetResultDistanceFromLBLToLBB()
{
	return Math.GetLength(FLBLPoint, FLBBPoint);
}
//------------------------------------------------------------------------------------------
double CMultiLineDefect::GetResultC1DisX()
{
	return Math.GetLength(FLTPoint,FLTTPoint);
}
//------------------------------------------------------------------------------------------
double CMultiLineDefect::GetResultC1DisY()
{
	return Math.GetLength(FLTPoint,FLTLPoint);
}
//------------------------------------------------------------------------------------------
double CMultiLineDefect::GetResultC2DisX()
{
	return Math.GetLength(FRTPoint,FRTTPoint);
}
//------------------------------------------------------------------------------------------
double CMultiLineDefect::GetResultC2DisY()
{
	return Math.GetLength(FRTPoint,FRTRPoint);
}
//------------------------------------------------------------------------------------------
double CMultiLineDefect::GetResultC3DisX()
{
	return Math.GetLength(FLBPoint,FLBBPoint);
}
//------------------------------------------------------------------------------------------
double CMultiLineDefect::GetResultC3DisY()
{
	return Math.GetLength(FLBPoint,FLBLPoint);
}
//------------------------------------------------------------------------------------------
double CMultiLineDefect::GetResultC4DisX()
{
	return Math.GetLength(FRBPoint,FRBBPoint);
}
//------------------------------------------------------------------------------------------
double CMultiLineDefect::GetResultC4DisY()
{
	return Math.GetLength(FRBPoint,FRBRPoint);
}
//------------------------------------------------------------------------------------------
double CMultiLineDefect::GetResultSizeH()
{
	TShape Mode;
	Mode =shRectC;
	if(Mode!=shRectC) return false ;
	return Math.GetLength(FLTPoint,FLBPoint);
}
//------------------------------------------------------------------------------------------
double CMultiLineDefect::GetResultSizeW()
{
	return Math.GetLength(FLTPoint,FRTPoint);
}
//------------------------------------------------------------------------------------------

void CMultiLineDefect::Train(int n, BYTE* pImg, int imgW, int imgH, int roi_x, int roi_y, int roi_w, int roi_h)
{
	if (n > 1) return;

	if (n == 0)
	{
		Find1->GImage->SetImagePtr(imgW, imgH, pImg);
		Find1->TRoi->SetOrgX(roi_x);
		Find1->TRoi->SetOrgY(roi_y);
		Find1->TRoi->SetWidth(roi_w);
		Find1->TRoi->SetHeight(roi_h);
		Find1->OnExecute();
	}
	else
	{
		Find2->GImage->SetImagePtr(imgW, imgH, pImg);
		Find2->TRoi->SetOrgX(roi_x);
		Find2->TRoi->SetOrgY(roi_y);
		Find2->TRoi->SetWidth(roi_w);
		Find2->TRoi->SetHeight(roi_h);
		Find2->OnExecute();
	}
}






